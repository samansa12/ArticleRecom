powerlist structure parallel recursion many dataparallel algorithmsfast fourier transform batchers sorting schemes prefixsumexhibit recursive structure propose data structure called powerlist permits succinct descriptions algorithms highlighting roles parallelism recursion simple algebraic properties data structure explotied derive properties algorithms establish equivalence different algorithms solve problem b program grant 003658219 national science foundation award ccr 9111912 1 notable exception recursive description prefix sum algorithm karp ramachandran12 data structure powerlist proposed paper highlights role parallelism recursion many known parallel algorithms fft batcher merge prefix sum embedding arrays hypercubes etchave surprisingly concise descriptions using powerlists simple algebraic properties powerlists permit us deduce properties algorithms employing structural induction powerlist basic data structure recursion employed lisp16 ml17 list list either empty constructed concatenating element list restrict finite lists throughout paper call list linear list length grows 1 result applying basic constructor list structure seems unsuitable expressing parallel algorithms succinctly algorithm processes list elements describe successive elements list processed propose powerlist data structure suitable describing parallel algorithms basecorresponding empty list linear caseis list one element clearly many bases depending specific element list larger powerlist constructed elements two powerlists length described thus powerlist multiplicative nature length doubles applying basic constructor two different ways powerlists joined create larger powerlist p q powerlists length powerlist formed concatenating p q q powerlist formed successively taking alternate items p q starting p restrict p q contain similar elements defined section 21 following examples sequence elements powerlist enclosed within angular brackets operation j called tie zip 21 definitions data item linear list theory called scalar typical scalars items base typesinteger boolean etctuples scalars functions scalars scalars linear lists scalars scalars uninterpreted theory merely assume scalars checked type compatibility use several standard operations scalars purposes illustration notational convention linear lists enclosed within square brackets powerlist list length 2 n n whose elements similar enclose powerlists within angular brackets h two scalars similar type two powerlists similar length element one similar element observe similar equivalence relation let denote arbitrary scalar p powerlist u v similar powerlists recursive definition powerlist hsi hp u j v u v examples h2i powerlist length 1 containing scalar hh2ii powerlist length 1 containing powerlist length 1 scalar h powerlist powerlist length 1 containing empty linear list powerlist length 2 element powerlist length 2 whose elements linear lists numbers representation matrix column element outer powerlist another representation matrix row element outer powerlist hhhai hbii hhci hdiii representation tree figure 1 powerlist contains two elements one left right subtrees 22 functions powerlists convention write function application without parantheses confusion possible thus write f x instead fx g x instead gx constructors j binding power binding power lower function application throughout paper denotes scalar p powerlist x either scalar powerlist typical names powerlist variables p q hhci hdii hhhai hbii hhci hdiii hhai hbii figure 1 representation complete binary tree data leaves leaf nodes powerlist one element nonleaf nodes powerlist two elements namely powerlists left right subtrees functions linear lists typically defined case analysisa function defined empty list recursively nonempty lists functions powerlists defined analogously instance following function rev reverses order elements argument powerlist case analysis linear lists based length argument powerlist adopt pattern matching scheme ml17 miranda24 2 deconstruct argument list components p q recursive case deconstruction general uses operators j see section 3 definition rev used j deconstruction could used instead defined rev recursive case shown using laws section 3 two proposed definitions rev equivalent powerlist p scalar functions operations scalars outside theory examples paper however use scalar functions particularly addition multiplication complex numbers cons linear lists scalar function f zero scalars arguments value scalar coerce application f powerlist applying f pointwise elements powerlist scalar function f one argument define 2 miranda trademark research software ltd shown scalar function operates two arguments often written infix operator function phi p q phi u thus scalar functions commute j note since scalar function applied recursively element pow erlist effect propagates levels thus applied matrices forms elementwise sum 2 23 discussion base case powerlist singleton list empty list empty lists equivalent data structures arise applications considered instance matrix algorithms base case 1 theta 1 matrix rather empty matrix fourier transform defined singleton list empty list smallest hypercube one node recursive definition powerlist says powerlist either form u v u j v fact every nonsingleton powerlist written either form unique manner see laws section 3 simple way view elements l indexed nbit strings increasing numerical order length l sublist elements whose highest bit index 0 q sublist 1 highest bit index similarly u u sublist elements whose lowest bit index 0 vs elements 1 lowest bit index first may seem strange allow two different ways constructing listusing tie zip see paper causes difficulty flexibility essential many parallel algorithmsthe fast fourier transform prominentexploit forms construction restricted u v u j v u v similar restriction allows us process powerlist recursive divide conquer division yields two halves processed parallel employing algorithm square matrices instance often processed quarter ing show quartering quadrupling expressed theory similarity restriction allows us define complete binary trees hypercubes square matrices free structures length powerlist power 2 restricts theory somewhat possible design general theory eliminating constraint sketch outline section 6 l0 singleton powerlists hxi hyi l1 dual deconstruction nonsingleton powerlist p exist similar powerlists u v l2 unique deconstruction p l3 commutativity j laws derived suitably defining tie zip using standard functions linear list theory one possible strategy define tie concatenation two equal length lists use laws l0 l3 definition zip laws l1 l2 derived next alternatively laws may regarded axioms relating tie zip law l0 often used proving base cases algebraic identities laws l1 l2 allow us uniquely deconstruct nonsingleton powerlist using either j law l3 crucial law relating two construction operators j general case hence invariably applied proofs structural induction constructors play role inductive proofs proofs powerlists induction length depth shape list length len powerlist number elements since length powerlist power 2 logarithmic length lgl useful measure formally depth powerlist number levels depth depth depth last case since u v similar powerlists depth inductive proofs powerlists order lexicographically pair depth logarithmic length instance prove property pi holds powerlists sufficient prove pihsi last proof step could replaced shape powerlist p sequence natural numbers depth p n 0 logarithmic length p 1 logarithmic length element p say r 2 logarithmic length element formal definition shape similar depth shape linear sequence elements level similar shape type scalar elements define structure powerlist completely inductive proofs powerlists may ordered lexicographically pair depth shape shapes compared lexicographically show small algorithms powerlists include famous examples fast fourier transform batcher sorting networks restrict discussion section simple unnested powerlists depth 0 higher dimensional lists algorithms matrices hypercubes taken later section since powerlists unnested induction based length sufficient prove properties algorithms 41 permutations define functions permute elements powerlists function rev defined section 22 permutation function functions appear components many parallel algorithms rotate function rr rotates powerlist right one thus rrha b c di hd b ci function rl rotates left rlha b c di hb c ai seem simple definition rr rl using j deconstruction operator easy show using structural induction rrrl inverses amusing identity revrrrevrr p powerlist may rotated arbitrary amount k applying successive rotations better scheme rotating u v k rotate u v k2 precisely function grr given rotates powerlist right k k 0 straightforward show k k 0 p grr k kfold application rr rotate index class permutation functions defined transformations element indices imagine element powerlist 2 n elements associated nbit index indices increasing numerical order powerlist u j v indices elements u 0 highest bit v 1 highest bit u v similar remarks apply lowest bit bijection h mapping indices indices defines permutation powerlist element index moved position index h consider two simple index mapping functions corresponding permutations powerlists useful describing shuffleexchange network note indices part theory function rotates index right one position permutation function rs right shuffle associated definition rs may understood follows effect rotating index right lowest bit index becomes highest bit therefore rs applied u v elements uthose 0 lowest bit occupy first half resulting powerlist indices 0 highest bit rotation similarly v occupy second half analogously function rotates index left one position induces permutation defined ls left shuffle figure 2 shows effects index rotations 8element list rs ls figure 2 permutation functions rs ls defined section 41 trivial see rs ls inverses inversion function inv defined following function indices element index b p index b 0 inv p b 0 reversal bit string b thus 000 001 010 011 100 101 110 111 inv h b c e f g h h e c g b f h definition inv function arises variety contexts particular inv used permute output fast fourier transform network correct order following proof shows typical application structural induction inv1 invp structural induction p q base ffrom fdefinition invg applying law l0g induction fcommutativity j g fdefinition invg invr u invs v finductiong inv r inv j inv u inv v fapply definition inv sides j g using inv1 structural induction easy establish scalar operator phi last result holds permutation function place inv 42 reduction linear list theory4 reduction higher order function two argu ments associative binary operator list reduction applied phi 0 function powerlists defined red phi red phi p j red phi p phi red phi q 43 gray code gray code sequence n sequence 2 n nbit strings consecutive strings sequence differ exactly one bit position last first strings sequence considered consecutive standard gray code sequences shown figure 3 represent nbit figure 3 standard gray code sequence n strings linear lists length n gray code sequence powerlist whose elements linear lists standard gray code sequence may computed function g n 0 scalar function takes linear list argument appends 0 prefix according coercion rule powerlist obtained prefixing every element p 0 similarly function rev section 22 44 polynomial polynomial coefficients may represented powerlist p whose j th element p j polynomial value point n 0 quantity following function ep uses strategy evaluate polynomial p given point hwi singleton powerlist ep returns singleton powerlist p q note w 2 pointwise squaring w theta higher prioroty anticipation fast fourier transform generalize ep accept arbitrary powerlist second argument powerlists possibly unequal length let p ep w powerlist length w obtained evaluating p element w definition ep given also implements generalization since ep applies pointwise element 45 fast fourier transform polynomial p complex coeeficients fourier transform obtained evaluating p certain specific points precisely fourier transform ft powerlist p powerlist length given ep function defdined section 44 n logarithmic length wn powerlist h 2 n th principal root 1 straightforward computation p ep v p v consists evaluating p element v takes time since wn special form fourier transform computed om log steps using fast fourier transform algorithm8 algorithm also admits efficient implemntation requiring olog steps om processors derive fft algorithm need following two properties wn n n 0 powerlist u first equation follws fact right half wn 1 left half multiplied 2 n since 2 n1 th principal root 1 gamma1 second equation straightforward since wn powerlist containing successive powers number fdefinition ftg fsince w0 singleton definition epg general case ft p q flet n logarithmic length p definition ftg p q ffrom 1 let fdistribute ep second argumentg fdefinition epg fusing 2 replace u 2 wn g fdefinition ftg get formal definition fft write powers p powerlist h length p 2m th principal root 1 therefore u powers p functions powers defined similarly ep collecting definitions fft p clear fft p q computed fft p fft q om sequential steps o1 parallel steps using om processors u computed parallel length p therefore fft p q computed om log sequential steps olog parallel steps using om processors compactness description fft striking contrast usual descriptions see instance chandy misra7 section 613 compactness attributed use recursion avoidance explicit indexing elements employing j fft illustrates need including j constructors powerlists another function employs j inv section 41 inverse fourier transform inverse fourier transform ift defined similarly fft fact definition ift derived fft pattern matching singleton powerlist hxi compute ift fift fft inversesg general case compute ift p j q p q let unknowns u v forms deconstructions chosen easily solve equations generate next taking fft sides left side p j q ift fft inverses replacing right side definition fft u v yields following equations equations easily solved unknowns u v w u v note law unique deconstruction l2 used deduce first equation solutions equations yield following definition ift 2 divides element given powerlist 2 n th principal root 1 n length p j q fft definition ift includes constructors j implemented efficiently butterfly network complexity ift fft 46 batcher sorting networks section develop elementary results sorting discuss two remarkable sorting methods due batcher3 find interesting preferred operator discussing principles parallel sorting henceforth list sorted means elements arranged ascending order general method sorting given merge written binary infix operator creates single sorted powerlist elments two argument powerlists section show two different methods implementing merge one scheme batcher merge given operator bm another scheme given bitonic sort sorted lists p q merged applying function bi p j rev q comparison operator l used algorithms operator applied pair powerlists defined 2i th 2i th items p l q p min respectively expression p l q computed constant time using olen p processors bitonic sort sequence numbers x index ascending descending monotonic function bi given applied bitonic pow erlist returns sorted powerlist original items two powerlists u v sorted ascending order powerlist u j rev v bitonic thus u v merged applying bi u j rev v form recursive definition suggests bi implemented processors olog n parallel steps n length argument powerlist batcher merge batcher also proposed scheme merging two sorted lists define scheme bm infix operator function bm well suited parallel implementation recursive form suggests r bm v bm u computed parallel since l applied o1 parallel steps using processors n length argument powerlists function bm evaluated olog n parallel steps rest section develop certain elementary facts sorting prove correctness bm elementary facts sorting consider compare swap type sorting methods known see knuth13 sorting scheme correct iff sorts lists containing 0s 1s therefore restrict discussion powerlists containing 0s 1s powerlist p let z p number 0s simplify notation omit space write zp clearly powerlists containing 0s 1s following properties note condition analogous a2 p j q sorted simplicity a2 compared a2 0 may suggest primary operator parallel sorting 2 following results b1 b2 easy prove prove b3 b2 zp l b3 proof since statement theorem symmetric p q assume zp zq p min q p max q sorted fdefinition p l qg l q sorted 2 correctness bitonic sort show function bi applied bitonic powerlist returns sorted powerlist original elements b4 states bi preserves number zeroes argument list ie loses data b5 states resulting list sorted b4 zbi proof structural induction using b2 2 b5 proof structural induction base straightforward induction let finduction p qg ffrom b4 zbi fapply b3 bi p bi q bi p l bi q sorted fdefinition big correctness batcher merge show bm merges two sorted powerlists manner similar proof bi instead establish simple relationship functions bm bi correctness former obvious show rev reverses powerlist section 22 p q sorted p j rev q bitonic fact dont prove correctness bi follows bip j rev q hence bm q sorted contains elements p q proof b6 structural induction base let fdefinition revg fdefinition big fdefinition bmg induction let fexpanding fdefinition revg fdefinition big finductiong r bm v l bm u fdefinition bmg fusing definitions p qg compactness description batchers sorting schemes simplicity correctness proofs demonstrate importance treating recursion parallelism simultaneously ffl7 ffl6 ffl5 ffl4 ffl3 ffl2 ffl1 ffl7 ffl6 ffl5 ffl4 ffl3 ffl2 ffl1 ffl7 ffl6 ffl5 ffl4 ffl3 ffl2 ffl1 ffl7 ffl6 ffl5 ffl4 ffl3 ffl2 ffl1 level 3 level 2 level 1 level 0 ffl0 ffl0 ffl0 ffl0 figure 4 network compute prefix sum 8 elements 47 prefix sum let l powerlist scalars phi binary associative operator scalar type prefix sum l respect phi ps l list length l given ps th element ps l obtained applying phi first elements l order give formal definition prefix sum later section prefix sum fundamental importance parallel computing show two known algorithms problem concisely represented proved theory zip turns primary operator describing algorithms particularly simple scheme prefix sum 8 elements shown figure 4 figure numbered nodes represent processors though physical processors used levels initially processor holds list element l connections among processors different levels depict data transmissions level 0 processor 0 6 sends data right neighbor th level processor sends data processor exists means receives data level data transmission processor updates data r phi r data receives receives data level unchanged shown completion computation level log 2 len l processor holds th element ps l another scheme due ladner fischer15 first applies phi adjacent elements compute list hx 0 phi x list half many elements original list prefix sum computed recursively resulting list hx 0 phi x list contains half elements final list missing elements elements computed appropriately elements already computed list schemes prefix computation inherently recursive formulations highlight parallelism recursion specification sorting networks section 46 introduce operator terms prefix sum problem defined first postulate 0 identity element phi ie 0 phi x powerlist p let powerlist obtained shifting p right one effect shifting append 0 left discard rightmost element p thus ha b c di p q easy show s1 r phi s2 p q consider following equation powerlist variable z l given powerlist equation unique solution z di exactly ps l define ps l unique solution de call de defining equation ps l notes 1 operator phi necessarily commutative therefore rhs de may l phi z 2 operator phi scalar commutes 3 uniqueness solution de proved entirely within powerlist algebra similar derivation ladnerfischer scheme given later section 4 adams1 specified prefixsum problem without postulating explicit 0 element phi introduces binary operator phi two similar powerlists p phi q operator phi defined without introducing 0 computation prefix sum function sps simple prefix sum defines scheme figure 4 sps sps first level figure 4 l phi l computed hx zip two sublists prefix sums two lists computed independently zipped ladnerfischer scheme defined function lf lf p correctness prove correctness sps lf showing function ps satisfies equations defining functions instructive see sps lf derived easily specification de carry derivation fischerladner scheme illustration power algebraic manipulations first note p1 proof pshxi ffrom defining equation de pshxig fdefinition g fphi scalar operationg f0 identity phig derivation ladnerfischer scheme given powerlist p q derive expression psp q let r unknowns psp q solve ps p q using deg applying law l2 unique deconstruction equation conclude lf1 eliminate r lf2 using lf1 get using de equation get compute psp q psp q fby definitiong using lf1 rg defined lf3 exactly definition function lf nonsingleton powerlist also note r eliminating lf1 using lf2 g r phi q phi p definition g r phi q phi p using de equation lf4 fact used proving correctness sps next correctness sps show nonsingleton powerlist l ps proof let ps l psp q given lf4lf3g psq phi p psp phi q fletting ps u ps v show u q phi p p phi q q p phi p q fapply definition first termg p q phi p q remarks traditional way describing prefix sum algorithm simple scheme figure 4 explicitly name quantities com puted establish relationships among let ij computed th processor j th level logarithmic length list ae igamma2 oe correctness criterion description considerably difficult manipulate parallelism harder see proof correctness requires manipulations indices example show ladnerfischer scheme even difficult specify manner algebraic methods preferred describing uniform operations aggregates data 5 higher dimensional arrays major part parallel computing involves arrays one dimensions array dimensions dimensions numbered 0 represented powerlist depth gamma 1 conversely since powerlist elements similar powerlist depth may regarded array dimension instance matrix r rows c columns may represented powerlist c elements element powerlist length r storing items column conversely matrix may represented powerlist r elements element powerlist c elements manipulating higher dimensional arrays prefer think terms array operations rather operations nested powerlists therefore introduce construction operators analogous j tie zip along specified dimension use corresponding operators dimension dimension 2 etc definitions operators section 52 moment sufficient regard j 0 pointwise application j argument powerlists similarly 0 thus similar power matrices b stored columnwise ie element column j b concatenation b rows j 0 b concatenation columns figure 5 shows applications operators specific matrices given constructors may define matrix either figure 5 applying matrices matrices stored columns typical matrix format used display though matrix regarded powerlist powerlists singleton matrix hhxii similar matrices matrices analogous definitions given ndimensional arrays observe length dimension power 2 case pow erlist matrix constructed several different ways say first constructing rows columns vice versa show section 52 note could defined matrix using 0 instead j j duals sense either used construct uniquely deconstruct powerlist j 0 0 also duals show section 52 therefore freely use four construction operators matrices 2 example matrix transposition let function transposes matrices definition matrix consider three cases defining description function though straightforward introduced possibility inconsistent definition 2 theta 2 matrix instance either last two deconstructions apply obvious result obtained independent order rules applied show function prove result structural induction matrix form hhxii first deconstruction applies hence claim holds next consider matrix last two deconstructions apply matrix form p j applying one step last two rules different order get fapplying last ruleg fapplying middle ruleg fapplying first middle rule last ruleg induction hypothesis p q etc well defined hence crucial proof fact j j 0 commute reminiscent churchrosser property term rewriting systems commutativity important discuss next subsection easy show transposition square power matrix defined deconstructing matrix quarters transposing individually rearranging shown figure 6 transposition function general matrices get function oe transpositions square matrices note effectiveness pattern matching definition oe q oe v oe u oe figure schematic transposition square powermatrix 51 pointwise application let g function mapping items type ff type fi g 0 maps powerlist ffitems powerlist fiitems similarly binary operator op defined two forms explicitly use one examples f 0 function f arbitrary arity similarly defined observe f 0 applied powerlist length n yields powerlist length n number primes f determines dimension f applied outermost dimension numbered 0 therefore writing instance without primes simply zips two lists operator pointwise application also appears backus2 steele hillis23 common special cases binary operator op j pointwise application operators particular writing denote z define definition f 0 conclude f 0 j commute prove f 0 commutes theorem 1 f proof prove result unary f general case similar proof structural induction base f 0 hxi hyi fdefinition f 0 g singleton listsg induction argument commuteg finductiong theorem 2 scalar function f f proof proof structural induction straightforward 2 theorem 3 f g commute f proof structural induction 2 following results commutativity derived theorems 123 following mn natural numbers c1 f n c2 6 n c3 c4 scalar function f c1 follows applying induction theorems 1 3 fact f commute c2 follows c1 c3 c1 law l3 theorem 3 c4 c1 theorem 2 52 deconstruction section show powerlist written p q also written u v u v vice versa analogous law l1 dual deconstruction analogous law l2 show deconstructions unique theorem 4 dual deconstruction p q 0 defined exist u v conversely u v 0 u v defined exist q prove theorem proof similar theorem given theorem 5 unique letomega j natural number proof proof induction result follows law l2 proof similar prove result structural induction p base fdefinition j n1 g using law l2g j finduction ng fdefinition j n1 g using law l2g j finduction length theorems 4 5 allow richer variety pattern matching function def initions matrix transposition may employ natural mn construct pattern function defined 53 embedding arrays hypercubes ndimensional hypercube graph 2 n nodes n 0 node unique nbit label two nodes neighbors ie edge exactly labels differ single bit therefore every node n neighbors may represent ndimensional hypercube powerlist depth n level except innermost consists two powerlists natural mn used access nodes one combination dimensions conclude example shows higher dimensional structures hypercubes easily handled theory given array size claim elements placed nodes hypercube dimension 0 1 two adjacent data items array placed neighboring nodes hypercube two data items array adjacent indices differ exactly one dimension 1 modulo n n size dimension called wrap around adjacency embedding algorithm works follows array one dimension create gray code sequence g see section 43 abbreviate g g place th item array node label g adjacent items positions placed nodes g g i1 differ exactly one bit construction idea generalized higher dimensional arrays follows construct gray code sequences dimension independently store item index node g 0 denotes concatenations bit strings definition adjacent items differ 1 exactly one dimension k gray code indices identical dimensions except k differ exactly one bit dimension k describe function em embeds array hypercube given array size 2 m0 theta2 m1 theta2 md permutes elements array 2 theta 2 theta permutation preserves array adjacency de scribed algorithm inspired gray code function section 43 following matches scalar p powerlist em p first line rule embedding single item 0dimensional hypercube next line simply says array length 1 dimension embedded ignoring dimension last line says nonsingleton array embedded embedding left half dimension 0 reverse right half two component hypercubes larger hypercube 6 remarks related work applying uniform operations aggregates data proved extremely powerful apl9 see backus2 bird4 algebras operators one earliest attempts representing data parallel algorithms preparata vuillemin21 words algorithm performs sequence basic operations pairs data successively 2 locations apart algorithm operating 2 n pieces data described sequence n parallel steps form k th step applies parallel binary operation oper pairs data 2 n gammak apart show paradigm used describe large number known parallel algorithms algorithm efficiently implemented cube connected cycle connection structure style programming imperative easy apply algebraic manipulations programs programming paradigm fits well within notation mou hudak19 mou20 propose functional notation describe divide conquertype parallel algorithms notation vast improvement preparata vuillemins changing imperative style functional style programming allows succinct expressions possibility algebraic manipulations effectiveness programming style scientific problem may seen 25 constructs similar tie zip though allow unbalanced decompositions lists effective method programming vectors proposed blelloch5 6 proposes small set vectorscan instructions may used primitives describing parallel algorithms unlike method able control division list number iterations depending values data items necessary ingredient many scientific problems jones sheeran10 developed relational algebra describing circuit components circuit component viewed relation operators combining relations given appropriate interpretations circuit domain kapur subramaniam11 implemented powerlist notation proved many alogrithms paper using inductive theorem prover called rrl rewrite rule laboratory based equality reasoning rewrite rules extending theorem prover similarity constraints powerlist constructors stated explicitly one fundamental problems powerlist notation devise compilation strategies mapping programs written powerlist notation specific architectures architecture closest conceptually hypercube kornerup14 developed certain strategies whereby parallel step program mapped constant number local operations communications hypercube node combinational circuit verification area powerlist notation may fruitfully employed adams1 proved correctness adder circuits using notation ripplecarry adder typically easy describe prove whereas carrylookahead adder much difficult adams described circuits notation proved equivalence remarkably concise fashion obtains succinct description carrylookahead circuit employing prefixsum function see section 47 powerlists arbitrary length lengths powerlists restricted form 2 n n 0 could develop simple theory handling arbitrary length lists steele 22 suggests padding enough dummy elements list make length power 2 scheme advantage still retain simple algebraic laws powerlist another approach based observation positive integer either 1 2 theta 2 theta 1 positive integer therefore deconstruct nonsingleton list odd length two lists p q element e e either first middle last element instance following function rev reverses list last line definition applies nonsingleton list odd length list deconstructed two lists p q equal length e middle element abused notation applying j three arguments similarly function lf prefix sum may defined lf p last line e first element argument list remaining portion list without first item deconstructed p q right side line denotes list obtained appending element e list obtained applying ephi element lfp q used convention e phi list obtained applying ephi element interplay sequential parallel computations notation proposed paper addresses small aspect parallel computing powerlists proved surprisingly successful expressing computations whose structures independent specific data val ues case instance fast fourier transform batcher merge prefix sum typically however parallel sequential computations interleaved fast fourier transform batcher merge represent highly parallel computations binary search inherently sequential parallel search strategies gaussian elimination represents mixture computation consists sequence pivoting steps step applied parallel thus parallel computations may performed certain sequence sequence may depend data values computa tion general methods blelloch5 required powerlist notation integrated language supports sequential computation particular notation blends well ml17 lisp16 23 mixture linear lists powerlists exploit various combinations sequential parallel computing powerlist consisting linear lists components admits parallel processing component processed sequentially linear list whose elements powerlists suggests sequential computation step applied parallel powerlists powerlists allow multidimensional parallel computations whereas linear list linear lists may represent hierarchy sequential computations acknowledgement paper enriched comments suggestions adams al carruth suggested term powerlist jorge cobb edsger w dijkstra car hoare rajeev joshi markus kaltenbach deepak kapur jacob kornerup scott page vijaya ramachandran guy steele jr alex tomlinson evelyn tumlin ernie cohen singularly helpful early stage research grateful austin tuesday afternoon read commented draft manuscript adams kornerup especially comments second draft r verifying adder circuits using powerlists programming liberated von neumann style sorting networks applications lectures constructive functional programming vector models dataparallel computing nesl nested dataparallel language parallel program design foun dation algorithm machine calculation complex fourier series programming language circuit design ruby automated reasoning parallel algorithms using powerlists parallel algorithms shared memory machines sorting searching mapping powerlists onto hypercubes parallel prefix computation definition standard ml structure parallel recursion preliminary version algebraic model divideandconquer algorithms parallelism divacon parallel language scientific computing based divideandconquer cubeconnected cycles versatile network parallel computation steele jr steele jr overview miranda divideandconquer method solving tridiagonal systems hypercube massively parallel computers tr overview miranda parallel program design foundation definition standard ml vector models dataparallel computing parallel algorithms sharedmemory machines introduction parallel algorithms architectures powerlist connection machine lisp parallel prefix computation cubeconnected cycles versatile network parallel computation programming liberated von neumann style nesl nested dataparallel language version 26 verifying adder circuits using powerlists ctr jayadev misra derivation parallel string matching algorithm information processing letters v85 n5 p255260 march georg ch pflug ladislav halada note recursive parallel structure birge qi factorization tree structured linear programs computational optimization applications v24 n23 p251265 februarymarch gorlatch programming divideandconquer skeletons case study fft journal supercomputing v12 n12 p8597 janfeb 1998 ruben gamboa correctness fast fourier transform structured proof acl2 formal methods system design v20 n1 p91106 january 2002 ross paterson new notation arrows acm sigplan notices v36 n10 october 2001 jeanlouis giavitto olivier michel declarative definition group indexed data structures approximation domains proceedings 3rd acm sigplan international conference principles practice declarative programming p150161 september 0507 2001 florence italy christoph herrmann christian lengauer parallelization divideandconquer translation nested loops journal functional programming v9 n3 p279310 may 1999 roberto di cosmo zheng li susanna pelagatti calculus parallel computations multidimensional dense arrays computer languages systems structures v33 n34 p82110 october 2007 gorlatch sat programming methodology skeletons collective operations patterns skeletons parallel distributed computing springerverlag london
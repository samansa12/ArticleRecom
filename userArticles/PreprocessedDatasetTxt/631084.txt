provable improvements branch testing paper compares faultdetecting ability several software test data adequacy criteria previously shown csub 1 properly covers csub 2 csub 1 guaranteed better detecting faults csub 2 following sense test suite selected independent random selection one test case subdomain induced csub 1 least likely detect fault test suite similarly selected using csub 2 contrast csub 1 subsumes properly cover csub 2 necessarily case results used compare number criteria including several proposed stronger alternatives branch testing compare relative faultdetecting ability data flow testing mutation testing conditioncoverage techniques branch testing showing criteria examined guaranteed better branch testing according two probabilistic measures also show criteria sometimes poorer detecting faults substantially less expensive criteria b introduction although large number software testing techniques proposed last two decades surprisingly little concrete information effectively detect faults true case theoretical analyses authors address computer science dept polytechnic university 6 metrotech brooklyn ny 11201 supported part nsf grant ccr9206910 new york state science technology foundation center advanced technology program authors address computer science dept courant institute mathematical sciences new york university 251 mercer street new york ny 10012 supported part nsf grant ccr8920701 nasa grant nag11238 empirical studies fact even generally agreedupon notions means one testing strategy effective another previous comparisons software testing criteria based subsumes relation criterion c 1 subsumes criterion c 2 every program p every test suite satisfies c 1 also satisfies c 2 unfortunately clear fact us relative effectiveness weiss argued subsumption useful comparing cost criteria effectiveness 22 hamlet 13 pointed possible c 1 subsume c 2 yet test suite satisfies c 2 detect fault test suite satisfies c 1 weyuker weiss hamlet 24 investigated limitations subsumption relations nature including gourlays power relation 12 newly proposed relation better relation contrast approach probabilistic based fact given program specification criterion typically large number test suites satisfy given test data adequacy criterion often suites detect fault others reason compare adequacy criteria comparing likelihood detecting fault expected number faults detected test suites criterion selected particular way allows us compare existing criteria concrete way also corresponds reasonable intuitive notion means one criterion better detecting faults another 8 10 explored conditions one adequacy criterion guaranteed least good another according certain probabilistic measure fault detecting ability analysis based investigating software testing criteria divide programs input domain subsets subdomains showed possible c 1 subsume c 2 yet c 2 better detecting faults according measure simple example illustrates happen assume domain program p f0 1 2g 0 input p fails assume selection test case subdomain f0 1g test case subdomain f2g c 2 requires selection test case subdomain f0 1g test case subdomain f0 2g since every test suite satisfies c 1 also selecting one test case subdomain yields two possible test suites f0 2g f1 2g one cause p fail four possible c 2 adequate test suites f0 0g f0 2g f1 0g f1 2g three cause p fail thus test suite selected satisfy c 2 likely detect fault one selected satisfy c 1 situation occurred input caused failure member subdomains c 2 member one subdomain c 1 furthermore overlapping subdomains common occurrence software testing testing criteria defined literature give rise overlapping subdomains often even simple programs thus examples illustrate phenomenon mere theoretical curiosity one occurs real testing criteria real programs response type problem introduced stronger relation criteria properly covers relation proved c 1 properly covers c 2 one test case independently randomly selected subdomain using uniform distribution probability c 1 detect least one fault greater equal probability c 2 detect fault 8 10 powerful result provided model testing used reasonable model reality address issue section 21 show c 1 properly covers c 2 programs class p guaranteed c 1 least good c 2 sense testing program p p regardless particular faults occur p hand properly cover c 2 program p even c 1 subsumes c 2 c 2 may likely c 1 detect bug p paper use result explore relative faultdetecting ability several wellknown testing techniques also introduce another measure faultdetecting ability show c 1 properly covers c 2 c 1 also least good c 2 according new measure three families techniques widely investigated data flow testing mutation testing conditioncoverage techniques compare relative fault detecting ability criteria families branch testing showing criteria examined guaranteed better branch testing according probabilistic measures mentioned criteria sometimes poorer detecting faults substantially less expensive criteria background terminology multiset collection objects duplicates may occur formally mapping set objects nonnegative integers indicating number occurrences object shall delimit multisets curly braces use settheoretic operator symbols denote corresponding multiset operators throughout multiset 1 submultiset multiset 2 must least many copies element 1 2 1 sequel say procedure applied element multiset procedure applied exactly n times e 1 e 2 etc without regard whether e input domain program set possible inputs restrict attention programs finite input domains place bound input domain size since real programs run machines finite word sizes finite amounts memory unrealistic restriction test suite multiset test cases element input domain investigate test suites rather test sets easier practice allow occasional duplication test cases check duplicates eliminate test data adequacy criterion relation c programs theta specifications theta test suites used determine whether given test suite thorough job testing program p specification say adequate testing p respect according c simply cadequate p addition providing means evaluating test suites adequacy criteria serve basis test selection strategies discussed many systematic approaches testing based idea dividing input domain program subsets called subdomains requiring test suite include elements subdomain manner input domain subdivided may based structure program tested programbased testing structure semantics specification specificationbased testing combination thereof group techniques generally referred partition testing strategies fact strategies divide input domain overlapping subdomains thus form true partitions input domain paper refer strategies subdomainbased testing precisely testing criterion c subdomainbased program p specification nonempty multiset subdomains sdc p c requires selection one test cases subdomain sdc p note one could define adequacy criteria require selection least k testcases subdomain k 1 however restrict attention criteria require least one test case per subdomain serious limitation since virtually criteria discussed literature require selection least one test case per subdomain model criteria explicitly require k 1 test cases per subdomain could include k copies subdomain sdc p select one test case copy however done test selection strategy described may select test suite less k distinct test cases subdomain general sdc p multiset rather set criteria possible two different requirements correspond subdomain example consider allstatements criterion subdomain corresponds set inputs cause execution particular statement program two different statements executed test cases identical subdomains occur multiset subdomains happen either structure flow graph dictates every path covering one statement also covers another semantics program force two seemingly independent statements traversed exactly test cases course given criterion c multiset contains duplicates one define new criterion c 0 duplicates eliminated shall discuss frequently easier keep duplicates hence select extra test cases check see whether duplicates exist note since sdc p assumed nonempty least one test case must chosen subdomain empty test suite cadequate subdomainbased criterion subdomainbased criterion c applicable ps exists test suite cp holds c universally applicable applicable p every program specification pair p note since empty test suite cadequate c applicable p empty subdomain element sdc throughout paper testing criteria discussed universally applicable subdomainbased criteria unless otherwise noted fact many criteria defined discussed software testing literature universally applicable 7 example allstatements criterion requires every statement program executed applicable program statement cannot exercised input however universally applicable analogs criteria actually usable practice form statement testing really used requires every executable statement exercised formally versions obtained removing empty subdomains sdc p determining whether subdomain empty general undecidable however practice often easy testers determine whether subdomain empty inspecting program code specification another way testers pragmatically deal issue make tacit assumption never percentage x unexecutable statements branches whatever relevant program artifact covered require 100 gamma x statements exercised course possible x percent code unexecutable tester faced problem case analysis formally assess universally applicable versions adequacy criterion note relationship universally applicable analogs criteria may different original criteria 7 discussed section 3 given program p specification failurecausing input one output produced p input agree specified output say test suite detects fault program p contains least one failure causing input note concerned determining particular problem p caused failure determining problem exists intuitively good testing strategy one likely require selection one failurecausing inputs exist 21 model many different ways select test suite satisfies given adequacy criterion would like able compare likelihoods test suites satisfy given adequacy criteria detect faults without regard test suites selected however problem vague analyze since likelihood c adequate test suite detects fault defined respect given probability distribution space test suites satisfying c distributions may defined precise way may arise practice testers manually selecting test cases consider natural since notion natural differs one person another distributions cannot formally analyzed also extremely difficult study empirically thus order carry analysis faultdetecting ability need use test selection model welldefined obviously biased criterions favor far reality mind assume tester selects test suite satisfies subdomainbased criterion c first dividing domain based sdc p 2 sdc randomly selecting element sequel let size subdomain let number failurecausing inputs let assuming one test case independently selected subdomain according uniform distribution gives probability test suite chosen using test selection strategy expose least one fault measure previously investigated 4 10 14 23 called 2 10 note sdc p contains duplicate subdomain model requires independent selection one test case copy subdomain several earlier works compared effectiveness testing criteria 4 14 23 test selection procedure actually specified part criterion thereby obscuring distinction test selection evaluation test adequacy example duran ntafos 4 hamlet taylor 14 compare random testing partition testing partition testing speak dividing programs input domain classes whose points somehow sufficient try one representative class14 p 1402 weyuker jeng 23 compared partition testing strategies random testing using generalized form test data selection n test cases independently selected subdomain test case selection procedure integrated testing criterion note papers based assessments effectiveness measure addition cases assumed subdomain division performed test cases selected selection subdomain independent contrast paper make role selection criterion explicit could argued test selection model accurately reflect testing practice testers sometimes allow test case count toward subdomains belongs argue fact test selection model far reality many cases particular specificationbased testing frequently done first determining test requirements selecting test cases requirement without regard whether test case also fulfills additional requirements especially true system testing done independent testing group test cases derived specification even implementation complete addition expect automated test generation tools targeted programbased testing techniques become available also become common select test suites criteria manner similar strategy manually crafting test cases often far costly test case execution test suite size important issue circumstances generation done automatically may well easier generate test cases test condition subdomain generate test case condition execute see additional conditions inadvertently exercised remove consideration one note practice proposed adequacy criteria monotonic means test suite adequate criterion test suite formed adding test cases suite also adequate using selection method extra test cases cannot added sense comparing test suites containing elements required criterion 22 relations among testing criteria 8 10 explored several relations r among subdomainbased criteria asking whether commonly used relation literature comparing criteria subsumes relation recall criterion c 1 subsumes criterion c 2 every program p specification every test suite satisfies c 1 also satisfies c 2 showed fact c 1 subsumes c 2 guarantee mc 1 simple example illustrating appeared section 1 therefore introduced stronger relation among criteria properly covers relation relevant comparing faultdetecting abilities criteria order explain intuition motivating properly covers relation relationship subsumption first mention two weaker relations narrows covers relations also defined 8 10 every subdomain subdomain 0 2 sdc1 p 0 c 1 universally narrows c 2 every program specification pair 10 showed criteria require selection least one element subdomain opposed explicitly requiring selection k elements c 1 universally narrows c 2 thus criteria considered current paper universally narrows relation equivalent subsumption every subdomain 2 collection fd subdomains belonging sdc1 universally covers c 2 every program specification 10 showed various wellknown criteria related one another covers relation showed possible c 1 cover c 2 p still problem arises one subdomain c 1 used covering two subdomains c 2 therefore introduced properly covers relation overcomes problem g let sdc2 g c 1 properly covers c 2 ps multiset submultiset sdc1 p nkn note number occurrences subdomain 1 less equal number occurrences subdomain multiset sdc1 words c 1 properly covers c 2 c 2 subdomains covered c 1 subdomains ie expressed union c 1 subdomains furthermore done way none c 1 subdomains occurs often covering sdc1 c 1 universally properly covers c 2 every program p specification following example illustrates properly covers relation example 1 consider program p whose input domain fxj1 x 10g let c 2 criterion whose subdomains program p 2 fxj1 x 6g 2 fxj4 x 10g let c 1 criterion whose subdomains 1 properly covers c 2 p since 2 2 2 5 case g 1 note possible one criterion subdomains another without properly covering case criterion c 0obtained c 1 removing subdomains 1 c 0narrows properly cover c 2 2 observation 1 p narrows covers properly covers relations transitive c 1 properly covers c 2 c 1 covers c 2 c 1 covers c 2 c 1 narrows c 2 sdc2 following theorem proven 10 theorem 1 c 1 properly covers c 2 program p specification thus show c 1 universally properly covers c 2 guaranteed test suites chosen satisfy c 1 according test selection strategy least likely detect faults chosen satisfy c 2 another reasonable measure faultdetecting ability criterion expected number failures detected let sdc g assuming independent random selection one test case subdomain using uniform distribution given show c 1 properly covers c 2 given program specification pair c 1 also guaranteed least well c 2 according measure e examples 2 6 show necessarily case c 1 subsumes c 2 properly cover c 2 theorem 2 c 1 properly covers c 2 program p specification ec proof begin noting 1 size number failurecausing inputs let n g let submultiset sdc1 p let k size k number failure causing inputs k ij size 1 ij number failurecausing inputs 1 ij 2 2 1 1 note 3 follows 1 2 since 2 since submultiset sdc1 summation 4 involves summands 3 perhaps additional ones result follows immediately fact summand nonnegative 2 theorems 1 2 easily generalized selection strategies nonuniform distributions subdomains used provided distributions overlapping subdomains satisfy certain compatibility property number strategies using arbitrary distribution entire input domain induce compatible distributions subdomains discussed 6 23 program structure testing criteria based structure program tested called programbased structural whitebox techniques criteria multiset sd c p independent specification criteria consider remainder paper programbased however important note theorems 1 2 hold subdomainbased criteria regardless basis division domain thus specificationbased functional blackbox subdomainbased criteria could also compared using techniques similar used paper sometimes represent program flow graph singleentry singleexit directed graph nodes represent sequences statements individual statements edges represent potential flow control nodes path node n 1 node n k sequence n nodes edge suffix path n path feasible exists input causes executed infeasible otherwise variable v definition node n n contains statement v assigned value variable v use node n n contains statement vs value fetched use variable occurring boolean expression controlling conditional loop statement sometimes associated edges leaving node called predicate use puse definition v node reaches use v node edge u definitionclear path respect v u ie path u along v redefined since criteria consider based program structure necessary select fixed language programs test reason limit attention programs written pascal results depend essential way choice language also assume every program least one conditional repetitive statement least one variable occurs every boolean expression controlling conditional repetitive statement program note variable occurrence may implicit use input file variable statement eof first requirement satisfied every input traverses exactly path program latter requirement fulfilled boolean expression always evaluate true always evaluate false branch unexecutable note require programs wellstructured gotoless contrast reasons described section 3 requirement earlier paper 10 also require programs satisfy feasible anomalies nfa property every feasible path start node use variable v must pass node definition v reasonable property require since programs satisfy property possibility referencing undefined variable 1 although algorithm check whether nfa property holds easy check stronger anomalies property requires every path start node use v whether feasible pass node definition v algorithm presented 5 also possible enforce anomalies property considering entry node definitions variables branch testing also known decisioncoverage one widely discussed subdomainbased criteria decision maximal boolean expression controlling execution conditional statement loop example statement boolean expression x1 y1 decision decisioncoverage criterion two subdomains decision one consisting inputs cause evaluate true point execution one consisting inputs cause evaluate false point execution 2 note two subdomains necessarily disjoint since decision within 1 clarke et al 2 pointed program may legitimately feasible definitionclear path respect v start node call procedure q defines reference parameter v cases nfa property enforced considering argument v defined used call q indeed actual data flow q p may attempt reference undefined variable 10 investigated different variant branch testing called alledges edge programs flow graph gives rise subdomain distinction alledges decision coverage discussed 9 loop single test case may cause decision evaluate true one iteration loop false another iteration remainder paper use universally properly covers relation compare various criteria decisioncoverage criterion thereby exhibit criteria guaranteed least good decisioncoverage according two measures faultdetecting ability e case compare criteria strictly subsumes c 2 therefore follows criteria universally properly cover c 1 thus focus attention question whether c 1 universally properly covers c 2 3 data flow testing several criteria proposed powerful alternatives branch testing involve use data flow information criteria based data flow analysis similar done optimizing compiler require test data exercise paths points values assigned variables points values used section examine several dataflow based testing criteria show universally properly covers decisioncoverage criterion thus viewed better detecting faults branch testing also compare various data flow testing criteria one another alluses criterion 18 19 requires test data cover every definitionuse association program definitionuse association triple u v node programs flow graph variable v defined u node edge v used definitionclear path respect v u 3 frequently refer definitionuse association association test case covers association u v causes definitionclear path respect v u executed similarly allpuses criterion 18 19 restricted version alluses requires test data cover every association u v u edge puse variable v precise definitions criteria subset pascal similar one question given 7 alluses universally properly covers allpuses allpuses universally properly covers decisioncoverage proof since sd allpuses alluses universally properly covers allp uses 3 note u edge n covering path must form must include head tail edge proof allpuses universally properly covers decisioncoverage similar proof 10 allpuses universally covers alledges let p program let decision p let subdomain consisting inputs cause decision evaluate true alternatively could let subdomain consisting inputs cause decision evaluate false let e edge executed evaluates true false since interested feasible analog decisioncoverage assume 6 ie e feasible let v variable occurring decision let definitions v feasible definitionclear path respect v ffi e subdomain ftjt covers association vg recall limiting attention programs satisfy nfa property thus every feasible path start node e passes least one test case exercises one must exercise edge e since outcome decision p gives rise distinct set associations allpuses universally properly covers decisioncoverage 4 2 next consider ntafos required ktuples criteria 17 criteria require execution paths going variable definition use influenced definition via chain intervening definitions uses kdr interaction sequence variables along sequence distinct statements variable x defined used i1 definitionclear path respect x i1 note value assigned x 1 1 influence value x kgamma1 used k required ktuples criterion requires kdr interaction exercised ie path 1 executed p definitionclear path respect x certain requirements based control flow also included clarke et al 2 pointed certain technical problems original definition defined required ktuples criterion making following two modifications 1 ldr interactions must exercised l k 2 statements path need distinct showed required ktuples subsumes required kgamma1tuples required subsumes alluses without modification 1 required ktuples fails subsume required kgamma1tuples without modification 2 required 2tuples fails subsume alluses 10 showed allpuses universally covers universally properly cover edges order restricted attention programs goto statements failure universally properly cover need restrict class programs arose due edges p flow graph puse edges artifact conventions used building flow graphs fundamental aspect program structure consider decisioncoverage version branch testing rather alledges version extraneous edges cease exist problems disappear lemma 2 k 2 required k1tuples criterion universally properly covers required ktuples criterion required 2tuples criterion universally properly covers alluses proof follows immediately fact k 2 sd alluses next consider laski korels criteria 15 subsequently become known contextcoverage orderedcontextcoverage criteria consider paths definitions variables used given statement let x used node n elementary data context n set fffi definition x path p start node node n suffix definitionclear path respect x ffi n thus control reach n variables values assigned nodes respectively contextcoverage criterion requires execution path context clarke et al 2 defined contextcoverage criterion making following modifications 1 subset set variables used node n gives rise context 2 execution paths successors node n required showed contextcoverage subsumes alluses modification 1 motivated fact may definitionclear path respect x start node use x n since assuming nfa property class programs considered path feasible furthermore since 2 k subsets set k variables modification 1 may lead extremely large numbers subdomains laski korel definitions associated uses occurring decisions decision node edges leaving node modification 2 added order insure contextcoverage subsumed branch testing alternatively achieved distinguishing puses cuses associating puses edges 18 19 remainder paper use term contextcoverage refer original laskikorel criterion minor modification use notation denote context arising definitions x nodes ffi uses x node edge u laski korel also introduced orderedcontextcoverage criterion 15 ordered elementary data context node n permutation elementary data context n criterion requires orderedcontext exercised path visits definitions given order lemma 3 orderedcontextcoverage universally properly covers contextcoverage context coverage universally properly covers decisioncoverage proof observation 1 fact orderedcontextcoverage universally properly covers contextcoverage follows immediately definitions proof context coverage universally properly covers decisioncoverage similar lemma 1 vk variables occurring decision node n let successor node n let decisioncoverage subdomain corresponding n let l g set contexts corresponding edge n let corresponding subdomains consider test case 2 let last definitions respectively first occurrence n path executed clearly one contexts c 2 conversely assume 2 definition contextcoverage modified associate puses edges executes path includes n hence 2 since edge decision gives rise distinct set contexts covering proper 2 note statement uses variables v number definitions reach number executable contexts arising single statement may high furthermore number executable ordered contexts arising context may high k thus contextcoverage orderedcontextcoverage potential extremely expensive criteria contrast number definitionuse associations arising statement one might expect contextcoverage orderedcontextcoverage guaranteed better exposing faults simpler data flow testing criteria hamlet argued criteria good concentrating failurecausing input 13 fact always case next show criteria guaranteed better detecting faults allpuses criterion lemma 4 contextcoverage universally properly cover allpuses alluses orderedcontextcoverage universally properly cover allpuses alluses proof consider following program pxy begin else x 0 figure 1 program contextcoverage properly cover allpuses else 0 else flow graph program shown figure 1 note decision node 8 always evaluates true thus control always follows edge 8 9 purely convenience simplify descriptions subdomains calculations e variable used edges 2 3 2 4 x consequently defpuse subdomains arising puses identical context subdomains arising similarly subdomains arising defpuse associations 1 5 6 1 5 7 identical corresponding context subdomains difference two criteria comes decision involving variables x defpuse associations arising decision give rise subdomains shown first three columns table 1 contexts arising decision give rise subdomains 5 observe must used covering 2 4 hence contextcoverage properly cover allpuses program orderedcontexts program identical contexts every path start node edge 89 passes definition x node 4 id subdomain duacontext table 1 subdomains allpuses contextcoverage orderedcontextcoverage node 5 passes definition node 6 node 7 thus ordered contextcoverage properly cover allpuses program fact contextcoverage orderedcontextcoverage universally properly cover alluses follows transitivity universally properly covers relationexample 2 consider specification note p x failurecausing inputs 8 well subdomains based values shown table 1 mallpuses probability failurecausing input selected subdomains arising uses ones edge 8 9 eorderedcontextcoverage eallpuses b expected number failurecausing input selected subdomains arising uses ones edge 8 9 thus program allpuses better contextcoverage orderedcontextcoverage according measures e 2 note program also illustrates 2 k contexts arise statement using k variables thus even unordered contextcoverage may prohibitively expensive summarizing lemmas section theorem 3 alluses allpuses requiredktuples contextcoverage orderedcontext coverage universally properly cover decisioncoverage k 2 requiredk1 universally properly covers requiredktuples required 2tuples universally properly covers alluses neither contextcoverage orderedcontextcoverage universally properly covers allpuses alluses conclude section mentioning two data flow testing criteria dupaths criterion 19 allsimpleoipaths criterion 20 roughly speaking alldupaths criterion requires execution particular paths variable definitions uses allsimpleoipaths criterion requires execution particular types paths cover chains definitions uses leading inputs outputs restrictions kinds paths considered arise control flow considerations alldupaths attention restricted simple paths ie paths nodes except possibly first last distinct allsimpleoipaths criterion attention restricted paths traverse certain loops zero one two times rapps weyuker showed alldupaths subsumes alluses ural yang showed allsimpleoipaths subsumes alldupaths however results based original nonapplicable versions criteria previously shown one considers instead applicable analogs criteria alldupaths even subsume branch testing 7 similar problems arise allsimpleoipaths con sequently careful placement faults executable portions code included executable dupath executable simple oipath possible construct programs criteria less likely expose fault branch testing 4 mutation testing next consider mutation testing criterion 3 unlike criteria examined far mutation testing pathoriented criterion instead considers test suite adequate testing program p distinguishes p set variants called mutants mutants formed applying mutation operators simple syntactic changes program mutation testing subdomains form ftjp 6 p 0 tg p 0 particular mutant p obviously number nature subdomains depend exactly mutation operators used wellknown mutation operators include following two operators mutation testing subsumes branch testing 1 1 replace decision true 2 replace decision false since mutation operators directly relevant comparison mutation testing branch testing use term limited mutation testing refer mutation testing two operators see limited mutation testing subsumes decisioncoverage consider decision program p let dt decisioncoverage subdomain arising true outcome decision let p 0 mutant replaced false let p 0 corresponding mutation testing subdomain let 2 p 0 ie input p 6 p 0 therefore must cause evaluate true least otherwise would distinction computations p p 0 thus dt however proof following theorem shows p 0 dt necessarily identical even though wrong branch taken mutant output may affected observation allows construction programs decisioncoverage likely detect fault limited mutation testing theorem 4 limited mutation testing universally cover decisioncoverage proof consider following program begin cx x div 2 integer part x2 else x2 note x even output x2 regardless whether cx holds let p 0 mutant cx replaced true let p 00 mutant cx replaced false subdomains arising mutants fxjnot cx oddxg subdomains arising decisioncoverage thus even element either dcf dct belongs either limited mutation testing subdomains limited mutation testing cover decisioncoverage program 2 example 3 let p program let specification least one failurecausing input failurecausing inputs even first glance one might attribute rather surprising result highly restricted form mutation testing considered therefore consider mutation testing additional mutation operators application mutation operator gives rise additional nonempty subdomain provided mutated program equivalent original program thus additional mutation operators certainly increase faultdetecting ability however mutation operators proposed literature necessarily lead proper coverage branch testing therefore believe even addition mutation operators possible construct programs mutation testing less likely detect faults branch testing assessed using either e 5 condition coverage family several criteria based considering individual conditions comprise decision proposed refer criteria conditioncoverage family consider conditional statement controlled compound predicate branch testing would require selection test case makes predicate b evaluate true test case makes evaluate false note possible adequately test statement using branch testing strat egy without ever subexpression b false simply selecting one test case making true b true another making false b true similarly statement b adequately branchtested without b ever evaluating true myers 16 argued weakness branch testing since fault pxy begin else figure 2 simple program figure 3 flow graph program figure 2 b wrong expression could go undetected using branch testing therefore introduced three new criteria conditioncoverage decisionconditioncoverage multipleconditioncoverage intended overcome deficiency recall decision maximal boolean expression controlling execution conditional statement loop decisioncoverage requires every decision take value true least testing also take value false least example consider program shown figure 2 flowgraph program shown figure 3 program x1 y1 decision condition boolean variable relational expression boolean function occurring decision example x1 condition y1 thus decision made conditions conditioncoverage requires every condition take value true least take value false least example two test cases sufficient satisfy conditioncoverage test suites among others would satisfy criterion decisionconditioncoverage requires every decision take value true least take value false least every condition take value true least testing take value false least example test suite satisfied conditioncoverage would satisfy decision conditioncoverage multipleconditioncoverage requires every combination truth values conditions occurs least testing 5 example figure 2 multiple conditioncoverage would require four test cases note number subdomains arising multiple condition coverage n number decision statements p c number conditions th decision p thus worst case number test cases required multipleconditioncoverage exponential number conditions p numbers test cases required decisioncoverage conditioncoverage decision conditioncoverage worst linear number conditions example 4 consider program shown figure 2 recall input domain program decision coverage subdomains sd dc let 5 variation meaning term multipleconditioncoverage subsequent software testing literature usage terms consistent myers definitions subdomains corresponding conditions negations multiset subdomains arising conditioncoverage sd cc multiset subdomains arising decisionconditioncoverage sd dcc finally let subdomains along 1 correspond combinations conditions multiset subdomains arising multipleconditioncoverage sd mcc gnotice program conditioncoverage decisionconditioncoverage criteria give rise nondisjoint subdomains generally programs exist criteria family nondisjoint subdomains several reasons first conditions compound predicate need mutually exclusive second condition negation condition overlaps decision occurs negation decision furthermore even subdomains arising particular decision condition negation different combinations conditions negations may intersect occur decision occurs within loop single test case may cause decision condition combination conditions evaluate true one iteration loop false another myers points though using terminology conditioncoverage subsume decisioncoverage decisionconditioncoverage points considers deficiency decisionconditioncoverage possible satisfy decisionconditioncoverage without executing branches transformed flow graph compound decisions broken series decisions containing individual conditions myers introduced multipleconditioncoverage overcome deficiency indicates correctly multipleconditioncoverage subsumes decision conditioncoverage concludes multipleconditioncoverage superior decision conditioncoverage summarizing criteria myers says programs containing decisions multiple conditions minimum criterion sufficient number test cases evoke possible combinations condition outcomes decision points entry program least once16 p 44 given myers recommends multipleconditioncoverage minimal criterion spite expense book widely used testing practitioners worth investigating whether multipleconditioncoverage really good detecting faults show decisionconditioncoverage multipleconditioncoverage universally properly cover decisioncoverage multipleconditioncoverage universally properly cover decisionconditioncoverage exhibit program decision conditioncoverage better multipleconditioncoverage according examining relationship criteria note one could argue decisionconditioncoverage unfair advantage multiplecondition coverage program figure 2 particular program decisionconditioncoverage subdomains multipleconditioncoverage subdomains fact reason multipleconditioncoverage fails properly cover decisioncondition coverage much fundamental illustrate introduce pared version decisionconditioncoverage call minimizeddecisioncondition coverage note decisionconditioncoverage criterion several redundant sub domains test case satisfying obviously satisfies b similarly test case satisfying either b satisfies b subdomains corresponding b b eliminated consideration redundant subdomains arising disjunctive clause eliminated similar manner precisely minimizeddecisionconditioncoverage criterion multiset subdomains sd mdcc p obtained follows decision form b include subdomain dt consisting inputs make evaluate true subdomain daf consisting inputs make evaluate false subdomain dbf consisting inputs make b evaluate false decision form b include subdomain df consisting inputs make evaluate false subdomain dat consisting inputs make evaluate true subdomain dbt consisting inputs make b evaluate true decisions include corresponding decision conditioncoverage subdomains note program number subdomains arising minimizeddecisioncondition coverage less equal number arising multipleconditioncoverage example 5 consider program shown figure 2 specification subdomains arising minimizeddecisionconditioncoverage sd mdcc gtheorem 5 relations among conditioncoverage family criteria follows 1 decisionconditioncoverage universally properly covers decisioncoverage 2 multipleconditioncoverage universally properly covers decisioncoverage 3 minimizeddecisionconditioncoverage universally properly covers decisioncoverage 4 decisionconditioncoverage universally properly covers minimizeddecisioncondition coverage 5 multipleconditioncoverage universally properly cover minimizeddecision conditioncoverage 6 multipleconditioncoverage universally properly cover decisioncondition coverage 7 multipleconditioncoverage universally properly cover conditioncoverage proof prove parts 3 5 7 rest proof straightforward found 9 see part 3 let 2 sd dc p definition decisioncoverage either dt df decision case 1 form b dt 2 sd mdcc case 2 form b df daf case 3 form b dt dat dbt 2 sd mdcc case 4 form b df 2 sd mdcc conjunct disjunct two conditions 2 sd mdcc cases union minimizeddecision condition subdomains arising decision since decision gives rise collection minimizeddecisioncondition subdomains covering proper see part 5 consider program figure 2 recall sd mcc possible express minimized decisioncondition subdomain union multipleconditioncoverage subdomains follows id subdomain table 2 subdomain sizes numbers failures program example 6 notice subdomain 9 occurs sd mcc p occurs twice covering sd mdcc p occurrences necessary sense covering sd mdcc p must least two occurrences 9 fore multipleconditioncoverage properly cover minimizeddecisioncondition coverage program proof part 7 almost identical since 5 must used covering sd cc use result exhibit program criteria discussed section except decisioncoverage better multipleconditioncoverage according measures e example let p program examples 4 5 example specification p x 10 values subdomain shown table 2 note since 45 failurecausing inputs lie subdomains 5 6 9 failurecausing inputs lie 1 7 8 minimizeddecisioncondition criterion greater chance selecting failurecausing input multipleconditioncoverage criterion even though subdomains hence test cases induced multipleconditioncoverage criterion minimizeddecisioncondition criterion particular 6 criterion decisioncoverage 045 045 conditioncoverage 075 100 decisionconditioncoverage 086 145 minimized decisionconditioncoverage 075 100 multipleconditioncoverage 056 056 table 3 values e program example 5 whereas 7 9 similarly emdcc 6 whereas emcc 7 9 values e conditioncoverage decisionconditioncoverage shown table 3 illustrate multipleconditioncoverage also performs worse criteria program specification according measures noted multipleconditioncoverage requires test cases program required minimizeddecisionconditioncoverage example also illustrates bigger test suites necessarily better 2 myers motivation introducing multipleconditioncoverage possible satisfy decisionconditioncoverage without covering edges flow graph arising assembly code concern may arisen analogy hardware testing wires connecting gates analogs branches assembly code even though issue software testing intuitive motivation requiring edges executed lowlevel flow graph edges corresponding evaluations subexpressions condition program erroneous subexpression form b subdomain consisting inputs make subexpression evaluate true may concentrate failurecausing inputs subdomains true corresponding individual con ditions similarly program erroneous subexpression form b subdomain consisting inputs make subexpression evaluate false may concentrate failurecausing inputs subdomains false corresponding individual conditions consequently selecting test cases subexpression subdomains increase likelihood detecting type fault several criteria including multivalue expressions criterion 11 21 capture intuition properly cover decisionconditioncoverage whose cost linear number conditions discussed 9 6 conclusion compared faultdetecting ability several software testing criteria comparison done according carefully defined notions means criterion c 1 better detecting faults criterion c 2 particular investigated whether test suites chosen randomly selecting one element subdomain induced c 1 least likely include least one failurecausing input test suites chosen manner satisfy c 2 previously shown c 1 universally properly covers c 2 c 1 better c 2 sense paper extended result using expected number failures exposed basis comparison showed c 1 properly covers c 2 expected number failures exposed test suites selected using strategy guaranteed least large c 1 c 2 note c 1 universally properly covers c 2 c 1 guaranteed least good c 2 according measures program regardless faults program showed allpuses alluses requiredktuples contextcoverage ordered contextcoverage minimizeddecisionconditioncoverage decisionconditioncoverage multipleconditioncoverage universally properly cover decisioncoverage however limited mutation testing subsumes universally properly cover decision coverage furthermore multipleconditioncoverage subsumes universally properly cover decisionconditioncoverage contextcoverage subsumes universally properly cover alluses allpuses orderedcontextcoverage subsumes universally properly cover alluses allpuses relations summarized figure 4 case c 1 fails universally properly cover c 2 exhibited simple program since multipleconditioncoverage contextcoverage orderedcontextcoverage potentially require number test cases exponential aspect program size calls question usefulness emphasize results figure 4 summary relations criteria solid arrow c 1 c 2 indicates c 1 universally properly covers c 2 dotted arrow c 1 c 2 indicates c 1 subsumes universally properly cover relation explicitly shown figure follow transitivity along fact universally properly covers implies subsumption hold presented show existence programs specifications c 2 better detecting faults c 1 situations c 1 subsumes universally properly cover c 2 based fact c 1 properly cover c 2 program p often possible find specification equivalently find distribution failurecausing inputs mc 2 ec 2 however even program p specifications 0 equivalently distributions failurecausing inputs even universally properly cover c 2 may case c 1 properly covers c 2 particular program tested thus c 1 guaranteed least likely c 2 detect fault program necessarily others several implications results testing practitioner c 1 universally properly covers c 2 practitioner guaranteed likely detect fault using c 1 using c 2 provided tests selected using strategy described earlier hand c 1 properly cover c 2 program test practitioner warned even c 1 requires many test cases may less likely detect fault thus criteria relatively low hierarchy criteria induced properly covers relation may questionable value hand certainly could happen criteria indeed good detecting faults typical programs paper address question fact absence precise notion constitutes typical program questions answered accumulation anecdotal evidence also note seems reasonable conjecture using test selection strategies closely approximate one described yield similar results practice however analytical andor empirical research needed bear particular approximation strategies one might argue approach making real world fit model fact may justified software engineering unlike physical sciences exercise significant control real world benefit example may reasonable devise test data selection strategies closely resemble ones used model payoff would tester precise knowledge relative faultdetecting ability criteria without prior knowledge nature faults program investigation also sheds light develop new criteria provably better existing criterion c one possibility take criterion c 0 universally covers universally properly cover c find subdomains c 0 used k 1 times covering c include k duplicates subdomain equivalently choose k test cases subdomain finally note results based test suite selection procedure idealization way test suites selected typical testing environment assumed test cases selected domain divided subdomains practice testing criteria generally used basis evaluating adequacy test suites selecting test cases suggests two open problems develop practical test selection algorithms approximate strategy used conduct theoretical studies similar one based measures closely reflect existing test selection strategies acknowledgments authors would like thank anonymous referees carefully reading manuscript making several useful suggestions results presented paper appeared proceedings ieee 15th international conference software engineering may 1993 r mutation analysis ideas formal evaluation data flow path selection criteria hints test data selection help practicing programmer evaluation random testing data flow analysis software reliability test selection analytical comparability faultdetecting ability applicable family data flow testing criteria assessing faultdetecting ability testing methods analytical comparison several testing strategies formal analysis fault detecting ability testing methods mathematical framework investigation testing theoretical comparison testing methods partition testing inspire confidence data flow oriented program testing strategy art software testing required element testing data flow analyisis techniques program test data selection selecting software test data using data flow information structural test selection criterion comparison structural test coverage metrics comparing test data adequacy criteria analyzing partition testing strategies comparison program testing strate gies tr selecting software test data using data flow information structural test selection criterion applicable family data flow testing criteria comparing test data adequacy criteria theoretical comparison testing methods formal evaluation data flow path selection criteria partition testing inspire confidence program testing analyzing partition testing strategies comparison program testing strategies assessing faultdetecting ability testing methods experimental results automatic test case generator data flow analysis software reliability data abstraction implementation specification testing art software testing formal analysis faultdetecting ability testing methods data flow analysis techniques test data selection ctr bingchiang jeng elaine j weyuker simplified domaintesting strategy acm transactions software engineering methodology tosem v3 n3 p254270 july 1994 alberto avritzer elaine j weyuker automatic generation load test suites assessment resulting software ieee transactions software engineering v21 n9 p705716 september 1995 alberto avritzer elaine j weyuker generating test suites software load testing proceedings 1994 acm sigsoft international symposium software testing analysis p4457 august 1719 1994 seattle washington united states istvn forgcs exact array reference analysis data flow testing proceedings 18th international conference software engineering p565574 march 2529 1996 berlin germany phyllis g frankl oleg iakounenko empirical studies test effectiveness acm sigsoft software engineering notes v23 n6 p153162 nov 1998 allen parrish stuart h zweben relationships among alluses alldupaths alledges testing criteria ieee transactions software engineering v21 n12 p10061009 december 1995 finding failures cluster analysis execution profiles proceedings 23rd international conference software engineering p339348 may 1219 2001 toronto ontario canada giovanni denaro sandro morasca mauro pezz deriving models software faultproneness proceedings 14th international conference software engineering knowledge engineering july 1519 2002 ischia italy tsong yueh chen yuen tak yu expected number failures detected subdomain testing random testing ieee transactions software engineering v22 n2 p109119 february 1996 sandro morasca stefano serracapizzano analytical comparison testing techniques acm sigsoft software engineering notes v29 n4 july 2004 r hierons comparing test sets criteria presence test hypotheses fault domains acm transactions software engineering methodology tosem v11 n4 p427448 october 2002 andy podgurski wassim masri yolanda mccleese francis g wolff charles yang estimation software reliability stratified sampling acm transactions software engineering methodology tosem v8 n3 p263283 july 1999 f yates n malevris objective comparison cost effectiveness three testing methods information software technology v49 n910 p10451060 september 2007 walter j gutjahr partition testing vs random testing influence uncertainty ieee transactions software engineering v25 n5 p661674 september 1999 hong zhu formal analysis subsume relation software test adequacy criteria ieee transactions software engineering v22 n4 p248255 april 1996 phyllis frankl dick hamlet bev littlewood lorenzo strigini choosing testing method deliver reliability proceedings 19th international conference software engineering p6878 may 1723 1997 boston massachusetts united states elaine j weyuker using operational distributions judge testing progress proceedings acm symposium applied computing march 0912 2003 melbourne florida phyllis g frankl richard g hamlet bev littlewood lorenzo strigini evaluating testing methods delivered reliability ieee transactions software engineering v24 n8 p586601 august 1998 phyllis g frankl yuetang deng comparison delivered reliability branch data flow operational testing case study acm sigsoft software engineering notes v25 n5 p124134 sept 2000 yuen tak yu man fai lau comparison mcdc mumcut several coverage criteria logical decisions journal systems software v79 n5 p577590 may 2006 richard demillo aditya p mathur w eric wong critical remarks hierarchy faultdetecting abilities test methods ieee transactions software engineering v21 n10 p858861 october 1995 mary jean harrold analysis testing programs exception handling constructs ieee transactions software engineering v26 n9 p849871 september 2000 alessandro orso saurabh sinha mary jean harrold classifying data dependences presence pointers program comprehension testing debugging acm transactions software engineering methodology tosem v13 n2 p199239 april 2004 antonia bertolino software testing research achievements challenges dreams 2007 future software engineering p85103 may 2325 2007 hong zhu patrick v hall john h r may software unit test coverage adequacy acm computing surveys csur v29 n4 p366427 dec 1997
synthesis pipelined dsp accelerators dynamic scheduling abstract construct complete systems silicon application specific dsp accelerators needed speed execution high throughput dsp algorithms paper methodology presented synthesize high throughput dsp functions accelerator processors containing datapath highly pipelined bitparallel hardware units emphasis put definition controller architecture allows efficient runtime schedules dsp algorithms highly pipelined data paths methodology illustrated means fft butterfly accelerator block b introduction c omplex digital systems videophone terminal figure 1 typically consist heterogeneous mix hardware blocks 1 processor cores general purpose macro blocks dedicated accelerator proces sors accelerator blocks required execute high performant dsp functions motion estimation dctidct functions paper concentrate generation application specific accelerator processors highlight design issues architecture char acteristics requirements accelerator processors ffl high throughput requirements impose usage pipelined data paths ffl area saved hardware sharing different microinstructions ffl accelerator processor embedded overall system architecture p schaumont b vanthournout bolsens teruniversitary microelectronics center imec kapeldreef 75 b 3001 leuven belgium h de man interuniversitary microelectronics center professor katholieke universiteit leuven belgium control data variable length coder variable length decoder motion estimator reconstructor compressor accelerator components micro controller video ram io fig 1 architecture video phone ffl accelerator functions execute manifest rate nonmanifest rate data introduction interval dii 23 example former processing data stream ad converter example latter processing data processor core inside system support nonmanifest dii allows split development system control component schedule accelerator processor schedule software executed system control component thus revised even accelerator processor developed essential feature presence todays complex algorithms seen system control software accelerator component function call execution call spawns system control thread accelerator executes accelerator operations resynchronizes system control thread scheme used commercial numerical coprocessor components 4 presented synthesis system allows generate components much higher complexity processing power ii overview work automated synthesis systems pipelined datapaths reported previously pisyn 2 sodas 3 sehwa 5 assume fixed dii therefore fix runtime schedule compile time accelerator function fixed rate assumption hold flexibility needed purpose work concentrated following issues accelerator algorithm defined means signal flow graph sfg accelerator datapath defined set application specific units asu 6 asu bitparallel hardware operator able execute one microinstructions microinstructions defined subsets clusters sfg cluster corresponds one microinstruction set clusters covers complete sfg way accelerator algorithm corresponds sequence microinstructions efficient interconnect network consisting pipeline registers take care moving data one asu without creating communication bottleneck simple fast controller structure defined organizes runtime sequencing microinstructions asus finally complete design flow algorithm specification implementation defined synthesis including pipelining retiming asu components rely existing data path synthesis tools retiming tools instruction bus accelerator controller accelerator datapath doack done pipeline register fig 2 architecture accelerator processor 8 design flow integrated software system called dolphin next sections detail design steps realise data path architecture composed asus overview synthesis process examine design steps lead accelerator datapath iiia iiic following architecture runtime controller elaborated iiid operation controller explained iiie finally described architecture method demonstrated iv synthesizing quadrature mirror filter bank used image encoding iii accelerator architecture figure 2 shows overall structure pipeline pro cessor two parts distinguished accelerator data path accelerator controller accelerator datapath consists asus interconnection buses pipeline registers connections run pointtopoint use latch registers require readwrite signals avoided way interconnection strategy avoids either multiplexed bus interconnect storage register become pipeline bottleneck accelerator controller steered system level controller processor interface also generates control signals accelerator datapath well strobe signals input output buses dat apath accelerator controller provide looping branching support sequences microinstructions datapath accelerator data path different steps taken design accelerator data path illustrated figure 3 along small example 1 using sfg specification accelerator func tion accelerator data path defined clustering sfg cluster contain functional operations additions shifts else signal flowgraph inputs outputs sdf semantics 9 assumed clustered graph must directed acyclic graph dag implies loops sfg algorithmic feedback loops must enclosed within one cluster 2 clusters assigned hardware clusters containing functional operations assigned asu op erators clusters containing inputoutput operations assigned inputoutput strobes sfg data precedences cross borders clusters define interconnection buses accelerator data path 3 set clusters assigned one asu define asu microinstruction set composition consists local controller lc bitparallel data path local controller handles microinstruction decoding local decision making consequence global decision making thus condition evaluation circuitry accelerator controller asu bitparallel data path obtained using cathedral3 data path synthesis tools 7 8 capable mapping sfg operations inside cluster bitparallel data path using sharing possible available bitparallel operators corresponding sfg operations listed table operators library parametrized descriptions instantiated standard cells synthesis aside asu definition tools retiming software used insert pipeline registers asu data path also netlist optimization tools 10 11 used tune instantiated bitparallel operator application specific one io timing behavior data control ports asu known timing view expressed number clock cycles representing latency asu input consumption output production 4 find number interconnection pipeline registers proceed follows cluster latency expressed number clock cycles needed evaluate cluster using cluster latencies operation lengths operatormicroinstructions tuples conflicts clustered graph scheduled cluster latency equal asu latency incremented one increment one ensures least one pipeline register present interconnection bus two asu clusters maximum combinatorial delay critical path length accelerator datapath therefore comply timing specs used individual asus list scheduling algorithm used perform dering cluster schedule also used model microinstruction sequence overall data path table one row per asu one column per clock cycle structure called reservation clustering clustered sfg cluster assignment asu definition clusters per asu asu structure timing view per asu cluster scheduling schedule reservation table construction interconnect extraction reservation table interconnect controller generation accelerator controller ip ip op op io 0 m0 io 1 m4 m1 m3 in2 in1a io 0 m0 io 1 m4 assigned clusters asu structure reservation table24 fig 3 design flow accelerator processor table basic data structure design accelerator controller b cluster scheduling cluster scheduling algorithm applied influences controller specification reservation table interconnect specification number pipeline registers interconnect bus wish distinguish scheduling applied obtain data path interconnect scheduling needed decide upon dii runtime scheduling authors fix dii compile time apply sophisticated techniques 12 13 14 15 arrive minimum cost solution interconnect dii unfortunately cannot applied problem hand accelerator requires dii selectable runtime controller presented able within performance capabilities pipeline therefore consider scheduling used obtain data path interconnect currently list scheduling algorithm used approach takes microinstruction resource conflicts account order ob available bitparallel asu operators sfg operation asu operator description multfbb booth multiplier delay regfbb register delay regfilefbb register file fixed hardwired shift operator variable shiftfbb barrel shifter compfbb comparison addsubfbb flag generation detection 0 1 z muxfbb signal selection increment tain optimal solution one two approaches ffl optimization desired dii shown 16 arbitrary dii dii cycle pipeline obtained provided performance pipeline exceeded adequate number data path interconnect delays introduced ffl optimization interconnect cost minimization number pipeline registers residing interconnect buses done polynomial time 17 time dii rate longer arbitrarily chosen two methods conflicting goals depending application one might prefer one c clustering sfg clustering assignment process leads definition data path operators detailed section current state art clustering strategies 18 indicate single unifying approach obtain clusters automatically rather ideal approach believed toolbox functions aid designer clustering sfg therefore current approach sfg clustering assignment accelerator processor manual pro cess section identify costs involved process derive guidelines steer shown application area dsp small clusters introduce excessive multiplexing cost therefore large clusters preferable first hardware costs inside asu processor identified hardware cost primarily defined active silicon area three sources active area ffl data path cost determined operator area needed implement sfg operations ii cell area equivalent 2nand gates cell function location gatesbit fadd1 full adder data path 55 mux2 2multiplexer sharing 23 dff msflipflop interconnect 46 la latch interconnect 35 ffl multiplexing cost multiplexer area needed implement hardware sharing operator ffl interconnection cost consisting area pipeline registers carry signals one cluster next sfg clustering cluster assignment operationoperator binding fixed 1 multiplexing cost data path cost determined set clusters assigned asu 2 interconnection cost expressed number sfg signals crossing boundary clusters lifetimes signals latter determined cluster schedule hardware sharing effective savings data path cost exceeds extra cost introduced sharing operations shown table except delay operations shareable delay operations needed implement algorithmic state common dsp algorithms show need large shareable cluster size within target accelerator processor architecture table ii hardware cost different operators expressed terms equivalent 2input nandgates target technology figures obtained averaging properties two 05 standard cell cmos li b c b b c b c fig 4 sharing cost example braries bitparallel operators introduced data path synthesis tools described terms cells example ripple carry adder chain fadd1 cells multiplier matrix fadd1 cells table also lists multiplexing operator interconnect opera tors flipflop latch proposed accelerator uses edgesensitive flipflop interconnect consider sfg snippet figure 4 assigned two different ways leftmost one intended sharing area cost 11 gatesbit rightmost one shares addition area cost 147 gatesbit implementations per formance rightmost implementation half critical path leftmost one needs two clock cycles perform operation conclude sharing useful sfg multiplexing cost exceeds sharing gain operator area cost gets higher example using multipliers sharing might provide area gain data path synthesis tools try maximize cluster subgraph shared among different micro instructions sharing area gain exceed multiplexing cost given nature dsp algorithms however easy task ffl complex operations often expanded simple ones constant multiplication implemented expansion addshift operations irregular structure structures difficult share ffl many operations like shift bitselect bitreverse implemented hardwired virtually nil operator size ffl dsp algorithms algorithmic delay key element delay cannot shared cuts maximal cluster subgraph shared conclude clustering process doack done example interface behavior m40fig 5 processor interface behavior done care designer knows application hand best position table ii shows one might inflected use latch la instead flipflop dff order gain interconnect area done following reason using latches separate pipeline stages double phase clocking scheme half pipeline stages filled maxi mumthroughput 19 get performance edge triggered flipflops need dual latch pipeline stage figures table indicate duallatch solution better flipflop solution accelerator controller discussion data path synthesis process focus accelerator controller accelerator controller must perform asu microinstruction sequencing according cluster schedule represented reservation table figure 5 operation controller illustrated example reservation table derived previous example top processing three sfg frames shown terms processor interface pins time runs left right one clock cycle time processor interface makes use three signals doack done pin used initiate processing one sfg frame represented accelerator controller one reservation table instance command accepted means hardware available execute schedule reservation table next cycles example pin held high 5 consecutive clock cycles acceptance commands acknowledged doack output second clock cycle new reservation table instance interleaved first one third fourth cycle however interleaving fails acknowledged failure originates hardware sharing asu 0 6 ieee transactions large scale integration vlsi systems called pipeline conflict thus accelerator controller takes care two key functions ffl runtime scheduling asu microinstructions detection conflicts ffl interleaving acceleratorlevel instructions leads accelerator controller hardware presented figure 6 three parts discerned ffl microinstruction shifter ffl conflict controller ffl processor interface microinstruction shifter used store reservation table initiations asu microinstruction bus putoutput strobe proper shift register corresponding one row reservation table start signal loads one instance reservation table shift registers order obtain interleaving shown earlier start signal also fed conflict controller hardware conflict model signals occuring pipeline conflicts ready output whenever output high new reservation table interleaved microinstruction shifter output low interleaving possible start signal depends two conditions ffl user requests accelerator execution pin processor interface ffl conflict controller indicates shift register controller ready accept new initiation therefore start derived ready signals means gate two remaining processor interface signals easily derived start signal done output models latency accelerator obtained start simple delay processor interface makes standalone slave operation possible standalone operation dopin tied logical high case processing rate fixed conflict controller processing frame initiated whenever pipeline conflict occuring e controller work conflict controller contains core dynamic scheduling properties accelerator simple control strategy architecture used conflict controller due davidson 20 approach based dynamic modeling data path resource conflicts instances conflict occurs initiation reservation table called forbidden latencies example reservation table figure 7 initiation introduce pipeline conflict due asu 0 two cycles initiation initiation latency defined delay clock cycles two succesive initiations order satisfy resource constraints initiation latency cannot equal forbidden latency achieve dynamic modeling pipeline conflicts marked indices bit vector shifted right time proceeds bit vector called collision done doack start micro instruction shifter conflict controller processor interface ready reservation table shift reg instruction bus acceleration controller fig 6 accelerator controller vector numbered right left starting 1 bit position vector indicates wether pipeline conflict occurs within clock cycles hence bit position one indicates wether conflict occurs next cycle thus wether new initiation possible next cycle initial marking forbidden latencies found reservation table results initial collision vec tor upon new initiation initial collision vector marked current collision vector taking initial collision vector state diagram constructed states indicating initiation instances edges carrying initiation latencies state diagram discussed literature 2122 states marked collision vector initial state carries initial collision vector represents moment initiation empty pipeline positions within collision vector zero bits initiation latencies derived initial state example state 10 new initiation possible already next cycle moment initial collision vector shifted one position corresponding one cycle delay time pipeline conflicts introduced new initiation annotated collision vector oring initial collision vector current one results new collision vector state 11 state initiation latency least 3 cycles required bit positions 1 2 nonzero collision vector next initiation returns us initial state 3 more3 morestate transition diagram forbidden latencies collision vector shift reg conflict controller conflict 2 initial collision vector clock cycle start ready fig 7 construction conflict controller state diagram models every valid pipeline state therefore cycle within state diagram valid schedule using initial collision vector simple hardware structure generates state diagram con structed collision vector modeled means shift register upon initiation new version initial collision vector ored current collision vector structure used conflict controller advantages using controller architecture ffl static dynamic schedules available within controller architecture corresponding standalone slavemode operation using runtime conflict modeling possible schedules supported ffl controller regular structure small fast shown careful design reduces critical path one gate delay ffl allows parallel pipelined execution several sfg frames iv design example next present synthesis environment called dolphin supports synthesis accelerator processors course synthesis example accelerator example concerns accelerator typically used image encoding algorithms twochannel quadrature mirror filter qmf bank filter decomposes fullrate signal two halfrate subsignals ensemble subsignals used reconstruct original signal basic theory qmf banks exposed 23 24 25 present recent work figure 8 sketches system architecture 2 channel qmf bank signal inz decimated two streams consisting even odd inz samples fed two digital filters h 0 z h 1 z two decimated signals 1 z 2 z produced the2 inz z k z k z k fig 8 twochannel qmf bank filter impulse responses h 0 z h 1 z mirror symmetrical related reconstruction property holds output signals 1 z 2 z wish generate accelerator processor filter one input port allocated feed input signal inz one output port extracts 1 z 2 z way data rates input output port balanced also want accelerator processor minimal latency maximal data throughput behavioral description qmf filterbank silage behavioral language 26 shown listing 9 design example use filter coefficients 16tap fir case described 24 quantized 14 bit accelerator synthesized according design flow shown figure 3 clustering sfg definition asu datapath evaluation cluster sched ule controller synthesis target implementation cmos 07 standard cell technology purpose clustering silage description converted graph format upon user interactively indicate desired clustering clustering performed indicated figure 10 ffl input operation inz assigned io tuple io 0m0 ffl splitting inz odd even streams requires one delay operation assigned asu 8 ieee transactions large scale integration vlsi systems define w fix1412 define w2 fix1816 begin fig 9 qmf silage description2 inz z io 0 m0 io 1 m0 io 1 m1 z k fig 10 clustering qmf bank ffl filtering decimated streams grouped single cluster assigned asu microinstruction tuple asu sharing introduced maximal throughput requirement irregular structure constant tap multiplications ffl two output operations assigned io tuple io 1 m0 io 1m1 assignment expresses sharing output signals 1 z 2 z output port following clustering asu definition done following steps performed ffl operator selection operator netlist generation includes expansion operations expansion constant filter tap multiplications canonical signed digit csd addshift operations ffl mapping operator netlist abstract standard cell library ffl standard cell netlist optimization including redundancy removal retiming buffering retiming tool allows specify desired target clock example target clock 27mhz chosen next evaluate cluster schedule using timing view obtained asu definition conflict model shown left figure 11 presence decimate operations input description visible multiplexing switches tool copes expansion step enumerates paths clustered graph since graph acyclic trivial operation resulting conflict model shown right figure 11 using schedule obtained list scheduler reservation table shown figure 12 constructed data structure fixes collision vector defines state transition diagram shift register controller well conflict controller synthesized finally controller datapath interconnected resulting cicruit properties summarized table iii complete design flow supported software script allowing short editcompiletest cycle behavioral description optimzed netlist example cycle takes less 15 minutes hp700 v conclusion paper strategy tool presented integrate data path synthesis retiming tools system component design environment ffl proposed strategy allows generate small efficient control pipelined systems ffl addition implementation system level data model offered processor interface expand fig 11 qmf multirate expanded conflict model collision state transition diagram reservation table fig 12 qmf reservation table different schedules available within one controller architecture allowing nonmanifest data rates integrated environment design accelerators called dolphin developed currently used design accelerator parts systems videotelephony compression advanced catv modem parts acknowledgements authors wish thank karl van rompaey serge vernalde imec constructive remarks writing paper work also founded netlist optimization tools developed luc rijnders zohair sahraoui imec library work veerle derudder imec test work maryse wouters imec iii circuit properties qmf bank accelerator component cells active area critical mm data path 1894 288 263 controller interconnect 408 046 575 technology cmos 07 standard cells r vlsi architectures video compression scheduling hardware sharing pipelined data paths design pipelined datapath synthesis system digital signal processing issues cpu coprocessor communication synchronization sehwa software package synthesis pipelines behavioral specifications cathedraliii architecturedriven highlevel synthesis high throughput dsp applications combined hardware selection pipelining highperformance datapath design synthesis high throughput dsp asics using application specific data paths static scheduling synchronous data flow programs digital signal processing area optimization bitparallel custom data paths timing optimization bitlevel arithmetic transformations pls scheduler pipeline synthesis force directed scheduling automatic data path synthesis functional requirements extended scheduling tool formal approach scheduling problem high level synthesis maximum performance pipelines switchable reservation tables minimizing number delay buffers synchronization pipelined systems synthesis accelerator datapaths high throughputsignal processing applications counterflow pipeline processor architecture effective control pipelined computers architecture pipelined computers pipeline architecture quadrature mirror filter banks mband extensions perfectreconstruction techniques closed form expression efficient class quadrature mirror filters fir imple 10 ieee transactions large scale integration vlsi systems mentation fast low roundoff implementation quadrature mirror filters subband cod ing dsp specification using silage language tr cathedraliii pipeline architecture ctr miodrag potkonjak kyosun kim ramesh karri methodology behavioral synthesisbased algorithmlevel design space exploration dct case study proceedings 34th annual conference design automation p252257 june 0913 1997 anaheim california united states andreas koch efficient integration pipelined ip blocks automatically compiled datapaths eurasip journal embedded systems v2007 n1 p99 january 2007
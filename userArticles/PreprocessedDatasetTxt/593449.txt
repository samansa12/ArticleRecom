discovery frequent episodes event sequences sequences events describing behavior actions users systems collected several domains episode collection events occur relatively close given partial order consider problem discovering frequently occurring episodes sequence episodes known one produce rules describing predicting behavior sequence give efficient algorithms discovery frequent episodes given class episodes present detailed experimental results methods use telecommunication alarm management b introduction data mining machine learning techniques adapted towards analysis unordered collections data however important application areas data analyzed consists sequence events examples data alarms telecommunication network user interface actions crimes committed person occurrences recurrent ill nesses etc recently interest knowledge discovery sequential data increased see eg 5 8 17 19 24 abstractly data viewed sequence events event associated time occurrence example event sequence represented figure 1 bcde f event types eg dioeerent types alarms telecommunication network dioeerent types user actions marked time line one basic problem analyzing sequence nd frequent epis odes ie collections events occurring frequently together example sequence figure 1 episode ie followed fj occurs several times even sequence viewed narrow window epis odes general partially ordered sets events sequence gure one make instance observation whenever occur either order c occurs soon discovering episodes telecommunication network alarm log goal nd relationships alarms relationships used online analysis incoming alarm stream eg better explain problems cause alarms suppress redundant alarms predict severe faults paper consider following problem given class episodes input sequence events nd episodes occur frequently event sequence describe framework formalize know time edf bcef c bad c efc beaecf figure 1 sequence events ledge discovery task section 2 algorithms discovering frequent episodes given section 3 thery based idea rst nding small frequent episodes progressively looking larger frequent episodes additionally algorithms use simple pattern matching ideas speed recognition occurrences single episodes section 4 outlines alternative way approaching problem based locating minimal occurrences episodes experimental results using approaches various data sets presented section 5 discuss extensions review related work section 6 section 7 short conclusion 2 event sequences episodes overall goal analyze sequences events discover recurrent combinations events call frequent episodes rst formulate concept event sequence look episodes detail 21 event sequences consider input sequence events event associated time occurrence given set e event types event event type integer occurrence time event event type actually contain several attributes simplicity consider event type single value event sequence e triple edf bcef c bad c efc beaecf figure 2 example event sequence two windows width 5 ordered sequence events 2 e integers called starting time e ending time example 1 figure 2 presents graphically event sequence observations event sequence made time 29 time 68 event occurred time interval 29 68 event type time occurrence recorded analysis sequences interested nding frequent episodes class episodes considered interesting events episode must occur close enough time user denes close close enough giving width time window within episode must occur dene window slice event sequence consider event sequence sequence partially overlapping windows addition width window user species many windows episode occur considered frequent formally window event sequence event sequence consists pairs time span e gamma called width window w denoted widthw given event sequence integer win denote ws win set windows w denition rst last windows sequence extend outside sequence rst window contains rst time point sequence last window contains last time point denition event close either end sequence observed equally many windows event middle sequence given event sequence window width win number windows ws win example 2 figure 2 shows two windows width 5 sequence previous example window starting time 35 shown solid line immediately following window starting time 36 depicted dashed line window starting time 35 note event f 40 occurred ending time window window starting 36 similar one dioeerence rst event 35 missing new event f 40 end set 43 partially overlapping windows width 5 constitutes ws 5 rst window 25 30 last hd event 67 occurs 5 windows width 5 eg event c 50 22 episodes informally episode partially ordered collection events occurring together episodes described directed acyclic graphs consider instance episodes ff fi fl figure 3 episode ff serial episode occurs sequence events types e f occur ff figure 3 episodes ff fi fl order sequence sequence events occurring two alarm sequence instance merged several sources therefore useful episodes insensitive intervening events episode fi parallel episode constraints relative order b given episode fl example nonserial nonparallel episode occurs sequence occurrences b precede occurrence c constraints relative order b given mostly consider discovery serial parallel episodes dene episodes formally episode ff triple v g v set nodes partial order v mapping associating node event type interpretation episode events gv occur order described size ff denoted jffj jv j episode ff parallel partial order trivial ie x 6 x 2 v x 6 episode ff serial relation total order ie x x injective mapping g injection ie event type occurs twice episode example 3 consider episode figure 3 set v contains two nodes say x mapping g labels nodes event types seen gure event type supposed occur event type f ie x precedes x episode ff injective since contain duplicate event types window ff occurs may however multiple events types e f next dene episode subepisode another relation used extensively algorithms discovering frequent episodes exists injective mapping ff superepisode fi fi ff write fi oe ff fi ff ff 6 fi example 4 figure 3 see fi fl since fi subgraph fl terms denition mapping f connects nodes labeled nodes labeled b ie nodes fi disjoint corresponding nodes fl since nodes episode fi ordered corresponding nodes fl need consider means episode occurs sequence nodes episode need corresponding events sequence event types partial order episode respected occurs event sequence exists injective mapping ng nodes events example 5 window w 35 40 figure 2 contains events b c e episodes fi fl figure 3 occur window ff odes window width win frequency threshold minfr condence threshold minconf output episode rules hold respect win minfr minconf 1 find frequent episodes algorithm 2 2 compute fs win minfr 3 generate rules 4 ff 2 fs win minfr 5 fi oe ff 6 frfffrfi minconf 7 output rule fi ff condence frfffrfi dene frequency episode fraction windows episode occurs given event sequence window width win frequency episode ff occurs wgj given frequency threshold minfr ff frequent frff win minfr task interested discover frequent episodes given class e episodes class could eg parallel episodes serial episodes denote collection frequent episodes respect win minfr fs win minfr frequent episodes known used obtain rules describe connections events given event sequence example know episode fi figure 3 occurs 42 windows superepisode fl occurs 40 windows estimate seeing window b chance 095 c follows window rules show connections events clearly frequent episodes alone algorithm 1 shows rules condences computed frequencies episodes window width win frequency threshold minfr output collection fs win minfr frequent episodes 1 compute c 1 fff 2 l 3 c l 6 4 database pass algorithms 4 5 5 compute f l fff 2 c l j frff win minfrg 7 candidate generation algorithm 3 8 compute c l fff l fi 2 e fi oe ff 9 l fi 2 f jfij 10 l output f l episodes note indentation used algorithms specify extent loops conditional statements algorithms given frequent episodes rule generation straightforward concentrate following discovery task given event sequence set e episodes window width win frequency threshold minfr nd fs win minfr give rst specication algorithm exact methods subtasks call methods collectively algorithm 31 main algorithm algorithm 2 computes collection fs win minfr frequent episodes class e episodes algorithm performs levelwise breadthrst search episode lattice spanned subepisode relation search starts general episodes ie episodes one event level algorithm rst computes collection candidate episodes checks frequencies event sequence database crucial point candidate generation given following immediate lemma lemma 6 episode ff frequent event sequence subepis odes fi ff frequent collection candidates specied consist episodes smaller subepisodes frequent criterion safely prunes consideration episodes frequent detailed methods candidate generation database pass phases given following subsections 32 generation candidate episodes present candidate generation method detail method easily adapted deal classes parallel episodes serial episodes injective parallel serial episodes algorithm 3 computes candidates parallel episodes algorithm represented lexicographically sorted array event types array denoted name episode items array referred square bracket notation example parallel episode ff events types c c f represented array ff collections episodes also represented lexicographically sorted arrays ie ith episode collection f denoted f since episodes episode collections sorted episodes share rst event types consecutive episode collection particular episodes f l f l j size l share rst l gamma 1 events k f l k shares also algorithm 3 input sorted array f l frequent parallel episodes size l output sorted array candidate parallel episodes size l 1 1 c l1 2 k 0 3 l 1 h 1 jf l j f l blockstarth 4 1 jf l j 5 currentblockstart 6 j 7 f l f l j l gamma 1 rst event types common 8 build potential candidate ff combination 9 x 1 l ffx f l ix 11 build test subepisodes fi contain ffy 12 1 l gamma 1 13 x 1 gamma 1 fix ffx 14 x l fix ffx 15 fi f l continue next j line 6 16 subepisodes f l store ff candidate 18 c l1 k ff 19 c l1 blockstartk currentblockstart events maximal sequence consecutive episodes size l share rst events called block potential candidates identied creating combinations two episodes block eoecient identication blocks store f l blockstart j episode f l j f l rst episode block algorithm 3 easily modied generate candidate serial episodes events array representing episode order imposed total order instance serial episode fi events types c f c order represented array fi replacing line 6 j f l blockstarti f l algorithm 3 generates candidates serial episodes options algorithm desired episode class consists parallel serial injective episodes ie episode contain event type simply insert line continue next j line 6 line 6 time complexity algorithm 3 polynomial size collection frequent episodes independent length event sequence theorem 1 algorithm 3 variations time complexity ol 2 jf l j 2 log jf l j proof initialization line j outer loop line iterated ojf l j times inner loop line times within loops potential candidate lines 9 10 l gamma 1 subcandidates lines 12 built time ol importantly subsets need searched collection f l line 15 since f l sorted subcandidate located binary search time ol log jf l j total time complexity thus ojf l j l log jf l practical situations time complexity likely close ol 2 jf l j log jf l j since blocks typically small 33 recognizing episodes sequences let us consider implementation database pass give algorithms recognize episodes sequences incremental fashion two windows 1 sequences w w 0 events similar take advantage similarity recognizing episodes w make incremental updates data structures achieve shift window obtain w 0 algorithms start considering empty window input sequence end considering empty window sequence way incremental methods need special actions beginning end computing frequency episodes windows correctly input sequence course considered 331 parallel episodes algorithm 4 recognizes candidate parallel episodes event sequence main ideas algorithm following candidate parallel episode ff maintain counter ffeventcount indicates many events ff present window ffeventcount becomes equal jffj indicating ff entirely included window save starting time window ffinwindow ffeventcount decreases indicating ff longer entirely window increase eld fffreqcount number windows ff remained entirely window end fffreqcount contains total number windows ff occurs access candidates eoeciently indexed number events type contain episodes contain exactly events type list containsaa window shifted contents window change episodes aoeected updated instance one event type window second one comes episodes list containsa2 updated information events type expecting present algorithm 4 input collection c parallel episodes event sequence window width win frequency threshold minfr output episodes c frequent respect win minfr 1 initialization 2 ff c 3 ff 4 acount 0 5 1 jffj containsa 6 ff c 7 ff 8 number events type ff 9 10 ffeventcount 0 11 fffreqcount 0 12 recognition 13 start 14 bring new events window 15 events 16 acount acount 17 ff 2 containsa acount 18 ffeventcount ffeventcount 19 ffeventcount jffj ffinwindow start 20 drop old events window 21 events 22 ff 2 containsa acount 23 ffeventcount jffj 24 fffreqcount fffreqcount 25 ffeventcount ffeventcount gamma acount 26 acount acount gamma 27 output 28 episodes ff c 29 fffreqcountt 332 serial episodes serial candidate episodes recognized event sequence using state automata accept candidate episodes ignore input idea automaton serial episode ff several instances automaton time active states reaeect disjoint prexes ff occurring window algorithm 5 implements idea initialize new instance automaton serial episode ff every time rst event ff comes window automaton removed event leaves window automaton ff reaches accepting state indicating ff entirely included window automata ff accepting state already save starting time window ffinwindow automaton accepting state removed automata ff accepting state increase eld fffreqcount number windows ff remained entirely window useless multiple automata state would make transitions produce information suoeces maintain one reached common state last since also removed last thus jffj automata episode ff automaton need know removed thus represent automata ff one array size jffj value ffinitialized latest initialization time automaton reached ith state recall ff represented array containing events array used label state transitions access traverse automata eoeciently organized following way event type 2 e automata accept linked together list waitsa list contains entries form ff x meaning episode ff waiting xth event event enters window shift list waitsa traversed automaton reaches common state another automaton earlier entry ffinitialized simply overwritten transitions made one shift window stored list transitions represented form ff x meaning episode algorithm 5 input collection c serial episodes event sequence window width win frequency threshold minfr output episodes c frequent respect win minfr 1 initialization 2 ff c 3 1 jffj 4 ffinitializedi 0 5 waitsffi 6 ff 2 c 7 waitsff1 waitsff1 fff 1g 8 fffreqcount 0 9 10 recognition 11 start 12 bring new events window 13 beginsatstart 14 transitions 15 events 16 ff 17 19 transitions transitions fff 20 else 21 transitions transitions fff 24 ffinitialized 25 26 ff j 2 transitions 27 ffinitializedj 28 beginsatt beginsatt fff jg 29 30 drop old events window 31 ff l 2 beginsatstart gamma 1 33 else waitsffl 34 ffinitializedl 0 35 output 36 episodes ff c 37 fffreqcountt ff got xth event latest initialization time prex length x updates regarding old states automata done immediately updates new states done transitions identied order overwrite useful information easy removal automata go window automata initialized time stored list beginsatt 333 analysis time complexity simplicity suppose class event types e xed assume exactly one event takes place every time unit assume candidate episodes size l let n length sequence theorem 2 time complexity algorithm 4 proof initialization takes time ojcj l 2 consider number operations innermost loops ie accesses ffeventcount lines 25 recognition phase shifts window shift one new event comes window one old event leaves window thus episode ff ffeventcount accessed twice one shift cost recognition phase thus jcj practice size l episodes small respect size n sequence time required initialization safely neglected injective episodes following tighter result theorem 3 time complexity recognizing injective parallel episodes algorithm 4 excluding initialization n win proof consider win successive shifts one time unit sequence shifts jcj candidate episodes ff undergo 2l changes event type acount increased 1 decreased 0 due fact event type come window acount 1 next win time units reading input takes time n time bound contrasted time usage trivial nonincremental method sequence preprocessed windows frequent sets searched time requirement recognizing jcj candidate sets n windows plus time required read n windows size win jcj l larger factor win theorem 4 time complexity algorithm 5 jcj l proof initialization takes time ojcj l win recognition phase shifts shift one event comes window one event leaves window one shift eoeort per ff depends number automata accessed maximum l automata episode worstcase time complexity thus note win worst case input sequence consists events one event type candidate serial episodes consist events particular type every shift window results update every automaton worstcase complexity close complexity trivial nonincremental method jcj l practical situations however time requirement considerably smaller approach savings obtained case injective parallel episodes theorem 5 time complexity recognizing injective serial episodes algorithm 5 excluding initialization jcj proof shifts aoeect two automata episode event comes window state figure 4 recursive composition complex episode transition one automaton one automaton removed initializing event goes window 34 general partial orders far discussed serial parallel episodes next discuss brieaey use partial orders episodes recognition arbitrary episode reduced recognition hierarchical combination serial parallel episodes example episode fl figure 4 serial combination two episodes parallel episode ffi 0 consisting b episode ffi 00 consisting c alone occurrence episode window tested using hierarchical structure see whether episode fl occurs window one checks using method serial whether subepisodes ffi 0 ffi 00 occur order check occurrence ffi 0 one uses method parallel episodes verify whether b occur however complications one take account first sometimes necessary duplicate event node obtain decomposition serial parallel episodes duplication works easily injective episodes noninjective episodes need complex methods another important aspect composite events duration unlike elementary events e practical alternative handle episodes basically like parallel episodes check correct partial ordering events window parallel episodes located eoeciently found checking correct partial ordering relatively fast 4 alternative occurrence 41 outline approach section describe alternative approach discovery epis odes instead looking windows considering whether occurs window look exact occurrences episodes relationships occurrences one advantages new approach focusing occurrences episodes allows us easily nd rules two window widths one lefthand side one whole rule iif b occur within 15 seconds c follows within approach based minimal occurrences episodes besides new rule formulation use minimal occurrences gives raise following new method called minepi recognition episodes input sequence frequent episode store information locations minimal occurrences recognition phase compute locations minimal occurrences candidate episode ff temporal join minimal occurrences two subepisodes ff addition simple eoecient formulation advantage condences frequencies rules large number dioeerent window widths obtained quickly ie need rerun analysis one wants modify window widths case complicated episodes time needed recognizing occurrence episode signic ant use stored minimal occurrences episodes eliminates unnecessary repetition recognition eoeort identify minimal occurrences time intervals following way given episode ff event sequence say interval occurrence ff 1 ff occurs window e 2 ff occur proper subwindow ie window w e 0 e widthw set intervals minimal occurrences episode ff given event sequence denoted moff occurrence ffg example 7 consider event sequence figure 2 episodes figure 3 parallel episode fi consisting event types b four minimal occurrences partially ordered episode fl following three minimal occurrences episode rule expression fi win 1 episodes fi ff win 1 win 2 integers informal interpretation rule episode fi minimal occurrence interval occurs interval 0 e 0 e formally expressed following way given win 1 fi denote mo win 1 interval u u e dene occff u u e true exists minimal occurrence u 0 e u e condence episode rule fi win 1 example 8 continuing previous example eg following rules condences rule fi 3 fl 4 denominator jf35 38gj nu merator condence 13 rule fi 3 fl 5 condence 1 note since fi subepisode ff rule righthand side ff contains information relative location event inewj events rule righthand side actually required positioned eg events lefthand side also number possible denitions temporal relationship intervals instance rules point backwards time dened similar way brevity consider one case dened frequency episode fraction windows contain episode frequency nice interpretation probability randomly chosen window contains episode concept useful minimal occurrences 1 xed window size 2 window may contain several minimal occurrences episode instead frequency use concept support number minimal occurrences episode support episode ff given event sequence jmoffj similarily frequency threshold use threshold support given support threshold minsup episode ff frequent jmoffj minsup current episode rule discovery task stated follows given event sequence class e episodes set w time bounds nd frequent episode rules form fi win 1 42 finding minimal occurrences episodes section describe informally collection minepi algorithms locate minimal occurrences frequent serial parallel episodes let us start observations basic properties episodes lemma 6 still holds subepisodes frequent episode frequent thus use main algorithm algorithm 2 candidate generation algorithm following results minimal occurrences episode also containing minimal occurrences subepisodes lemma 9 assume ff episode fi ff subepisode moff fi occurs e hence interval u ff serial episode size k let subepisodes ff 1 ff 2 ff size 1 lemma 11 let ff parallel episode size k let subepisodes ff 1 ff 2 ff size e e g minimal occurrences candidate episode ff located following way rst iteration main algorithm moff computed input sequence episodes ff size 1 rest iterations minimal occurrences candidate ff located rst selecting two suitable subepisodes ff 1 ff 2 ff computing temporal join minimal occurrences ff 1 ff 2 spirit specic serial episodes two subepisodes selected ff 1 contains events except last one ff 2 turn contains except rst one minimal occurrences ff found following specication u parallel episodes subepisodes ff 1 ff 2 contain events except one omitted events must dioeerent see lemma 11 idea compute minimal occurrences ff minimal occurrences candidate episode ff found linear pass minimal occurrences selected subepisodes ff 1 ff 2 time required one candidate thus ojmoff n length event sequence optimize running time ff 1 ff 2 selected jmoff 1 j minimized space requirement algorithm expressed jmoffj assuming minimal occurrences frequent episodes stored alternatively jmoffj current next levels minimal occurrences stored size p bounded n number events input sequence event sequence minimal occurrence episode size 1 second iteration event input sequence start jf 1 j minimal occurrences episodes size 2 space complexity second iteration thus ojf 1 jn minimal occurrences episodes located quite eoeciently size data structures even larger original database especially rst couple iterations practical solution use beginning pattern matching methods eg similar ones given section 3 locate minimal occurrences finally note minepi used solve task winepi namely window contains occurrence episode exactly contains minimal occurrence frequency episode ff thus computed moff 43 finding condences rules show information minimal occurrences frequent episodes used obtain condences various types episode rules without looking data recall dened episode rule expression fi win 1 ff win 2 fi ff episodes fi ff win 1 win 2 integers nd rules rst note rule frequent episode ff frequent rules form enumerated looking frequent episodes ff looking subepisodes fi ff evaluation condence rule fi win 1 done one pass structures mofi moff follows locate minimal occurrence ff u u u e rst interval moff property check whether u time complexity condence computation given episode given time bounds win 1 win 2 ojmofij jmoffj con dences win set w time bounds found using table size jwj 2 time ojmofij reasons brevity omit details set w time bounds used restrict initial search minimal occurrences episodes given w denote maximum time bound episode rules occurrences win units used longer episode occurrences thus ignored already search frequent episodes consider support computed respect given win max 5 experiments run series experiments using winepi minepi general performance methods eoeect various parameters scalability methods considered section consideration also given applicability methods various types data sets experiments run pc 166 mhz pentium processor main memory linux operating system sequences resided aeat text le 51 performance overview experimental overview discovered episodes rules telecommunication network fault management database database sequence 73679 alarms covering time period 7 weeks 287 dioeerent types alarms diverse frequencies distributions average alarm every minute however alarms tend occur bursts extreme cases 40 alarms one second start looking performance winepi method described section 3 several performance characteristics used evaluate method time required method number episodes rules found method respect frequency threshold window width possible performance measures present results two opposite extreme cases complexity serial episodes injective parallel episodes tables nding frequent episodes alarm database various frequency thresholds number frequent episodes decreases rapidly frequency threshold increases given frequency threshold numbers serial injective parallel episodes may fairly similar eg frequency threshold 0002 results frequency candidates frequent iterations total threshold episodes time table 1 performance characteristics serial episodes database window width frequency candidates frequent iterations total threshold episodes time table 2 performance characteristics injective parallel episodes serial episodes 93 parallel episodes actual episodes however dioeerent seen number iterations recall iteration l produces episodes size l frequency threshold 0002 longest frequent serial episode consists 43 events candidates last iteration infrequent longest frequent injective parallel episodes 3 events number iterations equals number candidate generation phases number database passes equals number iterations smaller one candidates last iteration episodes window width figure 5 number frequent serial solid line injective parallel dotted line episodes function window width winepi alarm database frequency threshold 0002 eoeect window width number frequent episodes represented figure 5 window width considerably fewer frequent injective parallel episodes frequent serial episodes alarm data increase number episodes fairly even throughout window widths considered however later show may depend heavily type data using figure 6 represents number serial injective parallel episodes found method figure 7 total processing time required frequency threshold increases curves decrease steeply increasing frequency threshold time requirement much smaller parallel episodes serial episodes threshold two reasons parallel episodes considerably shorter see tables 1 2 hence fewer database passes needed complexity recognizing injective parallel episodes also smaller episodes frequency threshold figure number frequent serial solid line injective parallel dotted line episodes function frequency threshold database window width time frequency threshold figure 7 processing time serial solid line injective parallel dot ted line episodes function frequency threshold winepi alarm database window width 52 quality candidate generation take closer look candidates considered frequent episodes found iterations procedure example let us look happens rst iterations statistics rst ten iterations episode episodes candidates frequent match size episodes table 3 number candidate frequent serial episodes rst ten iteration phases winepi alarm database frequency threshold 0001 window width run frequency threshold 0001 window width 60 shown table 3 three rst iterations dominate behavior method phases number candidates large small fraction less 20 per cent candidates turns frequent third phase candidate generation eoecient candidates found infrequent although total number iteration phases 45 last 35 iterations involve 13 candidates thus could safely combine several later iteration steps reduce number database passes take closer look frequent episodes observe frequent episodes longer 7 events consist repeating occurrences two frequent alarms two alarms occurs database 12000 times 16 per cent events support candidates frequent iterations total threshold episodes time 50 12732 2735 83 28 500 813 138 1000 589 92 48 14 2000 405 64 table 4 performance characteristics serial episodes minepi alarm database maximum time bound 60 support candidates frequent iterations total threshold episodes time 100 4376 1755 71 20 500 633 138 1000 480 89 48 12 2000 378 66 table 5 performance characteristics parallel episodes minepi alarm database maximum time bound 60 53 comparison algorithms winepi minepi tables 4 5 represent performance statistics nding frequent episodes minepi method using minimal occurences compared corresponding gures winepi tables 1 2 observe general tendency rapidly decreasing number candidates episodes support threshold increases episodes found winepi minepi necessarily compare cases tables 1 4 approximately number frequent episodes eg 151 serial episodes winepi 138 time support threshold figure 8 processing time serial solid line injective parallel dotted line episodes minepi alarm database maximum time bound 60 minepi notice correspond episodes sizes longest freuquent episodes somewhat dioeerent 43 original 48 minimal occurrence method frequency threshold corresponds minimum 150 instances episode support threshold used minepi 500 dioeerence methods clear small episodes consider episode ff consisting one event winepi considers single event occur windows width 60 minepi sees one minimal occurrence hand two successive events type result ff occuring 61 windows number minimal occurrences doubled 1 2 figure 8 shows time requirement nding frequent episodes minepi processing time minepi reaches plateau size maximal episodes longer changes case support threshold 500 behavior similar serial parallel episodes time requirements minepi directly compared winepi episodes discovered dioeerent implementation minepi works entirely main memory large databases might varying support threshold four time bounds support distinct rule gen threshold rules time 50 50470 149 1000 1221 15 2000 1082 14 4000 1005 14 varying number time bounds support threshold 1000 number rule gen time bounds rules time table number rules rule generation time minepi alarm data base serial episodes support threshold 1000 maximum time bound 60 condence threshold 0 possible rst iterations either minimal occurrences need stored disk methods eg variants algorithms 4 must used 54 rules methods easily produce large amounts rules recall rules constructed considering frequent episodes ff righthand side subepisodes fi ff lefthand side rule additionally considers variations rules time bounds given set w table 6 represents results serial episodes initial episode generation minepi took around 14 total number frequent episodes 92 table shows number rules obtained minepi con dence threshold 0 maximum time bound 60 left varying support threshold rules dioeer time bounds excluded gures rule generation time however obtained generating rules four dioeerent time bounds rules confindence threshold figure 9 total number distinct rules found minepi various con dence thresholds alarm database maximum time bound 60 support threshold 100 minimal occurrence method particularly useful interested nding rules several dioeerent time bounds right side table 6 represents performance results varying number time bounds time requirement increases slowly time bounds used time increases slowlier number rules amount almost 80000 rules obtained may seem unnecessarily large unjustied remember however 1221 distinct rules rest rules present dioeerent combinations time bounds case granularity one second cost 43 thus obtain negrained rules frequent episodes dioeerent criteria used select interesting rules figure 9 represents eoeect condence threshold number distinct rules found minepi although initial number rules may quite large decreases fairly rapidly require reasonable condence data set events event supp max conf freq rules name types thr time b thr epis alarms 73679 287 100 protein table 7 characteristic parameter values data sets number episodes rules found minepi 55 results dioeerent data sets addition experiments alarm database run minepi variety dioeerent data collections get better view usefulness method data collections used typical parameter values results presented table 7 www data part www server log department computer science university helsinki log contains requests www pages departments server requests made www browsers host internet consider www page fetched event type number events data set 116308 covering three weeks february march 1996 total 7634 dioeerent pages referred requests images excluded consideration suitable support thresholds vary lot depending number events distribution event types suitable maximum time bound device generated alarm data one minute slower pace human user requires using larger time bound two minutes www log using relatively small time bound reduce probability unrelated requests contributing support low condence threshold www log justied since interested fairly usual patterns usage dominating ones www server log found eg long often used paths pages home page department pages individual courses behavior suggests rather using bookmark directly home page course many users quickly navigate departmental home page two text data collections modications english text word considered event words indexed consecutively give itimej event end sentence causes gap indexing scheme correspond longer distance words dioeerent sentences used text gnu man pages gnu awk manual size original text text1 5417 words size condensed text le text2 noninformative words articles prepositions conjunctions stripped ooe 2871 words number dioeerent words original condensed text 1102 resp 905 text analysis point using large time bounds since unlikely connection words fairly close clearly seen figure 10 represents number episodes found various window widths using winepi gure reveals behavior distinctively dioeerent corresponding figure 5 alarm database observe text data window widths 24 50 produce practically amount serial episodes number episodes increase considerably larger window widths data interesting frequent episodes smaller 24 episodes found much larger window widths noise phenomenon observed parallel episodes rules found text using simple analysis like strongest rules original text involve either word igawkj episodes window width figure 10 number serial solid line injective parallel dotted line episodes function window width winepi compressed text data text2 frequency threshold 002 common phrases value 2 3 condence 090 meaning 90 cases words ithe valuej consec utive immediately followed preposition iofj rules found condensed text since prepositions articles stripped ooe rules condensed text contain multiple occurrences word igawkj combinations words occurring header man page ifree softwarej performed scaleup tests 5 10 20 fold multiples compressed text le ie sequences approximately 2900 58000 events results figure 11 show time requirement roughly linear respect length input sequence could expected finally experimented protein sequences used data database 1 expasy www molecular biology server geneva university hospital university geneva 11 prosite contains biologically signicant dna protein patterns help time relative size database r r r r figure 11 scaleup results serial solid line injective parallel dotted line episodes minepi compressed text data maximum time bound 60 threshold 10 smallest le nfold larger les identify family protein new sequence belongs purpose experiment evaluate algorithm external data collection patterns known exist nd patterns previously unknown biologists selected target family 7 sequences idna mismatch repair proteins 1j prosite entry ps00058 sequences family known contain string gfrgeal seven consequtive symbols transformed data manner similar english text symbols indexed consecutively protein sequences place gap total length data set 4941 events alphabet 22 event types method could easily modied take several separage sequences input compute support ff eg number input sequences contain minimal occurrence ff length maximum time bound parameter values protein database chosen purpose reveal pattern known present database window width selected 10 ie slightly larger length pattern looking support threshold set 7 seven individual sequences original data data interested longest episodes length 7 longer 20000 episodes found 17 episodes length 7 8 expected contain sequence gfrgeal known database longer episodes variants pattern eighth symbol fairly near necessarily immediately subsequent pattern eg gfrgeals types patterns belong pattern class used prosite suprise longer patterns reported prosite database 6 extensions related work task discovering frequent parallel episodes stated task discovering frequent sets central phase discovering assocation rules 2 rule generation methods also basically association rules winepi levelwise main algorithm also used successfully search frequent sets 3 technical problems related recognition episodes researched several elds taking advantage slowly changing contents group recent events studied eg articial intelligence similar problem spirit many patternmany object pattern match problem production system interpreters 9 also comparable strategies using sliding window used eg study locality reference virtual memory 7 setting dioeers window queue special property know advance event leave window knowledge used winepi recognition serial episodes minepi take advantage fact know subepisodes candidates occurred recent work sequence data databases see 21 provides interesting openings towards use database techniques processing queries sequences problem similar computation frequencies occurs also area active databases triggers specied composite events somewhat similar episodes 10 shown nite automata constructed composite events recognize trigger red method practical episodes since deterministic automata could large methods matching sets episodes sequence similarities algorithms used string matching eg 12 par ticular recognizing serial episodes sequence seen locating occurrences subsequences matches patterns variable length dont care symbols length occurrences limited window width learning set sequences received considerable interest eld bioinformatics interesting problem discovery patterns common set related protein amino acid se quences classes patterns dioeer eg substrings xed length dont care symbols 15 closer patterns considered 24 described algorithm nds patterns similar serial episodes however patterns given minimum length occurrences within given edit distance recent results pattern matching aspects recognizing episodes found 6 work closely related perhaps 4 multiple sequences searched patterns similar serial episodes extra restrictions event taxonomy methods extended taxonomy direct application similar extensions association rules 13 14 22 also methods applied analyzing several sequencies actually variety choices denition frequency episode set sequencies recently pattern class 4 extended windowing extra time constraints event taxonomy 23 survey patterns sequential data see 17 stochastics event sequence data often called marked point process 16 noted traditional methods analyzing marked point processes ill suited cases number event types large however exists interesting combination techniques frequent episodes discovered rst phenomena describe analyzed detail methods marked point processes also interesting similarities discovery frequent episodes work done inductive logic programming see eg 20 noticeable dioeerence caused sequentiality underlying data model emphasis timelimited occurrences similarly problem looking one occurrence episode viewed constraint satisfaction problem class patterns discovered easily modied several direc tions dioeerent windowing strategies could used eg considering windows starting every win 0 time units win 0 windows starting every event types patterns could also searched eg substrings xed length dont care symbols searching episodes several sequences problem general framework episode discovery presented 18 episodes dened combinations events satisfying certain user specied unary binary conditions conclusions presented framework discovering frequent episodes sequential data framework consists dening episodes partially ordered sets events looking windows sequence described al gorithm winepi nding episodes given class episodes frequent enough algorithm based discovery episodes considering episode subepisodes frequent incremental checking whether episode occurs window implementation shows method eoecient applied method analysis alarm aeow telecommunication networks discovered episodes embedded alarm handling software also presented alternative approach minepi discovery frequent episodes based minimal occurrences episodes approach supplies power representing connections events produces rules two time bounds rule formalisms advantages rules minepi often informative frequencies condences rules nice interpretations probabilities concerning randomly chosen windows large part algorithms similar signicant dioeerences computation frequency support roughly general tendency performance winepi eoecient rst phases discovery mostly due smaller space requirement later iterations minepi likely outperform winepi clearly methods modied crossuse ie winepi nding minimal occurrences minepi counting windows large problems whether rule type winepi minepi mixture two methods could give better performance either alone interesting extensions work presented facilities rule querying compilation ie methods user could specify class highlevel language denition would automatically compiled specialization algorithm would take advantage restrictions episode class open problems include combination episode techniques marked point processes intensity models r mining association rules sets items large databases fast discovery association rules mining sequential patterns testing complex temporal relationships involving multiple granularities application data mining working set model program behavior situation recognition representation algorithms fast algorithm many patternmany object pattern match problem composite event specica tion active databases geneva university hospital university geneva simple eoecient string matching k mismatches discovery multiplelevel association rules large databases perspective databases data mining finding aeexible patterns unaligned protein sequences statistical analysis failure time data identifying using patterns sequential data discovering generalized episodes using minimal occurrences algebraic formulation temporal knowledge reasoning recurring events inductive logic programming mining generalized association rules mining sequential patterns generalizations performance improvements combinatorial pattern discovery scientic data preliminary results tr ctr srivatsan laxman p sastry k p unnikrishnan discovering frequent episodes learning hidden markov models formal connection ieee transactions knowledge data engineering v17 n11 p15051517 november 2005 jiawei han jian pei xifeng yan sequential pattern mining structured pattern mining patterngrowth approach journal computer science technology v19 n3 p257279 may 2004 sandra de amo daniel furtado firstorder temporal pattern mining regular expression constraints data knowledge engineering v62 n3 p401420 september 2007 tomoyuki morita yasushi hirano yasuyuki sumi shoji kajita kenji mase pattern mining method interpretation interaction proceedings 7th international conference multimodal interfaces october 0406 2005 torento italy parthasarathy j zaki ogihara dwarkadas incremental interactive sequence mining proceedings eighth international conference information knowledge management p251258 november 0206 1999 kansas city missouri united states jian pei jiawei han wei wang mining sequential patterns constraints large databases proceedings eleventh international conference information knowledge management november 0409 2002 mclean virginia usa jiawei han jian pei behzad mortazaviasl qiming chen umeshwar dayal meichun hsu freespan frequent patternprojected sequential pattern mining proceedings sixth acm sigkdd international conference knowledge discovery data mining p355359 august 2023 2000 boston massachusetts united states mohammed j zaki sequence mining categorical domains incorporating constraints proceedings ninth international conference information knowledge management p422429 november 0611 2000 mclean virginia united states ann devitt joseph duffin robert moloney topographical proximity mining network alarm data proceeding 2005 acm sigcomm workshop mining network data august 2626 2005 philadelphia pennsylvania usa liping ji kianlee tan anthony k h tung mining frequent closed cubes 3d datasets proceedings 32nd international conference large data bases september 1215 2006 seoul korea zdenk tronek episode directed acyclic subsequence graph nordic journal computing v11 n1 p3540 spring 2004 roy villafane kien hua duc tran basab maulik knowledge discovery series interval events journal intelligent information systems v15 n1 p7189 julyaug 2000 katharina morik applications knowledge discovery proceedings 18th international conference innovations applied artificial intelligence p15 june 2224 2005 bari italy mingyen lin suhyin lee interactive sequence discovery incremental mining information sciencesinformatics computer science international journal v165 n34 p187205 19 october 2004 kenji yamanishi yuko maruyama dynamic syslog mining network failure monitoring proceeding eleventh acm sigkdd international conference knowledge discovery data mining august 2124 2005 chicago illinois usa heikki mannila christopher meek global partial orders sequential data proceedings sixth acm sigkdd international conference knowledge discovery data mining p161168 august 2023 2000 boston massachusetts united states mingyen lin suhyin lee efficient mining sequential patterns time constraints delimited pattern growth knowledge information systems v7 n4 p499514 may 2005 anthony kh tung hongjun lu jiawei han ling feng breaking barrier transactions mining intertransaction association rules proceedings fifth acm sigkdd international conference knowledge discovery data mining p297301 august 1518 1999 san diego california united states helen pinto jiawei han jian pei ke wang qiming chen umeshwar dayal multidimensional sequential pattern mining proceedings tenth international conference information knowledge management october 0510 2001 atlanta georgia usa minghua zhang ben kao david w cheung kevin yip mining periodic patterns gap requirement sequences proceedings 2005 acm sigmod international conference management data june 1416 2005 baltimore maryland ke wang yabo xu jeffrey xu yu scalable sequential pattern mining biological sequences proceedings thirteenth acm international conference information knowledge management november 0813 2004 washington dc usa robert gwadera mikhail j atallah wojciech szpankowski reliable detection episodes event sequences knowledge information systems v7 n4 p415437 may 2005 alberto apostolico mikhail j atallah compact recognizers episode sequences information computation v174 n2 p180192 may 1 2002 gong chen xindong wu xingquan zhu mining sequential patterns across time sequences new generation computing v26 n1 p7596 january 2008 foto afrati aristides gionis heikki mannila approximating collection frequent sets proceedings tenth acm sigkdd international conference knowledge discovery data mining august 2225 2004 seattle wa usa kuoyu huang chiahui chang smca general model mining asynchronous periodic patterns temporal databases ieee transactions knowledge data engineering v17 n6 p774785 june 2005 ahmed metwally divyakant agrawal amr el abbadi using association rules fraud detection web advertising networks proceedings 31st international conference large data bases august 30september 02 2005 trondheim norway mohammad elramly eleni stroulia paul sorenson recovering software requirements systemuser interaction traces proceedings 14th international conference software engineering knowledge engineering july 1519 2002 ischia italy jian pei jiawei han wei wang constraintbased sequential pattern mining patterngrowth methods journal intelligent information systems v28 n2 p133160 april 2007 changshing lee yuanfang kao yauhwang kuo meihui wang automated ontology construction unstructured text documents data knowledge engineering v60 n3 p547566 march 2007 r b v subramanyam goswami fuzzy data mining algorithm incremental mining quantitative sequential patterns international journal uncertainty fuzziness knowledgebased systems v13 n6 p633652 december 2005 wei wang jiong yang philip yu mining patterns long sequential data noise acm sigkdd explorations newsletter v2 n2 p2833 dec 2000 jian pei jiawei han behzad mortazaviasl jianyong wang helen pinto qiming chen umeshwar dayal meichun hsu mining sequential patterns patterngrowth prefixspan approach ieee transactions knowledge data engineering v16 n11 p14241440 november 2004 andrzej skowron piotr synak reasoning information maps fundamenta informaticae v59 n23 p241259 february 2004 gregory buehrer srinivasan parthasarathy amol ghoting outofcore frequent pattern mining commodity pc proceedings 12th acm sigkdd international conference knowledge discovery data mining august 2023 2006 philadelphia pa usa hewijin christine jiau yijen su yeoumin lin shangrong tsai mpm hierarchical clustering algorithm using matrix partitioning method nonnumeric data journal intelligent information systems v26 n2 p185207 march 2006 andrzej skowron piotr synak reasoning information maps fundamenta informaticae v59 n23 p241259 april 2004 dong xin jiawei han xifeng yan hong cheng compressing frequent patterns data knowledge engineering v60 n1 p529 january 2007 jiawei han jian pei yiwen yin mining frequent patterns without candidate generation acm sigmod record v29 n2 p112 june 2000 jochen hipp ulrich gntzer gholamreza nakhaeizadeh algorithms association rule mining general survey comparison acm sigkdd explorations newsletter v2 n1 p5864 june 2000 jiawei han jian pei yiwen yin runying mao mining frequent patterns without candidate generation frequentpattern tree approach data mining knowledge discovery v8 n1 p5387 january 2004 jian pei jiawei han laks v lakshmanan pushing convertible constraints frequent itemset mining data mining knowledge discovery v8 n3 p227252 may 2004 aristides gionis teija kujala heikki mannila fragments order proceedings ninth acm sigkdd international conference knowledge discovery data mining august 2427 2003 washington dc dong xin jiawei han xifeng yan hong cheng mining compressed frequentpattern sets proceedings 31st international conference large data bases august 30september 02 2005 trondheim norway valery guralnik jaideep srivastava event detection time series data proceedings fifth acm sigkdd international conference knowledge discovery data mining p3342 august 1518 1999 san diego california united states gabriela guimares lus moniz pereira inferring definiteclause grammars express multivariate time series proceedings 18th international conference innovations applied artificial intelligence p332341 june 2224 2005 bari italy yves bastide rafik taouil nicolas pasquier gerd stumme lotfi lakhal mining frequent patterns counting inference acm sigkdd explorations newsletter v2 n2 p6675 dec 2000 yida wang eepeng lim sanyih hwang efficient mining group patterns user movement data data knowledge engineering v57 n3 p240282 june 2006 anthony k h tung hongjun lu jiawei han ling feng efficient mining intertransaction association rules ieee transactions knowledge data engineering v15 n1 p4356 january tubao ho canhhao nguyen saori kawasaki siquang le katsuhiko takabayashi exploiting temporal relations mining hepatitis data new generation computing v25 n3 p247262 january 2007 chinchen chang chihyang lin henry chou perfect hashing schemes mining traversal patterns fundamenta informaticae v70 n3 p185202 april 2006 mingyen lin suhyin lee incremental update sequential patterns large databases implicit merging efficient counting information systems v29 n5 p385404 july 2004 r anderson pedro domingos daniel weld personalizing web sites mobile users proceedings 10th international conference world wide web p565575 may 0105 2001 hong kong hong kong richard relue xindong wu hao huang efficient runtime generation association rules proceedings tenth international conference information knowledge management october 0510 2001 atlanta georgia usa mohammad elramly eleni stroulia paul sorenson runtime behavior usage scenarios interactionpattern mining approach proceedings eighth acm sigkdd international conference knowledge discovery data mining july 2326 2002 edmonton alberta canada gregory buehrer srinivasan parthasarathy shirish tatikonda tahsin kurc joel saltz toward terabyte pattern mining architectureconscious solution proceedings 12th acm sigplan symposium principles practice parallel programming march 1417 2007 san jose california usa akihiro inokuchi takashi washio hiroshi motoda complete mining frequent patterns graphs mining graph data machine learning v50 n3 p321354 march jiong yang wei wang philip yu jiawei han mining long sequential patterns noisy environment proceedings 2002 acm sigmod international conference management data june 0306 2002 madison wisconsin jun wook lee ok hyun paek keun ho ryu temporal moving pattern mining locationbased service journal systems software v73 n3 p481490 novemberdecember 2004 carl h mooney john f roddick marking time sequence mining proceedings fifth australasian conference data mining analystics p129134 november 2930 2006 sydney australia wenke lee salvatore j stolfo kui w mok algorithms mining system audit data data mining rough sets granular computing physicaverlag gmbh heidelberg germany 2002 jiong yang wei wang philip yu mining asynchronous periodic patterns time series data ieee transactions knowledge data engineering v15 n3 p613628 march jian pei jiawei han constrained frequent pattern mining patterngrowth view acm sigkdd explorations newsletter v4 n1 june 2002 jiawei han jian pei mining frequent patterns patterngrowth methodology implications acm sigkdd explorations newsletter v2 n2 p1420 dec 2000 joo b cabrera lundy lewis xinzhou qin wenke lee raman k mehra proactive intrusion detection distributed denial service attacksa case study security management journal network systems management v10 n2 p225254 june 2002 tamas abraham event sequence mining develop profiles computer forensic investigation purposes proceedings 2006 australasian workshops grid computing eresearch p145153 january 1619 2006 hobart tasmania australia weiguang teng mingsyan chen philip yu regressionbased temporal pattern mining scheme data streams proceedings 29th international conference large data bases p93104 september 0912 2003 berlin germany gerhard widmer simon dixon werner goebl elias pampalk asmir tobudic search horowitz factor ai magazine v24 n3 p111130 september magnus lie hetland pl strom evolutionary rule mining time series databases machine learning v58 n23 p107125 february 2005 gosta grahne jianfei zhu fast algorithms frequent itemset mining using fptrees ieee transactions knowledge data engineering v17 n10 p13471362 october 2005 theodore johnson laks v lakshmanan raymond ng 3w model algebra unified data mining proceedings 26th international conference large data bases p2132 september 1014 2000 jian pei guozhu dong wei zou jiawei han mining condensed frequentpattern bases knowledge information systems v6 n5 p570594 september 2004 guirong xue huajun zeng zheng chen weiying hongjiang zhang chaojun lu implicit link analysis small web search proceedings 26th annual international acm sigir conference research development informaion retrieval july 28august 01 2003 toronto canada yenliang chen shihsheng chen pingyu hsu mining hybrid sequential patterns sequential rules information systems v27 n5 p345362 july 2002 mika klemettinen heikki mannila hannu toivonen rule discovery telecommunication alarmdata journal network systems management v7 n4 p395423 7 amol ghoting gregory buehrer srinivasan parthasarathy daehyun kim anthony nguyen yenkuang chen pradeep dubey cacheconscious frequent pattern mining modern processor proceedings 31st international conference large data bases august 30september 02 2005 trondheim norway yenliang chen yahan hu constraintbased sequential pattern mining consideration recency compactness decision support systems v42 n2 p12031215 november 2006 shaoshin hung tingchia kuo damon shingmin liu efficient mining clustering algorithm interactive walkthrough traversal patterns proceedings 2004 ieeewicacm international conference web intelligence p356362 september 2024 2004 usama fayyad knowledge discovery databases overview relational data mining springerverlag new york inc new york ny 2001 yun chi richard r muntz siegfried nijssen joost n kok frequent subtree mining overview fundamenta informaticae v66 n12 p161198 january 2005 e boros v gurvich l khachiyan k makino maximal frequent minimal infrequent sets binary matrices annals mathematics artificial intelligence v39 n3 p211221 november alexandros nanopoulos dimitrios katsaros yannis manolopoulos data mining algorithm generalized web prefetching ieee transactions knowledge data engineering v15 n5 p11551169 september taneli mielikinen evimaria terzi panayiotis tsaparas aggregating time partitions proceedings 12th acm sigkdd international conference knowledge discovery data mining august 2023 2006 philadelphia pa usa van der aalst ton weijters laura maruster workflow mining discovering process models event logs ieee transactions knowledge data engineering v16 n9 p11281142 september 2004 heikki mannila hannu toivonen levelwise search borders theories knowledgediscovery data mining knowledge discovery v1 n3 p241258 1997 jiong yang wei wang philip yu mining surprising periodic patterns data mining knowledge discovery v9 n2 p189216 september 2004 amol ghoting gregory buehrer srinivasan parthasarathy daehyun kim anthony nguyen yenkuang chen pradeep dubey cacheconscious frequent pattern mining modern emerging processors vldb journal international journal large data bases v16 n1 p7796 january 2007 zhiping zeng jianyong wang lizhu zhou george karypis outofcore coherent closed quasiclique mining large dense graph databases acm transactions database systems tods v32 n2 p13es june 2007 david aldabass evtim peytchev mohamed khalil manling ren scalability issues urban traffic systems proceedings 1st international conference scalable information systems p31es may 30june 01 2006 hong kong klaus julisch marc dacier mining intrusion detection alarms actionable knowledge proceedings eighth acm sigkdd international conference knowledge discovery data mining july 2326 2002 edmonton alberta canada w p van der aalst j weijters process mining research agenda computers industry v53 n3 p231244 april 2004 ling feng jeffrey xu yu hongjun lu jiawei han template model multidimensional intertransactional association rules vldb journal international journal large data bases v11 n2 p153175 october 2002 qing li ling feng allan wong intratransaction generalized intertransaction landscaping multidimensional contexts association rule mining information sciencesinformatics computer science international journal v172 n34 p361395 9 june 2005 luc dehaspe hannu toivonen discovery frequent datalog patterns data mining knowledge discovery v3 n1 p736 march 1999 taneli mielikinen frequencybased views pattern collections discrete applied mathematics v154 n7 p11131139 1 may 2006 jos l balczar gemma c garriga horn axiomatizations sequential data theoretical computer science v371 n3 p247264 march 2007 xingquan zhu xindong wu ahmed k elmagarmid zhe feng lide wu video data mining semantic indexing event detection association perspective ieee transactions knowledge data engineering v17 n5 p665677 may 2005 jiawei han laks v lakshmanan jian pei scalable frequentpattern mining methods overview tutorial notes seventh acm sigkdd international conference knowledge discovery data mining august 2629 2001 san francisco california vipin kumar mohammed zaki high performance data mining tutorial pm3 tutorial notes sixth acm sigkdd international conference knowledge discovery data mining p309425 august 2023 2000 boston massachusetts united states
rewrite rules bisimulation congruences dynamics many calculi clearly defined reduction semantics work calculus however understanding operational congruences fundamental often given tractable definitions characterisations using labelled transition semantics paper considers calculi arbitrary reduction semantics three simple classes firstly ground term rewriting leftlinear term rewriting class essentially action calculi lacking substantive name binding general definitions labelled transitions given case uniformly set rewrite rules without requiring prescription additional notions observation give rise bisimulation congruences test theory shown bisimulation fragment ccs recovered transitions generated fragment ambient calculus cardelli gordon ski combinators also discussed briefly b introduction dynamic behaviour many calculi defined clearly reduction semantics comprising set rewrite rules set reduction contexts may applied structural congruence define atomic internal reduction steps terms work calculus however compositional understanding behaviour arbitrary subterms given operational congruence relation usually required literature contains investigations congruences large number particular calculi often given tractable definitions characterisations via labelled transition relations capturing potential external interactions subterms environments defining labelled transitions give rise satisfactory operational congruences generally requires mix calculusspecific ingenuity routine work paper problem addressed arbitrary calculi certain simple forms give general definitions labelled transitions depend reduction semantics without requiring additional observations prescribed first consider term rewriting ground leftlinear rules arbitrary signature without structural congruence consider calculi arbitrary signatures containing symbols 0 j structural congruence consisting associativity commutativity unit leftlinear rules nontrivial sets reduction contexts suffices example express ccsstyle synchronisation essentially computer laboratory university cambridge email petersewellclcamacuk introduction class action calculi controls number arguments case define labelled transitions prove bisimulation congruence give comparison results background reductions labelled transitions reductions definitions dynamics smallstep operational semantics lambda calculi sequential programming languages commonly given reduction relations calculus rewrite rule xmn gammam nx fi reduction applied context programming lan guages control order evaluation usually required done abstract machines states reductions adhoc mathematical objects elegantly one give definitions structural operational semantics sos style plotkin plo81 states terms language sometimes augmented eg store reductions given syntaxdirected inductive definition explicit reformulations using rewrite rules reduction contexts first given felleisen friedman ff86 neglect semantics bigstepevaluationnatural style contrast recently definitions operational semantics process calculi primarily given labelled transition relations central reason difference mathe matical lambda process terms quite different intended interpretations standard interpretation lambda terms functional programs specify computations may either terminate terminate result cannot reduce confluence properties ensure result terms unique exist implicitly examined either equality coarser notion theory processes however inherits automata theory view process terms may reduce internally interact environments labelled transitions allow interactions expressed reductions may create destroy potential interactions termination processes usually central concept structure terms even terms cannot reduce considered examinable additional technical reason definitions reductions process calculus require either auxiliary labelled transition relations nontrivial structural congruence example consider ccs fragment standard semantics reductions p gammaq also labelled transitions p ff gammaq p ff gammaq represent potentials p synchronising ff defined sos ff gammap gammap com ff par gammaq gammaq gammaq gamma either gamma ff gamma ff gamma noted berry boudol bb92 following work banatre le metayer bm86 gamma language semantic definitions process calculi could simplified working modulo equivalence allows parts redex brought syntactically adjacent presentation terms chemical abstract machines slight variation give reduction semantics ccs fragment consists rewrite rule q set reduction contexts given structural congruence j defined least congruence satisfying use j right gives exactly reductions toy calculus two similar complexity calculus mpw92 building en86 however milner given reduction semantics much simpler rather delicate sos definitions labelled transition systems mil92 following recent name passing process calculi often defined reduction semantics form eg ho san93 ae nm95 join fg96 blue bou97 spi ag97 dpi sew98b rh98 ambient cg98 calculi turning operational congruences confluent calculi definition appropriate operational congruence relatively straightforward even usual case dynamics expressed reduction relation example simple eager functional programming language base type int integers terminated states programs type int clearly observable equality basic observations used define morrisstyle operational congruence several authors considered tractable characterisations congruences terms bisimulation see eg how89 ao93 gor95 references therein gr96 related work object calculus nonconfluent calculi situation problematic process calculi labelled transition semantics equipped plethora different operational equivalences whereas rather styles definition proposed reduction semantics labelled transition case many moreorless plausible notions observation differing eg treatment linearbranching time internal reductions termination divergence etc space illustrated surveys van glabbeek gla90 gla93 difficulty select notion appropriate particular application one attempt sew97 reduction case converse problem reduction relation seem support notion observation gives rise satisfactory operational congruence explicitly addressed ccs calculi milner sangiorgi ms92 san93 barbed bisimulation equivalences defined terms reductions observations barbs vestigial labelled transitions similar distinguished observable transitions tests de nicola hennessy dh84 expressive power calculi suffices recover early labelled transition bisimulations induced congruences related work honda yoshida hy95 uses insensitivity basic observable labelled transitions summarizing definitions operational congruences calculi reduction semantics generally based either observation terminated states confluent case observation barbs natural definition exists either case characterisations congruences terms labelled transitions involving little quantification contexts possible desirable moreover reasonable calculi may natural definition barb induces appropriate congruence paper show labelled transitions give rise bisimulation congruences defined purely reduction semantics calculus without prescribing additional observations preliminary work simple classes reduction semantics involving name variable binding considered test definitions show recover usual bisimulation ccs fragment also discuss term rewriting fragment ambient calculus cardelli gordon directly express semantics interesting calculi requires richer framework one must deal binding rewrite rules involving term name substitutions structural congruence allows scope mobility delicate sets reduction contexts action calculi milner mil96 candidate framework allows several calculi mentioned defined cleanly work seen step towards understanding operational congruences arbitrary action calculi labelled transitions intuitively capture possible interactions term surrounding context made explicit labels transitions term contexts applied create occurrence rewrite rule similar approach followed jensen jen98 form graph rewriting idealizes action calculi bisimulation particular action calculus representing calculus studied mifsud mif96 next three sections develop theory ground term rewriting leftlinear term rewriting addition ac1 structural congruence reduction contexts section 5 contains concluding remarks proofs omitted found technical report sew98a ground term rewriting section consider one simplest possible classes reduction semantics ground term rewriting definitions proofs rather straightforward provide guide following two sections reductions take signature consisting set sigma function symbols ranged oe arity function j j sigma n context composition application contexts tuples terms written b identity context tupling say nhole context linear exactly one occurrence holes section b l range terms b c df h range linear unary contexts e ranges linear binary contexts take set r rewrite rules consisting pair hl ri terms reduction relation labelled transitions transitions term labelled linear unary contexts transitions sgammat labelled identity context simply reductions transitions transitions gammat f 6j indicate applying f creates instance rewrite rule target instance example given rule labelled transitions c labels f f j 9hl ri 2 r contextual labelled transition relations f gamma defined gammat ri bisimulation congruence let strong bisimulation respect transitions congruence proof straightforward given detail guide intricate corresponding proofs following two sections structure three lemmas show contexts labels sources transitions interrelate proved case analysis using dissection lemma standard folklore one following cases holds 1 b exists 2 properly b exists 6 3 b disjoint exists e one following holds 1 exists h 2 exists 1 2 proof definition reduction ri applying dissection lemma lemma 1 l gives following cases 1 l exists b taking second clause holds 2 properly l exists b b 6 taking second clause holds 3 l disjoint exists e taking r first clause holdslemma 3 f gammat f 6 f gammat proof definition labelled transitions ri linear gammat 2 lemma gammat f gammat proof conclusion immediate otherwise definition transitions ri one f gammat definition transitions cases f 6 proposition 5 congruence proof show bisimulation 1 suppose sgammat lemma 2 one following holds exists h hence b exists 1 2 0 exists 0 0 a2 definition reduction 2 suppose f gammat f 6 gammat 0 exists 0 gammat 0 alternative approach would take transitions unary linear contexts f note defined using reduction relation whereas definition involved reduction rules let alt strong bisimulation respect transitions one show alt congruence moreover unaffected cutting label set considered general alt strictly coarser example noninclusion signature consists constants ff fi unary symbol fl reduction rules ffgammaff fi gammafi flfigammafi ff 6 fi whereas ff alt fi insensitivity possible interactions terms internal transitions suggests analogue alt expressive settings unlikely coincide standard bisimulations particular calculi indeed one show applying alternative definition fragment ccs ff ff usual reduction relation gives equivalence identifies ff j ff fi remark proofs lemmas 24 labelled transition exhibited conclusion involves rewrite rule transition premise one could therefore take finer transitions f annotated rewrite rules still congruence result cases gives finer bisimulation relation remark labelled transition relation linear r ie labelled transitions generated union sets rewrite rules union relations generated r 1 r 2 rewriting leftlinear rules section definitions generalised leftlinear term rewriting second step towards framework expressive enough simple process calculi notation next two sections must consider complex dissections contexts terms convenient treat contexts terms uniformly working ntuples mhole contexts mn 0 concretely work category c sigma natural numbers objects morphisms identity id composition substitution b strictly associative binary products written k b l write phi b l angle brackets domain subscripts often elided let b e q range 0 morphisms ie mtuples terms range 1 morphisms ie mhole contexts projections permutations say morphism linear contains exactly one occurrence contains one occurrence sometimes abuse notation examples writing remark many slight variations c sigma possible chosen take objects natural numbers instead finite sets variables give lighter notation labels concrete syntax chosen morphisms 0 1 exactly standard terms sigma modulo elision angle brackets subscript 0 reductions usual notion leftlinear term rewriting expressible follows take set r rewrite rules consisting triple hn l ri n 0 linear 1 reduction relation f defined labelled transitions labelled transitions term two forms sgammat internal reductions f gammat f 6 context together part makes left hand side rewrite rule example given rule labelled transitions terms labelled transitions label contributes whole left hand side rule would redundant definition exclude eg ffifl gamma ffls consider rule labelled transitions addition one construct instances rule placing term ff contexts suggesting labelled transitions ff oe flt gamma fflt instead keep label sets small capture uniformity allow labels targets transitions parametric uninstantiated arguments rewrite rule case definition give general contextual labelled transitions form f gammat 1 first argument f hole placed create instance rule l n arguments parameters l thereby instantiated transitions defined follows sgammat gammat linear identity iff exist permutation linear identity definition illustrated figure 1 restriction l 1 6 id 1 excludes transitions label contributes whole l permutation required parameters l divided instantiated uninstantiated example rule f r nn figure 1 contextual labelled transitions leftlinear term rewriting boxes input wires right n output wires left represent ntuples mhole contexts wires ordered top bottom give rise transitions last redundant could excluded requiring monotone partition bisimulation congruence binary relation terms f j lifted relation 0 def say bisimulation 0 write largest congruence proof requires simple dissection lemma three lemmas relating contexts sources labels lemma 6 dissection one following holds 1 component b exist linear identity ie 1 components b 2 2 component b 1 exist partition linear one following holds 1 exists 2 lemma 8 f one following holds 1 exists h 1n 1 id n 2 exist f lemma 9 gamma linear theorem 1 congruence proof show bisimulation first note see take linear linear show gammat exists 0 1 suppose sgammat lemma 7 one following holds exists hence b exist 0 exists 0 0 f definition reduction 2 suppose f linear f 6 id 1 lemma 8 one following holds exists hence b exist f 0 exists linear f exists tn f definition reduces section 2 rules ground open rules instead allowing parametric labels one could simply close rewrite rules instantiation apply earlier definition general would give strictly coarser congruence example noninclusion take signature consisting nullary ff unary fl r consisting rules fl gammafl flflffgammaflflff g transitions mn 1 flff 6 r flflff flff clr flflff proposition comparison bisimulation defined congruence arbitrary leftlinear term rewriting systems much work term rewriting deals reduction relations confluent ter minating setting terms unique normal forms primary equivalence terms normal form easily proved congruence general incomparable see one noninclusion note sensitive atomic reduction steps sensitive equality terms example nullary symbols ff fi fl rewrite rule fl gammafi ff fi fi fl whereas ff 6 fi fi 6 fl one might address second noninclusion fiat adding value v unary test operator h v reduction rule h v vgammav first one might move weak bisimulation abstracting reduction steps simplest alternative take largest relation 0 symmetric clauses say set r rewrite rules rightaffine right hand side rule affine condition congruence result without left open theorem 2 r rightaffine congruence example integer addition rewrite systems coincides taking signature comprising nullary z integer z binary plus ifzero rewrite rules integers x z gives labelled transitions x plus z together reductions gamma normal forms simply integers coincide integer equality general however still incomparable example unary ffi fl nullary ff rules flffgammaff ffiffgammaff ffifl gamma ff 6 fiff may pathological rule set one would like conditions excluding coincide example ski combinators taking signature sigma comprising nullary ks binary ffl rewrite rules gives labelled transitions ffl 1 together permutation instances reductions gamma significance unclear note rules rightaffine theorem 2 guarantee congruence quite intensional sensitive number arguments consumed immediately term example k rewriting leftlinear rules parallel boxing section extend setting one sufficiently expressive define reduction relations simple process calculi suppose signature sigma includes binary nullary symbols j 0 parallel nil take structural congruence j generated associativity commutativity identity axioms parallel written infix reduction rules r allow symbols boxing ie inhibit reduction arguments oe 2 sigma suppose given set boe defining argument positions reduction may take place require 2g reduction contexts c f c linear generated formally structural congruence defined morphisms c sigma follows family relations indexed domain codomain arities indexes usually elided reductions reduction relation f defined sgammat iff class calculi essentially class action calculi substantive name binding ie controls k arity rules form actions morphisms c sigma includes simple process calculi example fragment ccs section 1 specified taking signature sigma ccs consisting unary ff ff ff 2 0 j rewrite rules notation context f mn 2 1m say f shallow argument occurrences f symbol except j say f deep argument occurrence f symbol equal j say f shallow deep shallow deep 2 1m say f iseparated occurrences j parallel occurrence labelled transitions labelled transitions form previous section transitions f nontrivial label f may either contribute deep subcontext left hand side rewrite rule analogous nonidentity labels previous section parallel component respectively f deep shallow first argument cases must treated differently example rule term rewriting leftlinear rules parallel boxing generate labelled transitions transitions contribute whole left hand side rule j ff j fi redundant excluded necessary take labels subcontexts left hand sides rules structural congruence merely equality example given rule need labelled transitions finally existence rules arguments occur parallel nontrivial terms means must deal partially instantiated arguments consider rule term j ae could placed context oe j create instance left hand side term instantiating 1 context instantiating 2 ae j instantiating 3 labelled transition parametric two places partially instantiating second ae general definition transitions given figure 2 uses additional notation write par n h 1 ppar n nn parts definition illustrated figure 3 rectangles denote contexts terms triangles denote instances par hatched triangles denote instances ppar first approximation definition f deep 1 states f gammat iff rule lgammar l factored l 2 2 arguments enclosing l 1 1 arguments parallel 3 arguments source l 1 instantiated u parallel e label f roughly target r instantiated u 3 partially instantiated e worth noting nonidentity labelled transitions depend set reduction contexts intended intuition labelled transition relations provide enough information reductions term determined labelled transitions structure main property required congruence proof precise result showing labelled transitions provide extraneous information would desirable bisimulation congruence bisimulation defined exactly previous section congruence proof requires dissection lemmas analogous lemmas 1 6 lemmas showing transition related transition analogous lemmas 23 78 partial converses analogous lemmas 4 9 except main dissection lemma omitted found long version lemma 11 dissection 0 b linear one following hold transitions f gammat defined ffl f j id ffl f deep argument 1 f gammat iff exist permutation linear deep linear deep argument 1 1separated ffl f shallow argument 1 f 6j id gammat iff exist permutation linear deep linear deep figure 2 contextual labelled transitions em 3 e e r f e r deep shallow figure 3 contextual labelled transitions illustrated 1 deeply component b exist linear 1separated linear deep j par 1m3 1 b 2 b 3 b potentially overlapping latter split e 1 e 2 2 deeply component b 1 exist partition linear deep first clause lemma illustrated figure 4 example consider clause 1 lemma holds dissection give rise transition theorem 3 congruence remark definitions allow rather crude specifications set c reduction contexts ensure c number closure properties reduction semantics require delicate sets reduction contexts example list cons constructor one might want allow taken given set values would require nontrivial generalisation theory figure 4 clause 1 dissection lemma example ccs synchronization ccs fragment definition gives gamma gamma together structurally congruent transitions ie generated reductions proposition 12 coincides bisimulation labelled transitions section 1 proof write std standard bisimulation labelled transitions section 1 show std bisimulation contextual labelled transitions suppose gamma must exist u r p j p ff exists q 0 p 0 ff must exist u 0 r 0 hence gamma using fact std congruence converse suppose gammaq must exist u r p j ffu j r gamma exists 0 p must exist u 0 r 0 definition standard transitions coincide modulo structural congruence contextual labelled transitions parameter instantiated 0 one might look general conditions r bisimulation 0instantiated transitions already congruence coincides example ambient movement ccs fragment degenerate several respects left hand side rewrite rule nested nonparallel symbols parameters parallel non0 term deep transitions partial instantiations less degenerate example consider fragment ambient calculus cg98 without binding signature sigma amb unary written outfix open 2 allow reduction rewrite rules ramb open definition gives transitions together structurally congruent transitions permutation instances reductions ms j r n open 5 conclusion given general definitions contextual labelled transitions bisimulation congruence results three simple classes reduction semantics preliminary work definitions may inform work particular interesting calculi directly apply results must generalized expressive classes reduction semantics several directions suggest higher order rewriting functional programming languages generally equipped straightforward definitions operational congruence involving quantification contexts discussed introduction several cases given tractable characterisations terms bisimulation one might generalise term rewriting case section 3 notion higher order rewriting vr96 equipped nontrivial sets reduction contexts investigate extent done uniformly name binding express calculi mobile scopes calculus descendants one requires syntax name binding structural congruence allowing scope extrusion generalising definitions section 4 class nonhigherorder action calculi would take number examples currently lack satisfactory operational congruences show indexed structure labelled transitions arises rewrite rules structural congruence ultimately one would like treat concurrent functional languages particluar cases shown one define labelled transitions give rise bisimulation congruences eg ferreira hennessy jeffrey core cml fhj96 express reduction semantics languages would require higher order rules rich structural congruence colouring definition labelled transitions section 4 rather intricate tractable generalisations expressive settings one would like concise characterisation promising approach seems work coloured terms symbol except j 0 given tag set colours gives notion occurrence symbol term preserved structural congruence context application hence provides different way formalising idea label transition f gammat must part redex within f observational congruences focussed strong bisimulation intensional equivalence would interesting know extent congruence proofs given uniformly equivalences abstract branching time internal reductions etc particularly one would like know whether theorem 2 holds without restriction rightaffine rewrite rules one define barbs arbitrary calculus 9f 6j id gammat iff potential interaction context conditions barbed bisimulation congruence coincides could provide useful test expressiveness calculi structural operational semantics definitions labelled transition relations inductive term structure several authors considered calculi equipped labelled transitions defined sos wellbehaved format eg ds85 bim95 gv92 gm98 tp97 ber98 relationship two unclear one would like conditions rewrite rules ensure labelled transitions section 4 definable functorial operational semantics tp97 conversely one would like conditions sos ensuring characterised reduction semantics acknowledgements would like thank philippa gardner ole jensen sren lassen jamey leifer jeanjacques levy robin milner many interesting discussions comments earlier drafts acknowledge support epsrc grant grk 38403 r calculus cryptographic protocols spi calculus full abstraction lazy lambda calculus chemical abstract machine congruence theorem structured operational semantics higherorder languages bisimulation cant traced new computational model discipline programming mobile ambients testing equivalences processes calculus communicating systems labelpassing control operators reflexive cham joincalculus theory weak bisimulation core cml linear time branching time spectrum linear time branching time spectrum ii tile model bisimilarity theory functional programming bisimilarity firstorder calculus objects subtyping structured operational semantics bisimulation congruence equality lazy computation systems reductionbased process semantics phd thesis control structures functions processes calculi interaction calculus mobile processes barbed bisimulation constraints free concurrent computation structural approach operational semantics typed language distributed mobile processes expressing mobility process algebras firstorder higherorder paradigms implementations semantics concurrent programming language rewrite rules bisimulation congruences globallocal subtyping capability inference distributed towards mathematical operational semantics confluence normalisation higherorder rewriting tr equality lazy computation systems linear timebranching time spectrum extended abstract chemical abstract machine dynamic congruence vs progressing bisimulation ccs structured operational semantics bisimulation congruence calculus mobile processes full abstraction lazy lambda calculus turning sos rules equations bisimulation cant traced reductionbased process semantics theory weak bisimulation core cml reflexive cham joincalculus bisimilarity firstorder calculus objects subtyping myampersandpgrcalculus direct style calculus cryptographic protocols typed language distributed mobile processes extended abstract rewriting tile model constraints free concurrent computation barbed bisimulation globallocal subtyping capability inference distributed picalculus rewrite bisimulation congruences categorical axiomatics bisimulation linear time branching time spectrum ii implementations semantics concurrent programming language mobile ambients towards mathematical operational semantics congruence theorem structured operational semantics higherorder languages ctr davide grohmann marino miculan directed bigraphs electronic notes theoretical computer science entcs 173 p121137 april 2007 henrik pilegaard flemming nielson hanne riis nielson active evaluation contexts reaction semantics electronic notes theoretical computer science entcs v175 n1 p5770 may 2007 vladimiro sassone pawe sobociski locating reaction 2categories theoretical computer science v333 n12 p297327 1 march 2005 ole hgh jensen robin milner bigraphs transitions acm sigplan notices v38 n1 p3849 january hartmut ehrig barbara knig deriving bisimulation congruences dpo approach graph rewriting borrowed contexts mathematical structures computer science v16 n6 p11331163 december 2006 massimo merro francesco zappa nardelli behavioral theory mobile ambients journal acm jacm v52 n6 p9611023 november 2005
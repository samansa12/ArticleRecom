exception handlers functional programming languages constructs expressing exception handling greatly help avoid clutter code allowing programmer separate code handle unusual situations code normal case author proposes new approach embed exception handlers functional languages proposed approach discards conventional view treating exceptions means effecting control transfer instead exceptions used change state object two types exceptions terminate resume treated differently terminate exception raised viewed shielding input object hand resume exception designates input object curable requires immediate application handler function approach enables clean semantics functions raising exceptions without associating implementation restriction without loss referential transparency commutativity properties functions b introduction functional programming languages fp 1 describe algorithms clear concise natural way programming language highly desirable feature fp programs constructed using primitive userdefined functions building blocks functionals program forming operations composing functions programs exhibit clear hierarchical structure high level programs combined form higher level pro grams besides functional languages free side effects express parallelism natural way properties make fp attractive theoretical perspective also program construction point view key issue program construction robustness 8 software reliability achieved judicious use faulttolerant tools exception handling 4 one two techniques used developing reliable software functional languages namely standard ml 7 parallel standard ml psml 6 alex 3 gerald 9 author department electrical engineering mcgill university 3480 university street montreal h3a 2a7 canada research work supported grants received micronet network centres excellence canada preliminary version work appeared proceedings 16th international computer software applications conference chicago il 1992 functional languages fl 2 support constructs software faulttolerance one reason could attributed concise semantics strong mathematical properties functional languages make proving correctness programs easy hence program verification tech niques rather faulttolerant tools popular functional languages despite fact argue notations exception handling still necessary following reason definition exceptions necessarily restricted failures following goodenoughs definition 5 consider exceptional conditions brought attention operations invoker treat exceptions failures broadened outlook exception handling becomes useful tool functional languages imperative language exceptions classified two types namely terminate resume exceptions paper define develop required notations programming terminate resume exceptions though proposed notations principle used functional applicative language choose backus fp 1 expository pur poses discuss certain preliminaries exception handling next section section also presents approach embedding faulttolerant tool fp subsequent section introduces new constructs programming terminate exceptions present examples explain meaning intentions proposed constructs section iv demonstrate introduction new constructs destroy algebraic properties fp section v deals resume ex ceptions finally compare work related work section vi ii background section concepts exception handling elucidated imperative framework reasons simplicity ease understanding preliminaries specified services provided given software module classified normal expected desired abnormal expected undesired unanticipated un expected undesired services 4 5 first case execution module terminates normally second case leads exceptional result exception handled module certainly fails provide specified service handle detected exceptions mod ule therefore contains exception handlers despite occurrence lower level exception module provides normal service say lower level exception masked handler hand module unable mask lower level exception provides exceptional result exception propagates higher level last three cases corresponds unexpected behavior software module unexpected behavior attributed existence one design faults either module lower level module design faults unanticipated exceptions handled help default exception handlers notation procedure used indicate procedure p addition normal return also provides exceptional return e brackets three dots denote parameters procedure whose details germane discus sion body p designer insert construct responsible raising exception condition b true exception e raised cleanup operations may performed signaling e construct represents case exception detected runtime test b alternatively exception could detected system run time signal exceptional conditions arithmetic overflow flow illegal array index explicit conditions need programmed systemdefined exceptions point exception raised either detected system runtime test called activation point handler h e associated place p invoked fact handler associated invoker p ancestors p programmer desires place handler associated termed association point exception depending type service required exception one two types namely terminate exception resume exception 4 5 consider procedure defined procedure exception e invoked runtime test b satisfied following control transfers handler h e terminate exception completion h execution control continues association point resume exceptions statements following executed completion h thus exceptions control switches activation point handler continues execution association point whereas resume exceptions control temporarily jumps handler returns activation point completion handler fact made use defining notations exception handling fp b related issues bretz 3 identifies two problems supporting exception handling constructs functional programming exception imperative languages treated means effecting control transfer hence fundamental conflict functional approach followed functional languages control floworiented view exceptions due exceptions functional languages result nondeterministic behavior fp program example two exception points inside given function result parallel evaluation function could different depending exception raised first consider evaluation function addsubexp defined using alex syntax 3 signals application like handle xx terminate could yield 3 5 depending order evaluation subexpressions problem considered intrinsic incorporating exceptions functional languages languages ml 7 alex 3 circumvent problem proposing sequential execution fp restriction severe essentially required control flow view exceptions carried functional lan guages discard view define semantics fp functions operating exception objects without imposing restriction execution though gerald 9 psml 6 allow parallel execution subexpressions retain deterministic behavior assigning priorities exceptions secondly exception handling might cause side effects expressions hence might violate property referential transparency proposed solutions 3 7 suggest association environment functions case discarding conventional control flow view exception solves problem naturally established section iv introduction new constructs preserve algebraic properties functional languages approach like psml 6 uses error values handling exceptions however important differences two section vi brings differences reeves et al 9 point embedding exception handling constructs lazy functional languages transform nonstrict functions hyperstrict functions illustrated help expression handle bad x0 terminate phi nonstrict binary operator nonstrict arguments signal bad propagates operators phi handled respective handler function even though phi defined nonstrict arguments uppropagation signal phi makes strict subexpressions need evaluated determine whether raise exception reeves et al claim transformation nonstrict actors hyperstrict actors due uppropagation signals nonstrict operators overcome problem notion downpropagation firewalls defined 9 paper however argue uppropagation persistent nature exception values causes problem mean exception value part object hx error signal e special status persists object indistinguishable e also referred following strict semantics exception values section iiic illustrate help example show problem could overcome following lazy semantics error values following subsection describe approach incorporating exception handlers functional languages c approach embedding exception handlers fp exceptions incorporating exception handlers fp discard conventional control floworiented approach instead terminate exception considered shield input object terminate exception e raised applying function f object x input object considered shielded e object represented x e exception object x e component composite object x 1 objects respectively known fully partially shielded objects shielded object x 1 x e 1 one fully shielded object possibly shielded different exception names constituent elements thus partially shielded object fully shielded object cannot shielded either exception another exception x e e 0 valid objects however object valid interestingly e 0 e object observe hierarchy shielding function except respective handler operating fullyshielded object inhibited words object fully shielded function applied behaves like identity function handler h exception e applied x e removes shield object results h x must noted handler remove corresponding shield thus object shielded number exceptions shields removed respective handlers applied appropriate order functions operating partially shielded object either behaves like identity function results expected value depending semantics function functions defined nonstrict respect exception shielded objects 1 even though functions strict diverging computations original definition fp relax allow functions semantics fp functions functional forms operating shielded objects partially shielded objects described next section reason choosing nonstrict semantics henceforth nonstrictness paper refers nonstrict respect shielded objects allow shielded objects exist carry strict fp functions functional forms ultimately handled appropriate handler resume exceptions resume exceptions handled locally possible therefore embedding functional languages cause fundamental conflict since resume exceptions handled locally concept shielding object help however sophisticated handling required resume exceptions view situation following manner resume exception raised input object considered abnormality needs cured immediately instead passing object possibly shield handler handler invoked activation point immediate cure function view simple serves purpose following sections introduce notations constructs terminate resume exceptions new constructs defined domain semantics fp functions redefined required iii terminate exceptions objects functions functional forms fp extended following way embed terminate exceptions extended fp system objects formally object undefined denoted atom x sequence objects hx x could normal object ii partially shielded iii completely shielded single exception domain objects divided three disjoint sets namely set c completely shielded objects form x e ii set p partially shielded objects form hx iii set n normal shielded objects form hx p sets n p c primitive functions semantics primitive functions operating shielded objects defined meaning functions applied normal objects 1 select tail null functionals construction constant nonstrict appropriate components input object chose nonstrict semantics want show approach embed exception handling constructs introduce hyperstrictness straightforward extend definition functions functional forms support lazy semantics also possible prove algebraic laws fp nonstrict functions lines similar given 1 present beyond scope paper select tail atom equal equal strict function strict components argument input object x partially fully shielded equal behaves like identity function id null reverse reverse distribute left function distribute right defined similar way add subtract multiply divide functions expect input object form except function input form x 1 strict transpose append left append left strict second component input similarly append right function strict first component input next deal functional forms functional forms composition f construction condition constant constant functional nonstrict partially fully shielded objects means apply insert definitions definitions fp program written form hfuncnamei hfuncdefni represent function name function body respectively term inside braces optional term included function raises exception exceptions raised function listed exceptionlist programming exceptions terminate exception raised using esc function exception name e adding syntactic sugar esc function written fp style esc ffi e id however continue use representation esc e simplicity sake handler functions handler terminate exception e written read e h application function called handler function x defined order write handler functions fp style function hand defined however prefer sake simplicity definition esc handler functions observed exception name finally default handler written following semantics b examples illustrate notations introduced far means examples example 31 first example deals systemdefined exception consider select function k select kth element object let systemdefined exception e isv isv stands illegal selector value sume runtime application function k object raises exception e isv whenever k greater n exceptional case application results hx handler function 1r function select rightmost element structured object applied shielded object produce xn example 32 consider addsubexp function discussed section iib problem programmed fp application addsubexp1 results applying finally add result irrespective order subexpressions exp1 exp2 evaluated interesting note gerald 9 psml 6 one two exceptions e1 e2 given higher priority exception allowed propagate example evaluating subexpressions parallel deterministic behavior guaranteed way gerald intuitive approach adopted gerald based replacement model yemini berry 11 obvious psml uses error data values handle exceptions prioritizing exceptions results loss commutative property commutativity regained gerald enforcing certain lexical scoping rules case enforcing priorities subexpressions parallel execution model would cause additional implementation overhead neither gerald psml addresses implementation issues involved prioritizing exceptions example 33 lastly consider conversion string numbers ascii equivalents assume functions asc asc produce ascii equivalent number ascii character respectively conversion string numbers easily done fp using applytoall functional illustrate features proposed notation recursive context program example following way ascii ffi1 asciistring ffitl functions ge le represent respectively greater equal less equal logical functions application asciistring input h64 65 30i results ha b c remarks certain remarks order systemdefined exceptions detected implicitly runtime exceptions raised executing primitive functions fp appropriate declare systemdefined exceptions type termi nate handlers systemdefined exceptions easily defined using proposed notations shown example 31 ii proposal user freedom define handler anywhere likes shielded objects partially fully propagate strict functions reach handler propagation implicit however nonstrict functions may dangerous effect partially completely pruning exception object hence care need exercised placing handler functions iii shielded object propagates dynamic invocation chain encounters appropriate han dler hence handler association dynamic may observed view terminate exceptions shield abnormal values facilitates dynamic handler association natural manner iv mentioned earlier psml gerald require additional prioritizing schemes retain deterministic behavior parallel execution model ap proach however exception object nonpersistent cause indeterminate behavior matter order subexpressions evaluated v lastly review problem exceptions introducing hyperstrictness functional languages consider function signals e1 expression similar handle bad x0 terminate select function used former place operator phi 9 argued uppropagation signal bad transforms phi strict function however reducing circledplus turn returns value 14 thus evaluation remains nonstrict even presence exception e1 uppropagation however allow exception objects persistent application circled plus h12 13 14i would result 2 h13 e1 making select function strict thus say essentially persistent nature exception ob jects uppropagation transforms nonstrict functions strict functions following section present formal approach describe terminate exceptions handlers iv formal study fp exceptions preliminaries set input objects called input domain denoted order study algebraic properties functional pro grams first need study behavior primitive functions fp primitive function f domain input objects partitioned two disjoint sets called active domain represented ad f denoted id f intuitively active domain function f consists objects function intended effect objects belonging identity domain f function inhibited formally object x belongs ad f x identity function id ad id f set objects objects active domain function could still partially completely shielded objects active domain identity domain esc e objects belonging c form domain esc e next consider handler function may noted effect application handler function object belonging active domain slightly different effect f x x 2 ad f performs two actions removing shield x ii application h normal object barring small difference say primitive function f including esc e functions handler functions behaves either f identify function id behavior f however deterministic depends entirely whether input object active identity domain f b choice operator represent behavior function mathematically introduce deterministic choice operator function f written f f1 f f2 identify function application f object x results ad f f 1 appropriately defined handler func tions details f required proving algebraic properties hence ignored henceforth following axioms written choice operator using definitions functional forms presented section iiia axiom 1 composition axiom 2 condition axiom 3 construction axiom 4 applytoall axiom 5 insert f basis axioms selection choice deterministic selection one function influence selection therefore choice operator rewritten one variables choice subscripts suitably renamed lastly n 8x active domain constant functional n c algebraic laws fp programs section prove algebraic laws fp programs listed 1 important realize fp programs considered extended include exception handler functions composition associative composition condition proof proof law similar l2 2 construct composition l4 using axiom 3 axiom 1 l5 proof law proved lines similar l2 l4 axioms 2 3 used proof 2 construct applytoall using axiom 2 using axiom 4 miscellaneous proof using axioms 1 4 law proved 2 proof law proved using axiom 2 algebraic law laws means exhaustive one easily prove laws described 1 lines similar discussed v resume exceptions section introduce notations programming resume exceptions notations resume exceptions denoted e e could possibly subscripted function res e introduced raise resume exception handler h resume exception represented influx symbol indicating e type resume mentioned earlier application function object x raises resume exception object x treated cur able corresponding handler function applied object x activation point neither corresponding handler default handler present resume exception runtime error occurs res e function invoked resume exceptions shield objects existing definitions objects functions functional forms sufficient express explicit compiletime techniques required accomplish dynamic association handler resume exception beyond scope paper discuss implementation association handlers present simple example illustrate resume exceptions programmed example 51 example deals program adds magnitudes sequence numbers program calls function sum adds two numbers exceptions raised sum whenever either numbers considered addition negative handler takes input argument returns magnitude sum operation resumed handling exception negate function negates input argument seen cond function example raises e whenever input negative cure function negate immediately applied input object exception e raised b remarks first sight functions raising resume exceptions appear violate referential transparency consider function f raises resume exception e suppose h handler e necessarily associated f fx may result one two values depending whether object lies normal exception domain f thus appears f non deterministic reasoned following way function f considered sort higher order function h argu ment function f selectively applies h whenever input object exception domain f deterministic function whose range divided two sets one corresponding normal values exception values ii resume exceptions indirectly used define higher order functions fp example consider function f written composition two functions let want define function fh f h supplied argument using resume exception notation function defined thus function f considered place holder filled handler function different handler functions associated f generate number fh functions interesting use resume exceptions vi related work attempts 2 3 6 7 9 10 incorporate exception handling functional applicative languages compare earlier proposals main difference work related ones radical change way exceptions viewed earlier proposals 3 7 treat exceptions means effecting control transfer leads fundamental conflict remedy requires imposition sequential execution treat exception objects either shielded requiring immediate application cure functions approach naturally suits functional style therefore necessitate constraint execution model ii approach similar psml 6 use error data values handle exceptions however psml explained section iiib deterministic program behavior retained assigning priorities exceptions besides prioritizing exceptions involves additional implementation overheads gerald 9 uses replacement model yemini berry 11 also prioritizes exceptions guarantee deterministic behavior hand ap proach following nonstrict semantics avoids need requirements iii gerald argued uppropagation error signals transforms nonstrict functions strict functions overcome problem use firewalls downpropagation proposed section iiic established persistent nature error signals gerald makes nonstrict functions strict functions shielded objects nonpersistent approach introduce hyperstrictness iv scheme exception automatically propagated higher level modules appropriate handler found propagation exception along dynamic invocation chain transparent user programming language ml 7 also supports implicit propagation exceptions contrast alex 3 exceptions must explicitly transmitted v ml 7 supports terminate type exceptions whereas work like alex 2 allows resume terminate exceptions vi fl language 2 designed constructs exception handling though userdefined exceptions programmed fl exceptions mainly used signal application inappropriate input objects primitive functions one type exception allowed fl vii wadler 10 suggests lazy evaluators need extra constructs provide exception handling function results packaged singleton list null list representing error result however minimalistic approach requires considerable programmer effort discipline moreover method support different kinds named exceptions vii conclusions paper introduced notations exception handling fp languages constructing reliable software notations introduced illustrated help example programs incorporating exception handling fp conventional view treating exceptions means effecting control transfer discarded view exceptions allows us describe semantics fp functions functional way retaining referential transparency nice mathematical properties functional languages fact accomplished without imposing additional execution constraints sequentializing execution semantics primitive functions fp defined nonstrict manner exception objects means even eager evaluation strategies followed implemen tation result still lazy exception objects lastly approach exception handling introduce hyperstrictness even though chose backus fp incorporated exception handling constructs scheme general could applied functional language addition alex supports exceptions different class called retry 3 retry exceptions exiting handler execution control switched beginning module exception raised attempt incorporate class exceptions inherent control transfer present proposed method exception handling advantages retaining nice mathematical properties functional language ii deterministic program behavior iii nonstrictness lazy languages lead implementable parallel programming language acknowledgments author thankful anonymous reviewers helpful comments work presented paper would taken present shape without numerous discussions author ra nicholl university western ontario london canada r programming liberated von neumann approach functional style algebra programs fl language manual exception handling construct functional languages exception handling software fault tolerance exception handling issues proposed notation exception handling parallel functional lan guage psml definition standard ml version 3 system structure software fault tolerance ger ald exceptional lazy functional programming language replace failure list successes method exception handling backtracking pattern matching lazy functional languages axiomatic treatment exception handling expressionoriented language tr replace failure list successes axiomatic treatment exception handling expressionoriented language programming liberated von neumann style exception handling exception handling construct functional languages ctr margaret burnett anurag agrawal pieter van zee exception handling spreadsheet paradigm ieee transactions software engineering v26 n10 p923942 october 2000 takeshi ogasawara hideaki komatsu toshio nakatani edo exceptiondirected optimization java acm transactions programming languages systems toplas v28 n1 p70105 january 2006
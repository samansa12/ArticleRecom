improvements graph coloring register allocation describe two improvements chaitinstyle graph coloring register allocators first optimistic coloring uses stronger heuristic find kcoloring interference graph second extends chaitins treatment rematerialization handle larger class values techniques complementary optimistic coloring decreases number procedures require spill code reduces amount spill code spilling unavoidable rematerialization lowers cost spilling values paper describes techniques experience building using register allocators incorporate provides detailed description optimistic coloring rematerialization presents experimental data show performance several versions register allocator suite fortran programs discusses several insights discovered repeated implementation allocators b introduction relationship runtime performance effective use machines register set well understood compiler process deciding values keep registers point generated code called register allocation values registers accessed quickly values memory high performance microprocessorbased machines difference access time order magnitude thus register allocation strong impact runtime performance code compiler generates memory latencies rising register latencies impact allocation performance increasing addition features like superscalar instruction issue increase programs absolute demand registers machine issues two instructions single cycle must two sets operands ready place start cycle naturally increases demand registers popular techniques performing register allocation based graph coloring paradigm allocators construct graph representing constraints allocator must preserve using graph coloring techniques discover mapping values procedure registers target machine mapping must observe constraints first graph coloring allocator built chaitin colleagues 8 another approach called prioritybased coloring described chow hennessy 10 11 two techniques formed core around rich literature emerged see section 7 techniques used building graph coloring allocators improved recent years several important extensions chaitins basic techniques appeared 2 28 nevertheless problems remain practice problems appear either overspilling poor spill choice former case allocator fails keep value register even though register available throughout lifetime latter case allocator chooses wrong value keep register point code preliminary versions results appeared sigplan conference programming language design implementation 1989 1992 research supported ibm corporation darpa onr grant n0001491j1989 authors address department computer science rice university houston paper presents two improvements existing techniques register allocation via graph coloring improvements address specific problems observed use chaitinstyle chowstyle allocators notion abstracting storage allocation problems graph coloring dates early 1960s 26 see section 7 first implementation graph coloring register allocator done chaitin colleagues pl8 compiler 8 6 chow hennessy later described prioritybased scheme allocation based coloring paradigm 10 11 almost subsequent work coloringbased allocation followed one two papers work follows chaitins scheme discussion register allocation contain several implicit assumptions work assume allocator works lowlevel intermediate code assembly code code shaped optimization phase allocation code reference unlimited number registers call preallocation registers virtual registers allocator work virtual registers instead works distinct live ranges procedure single virtual register several distinct values interesting different parts program values become separate live range allocator discovers separate live ranges allocates physical registers target machine model register allocation graph coloring problem compiler first constructs interference graph g nodes g correspond live ranges edges represent interferences thus edge g node live range l node j l interferes l j simultaneously live point cannot occupy register 1 live ranges interfere particular live range l called neighbors l graph number neighbors degree denoted l ffi attractive feature chaitins approach machinespecific constraints register use represented directly graph 8 thus graph represents constraints embodied program presented target architecture single unified structure one key underlying insights graph coloring allocators interference graph represents constraints find allocation g compiler looks kcoloring g assignment k colors nodes g adjacent nodes always distinct colors choose k match number machine registers map kcoloring g feasible register assignment underlying code graph coloring npcomplete compiler uses heuristic method search coloring guaranteed find kcoloring kcolorable graphs kcoloring discovered values spilled values kept memory rather registers spilling one live ranges creates new different interference graph compiler proceeds iteratively spilling live ranges attempting color resulting new graph practice chaitin style allocator rarely requires three trips loop figure 1 illustrates chaitinstyle allocator proceeds seven phases 1 renumber systematically renames live ranges creates new live range definition point use point unions together live ranges reach use implementation models example classical disjoint set unionfind problem papers pl8 compiler type analysis called getting right number names8 hewlettpackard precision architecture compiler papers refer type analysis web analysis23 et al complete discussion interference 8 renumber build coalesce spill costs simplify select spill code oe figure allocator 2 build constructs interference graph implementation closely follows published descriptions pl8 allocator 8 6 interference graph simultaneously represented bitmatrix collection adjacency lists 3 coalesce attempts shrink number live ranges two live ranges l l j combined initial definition l j copy l otherwise interfere combining two live ranges eliminates copy instruction denote new live range l ij allocator combines l l j construct imprecise conservative approximation set interferences l ij conservative update lets allocator batch together many combining steps performs coalescing possible update repeats build coalesce coalescing changed graph 4 spill costs estimates live range runtime cost instructions would added item spilled spill cost estimated computing number loads stores would required spill live range operation weighted c theta 10 c operations cost target architecture instructions loopnesting depth 5 simplify constructs ordering nodes creates empty stack repeats following two steps graph empty exists node l l ffi edges graph place l stack coloring b otherwise choose node l spill remove l edges graph mark l spilled node marked spilling allocator inserts spill code see 7 repeats allocation process spilling required proceeds select see 6 6 select assigns colors nodes graph order determined simplify repeats following steps stack empty pop live range stack b insert corresponding node g c give color distinct neighbors 7 spill code invoked simplify decides spill node spilled live range converted collection tiny live ranges inserting loads uses stores definitions required understand works consider actions simplify select simplify moves l graph stack l ffi k live range meets condition trivially colorable receive color independent colors assigned neighbors thus simplify removes node prove node get assigned color live range removed degrees neighbors lowered turn may prove assigned colors select assigns colors nodes reverse order removal thus colors node graph trivially colorable simplify ordered stack must true one sense ordering colors constrained nodes first l gets colored l j precisely simplify proved l j colorable independent specific color chosen l example consider finding threecoloring simple graph shown figure 2 first simplify removes nodes need spill one possible sequence removals c b e next select reinserts nodes graph assigning colors node e inserted first given color say red next added get color except red running entire stack might result assignment e red blue b green c red blue decision spill live range made simplify allocator cannot find node trivially colorable selects node spill metric picking spill candidates important chaitin suggests choosing node smallest ratio spill cost divided current degree 6 chaitins heuristic guaranteed find minimal coloring guaranteed find kcoloring exists graph coloring npcomplete example suppose want find twocoloring diamond graph shown figure 2 clearly one exists example w red x blue blue z red applying simplify diamond graph presents immediate problem nodes degree less two thus node selected spilling spill costs equal allocator make arbitrary choice example x x removed graph marked spilling simplify remove remaining three nodes without spilling since node marked spill allocator must insert spill code rebuild interference graph try despite existence examples like diamond graph chaitins technique produces good allocations practice several factors contribute success allocation based global information form precise interference graph includes powerful mechanism remove unneeded copies coalescing finally uses spill costs guide generation spill code spill costs encode simple information controlflow graph improvements chaitins work retain properties part parascope programming environment built optimizing compiler fortran running uniprocessors 12 initial implementation included register allocator used chaitins technique described section 2 allocator worked well seemed produce satisfactory allocations ffifl ffifl e c simple graph z x diamond graph figure example graphs many long live ranges subroutine many deeplynested loops figure 3 structure svd required modest amounts time space compile time however debugged parts compiler discovered several cases produced obviously flawed allocations 31 motivating problem particularly interesting case arose code generated singular value decomposition svd golub reinsch actual code software library distributed forsythe malcolm molers book numerical methods 18 two hundred fourteen lines code excluding comments code contains thirtyseven doloops organized five different loop nests first loop nest simple array copy four larger complex loop nests follow figure 3 shows structure svd allocator spilled many short live ranges deference larger longer live ranges arraycopy loops spilled loop indices limits even though several registers unused loop study understood register allocator overspilled badly situations provoked behavior optimization dozen long live ranges extend initialization portion code large loop nests figure shows long live ranges span small arraycopy loops span much code high degree interference graph additionally large spill costs referenced often inside deeply nested loops restrict graph much allocator must spill live ranges initially allocator chooses spill indices limits arraycopy loops choice correct values smaller estimated spill costs longer live ranges allocator choose first unfortunately spilling help problem later loop nests alleviate demand registers large loop nests allocator must spill values proceeds eventually spills longer live ranges result unused registers arraycopy loops indices limits kept memory 32 improvement knowing allocator overspilled diamond graph svd reconsidered allocation process examples highlights different problem 1 diamond graph twocolorable see inspection allocator fails approximation uses decide whether x get color weak looking kcoloring allocator approximates x gets color x degree less k sufficient condition x get color necessary condition example x may k neighbors two neighbors may get assigned color precisely happens diamond graph 2 svd allocator must spill live ranges heuristic picking spill candidate selects small live ranges used shallow loop nests less expensive spill unfortunately spilling productive alleviate register pressure major loop nests time allocator makes decisions cannot recognize spills help similarly allocator cannot retract decisions later spilled live range stays spilled coloring heuristic explored matula beck finds twocoloring diamond graph 27 algorithm differs slightly chaitins approach simplify graph repeatedly remove node smallest current degree versus chaitins approach removing node n n k nodes removed select colors reverse order deletion fashion chaitin diamond graph heuristic generates twocoloring chaitins heuristic fails pessimistically assumes neighbors node get different colors matula becks heuristic discovers two coloring capitalize case two neighbors receive color unfortunately matula becks scheme simply finds coloring notion finding kcoloring particular k mechanism producing spill code real programs serious problem many procedures require spill code interference graphs simply kcolorable example svd routine must spill live ranges optimal coloring would eliminate spills wanted algorithm combined matula becks stronger coloring heuristic chaitins mechanism costguided spill selection achieve effect made two modifications chaitins original algorithm 1 simplify allocator removes nodes degree less k arbitrary order whenever discovers remaining nodes degree greater k chooses spill candidate node removed graph instead marking spilling simplify optimistically pushes stack hoping color available spite high degree thus removes nodes order chaitins allocator spill candidates included stack possible coloring 2 select allocator may discover color available node case leaves node uncolored continues next node uncolored node must node chaitins method would spill see consider graph node colored methods node n inserted graph removed chaitins method guarantees color available n method guarantees property nodes except spill candidates thus uncolored node must spill candidate node chaitin would spilled nodes receive colors allocation succeeded nodes uncolored allocator inserts spill code corresponding live ranges rebuilds interference graph tries resulting allocator shown figure 4 call optimistic allocator decision insert spill code occurs select rather simplify rest allocator unchanged chaitins scheme form allocator handle problems described head section deferring spill decision two powerful consequences first eliminates nonproductive spills chaitins scheme spill decisions made simplify nodes assigned colors selects node spill candidate live range spilled scheme spill candidates get placed stack nodes select discovers color available live range actually spilled mechanism effect allows allocator reconsider spill decisions second late spilling capitalizes specific details color assignment provide stronger coloring heuristic selecting color node x examines colors xs current neighbors provides direct measure x get color rather estimating answer x particular two xs neighbors receive color x may receive color even though x k optimistic allocator finds twocoloring diamond graph recall svd live ranges j n early spill candidates spill costs small however spilling alleviate register pressure inside major loop nests thus allocator must spill large live ranges happens small live ranges selected spill candidates placed stack small live ranges come stack select large live ranges spilled allocator easily determine colors available small live ranges early arraycopy loops optimistic coloring simple improvement chaitins pessimistic scheme assume two allocators one optimistic one pessimistic use spill metric example chaitins metric spill cost divided current degree optimistic allocator stronger coloring heuristic following sense color graph pessimistic allocator color graphs pessimistic allocator spilling necessary optimistic allocator spill subset live ranges spilled pessimistic allocator optimistic coloring helps generate better allocations cases eliminates spilling diamond graph one example many cases cost spilling reduced procedure executes fewer cycles due register spilling section 5 presents dynamic measurements improvement implementation technique backend ibm xl compiler family rs6000 architecture resulted decrease twenty percent estimated spill costs spec benchmark suite 22 renumber build coalesce spill costs simplify select spill code oe figure 4 optimistic allocator even optimistic coloring allocator must spill live ranges happens allocator choose least expensive mechanism accomplish spill particular recognize cases cheaper recompute value store retrieve memory consider code fragments shown figure 5 notation p means contents memory location addressed p source note p constant first loop varying second loop register allocator take advantage situation imagine high demand registers first loop forces p spilled column shows desired result upper loop p loaded needed using loadimmediate instruction lower loop p loaded loop using loadimmediate chaitin column illustrates code would produced chaitinstyle allocator entire live range p spilled memory loads inserted uses stores inserted definitions splitting final column shows code would expect splitting allocator 11 25 21 5 actual code might worse fact work rematerialization motivated problems observed experiments live range splitting 3 unfortunately examples sort discussed literature splitting allocators unclear best extend techniques achieve ideal solution section divides two major subsections first presents conceptual view approach rematerialization second discusses actual implementation allocator source chaitin store p reload p reload p store p splitting store p reload p reload p figure 5 rematerialization versus spilling 41 ideas chaitin et al discuss several ideas improving quality spill code 8 point certain values recomputed single instruction required operands always available computation call exceptional values neverkilled note values recalculated instead spilled reloaded note uncoalesced copy never killed value eliminated recomputing directly desired register 8 together techniques termed rematerialization practice opportunities rematerialization include immediate loads integer constants machines floatingpoint constants ffl computing constant offset frame pointer static dataarea pointer ffl loads known constant location either frame static dataarea ffl loading nonlocal frame pointers display values must cheaply computable operands available throughout procedure important understand distinction live ranges values live range may comprise several values connected common uses source column figure 5 p denotes single live range composed three values address label result expression subtly merge two values head second loop chaitins allocator correctly handles rematerialization spilling live range single value cannot handle complex cases like variable p figure 5 extended chaitins work take advantage rematerialization opportunities complex multivalued live ranges method tags value enough information allow allocator handle correctly achieve 1 split live range component values 2 tag value rematerialization information 3 form new live ranges connected values identical tags approach allows correct rematerialization multivalued live ranges introduces new problem minimizing unnecessary splits following sections describe find values propagate tags split live ranges remove unproductive splits discovering values find values construct procedures static single assignment ssa graph representation transforms code use value references exactly one definition 13 achieve goal construction technique inserts special definitions called oenodes points controlflow paths join different values merge actually use pruned ssa graph dead oenodes eliminated 9 natural way view ssa graph procedure collection values composed single definition one uses values definition either single instruction oenode merges two values examining defining instruction value recognize neverkilled values propagate information throughout ssa graph propagating rematerialization tags propagate tags use analog wegman zadecks sparse simple constant algorithm 31 2 modify lattice slightly represent necessary rematerialization information new lattice 2 powerful sparse conditional constant algorithm unnecessary earlier optimization eliminated controlflow paths would detect nonexecutable elements may one three types top means information known value defined copy instruction oenode initial tag inst value defined appropriate instruction neverkilled rematerialized values tag simply pointer instruction bottom means value must spilled restored value defined inappropriate instruction immediately tagged additionally meet operation u modified correspondingly new definition u u inst u inst inst inst inst u inst inst 6 inst j note inst inst j compares instructions operandbyoperand basis since instructions 2 operands modification affect asymptotic complexity propagation propagation value tagged particular inst values defined copy instruction tags lowered inst depending value flows copy tags values defined oenodes lowered inst values flowing node equivalent inst tags otherwise lowered process tags value ssa graph either instruction values tag spilling value requires normal heavyweight spill however tag instruction rematerialized issuing instruction specified tag lightweight spill tags used two later phases allocator spill costs uses tags compute accurate spill costs spill code uses tags emit desired code inserting splits propagation oenodes must removed values renamed recreate executable program consider example figure 6 source column simply repeats example introduced figure 5 ssa column shows effect inserting oenode p renaming different values comprising ps live range splits column illustrates copies necessary distinguish different values without oenodes final column minimal shows single copy required isolate neverkilled value p 0 values comprising p avoid extra copy noting p 1 identical tags propagation may treated together single live range p 12 similarly two connected values inst tag would combined single live range purposes rematerialization copies placed perfectly neverkilled value isolated copies introduced algorithm removing oenodes inserting copies described section 42 course allocator could insert copies suggested splits column form live range splitting idea discussed elsewhere 3 removing unproductive splits approach inserts minimal number copies required isolate neverkilled values nevertheless coloring make copies superfluous recall minimal column figure 6 neither p 0 spilled receive color copy connecting unnecessary real runtime cost copy eliminated whenever possible cannot simply use coalesce would remove copies losing desired separation values different tags therefore use pair limited coalescing mechanisms remove unproductive copies source ssa splits minimal figure 6 introducing splits conservative coalescing straightforward modification chaitins coalesce phase conceptually add single constraint coalesce combine two live ranges resulting single live range spilled biased coloring increases likelihood live ranges connected copy get assigned register conceptually select tries assign color two live ranges connected copy taken together two mechanisms remove unproductive copies 42 implementation chaitinstyle allocators extended naturally accommodate approach highlevel structure depicted figure 4 unchanged several lowlevel modifications required next sections discuss enhancements required renumber coalesce select renumber chaitins version renumber based defuse chains 8 long interest rematerialization adopted implementation strategy renumber based pruned ssa graph conceptually implementation four steps 1 determine liveness basic block using sparse dataflow evaluation graph 9 2 insert oenodes based dominance frontiers 13 avoid inserting dead oenodes 3 renumber operands every instruction refer values instead original virtual registers time accumulate availability information block intersection live avail needed block allow construction precise interference graph 8 4 form live ranges unioning together values reaching oenode using fast disjoint set union disjoint set structure maintained building interference graph coalescing coalesces union operations implementation steps 3 4 performed single walk dominator tree using techniques renumber completely avoids use bitvectored flow analysis despite apparent complexity algorithms involved fast practice requires modest amount space renumber already uses ssa graph modest changes required support rematerial ization modified renumber six steps 1 determine liveness basic block using sparse dataflow evaluation graph 2 insert oenodes based dominance frontiers still avoiding insertion dead oenodes 3 renumber operands instruction refer values time initialize rematerialization tags values 4 propagate tags using sparse simple constant algorithm modified section 41 5 examine copy instruction source destination values identical inst tags union remove copy 6 examine operands oenode operand value tag result value union values otherwise insert split distinguished copy instruction connecting values corresponding predecessor block steps 5 6 performed single walk dominator tree conservative coalescing prevent coalesce removing splits carefully introduced renumber must limit power specifically never coalesce split instruction resulting live range may spilled normal coalescing two live ranges l l j combined l j defined copy l otherwise interfere conservative coalescing add additional constraint combine two live ranges connected split l ij k neighbors significant degree significant degree means degree k understand restriction safe indeed conservative recall chaitins coloring heuristic 6 spilling nodes degree k removed graph node removed degrees neighbors reduced perhaps allowing removed process repeats graph empty remaining nodes degree k therefore node spilled must least k neighbors degree k initial graph practice perform two rounds coalescing initially possible copies coalesced split instructions graph rebuilt coalescing repeated copies removed begin conservatively coalescing split instructions repeatedly build interference graph attempt conservative coalescing splits removed theory intermix conservative coalescing unrestricted coalescing since result unrestricted coalesce may spilled example l l j might conservatively coalesced later coalesce l ij l k provoke spilling l ijk since significant degree l ijk may quite high practice may prove problem measured effect intermixing conservative coalescing unrestricted coalescing produce worse allocations would simplify speed entire process conservative coalescing directly improves allocation coalesce removes instruction resulting code split instruction introduced allocator regions little competition registers conservative coalescing undoes splitting however cannot undo nonproductive splits biased coloring second mechanism removing useless splits involves changing order colors considered assignment renumber inserts splits marks pairs values connected split partners select assigns color l first tries colors already assigned one l partners careful implementation expensive picking first available color really amounts biasing spectrum colors previous assignments l partners biasing mechanism combine live ranges conservative coalescing cannot example l might 2k neighbors significant degree neighbors might interfere thus might colored identically conservative coalescing cannot combine l partners resulting live range would many neighbors significant degree biasing may able combine l partners applied allocator shown live ranges receive colors late point allocation combining matter choosing right colors virtue late application biasing mechanism uses detailed level knowledge problem available earlier process example coalescing performed increase likelihood biasing match partners add limited lookahead picking color l uncolored partner l j allocator look color still available l j average l small number partners thus add limited lookahead biased coloring without increasing asymptotic complexity select implemented techniques optimizing compiler fortran compiler experimental code generators rtpc sparc i860 rs6000 experiment register allocation built series allocators independent particular architecture 3 experimental allocators work routines expressed iloc lowlevel intermediate language designed allow extensive optimization iloc routine assumes infinite register set rewritten terms particular target register set spill code added necessary target register set specified small table may varied allow convenient experimentation wide variety register sets allocation iloc routine translated complete c routine c routine compiled resulting object files linked complete program several advantages ffl inserting appropriate instrumentation translation c collect accurate dynamic measurements ffl compilation c allows us test single routine context complete program running real data ffl perform tests machineindependent fashion potentially using variety register sets simply timing actual machine code inherently machinedependent tends obscure effects allocation translation c add instrumentation count number times specific iloc instruction executed comparing register allocators interested number loads stores copies loadimmediates addimmediates figure 7 shows small sample iloc code corresponding c translation usually onetoone mapping iloc statements c translations though additional c required function header declarations register variables eg r14 f15 also note simple instrumentation appearing immediately several statements course sample simple majority iloc complex lle3 nop lla4 ldi r14 8 add r9 r15 r11 mvf f15 f0 bc l0023 l0023 lddrr f14 r14 r9 dabs f14 f14 dadd f15 f15 f14 addi r14 r14 8 sub r7 r10 r14 br ge r7 n6 n7 lle3 goto l0023 r7 figure 7 iloc c 51 target machine tests reported target machine defined sixteen integer registers sixteen floatingpoint registers floatingpoint register hold doubleprecision value distinction made singleprecision doubleprecision values held registers four integer registers may used pass arguments recall arguments passed reference fortran therefore argument registers hold pointers actual values remaining arguments passed stack frame function results returned integer floatingpoint register appropriate ten register class designated calleesaves remaining six including argument registers preserved callee reporting costs assume load store requires two cycles instructions assumed require one cycle course simple approximations costs real machine 52 spill costs since instrumentation reports dynamic counts loads stores etc need mechanism isolating instructions due allocation difficulty spills profitable cases allocator removes instructions eg copy instructions therefore tested routine hypothetical huge machine 128 registers assuming would give nearly perfect allocation difference huge results results one allocators targeted standard machine equal number cycles added allocator cope insufficient registers 53 results test suite collection seventy routines contained eleven programs eleven routines forsythe malcolm molers book numerical methods 18 grouped seven programs simple drivers remaining fiftynine routines spec benchmark suite 30 four spec programs used doduc 41 routines fpppp 12 routines matrix300 5 routines tomcatv routine two fortran programs suite spice nasa7 require language extensions yet supplied frontend results presented sequence comparisons two tables first two columns give program subroutine name third fourth column give observed spill costs two allocators compared costs calculated dynamic counts instructions described cycles spill code percentage contribution program routine original optimistic load store copy ldi addi total fmin fmin 551 370 seval spline 125 117 5 2 6 solve svd svd 2509 1977 doduc colbur deseco 5500 4957 inithx 714 579 11 4 4 19 lectur 257 221 prophy 1954 1531 13 9 0 21 repvid supp efill 173 94 21 sgemm table 1 effects optimistic coloring earlier last column total gives percentage improvement spill costs old allocator new one large positive numbers indicate significant improvements middle columns show contribution instruction type total percentages rounded nearest integer insignificant improvements reported 0 insignificant losses reported gamma0 cases result zero simply show blank since results rounded total entry may equal sum contributing entries table shows routines difference observed 3 consider first row table 1 row presents results routine fmin program fmin allocator using chaitins heuristic generated allocation requiring 551 cycles spill code optimistic allocator required 370 cycles 16 savings came execute fewer loads 16 arose fewer stores insignificant improvement due executing fewer loadimmediates total improvement 32 3 raw data tables given appendix briggs thesis 3 optimistic coloring table 1 shows comparison test results allocator using two different coloring heuristics column labeled original gives data version using chaitins coloring heuristic column labeled optimistic gives data version using optimistic coloring heuristic test suite 70 routines measured improvements 26 cases single loss extra load store required improvements ranged tiny quite large sometimes reducing spill costs 40 single loss disappointing since claimed optimistic coloring heuristic never spill chaitins heuristic however must recall structure allocator attempt color spill code inserted entire buildcoalescecolor process repeated optimistic coloring heuristic perform least well chaitins heuristic graph spilling two allocators facing different problems rematerialization table 2 summarizes effect new approach rematerialization compares two versions optimistic allocator differ handling neverkilled values column labeled optimistic gives data version uses chaitins limited approach rematerialization column labeled rematerialization gives data version incorporating new method entire suite 70 routines observed improvements 28 cases degradations cases one loss small 2 loads 2 stores extra copy somewhat larger improvements ranged tiny reasonably large many greater 20 course adjusting relative costs instruction especially loads stores change amount improvement expected see pattern fewer load instructions loadimmediates typically number stores number copies also reduced reduced number copy instructions suggests heuristics removing unhelpful splits adequate practice note reduction obtained spite extra copies introduced renumber 54 allocation costs improved allocations come cost compiletime case optimistic allocator coloring phase expensive due need attempt coloring even spill candidates discovered support rematerialization requires several extra steps extra pass code required initialize rematerialization tags propagation time required propagate tags throughout routine finally least one extra pass required accomplish conservative coalescing hand buildcoalesce process may slightly faster since eliminate copies renumber recall step 5 section 42 table 3 shows comparative timings three allocators three routines spec suite times given seconds measured 100 hertz clock unloaded ibm rs6000 model 540 run repeated 10 times results averaged first column shows phase allocation cfa stands controlflow analysis includes time required compute forward reverse dominators dominance frontiers build includes entire buildcoalesce loop color includes simplify select note tomcatv required extra rounds spilling original allocator optimistic allocator routine orig column gives times required allocator chaitins original coloring heuristic opt column gives times required optimistic allocator remat column gives times required optimistic allocator improved rematerialization selected three routines illustrate performance range sizes first routine repvid cycles spill code percentage contribution program routine optimistic rematerialization load store copy ldi addi total seval spline solve zeroin zeroin 236 doduc bilan 1046 966 5 3 8 bilsla colbur 19 24 gamma11 gamma11 gamma5 gamma26 debico drigl heat 34 inideb 50 48 4 4 inisla 28 lectur orgpar pastem 289 prophy repvid main table 2 effects rematerialization program doduc 144 noncomment lines fortran compiles text size 1284 bytes using ibms xlf compiler full optimization second routine tomcatv 133 lines text size 3064 bytes largest routine twldrv program fpppp 881 lines text size 15616 bytes three routines appear table 1 obvious conclusion draw data table 3 support rematerialization require small amount additional compiletime hand optimistic coloring heuristic little cost sometimes faster chaitins pessimistic heuristic results table 3 also illuminate number interesting details behavior three allocators ffl initial pass buildcoalesce loop dominates overall cost allocation noted chaitin comparison additional iterations colorspill process quite inexpensive ffl case cost renumber higher remat reflecting cost propagating rematerialization tags repvid tomcatv twldrv phase orig opt remat orig opt remat orig opt remat renum 04 03 04 06 06 07 56 56 62 build costs color spill renum build 06 06 06 09 09 12 62 61 81 costs color spill renum build costs color spill renum 02 02 03 build 06 05 09 costs color spill renum 02 build costs 01 color 02 total 40 39 47 97 85 113 1355 1365 1367 table allocation times seconds ffl cases cost buildcoalesce loop higher remat due additional passes conservative coalescing ffl low cost controlflow analysis illustrates speed practicality algorithm calculating dominance frontiers 13 ffl higher cost coloring first pass arises cost choosing nodes spill cost coloring linear size graph spill selection os delta n number spill choices n number nodes large number spills term dominates cost coloring pleased overall speed allocators results appear slightly faster times reported ibms xlf compiler register allocation comparable times reported optimization extensive comparison prioritybased coloring allocators appeared much slower small routines much faster large routines 3 course speeds competitive fast local techniques used nonoptimizing compilers 19 20 however believe global optimizations require global register allocation 6 implementation insight perform experiments described section 5 implemented several versions allocator natu rally gained insight implementation chaitinstyle graph coloring allocators section attempts convey ideas concise form hope proves useful implementors possible label insight particular phase allocator affects constant values rematerialization scheme suggests compiler represent constants way makes visible allocator current compiler integer constants obvious code loaded using integer load immediate instruction noninteger constants stored static constant pool loaded using fixed offset static data area pointer effectively hides rematerialization changing intermediate representation make values visible would expose rematerialization improving quality final code build like chaitin advocate building two representations interference bit matrix set adjacency vectors many implementations use single representation claim space savings however forms graph needed efficient execution allocator practice problems explosion size interference graph allocator runs reasonable amount space example interference graph tomcatv requires 146404 bytes graph twldrv requires 3357640 bytes 3 usually bit vectors iterative solution live variables problem large interference graphs actually fact led us sparse evaluation graph techniques choi cytron ferrante 9 coalescing coalescing transitive even though l l j interfere l l k interfere l ij interfere l k l j interferes l k thus order coalescing important coalescing proceed innermost loops outward insideout coalescing ensures copies deeply nested loops get removed copies outer loops practice makes noticeable difference many routines conservative coalescing biased coloring direct tradeoff strength conservative coalescing effectiveness biased coloring practice experimented several different restrictions coalescing precise ie less conservative restrictions coalescing increase set live ranges combine decreases number live ranges combined biased coloring unclear whether occurs precise coalescing condition restricts freedom graph combines live ranges biased coloring also catch case biased coloring cannot completely eliminate need conservative coalescing computing spill costs allocator spill costs always executed chaitins allocator waits must choose first value spill 7 approach merits live ranges negative spill costs suggests less expensive store reload keep registers allocator computes spill costs early aggressively removes live ranges negative spill cost chaitin defers computation spill costs allocator recognizes must spill speeds allocation procedures color without spilling additionally allocator skip spillcost computation live ranges already removed graph simplify rematerialization fundamentally changes allocator chaitinstyle allocators live ranges unrelated order removal trivially colored nodes little noticeable effect results allocation introduction splits isolate neverkilled values use biased coloring change fact gives new importance relative removal order trivially colored nodes faced multiple nodes removed select first remove nodes partners forces nodes partners colored first colored less constrained graph practice increases effectiveness biased coloring picking spill candidates introducing splits support rematerialization increases number nodes interference graph adversely effect running time simplify increasing time spent searching spill candidates described section 2 search spill candidate must examine node remaining current graph naive implementation repeats process spill spill metric includes nodes current degree thus choosing spill candidates takes ok number spills n number live ranges original graph undoubtedly careful algorithmic work improve situation practice refactored comparison noting l l costl replacing floatingpoint divisions integer multiplies improved constant factor limited backtracking select assigns colors nodes somewhat arbitrary manner biased coloring capitalizes fact carefully choosing order cases matters nonetheless improved color choice avoid spills optimistic allocator add limited form backtracking color available node p select consider recoloring one ps neighbors open color p backtracking must carefully constrained avoid combinatorial explosion examining ps neighbors determine available colors accumulate number uses color note neighbor uses color color remains p one colors used one ps neighbors select try recolor neighbor succeeds color available p limited backtracking easy implement takes little compile time rarely leads degradation 4 hand rarely leads significant improvement 3 also fits biased coloring however experience suggests limited lookahead see section 42 produces consistent improvement limited backtracking biased scheme npnoise testing often stumbled phenomenon label npnoise measuring output process involves heuristic solution npcomplete problem answers often contain behavior seems anomalous sometimes heuristic must pick set choices local cost different choices lead different answers allocator use lineartime heuristic find coloring decision tree perspective picks path tree time proportional height tree course tree exponential number nodes step picks based local information history previous choices remaining nodes changing local choice lead different global result thus simple things like ordering nodes ties broken actual color assignments produce variations output variations make difficult compare two competing allocators example table 2 rematerialization scheme produced worse code optimistic allocator chaitins scheme two routines colbur ddeflu doduc heuristic general better global behavior produce anomalous results specific cases effect may part account effects seen haifa group best three spilling scheme 2 smooth npnoise using three different spill metrics taking best result 4 never seen produce worse allocation though situations conceivable often better save expensive spill instead possibly saving lessexpensive spills future relationship economical use memory graph coloring discussed long time first paper subject appears lavrovs 1961 paper minimizing memory use 26 suggests building inconsistency graph coloring propose practical method finding coloring ershov colleagues built work alpha project solved storage allocation problems building interference graph using packing algorithm 14 15 late sixties cocke clearly talking applying insights directly register allocation kennedy schwartz credit insight 24 29 early work graph coloring register allocation emphasizes coloring problem little consideration questions spill choice placement algorithms cocke ershov reported schwartz 29 concerned exclusively minimizing number colors required discussion spill code flow graph ignored entirely first complete register allocator based upon graph coloring described chaitin colleagues 8 spilling handled variety heuristics based upon interval analysis flow graph unfortunately ad hoc techniques expensive always effective subsequent paper chaitin introduces simpler technique attempts solve spilling problem based interference graph spillcost estimates live range 6 section 2 describes allocator chow hennessy describe prioritybased coloring scheme 10 11 work values initially reside memory divide register set local global allocation build imprecise interference graph color constrained live ranges priority order priority function uses spill cost normalized live range length constrained live range cannot colored split smaller pieces try color independently fabri context work minimizing memory storage requirements introduces renaming transformation analogous chows live range splitting 16 notes cases splitting improved resulting coloring mentions applicability register allocation problems several groups refined chows approach larus hilfinger make several modifications 25 work values initially reside registers eliminate local allocation limit basic block sizes use sophisticated live range splitting technique gupta soffa steele describe approach partitions interference graph subgraphs colored individually later merged 21 hewlettpackard compiler group describe another prioritybased allocator 23 assign colors order decreasing degree interference graph must spill examine current live range assigned colors spill value minimal cost spill metric metric combines chaitins notion spill cost term includes impact keeping value register across loops live used implemented version algorithm believe scheme avoid problems like one observed svd routine hand spill live ranges chaitin proves trivially colored bernstein colleagues describe collection techniques 2 show bestofthree coloring scheme produces better results chaitins original scheme 5 impose largest degree first ordering removing unconstrained nodes graph simplify step 5a section 2 introduce cleaning heuristic decrease amount spill code generated within single basic block experience improvements orthogonal presented paper callahan koblenz construct finegrained hierarchical decomposition flow graph tiling 5 coloring performed individual tiles results merged two passes tree 5 see discussion npnoise section 6 one possible explanation behavior algorithm explicitly parallel course global allocators built graph coloring paradigm approaches include binpacking allocators built digital equipment corporation probabilistic allocator fischer proebsting 1 17 difficult compare techniques implementations work different intermediate representations follow different optimizers compilers target different machines optimistic coloring simple improvement chaitins original allocator produces allocation chaitins method except improves result results table 1 show happens regularly costs nearly identical occasionally one method require extra trip around main loop spill code insertion another paper shown optimistic allocators generate better allocations machines use register pairs values 4 implementation chaitinstyle allocator incorporate improvement makes significant difference allocation quality little cost method rematerializing neverkilled values finds maximum extents neverkilled value ensures allocator spill values least expensive way procedures never killed values must spilled result better code results table 2 show actually happens opportunities rematerialization exist features added rematerialization hurt additionally algorithms describe section 4 fast practical experience suggests asymptotically fast algorithms produce good compiletime performance acknowledgements ken kennedy participated early discussions coloring encouraged work start jorge pointed matulas algorithm mark krentel suggested coloring heuristic giving easily encouraged us try aggressive coloring heuristics greg chaitin ben chase john cocke marty hopkins bob hood ken kennedy chuck lins peter markstein tom murtagh randy scarborough rick simpson tom spillman matthew zaleski contributed work encouragement enlightened discussion colleagues parascope project rice provided us excellent testbed ideas people go heartfelt thanks r spill code minimization techniques optimizing compilers register allocation via graph coloring coloring register pairs register allocation via hierarchical graph coloring register allocation spilling via graph coloring register allocation spilling via graph coloring automatic construction sparse data flow evaluation graphs register allocation prioritybased coloring prioritybased coloring approach register allocation parascope parallel programming environment efficiently computing static single assignment form control dependence graph automatic storage optimization probabilistic register allocation computer methods mathematical computations retargetable compiler ansi c simple register spilling retargetable compiler register allocation via clique separators private communication effectiveness machinelevel global optimizer global flow analysis register allocation simple code structures register allocation spur lisp compiler store economy closed operator schemes graph coloring register allocation processors multiregister operands programming interim report setl project release 12 constant propagation conditional branches tr effectiveness machinelevel global optimizer register allocation spur lisp compiler spill code minimization techniques optimizing compliers register allocation via clique separators prioritybased coloring approach register allocation graph coloring register allocation processors multiregister operands automatic construction sparse data flow evaluation graphs constant propagation conditional branches register allocation via hierarchical graph coloring efficiently computing static single assignment form control dependence graph retargetable compiler ansi c coloring register pairs simple register spilling retargetable compiler probabilistic register allocation register allocation via graph coloring alphamyampersandmdashan automatic programming system high efficiency smallestlast ordering clustering graph coloring algorithms register allocation prioritybased coloring engineering compiler computers intractability computer methods mathematical computations automatic storage optimization register allocation myampersandamp spilling via graph coloring global flow analysis register allocation simple code structures ctr christian wimmer hanspeter mssenbck optimized interval splitting linear scan register allocator proceedings 1st acmusenix international conference virtual execution environments june 1112 2005 chicago il usa atsushi ohori register allocation proof transformation science computer programming v50 n13 p161187 march 2004 yoonseo choi hwansoo han optimal register reassignment register stack overflow minimization acm transactions architecture code optimization taco v3 n1 p90114 march 2006 suhyun kim soomook moon jinpyo park kemal ebciolu unrollbased register coalescing proceedings 14th international conference supercomputing p296305 may 0811 2000 santa fe new mexico united states sriraman tallam rajiv gupta bitwidth aware global register allocation acm sigplan notices v38 n1 p8596 january john lu keith cooper register promotion c programs acm sigplan notices v32 n5 p308319 may 1997 weijia li youtao zhang jun yang jiang zheng ucc updateconscious compilation energy efficiency wireless sensor networks acm sigplan notices v42 n6 june 2007 kun zhang tao zhang santosh pande binary translation improve energy efficiency postpass register reallocation proceedings 4th acm international conference embedded software september 2729 2004 pisa italy sreeranga p rajan masahiro fujita ashok sudarsanam sharad malik development optimizing compiler fujitsu fixedpoint digital signal processor proceedings seventh international workshop hardwaresoftware codesign p26 march 1999 rome italy bernhard scholz erik eckstein register allocation irregular architectures acm sigplan notices v37 n7 july 2002 omri traub glenn holloway michael smith quality speed linearscan register allocation acm sigplan notices v33 n5 p142151 may 1998 xiaotong zhuang santosh pande parallelizing loadstores dualbank memory embedded processors acm transactions embedded computing systems tecs v5 n3 p613657 august 2006 james shuler henry r bauer iii lookahead allocation presence branches proceedings 1997 acm symposium applied computing p504508 april 1997 san jose california united states michael paleczny christopher vick cliff click java hotspottm server compiler proceedings javatm virtual machine research technology symposium javatm virtual machine research technology symposium p11 april 2324 2001 monterey california ashok sudarsanam stan liao srinivas devadas analysis evaluation address arithmetic capabilities custom dsp architectures proceedings 34th annual conference design automation p287292 june 0913 1997 anaheim california united states daniel luna mikael pettersson konstantinos sagonas efficiently compiling functional language amd64 hipe experience proceedings 7th acm sigplan international conference principles practice declarative programming p176186 july 1113 2005 lisbon portugal kameswari v garigipati cindy norris evaluating use profiling regionbased register allocator proceedings 2002 acm symposium applied computing march 1114 2002 madrid spain akira koseki hideaki komatsu toshio nakatani preferencedirected graph coloring acm sigplan notices v37 n5 may 2002 christian w probst andreas gal michael franz average case vs worst case margins safety system design proceedings 2005 workshop new security paradigms september 2023 2005 lake arrowhead california christopher lupo kent wilken post register allocation spill code optimization proceedings international symposium code generation optimization p245255 march 2629 2006 andrew w appel lal george optimal spilling cisc machines registers acm sigplan notices v36 n5 p243253 may 2001 ivan baev richard e hank david h gross prematerialization reducing register pressure free proceedings 15th international conference parallel architectures compilation techniques september 1620 2006 seattle washington usa jinpyo park jehyung lee soomook moon register allocation banked register file acm sigplan notices v36 n8 p3947 aug 2001 lal george andrew w appel iterated register coalescing acm transactions programming languages systems toplas v18 n3 p300324 may 1996 lal george andrew w appel iterated register coalescing proceedings 23rd acm sigplansigact symposium principles programming languages p208218 january 2124 1996 st petersburg beach florida united states keith cooper philip j schielke devika subramanian optimizing reduced code space using genetic algorithms acm sigplan notices v34 n7 p19 july 1999 max hailperin comparing conservative coalescing criteria acm transactions programming languages systems toplas v27 n3 p571582 may 2005 daniel luna mikael pettersson konstantinos sagonas hipe amd64 proceedings 2004 acm sigplan workshop erlang p3847 september 2222 2004 snowbird utah usa yang sun chan g r gao roy ju gueiyuan lueh zhaoqing zhang interprocedural stacked register allocation itanium like architecture proceedings 17th annual international conference supercomputing june 2326 2003 san francisco ca usa ashok sudarsanam sharad malik masahiro fujita retargetable compilation methodology embedded digital signal processors using machinedependent code optimizaton library readings hardwaresoftware codesign kluwer academic publishers norwell 2001 thomas zeitlhofer bernhard wess listcoloring interval graphs application register assignment heterogeneous registerset architectures signal processing v83 n7 p14111425 july sathyanarayanan thammanur santosh pande fast memoryefficient register allocation framework embedded systems acm transactions programming languages systems toplas v26 n6 p938974 november 2004 michael smith norman ramsey glenn holloway generalized algorithm graphcoloring register allocation acm sigplan notices v39 n6 may 2004 jinpyo park soomook moon optimistic register coalescing acm transactions programming languages systems toplas v26 n4 p735765 july 2004 massimiliano poletto vivek sarkar linear scan register allocation acm transactions programming languages systems toplas v21 n5 p895913 sept 1999 changqing fu kent wilken faster optimal register allocator proceedings 35th annual acmieee international symposium microarchitecture november 1822 2002 istanbul turkey kreahling cindy norris profile assisted register allocation proceedings 2000 acm symposium applied computing p774781 march 2000 como italy johansson mikael pettersson konstantinos sagonas high performance erlang system proceedings 2nd acm sigplan international conference principles practice declarative programming p3243 september 2023 2000 montreal quebec canada jian wang andreas krall anton ertl christine eisenbeis software pipelining register allocation spilling proceedings 27th annual international symposium microarchitecture p9599 november 30december 02 1994 san jose california united states javier zalamea josep llosa eduard ayguad mateo valero register constrained modulo scheduling ieee transactions parallel distributed systems v15 n5 p417430 may 2004 josep llosa mateo valero eduard ayguad heuristics registerconstrained software pipelining proceedings 29th annual acmieee international symposium microarchitecture p250261 december 0204 1996 paris france martin farach vincenzo liberatore local register allocation proceedings ninth annual acmsiam symposium discrete algorithms p564573 january 2527 1998 san francisco california united states david koes seth copen goldstein progressive register allocator irregular architectures proceedings international symposium code generation optimization p269280 march 2023 2005 florent bouchez alain darte fabrice rastello complexity register coalescing proceedings international symposium code generation optimization p102114 march 1114 2007 tao zhang xiaotong zhuang santosh pande compiler optimizations reduce security overhead proceedings international symposium code generation optimization p346357 march 2629 2006 keith cooper anshuman dasgupta tailoring graphcoloring register allocation runtime compilation proceedings international symposium code generation optimization p3949 march 2629 2006 javier zalamea josep llosa eduard ayguad mateo valero improved spill code generation software pipelined loops acm sigplan notices v35 n5 p134144 may 2000 r govindarajan hongbo yang jos nelson amaral chihong zhang guang r gao minimum register instruction sequencing reduce register spills outoforder issue superscalar architectures ieee transactions computers v52 n1 p420 january wentsong shiue retargetable compilation low power proceedings ninth international symposium hardwaresoftware codesign p254259 april 2001 copenhagen denmark keith cooper l taylor simpson christopher vick operator strength reduction acm transactions programming languages systems toplas v23 n5 p603625 september 2001 keith farkas paul chow norman p jouppi zvonko vranesic multicluster architecture reducing processor cycle time partitioning international journal parallel programming v27 n5 p327356 oct 1999 matthias jacob keith h randall crossarchitectural performance portability java virtual machine implementation proceedings 2nd java virtual machine research technology symposium p7989 august 0102 2002 david ryan koes seth copen goldstein global progressive register allocator acm sigplan notices v41 n6 june 2006 keith farkas paul chow norman p jouppi zvonko vranesic multicluster architecture reducing cycle time partitioning proceedings 30th annual acmieee international symposium microarchitecture p149159 december 0103 1997 research triangle park north carolina united states wolfram amme jeffery von ronne michael franz ssabased mobile code implementation empirical evaluation acm transactions architecture code optimization taco v4 n2 p13es june 2007 jay bharadwaj william chen weihaw chuang gerolf hoflehner kishore menezes kalyan muthukumar jim pierce intel ia64 compiler code generator ieee micro v20 n5 p4453 september 2000 suhyun kim soomook moon jinpyo park kemal ebcioglu unrollbased copy elimination enhanced pipeline scheduling ieee transactions computers v51 n9 p977994 september 2002 tao zhang xiaotong zhuang santosh pande building intrusiontolerant secure software proceedings international symposium code generation optimization p255266 march 2023 2005 xavier leroy bytecode verification java smart cards softwarepractice experience v32 n4 p319340 10 april 2002 suganuma ogasawara k kawachiya takeuchi k ishizaki koseki inagaki yasue kawahito onodera h komatsu nakatani evolution java justintime compiler ia32 platforms ibm journal research development v48 n56 p767795 septembernovember 2004
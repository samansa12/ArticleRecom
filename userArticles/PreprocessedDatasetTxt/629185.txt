unified formalization four sharedmemory models authors present dataracefree1 sharedmemory model unifies four earliermodels weak ordering release consistency sequentially consistent specialoperations vax memory model dataracefree0 dataracefree1 unifies themodels weak ordering release consistency vax dataracefree0 byformalizing intuition programs synchronize explicitly correctly thensequential consistency guaranteed high performance manner retainsthe advantages four models dataracefree1 expresses programmersinterface explicitly formally weak ordering vax allows animplementation allowed weak ordering release consistency dataracefree0the implementation proposal dataracefree1 differs earlier implementations bypermitting execution synchronization operations processor even whileprevious data operations processor progress ensure sequentialconsistency two sychronizing processors exchange information delay later operationsof second processor conflict incomplete data operation firstprocessor b introduction memory model sharedmemory multiprocessor system formal specification memory operations program appear execute programmer particular memory model specifies values may returned read operations executed sharedmemory system paper presents new memory model dataracefree1 unifies four earlier models 1 although four models similar model different advantages disadvantages programmers system designers unifies four models retaining advantages four models uniprocessors provide simple memory model ensures memory operations appear execute one time order specified program program order thus read returns value last write program order location improve performance however uniprocessors often allow memory operations overlap memory operations issued executed program order uniprocessors use interlock logic maintain programmers model memory memory operations appear execute one time program order model uniprocessor memory therefore advantage simplicity yet allows high performance optimizations commonly often implicitly assumed memory model sharedmemory multiprocessor systems sequential consistency formalized lamport 21 follows definition 11 multiprocessor system sequentially consistent result execution operations processors executed sequential order operations individual processor appear sequence order specified program words sequentially consistent multiprocessor appears like multiprogrammed uniprocessor 24 although sequential consistency retains simplicity uniprocessor memory model limits performance preventing use several optimizations figure 1 shows multiprocessor systems without caches common uniprocessor hardware optimizations write buffers overlapped memory operations outoforder memory operations lockupfree caches 20 violate sequential consistency optimizations significantly improve performance become increasingly important future processor cycle times decrease memory latencies increase 13 gharachorloo et al described 1 earlier version work appears proceedings 17th annual international symposium computer architecture june 1990 1 dataracefree1 memory model developed paper extends dataracefree0 model 1 distinguishing unpaired synchronization operations paired release acquire synchronization opera tions definition dataracefree1 section 2 uses notions different operations distinguished distinction correct synchronizationorder1 happensbefore1 relations data races notions extensions similar concepts developed dataracefree0 also parallel work paper published technique detecting data races dataracefree1 system 2 consequently 2 reviews data races datarace memory model contains definitions slightly different form section 2 material used section 2 permission acm mechanisms allow optimizations used sequential consistency model mechanisms require hardware support prefetching rollback 12 initially figure 1 violation sequential consistency 2 shared variables r1 r2 local registers execution depicted violates sequential consistency since total order memory operations consistent program order lets p 1 p 2 return 0 reads x note neither processor data dependencies among instructions therefore simple interlock logic preclude either processor issuing second instruction first sharedbus systems without caches execution possible processors issue memory operations order allow reads pass writes write buffers systems general interconnection networks without caches execution possible even processors issue memory operations program order operations reach memory modules different order 21 sharedbus systems caches even cache coherence protocol 6 execution possible processors issue memory operations outoforder allow reads pass writes write buffers systems general interconnection networks caches execution possible even memory operations issued reach memory modules program order complete program order situation arise processors initially x caches processor issues read write propagates cache processor alternate memory models proposed improve performance sharedmemory systems useful new models satisfy following properties 1 model simple programmers use 2 model allow high performance central assumption work programmers prefer reason sequential consistency model since natural extension wellunderstood uniprocessor model therefore one way memory model satisfy first property appear sequentially consistent programs formally characterize group programs memory model satisfy second property allowing high performance optimizations guarantee sequential consistency group programs one group programs possible guarantee sequential consistency still use many optimizations programs explicitly distinguish synchronization memory operations operations used order operations data memory operations operations used read write data dichotomy 2 figure 1 modified version figure 1 1 presented permission ieee memory operations motivation behind four models weak ordering 9 release consistency sequentially consistent special operations henceforth called release consistency 11 vax 8 dataracefree0 originally called ordering respect dataracefree0 1 although four memory models similar small differences formalization lead differences way satisfy two properties weak ordering 9 release consistency 11 restrict hardware actually execute specific memory operations program order programmers authors ordering later stated mutual exclusion ensured access shared variable using constructs critical sections implemented hardwarerecognizable synchronization operations 10 26 authors release consistency formalize group programs called properly labeled pro grams release consistency ensures sequential consistency properly labeled program distinguishes memory operations depending use example distinguishes synchronization operations ordinary data operations vax dataracefree0 models differ weak ordering release consistency avoiding explicit restrictions actual order execution specific memory operations vax architecture handbook 8 data sharing synchronization section states following accesses explicitly shared data may written must synchronized accessing shared writable data programmer must acquire control data structure seven instructions provided permit interlocked access control variable dataracefree0 1 states sequential consistency provided dataracefree pro grams dataracefree program discussed formally sections 2 distinguishes synchronization operations data operations ensures conflicting data operations race ie cannot execute con currently programs contain data races dataracefree0 guarantee behavior hardware different formalizations four models result models satisfying simplicity highperformance property better models however model satisfies properties better models example vax imposes least restrictions hardware specification less explicit formal models consider statement accessing shared writable data programmer must acquire control data structure allow concurrent readers hardware behave programs satisfy specified conditions although may possible answer questions vax handbook explicit formal interface would allow straightforward unambiguous resolution questions release consistency hand provides formal explicit interface however section 4 show hardware requirements release consistency restrictive necessary paper defines new model dataracefree1 unifies weak ordering release consistency vax dataracefree0 models manner retains advantages models programmer hardware designer following summarizes dataracefree1 unifies four models overcomes specific disadvantages specific models programmer dataracefree1 unifies four models explicitly addressing two questions program correctly synchronized b hardware behave correctly synchronized pro answers questions formally intuition behind answers simple program correctly synchronized none sequentially consistent executions data race ie conflicting data operations execute concurrently b programs correctly synchronized hardware behaves sequentially consistent viewpoint practically provided release consistency dataracefree0 however explicit formal weak ordering vax eg allows concurrent readers form data race hardware designer dataracefree1 unifies four models shown section implementing models sufficient implement dataracefree1 furthermore dataracefree1 less restrictive either weak ordering release consistency dataracefree0 hardware designers since exists implementation dataracefree1 allowed weak ordering release consistency data racefree0 new implementation described section 4 differs implementations weak ordering release consistency allowing synchronization operations execute even previous data operations synchronizing processors incomplete achieve sequential consistency processors exchange information time synchronization ensures later operation may conflict incomplete data operation delayed data operation completes new implementation differs implementations data racefree0 distinguishing different types synchronization operations rest paper organized follows section 2 defines dataracefree1 sections 3 4 compare dataracefree1 weak ordering release consistency vax dataracefree0 models viewpoint programmer hardware designer respectively section 5 relates dataracefree1 models section 6 concludes paper 2 dataracefree1 memory model section 21 first clarifies common terminology used throughout paper informally motivates dataracefree1 memory model section 22 gives formal definition dataracefree1 data racefree1 extension earlier model dataracefree0 1 21 terminology motivation rest paper assumes following terminology terms system program operations definition 11 sequential consistency used several levels paper discusses memory models lowest level system machine hardware program set machinelevel instructions operation memory operation either reads memory location read operation modifies memory location write operation part machine instructions program program order execution partial order memory operations execution imposed program text 27 result execution refers values returned read operations execution sequentially consistent execution execution could occur sequentially consistent hardware two memory operations conflict least one write access location 27 motivation dataracefree1 similar weak ordering release consistency vax model dataracefree0 based following observations made 1 3 assuming processors maintain uniprocessor data control dependencies sequential consistency violated two processors interact memory operations common locations interactions classified data memory operations synchronization memory operations data operations usually frequent involve reading writing data synchronization operations usually less frequent used order conflicting data operations different processors example implementation critical section using semaphores test semaphore unset clear semaphore synchronization operations reads writes critical section data operations additionally synchronization operations characterized paired acquire release synchronization operations unpaired synchronization operations follows characterization similar used properly labeled programs release consistency 11 section 3 discusses differences execution consider write read synchronization operation location read returns value write value used reading processor conclude completion memory operations writing processor write program interaction write synchronization operation called release read synchronization operation called acquire release acquire said paired synchronization operation unpaired paired synchronization operation execution example consider implementation critical section using semaphores semaphore tested testset instruction cleared unset instruction write due unset paired test returns unset value unset write release operation 3 observations paraphrased 1 permission ieee test read acquire operation unset value returned test used conclude completion memory operations previous invocation critical section write due set testset read due test testset returns set value unpaired operations read acquire write release set value communicate completion previous memory operations illustrated section 4 possible ensure sequential consistency placing hardware restrictions synchronization operations synchronization operations paired operations require restrictions thus hardware could distinguish type operation could complete data operations faster operations unpaired synchronization operations faster paired synchronization operations without violating sequential consistency dataracefree1 system gives programmers option distinguishing types operations enable higher performance 22 definition dataracefree1 section 21 informally characterized memory operations based function perform indicated distinguishing memory operations based characterization higher performance obtained without violating sequential consistency section first discusses memory operations distinguished based characterization dataracefree1 system gives formal criterion operations distinguished correctly dataracefree1 section concludes definition dataracefree1 memory model impose restrictions different memory operations may dis tinguished one option distinguishing data operations synchronization operations hardware provide different instructions may used type operation example special instructions testset unset may used generate synchronization operations alternatively operations certain memorymapped locations may distinguished synchronization operations one way distinguishing paired unpaired synchronization operations hardware provide special instructions synchronization operations static pairable relation instructions write read execution distinguished hardware paired release acquire generated instructions related pairable relation read returns value write figure 2 gives examples different instructions pairable relation illustrates use following discusses programmer distinguishes operations correctly dataracefree1 operations distinguished exactly according function outlined section 21 distinction indeed correct however dataracefree1 require programmer distinguish operations match syncreadflag testsets b fetchinccount fetchinccount syncwriteflag fetch inc syncwrite unsets testsets unsets test testset set testset unset testsets unsets data ops critical section data ops barrier code barrier fetchinccount n data ops barrier testsets code critical setion sync read acquire acquire release release syncreadflag localflag whilesyncreadflag localflag else figure 2 synchronization instructions pairable relation different systems figures 2a 2b represent two systems different sets instructions used synchronization operations system figure shows different synchronization operations pairable relation along programs executions use operations table figure lists read synchronization operations potential acquires horizontally write synchronization operations potential releases verti cally indicates synchronization operations corresponding row column pairable paired execution read returns value written write execution executions occur sequentially consistent hardware operations execute order shown opx denotes operation op location x dataread datawrite denote data operations testset fetchinc 17 instructions defined atomic instructions read write operations represented together testsetx fetchincx paired operations connected arrows figure 2a shows system testset unset instructions useful implement critical sec tion testset atomically reads memory location updates value 1 unset updates memory location value 0 write due unset read due testset pairable figure shows code critical section execution involving two processors figure 2b shows system fetchinc 17 syncwrite syncread instructions useful implement barrier fetchinc atomically reads increments memory location syncwrite synchronization write updates memory location specified value syncread synchronization read memory location write due fetchinc pairable read due another fetchinc write due syncwrite pairable read due syncread also shown code n processors synchronize barrier 23 execution 2 variable localflag implemented local register processor operations shown execution function exactly absence precise knowledge regarding function operation programmer conservatively distinguish operation synchronization operation even operation actually performs function data operation sequential consistency still guaranteed although full performance potential system may exploited henceforth characterization operation one distinguished programmer may different based actual function operation per forms example operation actually data operation programmer uses synchronization instruction referred synchronization operation intuitively operations distinguished correctly dataracefree1 sufficient synchronization operations distinguished releases acquires criteria sufficiency operation distinguished data involved race ie program dataracefree notion data race formalized defining happensbefore1 relation every execution program follows happensbefore1 relation execution partial order memory operations execution informally happensbefore1 orders two operations initiated different processors paired release acquire operations execute definition 22 formalizes intuition using program order synchronizationorder1 relations definition 21 definition 21 execution memory operation 1 ordered memory operation 2 relation 1 release operation 2 acquire operation paired definition 22 happensbefore1 relation execution irreflexive transitive closure program order synchronizationorder1 relations execution definitions data race dataracefree program dataracefree1 model follow definition 23 data race execution pair conflicting operations least one data ordered happensbefore1 relation defined execution execution dataracefree data races program dataracefree sequentially consistent executions dataracefree definition 24 hardware obeys data race free 1 memory model result every execution dataracefree program hardware obtained execution program sequentially consistent hardware figures 3a 3b illustrate executions respectively exhibit exhibit data races execution figure 3a implementation critical section code figure 2a except programmer used data operation instead unset synchronization operation p 0 write therefore happensbefore1 order p 0 write x p 1 read x since write read x conflict data opera tions form data race similar reasons p 0 data write forms data race p 1 test set data write figure 3b shows execution barrier code figure 2b execution dataracefree happensbefore1 orders conflicting pairs operations least one pair data note execution figure 3b use critical sections therefore dataracefree1 require sharing done critical sections also note programs based asynchronous algorithms operations access data ordered synchronization programs data racefree operations also need distinguished synchronization operations syncreadflag testsets b fetchinccount fetchinccount syncwriteflag testsets syncreadflag po po po po po po po po po so1 so1 po po po figure 3 executions exhibit b exhibit data races discussed section 21 definition dataracefree1 assumes program uses machine instructions hardwaredefined synchronization primitives however programmers using highlevel parallel programming languages use dataracefree1 extending definition dataracefree highlevel programs discussed dataracefree0 1 extension straightforward requires highlevel parallel languages provide special constructs synchronization eg semaphores monitors forkjoins task ren dezvous dataracefree1 place restrictions highlevel synchronization mechanisms responsibility compiler ensure program dataracefree highlevel compiles one dataracefree machinelevel ensuring sequential consistency programmer 3 vs weak ordering release consistency vax model dataracefree0 programmers section compares dataracefree1 memory model weak ordering release consistency vax dataracefree0 programmers viewpoint stated earlier central assumption work programmers prefer reason sequential consistency programmers dataracefree1 provides simple model program dataracefree hardware appear sequentially consistent weak ordering vax memory model state programs obey certain conditions hardware wellbehaved however sometimes interpretation may needed deduce whether program obeys required conditions concurrent readers case section 1 hardware behave programs obey required conditions dataracefree1 expresses aspects explicitly formally weak ordering vax dataracefree1 states program datarace free hardware appears sequentially consistent programs dataracefree release consistency provide formal interface programmers dataracefree1 provides similar interface minor differences programs dataracefree0 ensures sequential consistency also called dataracefree programs 1 difference dataracefree0 distinguish different synchronization operations effectively pairs conflicting synchronization operations depending order execute distinction significantly affect programmers exploited hardware designers programs release consistency ensures sequential consistency called properly labeled programs 11 dataracefree programs properly labeled properly labeled programs dataracefree defined definition 24 15 difference minor arises properly labeled programs less explicit notion pairing allow conflicting data operations ordered operations nsyncs correspond nonpairable synchronization operations dataracefree1 although memory model allows hardware guarantees sequential consistency properly labeled programs formally described model would similar dataracefree1 similarity dataracefree properly labeled programs potential disadvantage dataracefree1 relative weak ordering release consistency programmers asynchronous algorithms rely sequential consistency correctness 7 weak ordering release consistency provide programmers option reasoning explicit hardware conditions writing programs dataracefree work correctly possibly faster dataracefree1 based assumption programmers prefer reason sequential consistency therefore restrict behavior hardware program dataracefree nevertheless maximum performance programmers asynchronous algorithms could deal directly specific implementations dataracefree1 would entail risk portability across dataracefree1 implementations would enable future faster implementations common programs summarize programmers dataracefree1 similar release consistency dataracefree0 provides explicit formal interface weak ordering vax model previous work discusses requirement dataracefree programs models restrictive programmers 1 11 data races 2 violations sequential consistency due data races 14 may dynamically detected models 4 vs weak ordering release consistency vax model dataracefree0 hardware designers section compares dataracefree1 weak ordering release consistency vax model data racefree0 hardware designers viewpoint first shows dataracefree1 unifies four models hardware designer implementation weak ordering release consistency vax model data racefree0 obeys dataracefree1 section 41 shows dataracefree1 less restrictive weak release consistency dataracefree0 hardware designer dataracefree1 allows implementation allowed weak ordering release consistency dataracefree0 section 42 41 unifies weak ordering release consistency vax model datarace free0 hardware designers hardware designer dataracefree1 unifies release consistency dataracefree0 weak ordering vax model implementation four models obeys dataracefree1 specifically implementations release consistency obey dataracefree1 discussed section 3 implementations release consistency ensure sequential consistency dataracefree programs implementations dataracefree0 obey dataracefree1 discussed section 3 implementations dataracefree0 ensure sequential consistency dataracefree programs implementations weak ordering obey dataracefree1 earlier work shows implementations weak ordering obey dataracefree0 1 argument implementations dataracefree0 obey dataracefree1 dataracefree1 formalizes vax model therefore implementations vax model obey data racefree1 42 dataracefree1 less restrictive weak ordering release consistency dataracefree0 hardware designers less restrictive hardware designer implement either weak ordering release consistency dataracefree0 dataracefree1 allows implementation allowed weak release consistency dataracefree0 figure 4 motivates implementation figure shows part execution two processors execute critical section code figure 2a processors p 0 p 1 testset succeed execute data operations including one location x finally unset critical section code dataracefree therefore executions dataracefree1 implementation appear sequentially consistent execution figure 4 p 0 testset succeeds first therefore p 1 testset succeeds returns value written p 0 unset thus appear sequentially consistent p 1 data read x return value written p 0 data write x figure 4 shows implementations weak release consistency dataracefree1 achieve unsets testsets wo stalls p0 datawrite completes wo rc stall p1 unset therefore datawrite drf1 delays dataread datawrite completes testsets rc delays unset datawrite completes drf1 stalls p1 unset po po po po po po po so1 need never stall p0 delay operations testsets po unsets po po po release consistency figure 4 implementations memory models weak ordering release consistency require p 0 delay execution unset p 0 data completes ie seen processors however delay necessary maintain sequential consistency also observed zucker 28 imposed implementation proposal datarace described next instead implementation maintains sequential consistency requiring p 0 data write x completes p 1 executes data read x achieves ensuring p 1 executes testset p 0 notifies p 1 incomplete write x ii p 1 delays read x p 0 write x completes new optimization p 0 execute unset earlier p 1 testset succeed earlier weak ordering release consistency thus p 1 reads writes following testset program order conflict previous operations p 0 also complete earlier operations data read x conflict previous operations p 0 may delayed p 0 corresponding operation completes nevertheless operations also complete earlier weak ordering release consistency example p 1 read x occurs late enough program p 0 write may already complete p 1 examines read therefore read proceed without delay recently implementation release consistency proposed uses rollback mechanism let processor conditionally execute reads following acquire p 1 testset acquire completes 12 optimization benefit implementations also allows writes following acquire issued completed earlier lets reads following acquire committed earlier dataracefree1 implementation differs dataracefree0 implementations dataracefree distinguishes unset testset synchronization operations take different actions dataracefree0 make distinctions section 421 describes sufficient condition implementing dataracefree1 based motiva tion section 422 gives detailed implementation proposal based conditions 421 sufficient conditions hardware obeys dataracefree1 memory model result execution dataracefree program hardware obtained sequentially consistent execution program result execution set values read operations return section 21 value returned read value write location seen last reading processor thus value returned read depends order reading processor sees read respect writes location ie order processor sees conflicting operations thus hardware dataracefree1 obeys following conditions conditions hardware dataracefree1 every execution e data racefree program hardware operations execution e sequentially consistent execution program ii order two conflicting operations seen processor execution e sequentially consistent execution processor sees write read executed processor location write return value subsequent write processor sees read read returns value notions similar performed respect processor performed 9 following gives three requirements data synchronization control together sufficient hardware satisfy dataracefree1 conditions therefore obey dataracefree1 data requirement pertains pairs conflicting operations dataracefree program least one operations data operation execution sequentially consistent hardware pair operations ordered happensbefore1 relation execution seen processors order data requirement execution dataracefree1 hardware pairs operations continue seen processors happensbefore1 order execution requirement ensures figure 4 p 1 sees p 0 write x read x based discussion figure 4 data requirement conditions meet data requirement pair conflicting operations different processors conflicting operations processor sufficient maintain intraprocessor data dependencies conditions assume maintained rest section preceding following refer ordering program order operation either synchronization data completes performs 9 seen defined processors data requirement conditions let rel acq release acquire operations issued processors p rel p acq respectively let rel acq paired prerelease condition p rel issues rel remembers operations preceding rel incomplete releaseacquire condition acq completes p rel transfers p acq addresses identity remembered operations ii acq completes rel completes operations transferred p rel p rel acquires preceding rel complete postacquire condition let acq precede program order let operation x transferred p acq acq issued acq completes ii x conflict issued completes data requirement conditions proved correct showing ensure x conflicting operations different processors happensbefore1 orders x x completes processor sees implies processors see x meeting data requirement execution figure 4 prerelease condition ensures p 0 executes unset remembers incomplete releaseacquire condition ensures p 1 executes successful testset transfers address x p 1 postacquire condition ensures p 1 detects delay completes enforces delay thus datareadx returns value written besides data requirement dataracefree1 conditions also require order two conflicting synchronization operations seen processor sequentially consistent hardware synchronization requirement data synchronization requirements would suffice satisfy data conditions also guaranteed execution e hardware obeyed requirements sequentially consistent execution operations happensbefore 1 order execution conflicting synchronization operations e absence control flow operations branches automatically ensured presence control flow operations ever extra requirement called control requirement needed ensure 3 weak ordering release consistency proposed implementations dataracefree0 satisfy synchronization requirement explicitly control requirement implicitly requiring uniprocessor control dependencies maintained since key difference implementations earlier models new implementation dataracefree1 data requirement following describes implementation proposal data requirement conditions 3 formalize three requirements give explicit conditions synchronization control requirements conservative way satisfy synchronization requirement processor also stall issue synchronization operation completion preceding synchronization operations write operations whose values returned preceding synchronization read operations conservative way satisfy control requirement processor also block read controls program flow read completes note optimizations data requirement conditions implementation following section possible 3 example releaseacquire condition acquire complete even operations transferred releasing processor incomplete long releasing processor transfers identity incomplete operations acquiring processor postacquire condition necessary delay operation following acquire conflicting operation x transferred acquiring processor completes instead sufficient delay x seen acquiring processor long mechanism cachecoherence protocol ensures writes location seen order processors thus releasing processor also transfer values written incomplete writes reads following acquire use transferred values need delayed 422 implementation proposal dataracefree1 obey weak ordering release con sistency dataracefree0 section describes implementation proposal data requirement conditions proposal assumes arbitrarily large sharedmemory system every processor independent cache processors connected memory arbitrary interconnection network proposal also assumes directorybased writeback invalidation ownership hardware cachecoherence protocol similar respects discussed agarwal et al 4 one significant feature protocol invalidations sent write line readonly shared state acknowledged invalidated processors cachecoherence protocol ensures operations eventually seen processors b writes location seen order processors c processor detect operation issues complete c operations complete issuing processor receives requested line cache however write data synchronization line readonly shared state completes invalidated processors send acknowledgements either writing processor may directly receive ack nowledgements directory may collect forward single message writing processor indicate completion write implementation proposal involves adding following four features uniprocessorbased processor logic base cachecoherence logic mentioned tables 1 2 summarize features addition three buffers per processor incomplete reserve special table 1 modification issue logic delay issue stall certain operations table 2a modification cachecoherence logic allow processor retain ownership line processors reserve buffer specially handle paired acquires line table 2b new processortoprocessor message called empty special buffer table 2c discussion explains features used implement prerelease release acquire postacquire parts data requirement conditions recall preceding following refer ordering program order prerelease condition processor must remember operations preceding releases incomplete processor uses incomplete buffer store address incomplete data opera tions release issued preceding synchronization operations complete prevent deadlock preceding data operations issued thus incomplete buffer remembers operations required prerelease condition distinguish operations preceding following release entries incomplete buffer may tagged multiple incomplete buffers may used releaseacquire condition acquire cannot complete following occurred regarding release paired acquire release complete b operations received releasing processor acquires preceding release complete c releasing processor transfers new acquiring processor addresses incomplete operations preceding release purpose every processor uses reserve buffer store processors releases conditions hold release write operation releasing processor procures ownership released line processor give ownership address line reserve buffer consequently cachecoherence protocol forwards subsequent requests line including acquires paired release releasing buffer contents purpose incomplete incomplete data operations processor used remember incomplete operations processor preceding release pro cessor reserve releases processor incomplete operations used remember releases processor may cause future paired acquires processors need special attention special incomplete operations another processor received acquire processor used identify operation proces requires special action due early completion acquire processor contents purpose buffers buffer insertions deletions event entry inserted event entry deleted incomplete data miss address data operation data miss complete address data operation reserve release issued address release operation release com pletes operations preceding release complete ie deleted incomplete buffer special buffer empties address release operation special acquire completes addresses received acquire empty special buffer message arrives entries b insertion deletion actions buffers table 1 key buffers aggressive implementation dataracefree1 processor releasing processor stall acquires paired release conditions b c met table 2b gives details base cachecoherence logic modified allow releasing processor retain ownership released line reserve buffer service acquires paired release b c met retain ownership released line releasing processor stalls release operations processors line performs remote service external requests line remote service mechanism allows releasing processor service requests address operation special buffer action process usual data unpaired synchronization release issue previous operations issued previous synchronization operations complete acquire issue special buffer empties stall acquire completes yes stall delay issue operation special buffer empties modification issue logic address request reserve buffer action requests processor process usual process usual read write cache line replace ment stall processor address deleted reserve buffer requests processors forwarded processor process usual release stall request address deleted reserve buffer acquire stall request special buffer empties paired release reserve buffer completes send acquiring processor released line entries incomplete buffer tagged preceding release request acquiring processor cache line inform directory processor retaining ownership data unpaired synchronization read request send line processor write request update line processors cache send acknowledgement pro request processor cache line inform directory processor retaining ownership b modification cachecoherence logic processor event message incomplete buffer entries corresponding release deleted send empty special buffer message processors executed acquires paired release c new processortoprocessor message table 2 aggressive implementation dataracefree1 processors without allowing processors cache line mechanisms stalling operations external release remote service external operations necessary stalling data operations lead deadlock servicing external release operations remotely would let new releasing processors procure ownership line required releaseacquire condition meeting conditions b c requires processor wait release complete special buffer empty transfer contents incomplete buffer acquiring processor postacquire condition processor must stall acquire completes b delay following operation completion conflicting operation transferred acquire pur pose processor uses special buffer save information transferred acquire following operation conflicts operation stored special buffer processor either stall b delay operation receives empty special buffer message releasing processor releasing processor sends empty special buffer message deletes address release paired acquire reserve buffer simplicity acquiring processor also stall acquire special buffer empties avoid complexity delay operation incomplete operations multiple processors completes implementation proposal data requirement conditions assuming process runs uninterrupted processor handle context switches correctly processor must stall switching various buffers mentioned empty overflow buffers also handled making processor stall entry deleted relevant buffer proposal never leads deadlock livelock long underlying cachecoherence protocol implemented correctly messages lost network timeout initiates system cleanup generated lost message specifically proposal never stalls memory operation indefinitely since proposal never delays completion issued data operations ii proposal delays operation certain issued data operations incomplete thus proposal lead deadlock livelock 5 vs models previous sections shown dataracefree1 memory model unifies weak ordering release con sistency vax model dataracefree0 section first summarizes memory models proposed literature examines dataracefree1 relates ibm 370 memory model 19 guarantees except write followed read different loca tion operations single processor appear execute program order writes appear execute atomically 370 also provides serialization operations executing serialization operation processor completes operations serialization operation according program order executing nonserialization operation processor completes serialization operations nonserializa tion operation according program order processor consistency 11 16 pram 22 total store ordering 25 models ensure writes given processor appear execute order processors models mainly differ whether write appears become visible processors simultaneously different times partial store ordering model 25 similar total store ordering except orders writes processor separated store barrier operation model known release consistency processorconsistent special operations 11 similar release consistency sequentially consistent special operations except requires special operations syncs nsyncs processorconsistent concurrentconsistency model 26 ensures sequential consistency programs except explicitly test sequential consistency take access timings consideration slow memory model 18 requires read return value previous conflicting write value written say processor p read values earlier conflicting writes p cannot returned causal memory model 5 18 ensures write causally precedes read observed read causal precedence transitive relation established program order due read returns value write based assumption programmers prefer reason sequential con sistency concurrent consistency model explicitly states programmers expect sequential consistency however conditions give sequential consistency seem ambiguous difficult relate directly dataracefree1 370 model explicitly state programmers expect sequential consistency however previous sections dataracefree1 used determine sufficient condition follows serialization operations analogous synchronization operations weak order ing therefore 370 appears sequentially consistent dataracefree programs serialization operations access memory interpreted synchronization operations every write serialization operation pair able every read serialization operation remaining models difficult determine exactly programmers expect sequential con sistency assumption programmers prefer reason sequential consistency true stated models harder reason dataracefree1 future hope specify models using approach dataracefree1 ie specify models terms formal set constraints programs hardware appears sequentially consistent programs obey constraints call approach sequential consistency normal form investigate specifications provide greater insight lead unifications 6 conclusions many programmers sharedmemory systems implicitly assume model sequential consistency shared memory unfortunately sequential consistency restricts use many high performance uniprocessor optimizations higher performance several alternate memory models proposed models 1 simple reason 2 provide high performance believe programmers prefer reason sequential consistency therefore way satisfy properties model appear sequentially consistent common programs give programs highest performance possi ble models weak ordering release consistency sequentially consistent special operations vax dataracefree0 based common intuition programmers distinguish data synchronization operations correct execution guaranteed along high performance however model formalizes intuition differently different advantages disadvantages respect models paper proposed memory model dataracefree1 unifies weak ordering release consistency vax model dataracefree0 retains advantages hardware dataracefree1 appears sequentially consistent programs dataracefree dataracefree1 unifies four models providing programmers view similar four models permitting hardware allowed four models compared weak ordering dataracefree1 provides formal interface programmers since explicitly states program correctly synchronized dataracefree hardware behaves correctly synchronized programs sequentially consistent also dataracefree1 less restrictive weak ordering hardware designers since allows implementation weak ordering allow compared release consistency dataracefree1 less restrictive hardware designers since allows implementation release consistency allow compared vax model dataracefree1 provides formal interface since explicitly states program correctly synchronized hardware behaves correctly synchronized programs compared dataracefree0 dataracefree1 less restrictive hardware designers since allows implementations take different actions different types synchronization operations acknowledgements immensely grateful dr harold stone editor advice patience several revisions paper also grateful anonymous referees many comments suggestions improved work considerably thank kourosh gharachorloo many insightful discussions memory models comments earlier drafts paper also thank vikram adve brian bershad allan gottlieb ross johnson alex klaiber jim larus david wood richard zucker valuable comments earlier drafts paper r weak ordering new definition detecting data races weak memory systems sufficient conditions implementing dataracefree1 memory model evaluation directory schemes cache coherence implementing programming causal distributed shared memory evaluation using multiprocessor simulation model asynchronous parallel successive overrelaxation symmetric linear complementarity problem memory access buffering multiprocessors memory access dependencies sharedmemory multiprocessor memory consistency event ordering scalable sharedmemory multiprocessors two techniques enhance performance memory consistency models performance evaluation memory consistency models sharedmemory multiprocessors detecting violations proving computer sciences technical report nyu ultracomputer designing mimd shared memory parallel computer weakening consistency enhance concurrency distributed shared memories make multiprocessor computer correctly executes multiprocess programs pram scalable shared memory algorithms scalable synchronization sharedmemory multiprocessors seminar texas instruments research labs dallas access ordering coherence shared memory multiprocessors efficient correct execution parallel programs share memory study weak consistency models tr cache coherence protocols evaluation using multiprocessor simulation model memory access buffering multiprocessors efficient correct execution parallel programs share memory evaluation directory schemes cache coherence asynchronous parallel successive overrelaxation symmetric linear complementarity problem access ordering coherence shared memory multiprocessors memory access dependencies sharedmemory multiprocessors algorithms scalable synchronization sharedmemory multiprocessors performance evaluation memory consistency models sharedmemory multiprocessors proving sequential consistency highperformance shared memories extended abstract detecting violations sequential consistency detecting data races weak memory systems weak orderingmyampersandmdasha new definition memory consistency event ordering scalable sharedmemory multiprocessors lockupfree instruction fetchprefetch cache organization ctr honghui lu alan l cox willy zwaenepoel contention elimination replication sequential sections distributed shared memory programs acm sigplan notices v36 n7 p5361 july 2001 alvaro e campos juan e navarro pagecoherent causally consistent protocol distributed shared memory journal systems software v72 n3 p305319 august 2004 l cox dwarkadas p keleher h lu r rajamony w zwaenepoel software versus hardware sharedmemory implementation case study acm sigarch computer architecture news v22 n2 p106117 april 1994 leonidas kontothanassis michael l scott ricardo bianchini lazy release consistency hardwarecoherent multiprocessors proceedings 1995 acmieee conference supercomputing cdrom p61es december 0408 1995 san diego california united states neves miguel castro paulo guedes checkpoint protocol entry consistent shared memory system proceedings thirteenth annual acm symposium principles distributed computing p121129 august 1417 1994 los angeles california united states chong kai hwang performance analysis four memory consistency models multithreaded multiprocessors ieee transactions parallel distributed systems v6 n10 p10851099 october 1995 povl koch robert j fowler eric jul messagedriven relaxed consistency software distributed shared memory proceedings 1st usenix conference operating systems design implementation p7es november 1417 1994 monterey california jos f martnez josep torrellas speculative synchronization applying threadlevel speculation explicitly parallel applications acm sigops operating systems review v36 n5 december 2002 james r larus brad richards guhan viswanathan lcm memory system support parallel language implementation acm sigplan notices v29 n11 p208218 nov 1994 robert stets sandhya dwarkadas nikolaos hardavellas galen hunt leonidas kontothanassis srinivasan parthasarathy michael scott cashmere2l software coherent shared memory clustered remotewrite network acm sigops operating systems review v31 n5 p170183 dec 1997 ramakrishnan rajamony alan l cox performance debugging shared memory parallel programs using runtime dependence analysis acm sigmetrics performance evaluation review v25 n1 p7587 june 1997 alex gontmakher avi mendelson assaf schuster using fine grain multithreading energy efficient computing proceedings 12th acm sigplan symposium principles practice parallel programming march 1417 2007 san jose california usa dejan perkovic peter j keleher protocolcentric approach onthefly race detection ieee transactions parallel distributed systems v11 n10 p10581072 october 2000 leonidas kontothanassis robert stets galen hunt umit rencuzogullari gautam altekar sandhya dwarkadas michael l scott shared memory computing clusters symmetric multiprocessors system area networks acm transactions computer systems tocs v23 n3 p301335 august 2005 guang r gao vivek sarkar location consistencya new memory model cache consistency protocol ieee transactions computers v49 n8 p798813 august 2000 fong pong michel dubois formal automatic verification cache coherence multiprocessors relaxed memory models ieee transactions parallel distributed systems v11 n9 p9891006 september 2000 robert c steinke gary j nutt unified theory shared memory consistency journal acm jacm v51 n5 p800849 september 2004 vijay pai parthasarathy ranganathan sarita v adve tracy harton evaluation memory consistency models sharedmemory systems ilp processors acm sigplan notices v31 n9 p1223 sept 1996 matthew j zekauskas wayne sawdon brian n bershad software write detection distributed shared memory proceedings 1st usenix conference operating systems design implementation p8es november 1417 1994 monterey california xiaowei shen arvind larry rudolph commitreconcile fences crf new memory model architects compiler writers acm sigarch computer architecture news v27 n2 p150161 may 1999 fong pong michel dubois verification techniques cache coherence protocols acm computing surveys csur v29 n1 p82126 march 1997 allon adir hagit attiya gil shurek informationflow models shared memory application powerpc architecture ieee transactions parallel distributed systems v14 n5 p502515 may dan grossman jeremy manson william pugh highlevel memory models mean transactions proceedings 2006 workshop memory system performance correctness october 2222 2006 san jose california jeremy manson william pugh sarita v adve java memory model acm sigplan notices v40 n1 p378391 january 2005 jae bum lee chu shik jhon reducing coherence overhead barrier synchronization software dsms proceedings 1998 acmieee conference supercomputing cdrom p118 november 0713 1998 san jose ca h sarojadevi k nandy balakrishnan correctness program execution cache coherence maintained locally datasharing boundaries distributed shared memory multiprocessors international journal parallel programming v32 n5 p415446 october 2004 rasit eskicioglu comprehensive bibliography distributed shared memory acm sigops operating systems review v30 n1 p7196 jan 1996
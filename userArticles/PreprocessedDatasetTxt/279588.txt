algorithms variable length subnet address assignment abstractin computer network consists subnetworks lbit address machine consists two parts prefix si contains address subnetwork machine belongs suffix length l si containing address particular machine within subnetwork fixedlength subnetwork addressing si independent whereas variablelength subnetwork addressing si varies one subnetwork another avoid ambiguity decoding addresses requirement si prefix another sj practical problem find suitable set sis order maximize total number addressable machines ith subnetwork contains ni machines ni machines subnetwork need addressable solution ni 2lsi 2lsi machines subnetwork addressable none addressable solution assigns address si subnetwork abstract problem implied formulation given integer l given necessarily distinct positive integers n1 cdots nm find binary strings s1 cdots sm may empty 1 nonempty string si prefix another string sj 2 si l bits long 3 quantity sum nolimits skne0 min left nk 2lsk right maximized generalize algorithm case ni also priority pi associated additional constraint involving priorities subnetworks important others treated preferentially assigning addresses algorithms used solve case l variable input longer specifies l rather gives target integer number addressable machines goal find smallest l whose corresponding optimal solution results least addressable machines b introduction introduction discusses connection computer networking abstract problems algorithms subsequently given also introduces terminology computer network consists subnetworks lbit address machine consists two parts prefix contains address subnetwork machine belongs suffix containing address particular machine within subnetwork case various subnetworks contain roughly number machines fixed partition l bits tbit prefix l gamma tbit suffix works well practice subnetwork contain 2 lgammat addressable machines contains 2 lgammat address remaining ones unsatisfied sense address fixed length partition scheme machines unsatisfied way satisfy increase value l however fixed length scheme wasteful subnetworks consist eventually consist different numbers machines say machines ith subnetwork case fixed scheme leave many machines unsatisfied particular value l even though variable length partition scheme describe next could satisfy without increase l variable partition scheme length prefix containing subnetworks address varies one subnetwork another words let prefix address ith subnetwork js j however avoid ambiguity store transmit js j requirement prefix another j variable length subnetwork addressing easily shown satisfy larger total number addressable machines fixed length scheme examples fixed length subnetwork addressing cannot satisfy addressing furthermore also interested cases even variable length addressing cannot satisfy n machines cases want use l bits available effectively possible ie order satisfy many machines possible course optimal solution might leave unsatisfied machines say ith subnetwork translates empty string ie js solution therefore consists determining binary strings maximize sum solution completely satisfies ith subnetwork satisfies machines subnetwork ie js machine ith subnetwork satisfied say ith network completely unsatisfied solution satisfies machines ith subnetwork subnetwork partially satisfied happens case 2 lgammajs j machines subnetwork satisfied optimal solution leave subnetworks completely satisfied others completely unsatisfied others partially satisfied prioritized version problem models situation subnetworks important others use following priority policy priority policy number satisfied machines subnetwork lowerpriority subnetworks exist next section proves useful properties subset optimal solutions assume unprioritized case leave prioritized case end paper proceeding technical details approach stress provided enough background motivation make paper selfcontained reader interested background provided find references 11 8 9 10 6 4 12 specifications standard subnet addressing related topics general discussion hierarchical addressing benefits large networks various lookup solution methods eg digital trees see 7 5 finally follows assumes reader familiar basic techniques terminology text algorithms data structures literature refer reader example references 1 2 3 preliminaries following definitions observations useful later assume without loss generality since case n admits trivial solution 2 l machines satisfied subnetwork 1 assume logarithms base 2 lemma 1 let solution necessarily optimal exists solution 0 satisfies number machines uses set subnetwork addresses completely unsatisfied subnetworks k lowest k words js proof among solutions satisfy number machines consider one smallest number offending pairs defined pairs completely unsatisfied j completely unsatisfied claim number pairs zero otherwise interchanging roles subnetworks j solution decrease total number satisfied machines contradiction since resulting solution least one fewer offending pair 2 hand necessarily exist 0 equal value say completely satisfied subnetworks k highest n values optimal solution seek go selected subnetworks decreasing n values initially encounter mixture completely satisfied partially satisfied subnetworks get completely unsatisfied one lemma remaining ones completely unsatisfied lemma 2 let solution necessarily optimal exists solution 0 satisfies many machines uses set subnetwork addresses js proof among solutions satisfy number machines consider one smallest number offending pairs defined pairs j js claim number pairs zero otherwise interchanging roles subnetworks j solution decrease total number satisfied machines contradiction since resulting solution least one fewer offending pair 2 let full binary tree height l ie 2 l leaves 2 nodes solution one map nonempty node obvious way node v corresponding subnetwork obtained starting root going dictated bits string 0 means go left child 1 means go right child note depth v distance root js j v ancestor another v j requirement nonempty prefix another j node w use parentw denote parent w use lw denote number leaves subtree w hence solution completely satisfies subnetwork iff case extend terminology saying node v completely satisfied rather accurate subnetwork corresponding node v completely satisfied solution satisfies lemmas 1 2 solution depth v implies v 0 smaller preorder number v 0 j equivalent saying 0 lexicographically smaller 0 obtained sequence interchanges various subtrees follows initially copy repeat following 1 perform interchange 0 subtree rooted node v subtree rooted leftmost node 0 depth simply new position occupied interchange 2 delete 0 subtree rooted v 0 performing interchanges done 0 gives new v 0 desired propertythe interchange operations used prove lemma actually performed algorithm use proof lemma lemma 4 let solution necessarily optimal satisfies properties lemmas 1 3 exists solution 0 satisfies many machines also satisfies properties lemmas 13 v root lparentv nonempty 0 subset nonempty proof among solutions satisfy number machines let one maximizes integer v lemmas property ie claim 0 already satisfies lemma suppose contrary k ie lparentv i1 cannot completely satisfied since would imply lv i1 hence v i1 partially satisfied ie lv z parent v i1 sibling v i1 must right v i1 since otherwise v v lparentv contradicts definition also note fact lz n i1 implies n ie number unsatisfied machines subnetwork promoting v i1 moving parent one level tree thus replacing old i1 new shorter one obtained dropping rightmost bit old i1 ii deleting 0 j new i1 prefix note j removed corresponding v j subtree hence removal j results ly machines becoming unsatisfied compensated ly machines subnetwork become newly satisfied result v i1 promotion implying new solution 00 value less 0 however v j deleted subtree cause 00 longer satisfy property lemma 1 surviving v right z n n j next describe modify 00 satisfy lemma 1 rest proof 0 refers solution started v i1 moved one level 00 refers solution v i1 moved let v denote set deleted v j ys subtree original 0 00 00 right z hence need repair 00 restore property lemma 1 repair needed done follows simultaneously elements sequence v following tree place element considered say v j place previously original 0 occupied v jl1 v j cannot placed new solution leaves completely unsatisfied 00 modified satisfies number machines original one still satisfies lemmas 13 moved v i1 one level tree repeated v i1 high enough contradiction definition integer hence must case 0 lemma 5 exists optimal solution satisfies properties lemma 4 every subnetwork length equal either proof let optimal solution satisfying lemma 4 first claim every satisfies js suppose contrary length less moving v current position say node descendant whose depth equals e would leave subnetwork completely satisfied without affecting subnetworks repeating gives solution every length course moving v say ys left subtree leaves hole ys right subtree sense right subtree unulitilized new solution resulting might many unutilized subtrees easy move right lie right utilized subtrees details easy omitted hence assume js note introduce violation properties lemma 4 complete proof must show js implies taking logarithms sides gives completes proof 2 observations made far enough easily solve om log time following easier version problem either completely satisfy subnetworks report possible clearly suffices find v subnetwork since v uniquely determine done om log time following greedy algorithm operates portion v 1 sort n decreasing order say n log log factor goes away n sorted linear time eg integers smaller o1 2 n compute depth v 3 repeat following leftmost node depth none v node exists stop output solution exists time om implementing step construction simultane ously preorder traversal relevant portion call start root stop first preorder node depth 1 label v 1 consider leaf 0 resume preorder traversal reaches another node depth 2 labeled v 2 considered another leaf 0 etc note end leaves 0 v left right order theorem 1 algorithm greedy solves problem finding assignment addresses completely satisfies subnetworks assignment exists time complexity om given sorted order om log sort n proof time complexity argued exposition algorithm correctness algorithm follows immediately lemmas 15 2 theorem 2 assignment completely satisfies subnetworks exists proof observe algorithm greedy succeeds satisfying subnetworks inequality satisfied 2 corollary 1 whether assignment completely satisfies subnetworks determined om time even n given sorted order proof righthand side inequality previous theorem computed om time 2 would greedy algorithm solve problem satisfying largest number machines cannot satisfy cannot assign v node step 3 instead saying solution exists accurately claim solution produced far optimal answer seen simple example example greedy algorithm satisfies 5 machines whereas possible satisfy 7 machines however following holds observation 1 solution returned greedy algorithm satisfies number machines less half number satisfied optimal solution number subnetworks completely satisfied greedy observe since would put v greater depth current position therefore optimal solution could compared greedy satisfy additional machines less number satisfied greedyhowever need resort approximating optimal solution since next section give algorithm finding optimal solution 3 algorithm unprioritized case assume throughout section greedy algorithm described earlier failed satisfy machines goal satisfy many machines possible call level 2 nodes whose depth distance root number nodes level follows 1 kth leftmost node level lemma 5 says v either depth limits number choices place v 2 choices depth 2 1 choices depth 1 every maximum number machines subnetworks satisfied using portion preorder numbers preorder number j subject constraint v placed node defined analogously playing role played definition ci j ci js c 0 js play important role algorithm clearly quantities could easily obtain number machines satisfied optimal solution simply choosing maximum among another notion used algorithm predecessor node v integer greater vs depth node level immediately left ancestor v level node exists v predecessor words w ancestor v level possibly predecessor v rightmost node left w level algorithms implicitly make use fact predecessor given node v obtained constant time v represented pair b vs depth b lefttoright rank b depth ie v bth leftmost node depth predecessor b c following algorithm preliminary later modified better algorithm input algorithm l n output placement v recall equivalent computing easily obtained v fact obtained v constant time pointed later assume preprocessing step already computed use pred v pred b interchangeably denote predecessor node v b convention pred b gamma1 gamma1 undefined ie b predecessor 1 turn following convention 0 node gives ci b value maximization fi b predd predd b convention 0 node gives c 0 b value maximization f predd predd 2 find largest b ci bs c 0 bs computed previous step suppose ck b respectively c 0 k b ck b respectively c 0 k b maximum possible number machines satisfied optimal solution v generate set assignments correspond optimal solution rather value use f f 0 functions obtained previous step starting node respectively trace back output nodes optimal solution go along order v k v details tracing back follows k largest ci bs c 0 bs computed previous step repeat following b output v equal either fi fi case f 0 fi case note output string corresponding v node rather describing v modify step 2b follows v b binary string consisting rightmost digits binary representation integer 2 breadthfirst number node b empty string corresponds root since 2 0 implies computed pair b constant time correctness algorithm preliminary follows lemmas 1 5 time complexity preliminary unsatisfactory depend size well making worst case take om2 l time however following simple modification results om 2 steps 1a respectively 1b replace iteration bounds b remain unchanged 2 1a 2 1 1b arguing correctness modified algorithm observe time complexity om 2 since iterate 2 distinct note relevant ci bs need explicitly initialized implicitly assumed zero initially works particular order step 1 computes correctness follows claim proved next optimal solution 2 nodes level use leftmost nodes level let optimal solution smallest possible number call violations claim ie smallest number nodes b b 2 gamma v b prove contradiction suppose 0 let smallest depth claim violated let b node level violates claim placed b optimal solution since nodes right v level value would surely decrease modify repositioning v subtrees rightmost nodes level without changing depth modification however would decrease contradicting definition hence must zero claim holds following summarizes result section theorem 3 unprioritized case solved om 2 time 4 algorithm prioritized case let priorities priority subnetwork k rest section assume l large enough completely satisfy subnetworks case l large enough priorities play role theorem use greedy alternatively corollary 1 binary search largest call subnetworks k completely satisfied comparison binary search corresponds call greedy alternatively corollary 1 course ignores priorities subnetworks k takes total time om log even though may use greedy logarithmic number times sort decreasing n j makes subsequent execution greedy cost om time rather om log let solution returned greedy subnetworks completely satisfied definition impossible completely satisfy subnetworks task modify satisfy many machines subnetworks k possible without violating priority policy hence keeping subnetworks completely satisfied done follows 1 set depth k 1 dlog n k e 2 use greedy log log n k j times binary search smallest depth call v k j placed without resulting infeasibility tested greedy placing subnetworks k previously fixed depths ii placing k j depth log n k j possible values implies log log n k j iterations binary search exists ie placement k j prevents required placement proceed step 3 binary search finds fix depth v j stays future iterations set 2 3 solution described current depths k fixed depths used preorder traversal part position v k 1 algorithm respects priority policy follows way fix depth subnetworks lower priority interfere considered later iteration time complexity easily seen om 2 log l since n k following summarizes result section theorem 4 prioritized case solved om 2 log l time 5 remarks l variable consider situation instead specifying l input specifies target integer fl number addressable machines goal find smallest l capable satisfying least fl machines algorithms gave earlier assume fixed l used subroutines forward binary search optimal ie smallest value l call l satisfies least fl machines use log times forward binary search l looks like extra multiplicative log l variable seek minimize opposed version problem fixes l ahead time however theorem 2 implies log important case seek smallest l satisfies machines version problem solved fast one l fixed seek check whether completely satisfy subnetworks acknowledgement authors grateful three anonymous referees helpful comments earlier version paper r combinatorial algorithms words introduction algorithms algorithms class subnet experiment parallel searching techniques routing table lookup class subnet experiment results recommendations fast routing table lookup using cams internet standard subnetting procedure broadcasting internet datagrams presence subnets internet subnets variable length subnet table ipv4 assignment subnet numbers tr
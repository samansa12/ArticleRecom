model checking xml manipulating software use xml de facto data exchange standard allowed integration heterogeneous web based software systems regardless implementation platforms programming languages hand rich treestructured data representation expressive xml query languages xpath make formal specification verification software systems manipulate xml data challenge paper present initial efforts automated verification xml data manipulation operations using spin model checker present algorithms translating bounded xml data xpath expressions promela input language spin techniques presented paper constitute basis web service analysis tool wsat verifies ltl properties composite web services b introduction web based software systems eg web services becoming increasingly important partly due wide use web electronic commerce errors systems multimillion dollar transactions carried costly adhoc repairs failure acceptable static analysis techniques especially model checking valuable ensuring correctness robustness systems deployed generally agreed messages exchanged among web based systems xml 21 format example almost permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copies bear notice full citation first page copy otherwise republish post servers redistribute lists requires prior specific permission andor fee july 1114 2004 boston massachusetts usa web service standards eg wsdl 18 bpel4ws 1 wsci owls 17 built xml related standards including xml schema 23 xpath 22 rich treestructured data representation xml powerful xpath expressions ever impede direct application model checking techniques verification web based systems earlier efforts verify web services eg 6 15 12 basically focus control flows abstracting away xml data semantics analysis paper presents initial efforts formal specification verification software systems xpath based manipulation bounded xml data techniques presented paper constitute basis web service analysis tool wsat 10 19 verify linear temporal logic ltl properties conversation protocols 7 interacting bpel4ws 1 web services 8 clearly techniques also used verification types software systems exchange xml data use spin 11 backend model checker verification xml data manipulation operations developed algorithms translating xml data types xpath expressions promela input language spin handling xml data manipulation consists two parts 1 mapping xml schema type system promela 2 translation algorithm generates promela code xpath expression type mapping straightforward however translation xpath expressions trivial implemented translation algorithms presented paper part wsat use spin backend model checker based following considerations 1 promela supports arrays useful translating xml schema data types 2 communication channels promela enables us model asynchronous communication among web services 8 however spin explicitstate model checker may scale large data domains due statespace explosion future plan investigate use symbolic model checking techniques verification xml data manipulation 15 verification composition web services investigated using petri net model 6 web service compositions specified using message sequence charts modeled using finite state machines analyzed using ltsa model checker earlier efforts verification web based software systems mostly concentrate analysis control flows techniques handling xml data however enable verification properties relating data manipulation enables us analyze web based software systems greater level detail without adhoc data abstractions idea employing backend model checkers verification expressive language used verification tools bandera 4 jwig project extends java language highlevel features web service programming dynamic construction documents 5 ensure generated xml document consistent message format declared using dsd 14 type system similar xml schema jwig provides static analysis set predefined properties verification problem considered paper wsat rather different consider relationships expressed temporal logic multiple xml messages execution web service also focus xpath expressions part jwig techniques presented paper apply bounded xml data number children xml node always bounded unbounded xml schema types various fragments xpath captured using unranked tree automata 13 16 unranked tree automata model overcomes problem boundedness data semantics leaf value nodes lost modeling example fragment xpath studied 13 allow arithmetic constraints qualifiers reasons structure xml document paper organized follows section 2 reviews xml related standards essential systems exchange xml data formal models established standards facilitate technical discussion later section 3 introduces mapping msl theoretical model xml schema promela translation algorithm xpath promela presented section 4 section 5 discusses application presented techniques verification web services section 6 concludes paper 2 xml related standards section present syntax semantics xml msl xpath translation algorithms presented following sections build definitions given section 21 xml extensible markup language xml markup language used describing data 21 de facto universal data transfer format internet xml plays central role specifying semistructured data way platform language neutral degree selfexplanatory xml schema 23 provides type system xml ie used specify expected data organization xml document xpath 22 one popular xml query languages used navigate xml document access components similar html xml documents structured using tags written followed however tags xml describe content data rather appear ance fig 1a shows xml document containing data register message sent investor register stock analysis service description service provided section 5 xml document consists string containing identification investor list stock identifiers investor interested payment information xml documents modeled trees internal node corresponds tag leaf nodes correspond basic type values document fig 1a corresponds tree fig 1b following introduce formal representation xml documents one simplification make omit tag attributes used xml since tag attribute regarded leaf node child corresponding tag node simplification impair expressive power model definition 21 xml document quadruple 1 l list labels label either internal node tag leaf node value basic type boolean integer string denote ith node l li indices start 1 2 n size l parent function b 1 define p transitive reflexive closure p 4 r 1 n 1 n range function ri 1 n b j j given node index pi points parent node since root parent define node ri denotes maximum index nodes subtree node note constraints p r guarantee l preorder traversal document tree x 21 fig 1c quadruple representation xml document fig 1a obviously list l preorder traversal tree fig 1b parent function p range function r describe tree structure example subtree starting node requestlist spans five nodes hence range function definition 21 extended describe tree sequence restriction 1 pi item 3b modified 0 pi tree sequence call node whose parent node 0 root node introduce split operator splits tree sequence two tree sequences extract operator generates tree sequence single xml document tree extracting contents definition 22 given xml tree sequence r split integer applied x node root node 1 result two tree sequences 1 l 2 3 p1 coincides p domain 1 s1 1 ns1 4 r1 coincides r restricted domain 1 s1 r2 given xml tree sequence least root nodes k split tree sequence k sequences consecutively applying split operator k 1 times second part result previous split call operation ksplit register requestlist payment accountnumstockid stockid register investorid vip01 requestlist stockid 0001 stockid 0002 payment accountnum 0425 b c figure 1 xml document corresponding tree b formal representation c definition 23 given single xml tree extract operator generates tree sequence extractx 22 apply exact operator xml tree part c fig 1 get xml tree sequence x investorid vip01 requestlist stockid 0001 stockid 0002 payment accountnum 0425 note tree sequence x split 3 8 exists 3split x 22 xml schema msl xml provides standard way exchange data inter net however parties exchange xml documents still agree type data ie tags appear document order etc xml schema 23 language defining xml data types paper focus subset xml schema example handle unordered sequence types model schema language msl 2 compact formal model captures features xml schema use simplified version msl type expressions defined follows g g0 g1 gk represent msl types b basic data type string integer boolean tag n two positive integers n intuitively semantics msl type expressions summarized follows tg0 denotes type root node labeled children types match sequence msl types represented g0 g1mn denotes sequence size least n member type g1 g1 gk denotes ordered sequence first member type g1 second member type g2 g1 gk denotes choice among types g1 gk simplify presentation assume types g1 gk appear g1 gk g1 gk derived rules g b g tg0 similar xml define parent function msl types given two msl types g g pg exists either following two conditions satisfied 1 g1 g gk associate attribute called tag msl type g g derived rule g tg0 tag null formally xml document tree sequence instance msl type g one following holds 1 g b leaf node value type b 2 g tg0 x single xml document tree instance g0 3 g g1mn exists ksplit x resulting tree sequences instances g1 4 g g1 gk exists ksplit x resulting tree sequences x1 xk instances g1 gk respectively 5 g g1 gk x instance g example 23 easy verify xml document register fig 1 instance following msl type register 23 xpath order write specifications programs manipulate xml documents need expression language access values nodes xml documents use subset xpath 22 navigate xml trees return answer nodes fragment xpath use consists following operators child axis descendant axis selfreference parentreference test b node name test wildcard predicates xpath expression defined following const op exp exp op exp empty string exp denotes zero repetition exp syntax rules expression basic types boolean integer string constructed combining xpath location paths represented p constant values rep resented const operators basic types represented op two types location paths relative location paths absolute location paths absolute location path starts relative location path represented r consists list steps represented connected steps relative location path evaluated left right step selfreference parentreference complex form consists node test n sequence predicates form exp node test n three possible forms type test b name test wildcard match finally step function call position last following restriction function calls appear last step location path formally xpath expression accepts inputs form c context c set node indices xml document x either single node x set values basic type set node indices input context must ascending order repetition output xpath expression set nodes xml document used input set values x l n domain node indices x ie 1 n dom domain leaf node values semantics xpath expression exp well step node test n location path r defined function formally define semantics xpath expressions give example expressions results evaluating distinguish node indices values write node indices bold characters 24 consider input 1 1 1 root node xml document presented fig 1 following xpath expressions investorid results 2 0002 false true resp present formal semantics xpath expressions give semantics node test first step location path finally entire xpath expression consider node test n input c c set node indices node xml document x l n p r results nc defined follows 1 n type b 2 n nc 3 n nc basically rules 1 2 select children nodes input node types tags resp rule 3 simply returns children nodes finally input set values nc returns empty set definition step similar given step input c set values simply returns node x result defined follows 1 2 3 exp true expc exp boolean expression expc exp location path otherwise 4 5 last sc c position c rules 1 2 handling self reference parent reference straightforward third rule step either returns singleton set empty set depending evaluation predicate note location path used predicate evaluates true returns non empty set nodes finally evaluation step consists node test plus series predicates reduced equivalent location path example step stockidposition2 equivalent location path stockidposition2 given input c function call last simply returns singleton set contains size context c position returns position c position counted starting 1 given relative path r r1s input c according formula steps relative location path executed one one left right note context step result previous step case r r1s replace r1c equation 1 following set n p example given xml document fig 1 input 4 4 first step descendants operator location path stockidposition3int produces new context 4 5 6 7 8 later steps generates result 0001 absolute location path defined based relative location path absolute location path p r input c root p r pc finally semantics xpath expression basic types form exp exp1 op exp2 defined follows basically computes results possible combinations value sets two operands exp1 exp2 unary operators handled similarly assume operation op either relational operator arithmetic operator boolean operator note used condition boolean xpath expression evaluates true result set contains least one true value 1 working draft delicate handling scenario two sets arithmeticcomparison operators one support xpath 10 semantics presented paper raise type error operand contains one value hard support second semantics approach mtype stringvalue int intvalue t2stockid stockid 3 int stockidocc int intvalue int intvalue mtype maccountnum t4accountnum accountnum t5creditcard creditcard mtype choice t3requestlist requestlist t6payment payment figure 2 promela translation example 23 3 msl promela section focus mapping types msl promela present example translation fig 2 translation algorithm given fig 3 fig 2 promela translation msl type given example 23 clearly msl basic type straightforward mapping promela example int boolean mapped promela type int bool respectively msl type string mapped mtype enumerated type promela eg leaf node value investorid xpath translation explained later string constants collected declared used symbolic constants mtype assume strings used solely constants expect operators change values mtype variables translation complex msl types complicated gen erally msl complex type translated corresponding promela example register type example 23 mapped promela declaration typedef register intermediate type requestlist inside register translated typedef t3 requestlist prefixes t3 added prevent name collisions intermediate types since intermediate msl type child parent type promela type declaration parent type corresponding attribute definition example statement t3 requestlist requestlist defines attribute requestlist typedef register intermediate msl type multiple occurrences eg stockid element defined array max occurrence array size addition additional variable eg stockid occ defined parent type record actual occurrence msl types constructed using choice operator variable choice used record actual type chosen xml instance msl type eg choice attribute declared t6 payment fig 3 present procedure tr takes msl type declaration g input generates two strings output first string ie ret1 contains type declaration g well necessary type declarations intermediate types second output attribute definition g g intermediate type example procedure called intermediate type requestlist ret1 contains declaration t2 stockid t3 requestlist ret2 contains t3 requestlist requestlist show generation separator fig 3 however handled easily shown fig 3 function body tr processes input msl type declaration recursively according syntax rules note properly handles issues array declaration types multiple occurrences complex types constructed using choice operator declaration g including intermediate types ret2 attribute definition input g g intermediate function trg msl string2 begin string ret1 ret2 switch case g intermediate type else mtype g 1 tag switch return ret1 ret2 figure 3 translation msl promela 4 xpath promela section present translation algorithm xpath promela start brief discussion use xpath expressions xml manipulating software study motivating example finally present translation algorithm consider use xpath languages xml data manipulation bpel4ws wsci basically two types usage 1 boolean xpath expressions used branch loop conditions 2 location paths arithmetic expressions used left right hand sides assignment statements spectively handle two cases separately since semantics xpath expressions depend context used example location path used boolean condition meaning different case used left hand side assignment since implementation two cases similar remainder paper concentrate translation boolean xpath expressions 41 motivating example consider following xpath boolean expression xml variable register msl type register defined example 23 msl type variable request consists single child stockid xpath prefix used denote variable names xpath expression following variable name evaluated value variable xml document starting context 1 1 1 root node corresponding xml document expression queries whether document register last stockid value greater 5 equal stockid request corresponding promela translation shown fig 4 result xpath expression 3 results predicates 1 2 1 resp 5 index position last index position 6 int i1 i2 i3 i4 i58 i21 9 precalculate value last store i3 14 compute first predicate 19 else skip 22 bres3 i5 i3 28 od 29 translation whole expression 34 first predicate 36 43 second predicate 44 48 fi 50 bres2 51 translation expression 52 53 vrequeststockidintvalue 54 vregisterrequestliststockidi1intvalue 58 else skip figure 4 xpath promela example note four boolean variables five integer variables promela translation boolean variable bresult used record evaluation result whole xpath expression bres1 bres2 used evaluation two predicates right hand side expression bres3 used evaluation last function integer variables i1 i4 used array indices different parts promela code i3 records value function call last i2 i5 used position function hard see compute value last prior evaluation whole xpath expression record value i3 main body calculation loop searching proper value array index i4 satisfies first predicate value stockid greater 5 main body compute whole boolean xpath expression similar loop searching proper value array index i1 code handling two predicates nested note position variable i2 array index i1 properly updated according semantics boolean expressions xpath standard bresult set true find value i1 satisfying boolean expression finally note efficient promela translations one presented fig 4 example integer variable i4 array index reused replace i1 implementa tion variable assignment optimizer achieve ob jective however omit details implementation simplify presentation 42 supporting data structures make following observations based motivating example shown fig 4 1 every xpath language construct ex pression path step corresponds promela code segment example boolean xpath expression shown equation 2 corresponds whole promela code fig 4 right hand side corresponds whole code lines 51 57 left blank left hand side corresponds empty statement since code generated 2 particular loops generated steps generate xml data corresponds msl type multiple occurrences ie types declared gmn example step stockid right hand side corresponds loop line 30 line 66 3 generated code segments embedded example segment lines 34 63 corresponds int5 embedded code step stockid embeds code predicate positionlast lines 43 59 4 generated code regarded nestedloop simulates search procedures location path evaluation boolean expression placed body innermost loop translation algorithm needs mechanism represent structure input xml document approach conveniently capture promela code segments generated embedded hence introduce two data structures used translation algorithm type tree structure represents msl types statement macro represents partially generated promela code segments also define several functions manipulate data structures type tree use type trees statically represent input output xpath location path step given xml variable msl type straightforward derive corresponding type tree example fig 5 corresponding type tree xml variable register equation 2 msl type given example 23 note node type tree corresponds subexpression msl type expression given example 23 root node corresponds whole type expression hence node also corresponds msl type type tree node labeled msl type root node also labeled xml variable name note associated msl type multiple occurrence node equipped additional index example index i1 associated node 5 fig 5 recall msl type multiple occurrence translated array promela index used access elements array node register register string requestlist int payment creditcard int stockid idx i1 accountnum int figure 5 typetree variable register type tree tracing back root tree get qualified name ie expression promela translation accesses data type represented node example registerrequestliststockidi1intvalue qualified name node 6 prefix v automatically added system avoid name collision intvalue name attribute basic type int define number functions type trees given type tree xpath step function markchildts proceeds follows 1 unmark marked nodes 2 node unmarked step 1 mark children results executing step 3 return modified example let tr type tree fig 5 node 1 marked node marked let step requestlist result markchildtr type tree node 4 marked node functions markparentt markallt markroott work similar way example nodes 69 11 marked nodes executing markchildmarkalltr int statement macro translation algorithm xpath construct corresponds promela code segment code segment regarded list statement macros sequentially concatenated using statement macro simply macro captures block promela code certain functionality macro one blank space another promela code segment embedded five types macros using translation algorithm summarized low macro input parameters corresponding promela code appearance parameters replaced actual input value macro used statement macro promela code else skip else break od empty blank fig 6 presents set macros organized tree two types edges child parent embedment edge shown solid arrow sequential composition edge shown dotted arrow call tree macro tree fact promela code generated xpath expression construct captured using one set macro trees given macro tree straightforward generate corresponding promela code example macro tree fig 6 corresponds code segment line 30 line 66 line 51 line 57 blank fig 4 empty cond init init init init register stockid int5 sequence insert figure associate two attributes macro input type node output type node type tree macro input node characterizes starting node macro starts search ing output node starting point embedment example fig 6 macro fori113 corresponding code step stockid location path top figure input type node type node 1 fig 5 corresponds type xml variable register output node also input node embedment type node 5 msl type stockid result evaluating step input type node translation except concatenating code two expressions input node embedded code match output node blank inserted also associate hashtable macro records mapping xpath location paths qualified names exam ple hashtable last empty macro fig 6 map location path shown fig 6 ie right hand side equation 2 qualified name node 6 ie expression v registerstockidi1intvalue three different functions embed macros insertandreplacec1 c 2 functions return one macro tree result embedding c2 blanks c1 translation c1 always guaranteed single macro tree c2 set macro trees matchinsert function requires inserted macro tree must match output node host insertall insertandreplace require matching inserting c2 blanks c1 insertandreplace replaces location paths c2 qualified names based hashtable host function gencoden generates macro tree given type node n gencode relies global registry r registers index variables processed function traces back current type node root type node whenever unprocessed index encountered macro generated index index registered r new macro generated old macro generated embedded new macro form nested loop example index i1 processed gencoden6 generates fori113 given n6 node 6 fig 5 exp intermediate else blank ifexp filled end else end else end c gencoded type node souttree figure 7 translation algorithm 43 syntax directed translation algorithm discuss syntax directed translation algorithm presented fig 7 nonterminal eg exp p one inheritedattribute intree two synthesizedattributes outtree code attributes intree outtree type trees used capture input output xpath language constructs respectively attribute code set macro trees records generated promela code corresponds nonterminal nonterminal exp additional attribute var boolean variable records evaluation results exp var attribute null exp intermediate expression eg exp used branch condition host language predicate another xpath location path example generating promela code fig 4 equation 2 attribute var boolean expressions predicates int5 positionlast bres1 bres2 respectively handling expressions rules 1 2 3 4 handle translation xpath boolean arithmetic expressions rule 1 subexpressions inherit intree exp example evaluating equation 2 intree inherit null another ex ample processing expression int 5 intree inherit version type tree shown fig 5 node 5 marked node discuss instances type trees generated later handling xpath location paths code exp synthesized code two subex pressions basic idea embed code generated exp2 code exp1 regardless matching inputoutput type node use insertall instead matchinsert exp intermediate eg used boolean branching condi tion need additional processing calling insertandreplace insert another macro synthesized code macro assigns true attribute var exp evaluates true hence generated code evaluates boolean expression stores result var example mentioned earlier code right hand side equation 2 whole code fig 4 except lines 51 57 blank code left hand side empty macro synthesize code equation 2 two subexpressions macro assigns var ie bresult embedded blank lines 51 57 call insertandreplace note location paths equation replaced qualified names rest expression related syntax rules ie rules 2 3 4 work similar way pass information intree subexpressions synthesize code outtree subexpres sions finally note outtree used syntax rules expressions handling location paths rules 5 6 7 handle translation xpath location paths rule 5 location path associated xml variable corresponding type tree generated passed steps path example handle right hand side equation 2 type tree fig 5 gener ated note even xml variable new type tree instance generated index attributes unique names example precalculating value last line 11 28 another type tree generated xml variable register index node 5 i4 instead i1 fig 5 rule 6 handles absolute location paths inherited attribute intree handled differently xpath operator respectively rule 7 processes path step step left right passes outtree partial path p1 step right note synthesizing code need match type node embedding macros matchinsert called handling steps rules 8 9 10 11 handle steps semantics rules 8 9 clear rule 11 calls markchild function symbolically execute step intree type node outtree function gencode called generate macro tree finally rule 11 handles case step predicate example boolean expression int 5 let us call e2 equation 2 synthesized code consists two parts evaluation code expression lines 35 40 evaluation e2 macro lines 41 63 allows insertion code later steps lines 44 61 44 handling function calls handling position last calls little bit complicated though idea similar substitute appearance function call integer variable properly update value function called integer variable contains right value position last call owner nonintermediate boolean xpath expression call appears owner exp need another attribute called prefix contains promela macros like code attribute code prefix placed ahead code contained code form complete code owner position call encountered acquire unique integer variable call let v append macro initv1 prefix attribute owner insert incv blank macros generated immediate previous step example handle position equation 2 integer variable i2 acquired initialization statement line 8 update statement line 61 inside blank code corresponds previous step int5 handling last even complicated works three modes normal mode copy mode processed mode normal mode first time last call encountered copy mode last encountered second time precalculation code generated processed mode case value last call precalculated value changed consider last call equation 2 example normal mode acquire integer variable last call ie i3 call handling owner ie equation 2 precalculate value last hence line 9 line 28 generated second translation equation 2 reaches last call copy mode initialization update statements generated precalculation code ie line 10 line 22 return precalculation processing last enters processed mode i3 allowed changed appearance last second predicate replaced i3 example 41 translation equation 2 split two recursive translation tasks left right hand paths hard see left hand side generates empty macro concentrate right hand side converted following form translation algorithm start register processes steps left right first type tree register shown fig 5 generated function markall called resulting tree passed outtree step stockid outtree step stockid node 5 marked node function gencode called node 5 generates macro corresponds lines 31 65 fig 4 lines 34 63 blank handling next step int5 similar macro generated embedded macro generated third step positionlast integer variables i2 i3 acquired function two calls respectively initialization update statements position generated line 8 line 61 however since normal mode last generate code last instead translation equation 2 called precalculation last lines 9 28 generated return second translation call equation 2 first translation call advances last step int generates empty macro whose hashtable contains information maps right hand side location path corresponding qualified name finally synthesizing code attribute equation 2 macro lines 51 57 inserted two location paths equation 2 replaced qualified names 5 applications section discuss applications techniques verification web services present case study techniques help identify delicate design error xpath expressions conversation protocol briefly discuss work verifying interacting bpel4ws web services web service analysis tool wsat techniques presented paper constitute basis conversation protocol 3 7 9 topdown specification specifies desired global behaviors message sequences composite web service formally conversation protocol tuple p composition schema p defines set peers participants composite web service message classes transmitted among peers guarded finite state automaton gfsa set message classes defined composition schema message class consists msl type sender ceiver finite set states initial state f set final states transition relation transition form source destination states c message class g guard transition guard consists guard condition set assignments transition taken guard condition evaluates true assignments specify contents message sent given transition peer p sender message type c guard g predicate following message sent vector contains last instance message type received sent peer p guards written using xpath expressions present conversation protocol named stock analysis service sas fig 8 presents overall structure control flow fig 9 fragment formal specification shown fig 8 sas involves three peers investor inv stock broker firm sb research department rd inv initiates stock analysis service sending register message sb may accept reject registration registration accepted sb sends analysis request rd rd sends results analysis directly inv report receiving report inv either send ack sb cancel service sb either sends bill services inv continues service another analysis request fig 9 present partial specification sas proto col specification sas consists two parts schema gfsa protocol schema specifies set peers list msl types list peer peer message classes built upon msl types gfsa specification consists states tran sitions present two key transitions protocol t8 register ack cancel accept reject bill request terminate report investor research dept rd stock broker register reject terminate accept request report ack request report ack cancel bill cancel bill terminate figure 8 stock analysis service t14 transition equipped guard determines transition condition assignment message sent example transition t8 sends message type request transition condition following boolean xpath expression rest guard assigns values investorid stockid fields request message sent according semantics gfsa 8 except request message appears left side assignment operator appearance message classes refers latest copy message class hence transition condition t8 means stockid latest request message last stockid register message assignment tries send stockid subsequent register message stockid appeared latest request message similarly guard transition t14 specifies latest request message contains last stockid register message bill message sent conclude interaction generally logic t8 t14 intends send list stockid initial register message one one hard see sas protocol translated promela process translation xpath msl promela presented paper translation control flow gfsa discussed 8 note promela translation initialization stage assigns initial values messages nondeterministically given logic transitions t8 t14 natural propose following ltl property promela translation sas protocol index v registerrequestliststockid occ registerrequestliststockidindexintvalue value frequeststockid value conversation schema typelist register stockidxsdint13 payment accountnumxsdint creditcardxsdint messagelist registerinv sb register rejectsb inv reject protocol initialstate s1 finalstatess4 transitionrelation guard register stockid guard figure 9 sample conversation specification ltl property temporal operator g means glob ally temporal operator f means eventually index value two predefined constants variables starting v qualified names referring xml data discussed sections 3 4 variable msg variable promela translation gfsa records current message sent example transition t8 executed msg assigned value request ltl property states register message contains stockid position index value value eventually request containing stockid nothing wrong happens ie register rejected inv cancel service interestingly spin soon identifies sas specification satisfy proposed ltl property spin gives error trace register message three stockids values 0 1 0 respectively errortrace shows first request stockid 0 sent transition t8 disabled stockid latest request last stockid register message instead transition t14 triggered send bill message conclude interaction verification identifies error design xpath transition guards rely presumption redundant stockids register message however enforced specification spin explicit model checker verification unfortunately scale well integer domain set 01 verification time 3 seconds memory consumption around 50mb domain increased 03 memory consumption grows 600mb however experience shows spin still useful identifying errors protocols restricting data domains complexity data manipulation one challenges arise model checking composite web services since communication among web services asynchronous interesting problems analyzing web services become undecidable 7 7 8 proposed several sufficient conditions restrict control flows web services undecidability induced asynchronous communication avoided verification process decision procedures sufficient conditions implemented research project wsat 10 19 wsat also supports ltl model checking composite web services specified popular industry standards bpel4ws key idea translate bpel4ws services gfsa representation 8 techniques presented paper applied translate gfsa promela wsat extended future support web service specification languages damls wsci etc 6 conclusion paper presented techniques representing xml data xpath expressions promela techniques allow us verify ltl properties xml manipulating software web services contrast earlier work approach abstract away xml data manipulation implemented algorithms wsat tool verified several example systems including conversation protocols bpel4ws web services future work planning apply symbolic model checking techniques tackle large state spaces caused xml data acknowledgments bultan supported part nsf career award ccr9984822 nsf grant ccr0341365 fu partially supported nsf career award ccr9984822 nsf grants iis0101134 ccr 0341365 su supported part nsf grants iis0101134 iis9817432 7 r business process execution language web services bpel4ws msl model w3c xml schema conversation specification new approach design analysis eservice composition extending java highlevel web service construction conversation protocols formalism specification verification reactive electronic services analysis interacting bpel web services realizability conversation protocols message contents wsat tool formal analysis web service compositions spin model checker primer reference manual verification business processes web services containment equivalence xpath fragment document structure description 20 simulation verification automated composition web services automata theory xml researchers owl services coalition web service analysis tool wsat web service choreography interface wsci xml path language xml schema tr bandera msl myampersandmdash model w3c xml schema simulation verification automated composition web services containment equivalence xpath fragment automata theory xml researchers conversation specification extending java highlevel web service construction analysis interacting bpel web services realizability conversation protocols message contents ctr j koehler r hauser sendall wahler declarative techniques modeldriven business process integration ibm systems journal v44 n1 p4765 january 2005 richard hull jianwen su tools composite web services short overview acm sigmod record v34 n2 june 2005 mark grechanik finding errors interoperating components proceedings second international workshop incorporating cots software software systems tools techniques p3 may 2026 2007
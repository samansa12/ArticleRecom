explanationbased scenario generation reactive system models reactive systems control many useful complex realworld devices toolsupported specification modeling helps software engineers design systems correctly one tool scenario generator constructs input event sequence spec model reaches state satisfying given criteria uncover counterexamples desired safety properties explain feature interactions concrete terms requirements analysts even provide online help end users learning use system however exhaustive search algorithms model checkers work limited cases problem highly intractable functionally rich models correspond naturally complex systems engineers wish design paper describes novel heuristic approach problem applicable large class infinite state reactive systems key idea piece together scenarios achieve subgoals single scenario achieving conjunction subgoals scenarios mined library captured independently requirements acquisition explanationbased generalization abstracts may coinstantiated interleaved approach implemented present results applying tool 63 scenario generation problems arising case study telephony feature validation b introduction reactive systems control many useful complex realworld devices telephone switches air space craft software agents featurerich systems difficult design correctly particularly distinct functional features designed different people different times lifecycle product family specification modeling11 16 allows engineers apply relatively sophisticated validation tools simulation coverage analysis model checking17 5 theorem proving12 20 relatively abstract models systems behavior order find design errors implementation abstractness models makes many reasoning techniques tractable validated spec model used starting point code genera tion documentation behavior system support maintenance evolution11 spec modeling tool suite benefits significantly scenario generator constructs input event sequence spec model reaches state satisfying given criteria tool uncover counterexamples desired safety properties explain feature interactions concrete terms requirements analysts increase test coverage even function documentation showing end users achieve goals still learning use system however model checkers17 4 capable generating scenarios certain limited classes reactive systems finite state machines small highly symmetric state spaces problem intractable functionally rich models arise natural abstractions systems engineers wish design example addition requiring search infinite state space models incorporating arithmetic operators require scenario generator find satisfying instances arbitrary arithmetic constraints undecidable paper describes novel heuristic approach called ization applicable large class infinite state reactive systems key idea instantiate piece together abstracted scenarios achieve subsets conjuncts goal predicate single scenario achieving conjunction sub sets scenarios mined library concrete scenarios captured independently requirements acquisition critically abstracted via explanationbased generalization approach sound incomplete succeed finding scenarios cases satisfiable goal predicates however intended fast even failing cases practical interactive tool moreover approachs power increased adding scenarios library requirements uncovered specified power tool grows naturally even incomplete generator quite use ful typically engineer discover eg via static analysis proof attempts descriptions states spec inconsistencies may arise correctness properties may violated scenario generator run descriptions whenever generator successful definite design flaw found engineer focus attention first cases may even satisfiable put later design process known problems fixed fixing first problems may either alter eliminate ones anyway generator fails putting scenario coming close goal possible helpful well paper summed three key ideas ffl current limiteddomain exhaustive search approaches model checking17 scenario generation enough need usable scenario generator accommodates expressive logics large state spaces even though problem highly intractable ffl heuristic sgen 2 approach based mining abstracting requirements knowledge using explanationbased generalization applies richly expressive logics large state spaces ffl moderate sized case study involving feature interactions telephony gives initial empirical evidence sgen 2 practical useful section 2 defines terms describes tool suite sgen 2 implemented next three sections make key points conclude discussion related work limitations future work modeling work performed within interactive specification acquisition tools isat framework isat11 12 13 prototype tool suite reactive system design intended support fulllifecycle spec modeling well code generation reactive system necessarily finite state machine reacts parameterized input events changing state performing acts thought output events isat based two hypotheses ffl functional requirements reliably elicited validated requirers concrete formal behavior scenarios ffl specifications must executable amenable automatic analysis designer constructs reactive system model executable spec language requirer specifies functional requirements concrete scenarios latter interleaved sequences input events act state observations required true thus crucially sgen 2 natural part design lifecycle acquisition library validated concrete scenarios describing systems behavior 21 model formalism backpropagation isat spec model consists theory definition together set event handlers theory defines types functions semantic axioms pure computational logic well signatures state relations events acts make system order support model simulation execution primitive function declarations models theory must include total operational function capable computing value function inputs domain non error typecompatible output value inputs outside declared domain isat model theories somewhat similar computational logic described 3 thus isat supports arbitrary functional rich ness bounded users willingness ability code implementations functions provide logical axioms supporting reasoning tools see example models operate arbitrary data structures used richness good advantage work applying isat specification implementation email channels system13 isat model operates message data structures lists users messages even database relation objects event handlers expressed limited procedural language pebf procedural eventbased formal ism semantically related rulebased ebf described 11 details pebf crucial paper except supports predicate backpropagation operator backprop note pebf need input language seen designer many domainappropriate frontend formalisms eg domainspecific languages graphical programming environments may compiled p ebf formalisms beyond scope present paper however formally state isat model represented collection parameterized partial functional relations data domains types example relation address 7 call stores address ie phone number object representing ongoing call state values referred within p ebf expressions via lookup operator example lookup call 1234 returns current call extension 1234 involved state predicate booleantyped isat expression predicates may parameterized typed formal parameters state predicate one address parameter usr member usr lookup knownaddresses equal idle lookup mode usr equal nocall lookup call usr predicate represents states idle address nevertheless still valid call object negation desirable state invariant thus generated scenario reaching state proves existence design error backprop operator formally isats backprop takes six arguments returns three values p 0 state predicate 0 list actual concrete parameters p 0 p 0 true evaluated model state 0 state model applying concrete input event e results new state 0 pictorially true 0 return value e event schema variablization concrete event e defining fresh formal parameters p state predicate taking arguments p 0 plus formals e list actuals p p true moreover specify states actual parameters applying eae model results state 0 p 0 ap 0 clarify formals p union formals p 0 event schema e thus actual list values formals e formals p 0 intuitively backprop computes sufficient necessarily necessary condition event e state prior applying e p 0 true afterward backprop applies explanationbased generalization 11 8 pebf formalism others described similar operators dijkstras predicate transformers igerashi et als verification condition generators18 beyond scope paper explain algorithm detail exam ple state 1 user 1234 mode idle event results state 2 mode 1234 dialing backprop applied 1parameter predicate equal dialing lookup mode returns event schema offhook predicate equal idle lookup mode x equal x actuals lists bind x 1234 intuitively means offhook idle user user move dialing mode backprop note succeeding scenario trace involving sequence input events iteratively apply backprop get entire generalized scenario initial predicate depend state isat scenarios defined never succeed depend uninitialized state values rest paper refer operation backprop takes model scenario trace predicate backpropagated together satisfying actuals list returns fully backpropagated predicate actuals list list event schemas making generalized scenario 22 isat tools overview isat exploits two hypotheses provide suite analysis tools help designer produce specification meets true needs requirer isat includes following tools ffl scenario simulation takes scenario model executes model determine whether scenario represents correct behavior model thus requirements scenarios directly validated ffl coverage analysis reports states never reached statements model executed requirement scenarios helps designer elicit adequate requirements requirer ffl layered theorem proving12 20 technique proving arbitrary correctness properties state invariants pseudostate diagrams12 ffl conflict detection14 returns predicates describing states model reaches derive inconsistent next state potentially causing either crash simulator worse implemented system inconsistencies result setting state relations two inconsistent values raising conflicting output events playing ringback tone busy tone time phone coverage analysis conflict detection proof attempts produce state predicates apply scenario generator order discover whether represent reachable states model 3 scenario generation problem formally scenario generation problem take model state predicate p 0 find sequence l concrete input events list actual parameters executing l starting undefined initial state results state 0 satisfying concentrated conjunctive state predicates ie whose expression consists logical collection predicates method applied disjunctions conjunctive state predicates applying concurrently disjuncts requires engineering efficiency beyond scope paper sections 1 2 discussed ways tool suite benefit solving problem rich formalisms model checkers17 symbolic model checkers5 guarantee find property valid model return concrete counterexample scenario illustrating vi olation thus explore circumstances tools solve scenario generation problem inventing different ways solve model checkers exhaustively search state space system testing property state thus limited size state space handle model checkers exploit limited forms state space symmetry handle systems larger spaces eventually run state explosion problem symbolic model checkers checked properties impressively large 10 120 spaces clear technique extended handle nonboolean logics survey model checking relation theorem proving verification see6 simply avoid models large state spaces believe answer several common types design problems manifest complex large unbounded state space models system example complex systems frequently designed modular fashion designing functional features independently combining feature sets meet customization market needs telephone switching systems good example approach yet many systems built way problem even though individual features valid isolation combination may lead undesirable interactions lead faulty behavior way tool discover interactions model feature combinations follows features system complex must model order detect interactions another reason limitedspace approaches final answer difficult enough abstraction make problem tractable yet retain enough detail manifest problems interest particular property checked may require different handconstructed model ab straction since designers dont know advance problems system could lot wasted effort andor false confidence results dealing complex models abstraction relatively straightforward single one used properties finally another reason prefer single easily produced abstraction clearly faithful system possibility generating implementations directly models either code synthesis direct manual implementation ten abstractions necessary tractability missing much detail allow direct mapping implementations example alur et al1 report model checking effort phone switch necessary model queue data structures 7 bit integers representing number items queue implementation must supply details queue implementation well system behavior depending actual contents queues scenario generation hard soon representation language allows event state parameterization functions added uncomputable constraint satisfaction problem problem combinatorial search large state spaces example designers commonly need models arithmetic lists data structures text manipulation functions pattern matching etc possible define systems properties satisfied system reaches state satisfying arbitrary sentence rich theory proving state reachable undecidable godels incompleteness theorem generating scenario actually reaches even harder combinatorial search thus summary want able apply scenario generation complex modeling formalisms yet problem goes merely search un computable hope cases find approach solve problem usefully many cases take long also require whenever tool returns scenario actually satisfies goal predicate soundness goals sgen 2 approach 4 sgen 2 approach let us term overall conjunctive state predicate goal predicate individual conjuncts making conjunct predicates simply conjuncts two key insights behind algorithm first library requirement scenarios unlikely scenario reaches state satisfying goal predicate nevertheless likely scenarios reach states satisfying sets conjuncts thus might find scenarios somehow paste together single scenario achieves full conjunction typically two scenarios operate different data items example scenario 1 may achieve set 1 conjuncts address 1234 scenario 2 achieves set 2 address 5678 thus two concrete scenarios cannot interleaved form scenario achieves union sets single address however second key insight solve subproblem abstracting two scenarios using backprop finding common instantiation binding variables data values union two predicate subsets satisfied common instantiation found heuristic search merges two event sequences one achieving union conjunct sets appendix gives precise highlevel pseudocode description sgen 2 algorithm following illustrative example taken case study consider goal predicate member lookup knownaddresses lookup fpractive equal dialing lookup mode x lookup tcsactive member x lookup tcsscreenedlist describes states known address two features fpr tcs active x tcsscreenedlist x dialing initialization sgen 2 first mines library discovers scenario init initaddress 1234 activatetcs 1234 1234 offhook 1234 results state satisfying 4 5 conjuncts member lookup knownaddresses equal dialing lookup mode x lookup tcsactive member x lookup tcsscreenedlist bind x 1234 since unlikely find another scenario fortuitously achieves rest goal constant 1234 apply backprop predicate trace scenario 1 get generalized scenario init initaddress x activatetcs x offhook x subject backpropagated condition equal x sgen 2 also records actual bindings recursive step sgen 2 rec continues searching mined library information satisfiers remaining conjuncts goal case discovers among others scenario 2 activatefpr achieves remaining conjunct lookup fpractive bound 5678 note since 1 2 operate different constants cannot directly interleaved get scenario reaching desired conjunction applying backprop remaining conjunct trace 2 get generalized activatefpr t1 t2 w subject constraints implicit type constraints actual bindings 1357g calls coinstantiate routine attempts find common instantiation g 1 g 2 obeying sets constraints case since constraint set g 2 empty coinstantiate quickly finds common instantiation sets finally calls mergescenarios two scenarios g 1 g 2 denote instances g 1 g 2 obtained applying mergescenarios also takes two predicates satisfied g 1 respectively check whether result satisfies simultaneously case mergescenarios finds following interleaving indeed satisfy conjunct sets init initaddress 1234 activatetcs 1234 1234 activatefpr offhook 1234 point still unsatisfied conjuncts goal sgen 2 rec would call backprop generalize result scenario recur search yet another scenario satisfy next subset coinstantiate mergescenarios fails move next candidates search cf appendix 41 library mining first step sgen 2 search library execution traces requirement scenarios states sets conjuncts satisfied subroutine minelibrary accomplishes follows scenario requirements library first generates execution trace calling simulator extracts trace sets data values grouped type appearing trace possible welltyped assignment data values formal parameters goal predicate searches states execution trace conjunct first becomes true parameter signment creates predicate group satisfier pgs state records assignment set conjuncts satisfied set satisfied conjuncts termed satset pgs minelibrary returns entire collection pgss found way traces sorts list decreasing order size satset sgen 2 consider earlier pgss satisfy predicates minelibrary linear total number states traces library importantly however proportional number parameter assignments exponential number goal predicate parameters current implementation seems work adequately fast case study examples 5 parameters may necessary limit number assignments considered goal predicate many parameters 42 coinstantiation coinstantiate heuristically attacks gen eral uncomputable problem coinstantiation simply trying possible welltyped assignments constants parameters g 1 g 2 constant pool simply union constants actualbindings pgss g 1 g 2 generalized proven effective case study takes negligible time see statistics necessary coinstantiate made consider larger constant pools scenarios 43 scenario merging mergescenarios takes two scenariopredicate pairs scenario results state satisfying predicate goal return interleaving two scenarios satisfies predicates mergescenarios attempt check possible interleavings would require checking exponentially many sum lengths two input scenarios interleavings worst case note worst case occurs time interleaving exists fairly common designate input scenariopredicate pairs left scenario predicate right scenario predicate approach sequentially select front event either left right scenario add end result scenario left right empty possible ways waiting left right empty checking predicates would result exponential worst case mentioned instead mergescenarios heuristically limits search follows time selects event e l left scenario checks see whether result scenario extended point remainder right scenario right predicate would satisfied e l vetoed otherwise proceeds next choice induction one show instead extended result remainder left scenario left predicate would also satisfied dual check done event selected right front events left right identical algorithm also attempts third option adding one event discarding note since interleavings satisfy predicates end contain intermediate points check would fail approach less powerful brute force search ever case study mergescenarios failed total scenario satisfiable attempts generated scenario satisfiable table 1 sgen 2 success case study brute force search would succeeded yet much 12 times faster average 2x 5 case study ran sgen 2 63 distinct scenario generation problems arose larger case study feature interactions telephone switch specification study actually produced 66 problems three duplicates discarded paper larger study actually tool contest associated 1998 feature interactions workshop7 system modeled telephone switch implementing plain old telephone service pots plus 12 functional features call forwarding cf terminating call screening tcs freephone routing nine others sgen 2 case study performed four twelve modeled pots eight features included related paper14 explain used isat tool set model specs detect various types feature interactions among many predicates describing states undesired things may happen feature inconsistencies becoming manifest conflicts feature correctness properties violated absence scenario genera tor left user determine whether state predicates describe reachable states model thus 63 problems provide moderately complex test power usefulness scenario generator representative problems may encountered tool full data available 15 results 63 predicates averaged 172 parameters 598 conjuncts table 1 shows results running generator scenario generated refers trials sgen 2 succeeded finding scenario satisfiableno scenario refers cases failed find scenario even though predicate satisfiable satisfiable refers cases determined external means unsatisfiable hence exists scenario generate scengen scengen total 8938 603 8335 library mining 658 510 148 backprop 1766 coinstantiation merge table 2 sgen 2 aggregate run times rounded nearest second table shows run time statistics 63 tri als times measured 225 mhz macintosh clone 144 mb memory running isat system macintosh common lisp 42 table noscengen condition includes cases tool find scenario whether goal predicate satisfiable since user equivalent waiting tool finish discussion 60 cases possible generate scenario sgen 2 succeeded 40 time thus user sure least cases illustrate real design errors therefore concentrate first fixing note one error cause scenarios fail due conflicts would otherwise succeed far enough reach second error state thus fixing error cause sgen 2 succeed failed previously know one definite case others suspected sort error interference occurred case study first ran study cases failed individual conjuncts covered scenario library course known way satisfy single conjunct goal predicate wont satisfied either fortunately relatively easy discover scenario covering single conjunct member x lookup tcsscreenedlist x easily created three scenarios cover cases resulting one success several failures results reflect additional scenarios turning time see average time per trial 142 seconds overall succeeding cases taking 25 seconds average 101 sec maximum failing cases requiring 214 seconds 1054 sec maxi mum note distribution time radically different succeeding failing cases mergescenarios dominating failing cases minelibrary dominating succeeding cases coinstantiate never significant suggesting room improve power checking larger constant pools example without significantly harming overall run time hand must extremely careful increasing power mergescenarios since bottleneck failing cases results intended suggestive future algorithmic improvements believe significantly reduced careful reengineering effort current isat system exploratory prototype note also results depend model scenario library well summary seems least validation purposes imperfect scenario generator still quite useful long doesnt take long course always hope better success av erage future work go improving heuristics however desirable keep times relatively low cases including failure cases tool still usable thus must engineer powerspeed tradeoff carefully 6 related work discussed model checkers summarize model checkers useful solutions problem scenario generation long one effectively generate models limited formalism necessary run tool tractably however reason believe need handle complex formalisms addressed work least reasons discussed section 3 addi tion may wish use scenario generation ways beyond validation online help systems comparison amusing estimate state space size necessary model telephony case study specs finite state formalism model 12 features n users estimate least reachable states logs base 2 consider callwaiting similar features need least 3 users add forwarding multiuser features one easily imagine properties referring 6 users leading would challenge even best model checkers note even infinitestate model checkers bultan et al4 highly restrictive system restricted state spaces cross product boolean state space one representing integer inequalities higher dimensional polyhedra increasing model checking power adding specialized constraint reasoners shows promise even clear reactive systems people design expressible within restricted formalisms due common occurrence functions mixing arguments several different types another class approaches problem may seem applicable aibased planners strips9 prodigy19 problem applying systems spec model provides planning operators planning operators must explicitly list consequences example strips operators must add delete lists simi larly macro operators learned ebgbased prodigy system must explicitly include goals achieve limiting users scenario generation may give goal statement wish terms functions defined logic planning operator derived spec model potentially achieves many infinitely many fact different goals far many stored explicitly even could bound vocabulary sgen 2 avoids problem abstraction reasoning fly minelibrary backprop knowledge stored raw scenario traces unadorned goal information also work traditional testing literature generating test inputs cover given path program example gotlieb et al10 describe constraintbased approach essentially reduces trying find satisfying assignment boolean functional expression course uncomputable enrich formalism include eg arithmetic however constraint based approach may prove useful improving coinstantiate minelibrary address state space search needed handle reactive systems finally spec modeling tool suites providing many contrasting tools isat scr tool suite16 environments may incorporate model checking none capable dealing rich formalisms scenario generators knowledge 7 limitations future work basic limitation sgen 2 fundamentally hillclimbing algorithm particu lar examples case study easily solved merging two scenarios li brary sgen 2 cannot find example one scenario achieves particular conjunct set halfway event sequence several steps removed backprop irrelevant achieving set turns necessary however one wishes later merge second scenario achieving rest goal extra steps things like hanging phone activating feature subsequent scenario must start idle state power comes richness scenario library therefore likely useful development processes environments encourage formalization scenarios sgen 2 pro vides perhaps new argument favor integrating formal scenarios software process sgen 2 still early youth many ways improved example search sgen 2 considers first pgs given satset better expensive approach try pgs backprop generalization isomorphic one seen previously effect runtime must monitored ever mergescenarios time bottleneck failing cases may profit work limiting search minelibrary needs search fewer cases predicate takes many parameters course results one case study con clusive future work investigate sgen 2 effectiveness domains systems conclusions scenario generation tool useful specification modeling tool suite focusing attention design errors demonstrably present helping communicate errors requirements even implementing online help systems exhaustivesearch approaches model checking useful tractable rich formalisms allowing direct system models expressed sgen 2 heuristic approach highly uncomputable problem based simple idea piecing together partially satisfying scenarios requirements library using explanationbased generalization abstract order able coinstantiate results case study encouraging sgen 2 seems succeed often enough useful yet efficient enough engineered interactive tool work needs empirical validation seems promising pursued r model checking realtime systems telecommunications application computational logic hand book verifying systems integer constraints boolean predicates composite approach states beyond formal methods state art future directions feature interaction detection tool contest learning executing generalized robot plans automatic test data generation using constraint solving techniques systematic incremental validation reactive systems via sound scenario generalization reactive system validation using automated reasoning fragment library avoid unwanted email feature combination interaction detection via foregroundbackground models complete case study data paper automated consistency checking requirements specifi cations design validation computer protocols automatic program verification logical basis imple mentation quantitative results concerning utility explanationbased learning seven layers knowledge representation reasoning support software development tr
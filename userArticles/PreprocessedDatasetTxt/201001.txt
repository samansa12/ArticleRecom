closure analysis constraint form flow analyses untyped higherorder functional programs past decade presented ayers bondorf consel jones heintze sestoft shivers steckler wand others analyses usually defined abstract interpretations used rather different tasks type recovery globalization bindingtime analysis analyses contain global closure analysis computes information higherorder controlflow sestoft proved 1989 1991 closure analysis correct respect callbyname callbyvalue semantics remained open correctness holds arbitrary betareductionthis article answers question closure analysis others correct respect arbitrary betareduction also prove subjectreduction result closure information still valid betareduction core proof technique define closure analysis using constraint system constraint system equivalent closure analysis bondorf turn based sestofts b introduction 11 background optimization higherorder functional languages requires powerful program analyses traditional framework analyses abstract interpretation typed languages suitable abstract domains often defined induction structure types example function spaces abstracted function spaces untyped languages calculus dynamically typed languages scheme abstract domains cannot defined abstracting function spaces function spaces domains used may difficult relate abstract interpretation denotational semantics article consider style program analysis result abstraction operational semantics past decade program analyses untyped languages presented authors address computer science department aarhus university ny munkegade dk8000 aarhus c denmark email palsbergdaimiaaudk permission copy without fee part material granted provided copies made distributed direct commercial advantage acm copyright notice title publication date appear notice given copying permission association computing machinery copy otherwise republish requires fee andor specific permission acm transactions programming languages systems 1714762 january 1995 also proc caap94 pages 276290 c jens palsberg ayers 1992 bondorf 1991 consel 1990 jones 1981 heintze 1992 sestoft 1989 1991 shivers 1991a 1991b wand steckler 1994 others although analyses used rather different tasks type recovery globalization bindingtime analysis based essentially key idea absence types define abstract domains terms program points example consider following term giannini rocca 1988 proved strongly normalizing term higherorder polymorphic type still program analysis might answer basic questions 1 every application point abstractions applied 2 every abstraction arguments applied answer questions subset program points particular term thus let us label abstractions applications also variables labeled variable bound labeled label binds free arbitrary label introducing explicit application symbol get following abstract syntax term analysis might able find matter reduction proceeds applied abstraction label 3 applied abstractions label 3 application point dd delta k applied application point labeled 12 applied abstractions labels 3 4 abstraction cb never applied application point abstraction label 5 applied quoted sentences give intuitive understanding precise statements follow particular example labels rather unnecessary name clashes happen reduction k cb normal form presence name clashes reduction however crucial use sets program points abstract values questions turned paramount importance many analyses untyped functional programs following sestoft bondorf call analysis answer conservatively closure analysis top closure analysis one build example type recovery analyses globalization analyses bindingtime analyses closure analysis answers questions higherorder control flow extension answers questions one really interested example type recovery role closure analysis thus follows closure analysis constraint form delta 3 higherorder closure analysis closure analysis useful higherorder languages general example objectoriented languages see palsberg schwartzbach 1991 1994b also useful typed functional languages type information usually specific enough tell functions among typecorrect ones called application point closure analysis extensions defined abstract interpretations differ radically traditional abstract interpretations however abstract domain defined terms program analyzed means analyses global abstract domain defined complete program required moreover program cannot take higherorder input would add program points also minimal function graph approach program analysis uses abstract domains defined terms input program contrast traditional abstract interpretations analyze pieces program isolation refer analyses based closure analysis flow analyses examples largescale implementations analyses found similix system bondorf bondorf 1993 bondorf danvy 1991 schism system consel 1990 system agesen et al 1993 analyzing self programs ungar smith 1987 last implementations demonstrates closure analysis handle dynamic multiple inheritance closure analysis extensions formulated using constraints others example heintze 1992 1994 wand steckler 1994 constraint systems spirit close although technically somewhat different key difference heintzes definition heintze 1994 attempts avoid analyzing code executed callbyvalue goal shared analysis palsberg schwartzbach 1992a idea defining program analyses using constraints set variables called setbased analysis heintze proved closure analysis correct respect call byname callbyvalue semantics remained open correctness holds arbitrary betareduction 12 results prove closure analysis correct respect arbitrary betareduction also prove subjectreduction result closure information still valid betareduction correctness result implies closure analysis correct respect reduction strategy present novel specification closure analysis allows arbitrary beta reduction take place subsumes previous specifications present closure analysis uses constraint system constraint system characterizes result analysis without specifying computed example constraint system given section 13 prove constraintbased analysis equivalent closure analysis bondorf 1991 turn based sestofts sestoft 1989 also jens palsberg prove analyses equivalent novel simplification bondorfs definition proofs correctness subjectreduction proceed considering constraintbased definition closure analysis contrast closure analyses abstract interpretation one using constraint system depend labels distinct makes possible analyze term betareduce analyze result without relabeling first abstract interpretations might modified property also would somewhat messy indicates direct proof correctness modified abstract interpretation would complicated proof presented article technique proving correctness generalizes without problems analyses based closure analysis following two results proved article safety analysis palsberg schwartzbach 1992a 1992b correct respect arbitrary betareduction follows subjectreduction prop erty terms stay safe betareduction bindingtime analysis palsberg schwartzbach 1994a proved correct palsberg 1993 proved correct elegantly new technique constraintbased definition closure analysis straightforward extend practical languages mediumsized example see palsberg schwartzbach 1994b analysis defined objectoriented language 13 example constraint system expresses closure analysis term set horn clauses term contains n abstractions applications constraint system contains n constraints thus size constraint system worstcase quadratic size term space constraints disallow us show fullblown example involving name clashes reduction consider instead term xxxyy abstract syntax constraint system expresses closure analysis term looks follows 3 1 ae 3 ae 4 ae 4 ae symbols forms l l metavariables relate variables label l abstractions label l applications label respec tively notice assume example one abstraction closure analysis constraint form delta 5 label l reason want closure analysis terms also arising betareduction may copy terms hence labels left constraints indicated arise first two constraints express abstraction may evaluate abstraction label rest constraints come pairs application point abstraction label l two constraints form flg metavar operator flg metavar operator constraints read first constraint operator evaluates abstraction label l bound variable abstraction may substituted everything operand evaluate second constraint operator evaluates abstraction label l everything body abstraction evaluates also possible result evaluating whole application solution constraint system metavariables assigned closure formation minimal solution constraint system mapping l example whole term normalizing evaluate abstraction label 2 l 4 application point 3 applied abstractions label 2 l 1 application point 3 point abstractions label 2 applied l 1 abstractions applied terms either normalize evaluate abstraction label 2 l 2 one theorems says computed closure information correct one might also try closure analysis term using bondorfs abstract interpretation another theorems says get result contract redex term result term abstract one third theorems says mapping l gives correct closure information also term following section define three closure analyses bondorfs simpler abstract interpretation one constraint form section 3 prove equivalent section 4 prove correct 2 closure analysis recall calculus barendregt 1981 definition 21 language terms abstract syntax defined grammar application jens palsberg labels variables abstraction symbols application symbols semantic impact mark program points label bound variable binds labels drawn infinite set label symbols l l labels labels application symbols part concrete syntax identify terms ffcongruent ffconversion changes bound variables labels assume variable convention barendregt 1981 term occurs article bound variables chosen different free variables achieved renaming bound variables occurrence l xe called redex semantics usual given rewritingrule scheme l xe ee 0 x l denotes term e substituted free occurrences x l notice variable convention renaming bound variables necessary substitution particular write l yee 0 x l 0 l 6j x l 0 l among free variables e 0 thus l yee 0 x l 0 write es e denote e obtained es 0 betareductions term without redexes normal form abstract domain closure analysis term e called cmape defined follows definition 22 metavariable one forms l l set metavariables denoted metavar term assigned metavariable function var maps x l l l xe l term e labe set labels abstractions applications occurring e notice labe finite set csete powerset labe csete inclusion ordering complete lattice set cmape consists total functions metavar csete set cenve contains function cmape restricted metavariables form l cmape cenve pointwise ordering written v complete lattices least upper bound written function hv 7 si maps metavariable v set maps metavariables empty set finally define upd 21 specification closure analysis state precisely closure analysis intuitive argument follows formal definition definition 211 term e every l 2 cmape define binary relation terms follows following four conditions hold l xe ex contains l 0 ze 0 flg lvare 0 contains l xe ex contains 0such flg closure analysis constraint form delta 7 flg closure analysis e produces l 2 cmape intuitively ex e get conservative information abstractions e closure analysis ex example first condition definition 211 illustrated follows theta theta theta theta theta theta theta theta theta theta theta theta theta theta case e abstraction label l thus ex evaluate abstraction label l first condition says case mapping l must satisfy flg lvarex words analysis must aware abstraction possible result evaluating ex three conditions definition 211 cover cases abstractions proper subterms e second condition covers case abstraction e body yet another abstraction third fourth conditions cover cases abstraction operator operand appli cation respectively illustrate first three conditions others similar theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta thetab theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta thetab z l 0 case e contains abstraction label l l xe abstraction turn body abstraction label l 0 l 0 l xe second condition jens palsberg definition 211 says case must abstraction ex label l 0 l 0 bound variable may different mapping l satisfies flg lvare 0 words analysis must aware abstraction l 0 ze 0 ex evolve abstraction body abstraction label l notice possibility one abstraction ex label l 0 thus want closure information body abstraction label l 0 must compute union information bodies abstractions ex label l 0 similar comment applies third fourth condition definition 211 use closure information concern article however 22 bondorfs definition recall closure analysis bondorf 1991 minor changes notation compared presentation analysis assumes labels distinct bondorfs definition originally given subset scheme restricted calculus note bondorfs definition based sestofts sestoft 1989 simplified bondorfs definition follows bondorfs original definition assigns distinct metavariables different occurrences variable contrast assign metavariable occurrence variable simplified definition equivalent bondorfs original definition see use notation l xe subterm term analyzed partial function body maps label l e definition 221 define upd l let c 0 vare 1 let 00 upd let ae 00 ae 0 l2c upd l 00 closure analysis e computing fstbe modify definition different occurrences variable assigned distinct metavariables obtain bondorfs original definition definition assign set metavariables occurrences given variable moreover computed closure information computed stated analysis leave details reader 23 simpler abstract interpretation bondorfs definition simplified considerably see consider second component cmape theta cenve component updated closure analysis constraint form delta 9 ae read bx l ae key observation operations done first component instead thus omit use cenve rewriting bondorfs definition according observation arrive following definition bondorfs definition assume labels distinct definition 231 define mx l f closure analysis e computing fixme key question simpler abstract interpretation equivalent bondorfs might attempt prove using fixedpoint induction find much easier using particular constraint system stepping stone 24 constraint system term e constraint system finite set horn clauses inclusions form p p 0 p p 0 either metavariables elements csete solution system element cmape satisfies horn clauses constraint system defined terms term analyzed need assume labels distinct set 1 consists two elements term e constraint system ce union following sets constraints every l xe 0 e singleton constraint set consisting flg l every e every l xe 0 e set 1 ce least solution namely intersection solutions closure analysis e computing solution ce canonical choice solution course least one closure analysis bondorf jrgensen 1993 understood adding two constraints 1 effect inclusions changed equalities thus closure analysis computes approximate information return analysis computed almostlinear time using formulation problem bondorf jrgensen 1993 whereas fastest known algorithm computing least solution ce uses transitive closure see palsberg schwartzbach 1992a 1994b 3 equivalence prove three closure analyses defined section 2 equivalent applied terms labels distinct use standard jens palsberg terminology prefixed point v lemma 31 prefixed point 0 every proof induction structure e lemma 32 ce least solution fixme proof prove stronger property solutions ce exactly prefixed points two inclusions considered first prove every solution ce prefixed point proceed induction structure e base case consider x l clearly every prefixed point mx l induction step consider first l xe suppose solution c l xe also solution ce induction hypothesis prefixed point hence get l met h l using definition prefixed point since c l xe solution flg l consider suppose solution solution ce 1 induction hypothesis prefixed point 1 hence get 1 using definition prefixed point 1 ce 1 solution second prove every prefixed point solution ce proceed induction structure e base case consider x l clearly every solution cx l induction step consider first l xe 0 suppose prefixed point l xe 0 lemma 31 also prefixed point 0 induction hypothesis solution ce 0 thus need prove satisfies flg l first use prefixed point result follows second one consider e 0 lemma 31 also prefixed point 1 using assumption get w f varbodyli result follows consider suppose prefixed point 1 lemma 31 also prefixed point 1 induction hypothesis solution ce 1 thus need prove every l xe 0 prefixed point 1 f varbodyli result follows lemma 33 ce least solution fstbe proof similar proof lemma 32 theorem 34 three closure analyses defined section 2 equivalent proof combine lemmas 32 33 closure analysis constraint form delta 11 4 correctness prove three closure analyses defined section 2 correct key define entailment relation 0 definition 41 meaning constraints constraint system 0 logically derived central result theorem 410 ex theorem proved without considering solutions involved constraint systems definition 41 constraint system h horn clause judgment h entails h holds derivable using following five rules reflexivity modus ponens 0 constraint systems 0 8h 2 lemma 42 reflexive transitive solutionpreserving 0 proof last property immediate using discharge reflexivity consequence last property transitivity suppose 0 statement 0 h h proved induction structure proof 0 h prove 00 suppose h 2 00 0 00 get 0 h statement finally get h prove solutionpreserving suppose 0 solution l need prove every h 2 0 h solution l proved induction structure proof h following lemmas structured modus ponens used proof lemma 43 weakening used proof lemma 46 aid intuition informally read vare vare 0 assumption term e smaller flow information term e 0 next lemma states two specific constraints derived constraint system redex informally first constraint says argument smaller flow information bound variable second constraint says body abstraction smaller flow information whole redex jens palsberg lemma 43 c l xe proof flg l xe result follows var l modus ponens next lemma substitution lemma informally states term gets smaller flow information subterm gets substituted one smaller flow information lemma 44 varu l vareux l vare proof induction structure e using reflexivity repeatedly informally next lemma states betareduction creates terms smaller flow information lemma 45 cex proof proceed induction structure ex base case consider x l conclusion immediate since x l normal form induction step consider first l xe suppose notice using reflexivity get l consider finally three cases suppose using reflexivity get suppose using reflexivity get suppose get former lemma 44 get varee 2 x l vare using transitivity finally conclude varee 2 x l informally next lemma states entailment robust betareduction substitution lemma 46 suppose 1 proof reflexivity lemma 45 lemma 44 result follows using weakening following definition needed stating proving lemma 49 definition 47 set w e union following sets constraints every e every l xe 3 every e 0 every l xe 3 e set 1 lemma 48 w w proof immediate closure analysis constraint form delta 13 next lemma substitution lemma like lemma 46 states entailment robust substitution lemma 49 w e u varu l ceux l proof let ae denote substitution ux l proceed induction structure e base case consider x l j l 0 result follows w e u lemma 42 x l 6j l 0 result follows w e u lemma 42 induction step consider first also case result follows w e u lemma 42 x l 6j l 0 ae induction hypothesis ce 0 ae thus need show every first follows c l 0 second consider e 1 subterm subterm u case result follows w e u lemma 46 consider finally notice induction hypothesis ce 1 ae ce 2 ae thus need show every l 0 ae notice either l 0 ye 0 subterm ye 0 subterm l 0 ye 0 subterm u case result follows w e u lemma 46 prove betareduce ex e constraint system ex entails constraint system e theorem 410 ex proof proceed induction structure ex base case x l conclusion immediate since x l normal form induction step consider first l xe suppose induction hypothesis thus need show c l xe flg l l xe 0 c l xe first follows using discharge second four cases notice discharge c l xe every xe first case suppose also subterm l xe result follows lemma 46 second case consider subterm e 0 l xe e result follows lemma 46 third case consider l xe yet result follows lemma 46 fourth case consider subterm e 0 substitution arises contraction redex lemma 43 get result follows lemma 46 consider finally every l xe xe three cases suppose e 1 induction hypothesis ce 1 0 thus need show every l xe 0 e 0 three cases first case suppose l xe 0 subterm result follows lemma 46 14 delta jens palsberg second case consider subterm l xe result follows lemma 46 third case consider subterm l xe l xe substitution arises contraction redex lemma 43 see ce 1 result follows lemma 46 suppose e 2 proof case similar case omit details suppose e 1 see ce 1 see w e result follows lemma 49 theorem 411 three closure analyses defined section 2 correct proof theorem 34 see three analyses equivalent applied terms labels distinct thus sufficient prove one defined using constraint system correct proof two steps step 1 use lemmas 43 44 45 prove cex ex following properties hold contains l ye ex contains l ze 0 vare vare 0 0such step 2 suppose cex solution l suppose ex e prove induction length ex e base case immediate induction step suppose theorem 410 cex solution l induction hypothesis prove four cases considered first suppose lemma 45 get cex finally result follows using cex solution l suppose l xe ez contains ze 0 flg lvare 0 step 1 proof get ex contains l 0 00 cex finally result follows using cex solution l last two cases suppose e contains either l xe respectively cases similar second one omit details finally prove subjectreduction result theorem 412 ce solution l solution l proof immediate theorem 410 lemma 42 acknowledgments author thanks torben amtoft nils klarlund anonymous referees helpful comments draft article closure analysis constraint form delta 15 r type inference self analysis objects dynamic multiple inheritance efficient closure analysis reachability lambda calculus syntax semantics similix 50 manual automatic autoprojection higher order recursive equations automatic autoprojection recursive equations global variables abstract data types efficient analyses realistic offline partial evaluation binding time analysis higher order untyped functional languages characterization typings polymorphic type dis cipline based program analysis flow analysis lambda expressions correctness bindingtime analysis safety analysis versus type inference safety analysis versus type inference partial types analysis efficient implementation functional programs replacing function parameters global variables self power simplicity selective lightweight closure conversion revised october tr self power simplicity binding time analysis high order untyped functional languages objectoriented type inference automatic autoprojection recursive equations global variable abstract data types automatic autoprojection higher order recursive equations safety analysis versus type inference partial types based program analysis objectoriented type systems selective lightweight closure conversion setbased analysis ml programs safety analysis versus type inference type inference self flow analysis lambda expressions preliminary version ctr jens palsberg patrick okeefe type system equivalent flow analysis acm transactions programming languages systems toplas v17 n4 p576599 july 1995 jens palsberg equalitybased flow analysis versus recursive types acm transactions programming languages systems toplas v20 n6 p12511264 nov 1998 paolo di blasio kathleen fisher carolyn talcott controlflow analysis calculus concurrent objects ieee transactions software engineering v26 n7 p617634 july 2000 suresh jagannathan peter thiemann stephen weeks andrew wright single loving mustalias analysis higherorder languages proceedings 25th acm sigplansigact symposium principles programming languages p329341 january 1921 1998 san diego california united states flemming nielson hanne riis nielson infinitary control flow analysis collecting semantics closure analysis proceedings 24th acm sigplansigact symposium principles programming languages p332345 january 1517 1997 paris france kirsten l solberg gasser flemming nielson hanne riis nielson systematic realisation control flow analyses cml acm sigplan notices v32 n8 p3851 aug 1997 flanagan matthias felleisen componential setbased analysis acm sigplan notices v32 n5 p235248 may 1997 anindya banerjee modular polyvariant typebased closure analysis acm sigplan notices v32 n8 p110 aug 1997 flanagan matthias felleisen componential setbased analysis acm transactions programming languages systems toplas v21 n2 p370416 march 1999 philippe meunier robert bruce findler paul steckler mitchell wand selectors make setbased analysis hard higherorder symbolic computation v18 n34 p245269 december 2005 neal glew jens palsberg typesafe method inlining science computer programming v52 n13 p281306 august 2004 david herman philippe meunier improving static analysis embedded languages via partial evaluation acm sigplan notices v39 n9 september 2004 christian fecht helmut seidl propagating differences efficient new fixpoint algorithm distributive constraint systems nordic journal computing v5 n4 p304329 winter 1998 philippe meunier robert bruce findler matthias felleisen modular setbased analysis contracts acm sigplan notices v41 n1 p218231 january 2006 thomas jensen types program analysis essence computation complexity analysis transformation springerverlag new york inc new york ny 2002 murali krishna ramanathan ananth grama suresh jagannathan static specification inference using predicate mining acm sigplan notices v42 n6 june 2007 v krishna nandivada suresh jagannathan dynamic state restoration using versioning exceptions higherorder symbolic computation v19 n1 p101124 march 2006 jens palsberg christina pavlopoulou polyvariant flow information intersection union types proceedings 25th acm sigplansigact symposium principles programming languages p197208 january 1921 1998 san diego california united states andrew tolmach dino p oliva ml ada stronglytyped language interoperability via source translation journal functional programming v8 n4 p367412 july 1998 h seidl h srensen constraints stop higherorder deforestation proceedings 24th acm sigplansigact symposium principles programming languages p400413 january 1517 1997 paris france andrew k wright suresh jagannathan polymorphic splitting effective polyvariant flow analysis acm transactions programming languages systems toplas v20 n1 p166207 jan 1998 anindya banerjee thomas jensen modular controlflow analysis rank 2 intersection types mathematical structures computer science v13 n1 p87124 february jens palsberg typebased analysis applications proceedings 2001 acm sigplansigsoft workshop program analysis software tools engineering p2027 june 2001 snowbird utah united states david schmidt tracebased abstract interpretation operational semantics lisp symbolic computation v10 n3 p237271 may 1998
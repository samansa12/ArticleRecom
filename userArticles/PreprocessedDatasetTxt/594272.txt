full formalization sldresolution calculus inductive constructions paper presents full formalization semantics definite programs calculus inductive constructions first describe formalization proof firstorder terms unification proof obtained similar proof dealing quasiterms thus showing relate inductive set subset defined predicate sldresolution explicitely defined renaming process used sldderivations made explicit thus introducing complications usually overlooked proofs classical results last switching lifting lemmas soundness completeness theorems formalized present two lemmas usually omitted needed development also contains formalization basic results operators fixpoints general setting proofs results presented checked proof assistant coq b introduction paper concerned programming languages semantics aim formalize sldresolution calculus inductive constructions coq first terms substitutions dened unication theorem constantly used denition semantics denite programs proved similar theorem quasiterms 26 present formal denitions syntactic objects used logic programming atoms queries clauses etc introduce interpretation schemes last declarative operational semantics denite programs introduced proofs fundamental results theory logic programming formalized lifting switching lemmas soundness completeness theorems reader assumed familiar terminology basic results semantics logic programs introduced 2 19 course exists extensive literature logic programming 3 2 17 19 28 theorems proved one wonder usefulness formalization recall formalizing proof rst consists giving formal denitions objects used explicitely stating priori hypotheses needed last inferring conclusion therefore since proofs encoded using coq proof assistant objects properties explicitely dened well hypotheses needed proofs step proof also explicitely results denitions applications induction schemes lemmas orems makes dierence initial proofs found many books logic programming hence formalizing proofs brings us level detail often left reader see take account details often considered minor informal presentations proofs getting bit complicated furthermore see assumptions usually overlooked required theorems proved main diculty development concerned denition variable renaming process used sldderivation made explicit thus introducing complications usually omit ted instance see proof completeness theorem delicate seems requires formal point view several technical lemmas papers devoted details however 27 j c shepherdson points inaccuracy basic results theory logic programming presents discussion role standardizing apart sldresolution let us give famous ex ample coming paper showing classical result incorrectly stated famous book 19 j w lloyd gives fundamental theorem completeness sldresolution following form let p denite program g denite goal every correct answer p fgg exists computed answer p fgg substitution 1994 j c shepherdson wrote theorem true 27 gave simple counterexample course true nd two substitutions g however although act variables occurring g imply restricted yield another typical example lifting lemma generally stated follows program n goal substitu tion suppose exists sldrefutation p fng sequence mgus exists sld refutation p fng sequence mgus 0 n 0 0 general assumptions substitution supposed however order formalize corresponding proof builds derivation starting n assume hypotheses let x variable occurring domain n occur n whereas x used renamed clauses derivation starting n cannot used derivation starting n hence order exactly use sequences variant clauses always suggested two derivations suppose variable used renaming input clauses derivation starting n occurs n furthermore similar reasons order prove 0 suppose variable used renaming input clauses derivation starting n occurs domain similar problem happens proof switching lemma asserting sld derivation two atoms l 1 l 2 successively selected also selected reverse order derived states renaming variables z z want exactly use variants c 1 c 2 two derivations assumptions required hypotheses coming initial derivation however want select l 2 l 1 c 2 c 2 must satisfy nothing switching lemma ensures property depending standardization apart used sldderivations possible variable occurring r 0 occurring r 1 occurs c 2 avoid problem c 1 c 2 must satisfy holds use standardizing apart coming 2 hence formalizing proof brings us greatest level detail problems due variables occurring input clauses variants clauses used resolution steps coinciding variables derivation surprisingly another problem comes necessity explicitation priori assumptions needed obtain proof curiously even requirement seems natural common practice logic programming suppose proofs paper basic results assumptions variables occurring clauses used without justication course exists independence result asserting existence derivation depend choice variables input clauses even choice important proofs results still correct however properties variables formally proved independence result furthermore express properties objects occurring theorem instance cannot suppose proof clause share variables goal built proof goal appear theorem standard semantics la herbrand denite programs deals wellknown objects substitutions renaming however several nonequivalent denitions objects found literature thus introducing confusion example meaning renaming often assumed simpler formal denition implies 15 h p ko e nadel point dierent authors give subtley dierent denitions substitu tions cite six nonequivalent denitions point implication instance relation thus giving dierent versions lifting lemma therefore substitutions simple might rst ap pear motivates authors r kemp g ringwood 14 take instance relation primitive rather taking substi tutions also confusion literature concerning denition general uniers mgu short 18 j l lassez j maher k marriot compare four nonequivalent denitions mgu course logic programming concerned problems also subject confusions sldderivation following denitions renaming process required sldderiv ation found confusion arises conditions fact dene dierent hypotheses least two reasons conditions first standardization apart needed order able unify selected atom head variant clause used last reason obtain general possible answer substitution therefore formalization settles problem variable renaming long cause errors eld logic programming description coq use version 62 proof assistant coq 4 allows interactive development formal proofs coq based logical framework known calculus inductive constructions 5 extension typed calculus supporting dependent types polymorphic types basic idea underlying logical framework based curryhoward isomorphism 9 17 proof proposition seen functional object instance proof proposition form b function mapping every proof proof b type function isomorphic proved proposition types proposition identied objects proofs furthermore framework allows denition inductive coinductive types specied constructors classical example inductive type denition natural numbers dened system coq inductive three induction principles automatically generated denition natid pnatsp onnatp np nnnatp n id either indprop recset recttype classical example coinductive type type innite sequences formed elements type streams shorter coq introduced coinductive set stream asetconsastream astream note induction principle coinductive types coq also allows denition mutually recursive types shall use two distinct sorts prop type logical propositions set type data type specications type prop set type constructing proof within coq interactive process given goal user species deduction rule applied coq computations theorem prover solves successive subgoals tactics ie functions build proof given goal proofs elementary subgoals goal apply tactic subgoal n 3 terms unication rst step development consists naturally formalizing uni cation terms unication algorithm deals two sets terms substitutions let us rst present formal denitions given functional signature ie countable set arity function ar countable set x variable symbols terms x dened induction follows f functional symbol l list terms length n tff l term time introduce dependent type l n x lists terms length n x l n x mutually recursive substitutions dened applications x x recall given two terms 1 2 substitution called unier 1 2 unift called minimal unier minunift every unier 0 1 2 0 ie exists substitution 0 0 denoted predicate lesssubstt unier 1 2 called general unier minimal idempotent ie 8x 2 x denoted predicate idempotentt relevant 1 2 ie every variable occurring domain also occurs list formed 1 every variable occurring range also occurs list formed 1 2 underlt denitions extended lists terms instead formalizing unication terms following standard approach based unication algorithm since similar formal proof dealing quasiterms obtained j rouyer 26 transposed unication property quasiterms terms originally quasiterms introduced z manna r j waldinger order illustrate technique program synthesis 21 unication algorithm derived proving specication satised proof veried within cambridge lcf theorem prover 10 l c paulson 23 similar proof obtained j rouyer 26 quasiterms dened follows used obtain variable quasiterms constant quasi terms functional quasiterms consarg used build nonempty lists quasiterms terms lists terms merged single data type instance term fx gx obtained follows precisely j rouyer proved exists unier q 1 q 2 two quasiterms well formed unier quasisubstitution indeed substitution clearly x proper subset q x consargconsargx x x neither term list terms order transpose unication property dene mapping f wellformed quasiterms ie quasiterms representing terms terms however coq incorporate notion partiality function total current solution taken development consists considering simultaneously quasiterm proof well formed hence predicate p q x characterizing wellformed quasiterms dened depending type p two approaches possible rst one corresponds programming language type p dened recursively structure quasiterm q considered q well formed use applied q x proof proposition false obtained q proof wellformed second approach corresponds proofs language approach type dened recursively structure proof quasiterm considered well formed addition interest unication theorem motivated developing approach based reusability formal proofs therefore development shows dene partial functions precisely outline two inductively dened sets predicate p e 1 exists bijection e 2 dene following functions two characteristics problem follows 1 dened predicate allow direct denition functions predicates e p 1 therefore every expression stands 8e 2 know bijection furthermore would like function f 21 easy obtain seeing every e 2 e 2 relation element e 1 furthermore every e 2 denition f 12 rather critical denition pred icate domain f 12 technique used consists dening inductively every e 1 e 1 collection pe 1 proofs p logically equivalent pe 1 computational content course every e 1 e p 1 must exist proof p way position dene recursively structure proof function 8e 1 hence according def initions proofs viewed objects data structures mathematical collection inhabiting set type explicit algorithmic content thus allowing proceed induction proofs dene recursive functions structure proofs since e 2 isomorphic subset aim map result e 1 result e 2 proving conservativity lemmas let u 1 u 2 two formal properties respectively e 1 e 2 quasiunication unication assume property u 1 holds e 1 given two functions f 12 f 21 prove property u 2 e 2 following reasoning let e 2 element hypothesis u 1 f 21 e 2 exists proof p f 21 claim follows since manner proved unication theorem without really working unication proving conservativity lemmas full presentation proof see 13 theorem 31 unication given two terms 1 2 either 1 2 uniable exists idempotent minimal unier relevant terms 4 objects used logic programming present section formal denitions objects used logic programming introduce interpretation schema first let relational signature collection x atoms inductively dened follows p predicate symbol l list terms length n plp l atom queries denite clauses denite programs horn clauses dened atoms arity arfun nat mutual inductive ar f term listterm nat set cons nnatterm listterm nlistterm n subst var term inductive unificationtt1t2termset cons t1 cons t2 nil cons t1 cons t2 nil unificationt t1 t2 inductive quasiterm set vvarquasiterm cfunquasiterm rootfunquasitermquasiterm consarg quasitermquasitermquasiterm table 1 terms substitutions unication order able give interpretation objects necessary attach meaning symbols occurring therefore let us dene interpretations signature let n dependent polymorphic type lists elements type length n bool set booleans usual operators order dierentiate operators prop dene two collections mappings f n formed mappings n p n formed mappings n bool according denitions interpretations domain dened classical way f arf hence given interpretation resp nary function f predicate p interpreted mapping f bool position give following interpretation x inductive atom set plpprediclistterm arityp patom inductive request set truereqrequest consreqatomrequestrequest c x definition clausesetatomrequest inductive program set nilpgmprogram conspgmclauseprogramprogram inductive horn set hpprogramhorn hrrequesthornhorn table 2 syntactic objects schemes first dene x collection valuations mappings x terms lists terms interpreted follows let interpretation domain term resp list terms l length n interpreted application dened f l v l nil cons constructors n cons constructor l n x henceforth nd convenient write denote interpretation object clause interpreted application dened l v r false b true v ri v v b r v true c v v r v inductive dsetnnatlist nd definition fi set set dsetffunfn arity ar f x definition valuationsetsetasetvara fixpoint interpt dsetifi dtterm valuation ddvvaluation case ffunllistterm arity ar f f applyl arity ar f l v end applyl dsetifi dnnatllistterm n valuation list n vvaluation dnnatlist ncase l nil n0natt0terml0listterm n0 cons n0 interpt t0 v applyl n0 l0 v end bool inductive boolset truebool falsebool dsetnnatlist n bool definition pi set set dsetppredicpn arityp p table 3 interpretations interpretation domain said model object atom query every valuation v case write depending interpretation schema used query r write either r j r note whereas given valuation v 2 x proposition true decidable since innite set proposition necessarily decidable introduce many complications following terminate dene relation logical consequence j horn clause query follows general interpretation schema definition interpo dsetfi dpi valuation dbooldsetiffi dippi vvaluation case end p0predicl0listterm arityp p0 request false orb neg interpp ip l0 v interpr ip r0 v request true andb interpp ip l0 v interprn ip r0 v clause aatomrrequest orb interpr ip r v interpp ip v true andb interpc ip c0 v interpp ip p0 v pprograminterpp ip p v andb interpr ip r0 v interph ip h0 v definition ovaliddsetfi dpi doprop vvaluation dinterpo ip l vtrue request prop hvalid ip hreqnvalid ip r table 4 interpretations models 5 sldresolution logical approach denite programs split two parts declarative semantics determines computed operational semantics given sldresolution describes computed execution denite programs based combination two mechanisms replacement unication form computing specic form theorem proving called sldresolution selection linear denite 51 resolution transitions resolution rule inference rule denes deductive relation c denite clause c c program p atom called head c c query called body c r query r renaming substitution variable occurring rc also occurs r write resolution rule following abbreviated manner mgu r n rc r n stands n 1th atom r atnreq rn rc query obtained replacing r n 1th atom query rc changenr n rsubstreq r bodyc c r resolution step two choices made choice selected atom choice input clause whose head unies selected atom therefore resolution rule viewed rule moves state another dened follows first introduce sr collection mappings x x classical properties substitutions extended sr predicate p r sr characterizing renaming substitutions r occurring domain r also occurs range r r idempotent resolution state pair r substitution r query give formal denitions renaming conditions satised transition r first initial resolution state r must satisfy r renaming substitution r rename variables occurring c variables denoted prc r c last dene two predicates satised variable occurring range r also occurs domain p rs query r p rr position dene predicate p collection transitions mgu 1 2 atmgu means general unier 1 2 52 sldresolution derivations nite valid sldderivation nite sequence composable transitions satisfying predicate also hence derivations dened inductively lists proofs properties sldresolution obtained induction derivation using left induction schema however soundness proof shall need right one hence dene two collections derivations follows l r isomorphic l l c l z left induction z right induction two functions dened order relate two sets transitions dene predicate l characterizing valid derivations sequence composable transitions satisfying predicate p additional renaming condition introduce following deni tions two transitions e 1 f e 2 f said composable function l computes list variables occurring input clauses deriva tion dened predicate p l recursively dened p p resolution states definition statesetsubstrequest fst snd projections product type sr definition renamevarvar definition goodrenamerenamepropsrrename yvarxyrdom sr xrdom sr sr xsr yrdom sr xrrange sr x definition renamecrenameclauseprop prr definition renameoutreqrenamerequestprop prs definition renameoutdomrenamesubstprop xvarrdom r xs r xtv r x inductive transsettransconsstateprogramnat clauserenamesubstatomstatetrans inductive rsl eistatepprogramnnat cclauserrenamessubstaatomefstateproprslinit le n lengthr snd ei rsubstat r headc c h4 goodrename r xvarsubstt fst ei x substreq rsl ei p n c r ef definition rsltranspropttrans case aatomefstatersl ei p n c r ef end table 5 transitions l inductive derivset derivcons deriv trans deriv inductive derivfcons trans derivf derivf inductive coupletransok t1transt2transprop coupletransokinitptrans t1ptrans t2 stateendt t1stateinitt t2rsl t1rsl t2 coupletransok t1 t2 fixpoint listvarcd dderivlistv case varcl rsubstcl srtrans t0 ctrans t0 d1derivt1transappv listvarcd d1 varcl rsubstcl srtrans t1 ctrans t1 end fixpoint derivok dderivprop case coupletransok endd d2 t2derivok d2 rrange srtrans t2 x end table derivations stands last transition 0 r stands initial query r stands renaming substitution used transition 0 denitions allow full formalization classical properties sld resolution presented next section 6 basic results sldresolution denes relation satisfying several important properties logical ones soundness completeness two others particular form computation lifting switching lemmas 61 two classical lemmas 611 switching lemma resolution step derivation atom clause must selected following wellknown lemma ensures nondeterminism choice atom matter called dont care nondeterminism lemma 61 switching valid derivation two atoms b successively selected also selected reverse order derived states renaming variables lemma proved decomposing two transitions id r 0 z id stands identity substitution tv furthermore note suppose rst selected atom second query r thats assumption proof presented details 12 classical requires constantly denition variable renaming process used valid derivation note explicitely build proof substitution relating two derived states thus allowing us assert renaming variables 612 lifting lemma lifting lemma another classical lemma used completeness proof said introduction assume additional conditions renaming used order prove lemma 62 lifting let id r valid derivation nite list variables l dom l exists valid derivation id r query r f r proof obtained induction derivation using left induction schema two derived states explicitely related full presentation see 12 62 two fundamental properties answers solutions dene operational declarative semantics denite programs given denite program p solutions query derivok fst stateinitd dtv snd stateinitd dsubstreq eta r rrange srtrans x ptrans t1ptrans fst ex rfrequestsnd stateendd d0 substreq fst stateendd d0 rf snd stateendd dsubstreq fst stateendd substreq eta rf xvarsubstt fst stateendd eta x derivok derivcons derivcons t1 t2 le plus ntrans t1 lengthr bodyc ctrans t1 ntrans t2 fst stateinitd dtv derivok derivcons derivcons ntrans t3s minus ntrans t2 lengthr bodyc ctrans ntrans t4ntrans snd stateendd derivcons derivcons t1 t2 substreq r snd stateendd derivcons derivcons snd stateendd derivcons derivcons t3 t4 ex vvar r xtv v table 7 lifting switching lemmas fst stateinitd dtvsnd stateendd dtruereq substreq answer snd stateinitt headd table 8 soundness sldresolution r substitutions h p p declarative description desired output denite program query conversely operational counterpart solutions answers id r valid derivation answer r 621 soundness sldresolution soundness theorem expresses every answer query also solution query theorem 61 soundness denite program p query r get valid derivation id r corresponding proof requires notion free transitions transitions satisfying resolution rule except uniers used necessarily general uniers hence condition initial step condition h5 predicate rsl necessarily hold proof obtained using right induction schema 622 completeness sldresolution let us turn formalization completeness theorem sld resolution exists solution query exists answer query form completeness theorem weaker usual completeness theorem soundness theorem proved dont relate solution answer usual need new denitions lemmas rst let us summarize first dene herbrand interpretations respect denitions dene inductively collection ground terms groundterm terms containing variables obtained using function symbols occurring set also called herbrand universe time collection l n lists ground terms dened similarly dene collection ground atoms groundatom formed using relation symbols ground terms herbrand universe arguments set also called herbrand base also dene collection ground substitutions groundsubst mappings x exactly corresponds x furthermore avoid uninteresting complications assume signature used contains constant ie 0ary function symbol hence abovedened sets nonempty 8 j h gallier discusses detail need least one constant symbol context herbrand theorem introduce denition herbrand interpretation written h every f 2 f h mapping arf dened tfg unique constructor ground terms l 0 type l arf obtained l using denition dene herbrand interpretation interpretation ground terms based h since herbrand interpretations assignment constants functions xed seems possible identify herbrand interpretation subset herbrand base dened predicate characterizing ground atoms however note specications correspond two dierent kinds specications whereas every herbrand interpretation every ground atom proposition decidable arbitrary predicate p proposition pa therefore later well use theorems need get predicate herbrand base herbrand interpretation proposition assumption use assumption mapping fixpoint characterization least herbrand model completeness sldresolution obtained cost strong assumption implicitly suggested identication type every denite program p dene predicate least herbrand model p intersection herbrand models according denition 28 prove g wish obtain deeper characterization set using xpoint concepts study herbrand models denite programs r kowalski van emden associate denite program p operator p called immediate consequence operator provides link declarative operational semantics de nite programs using identication herbrand interpretation predicate herbrand base operator usually dened follows table 9 declarative semantics let p denite program p predicate ground atom clause c occurring p ground substitution p pa since possible variables occur atoms 0 cannot establish decidability p p even know decidability p given necessarily ground atom herbrand interpretation cannot prove decidability proposition interpretation model atom needed evaluate atoms necessarily ground body clause aected p since herbrand models program p exactly xpoints p formalize results operators xpoints general setting fact p easily seen upward continuous follows least xpoint p equal p us turn denition operational counterpart least herbrand model success set denite program dened predicate p herbrand base characterizing ground atoms exists sldrefutation starting two technical lemmas presented end section prove p equal p assumption every predicate herbrand base decidable position prove completeness theorem following theorem 62 completeness let p denite program r nonempty query solution r exists following valid derivation id r operators aset definition paaprop definition oppapa inductive ordset fixpoint ordfirst nnatord case n soordord oo lonatordord pnatso ordfirst p end ordinal powers fixpoint aafalse lnat ordaaex nnatpof f l n end theorem table 10 operators ordinals xpoints one delicate step proof completeness theorem sldresolution concerned combination derivations proof made induction length initial query following argument always used refutation b ground refutations combined refutation p however combination derivations rather delicate way made never given therefore formalization proof need technical lemma whose proof immediate shows constructive way nal refutation obtained initial ones course order ensure good properties variables occurring nal refutation able rename initial refutations first following variant lemma seldom stated whose proof immediate proved dierent form 2 stated 20 lemma 63 variant lemma let l list variables 1 valid derivation id r exists valid derivation 2 id r inductive tp inductive success pprogramagroundatomprop pderiv dpderivok fst stateinitd dtvsnd stateinitd consreq groundtoatom truereq snd stateendd dtruereq success p rtruereq semanticcsq hp p substreq r fst stateinitd snd stateendd table 11 completeness sldresolution variable occurring 2 also occurs l furthermore substitution r doms r varr 2 r words existence derivation depend choice variables input clauses suces good properties hold formalizing lemma consists building derivation 1 starting r nite set variables z derivation 2 starting r variable occurring input clauses 2 also occurs z r z z z d2 immediate consequence obtain following lemma lemma 64 combination derivations let p denite program r nonempty query ground substitution every atom occurring r success set p exists valid derivation id r proof proceed induction r claim obvious induction hypothesis every atom 0 occurring r p 0 exists valid derivation id r moreover hypothesis induction hypothesis build valid derivation r furthermore 1 p denition exists valid derivation ground substitution prove induction 1 3 id c r r also valid derivation moreover 2 lemma 63 exists valid derivation 4 induction 4 prove 5 valid derivation hence combining 3 5 suitable renaming conditions one obtains valid derivation id c r r settles claim j said formal completeness proved weaker soundness theorem proved dont relate solution answer due following usual step proof variables n enrich language p adding new constants substitution fx 1 exists sld refutation p f ng textually replacing refutation x operation cannot formalized using denitions allow add new constants functional signature textually replace constants variables variables constants possible solution could consists following ssemantics approach developed 7 allows variables herbrand base 7 related work said unication quasiterms formalized l c paulson 23 using lcf j rouyer 26 using coq concerning deni tion partial functions c dubois v vigui donzeaugouge 6 recently proposed method generate automatically predicate p characterizing domain partial function f equations dening f mlstyle formal completeness proofs envisaged several au thors 24 h persson presents formalization using proof assistant alf constructive completeness proof intuitionistic predicate logic wrt models based formal topology 11 j harrison discusses formalization hol basic rstorder model theory including compact ness lowenheimskolem uniformity theorems 16 j l krivine describes formalization second orderlogic intuitionistic proof completeness theorem classical logic finally note area formal methods applied logic programming starting operational semantics prolog soundness completeness proofs renement step toward warren abstract machine wam elaborated c pusch 25 theorem prover isabelle 8 conclusion order prove formal properties programs seems natural give formal specication operational semantics paper sldresolution formalized fundamental properties form computation proved 600 technical lemmas formalized development proofs machinechecked based j w lloyds book 19 follow traditional chosen take referential notion truth semantical notion alternative could consist taking another referential notion like natural deduction sequent calculus first note instead proving unication theorem following unication algorithm j rouyer 26 used result quasiterms obtain proof technique proposed based dening bijection terms quasiterms satisfying given predicate proving preservation unication property way proved unication theorem without really dealing unication theory thus avoiding heavy proof requiring handle sophisticated theories construction interesting represents alternative classical approach shows take advantage previous formal proof even desired proof exactly deal objects whereas unication theorem proved 26 requires 140 lemmas 75 lemmas proved development shows interest proofs library provided informal presentations variable renaming problems often ignored however problems cannot ignored said results presented proved calculus inductive construc tions thus making dierence proofs one nd many books logic programming main dierence concerned renaming process used sldderivation made explicit typical example proof completeness theorem requires variant lemma assert ing existence sldderivation depend choice variables input clauses used lemma combination derivations explicitely allows operation whose proofs rather long therefore formalizing sldresolution introduces many complications even combining sldderivations seems easy operation requires several renamings order satisfy standardization apart assumed denition derivation usually lemmas implicitly used without proof justication surprisingly full formalization proofs shows minor details could crucial interesting discussion ne points foundations logic programming found 15 27 course main problems come explicitation substitutions used unication variable renaming processes substitutions quite hard matter deal 1 substitutions said minence grise calculus also said sldresolution like sldresolution clauses reduction denes relation terms may interesting compare properties relations whereas reduction conuent sldresolution satises switching property weaker conuence fur thermore variables renaming process used sldderivation viewed implicit conversion renaming made explicit allows full formalization sldderivations along lines calculus explicit substitutions 1 reduction calculus renement calculus substitutions manipulated explicitely provides link classical calculus concrete implementations renaming process required sld derivation plays essential role logic programming constitutes important step denition operational semantics denite programs declarative reading horn clauses acknowledgments many thanks ren lalement enlightening discussions work well anonymous referees useful comments r explicit substitutions logic programming contributions theory logic programming project coq calculus constructions step towards mechanization partial functions domains inductive predicates declarative modeling operational behavior logic languages logic computer science proofs types edinburgh lcf formalizing basic formalization sldresolution calculus inductives constructions reynolds heyting models logic programs koichi furukawa une preuve formelle et intuitionniste du thorme de compltude de la logique classique computation logic foundations logic programming partial evaluation logic program ming deductive synthesis uni logic programming prolog verifying uni constructive completeness intuitionistic predicate logic formalization type theory dveloppement de lalgorithme duni role standardising apart logic programming semantics predicate logic programming language tr
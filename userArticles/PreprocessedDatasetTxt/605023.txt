challenges componentbased development generally understood building software systems components many advantages difficulties approach ignored system evolution maintenance migration compatibilities challenges met developing componentbased software system since systems evolve time components must maintained replaced evolution requirements affects specific system functions particular components also componentbased architecture levels increased complexity consequence different components systems different life cycles componentbased systems easier replace part system commercial component process however straightforward different factors requirements management marketing issues etc must taken consideration paper discuss issues challenges encountered developing using evolving componentbased software system industrial control system used case study b overview abb global electrical engineering technology company serving customers power generation transmission distribution industrial automation products etc abb group divided companies one abb automation products ab responsible development industrial automation products automation products encompass several families industrial processcontrol systems including software hardware main characteristics products reliability high quality compatibility features results responses main customers requirements customers require stable products running around clock year year easily upgraded without impact existing process achieve abb uses componentbased system approach design extendable flexible systems advant open control system ocs abb 2000 componentbased suit different industrial applications range includes systems power utilities power plants infrastructure pulp paper metals minerals petroleum chemical consumer industries transportation systems etc overview advant system shown figure 1 business system information management station operator station process controller process controller process controller figure 1 overview conceptual architecture advant open control system advant ocs performs process control provides business information assembling system different families advant products process information managed level process controllers process controllers based realtime operating system execute control loops operator station os information management station ims gather product information business system provides analysis information optimization entire processes advant products use standard proprietary communication protocols satisfy realtime requirements advant ocs therefore includes information management functions realtime insight aspects process controlled advant information management sqlbased relational database accessible resident software connected computers historical data acquisition reports versatile calculation packages application programming interface api proprietary third party applications examples functionality provided advant components access process production quality data process control unit plant intranet domain designing reuse designing reuse existing components many advantages sommerville 1996 software development time reduced reliability products increased important prerequisites advant ocs development advant ocs products assembled many different configurations use various branches industry specific systems designed reuse advant ocs products external products means customers get tailormade system meets needs external products components used together advant ocs due openness system example satellite communication component used transmit data offshore station supervision system inland integrated advant ocs advant system architecture designed reuse different products operator information management stations used system components assembling complete systems two operator station versions master os mod os used building different types operator applications scalability advant ocs configured multitude ways depending size complexity process initial investment consist standalone process controllers optionally local operator stations control supervision separate machines process sections subsequently several process controllers interconnected together central operator information management stations build control network several control networks interconnected give complete plant network share centrally located operator information engineering workplaces openness system strengthened flexibility add special hardware software specific applications weighing fixed variablespeed motor drives safety systems product quality measurements control example paper industry second third party administrative information control also easily incorporated costeffectiveness stepbystep expansion capability advant ocs allows users add new functionality without making existing equipment obsolete systems selfconfiguration capability eliminates need engineers enter edit topology descriptions new stations physically installed new units added system full operation advant ocs system expansion therefore easy costeffective reusable components advant ocs products component based minimize cost maintenance development figure 2 shows component architecture operator station assembled components figure 2 operator station assembled operator station functional components object management omf osbase functions realtime operating system user interface component library standard operating system components operator station consists specific number functional components set standard advant components components use user interface system uis component object management facility omf component handles infrastructure data management omf similar corba omg 2000 provides distributed object model data operation event services uxbase component provides drivers specific operating system functions helper classes strings lists pointers maps generalpurpose classes available ccomplib library component components built upon operating systems one standard systemsuch unix windows proprietary realtime system illustrate different aspects componentbased development maintenance shall look two components object management facility omf business type component highlevel functionality complex internal structure ccomplib basic general library component object management facility omf omf nbling et al 1999 objectoriented middleware industrial process automation encapsulates realtime process control entities almost every conceivable description objects accessed applications running different platforms example unix windows nt programming interfaces available many languages c c visual basic java smalltalk sql interfaces iec 11313 iec 1992 process control languages development omf also adapted microsoft component object model com via adapters another component called omf com aware adapters opc ole process control opc 1998 ole automation also implemented thanks software interfaces omf makes process production data available majority computer programmers users ie even necessarily involved industrial control field instance easy develop applications microsoft word excel access access process information omf developed demanding realtime applications incorporates features realtime response asynchronous communications standing queries priority scheduling data transfers one side omf provides industrystandard interfaces software applications offers interfaces many important communication protocols field including masternet mod dcn tcpip fieldbus foundation adapters make possible build homogeneous control systems heterogeneous field equipment disparate system nodes omf reduces time cost software development providing frameworks tools wide range platforms environments utilities well integrated respective surroundings allowing developers retain tools utilities prefer work ccomplib ccomplib class library contains generalpurpose classes containers string management classes file management classes etc ccomplib library developed standard libraries available market main purpose library improve efficiency quality promote uniform usage basic functions ccomplib component according definition szyperski 1998 component unit composition deployed independently product however development process ccomplib treated similar way binary components restrictions dynamic configuration experience advant system successful system main reasons success componentbased architecture giving flexibility robustness stability compatibility effective build integration procedures type architecture similar product line architectures bass et al 1999 case studies bosch 1999 shown productline architectures successfully applied small mediumsized enterprises although exists number problems challenges issues organization training information distribution product variants etc advant experience shows applying productline architectures successful large organizations however cost achieving features high suit requirements open system new abb products always backward compatible would easier develop new system required compatible previous systems guarantee system backward compatible warranty existing system work new products makes system trustworthy development large components easy reuse increases efficiency significantly compared reusing smaller component could developed inhouse cost purchase price advant ocs products examples large components used assemble process automation systems 3 different reuse challenges component generality efficiency reuse principles place high demands reusable components components must sufficiently general cover different aspects use time must concrete simple enough serve particular requirement efficient way developing reusable component requires three four times resources developing component serves particular case szyperski 1998 fact requirements components usually incomplete well understood sommerville 1996 brings additional level complexity case ccomplib situation simpler functional requirements clear relatively easy define interface used different components way situation complicated complex components omf although basic concept component functionality clear demands component interface behavior different different components products components required high level abstraction others required interface detailed level different types requirements led creation two levels components omf base including lowlevel functions omf framework containing higher level functions predefined behavior less flexibility general requirements generality efficiency time lead implementation several variants components used different abstraction level specific cases particular solution must provided type solution usually beyond objectoriented mechanisms since components higher abstraction level system evolution longlife products often affected evolution different kinds evolution system requirements functional non functional consequence continually competitive market situation demand continually improved system performance systems controlling servicing business industrial processes permanently increase efficiency processes improve quality products minimize production maintenance costs etc evolution technology related different domains advance technology different fields software used requires improved software improvements may require completely new approach new functions software evolution technology used software products evolution computer hardware software technology fast organization manufacturing longlife complex products must expect significant technology changes product life cycle reliability risk point view organizations prefer use latest technology demands highly competitive market forced adopt new technology appears often unpredictable changes must made products cause delivery delays increased production costs evolution technology used product development case products new technology tools used development process appear frequently market manufacturers faced dilemma adopt new technology possibly improve development process risk short term higher costs training migration continue using existing technology thereby miss opportunity lower development costs long run evolution society changes society example environmental requirements changes relations countries eu considerable impact demands products example new standards new currency etc development process relations employers employees working hours etc business changes face changes government policies business integration processes deregulation etc changes impact nature business resulting examples preference shortterm planning rather longterm planning stringent timetomarket requirements organizational changes changes society business direct effects business organizations see globalization process abrupt changes business operations demand flexible structures management procedures intime deliveries resources services skills changes require another fast flexible approach development process changes direct indirect impact product life cycle ability adapt changes becomes crucial factor achieving business success brown 2000 following sections discuss changes consequences development process product life cycle evolution functional requirements development reusable components would easier functional requirements evolve time development result new requirements products new requirements components defined reusable component demands placed number requirements coming different products may similar necessarily case requirements passed components means number requirements reusable components grow faster particular products nonreusable piece software relation component requirements requirements products expressed following equation rc0 denotes direct requirements component rpi requirements products pi ai impact factors component rc total number component requirements satisfy requirements components must updated rapidly new versions must released frequently products using process change components dynamic early stage components lives stage components less general cannot respond new requirements products without changed later stages generality adaptability increase impact product requirements become less significant period products benefit combinatorial synergy effects components reuse last stage life components getting outofdate finally become obsolete different reasons introduction new techniques new development runtime platforms new development paradigms new standards etc also higher risk initial component cohesion degenerates adding many changes turn requires efforts process illustrated figure 3 first graph shows growing number requirements certain products component used products number requirements common component grows faster beginning saturates period t0 t1 grows component features become inadequate product requirements satisfied new releases products components shown steps second graph component implements requirements releases normally precede releases product requirements originated product requirements accumulated requirements component product p2 product p1 t0 t1 time requirements satisfied releases component product p2 product p1 t0 t1 time figure 3 satisfy requirements reusable component must modified often beginning life indeed case components analyzing new functions classes required ccomplib new adapters protocol support required omf development time components significantly shorter products new versions product typically released every six months new versions components released least twice often several years intensive development improvement components became stable required less effort new changes period frequency releases lowered especially effort significantly lower new efforts development components appeared migration products different platforms newer platforms versions although functions products components changed significantly considerable amount work done component level migration different platforms several years development advant products ported different platforms reasons customer requirement products run specific platforms general trends growing popularity certain operating systems course time new versions variants platform already used appeared supporting new better cheaper hardware advant products migrate different platforms starting unix hpux 8x continuing trough new releases hpux 9x 10x ported unix platforms digital unix also complete different platforms open vms windows nt family nt 35 nt 40 windows 2000 products developed maintained parallel challenge multiplatform development keep compatibility different variants products maintain improve minimal efforts important part reuse concept keep highlevel components unchanged far possible decided encapsulate differences operating systems lowlevel components concept works however extent minimal activity required platform rebuild system platform make possible rebuild software every platform standardprogramming languages c c used unfortunately different implementations c standard different compilers caused problems code interpretation required rewriting certain parts code ensure standard system services available platforms posix standard used posix worked quite well different unix platforms much less windows nt second level compatibility problem graphical user interface gui main dilemma whether use exactly gui every platform use standard look feel gui platform question applied particularly nt relation unix platforms experience shown possible give definitive answer cases possible use gui graphical packages general different guis implemented main work regarding reuse code different platforms performed lowlevel components uxbase omf uxbase provides different lowlevel packages every platform example different drivers omf capsulated differences directly code using conditional compilation omf designed way possible divide code two layers one layer specific operating system layer business logic implemented supported platforms reuse issues different platforms ccomplib easier strictly package contains general algorithms depending specific operating system problems appeared however related different characteristics compilers different platforms compatibility one important factors successful reusability compatibility different versions components component replaced easily added new parts system compatible previous version compatibility requirements essential advant products since smooth upgrading systems running many years required compatibility issues relative simple changes introduced products maintenance improvement nature using appropriate test plans including regression tests functional compatibility tested reasonable extent complicated problems occur new changes introduced reusable component eliminate compatibility case additional software manage versions must written typical example incompatible change change communication protocol omf clients servers different versions omf must able talk make system flexible open possible different combinations operating systems versions omf still works solved algorithm ensures transmission correct data format two omf nodes version talk native protocol old omf node talks new new omf responsible converting data new format designated rmir receiver makes right new omf sends data older older omf convert data since unaware new protocol case newer omf must send old protocol format smir sender makes right algorithm builds fact machines know also know protocol talk however omfbased node know node always send predefined protocol referred well known format nodes recognize protocol translate algorithm minimizes number data conversions nodes case ccomplib problems compatibility somewhat different new demands classes functions appeared new standards technology one example use c templates template technology became sufficiently mature new requirements placed ccomplib classes reimplement template classes reason requirement using basic classes general efficient way another example unicode support addition ascii support new functions added new member functions existing classes adding new classes using inheritance mechanism reusing already existing classes introduction functions different format led additional efforts reusing cases old format replaced new one help simple tools built purpose cases due nonproper planning prioritizing timetomarket requirements old new formats used source modules led lower maintainability extend lower quality products development environment developing reusable components several dimensions development process must considered support development components different platforms support development different variants components different products support development maintenance different versions components different product versions independent development components products cope types problems sufficient appropriate product architecture component design development environment support also essential development environment must permit efficient work project editing compiling building debugging testing parallel distributed development must also supported components developed maintained time different platforms requires use powerful configuration management cm tool definition advanced cmprocess cm process support exists two levels first sourcecode level sourcecode files version management binary files built second level product integration phase product built must contain consistent set component versions example figure 4 shows inconsistent set components product version p1v2 uses component versions c1v2 c2v2 time component version c1v2 uses component version c2v1 older version integrating different versions component may cause unpredictable behavior product c2 version v1 c2 version v2 figure 4 example inconsistent component integration another important aspect cm developing reusable components change management change management keeps track changes logical level example error reports manages relations implemented physical changes ie changes documentation source code etc change requests example functional requirements error reports come different products important register information source change requests also important relate change request one product products following questions must answered impact implemented change products error appears one product appear products possible implications must investigated necessary users products concerned must informed development environment designated software development environment sde crnkovic 1997 used developing advant products internallybuilt program package encapsulates different tools provides support parallel development cm tool based rcs tichy 1985 provides support cm disciplines change management works pace management build management etc sde runs different platforms slightly modified functions example build process based makefiles autoconf unix platforms microsoft developer studio additional project settings used windows nt main objective sde keep sourcecode one place version control different versions components managed using baselines change requests change requests also version control gives possibility acquiring information useful project followup every change registration implementation release crnkovic willfr 1998 independent component development component development independent products gives several advantages functions broken smaller entities easier construct develop maintain independent component development facilitates distributed development common large enterprises development components independently product component development introduces also number problems component product test become difficult component level proper test environment must built often must include number components even maybe entire product another problem integration configuration problem situation shown figure 4 must avoided complex products impossible manually track dependencies components tool support checking consistency must exist advant development components treated separate products even developed within enterprise approach helped third party components used since managed uniform way every component contained file called import file included specification component versions used build component final product assembled components import file used integration checking consistent sets components selected development environment based make set use import files common product structure released components stored product structure availability others another structure used development component component exported product structure development finished using approach shown architecture design plays crucial role good architecture clear distinguish relations components facilitate development process whole development process complex requires organized planned support essential efficient successful development reusable components applications using maintenance process maintenance process also complex must handled different levels system level customers report problems product level errors detected specific product version reported finally component level fault located modification component impact components products lead explosion new versions different products already exist several versions minimize cumbersome process abb adopted policy avoiding generation supply specific patches selected customers instead revised products incorporating sets patches generated delivered customers maintenance contracts keep customer installations consistent relations components products systems must carefully registered make possible tracing errors levels systematic use software configuration management crucial role maintenance process support maintenance process advant products component specifications together error reports stored several classes repositories see figure 5 external customers customer complaints direct action report customers pmr direct action pmr released products beta release ppr ppr development cr figure 5 different levels error report management highest level repository managing customers reports ccrp makes possible service personnel provide customers prompt support information saved level customer product oriented reports indicating product problem registered product maintenance report repository pmr known problems related products components filed also product structure information stored level product structure showing dependencies products components provides product component developers assistance relating error reports source problem product component level similar error management process defined products beta phase ie yet released problems identified phase typically test groups registered form prerelease problem reports ppr problems either solved product released reclassified product error reports saved pmr change applied code documentation change control change initiated change request change required comes error report change request generated pmr change made component tested verified action description exported correlating pmr propagated products involved finally returned customer via ccrp repository procedure unique componentbased development means managing complex products maintaining many products specific componentbased approach mapping products components management error reports product component level difficult part management case entire procedure localized pmr level ie product level customer side information highest priority related products customers development level changes registered related primarily components information products components stored development level error management level complex error may detected specific product version may also present products product versions error may discovered one component present different versions component problem solved one component version also may necessary solve several revised component versions eventually subsequently integrated new versions one several products multidimensional problem many error reports impact different versions components products solution included different components product versions partially managed automatically many steps process require direct human decisions example decision solution problem included next product release although whole procedure carefully designed rigorously followed happened occasions unexpected changes included changes intended inclusion absent new product releases details maintenance process see kajkomattson 1999a kajkomattson 1999b another important subject maintenance external components shown external components must treated way internal components known errors complete error management process internal external components treated similar way list known corrected errors external components important developers product managers service people cost maintaining components even maintained others must taken consideration integrating standard components recent years demands customers systems changed customers require integration standard technologies use standard applications products buy definite trend market little awareness possible problems involved improper use standard components cause severe problems especially distributed realtime safetycritical systems longperiod guarantees addition new requirements timetomarket demands become important factor factors changes software hardware technology aoyama 1998 introduced new paradigm development process development process focused use standard defacto standard components outsourcing cots production components time final products longer closed monolith systems instead componentbased products integrated products available market new paradigm development process marketing strategy introduced new problems raised new questions mckinney 1999 development process changed developers designers programmers also integrators marketing investigators new development methods established developers properly educated criteria selection component guarantee standard component fulfills product requirements maintenance aspects responsible maintenance expected updating upgrading components satisfy compatibility reliability requirements trend market expect buy today also day begin delivering product developing component guarantee proper standard used standard valid five ten years questions must considered beginning componentbased development project josefsson josefsson 1999 presents certain recommendations component integrator use guidelines test imported component environment run limit practical number component suppliers minimize compatibility problems make sure supplier evaluated longterm agreement signed focus development environment support transferred editbuildtest cycle component integrationtest cycle configuration management must give consideration runtime phase larsson crnkovic 1999 replacing internal components standard components middle eighties abb advant products completely proprietary systems internally developed hardware basic application software beginning nineties standard hardware components software platforms purchased realtime additions application software developed internally system developed using components based new standard technologies development new components become available market abb faced issue one point time necessary abandon existing solutions favor new solutions based existing components technologies illustrate migration process discuss possibility replacing omf ccomplib standard components experience examples showed easier replace component replacement process made small incremental steps allowing new component coexist old one makes easier backward compatible change smooth replacing omf dcom moving unix based system system based windows nt serious effect system architecture microsoft components using new object model available namely comdcom box 1998 dcom functionality similar omf became new issue dcom released abb continue develop proprietary omf change new standard component problem dcom functionality omf vice versa domains overlap partially subscription data various capabilities made omf subscription functionality supported docm hand dcom create objects required like omf objects created actual use technologies support object communication area easier replace omf dcom decision made continue omf new components run top com could used would drastically reduce possibilities integration thirdparty components hand would require considerable work make current system run top com dilemma com vs omf begin omf adapted com adapter designated omf com aware functionality helped com developers access omf objects vice versa however solution problem using two different object models optimal since added overhead communication possible match data types one one made solution limited decision taken build new system com technologies proprietary extensions adding functions missing com communication current system omf com solution made easy remove old omf replace com small steps time adapters useful new component used parallel existing one rine et al 1999 adapters systems orbixcorba fieldbus foundation constructed external systems similar data types fairly straightforward build framework adapters parts take care proprietary system reused new systems accessed adding server client stub adapter framework able build functional adapters two middleware components important capability create remote calls dynamically instance dynamic invocation interface dii corba used middleware possibility might possible generate code automatically takes care different types calls going placed adapter system replacing ccomplib stl switch ccomplib stl austern 1999 much easier stl covers almost ccomplib functions provides additional functionality still much work reminded done since code using ccomplib changed able use stl instead decision taken continue using components use stl whenever new functionality added time use old components reduced internal maintenance cost reduced cases components libraries used gave disadvantages especially maintenance process managing evolution standard components use standard components implies less control larsson crnkovic 1999 larsson crnkovic 2000 cook dage 1999 especially components updated runtime system components usually configured buildtime known tested versions components used later system evolves new versions components system mechanism detect new components installed might check version replacement component least newer original version approach prevents system using old components guarantee functionality new components installed applying ideas configuration management version change management managing components approach used solve problems certain level configuration control achieved possible identify components versions dependencies components information system placed version control later retrieval makes possible compare different baselines system configuration manage dependencies graphic representation configuration introduced graphs placed version control information used predict components affected replacement installation new component generally difficult identify components runtime obtain version information components identified possible build graphs dependencies represented various ways placed configuration control larsson 2000 improve control external components placed change management permit monitoring changes bugs instead attaching source code files change requests common change management name version component used track changes problem report analysed outcome change request component involved change request contain list changed source files description patches component external patches component vendor must stored permit recreation configuration later cases high quality products must assured enterprise developing products must special welldefined relations component vendors support maintenance 5 conclusion presented abb advant control systems ocs successful example development componentbased system success systems market primarily result appropriate functionality quality success development maintenance continued improvement systems achieved careful architecture design main principle reuse components reuse orientation provides many advantages also requires systematic approach design planning extensive development support complex maintenance process general consideration given components certain otherwise successful development organization succeed development reusable components products based reusable components reusable component developed complex development process support required organization even requirements satisfied happen unpredictable extra costs one example illustrate early stage abb advant ocs development insufficient consideration given windows nt abb pay price oversight suddenly became clear windows nt would next operating platform new product versions new platform developed porting software old platform costs significantly greater design done independent first platform another problem addressed question moving new technologies require recreation components inclusion standard components available market cases difficult keep achieve functionality original components however seems process replacing proprietary components standard components available third parties inevitable important proper strategy migrating old components new ones 6 r new age software development componentbased software engineering changes way software development generic programming stl third product line practice report experience changeoriented scm tools programvarukomponenter praktiken maintenance abb software problem administration processes maintenance abb ii change execution processes applying configuration management techniques componentbased systems licentiate thesis dissertation 2000007 new challenges configuration management component configuration management impact commercial offtheshelf cots software interface systems software engineering using adapters reduce interaction complexity reusable componentbased software development software engineering tr rcsmyampersandmdasha system version control component software highly reliable upgrading components productline architectures industry impact commercial offtheshelf cots software interface systems software engineering using adapters reduce interaction complexity reusable componentbased software development largescale component based development software engineering experience changeoriented scm tools change measurements scm process new challenges configuration management maintenance abb maintenance abb ii ctr ade azurat mechanization invasive software composition flogic proceedings 2007 annual conference international conference computer engineering applications p8994 january 1719 2007 gold coast queensland australia lin chinfeng tsai hsientang fu chensu logic deduction expanded meansend chains journal information science v32 n1 p516 february 2006
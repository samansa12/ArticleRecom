detectable byzantine agreement secure faulty majorities wellknown n players connected pairwise secure channels achieve byzantine agreement number cheaters satisfies n3 even respect computational security however many applications sufficient achieve detectable broadcast primitive broadcast guaranteed players nonfaulty honest nonfaulty players always reach agreement whether broadcast achieved show detectable broadcast achieved regardless number faulty players ie n give protocol unconditionally secure well two efficient protocols secure respect computational assumptions existence quantum channels respectivelythese protocols allow secure multiparty computation tolerating n assuming pairwise authenticated channels moreover allow setup publickey infrastructures consistent among participants using neither trusted party broadcast channelsfinally show even necessary players begin protocol time step give detectable firing squad protocol initiated single user time either honest players end synchronized clocks honest players abort b introduction broadcast aka byzantine agreement important primitive design distributed protocols protocol designated sender achieves broadcast acts megaphone players receive message sends moreover honest player receives message knows honest players received message impossible even cheating force inconsistency outputs lamport shostak pease 24 22 showed players share initial setup information beyond pairwise authenticated channels fact broadcast possible n3 n number players number actively corrupted players tolerated protocol impossibility proofs 20 10 11 even additional resources eg secret channels private random coins quantum channels computers cannot help improve bound unless setup shared among pairs players involved hand picture changes dramatically previous setup allowed secure signature schemes exist adversary limited polynomial time pre agreement public verication key every player allows ecient broadcast n 22 8 ptzmann waidner 25 showed broadcast among n players precomputation phase allows later broadcast ecient unconditionally secure also n two works key pieces constructions surprisingly strong agreement protocols still achievable without previous setup fitzi gisin maurer von rotz 13 12 showed weaker variant broadcast detectable broad cast achieved n2 detectable broadcast cheaters force protocol abort case honest players agree aborted ideal settings robust tolerance errors necessary detection suces 11 contributions show detectable broadcast possible n three dierent models rst protocol requires pairwise authenticated channels assumes polynomialtime adversary existence secure signature schemes second protocol requires pairwise secure channels secure unbounded adversaries third protocol requires authenticated classical channels insecure quantum channels also tolerates unbounded adversaries theorem 1 detectable broadcast achievable based 1 network pairwise authenticated channels assuming secure signature scheme based 2 network pairwise secure channels computational assumptions based 3 network pairwise authenticated channels insecure quantum channels computational assumptions protocol 1 requires rounds 3 message bits sent correct players k length signature protocol 2 requires roughly 8 log message bits sent k security parameter protocol 3 requires rounds roughly okn 4 log n bits qubits communica tion message complexities stated respect message domains constant size exact complexities dependencies domain size given later particular results show impossibility weak broadcast deterministic protocols due lamport 21 extend randomized ones lamports proof apply protocols public coins fails players allowed private random inputs combined results previous literature results yield protocols detectable versions multiparty computation mpc resilience n adversary may force protocol abort assuming pairwise authenticated channels existence trapdoor permutations mpc protocol allows players inputs x1 xn evaluate function fx1 xn adversary neither corrupt output learn information beyond value f give two ways apply detectable broadcast protocol generic construction 15 2 14 remove assumption broadcast channel independent work goldwasser lindell 17 give dier ent general transformation also eliminates use broadcast channel transformation achieves weaker notion agreement ourshonest players may always agree whether protocol terminated successfully see work precise denition hand transformation ecient round complexity satises partial fairness satised ecient transformations additionally analyze behaviour transformation respect arbitrary mpc protocols 15 2 14 respect concurrent composition finally observed order achieve detectable broadcast multiparty computation prior agreement among players necessary implies protocol spontaneously initiated player time also implies players synchronous network achieve de tectable clock synchronization namely either honest players end synchronized clocks honest players abort necessarily exactly time 12 models definitions models consider synchronous network every pair players connected unjammable authenticated chan nel every pair j player p always send messages directly p j adversary neither prevent messages delivered introduce new messages channel synchronous mean players run common clock messages always delivered within bounded time protocols secure even adversary rush messages ie even messages honest players delivered corrupted players send messages protocols secure byzantine active adver saries select players coordinatedly corrupt arbitrarily malicious way corruptions may adap tive adversary grows set corrupted players based execution far framework consider three models denoted mauth 1 mauth authenticated channels computational security adversary may read communication network even among honest players limited polynomial time computations may tamper chan nels information available adversary internal state random coins honest players 2 msec secure channels unconditional security aka security channels honest players unreadable adversary computationally unbounded 3 unconditional security pairs players share authenticated classical channel insecure quantum channel adversary tamper adversary computationally unbounded one interested feasability results one needs consider second model msec carefully encrypting communication authenticated channels one implement secure channels mauth 5 fact protocol msec also protocol mauth however protocols designed specifically msec use computational cryptographic tools greater simplicity eciency 1 similarly protocol msec leads protocol mq implementing secure channels using quantum key distribution protocols designed specically mq may ecient denitions denitions may nite domain say require conditions task hold except probability exponentially small security parameter superpolynomially small case computational security protocols complexity polynomial n k ers player called sender holds input value xs 2 every player p 2 n nally decides output value broadcast satises validity sender honest honest players p decide senders input value consistency honest players compute output value detectable broadcast protocol among n players achieves detectable broadcast satises correctness honest players commonly accept commonly reject protocol honest players accept protocol achieves broadcast completeness player corrupted protocol players accept fairness honest player rejects protocol adversary gets information senders inputit turns protocols achieve stronger notion namely detectably establish setup needed perform strong broadcast using protocols 8 25 definition 3 detectable precomputation protocol among players achieves detectable precomputation broadcast detectable precomputation short satises correctness honest players commonly accept commonly reject protocol honest players accept strong broadcast achievable completeness player corrupted protocol honest players accept independence honest players intended input value precomputed broadcast need known time precomputation 4 independence implies two important properties rst precomputation may done long actual broadcasts designed specically mauth may also use potentially weaker computational assumptions example protocols require existence oneway functions general reduction msec mauth requires semantically secure encryption used second adversary gets information future inputs honest senders ie fairness dened detectable broadcast guaranteed particular means detectable precomputation implies detectable broadcast opposed detectable broadcast advantage detectable precomputation broadcast preparation separated actual execution broadcasts ie precomputation must detectable soon precomputation successfully completed strong broadcast possible secure number corrupted players 2 genericprotocolfordetectable along lines 13 give constructions protocols detectable precomputation implies detectable broadcast present protocols three models network authenticated channels computational security mauth secure channels unconditional security msec quantum channels mq protocols models mauth mq ecient one model mauth ultimately general since used small modications three models note although stated dierently known results 22 8 25 viewed context second one models mauth msec temporary phase wherein broadcast achievable reason allows running precomputation future broadcast achievable without additional assumptions mauth precomputation simply consist every player p compute secret broadcast public key msec involved methods must applied still principle precomputation similar players broadcast information allows players consistently compute keys pseudosignature scheme among players construction detectable precomputation generic sense reasonable precomputation protocol exploiting temporary broadcast order allow future broadcast transformed protocol detectable precomputation transformation based implementation conditional gradecast dened variant graded broadcast 9 independent work goldwasser lindell 17 calls task broadcast designated abort definition 4 conditional gradecast protocol among n players player called sender holds input value xs 2 every player p 2 n nally decides output value gradecast satises value validity sender honest honest players decide senders input value conditional grade validity players honest players p decide grade consistency honest player p gets grade honest players p j decide output value assume set png players model 2 fmauth msecg let precomputation protocol model additionally players assumed able broadcast mes sages let ng set protocols model protocol achieves broadcast sender p based information exchanged execution furthermore assume satises independence property denition 12 respect protocols b protocol always eciently terminates even involved broadcast invocations fail protocols always eciently terminate even based arbitrary precomputed information protocol detectable precomputation achieved b follows 1 run protocol wherein invocation broadcast replaced invocation conditional gradecast sender 2 player p computes logical grades got invocations conditional gradecast modied protocol g 3 player p invocation protocol run 4 player p accepts g received step 3 note protocols step 3 necessarily achieve broadcast since invocation step 1 might failed however always eciently terminate sumption informally argue protocol achieves detectable precomputation correctness suppose p j pk honest players suppose accepts g invocations conditional gradecast protocol achieved broadcast neglecting grade outputs hence protocols b indeed achieve broadcast since p j ac cepts players p broadcasted g step 3 especially honest ones hence honest players accept end completeness player corrupted invocation protocol player p ever computes grade players accept independence independence directly follows assumed independence property giving detailed view concrete protocols models mauth msec rst describe protocol achieves conditional gradecast models mauth msec protocol condgradecast respect sender 1 sender sends input xs every player player p receives 2 every player p redistributes every player computes grade value reconrmed everybody step 2 else lemma 1 protocol condgradecast achieves conditional grad ecast n proof validity conditions trivially satised hand suppose p honest honest player p j sent step 2 hence consistency satised 3 computational security let g signature scheme ie secure adaptive chosen message attack g key generation algorithm signing algorithm v verication algorithm algorithms take unary security parameter 1 k input simplicity assume signatures k bits long dolevstrong protocol 8 achieves strong broadcast consistent publickey infrastructure setup definition 5 consistent publickey infrastructure pki say group n players consistent publickey infrastructure g verication key pk known players chosen p particular keys belonging honest players chosen correctly according g using private randomness honest players know signing keys note cheaters keys may general depend keys honest players 4 proposition 2 dolevstrong 8 given consistent pki pairwise authenticated channels strong broadcast tolerating n cheaters achievable using rounds overall message complexity 2 log jdj bits message domain including possible padding session ids etc adversary makes protocol fail probability used forge signature adaptive chosen message attack probability n let dsbroadcast denote dolevstrong broadcast protocol precomputation protocol among n players allowing future broadcast set consistent infrastruc ture given broadcast channels simple every player generate signingverication key pair sk broadcast verication key hence applying generic transformation described previous section get following protocol detectable precomputation protocol detprecomp protocol model mauth 1 every player p generates signingverication key pair according g every player p j protocol condgradecast invoked p j inputs public key pk j sender every player p stores received public keys grades g 1 2 every player p computes g 3 every player p j instance dsbroadcast invoked sender every player p stores received values g j ng n fig g 4 players p accept reject otherwise theorem 2 protocol detprecomp achieves detectable precomputation among n players model mauth tolerating n corrupted players adversary make protocol fail probability used forge signature probability n proof completeness independence trivially satis ed remains prove correctness condition satis ed assume p j pk two honest players assume accepts show hence pk also accepts since p j accepts holds g 1 denition conditional gradecast implies players set consistent pki hence invocation protocol dsbroadcast achieves broadcast since p j accepts players step 3 hence honest players decide accept end protocol note protocols detprecomp dsbroadcast another important property ie keep players synchronized players accept terminate protocols communication round easily veried protocol dsbroadcast requires t1 rounds communication overall message complexity 2 log jdj n 3 bits sent honest players protocol detprecomp requires rounds overall message complexity 3 log jdjn 4 bits later broadcasts conventional calls dsbroadcast message complexity protocol detprecomp reduced 3 log jdj bits overall replacing n parallel invocations dsbroadcast step 3 consensuslike protocol default value 1 n dsbroadcast protocols run parallel slightly modied way rst round sender ps accepts simply sends bit signature message rejects sends together signature soon round accepts value one senders ps received valid signatures r dierent players including ps value respect protocol instance sender ps excactly one arbitrary sender ps adds signature 0 respect protocol instance next round relays r signatures every player decides 0 terminates player never accepts value sender ps decides 1 round 1 players ps honest send value clearly players decide 1 end hand correct player decides 0 correct players finally protocol player distributes signatures single invocation protocol dsbroadcast 4 unconditional security pseudosignatures consider applying framework setting pairwise secure channels requiring informationtheoretic security basic procedures come 25 modied version dolevstrong protocol signatures replaced informationtheoretically secure pseu dosignatures proposition 3 pfitzmannwaidner 25 exist protocols pwprecomp pwbroadcast pwprecomp run access broadcast channel subsequent executions pwbroadcast based output pwprecomp achieve strong broadcast secure unbounded adversary tolerating n total communication polynomial n log jdj k log b k security parameter failure probability 2 k b number future broadcasts performed number rounds 2n 2 generic transformation described section 2 directly applied pwprecomputation protocol resulting protocol detectable broadcast r 7 communication rounds overall message complexity bits polynomial n security parameter k however pwprecomputation protocol consists fault localization ie subprotocols allow identify players misbehaving steps required context since interested nding whether faults occurred give protocol precomputation one single broadcast sender steps stripped thereby 25 log n key size log log log jdj 1 j j j b j ng n fsg parallel 2 3 6 j select random authentication key 4 5 8p h h 6 agree pairwise key k 6 broadcast 2 1 7 broadcast accept reject 8 decide accept h 1 signers p j sent message accept respect j j b otherwise reject h 0 proof following lemma follows 25 lemma 4 given broadcast channel protocol simppwprecomp detectable precomputation broadcast respect protocol pwbroadcast requires three rounds two use broadcast channel furthermore purpose step 7 require broadcast done simple multisending since invocations precomputed broadcast follow anyway see protocol detprecomp section 4 protocol detprecomp model msec b later broadcasts 1 execute protocol simppwprecomp b wherein invocation broadcast replaced invocation protocol condgradecast 2 every player p computes g grades received invocation conditional gradecast step 1 h bit indicating whether accepted end step 1 3 every player p j instance pwbroadcast invoked sender every player p stores received values g j ng n fig g 4 players p accept reject otherwise protocol model mauth previous sec tion parallel invocations protocol pwbroadcast step 3 replaced consensuslike protocol saving factor n bitcomplexity whole protocol theorem 3 protocol detprecomp achieves detectable precomputation b future broadcasts among n players model msec tolerating number n corrupted players following property underlying pwprecomp security parameter least chosen overall error probability ie probability either protocol detprecomp one b broadcasts prepared fails 2 k proof proof proceeds along lines proof theorem 2 error probability follows analysis 25 one single precomputationbroadcast pair invoking pwprecomp security parameter k0 hence implies overall error probability n protocol simppwprecomp requires 4 rounds message exchange overall message complexity 7 log log jdjk0 log n log log log bits k0 security parameter underlying pwprecomp domain future messages broadcast including possible padding session ids etc protocol pwbroadcast requires 1 rounds message exchange overall message complexity 2 log jdj log n 2 bits since protocol detprecomp precomputing b later broadcasts invokes protocol simppwprecomp n parallel protocol pwbroadcast n times parallel requires overall t5 communication rounds overall message complexity 3 log jdj log log log bits sent correct players protocols presented previous section players accept terminate protocols detprecomp pwbroadcast communication round furthermore follows proposition 3 using recycling techniques 25 bit complexity protocol detprecomp reduced polylogarithmic number b later broadcasts precomputed ie polynomial n log jdj k log b 5 unconditional security quantum signatures section consider third network model mq participants connected pairwise authenticated channels well pairwise unauthenticated quantum channels msec require unconditional security small probability failure one always construct secure channels top model using quantum key distribution protocol eg bennett brassard 3 requires adding two rounds beginning protocol noiseless quantum channels agreeing key bits requires sending log qubits classical bits 1 note key distribution protocol may fail adversary intervenes case concerned players set grades 0 later agreement protocol honest players abort yields protocols similar complexity previous section one improve complexity protocols signicantly tailoring precomputation protocol quantum model using quantum signatures gottesman chuang 19 instead pseudosignatures 25 idea apply distributed swap test 19 ensure consistency distributed quantum keys 25 one gets broadcast protocol replacing classical signatures dolevstrong protocol 8 quantum signatures note quantum communication required rst round computation possibly corrupted epr pairs exchanged quantum transmissions done using quantum tele portation authentication initial epr transmissions done protocols barnum et al 1 theorem 4 protocol achieves detectable precomputation b future broadcasts among n players model mq tolerating number n corrupted players protocol rounds ok0n 5 b0 bits qubits com munication 6 secure multiparty computation results previous sections suggest two general techniques transforming protocol assumes broadcast channel detectable protocol 0 assumes pairwise communication channels may abort suppose upper bound r number rounds interaction required protocol called xedround rst transformation straightforward also used 13 first run protocol detectable precomputation broadcast succesful run replacing calls broadcast channel executions authenticated broadcast protocol 2 resulting protocol takes rounds second transformation suggested constructions previous sections first run replacing calls broadcast channel executions condgradecast next run detectable broadcast protocol attempt agree whether executions condgradecast succesful ie player uses protocol broadcast logical grades executions condgradecast detectable broadcasts complete successfully message 1 accept result otherwise abort resulting protocol takes rounds similar transformation also discussed goldwasser lindell 17 see remarks protocol achieves unconditional security secure channels required transforma tions computational security authenticated channels sucient moreover applying rst transformation computational setting bound needed ahead time number rounds interaction though nonetheless polynomial security parameter intuitive level rst transformation preserves security properties except robustness zero error robustness lost since adversaries force protocol fail interfering initial precomputation protocol zero error lost since detectable broadcast must small 2 note using authenticated broadcast protocol several times sequence numbers need added broadcast messages avoid replay attacks 18 23 probability error n3 result lamport 21 following section formalize intuition case secure multiparty computation mpc second transformation problematic protocol fails partway adversary may learn information supposed moreover protocol side eects use external resource side eects may occur even though protocol aborts nonetheless case multiparty computing transformation may modied avoid problems multiparty computation n informally mpc protocol allows players inputs x1 xn collectively evaluate function fx1 xn cheaters neither aect output except choice inputs learn anything honest players inputs except gleaned output simplicity consider deter ministic singleoutput functions incurs loss general ity also section paper restrict attention static adversaries ie set corrupted players decided protocol begins security multiparty computation usually dened via ideal model computation simulator pro tocol ideal model trusted third party p assists players simulator transforms adversary real protocol one ideal model produces almost output 3 standard ideal model mpc n2 essentially operates follows 14 players hand inputs p computes output special corrupted parties refuse cooperate player 1 honest parties get output player 1 corrupted adversary rst sees output decides whether abort protocol decides abort p sets output finally p hands possibly aborted output honest parties notion security corresponding ideal model called second malicious model 14 secure computation abort 17 given broadcast channel protocol denition mpc tolerating n static cheaters comes essentially goldreich micali wigderson 15 beaver goldwasser 2 though careful statement deni tion protocol proof security appears goldreich 14 work also points replacing calls broadcast channel authenticated broadcast protocol given signature infrastructure aect security protocol 4 applying rst transformation protocol obtain theorem 5 suppose trapdoor oneway permutations ex ist secure mpc protocol following denition 14 eciently computable function model authenticated channels tolerates n 3 output joint distribution adverarys view outputs honest players one point 14 discuss explicitly sequence numbers needed ensure independence various executions authenticated broadcast protocol problem since network synchronous sequence numbers derived round number proof sketch dierence protocol proved correct goldreich 14 initial detectable precomputation phase allows adversary abort protocol gets information honest parties inputs however already power standard ideal model refuse provide input p construct simulator 0 0 modify simulator constructed 14 add additional initial phase simulates detectable precomputation protocol using signature keys real honest parties inputs simulated ones protocol aborts 0 sends input behalf cheating parties p otherwise 0 runs simulator using output precomputation phase signature infrastructure correctness simulation follows correctness original simulator roundecient multiparty computation protocol ecient rst transformation multiplies round complexity original protocol instead consider applying second transformation mpc protocol replace every call broadcast channel invocation conditional gradecast agree end protocol whether broadcasts successful running detectable broadcast section 3 mentioned transformation must made carefully multiparty computing important transformed protocol leak information original protocol honest players continue run protocol inconsistent conditional gradecast occurred adversary could exploit inconsistencies learn secret values say seeing possible answers kind cutandchoose proof ensure problem honest player computed grade one executions condgradecast longer continues running original protocol instead resumes participation nal detectable broadcast phase players agree whether accept reject pointed goldwasser lindell 17 resulting protocol 0 achieves sort secure computation denition 14 particular denition implies partial fairness 0 satisfy protocol fair adversary never learn input honest players fairness fact unavoidable setting n2 since unavoidable 2party setting cleve 6 goldwasser levin 16 protocol partially fair designated player p1 p1 honest protocol fair 0 even partially fair since adversary may wait end computation learn output still force honest players abort goldwasser lindell 17 give similar transformation second one detectable broadcast phase end provide rigorous analysis prove achieves denition secure computation players need agree whether protocol aborted additionally show construction modied achieve partial fairness one think protocol 0 adding detectable broadcast phase initial protocol 17 ensure agreement computations result 7 nonunison starting pki previous detectable protocols implicitly assumed players start protocol communication round requires agreement among players protocol run point time protocol started argue assumption unnecessary even agreement player set among protocol run coan dolev dwork stockmeyer 7 gave solution byzantine agreement nonunison start problem problem related ring squad problem introduced burns lynch 4 given setup consistent pki protocol achieves broadcast n even honest players start protocol round ie broadcast initiated player turns idea also applicable detectable broadcast allows player pi shares authenticated secure channels members player set p 0 unexpectedly initiate protocol among players detectable precomputation let player pi called initiator players called initiees protocol following protocol description split initiators part initiees part protocol initadhoccomp initiator pi 1 send p 0 initiation message containing unique session identier id specication player set p 0 multiparty computation protocol among player set g 2 perform protocol detprecomp among p 0 precompute broadcast invocations required protocol nal broadcast round instead broadcasting value g indicate whether conditional gradecast protocols achieved broadcast value g broadcast indicates whether players p 0 synchronously entered precomputation protocol always used session identier id 3 accept execute protocol g players p 0 broadcasted acceptance end protocol adhoccomp initiee 1 upon receipt initiation message initiator decide whether interested execute instance among player set p check specied id used concurrent invocation check whether check whether authenticated secure channels p players p 0 fp g required protocol 2 checks step 1 positive perform protocol among p 0 precompute broadcast invocations required protocol nal broadcast round instead broadcasting value g indicate whether conditional gradecast protocols achieved broadcast value players p 0 synchronously entered precomputation protocol always used session identier id 3 accept execute protocol g players p 0 broadcasted acceptance end note rst check step 1 protocol adhoccomp implicitly prevents adversary spamming players initiations order overwhelm player work load player simply ignore initiations without aecting consistency among correct players theorem 6 suppose player set p 0 player pi pi shares authenticated secure channels every player p 0 whereas additional channels assumed players p 0 pi initiate protocol among player set achieves following properties n honest players p either commonly accept reject protocol instead rejecting also possible player ignores protocol implicit rejection accept broadcast multiparty computation achievable among p everybody knowing players p honest players connected pairwise authenticated secure channels players accept particular protocol used order detectably set consistent pki without need trusted party 8 acknowledgements thank sha goldwasser yehuda lindell discussions led substantial improvement treatment results section 6 well pointing errors earlier versions work also thank jon katz idit keidar ra ostrovsky helpful discussions work adam smith supported us army research oce grant daad19 0010177 9 r multiparty computation faulty majority update quantum cryptography byzantine adaptively secure multiparty computation limits security coin ips half processors faulty extended abstract distributed authenticated algorithms byzantine agreement optimal probabilistic protocol synchronous byzantine agreement easy impossibility proofs distributed consensus problems minimal complete primitives unconditional multiparty computation quantum solution byzantine agreement problem unconditional byzantine agreement multiparty computation secure dishonest minorities scratch secure multiparty computation play mental game fair computation general functions presence immoral majority secure computation without broadcast channel byzantine agreement authentication observations applications tolerating hybrid link faults quantum digital signatures weak byzantine generals problem byzantine generals problem composition authenticated byzantine agreement reaching agreement presence faults tr easy impossibility proofs distributed consensus problems limits security coin flips half processors faulty update quantum cryptography play mental game distributed firing squad problem multiparty computation faulty majority adaptively secure multiparty computation optimal probabilistic protocol synchronous byzantine agreement reaching agreement presence faults weak byzantine generals problem byzantine generals problem composition authenticated byzantine agreement minimal complete primitives secure multiparty computation fair computation general functions presence immoral majority unconditional byzantine agreement multiparty computation secure dishonest minorities scratch ctr amitanand sanketh k srinathant v vinod c pandu rangan distributed consensus presence sectional faults proceedings twentysecond annual symposium principles distributed computing p202210 july 1316 2003 boston massachusetts yehuda lindell anna lysyanskaya tal rabin composition authenticated byzantine agreement journal acm jacm v53 n6 p881917 november 2006
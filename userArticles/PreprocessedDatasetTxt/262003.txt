parallel incremental graph partitioning abstractpartitioning graphs equally large groups nodes minimizing number edges different groups extremely important problem parallel computing instance efficiently parallelizing several scientific engineering applications requires partitioning data tasks among processors computational load node roughly communication minimized obtaining exact solutions computationally intractable since graph partitioning npcompletefor large class irregular adaptive data parallel applications adaptive graphs computational structure changes one phase another incremental fashion incremental graphpartitioning problems partitioning graph needs updated graph changes time small number nodes edges may added deleted given instantin paper use linear programmingbased method solve incremental graphpartitioning problem steps used method inherently parallel hence approach easily parallelized using initial solution graph partitions derived recursive spectral bisectionbased methods methods achieve repartitioning considerably lower cost obtained applying recursive spectral bisection quality partitioning achieved comparable achieved applying recursive spectral bisection incremental graphs scratch b introduction graph partitioning wellknown problem fast solutions extremely important parallel computing research areas circuit partitioning vlsi design instance parallelization many scientific engineering problems requires partitioning data among processors fashion computation load node balanced communication minimized graphpartitioning problem nodes graph represent computational tasks edges describe communication tasks partition corresponding one processor optimal partitioning would allow optimal parallelization computations load balanced various processors minimized communication time many applications computational graph derived runtime requires graph partitioning also done parallel since graph partitioning npcomplete obtaining suboptimal solutions quickly desirable often satisfactory large class irregular adaptive data parallel applications adaptive meshes 2 computational structure changes one phase another incremental fashion incremental graphpartitioning problems partitioning graph needs updated graph changes time small number nodes edges may added deleted given instant solution previous graphpartitioning problem utilized partition updated graph time required much less time required reapply partitioning algorithm entire updated graph graph repartitioned may lead imbalance time required computation node cause considerable deterioration overall performance many problems graph may modified every iterations albeit incrementally remapping must lower cost relative computational cost executing iterations computational structure remains fixed unless incremental partitioning performed parallel may become bottleneck several suboptimal methods suggested finding good solutions graphpartitioning problem many applications computational graph vertices correspond two threedimensional coordinates interaction computations limited vertices physically proximate information exploited achieve partitioning relatively quickly clustering physically proximate points two three dimensions important heuristics include recursive coordinate bisection inertial bisection scattered decomposition index based partitioners 3 6 12 11 14 16 number methods use explicit graph information achieve partitioning important heuristics include simulated annealing mean field annealing recursive spectral bisection recursive spectral multisection mincutbased methods genetic algorithms 1 4 5 7 8 9 10 13 since methods use explicit graph information wider applicability produce better quality partitioning paper develop methods use explicit graph information perform incremental graph partitioning using recursive spectral bisection regarded one bestknown methods graph partitioning methods partition new graph considerably lower cost quality partitioning achieved close achieved applying recursive spectral bisection scratch algorithms inherently parallel rest paper outlined follows section 2 defines incremental graphpartitioning problem section 3 describes linear programmingbased incremental graph partitioning section 4 describes multilevel approach solve linear programmingbased incremental graph partitioning experimental results methods sample meshes described section 5 conclusions given section 6 problem definition consider graph represents set vertices e represents set undirected edges number vertices given number edges given jej graphpartitioning problem defined assignment scheme maps vertices partitions denote bq set vertices assigned partition q ie qg weight w corresponds computation cost weight vertex v cost edge given amount interaction vertices v 1 v 2 weight every partition defined cost outgoing edges partition represent total amount communication cost given would like make assignment time spent every node minimized ie represents ratio cost unit computationcost unit communication machine assuming computational loads nearly balanced w 0 w 1 second term needs minimized literature p cq also used represent communication assume solution available graph gv e using one many available methods literature eg mapping function available communication cost close optimal let g 0 incremental graph gv e ie vertices added vertices deleted similarly ie edges added deleted would like find new mapping new partitioning load balanced possible communication cost minimized methods described paper assume g 0 sufficiently similar gv e achieved ie number vertices edges addeddeleted small fraction original number vertices edges 3 incremental partitioning section formulate incremental graph partitioning terms linear programming highlevel overview four phases incremental graphpartitioning algorithm shown figure 1 notation order let 1 p number partitions 2 represent set vertices partition 3 represent average load partition four steps described detail following sections 1 assign new vertices one partitions given 0 step 2 layer partition find closest partition vertex given l 0 step 3 formulate linear programming problem based mapping step 1 balance loads ie modify 0 minimizing total number changes 0 step 4 refine mapping step 2 reduce communication cost figure 1 different steps used incremental graphpartitioning algorithm 31 assigning initial partition new nodes first step algorithm assign initial partition nodes new graph given simple method initializing 0 v given follows let vertices dv x shortest distance graph g 0 examples considered paper assume g 0 connected case several strategies used connected graph used instead g calculation 0 v connected new nodes connected old nodes clustered together potentially disjoint clusters assigned partition least number vertices rest paper assume 0 v calculated using definition 7 although strategies developed paper general independent mapping ease presentation assume edge vertex weights unit value algorithms easily modified case figure 2 describes mapping vertices graph figure b describes mapping additional vertices using strategy 32 layering partition mapping would ordinarily generate partitions unequal size would like move vertices one partition another achieve load balancing keeping communication cost small possible achieved making sure vertices transferred two partitions close boundary two partitions assign vertex given partition different partition close ties broken arbitrarily b figure 2 initial graph b incremental graph new vertices shown x min shortest distance graph v x simple algorithm perform layering given figure 3 assumes graph connected let number vertices partition moved partition j example case figure 3 labels vertices given figure 4 label 2 vertex partition 1 corresponds fact vertex belongs set contributed ff 12 33 load balancing number vertices moved partition partition j achieve load balance several ways achieving load balancing however since one goals minimize communication cost would like minimize l ij would correspond minimization amount vertex movement deformity original partitions thus loadbalancing step formally defined following linear programming problem minimize x subject constraint 12 corresponds load balance condition formulation based assumption changes original graph small initial partitioning well balanced hence moving boundaries small amount give balanced partitioning low communication cost f mapvj represents mapping vertex j g represents j th element local adjacent list partition g represents starting address vertex j local adjacent list partition g represents set vertices partition distance k node partition j f neighbor represents set partitions common boundaries partition g partition vertex count l add vj tag0 f level 0 repeat vertex vj 2 klevel l gamma xadj vj xadj count add vj tmps level vertex vj 2 tmps add vj taglevel f count 0klevel figure 3 layering algorithm b figure 4 labeling nodes graph closest outside partition microscopic view layering graph near boundary three partitions b layering graph figure 2 b edges shown constraints 11 l constraints 12 gammal gammal solution using simplex method l values zero figure 5 linear programming formulation solution based mapping graph figure 2 b using labeling information figure 4 b several approaches solving linear programming problem decided use simplex method shown work well practice easily parallelized 1 simplex formulation example figure 2 given figure 5 corresponding solution l l 1 new partitioning given figure 6 20initial partitions incremental partitions figure new partition graph figure 2 b load balancing step set constraints may feasible solution one approach relax constraint 11 l ij constraint clearly would achieve load balance may lead major modifications mapping another approach replace constraint 12 assuming would achieve load balancing one step several steps applied feasible solution cannot found reasonable value delta within upper bound c would better start partitioning scratch solve problem adding fraction nodes given time ie solve problem multiple stages typically cases arise new nodes correspond partitions amount incremental change greater size one partition 34 refinement partitions formulation previous section achieves load balance try explicitly reduce number crossedges minimization term 10 constraint 11 indirectly keep crossedges minimum assumption initial partition good section describe linear programmingbased strategy reduce number crossedges still maintaining load balance achieved finding vertices partitions boundary partition j cost edges vertices j larger cost edges local vertices figure 7 ie total cost crossedges decrease moving vertex partition j affect load used dense version simplex algorithm total time potentially reduced using sparse representation local nonlocal edge partition nonlocal edge partition 3 figure 7 choosing vertices refinement microscopic view vertex moved partition p p j reducing number cross edges b set vertices property partition figure 6 balance following linear programming formulation given moves vertices keeping load balance mapping vertex loadbalancing step let outk represent number edges vertex k partition 00 k connected partition jj 6 00 k let represent number vertices vertex k connected partition 00 k let b ij represent number vertices partition outgoing edges partition j local edges would like maximize number vertices moved moving vertex increase cost crossedges inequality definition changed strict inequality leave equality however since including vertices number points moved larger vertices moved satisfy load balance constraints without affecting number crossedges refinement problem posed following linear programming problem maximize x refinement step applied iteratively effective gain movement vertices small steps inequalities l ij need replaced strict inequalities l ij constraint 15 l load balancing constraint 16 gammal gammal solution using simplex method l figure 8 formulation refinement step using linear programming solution otherwise vertices equal number local nonlocal vertices may move boundaries without reducing total cost simplex formulation example figure 6 given figure 8 new partitioning refinement given figure 9 20incremental partitions refined partitions figure 9 new partition graph figure 6 refinement step 35 time complexity let number vertices number edges graph given v e respectively time layering ov e let number partitions p number edges partition graph 2 node graph represents partition edge super graph present whenever cross edges node one partition node another partition r number constraints variables generated linear programming op r o2r respectively thus time required linear programming op rr assuming r op reduces number iterations required linear programming problem dependent use fp denote number iterations thus time required linear programming op 2 fp gives total time repartitioning oe parallel time considerably difficult analyze analyze complexity neglecting setup overhead coarsegrained machines parallel time complexity layering step depends maximum number edges assigned processor could approximated oep level assuming changes graph incremental graph much larger number processors parallelization linear programming requires broadcast length proportional op assuming broadcast size p requires bp amount time parallel machine p processors time complexity approximated e 4 multilevel approach small graphs large fraction total time spent algorithm described previous section linear programming formulation solution since time required one iteration linear programming formulation proportional square number partitions substantially reduced using multilevel approach consider partitioning incremental graph partitions completed two stages partitioning graph 4 super partitions partitioning 4 super partitions 4 partitions clearly two stages used advantage algorithm time required applying linear programming stage would much less time required linear programming using one stage due substantial reduction number variables well constraints directly dependent number partitions however mapping initialization layering needs performed scratch level thus decrease cost linear programming leads potential increase time spent layering multilevel algorithm requires combining partitions original graph super partitions implementations recursive spectral bisection used ab initio partitioning algorithm due recursive property creates natural hierarchy partitions figure 10 shows twolevel hierarchy partitions linear programmingbased algorithm applied repartitioning graph adapted several times possible partitions corresponding lower level subtree small number boundary edges since multilevel approach results repartitioning small number partitions lower levels linear programming formulations may produce infeasible solutions lower levels problem partially addressed reconfiguring partitioning hierarchy simple algorithm used achieve reconfiguration tries group proximate partitions form multilevel hierarchy level tries combine two partitions one larger parti tion thus number partitions reduced factor two every level using procedure find unique neighborp figure 11 finds unique neighbor partition number crossedges large possible achieved applying simple heuristic figure 12 uses list partitions random order processor different order one processor successful generating feasible solution ties broken based weight processor number result merging broadcast processors case none figure 10 twolevel hierarchy 16 partitions partitions g represents number edges partition partition j g global success false trial 0 global success trial processor list partitions random order weight 0 find pairsuccessmarkweight edge global success global orsuccess global success fix pairsuccessmarkweight edge global success global orsuccess global success winner find winnersuccessweight f return processor number maximum weight g f processor winner broadcast mark processors g returnglobal success else trial trial1 figure reconstruction algorithm find pairsuccess markw eight edge success true find neighbor k j markk k exists weight else success false fix pairsuccess markw eight edge success true j p success x exists markx 0 x neighbor l neighbor markx l markl x weight else success false else figure 12 high level description procedures used find unique neighbor processors successful another heuristic figure 12 applied tries modify partial assignments made heuristic 1 find neighbor partition none processors able find feasible solution processor starts another random solution step iterated constant number l times 3 figure 11 shows partition reconfiguration simple example reconfiguration algorithm fails multilevel algorithm applied lower number levels one level randomlist randomlist randomlist randomlist b e f figure 13 working example reconstruction algorithm graph 4 partitions b partition c adjacency lists random order lists e partition rearrangement f processor 3 broadcasts result processors g hierarchy reconfiguration 3 practice found algorithm never requires one iteration 41 time complexity following provide analysis assuming reconfiguration required complexity reconfiguration discussed later multilevel approach assume level number partitions done equal given k thus number levels generated log k p time required layering increases oelog k p number linear programming formulations given p thus total time linear programming given p fk total time required repartitioning given oelog k p value k would minimize sum cost layering cost linear programming formulation choice k also depends quality partitioning achieved increasing number layers would general deteriorating effect quality partitioning thus values k chosen based tradeoffs however analysis suggests reasonably sized graphs layering time would dominate total time since layering time bounded oelogp time considerably lower applying spectral bisectionbased methods scratch parallel time considerably difficult analyze parallel time complexity layering step depends maximum number edges processor level approximated level assuming changes graph incremental graph much larger number processors discussed earlier parallelization linear programming requires broadcast length proportional ok small values k linear programming formulation executed one processor else communication dominate total time thus parallel time proportional e analysis take reconfiguration account cost reconfiguration requires okd 2 time parallel every iteration average number partitions every partition connected total time okd 2 log p reconfiguration time dominate total time required linear programming algorithm 5 experimental results section present experimental results linear programmingbased incremental partitioning methods presented previous section use term incremental graph partitioner igp refer linear programming based algorithm experiments conducted 32node cm5 available npac syracuse university meshes used two sets adaptive meshes experiments meshes generated using dime environment 15 initial mesh set given figure 14 incremental meshes generated making refinements localized area initial mesh meshes represent sequence refinements localized area number nodes meshes 1071 1096 1121 1152 1192 respectively partitioning initial mesh 1071 nodes determined using recursive spectral bisection partitioning used algorithm igp determine partitioning incremental mesh 1096 nodes repartitioning next set refinement 1121 1152 1192 nodes respectively achieved using partitioning obtained using igp previous mesh sequence meshes used test whether igp suitable repartitioning mesh several refinements figure 14 test graphs set irregular graph 1071 nodes 3185 edges b graph additional nodes c graph b 25 additional nodes graph c 31 additional nodes graph 40 additional nodes figure 15 test graphs set b mesh 10166 nodes 30471 edges b mesh 48 additional nodes c mesh 139 additional nodes mesh 229 additional nodes e mesh 672 results initial graph figure 14 total cutset max cutset min cutset figure 14 b partitioner times timep total cutset max cutset min cutset spectral bisection 3171 733 56 33 igp 1475 068 747 55 34 igp refinement 1687 088 730 54 34 figure 14 c partitioner times timep total cutset max cutset min cutset spectral bisection 3405 732 56 34 igp 1363 073 752 54 33 igp refinement 1642 105 727 54 33 figure 14 partitioner times timep total cutset max cutset min cutset spectral bisection 3496 716 57 34 igp 1589 092 757 56 33 igp refinement 1832 128 741 56 33 partitioner times timep total cutset max cutset min cutset spectral bisection 3820 774 63 34 igp 1569 094 815 63 34 igp refinement 1843 126 779 59 34 time unit seconds p parallel timing 32node cm5 timing 1node cm5 figure incremental graph partitioning using linear programming comparison spectral bisection scratch meshes figure 14 set next data set set b corresponds highly irregular meshes 10166 nodes 30471 edges data set generated study effect different amounts new data added original mesh figures 17 b 17 c 17 17 e correspond meshes 68 139 229 672 additional nodes mesh figure 15 results onelevel igp set meshes presented figure 16 results show even multiple refinements quality partitioning achieved comparable achieved recursive spectral bisection scratch thus method used repartitioning several stages time required repartitioning half time required partitioning using rsb algorithm provides speedup around 15 20 32node cm5 time spent algorithm solution linear programming formulation using simplex method number variables constraints generated onelevel linear programming algorithm loadbalancing step meshes figure partitions 188 126 respectively multilevel approach linear programming formulation subproblem given level initial graph figure 15 total cutset max cutset min cutset b initial assignment igp using partition figure 15 partitioner times timep total cutset max cutset min cutset spectral bisection 80005 2137 178 90 igp refinement 1390 101 2139 186 84 igp refinement 2407 183 2040 172 82 c initial assignment igp using partition figure 15 partitioner times timep total cutset max cutset min cutset spectral bisection 81436 2099 166 87 igp refinement 1889 108 2295 219 93 igp refinement 2933 201 2162 206 85 initial assignment igp using partition figure 15 partitioner times timep total cutset max cutset min cutset spectral bisection 85335 2057 169 94 igp refinement 2 3598 208 2418 256 92 igp refinement 4386 276 2139 190 85 initial assignment igp using partition figure 15 partitioner times timep total cutset max cutset min cutset spectral bisection 90481 2158 158 94 igp refinement 3 7678 366 2572 301 102 igp refinement 8948 439 2270 237 96 time unit seconds p parallel timing 32node cm5 timing 1node cm5 figure 17 incremental graph partitioning using linear programming comparison spectral bisection scratch meshes figure 15 set b solved assigning subset processors table 19 gives time required different algorithms quality partitioning achieved different numbers levels 4 theta 4 theta 2based repartitioning implies repartitioning performed three stages decomposition 4 4 2 partitions respectively results presented figure 19 solution qualities multilevel algorithms show insignificant deterioration number cross edges considerable reduction total time partitioning achieved algorithm igp set b meshes figure 18 using partition mesh figure 15 given figure 17 number stages required choosing appropriate value delta described section 23 1 1 2 3 respectively 4 worth noting although load imbalance created additional nodes severe quality partitioning achieved case close applying recursive spectral bisection scratch sequential time least order magnitude better recursive spectral bisection cm5 implementation improved time required factor 15 20 time required repartitioning figure 17 b figure 17 c close required meshes figure 14 timings meshes figure 17 17 e larger use multiple stages time reduced using multilevel approach figure 20 however time reduction relatively small 2407 seconds 670 seconds twolevel approach increasing number levels increases total time cost layering increases time reduction last mesh 10838 nodes largely due reduction number stages used multilevel algorithm section 33 almost cases speedup 15 25 achieved 32node cm5 figure 21 figure 22 show detailed timing different steps mesh figure 14 mesh figure 15 b sequential parallel versions repartitioning algorithm respectively clearly time spent reconfiguration negligible compared total execution time also time spent linear programming multilevel algorithm much less singlelevel algorithm results also show time linear programming remains approximately meshes time layering proportionally larger multilevel parallel algorithm time layering comparable time spent linear programming smaller mesh dominates time larger mesh since layering term olevels e results support complexity analysis previous section time spent reconfiguration negligible compared total time 6 conclusions paper presented novel linear programmingbased formulations solving incremental graphpartitioning problems quality partitioning produced methods close achieved applying best partitioning methods scratch time needed small fraction latter algorithms inherently parallel believe methods described paper critical importance parallelization adaptive incremental problems 4 number stages chosen trial error determined load imbalance b figure partitions using rsb b 0 partitions using igp starting using igp starting 0 0 partitions using igp starting 0 using igp starting 0 graph level description times timep total cutset time unit seconds cm5 figure 19 incremental multilevel graph partitioning using linear programming comparison singlelevel graph partitioning sequence graphs figure 14 graph level description times timep total cutset time unit seconds cm5 figure 20 incremental multilevel graph partitioning using linear programming comparison singlelevel graph partitioning sequence meshes figure 15 figure 14 level reconfiguration layering linear programming total figure 15 b level reconfiguration layering linear programming total time seconds balancing r refinement total figure 21 time required different steps sequential repartitioning algorithm figure 14 level reconfiguration layering linear programming data movement total figure 15 b level reconfiguration layering linear programming data movement total time seconds balancing r refinement total figure 22 time required different steps parallel repartitioning algorithm 32node cm5 r solving problems concurrent processors software support irregular loosely synchronous problems heuristic approaches task allocation parallel computing load balancing loosely synchronous problems neural network solving problems concurrent processors graphical approach load balancing sparse matrix vector multiplication hypercube improved spectral graph partitioning algorithm mapping parallel computations multidimensional spectral load balancing genetic algorithms graph partitioning incremental graph partitioning physical optimization algorithms mapping data distributedmemory multi processors solving finite element equations current computers fast mapping remapping algorithm irregular adaptive problems partitioning sparse matrices eigenvectors graphs partitioning unstructured mesh problems parallel processing dime distributed irregular mesh enviroment performance dynamic loadbalancing algorithm unstructured mesh calcula tions tr ctr sungho woo sungbong yang improved network clustering method ioefficient query processing proceedings 8th acm international symposium advances geographic information systems p6268 november 0611 2000 washington dc united states mark j clement glenn judd bryan morse j kelly flanagan performance surface prediction wanbased clusters journal supercomputing v13 n3 p267281 may 1999 donlin yang yehching chung chihchang chen chingjung liao dynamic diffusion optimization method irregular finite element graph partitioning journal supercomputing v17 n1 p91110 aug 2000 chingjung liao yehching chung treebased parallel loadbalancing methods solutionadaptive finite element graphs distributed memory multicomputers ieee transactions parallel distributed systems v10 n4 p360370 april 1999 john c lui f chan efficient partitioning algorithm distributed virtual environment systems ieee transactions parallel distributed systems v13 n3 p193211 march 2002 yehching chung chingjung liao donlin yang prefix code matching parallel loadbalancing method solutionadaptive unstructured finite element graphs distributed memory multicomputers journal supercomputing v15 n1 p2549 jan 2000 umit catalyurek cevdet aykanat hypergraphpartitioning approach coarsegrain decomposition proceedings 2001 acmieee conference supercomputing cdrom p2828 november 1016 2001 denver colorado umit catalyurek cevdet aykanat hypergraphpartitioningbased decomposition parallel sparsematrix vector multiplication ieee transactions parallel distributed systems v10 n7 p673693 july 1999 cevdet aykanat b barla cambazoglu ferit findik tahsin kurc adaptive decomposition remapping algorithms objectspaceparallel direct volume rendering unstructured grids journal parallel distributed computing v67 n1 p7799 january 2007 f hu r j blake load balancing unstructured mesh applications progress computer research nova science publishers inc commack ny 2001
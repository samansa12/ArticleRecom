lookahead procedures lanczostype product methods based threeterm lanczos recurrences lanczostype product methods solution large sparse nonhermitian linear systems either square lanczos process combine local minimization residual inherit underlying lanczos process danger breakdown various lanczostype product methods based lanczos threeterm recurrence lookahead versions presented avoid breakdowns nearbreakdowns cost small computational overhead different lookahead strategies discussed efficiency demonstrated several numerical examples b introduction lanczostype product methods ltpms like bicgs 42 bicgstab 44 bicgstab2 22 bicgstab 38 41 among efficient methods solving large systems linear equations sparse system matrix 2 c n thetan compared biconjugate gradient method advantage converging roughly twice fast requiring routine applying adjoint system matrix h vector nev ertheless inherit bicg short recurrence formulas generating approximations x k corresponding residuals r k b gamma ax k bicg convergence smoothed applying quasi minimal residual qmr method 16 local minimum residual process mr smoothing 37 47 product methods combined techniques 14 47 avoid likely erratic convergence behavior 11 36 benefit smoothing techniques disputed however wellknown problem methods make implicit use lanczos polynomials generated nonhermitian matrix danger breakdown although exact breakdowns rare practice observed nearbreakdowns slow even prevent convergence 15 lookahead techniques lanczos process 15 21 23 34 35 43 allow us avoid problem use variants bicg method without mentioned smoothing tech niques however general lookahead procedures far proposed bicgs ltpms either limited exact breakdowns 8 9 based different lookahead recursions fact lookahead steps proposed brezinski redivo zaglia 5 avoid nearbreakdowns cgs 6 applicable ltpms based socalled bsmrz algorithm based generalization coupled recurrences different standard biomin biodir versions bicg method implementing lanczos method theoretical comparison two approaches refer 25 x 19 recently number lookaheadlike algorithms lanczos type solvers proposed ayachour 1 brezinski et al 7 gravesmorris applied mathematics eth zurich ethzentrum hg ch8092 zurich switzerland mhgsammathethzch formerly swiss center scientific computing cscsscsc german aerospace research establishment dlr german remote sensing data center dfd d82234 oberpfaffenhofen germany kjrdfddlrde formerly also cscsscsc 19 ziegler 48 discussion beyond scope paper seems 1 7 48 restricted exact breakdowns paper start approach 15 23 x 9 derive alternative lookahead procedure ltpm algorithms make use lanczos threeterm recurrences compared standard coupled twoterm recurrences advantage simpler handle regard lookahead since affected one type breakdown contrast first version work 26 also capitalize upon enhancement lookahead lanczos algorithm pointed hochbruck recently see 28 25 adapted ltpms improvements help reduce overhead stabilize process starting initial approximation x 0 corresponding initial residual steps basis 2ndimensional krylov space way even indexed basis vectors form ae n nth lanczos polynomial see n another suitably chosen polynomial exact degree n algorithms discuss vectors either residual nth approximation xn scalar multiple allowing multiples residuals considering socalled unnormalized 20 inconsistent 25 krylov space solvers avoid occurrence pivot ghost breakdowns various types breakdowns connection block structure pade table see 20 24 30 31 setting 5 6 addressed particularly 4 generally define doubly indexed sequence product vectors w l n aim find n 1th step ltpm improved approximation xn1 computing new product vector w n1 n1 previously determined ones stable way visualize progression algorithm recurrences uses arrange product vectors w l n wtable 1 naxis points downwards laxis right describe algorithm moves table upper left corner downwards right paper organized follows section 2 review lookahead lanczos process versions based lanczos threeterm recurrences various ltpms introduced section 3 section 4 present ltpms lookahead procedures analyze computational overhead section 5 several lookahead strategies discussed preferred way applying lookahead procedures obtain solution linear system presented section 6 section 7 efficiency proposed algorithms demonstrated numerical examples section 8 draw conclusions 2 lookahead lanczos process primary aim lanczos process 32 construction pair biorthogonal bases two nested sequences krylov spaces given 2 c n thetan pair starting vectors ey biorthogonalization bio algorithm generates pair finite sequences fey n g 1 wtable different scheme introduced sleijpen fokkema 38 bicgstab fyng n0 left right lanczos vectors e ae equivalently hdelta deltai denotes inner product c n choose linear second argument indicates corresponding orthogonality sequence pairs lanczos vectors constructed threeterm recursions coefficients ff n fi n determined orthogonality condition 22 nonvanishing scale factors fl n chosen arbitrarily choosing would allow us consider right lanczos vectors yn residuals update iterates xn particularly simply choice also introduces possibility breakdown due ff n therefore suggest section 6 different way defining iterates 24 follows directly lanczos vectors written form e ynae n ae n denotes nth lanczos polynomial since aim ltpms consider krylov spaces e kn general basis vectors form e arbitrary suitably chosen polynomials n exact degree n e z 0 e 0 general e z n1 kn1 longer hold e kn1 yn1 still attained enforcing e z means choosing coefficients ff n 24 following way n 0 need since hez similarly orthogonality condition hez obtain equations 2729 first recurrence 24 specify one might call onesided lanczos process formulated 36 derive ltpms clearly recursive process terminates breaks ffi lookahead lanczos process 23 x 9 15 overcomes breakdown curable ie k hez k 6 0 however role restricted treating exact breakdowns ffi 0 allows us continue biorthogonalization process whenever stability reasons choose enforce orthogonality condition 22 partially couple steps come back later conditions make us start lookahead phase lookahead lanczos process price pay gramian matrix hez yn becomes blocklower triangular instead triangular generic onesided lanczos algorithm diagonal generic twosided lanczos algorithm words replace conditions e e nonsingular subsequence indices wellcondi tioned regular lanczos vectors yn j indices vectors called inner vectors likewise refer n regular index n called inner index otherwise note considerable freedom choosing subsequence fn j g j example might request smallest singular value oe min j sufficiently large sequence fyn g determined condition e hence depend directly sequence fez n g spaces e spanned first n j elements fez n g hand smallest singular value j depends basis chosen fact one take account forming blocks theta theta e z express relation 210 e ae lookahead step size following denoted h j n lookahead case lanczos vectors fyng generated recursion 23 x 9 15 theta denotes yet fully completed jblock inner index b regular coefficient vector fi n determined condition thus e coefficient vector ff n chosen arbitrarily n1 inner index obviously choice ff yields cheapest recursion may gain numerical stability choosing ff n 6 0 hand results condition e recently pointed hochbruck 28 recursion 213 simplified since contribution older block j gamma1 represented multiples single auxiliary vector 0 due fact noticed 23 matrix made coefficient vectors fi n j rank one see also 25 x 19 simplification also capitalized upon lookahead hankel solver freund zha 17 closely related lookahead lanczos algorithm particular due 210 212 therefore 214 simplifies e introducing auxiliary vector e z h recurrence 213 becomes 215 changes e 2 3 lanczostype product methods ltpms ltpms based two ideas first one derive certain sequence product vectors w l1 recursion formulas involve previously computed product vectors need explicitly computing vectors e z l yn multiplying threeterm recursion 24 right lanczos vectors yn l obtain aw l recursion applied move forward vertical direction wtable obtain formula proceeding horizontal direction recursion chosen polynomials l capitalized upon analogous way second basic idea rewrite inner products appear lanczos process terms product vectors coefficients ff n fi n 28 29 results ltpms still short recurrence formulas polynomials l short one addition two advantages bicg first multiplications adjoint system matrix h avoided second appropriate choice polynomials l smaller new residuals r l w l ay l expected reduction l operator l different choices polynomials l lead different ltpms following briefly review possible choices polynomials start general class satisfy threeterm recursion since left polynomials l right polynomials ae n fulfill threeterm recursion say class 3 3type ltpms following briefly review possible choices polynomials detailed discussion pseudocode resulting algorithms refer 36 31 ltpms based threeterm recursion f l g bioxcheb bioxmr2 assume polynomials l generated threeterm recursion form 22 l note induction l exact degree l l l hence polynomials qualify residual polynomials krylov space method multiplying yn l1 left applying 33 yields horizontal recurrence applying 31 34 following loop produces new product vector w n1 previously calculated ones namely w l 1 product aw also evaluated end loop besides n1 needed next run loop available loop 31 general 3 3type ltpm 1 compute n determine fi n ff n 2 use 31 compute w n1 3 compute n1 determine n jn 4 use 34 compute w n1 n w n1 n1 next discuss two ways choosing polynomials l specifying recurrence coefficients l j l one possibility combine lanczos process chebyshev method 13 45 choosing l suitably shifted scaled chebyshev polynomial combination suggested 3 22 44 let us call resulting 3 3type ltpm bioxcheb well known polynomials satisfy recurrence form 33 acquiring information spectrum matrix example performing iterations another krylov space method one determine recursion scaled shifted chebyshev polynomials correspond ellipse surrounding estimated spectrum 33 however necessity provide spectral information often seen drawback method another idea use coefficients l j l 33 locally minimizing norm new residual w l1 l1 idea borrowed bicgstab methods 44 22 reviewed l j l determined solving twodimensional minimization problem min introducing n theta 2 matrix b l1 theta w l write 35 leastsquares problem min therefore l j l computed solution normal equations l view twodimensional local residual norm minimization performed every step except first one call bioxmr2 method 2 version based coupled twoterm lanczos recurrences method introduced first author talk oberwolfach april 1994 independently well proposed cao 10 zhang 46 whose technical report dated april 1993 zhang also considered twoterm formulas l presented favorable numerical results 2 letter x name bioxmr2 reflects fact residual polynomials method products lanczos polynomials generated bio process polynomials obtained successive twodimensional minimization residual mr2 similarly bioxcheb means combination bio process chebyshev process 32 ltpms based twoterm recursion f l g biostab van der vorsts bicgstab 44 polynomials l built successively products polynomials degree 1 inserting system matrix multiplying yn right yields coefficient l determined minimizing norm w l1 solving onedimensional minimization problem min 2c leads haw l haw l recurrences 31 38 used compute new product vector w n1 w n n w n described loop 31 calculated 310 however since 38 twoterm recurrence need compute w n1 substep 2 loop call algorithm biostab since version bicgstab based threeterm recurrences lanczos biorthogonalization process 3 33 biostab2 biostab2 version bicgstab2 22 based threeterm lanczos recurrences polynomials l satisfy recursions l even l odd l may obtained solving onedimensional minimization problem 39 l given 310 however j l j small choice dangerous since vector component needed enlarge krylov space becomes negligible 38 value l chosen except roundoff choice effect later steps l j l determined solving twodimensional minimization problem 35 multiplying yn l1 applying 311 leads ae l even aw l l odd 31 applies even n jn chosen indicated n odd n even need compute w n1 substep 2 loop 3 eijkhout 12 also proposed variant bicgstab however way computing lanczos coefficients much complicated 34 biosquared bios bios obtained squaring threeterm lanczos process among basis vectors generated krylov space vectors correspond squared lanczos polynomials complementing bios recursion galerkin iterates obtain bioress 3 3type version sonnevelds 2 2type conjugate gradient squared cgs method 42 method fits framework ltpms identify l vectors e yn exactly left lanczos vectors yn e kn well e z n kn fulfilled thus coefficient ff n 32 simplifies wtable becomes symmetric since consequently analogy 31 aw l two recursions lead following loop loop 32 bios 1 compute n determine fi n ff n 2 use 31 compute w n1 3 compute n1 4 use 316 compute w n1 n1 note exploit substep 2 symmetry wtable product vector needed calculation w n n1 31 equal w n need stored also point 316 form 34 particular coefficients w n w l n need sum 1 4 lookahead procedures ltpms lookahead steps ltpm serve stabilize lanczos process vertical movement wtable except bios recursion formulas horizontal movement remain vertical movement general based recurrence formula 221 lanczos vectors need replace vectors product vectors w l introduce blocks product vectors c l theta theta auxiliary product vector w 0 l defined c l regular index c w l denotes yet completed jth block n 1 inner index multiplying 221 l left obtain aw l section 3 coefficient vectors fi 0 n regular case ff n expressed terms product vectors rewriting inner products way part l z l left side transferred right side inner product diagonal blocks j gramian yields theta fi 0 n 218 becomes likewise ff n 222 turns advancing horizontal direction wtable still use 34 38 combination 312 316 substituting aw n 44 according formulas letting n nelement 44 simplifies remark using 46 instead hez avoid compute store complete block elements block needed see figure 41 figure display entries w l n products aw l n wtable needed compute 42 new vector w l n1 marked inner case v 0 v regular case ff 0 ff v v fig 41 entries wtable needed construction new inner regular vector marked recurrence formula 42 v 0 indicates entries needed w 0 l c l additionally required j moreover ff 0 marks auxiliary vectors formula 45 ff n stands matrixvector product mv formula one product also appears explicitly 42 note horizontal recursions valid auxiliary product vectors example 34 41 imply 38 41 provide thus auxiliary vector updated horizontal direction cost one matrixvector product mv per step combining recursions vertical movement horizontal movement leads lookahead version ltpm actually also need compute approximations solution gamma1 b linear system defer till section 6 additional vectors involved recurrence formulas seems lookahead ltpm requires much computational work storage unstable standard version however number lookahead steps well size blocks small practice overhead moderate moreover describe following various choices polynomials mvs needed computed indirectly applying recurrence formulas way also values inner products obtained indirectly nearly cost 41 lookahead ltpms based threeterm recursion f l g la bioxcheb labioxmr2 methods incorporating horizontal threeterm recurrence bioxcheb bioxmr2 applying principles lookahead ltpms leads general loop 41 note first four substeps identical cases see section 5 decision regular inner loop made substep 5 figure 42 display action loop wtable use different format one hand specifies known current sweep loop computed sweep particular following symbols indicators used ffl v indicates corresponding product vector already known ffl denominator indicates product vector represented v matrix needed ffl solid box around fraction means product required requires mv ffl box around fraction means product obtained applying recurrence formula ffl number entry specifies substep current sweep entry calculated ffl prime indicates vector auxiliary one defined 41 vectors displayed last row corresponding block indicates product vector represented matrix needed ffl double primes indicate vector auxiliary one type defined 411 used labicgs vectors displayed lower right corner corresponding block wtable ffl indicate vector mv obtained free due symmetry wtable labicgs loop 41 lookahead 3 3type ltpm let min fn inner loop n 1 compute n 2 n use 42 compute indirectly aw n 3 n n 4 n n j 3 use 34 compute indirectly aw 1 n 5 use 42 compute w n n1 6 compute n1 n jn 7 use 34 compute w n1 n1 8 compute use 47 compute w 0 n1 regular loop n 1 compute n 2 n use 42 compute indirectly aw n 3 n n 4 n n j 3 use 34 compute indirectly aw 1 n 5 use 42 compute w n n1 n1 6 compute n1 n jn 7 use 34 compute w n1 n1 8 compute according definition 41 inner loop regular loop inner loop regular loop fig 42 action loop 41 lookahead 3 3type ltpm wtable blocks different sizes inner step left following regular step right shown first two wtables figure 42 display happens first inner step left regular step right follows directly regular step 1 second pair wtables figure 42 consider inner regular step case large block size note substeps 24 loop appear first pair substep 4 would still active regular loop end lookahead step length h active lookahead step length h j cost terms mvs 4h mvs h j 1 fact first substep h inner one regular loops h j mvs consumed another h needed substep 3 substep 6 remaining h used substep 6 inner loops lookahead needed h required procedure standard one allow lookahead hence step length 2 25 overhead step length 3 50 overhead even longer steps rare practice overhead grows gradually towards 100 42 lookahead biostab biostab2 since horizontal recurrence 38 biostab twoterm one need compute elements second subdiagonal wtable long lookahead step case lookahead step remains true elements lie subdiagonal block course diagonal block loop 41 means simplifies n j substep 5 regular loop need compute w changes refer equation numbers coefficients n jn summary obtain loop 42 first four substeps cases choice made substep 5 figure 43 display loop two sections wtables correspond second pair figure 42 since product vectors loop 41 longer needed loop 42 found without extra mv overhead terms mvs remains lookahead biostab2 could defined along lines alternating steps loop 41 loop 42 point also becomes clear obtain lookahead version biostab algorithm analogous bicgstab sleijpen fokkema 38 based threeterm lanczos process instead coupled twoterm bicg formulas 43 lookahead biconjugate gradient squared labios bios underlying process bioress version bicgs horizontal recurrence 34 substituted lanczos recurrence given 316 may need replaced lookahead formula analogous 42 l n exchanged suitably defined auxiliary vectors blocks vectors since wtable symmetric build vertical recursions reflections diagonal formulate recursion w 0 l horizontal one replaces 47 theta recurrence 49 follows horizontal lanczos lookahead recurrences computing derived 213 instead 221 gathered loop 42 lookahead biostab inner loop n 1 compute n 2 n use 42 compute indirectly aw n 3 n n 4 n n j 3 use 38 compute indirectly aw n j 1 n 5 use 42 compute w n n1 6 compute n1 n 7 use 38 compute w n1 n1 8 compute use 48 compute w 0 n1 regular loop n 1 compute n 2 n use 42 compute indirectly aw n 3 n n 4 n n j 3 use 38 compute indirectly aw n j 1 n 5 use 42 compute w n n1 6 compute n1 n 7 use 38 compute w n1 n1 8 compute according definition 41 inner loop regular loop fig 43 action loop 42 lookahead biostab wtable inner step left following regular step right shown one recurrence columns w l1 postmultiplied 41 49 simplified define block needed values j auxiliary vector l n k l n k1 coefficient fi 0 l ffi nk l nk gamma1 46 view 217 46 loop 43 lookahead bios inner loop n 1 compute n 2 n n j 2 use 42 compute indirectly aw n ngamma2 3 use 42 compute w n n1 4 compute n1 aw 0 n 5 use 413 compute w 0 n1 6 use 42 compute w n1 n1 regular loop n 1 compute n 2 n n j 2 use 42 compute indirectly aw n ngamma2 3 use 42 compute w n n1 4 compute n1 aw 0 n 5 use 413 compute w 0 n1 6 use definition 41 compute j use definition 411 compute w 00 j 7 use 42 compute w n1 n1 8 use definition 41 compute inner loop vs regular loop fig 44 action loop 43 lookahead bios wtable inner loop top following regular loop bottom shown consequently 49 simplifies l step resulting labios algorithm summarized loop 43 decision regular inner loop made substep 3 corresponds substep 5 loops 41 42 even first five substeps two versions loop identical figure 44 display labios pair loops figure 43 labiostab lookahead step length h j cost terms mvs 3h j mvs 3h standard nonlook ahead algorithm requires 2 mvs per step means overhead 50 first substep h inner one regular loop h j mvs consumed another 2h j mvs needed substep 4 44 overhead lookahead subsection discuss overhead lookahead process terms mvs inner products ips necessary storage nvectors first note ips required lookahead algorithms fixed initial vector e z 0 first argument therefore second argument ip computed recurrence formula also ip vector e z 0 computed indirectly applying recurrence formula thus ips n aw l n computed directly need computed explicitly means algorithms number required ips equal number required mvs must admit however recursively computed inner products well recursively computed matrixvector products may source additional roundoff may cause instability actually understanding compute inner products needed reader may want introduce ffitable oetable entries ffi l oe l loops figures generating w table hold well two tables note ffitable contains transposed matrix table cost overhead lookahead ltpms constructing lookahead step length h j 1 construction iterates yet included capitalizing upon storage locations become available lookahead step storage overhead could reduced roughly 50 method total cost cost overhead storage overhead mvs ips mvs ips relativ nvectors terms mvs cost lookahead step length h j 1 specified previous subsection subtracting cost h j nonlookahead steps 2h j mvs obtain overhead summarized table 41 stress algorithm overhead except necessary test regularity fails would reveal upcoming instability initiate lookahead step table lists additionally overhead storage nvectors straightforward implementation optimized respect memory usage comparison cite page 60 5 page 180 6 cgs lookahead procedure brezinski redivo zaglia requires 6h typical case 5h j n means relatively large lookahead step needed one first iterations therefore compared numbers overhead terms mvs four times h j large five times h larger labios assuming basis standard cgs implementation requiring 2mvs per ordinary iteration however also note according numbers step without lookahead 1 methods 5 6 need 3mvs instead 2mvs 5 lookahead strategies section address delicate issue perform lookahead step means ltpm decide whether new vertical index n1 regular index inner index ie whether required product vectors w l n1 n 1th row wtable computed regular inner vectors therefore lookahead procedure ltpms serves stabilize underlying lanczos method vertical movement product method wtable consequently criterion carry lookahead step ltpm based criterion given 15 lanczos algorithm however since lanczos vectors e yn yn computed explicitly product method need rewrite conditions criterion terms product vectors w l let us first motivate conditions case exact breakdown e z n 6 0 yn 6 0 division zero would occur next lanczos step first task lookahead process circumvent exact breakdowns without necessity restarting lanczos process loosing superlinear convergence finite precision arithmetic exact breakdowns unlikely however near breakdowns jffi small may occur cause large relative roundoff errors lanczos coefficients ff n fi n given 32 precise recall relative roundoff error computation inner product ffi bounded 18 p 64 denotes roundoff unit thus small value jffi leads finite precision arithmetic big relative roundoff error computation inner product n also causes perturbation lanczos coefficients ff n fi n since depend ffi respectively second task lookahead process therefore avoid convergence deterioration due perturbed lanczos coefficients course similar roundoff effects may come numerators formulas 32 ff n fi n large relative errors harmful denominators small would like point ltpm inner products ffi n enlarged certain extent appropriate adaptive choice polynomials n 39 40 long h example considering biostab case obtain since hez thus minimizing relative roundoff error calculation ffi n equivalent choosing ngamma1 minimizes n corresponds use orthogonal residual polynomials degree 1 instead minimal residual polynomials degree 1 recursive definition l therefore minimizing relative roundoff error inner product ffi conflicts often objective avoiding large intermediate residuals order prevent recursive residual drift apart true residual 40 performing lookahead step possible remedy need find criterion deciding lookahead step performed objectives attained view recursion 42 product vectors case lookahead follows block closed new product vector computed regular vector diagonal blocks j gamma1 j gramian numerically nonsingular thus first condition needs fulfilled order compute new product vector n1 regular vector n oe min j oe min j denotes minimal singular value block j note mean j well conditioned guarantees numerical nonsingu larity practice 51 replaced condition implies nonsingularity example one implemented linear solver used computing 219 ff n 222 freund et al 15 use second condition guarantee krylov space stably extended next lanczos step sense basis lanczos vectors sufficiently well conditioned terms product vectors second condition amounts computing l new product vector w l n1 regular vector addition 51 following conditions coefficients ff n fi n fulfilled kdeltak 1 denotes 1 norm na estimate kak updated dynamically ensure blocks w n j become larger user specified maximal size 15 motivation 52 ensure new regular vector obtained 42 c since n regular component new direction aw n n sufficiently large case n tol 2 chosen tolerance compared 52 condition 53 costs additional two inner products calculation w regular case reused computation new product vector w n n1 since could replace 53 less expensive condition however ltpm possible normalize product vectors w l see section 6 c equal 1 moreover 55 less strict 53 52 since lookahead step expensive regular steps providing increase krylov space dimension tight lookahead criterion save overall computational cost therefore reasonable spend extra effort reason favor criterion 53 drawback 53 take angle aw n n w account c c chosen larger case nearly 1 motivates choice suitably chosen constants c depending roundoff unit criterion requires extra inner product appropriate choice many small problems c worked well larger problems observed c c decays dramatically block size therefore probability 53 tol 2 defined 56 fulfilled decreases block length leads often especially bios situations maximal user specified block size reached investigations needed see problem solved better choice c 1 c 2 appropriate selection ff n inner case instead using 15 2 6 obtaining solution b far introduced various algorithms constructing sequence product vectors w l n provide basis km however goal solve linear system b describe accomplish algorithms several basic approaches constructing approximate solutions linear systems krylov space basis related galerkin method avoids difficulty arises galerkin solution exist difficulty causes example socalled pivot breakdown biconjugate gradient method approach natural generalization one lead unnormalized biores introduced 20 renamed consistent biores 25 contrast biomin biodir biores versions bicg method inconsistent biores variant endangered pivot breakdowns alternative would construct approximate solutions based quasiminimal residual qmr approach 16 combination approach ltpms refer reader 36 let doubly indexed sequence scalars ae l n given ae l define doubly indexed sequence product iterates x l n follows starting arbitrary x 0 n choose initial product vector w 0 0 ae 0 ae 0 1 product iterates implicitly defined ae l ae l n ae l n ae l course x l n constructed w l ae l follows 63 x l ae l n considered approximate solution corresponding residual w l ae l n order derive recursions scalars ae l n product iterates x l n introduce blocks theta x l theta x l theta ae l ae l theta ae l ae l well auxiliary product iterates x 0l auxiliary scalars ae 0l defined x 0l ae 0l b 63 41 64 ae 0l next using 42 conclude ae l aw l l aw l ae 0l ae 0l shows x l ae l ae 0l arrange product iterates x l n scalars ae l n two tables analogous wtable naxis pointing downwards laxis right two recursions used proceed vertical direction obtain recursions horizontal movement assume first polynomials given normalized threeterm recurrence 33 covers algorithms described paper except lookahead bios using 34 63 see product iterates satisfy scalars ae l n recursion ae l1 ae l ae valid since polynomials l normalized l l scalars ae l n change index l simply ae l ae 0 lookahead bios one horizontal movement explicitly computed per step namely substep 5 loop 43 based recurrence 413 define analogy 410 411 theta x 0nk theta x 0n theta ae 0n k ae 0l theta ae 0n ae x ae recurrences auxiliary iterates corresponding scalars given l ae 0l1 ae l using scaling parameter fl n 42 special choice ngamman 1m 1 also lanczos polynomials ae n could normalized ae n 1 ae l however mentioned fl n might turn zero would lead socalled pivot breakdown moreover avoid overflow underflow lanczos process scaling parameter fl n often used normalize lanczos vectors yn since lanczos vectors yn explicitly computed ltpm cannot base choice fl n norm however independent size blocks generated lookahead process always necessary compute product vectors w n n1 ltpm therefore chose fl n normalize w n n1 7 numerical examples section demonstrate practical performance lookahead versions ltpms numerical examples tests restricted biostab bioxmr2 bios lookahead versions ltpms denoted labiostab labioxmr2 labios respectively tests initial iterate x used iteration terminated norm recursive residual less square root roundoff unit test programs written fortran9095 run workstations 64bit ieee arithmetic start small artificially constructed model problems move gradually large realworld problems example 1 following small test example proposed joubert 29 also used brezinski redivozaglia 6 lanczos process hence biostab bioxmr2 bios without lookahead break step 2 contrary lookahead versions avoid breakdown converge 4 iterations shown plots true residual norms kb gamma ax l ae l n k figure 71 iteration number true residual labiosstab1e101e10 iteration number true residual labioxmr21e101e10 iteration number true residual labios fig 71 true residual norm history ie logkb gamma ax l ae l n vs n linear system defined 71 solved different ltpms lookahead example 2 second example taken 6 example 52 matrix order 400 righthand side imply solution lanczos process thus ltpms break first iteration lookahead versions perform two inner steps first second iteration following iterations regular steps typical behavior short lookahead steps therefore resulting mean overhead per iteration nearly negligible1e101e10 iteration number true residual fig 72 true residual norm history ie logkb gamma ax l ae l n vs n linear system defined 72 solved different ltpms lookahead table indices regular steps ltpms three problems pcyclic system matrix example labiostab labioxmr2 labios next set examples consider pcyclic matrices form hochbruck 27 showed computational work solving linear system pcyclic system matrix qmr lookahead reduced approximately factor 1p compared straightforward implementation using sparse matrixvector multiplications initial lanczos vectors one nonzero block conforming block structure inner vectors chosen nonzero structure destroyed blocks b k used generating possibly nonzero components krylov space basis proven cycle p steps least consecutive exact breakdowns p 2 using directly system matrix generate krylov subspace first cycle p steps consecutive exact breakdowns following cycles general longer persist must expected become nearbreakdowns therefore problems provide good test examples lookahead algorithms example 3 example consider 5cyclic matrix righthand side initial left lanczos vector choose entries convergence history different ltpms applied problem shown figure 73 indices regular steps listed table 71 found exactly predicted example 4 move bigger 4cyclic system matrix 100 theta 100 matrix random entries results problem shown figure 74 indices regular steps depicted also table 71 occur predicted example 5 finally consider 8cyclic system matrix b defined example 4 convergence history plotted figure 75 shows oscillations residual norm history labios overall labios needs one iteration step less labiostab labioxmr2 fulfill convergence condition methods lookahead criterion 53 tol 2 defined 56 used especially labios correct choice lookahead criterion seems crucial values c 1 c 2 breakdowns occurred expected discovered larger problem fig 73 true residual norm history ie logkb gamma ax l ae l n vs n linear system 5cyclic system matrix defined example 3 solved different ltpms lookahead fig 74 true residual norm history ie logkb gamma ax l ae l n vs n linear system 4cyclic system matrix defined example 4 solved different ltpms lookahead bios maximal user specified block length 10 reached often indicates constructed inner vectors become linear dependent therefore investigations needed figure better choice coefficient vector ff n inner case example following proposal 21 hochbruck used 27 chebyshev iteration generation inner vectors instead ff n adapted 15 example 6 last example take real world problem harwell fig 75 true residual norm history ie logkb gamma ax l ae l n vs n linear system 8cyclic system matrix defined example 5 solved different ltpms lookahead boeing sparse matrix collection namely sherman1 matrix order 1000 3750 nonzero entries righthand side b initial left lanczos vector e z 0 generated different unit vectors random entries without lookahead ltpms introduced break biostab step 186 biostab2 step 176 bioxmr2 step 145 bios step 352 contrary lookahead versions combination lookahead criterion 53 tol 2 defined converge shown figure 76 due real spectrum system matrix slight difference convergence labiostab labioxmr2 reported us bicgstab lookahead handle problem number mvs bicgstab lookahead 8 conclusions proposed lookahead versions various lanczos type product methods make use lanczos threeterm recurrences since based lanczos lookahead version gutknecht 23 freund et al 15 handle lookahead steps length avoid steps longer needed algorithms proposed work easy understand due introduction array product vectors symbolically displayed w table visualization progress wtable furthermore wtable proved useful tool derive optimal variants computational work terms mvs minimized variety numerical examples demonstrate practical performance proposed algorithms however larger problems indicate work directed finding improved lookahead criterion reliably avoids critical perturbations lanczos coefficients roundoff errors moreover one investigate better way constructing inner vectors choice adapted 15 alternatives would orthogonalize within block 2 construct chebyshev iteration 21 clear additional cost involved pays fig 76 true residual norm history ie logkb gamma ax l ae l n vs n realworld problem sherman1 matrix harwellboeing collection solved different ltpms lookahead lookahead process ltpm stabilizes primarily vertical movement wtable except bios algorithm wtable symmetric horizontal movement also important generate krylov space stably biostab2 bioxmr2 particular suitably modified reliably bicgstab since twodimensional steps offer flexibility also lasting positive effect roundoff vertical movement stabilize horizontal movement local minimal residual polynomial degree 1 adaptive choice bicgstab could used possibility adapt size h j current lanczos block would mean perform regular step h j dimensional local minimization residual alternative trade local residual minimization stable krylov space generation whenever former causes problem yet another possibility indicated section 42 combine lanczos process hybrid chebyshev iteration known finiteprecision arithmetic biores usually affected roundoff standard biomin version bicg least regard gap recursively explicitly computed residuals therefore process extend work lookahead procedures ltpms based coupled twoterm recurrences r avoiding lookahead lanczos method nonsymmetric lanczos finding orthogonal polynomials associated indefinite weights cgm whole class lanczostype solvers linear systems breakdowns computation orthogonal poly nomials new lookahead lanczostype algorithms linear systems avoiding breakdown cgs algorithm avoiding breakdown variants bicgstab algorithm quasiminimal residual variant bicgstab algorithm nonsymmetric systems working note 78 computational variants cgs bicgstab methods numerical determination fundamental modes transposefree quasiminimal residual algorithm nonhermitian linear systems implementation lookahead lanczos algorithm nonhermitian matrices qmr quasiminimal residual method nonhermitian linear systems matrix computations lookaround lanczos unsymmetric lanczos algorithms relations pade approx imation generalized conjugate gradient lanczos methods solution nonsymmetric systems linear equations iteration method solution eigenvalue problem linear differential integral operators tchebyshev iteration nonsymmetric linear systems reduction tridiagonal form minimal realizations scientific computing vector computers bicgstabl linear equations involving unsymmetric matrices complex spectrum maintaining convergence properties bicgstab methods finite precision arithmetic bicgstabl hybrid bicg methods analysis look ahead lanczos algorithm accelerating jacobi method solving simultaneous equations chebyshev extrapolation eigenvalues iteration matrix complex residual smoothing techniques iterative methods generalized biorthogonal bases tridiagonalisation matrices tr
sage graphics architecture scalable advanced graphics environment sage new highend multichip rendering architecture single sage board render excess 80 million fully lit textured antialiased triangles per second sage brings high quality antialiasing filters video rate hardware first time achieve concept frame buffer replaced fully doublebuffered sample buffer 1 16 nonuniformly placed samples per final output pixel video output raster samples subject convolution 5x5 programmable reconstruction bandpass filter replaces traditional ramdac reconstruction filter processes 400 samples per output pixel supports radially symmetric filter including negative lobes full mitchellnetravali filter sage board comprises four parallel rendering subunits supports two video output channels multiple sage systems tiled together support even higher fill rates resolutions performance b overview sages block diagram seen figure 1 diagram expanded external buses internal fifos internal multiplexers loadbalancing switches overall data flow required sorting may easily seen system level sages interchip connections typically unidirectional point topoint sourcesynchronous digital interconnects top half sages diagram fairly similar sortlast architectures command load balancing performed across parallel transform rasterize blocks followed sortlast tree sched chips interfacing frame buffer sage however frame buffer replaced sample buffer containing 20 million samples output side sample buffer sage introduces entirely new graphics hardware pipeline stage replaces ramdac sample tree followed parallel convolve chips apply 55 programmable reconstruction bandpass filter rasters sam ples convolve chip responsible antialiasing separate vertical column screen finished pixels emitted convolves video raster order 32 command distribution top pipeline master chip performs dma host fetch opengl command graphics data streams dma engine bidirectional contains mmu application data reside anywhere virtual memory locking application data regions necessary geometric primitives streams vertex data distributed loadbalanced way four parallel render pipelines 33 rendering transform lighting setup rasterization render pipeline consists two custom chips plus several memory chips first custom chip majc multiprocessor tremblay et al 2000 second rasterize chip performs setup rasterization textured drawing many previous architectures sortmiddle following taxonomy molnar et al 1994 parallel transform lighting setup pipelines recombine streams oneprimitive atatime distributed drawing stage architecting sage certain bandwidth advantages motivated choice sortlast architec ture average pixel size application triangles shrinks size setup data becomes larger actual sample data triangle also improves efficiency allowing rasterization chip generate samples triangle rather fraction occurs interleaved rasterization majc chip contains specialized vertex data handling circuits support two fully programmable vliw cpus cpus programmed implement classic graphics pipeline stages trans form clip check clipping face determination lighting geometric primitive setup operations special vertex data circuitry handles vertex strip mesh connectivity data cpus see streams nonredundant vertex data time thus redundant lighting computations avoided vertex reuse asymptotically reduce required vertex processing operations 12 vertex per triangle processed vertex mesh formats used support sample buffer programmable nonuniform sample positions hardware fill algorithms must extended beyond simple scanline interpolation generalizations plane equation evaluation needed ensure correctly sampled renderings geometric primitives furthermore sample fill rate run 8 times faster rasterize fill nonsupersampled machine keep aggregate equivalent commodity dram bandwidth sages eight 3dram memory interleaves excess 80 gigabytes per second rasterize chip rasterizes textured triangles lines dots sample buffer current sample density also performs imaging functions traditional rasterop window operations majc rasterization pipeline render 20 million lit textured supersampled triangles per second rasterizer chip dedicated 256 megabytes texture memory supports 256 megabytes user texture memory four times bandwidth single pipe one gigabyte texture memory applications use opengl targeted texture extension common case volume visualization ap plications textured triangles rasterize chip first determines pixels touched even fractionally triangle applies layers mipmapped optionally anisotropic filtered texturing pixel determines irregular sample positions within triangle interpolates color z alpha channel data sample point output stream sample rgbaz packets screen pixel xy address sample index implying sam ples subpixel location within pixel rasterize chip two external output buses first stage routing sample data sample memory performed samples leave rasterize chip 34 sortlast rasterize chips lies network comprising two sched chips route samples produced rasterize outputs pixel interleave sample buffer samples arrive sched chip input fifo rasterize chips routed appropriate second stage fifo based destination memory interleave output second stage fifo controlled load balancing switch memory interleave switch acts like traffic light busy intersection traffic one source allowed flow unimpeded time sources blocked programmable hysteresis flow host dma bus master dram mcode majc dram mcode majc dram mcode majc dram mcode dram dram dram dram texture rasterize texture rasterize texture rasterize texture majc rasterize sched sched buffer route convolve 6 swath line buffer convolve 6 swath line buffer convolve 6 swath line buffer convolve 6 swath line buffer figure 1 sage block diagram thick boxes custom chips red boxes fifos green circles load balancing switches sample data different rasterize chips ensures good cache locality within 3dram memories third layer fifos sched chip final sample prewrite queue front single memory interleave interleave group 4 3dram chips connected prewrite queue sched chips snoop queue perform 3dram cache prefetches scheduling sample writes sample buffer parallel rasterized sample streams merge together sched chip also place special control tokens enforce various renderorder constraints example algorithms make use stencil buffer require least two passesone prepare stencil buffer special pattern another pass sample writes conditionally enabled presence special stencil pattern clearly stencil writes first pass must complete second pass sample writes allowed go forward given interleave given sched chip encounters special synchronization token marking hard ordering constraint eg boundary two passes samples rasterizer processed three rasterizer inputs also encountered stopped synchronization token occurs samples generated primitives entered sage system synchronization token processed first pass example okay allow pending samples entered system synchronizing token proceed opengl driver knows generate ordering token unordered rendering mode sees command transition ordered rendering mode immediately followed command change back unordered rendering mode complex situations supported complex special token generation driver controllers 3dram chips sched chips also respond requests convolve chips streams samples sent 3dram video output pins parallel convolve chips generate video output 35 sample buffer sample buffer consists 32 3dram chips organized eight independent interleaves four chips input side four 3drams share single set control address data lines one four sets memory interleave pins sched chip output side 3dram outputs 40bit samples double pumping 20 video output pins pins individual wire route chip total 640 wires entering lower route network logically sample buffer organized two dimensional raster lists samples lists length pixels screen number samples listorder sample implies subpixel location rasterize convolve chips contain identical samplelocation tables accessed sample index space allocated within sample buffer subpixel location sample memories interleaved persample adjacent samples list different 3dram packages unlike firstgeneration 3dram components new 3drams used sage contain internal 21 multiplexer driven sam ples window id samplebysample doublebuffering occurs inside 3dram chip thus final rgb alphawindow control bits emerge 40bitpersample output packet size sample buffer enough support 12801024 doublebuffered samples z sample density 8 19201200 sample density 4 high sample densities require correspondingly high render bandwidth sample buffer achieved new generation 3dram deering et al 1994 3dram performs zbuffer compare alpha buffer blending internally traditional zbuffer readmodifywrite operation simplified operation important operation clearing sample buffer new frame rendering also potentially adversely affected high sample density greatly accelerated 3dram chips initializing samples 1280x1024x8 sample raster takes less 200 usec less 2 76hz frame time 36 sample raster delivery 640 outputs sample buffer feed array 10 route chips route chip 2bit slice router function route chip connects 2 output data pins 32 3drams redirect data four convolve chips attached need convolve chips fed contiguous vertical swath pixel interleaved sample buffer samples read sample buffers quarter scan line wide one pixel high bursts directed one four convolve chips details discussed convolve section job route chip absorb bursts internal fifos dribble back destination convolve chip 37 convolution clut video timing finally four convolve chips perform reconstruction band limiting filtering raster stream samples producing pixels fed next convolve chip final video output convolve chips replace digital portion ram dac contain color lookup gamma tables well video timing generator cursor logic genlock interface convolve chips contain da converters instead convolve video outputs digital support various existing emerging digital video interfaces two high quality external da converters svideo interface sage video daughter board support analog video devices traditional graphics hardware taxonomy refers section display however renderman term imaging pipeline may accurate description new functionality next several sections describe convolution processing detail starting discussion previous attempts implement video rate antialiasing 4 convolution introduction decade users batch photorealistic rendering software able obtain high quality antialiased imag ery usually means various supersampling algorithms ever realtime hardware systems cost constraints precluded deployment simplistic approximations algorithms fill rate limitations make realtime generation enough samples challenging restrictions hardware polygon fill algorithms preclude subpixel spatially variant sampling memory costs bandwidth limits prohibited use doublebuffered supersampled frame buffers finally computational cost realtime antialiasing reconstruction filters limited hardware implementations box tent filters inferior software reconstruction filters various alternatives stochastic supersampling tried years attempts avoid high hardware costs date attempts limited generality rendering seen much use realtime generalpurpose graphics hardware systems use confined applications whose structure could adequately constrained flight simulation video games nonuniform supersampling approach taken number rendering effects performed applications use multipass algorithms user programmable sample mask patterns include motion blur depth field anisotropic texture filtering subject supported sample densities paper directly address features rather focuses basic backend architecture required support filtered supersampled buffers 51 previous work software antialiasing rich detailed history mainstream approach recent years evaluate image function multiple irregularly spaced sample points per pixel followed applying reconstruction filter resampling lowpass filter originally referred stochastic supersampling basic idea trade visually annoying aliasing artifacts jaggies less visually perceptible noise glassner 1995 contains excellent survey discussion many variants approach implemented years pioneering commercial software implementation approach pixars photorealistic renderman cook et al 1987upstill 1990 previous work hardware 52 flight simulators backtofront sortingbased algorithms realtime antialiasing requirement flight simulation hardware several decades however early work field took advantage known scene structure usually ability constrain rendering primitives backtofront algorithms scale well average scene complexity grows hundred millions polygons per frame 53 percentage coverage algorithms systems example akeley 1993winner et al 1997 employed polygon antialiasing algorithms based storing extra information per pixel polygon fragments cover fractions pixel principle algorithms class produce higher quality results even supersampling techniques exact area contribution polygon fragment final visible pixel known practice hardware systems afford maintain limited amount shape information limited number polygon fragments within pixel scenes consisting small numbers large polygons polygons much greater area pixel vast majority pixels either completely covered one two poly gons occlusion edges silhouettes would jaggies removed care even corner cases two polygons one continuous surface land within one pixel often merged back single polygon case however todays typical polygon shrinking towards micro polygon algorithms rapidly become confused causing unacceptable visible artifacts 54 multipass stochastic accumulation buffers first attempted support general full scene antialiasing independent render order nearrealtime hardware multipass stochastic accumulation buffer deering et al 1988haeberli akeley 1990 approach render scene multiple times different subpixel initial screen offsets combine samples incremental filter accumulation buffer final display however multiple passes overhead filtering image copying reduced performance systems order magnitude still adding substantial cost deeper pixel accumulation buffer result technique supported multiple vendors never found much use interactive applications also subpixel sample positions correlate pix els final quality match software systems supersampling architectures implemented subsets general supersampling antialiasing algorithm akeley 1993 montrym et al 1997 implement one eight sampleperpixel rendering singlebuffered sample buffer sample rendering complete samples within pixel averaged together transferred output pixel buffer video display combined reconstruction lowpass filter thus 11 box filter require multiplies 1x1 region support also eliminates need neighboring pixels communicate filtering quality match batch software renderers results appreciably better supersampling proven good enough used flight simulation virtual set applications among others eyles al 1997 implemented supersampled rendering 11 weighted filter lower end simple processing antialiasing beginning show game chips tarolli et al 1999 appears implementation 22 single buffered supersampled buffer clear box filtering supported nvidia geforce3 supports sample densities either 2 4 either 11 box filter 33 tent filter domin 2001 resultant quality better antialiasing still far quality batch photorealism software frame rates however suffer almost linearly proportion sample density opengl 13 specification contain support supersam pling context applying filtering render buffer display buffer swap 6 sage supersampling issues 61 programmable nonuniform sample pattern important component highquality supersampling based antialiasing algorithms use carefully controlled sample patterns locally periodic todays best patterns constrained random perturbations uniform grids software algorithms afford luxury caching tens thousands pixel area worth precomputed sample patterns onchip hardware much severely space constrained sage supports pattern ram 64 2x2 pixels x 16 samples 6bit x 6bit subpixel offset en tries however effective nonrepeating size pattern extended 128x128 pixels use 2d hardware hash function permutes access pattern entries effectiveness hash function seen figure 5 large colored dot corresponds sample table small easily changeable realtime framebyframe basis supporting temporal perturbation sample pattern note sage system sample tables frame currently displayed stored convolve chips sample tables frame currently rendered stored rasterizer chips tables static system software must ensure updated appropriate time boundaries 7 convolve chip architecture details one primary ways architecture differs previous systems attempt compute antialiased pixels render side frame buffer far sample buffer concerned output display device capable displaying supersamples back end reconstruction filter pipeline convert streams supersamples antialiased pixels fly full highresolution video rates peak data rates required support impressive frame buffer output 16 billion samples per second approximately 8 gigabytes per second data realtime highquality filtering much data beyond capabilities todays silicon single chip thus find way spread convolution processing firehose data across multiple chips seen figure 1 convolution pipeline split four chips chip assigned different vertical swath screens samples reconstruction filters 55 supported vertical swaths must overlap horizontal neighbors 2 pixels half filter width final video stream assembled video passed chip chip chip inserts portion scan line aggregate stream last chip delivers complete video stream optional second video stream also emerges last chip 55 filter size also implies sample potentially used 25 different pixel computations avoid refetching samples offchip 6 swathlines worth sample data cached convolve chip ram consumes half active area chip internal architecture chip shown figure 2 video generation process chip starts generation raster convolution center output pixel center locations across swath convolution center location moves sample data transferred swathline buffers 55 filter processor array schematic filter processor shown figure 3 filter processor responsible samples one pixel sample buffer 55 array access samples may contribute single output pixel filter processor computes contribution samples total convolution partial results 25 filter processors summed form unnormalized convolution result nonuniform nonlocally repeating properties good sample patterns feasible cache precomputed convolution filter coefficients instead filter processor contains circuitry dynamically computing cus kernely kernelx sample pattern 5x5 region sample adr hash funct convolution center raster location generation sumcoeff 1sumcoeff filter processor array rgba swap rgba 1video video figure 2 convolution chip architecture color 6 swathline buffer timingrgba coeff inverse filter 2 find 1st r h er kernely range check figure 3 filter processor detailx 14 filter filter coeff icient sumcoeff tom filter coefficients arbitrary sample locations also contains multiplieraccumulator actually weights samples filter coefficient computation proceeds follows first sample location relative convolution center computed subtracting sample xy location generated sample pattern ram convolution center xy location squaring summing delta xy components results squared radial distance sample location convolution center squared distance scaled square inverse filter radius results greater unity force zero filter coefficient next squared distance encoded 3bit exponent 5bit mantissa 1 hidden bit floatingpoint representation 8bit floatingpoint number used index ram table squared distance vs filter coefficients numeric linearity point view squaring floatingpoint encoding nearly cancel resulting accurate relatively equallyspaced filter coefficients seen plot synthesized filter values vs distance figure 4 filter coefficient output table signed 14bit floatingpoint number used weight rgba sample values multiplied result converted back 27bit fixedpoint number directed set summing trees separate running sum applied filter coefficients similarly calculated thus hardware places two restrictions reconstruction filter must radially symmetric convolution space filter radial cross section quantized 256 values note nonuniform video andor screen space scalings elliptical filters physical display space supported separable filters theoretical advantages radial filters radial filtering less complex implement hardware technically filter weighted average filter handle filter normalization perform floatingpoint reciprocal operation sum filter coefficients normalizing multiply r g b unexpected advantage using dynamic normalization simulations error compared exact solution came well expectations slight errors coefficient generation produce similar bias normalization value mostly canceled remaining numeric errors coefficient generation less perceptual effect equivalent correct coefficient incorrect estimation sample distance center filter error sample position samples quite representative true underlying image vicinity visible errors antialiased output due sample missing significant change underlying image eg black white contribution image output errors due errors computing filter coefficient values quite small comparison hyperaccurate filtering preserve quantization present original samples sometimes called contouring mitigate con touring dither 12bit rgba samples computed rendering 10bit rgba values actually stored sample buffer con 13 13 mitchellnetravali filter filter weight barely visible jaggies curve quantization errors filter radius 10 20 figure 4 numerical accuracy filter representation volution reconstruction dithered sample values effectively reverses dithering achieving 12 bits accuracy per rgba component 71 video outputs two simultaneous potentially asynchronous video rasters generated parallel partitioning four convolve chips two subsets video streams emerge digital video ports last convolve chip swap circuit shown figure allows convolve chip add results either incoming streams pass unmodified also postprocessing swap shown one use second channel able read antialiased image back computer outer ring bus shown figure 1 without option host computer would way get copy antialiased image useful performing antialiased rendering intended later reuse reflection maps etc convolve video timing circuit run either sync master sync slave genlocked external sync source two video streams subregions window system rendering system think single display useful tiling two lowerresolution projectorsdisplays alternatively two video sources two separate potentially asynchronous image regions potentially different sample densities 72 video resizing key benefit sage architecture video resolution determined convolution hardware rendering hardware thus hardware used antialiasing also provides extremely high quality video rescaler better filtering quality possible external scaler operates original samples pixels sage correctly performs filtering linear light space one use generate ntsc video arbitrary zoomed panned subregions higher resolution display might used document software program important use systems realtime guarantees conserve fill rate actual size image rendered dynamically reduced interpolated back fixed video output size flight simulator using 12801024 video format might actually rendering 960768 load gets heavy saving nearly half fill time system described montrym et al 1997 also supports dynamic video resizing uses simple tent filter performs filtering nonlinear postgamma light space 73 fully antialiased alpha channel sages sample filtering algorithm operates rgb channels also stored doublebuffered alpha enabled example virtual set applications means sage automatically generates high quality soft key signal blending antialiased edges virtual objects front physical objects well blending variably transparent rendered objects front physical objects programmable choice reconstruction filters left end user general found mitchellnetravali family cubic filters mitchell netravali 1988 used high quality software renderers work well hard ware choice reconstruction filter subjective compo nent users prefer smoother filters banish jaggies expense slight blurring image users desire filter preserves sharpness risk artifacts also displaydevicespecific aspect choice reconstruction fil ter get close enduser look crt vs flat panel lcd display slightly different filters needed general use exotic filters used help simulate appearance special imaging devices 81 effects negative lobes one prices must paid use high quality reconstruction filters occasional artifacts ringing fringing due presence negative lobes filter hardware clamps negative color components zero also keeps histogram frequency extent occurrences histogram data used dynamically reduce negative lobes reconstruction filter artifacts severe 9 legacy compatibility issues several legacy compatibility issues sage must address many handled properties associated window id tags part sample one example support applications programmed assuming nonlinear light space andor pseudo color space nonlinear light space typically particular gamma space sage supports applications providing pseudo color direct color nonlinear true color luts specified window id properties samples sage luts applied samples convolution course 3d rendering performed linear light space bypass preconvolve luts preprocessing ensures sample inputs antialiasing convolution process linear light space convolution process generates linear light space pixels pixels converted proper nonlinear light space eg gamma cor rection particular display device attached system pixels antialiased proper emulation 2d window system rendering legacy applications require accurate emulation jaggies solution disable filtering pixels via special property window id tag pixels windows instead tagged sample typical ly one closest convolution center chosen output place convolution result thus possible screen simultaneously support antialiased nonantialiased windows filter 55 extent care must taken ensure unfiltered pixels contribute samples nearby filtered pixels case example nonantialiased window occludes antialiased window dynamic filter normalization circuit comes rescue simply dont apply filter coefficients aliased pixels within 55 window antialiased pixel still get unit volume ker nel approach also used eliminate artifacts visible video border place traditional approach adding extra nonvisible strip 2 pixels around full screen legacy issues include proper support traditional antialiased lines also subject supersampling filtering goal allow much possible existing applications move full scene antialiased operation minimal source code changes 101 images figure 5 image sage debugging simulator shows details sampling pattern sample density dering intensity dot corresponds computed sample value rgb green lines triangle tesselation boundaries faint red grid lines pixel boundaries 11 triangles shown 12segment radius3 pie wedge one slice missing sages native output environment display next set images digital photos functional sage hardware driving crt screen figures 6 10 shots portion 12801024 crt display shows portion object honeybee differences sample count reconstruction filter figure 6 shows one uniformly spaced sample per pixel reconstruction filtering figures 7 10 rendered using sample density 8 figures 7 10 use 44 mitchellnetravali 13 13 filter figure 4 figure 8 uses diameter 4 cylinder filter shows considerable blur figure 9 uses laplacian filter shows enhanced edges figure 10 wider approximately 800800 pixel shot bee 102 comparison renderman sages development pixars photorealistic renderman used verify quality antialiasing algo rithms custom renderman shaders written mimic different lighting algorithms employed scene descriptions camera parameters sampling rates reconstruction filters used generate images renderers resulting images cannot expected numerically identical every pixel primarily different sample patterns used well different numeric accuracies employed prman uses full 32bit ieee floatingpoint arithmetic internally control also ran prman sample density 256 numerically comparing hardware 16 sample rendering prman fewer 1 pixels differed value 6 contribution single sample however variance seen 16sample 256 sample prman images explains visual results general expert observers could determine image rendered system 103 data rates computational requirements doublebuffered sample buffer supporting 8 supersampled 12801024 imagery requires storage 20 million samples approximately eighth gigabyte including singlebuffered z 76 hz video display overheads fragmentation effects designed peak video output bandwidth 16 billion samples per second 8 gigabytes per second note render fill data rate several times larger support interesting depth complexity scenes full frame rates a55 filter sample density 4 requires 2544 floatingpoint multiplyadds per output pixel 800 operations per pixel similar number operations needed generate filter coefficients per pixel peak video output rates 250 mhz total operation count per second exceeds 04 teraflops numbers generated specialized hardware important note much greater number flops consumed general purpose computers running equivalent software antialiasing algorithms equivalent work 104 scalable sage chip set designed scale performance two chip rendering subsystem parallel pipeline rendering system combinatorial variations chip configurations allowed sage architecture described paper first implementation sage chipset based system addition current sage board necessary hooks scaled computer system level support even higher fill rates reso lutions performance include ability function sync slave synchronization signals stereo frame parity render buffer flip well special features enabled architecture sage convolve chip sage unique respect one also tile multiple commodity pc solutions together sage one starts much powerful building block high geometry fill rates large texture stores already performs high quality supersampled antialiasing sage complex multichip machine details textured render ing lighting picking texture readback context switching etc reimplemented sage often somewhat differently done short paper chose focus major effects antialiasing algorithm architecture detract areas 3d graphics hardware implementers pushed envelope well complete sage prototype hardware running opengl rendering full scene antialiasing arbitrary filters described paper board shown figure 11 13 conclusions new high end architecture implementation 3d graphics rendering sage described performance goal 80 million lit textured antialiased triangles per second met also achieved goal producing hardware antialiasing system whose images numerically perceptually indistinguishable images generated antialiasing portion leading software renderers achieved use hardware doublebuffered sample buffer onthefly videoout spatial filtering capable implementing nonuniform supersampling cubic reconstruction filters acknowledgements thanks dean stanton dan rice programming proofread ing photo composition thanks clayton castle help video recording thanks entire sage development team without sage would possible r realityengine graphics course notes cs448a triangle processor normal vector shader vlsi system high performance graphics fbram new form memory optimized 3d graphics principles digital image synthesis accumulation buffer hardware support highquality rendering reconstruction filters computer graphics sorting classification parallel rendering majc architecture renderman companion hardware accelerated rendering antialiasing using modified abuffer algorithm figure 5 sample pattern density 16 figure 6 bee figure 7 bee figure 8 bee figure 9 bee figure 11 photo prototype sage board tr reyes image rendering architecture accumulation buffer hardware support highquality rendering reality engine graphics sorting classification parallel rendering pixelflow infinitereality hardware accelerated rendering antialiasing using modified abuffer algorithm triangle processor normal vector shader reconstruction filters computergraphics principles digital image synthesis majc architecture ctr david zhang mohamed kamel george baciu introduction integrated image graphics technologies kluwer academic publishers norwell 2004 whitted j kajiya fully procedural graphics proceedings acm siggrapheurographics conference graphics hardware july 3031 2005 los angeles california philippe beaudoin pierre poulin compressed multisampling efficient hardware edge antialiasing proceedings 2004 conference graphics interface p169176 may 1719 2004 london ontario canada woolley david luebke benjamin watson abhinav dayal interruptible rendering proceedings symposium interactive 3d graphics april 2730 2003 monterey california gregory johnson juhyun lee christopher burns william r mark irregular zbuffer hardware acceleration irregular data structures acm transactions graphics tog v24 n4 p14621482 october 2005 timo aila ville miettinen petri nordlund delay streams graphics hardware acm transactions graphics tog v22 n3 july acm transactions graphics tog v25 n2 p375411 april 2006
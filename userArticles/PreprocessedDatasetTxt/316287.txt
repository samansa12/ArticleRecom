domainspecific language regular sets strings trees abstractwe propose new highlevel programming notation called fido designed concisely express regular sets strings trees particular viewed domainspecific language expression finitestate automata large alphabets sometimes astronomical size fido based combination mathematical logic programming language concepts combination shares similarities usual logic programming languages fido compiles finitestate string tree automata concept runtimeit already applied variety problems considerable complexity practical interest present paper motivate need language like fido discuss design implementation also briefly discuss design criteria domainspecific languages learned work fido show recursive data types unification implicit coercions subtyping merged variation predicate logic called monadic secondorder logic m2l trees fido translated first pure m2l via suitable encodings finally finitestate automata mona tool b introduction finitestate problems everywhere embedded many layers software systems often difficult extract solve computationally basic observation motivation work presented paper recent research us colleagues exploited monadic secondorder logic m2l finite strings trees solve interesting challenging problems case results obtained identifying inherent regularity problem domain thus reducing problem questions regular string tree languages successful applications today include verification concurrent systems 9 8 hardware verification 2 software engineering 10 pointer verification 7 work progress involves graphical user interface regular expressions extended m2l document logics www role m2l approach provide extraordinarily succinct notation complicated regular sets applications demonstrated notation essence used describe properties finite state automata regular ex pressions grammars would tend cum bersome voluminous removed users intuition hardly surprising since m2l variation predicate logic thus natural use also known nonelementarily succinct notations mentioned thus formulas m2l describe regular sets size corresponding dfa compared size formula bounded finite stack exponentials flip side impressive succinctness m2l correspondingly nonelementary lower bound decision procedure surprisingly mona implementation m2l 5 handle nontrivial formulas large 500000 charac ters due part application bdd techniques 4 specialized algorithms finitestate automata 3 careful tuning implementation 11 also turns intermediate automata generated even resulting subset constructions usually big compared automata representing properties reasoned successful applications m2l mona reside common productive niche require specification regular sets complicated describe means complicated infeasible tools basic m2l formalism simple quite intuitive early experience quickly indicated formalism practice suffers primitive domain discourse bitlabeled strings trees fact m2l specifications uncomfortably similar assembly code programs focus explicit manipulations bit patterns m2l interpreted trees situation even worse since theory two successors far less familiar intuitive linear sublogic similarly early experiences machine lan guages found m2l programmers spent time debugging cumbersome encodings contributions paper propose domainspecific programming formalism fido combines mathematical logic recursive data types believe new ways suggest following four kinds values finite domains recursive data values labeled finite domains positions recursive data values subsets positions show many common programming language concepts like sub typing coercions unification make sense underlying semantics based assigning automaton store transformer expressions semantic property allows us view compilation process calculations values deterministic finitestate automata expression evaluator calculates numbers arrive result automata primitive objects subjected operations reflecting semantics language view quite different method behind statemachine formalisms used verification promela language 6 language resembling general purpose language expresses single finitestate machine whose state space transition system constructed piecemeal calculations explore state space view however similar uses regular expressions text matching except implemented algorithms avoid construction deterministic automata fido implemented provides along supporting tools optimizing compiler m2l mulas used several reallife applications also source biggest formulas yet handled mona article motivate explain fido particular discuss type system compilation techniques also give several examples taken articles already published used fido without explaining origin design technical considerations concerning relationship data structures tree automaton representation 3 compilation process explained elsewhere 2 m2l mona basic m2l simple syntax seman tics formulas interpreted binary tree string labeled bit patterns determining values free variables firstorder terms denote positions tree include firstorder variables p successors t0 t1 secondorder terms denote sets positions ie monadic predi cates include secondorder variables p empty set unions 1 basic predicates set membership set inclusion 1 logic permits usual connectives first secondorder quantifiers convention leaf position p p1 sublogic strings uses 0successor mona tool accepts formulas suitable ascii syntax produces minimum dfa accepts trees satisfying given formula thus satisfiability formula equivalent non emptyness derived automaton validity equivalent totality values free variables formula encoded alphabet automaton thus formula yields alphabet sigma size 2 32 internal representation automata transition function shared multiterminal sigmabdd bdd techniques mona tool processed formulas hundreds thousands characters minutes 3 motivation small example motivate need highlevel notation assume wish use mona prove following hard theorem every string ab c eventually followed c state theorem m2l must first choose encoding labels b c purpose introduce two free secondorder variables labels encoded according following arbitrary schema position p label corresponds bit pattern 00 similarly assign b bit pattern 01 c pattern 10 property eventually followed c becomes formula regular expression ab c similar way encoded formula theorem formally stated implication oe mona tool readily verify formula m2l tautology thus proving theorem reason m2l specifications much voluminous promised apparent significant overhead encodings automatic checks consistent use bit patterns support encodings usually supplied type system m2l strings regular sets immediately suggest notions types quite common m2l formulas implicational form oe oe formula restricting strings coarse regular set provides intricate restrictions thus highlevel version formula could look like string x ab c keywords string pos intended declare free variables two kinds formula read positions p string x p label exists position q also x p q q label c main formula almost mona version proper use labels supported compiler verified type checker m2l interpreted trees however intuitive analogue regular expressions programming languages know intuitive successful formalism specifying coarse regular sets trees recursive data types thus adopt wellknown trusted programming concept highlevel notation using idea may prove theorem follows string x arbitrary recursive data types may course expressed directly formulas translation voluminous best performed automatically translation also solves problem mona decision procedure works formulas whose domain discourse binary trees whereas values recursive data types trees varying number branches solution rather technical since involves bending recursive data type value shape binary branching tree note regular tree sets captured recursive data types consider binary trees nodes colored red green blue subset trees one node colored blue recursive data type however easily captured following fido specification tree x rgb certainly advanced complicated notions data types could similarly adopted 1 ever fido philosophy rely heavily standard programming language concepts describe complex structures operations ambition idioms merged seamlessly logical concepts describe complex properties structures general allow finite domains name fido derives values nodes finite domains constructed conjunctively disjunctively enumerated scalar types thus alphabets tree automata reading recursive data types easily become large 4 design paper intended proper language report explain interesting unusual concepts fido notation provides domains data types finite domains constructed simple scalar lists freely combined product operator union operator j union two finite domains formed required disjoint thus define domains value domain state may written stateab2 complicated definitions obtain values ea1a2b3a2b1 mulas finite domain values may unified using syntax statepcar ps r unification variables recursive data types quite ordinary except constructors generalized single names finite domains finite domains could course encoded nonrecursive data types chosen separate concept several reasons first distinction trees labels seems intuitive many applications second allow operations finite domains trees example introduction unification concatenation trees would yield undecidable formal ism third translation automata finite domains encoded bdds whereas trees encoded state space often necessary programmer control choice example linear data type sequences state values terminated node labeled done nonlinear example denoting binary trees notation 110 abbreviates corresponding 10 scalars variables four kinds variables fido introduce examples domain variable ranges states may declared dom state tree variables recursive data type variables x may declared tree xy tree variable defines space positions thus position x cannot used denote node declare position variable may denote positions either x write pos p x value variable points node either x case node pointed either red black similarly set variable containing positions union xs ys position spaces may declared set x quantification variables quantified example formula computation contains loop may involve quantification strings trees finite domains positions 9string x comp 9dom state 9pos pq xpq ps qs types type may one four different kinds pos set dom tree pos kind corresponds firstorder terms ie positions trees set kind similarly encompasses secondorder terms dom kind new compared m2l describes values finite domains finally tree kind extension captures entire trees values within kind type refined set tree names set data type names example type posfxygfrstg denotes positions nodes either tree x roots subtrees one data types r refined types prove convenient restricting free variables model expressing relativized quantifications furthermore type structure proves crucial optimizations implementation type rules impose restrictions operators language generally rules boil trivial statements finite sets example terms types setx type setx 1 also term type posxd term pn type tn data type reached along nsuccessor formulas decided purely basis type system example p type type setx static decisions exploited fido compiler notational conveniences formal notation tendency become quagmire details design fido attacked problem three different ways first often convenient implicitly coerce values different kinds expressed simple subtype structure two types related subtype following finite order tree set dom pos posset root read order relations decorated coercions functions posset computes set positions tree root finds root positions tree read computes label position subtype structure exploited automatically insert coer cions note subtype structure clearly semantically coherent coercions unique 12 added coercion singleton pos set semantic coherence would fail second allow implicit casts finite mains example definitions allow values domains fruit root used directly values domain veg etable even though strictly speaking expressed eg castfruitapplevegetable third allow sensible defaults whenever possible thus name unambiguously determined specific meaning formal qualifiers may dismissed example name orange used scalar domain fruit constant fruitorange may written simply orange specific example techniques consider previous theorem already used number syntactic conveniences specification compiler inserts necessary coercions reconstruct explicit code 9pos qxtpq readqtc somewhat harder read reallife 12page formula 400 pedantic corrections automatically performed decompilers compiler writer must also consider need decompilers case fido mona specifications translated primitive logic fine want decide valid ity however mona also ability generate counterexamples invalid formulas mona counterexample make little sense fido programmer since completely different structure riddled bit patterns consequently fido system provides decompiler lifts counterexamples highlevel syntax another use mona illustrated following section generate specific automata application fido provides different decompiler expresses automaton particular kind attribute grammar level recursive data types 5 examples provide examples illustrating benefits fido notation include applications aim synthesize automata well aim verify properties case present toy example detail sketch large previously published application similar nature synthesis following example considers fragment html syntax syntactically correct html specifications allowed example document never contain anchor within another anchor confuse reader constraint could incorporated contextfree syntax would essentially double number nonterminals however easily capture html parse trees values recursive data type trees express logical formula restriction wish impose anchoru url html j paragraph j rule j listl list follows transition html j anchor 00 7 1 means node anchor two subtrees synthesizes attribute value 0 synthesize attribute value 1 simple ideas exploited collaboration ericsson telecommunications company formalize constraints design architectures 10 verification two specifications say distributed systems compared means implication bi implication connective consider simpleminded mutual exclusion protocol two processes shared memory turn integer range 12 task body proc1 begin loop b loop exit turn 2 task body proc2 begin loop b loop exit c criticalsection2 turn loop fido specification models valid interleaved computations simply asks whether safety property holds string ff computation let dom pc pc dom r turn apcr 7 bpcr j validstring x computation formula 8pos p x pnext6done let dom st state ps pnextt transst mutexstring x computation formula 8pos p xp6cc formula transst end denotes binary relation state domain values hold pairs values simultaneously match one listed cases corresponding raw mona formula looks like p q g0 q notin posp s1 s1p c posp s2 posp s3 posp s4 s0r pos41 s0 s0pc posp s3 posp s4 s0r pos41 osp s0 s0pc posp s1 s1pc posp pos41 s0 s0pc s1t s1pc pos41 s2 posp s3 posp s4 pos41 s0 pos41 s3 pos41 s4 posp s0 posp pos41 s3 pos41 s4 s0r pos p s0 posp s1 posp s2 s0pc posp s3 s1pc posp s4 s0r posp s0 s1s posp s2 s0pc pos pos41 s1 pos41 s2 s0pc pos41 pos41 s1 pos41 s2 s0pc pos41 s3 pos41 s1 pos41 s2 s0pc pos41 since simplistic mutual exclusion protocol clearly correct formula tautology ever mistakenly tried verify proc2 could never enter critical region mutexstring x computation formula 8pos p xp6c fido would generate counterexample computationba1 computationbb1 computationcb1 computationdb1 computationab2 computationac2 computationdone exactly describes computation realistic examples internal events projected away means existential quanti fier 8 detailed account given application fido language verification problem posed broy lamport 1994 distributed systems described interval logic easily defined fido evolution system finite segment time modeled recursive linear data type constructor define current event thus position variables instants thousands events possible distributed systems compared described types type property verified requires 12 pages fido specification translates m2l formula size 500000 characters entirely different use fido allows us verify many properties pascal programs use pointers 7 encoding store string using fido formulas describe effects program statements automatically verify desirable properties example following pro gram performs insitu reversal linked list colored elements program case tag color var xyp list begin xnil pxnext xp end system automatically verify resulting structure still linked list conforming type list also verify pointer errors occurred dangling references unclaimed memory cells however cannot verify resulting list contains colors reversed order still partial verification clearly serve finely masked filter many common programming errors pascal tool adds another level compila tion simple pascal programs fido specifications m2l formulas finally finitestate automata accepting encodings initial stores counterexamples program pages fido specification expands 60000 character m2l formula resulting automaton course tiny since counterexamples largest intermediate result 74 states 297 bddnodes direct translation mona would essentially add complexities fido compiler implementation pascal tool 6 implementation implemented parsing symbol analysis type checking entirely standard ways nonstandard every subterm compiled tree automaton intermediate representation m2l formula thus resource allocation becomes question managing bit pattern encodings domain values expressed m2l formulas strived achieve parsimonious strategy since every bit squandered may potentially double mona execution time concrete example consider type encoding mona requires seven bits two type bits t0 used distinguish types tree enum special null nodes tree single group bit g0 used distinguish redblack leaf variants four scalar bits s0 s1 s2 s3 used distinguish values final domain largest 010 example formula macro typetreevar1 p t0 p notin t1 expresses type tree encoded bit pattern 10 null nodes required encode arbitrary fanout binary tree example tree represented null nodes double lines wellformed value type tree described mona predicate tree tree imposes proper relationship types values nodes descendants technical problem predicate naturally described recursion available m2l solved phrasing requirements universal quantification imposes sufficient local wellformedness properties macro treetreevar1 all1 q pq null wf predicates describe relationship single node immediate descendants macro nullvar1 p notin t0 p notin t1 p notin g0 p notin p notin s2 p notin s3 macro typeenumvar1 p notin t0 p t1 macro grouptreeredblackvar1 p notin g0 macro grouptreeleafvar1 p g0 macro grouptreevar1 macro scalarenumvar1 p notin macro scalartreeredblackvar1 macro scalartreevar1 macro succenumvar1 macro succtreeredblackvar1 macro succtreeleafvar1 macro wfenumvar1 macro wftreevar1 p notin s0 succtreeleafp encoded simple inductive man ner illustration consider tiny formula p2s arguments general terms term p kind pos generates tuple p firstorder variable constrained formula oe similarly term kind set generates tuple secondorder variable term p2s generates formula existential quantification corresponds discharging registers fairly straightforward task provide similar templates fido constructs thereby providing compositional semantics recipe systematic translation concrete example consider formula tree x tree xleftrightleftred describes regular set trees specific node exists colored red encoded following mona formula macro dotrightvar1 pvar1 macro dotleftvar1 pvar1 assume ex1 p rootp treetreep ex0 t01t11g01s01 ex0 t02t12g02s02 t11pos6 t1 t01pos6 t0 g01pos6 g0 s01pos6 s0 analogy runtime computation mona finitestate automaton generated formula always guaranteed ter minate may prohibitively expensive thus fido compiler extensive optimizations many levels cases relying heavily type structure fido formulas symbolically reduced detect simple tautologies eliminate unnecessary variables quantifiers careful strategy employed allocate short bit patterns finite domains includes global analysis concrete uses also discovered fido type structure contains wealth information currently exploited mona implemen tation ongoing development effort enrich notion tree automata accommodate positional information derived fido specifications may case yield exponential speedup mona level 7 fido dsl opinion fido compelling example domainspecific language focused clearly defined narrow domain formulas monadic secondorder logic equivalently automata large alphabets offers solutions classical software problem drowning swamp lowlevel en codings advocates simple design principle go analogy standard programming language con cepts uses wellknown trusted technol ogy phases standard compiler including optimizations levels provides unique benefits cannot matched library standard programming language notational con veniences type checking global optimizations development discovered new insights domain new notions tree automata algorithms r specification language based ws2s hardware verification using monadic secondorder logic algorithms guided tree automata monadic secondorder logic practice model checker spin automatic verification pointer programs using monadic secondorder logic case study automated verification based trace abstractions automated logical verification based trace ab straction formal design constraints bdd algorithms cache misses three approaches type struc ture tr ctr anders mller michael schwartzbach pointer assertion logic engine acm sigplan notices v36 n5 p221231 may 2001 marjan mernik jan heering anthony sloane develop domainspecific languages acm computing surveys csur v37 n4 p316344 december 2005
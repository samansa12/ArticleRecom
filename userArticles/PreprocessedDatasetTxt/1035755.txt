superstabilizing mutual exclusion superstabilizing protocol protocol selfstabilizing meaning recover arbitrarily severe transient fault ii recover local transient fault satisfying passage predicate recovery paper investigates possibility superstabilizing protocols mutual exclusion ring processors local fault consists transient fault single processor passage predicate specifies one token ring single exception spurious token colocated transient fault first result paper impossibility theorem class superstabilizing mutual exclusion protocols two unidirectional protocols presented show conditions impossibility independently relaxed superstabilization possible using either additional time communication registers bidirectional protocol subsequently demonstrates superstabilization ioi1 time possible three superstabilizing protocols optimal respect number communication registers used b introduction notion superstabilization introduced dh95 refinement self stabilization superstabilization continues trend recent research combines stabilization forms fault handling ag93 gp93 bb95 main attraction stabilization possibility software initializes without requiring external signal useful presence transient faults distributed systems asynchronously reconfigure perhaps normal course phased computation stabilizing protocols typically engineered worst case transient fault designed mask likely cases faults reconfigurations faulttolerant behavior classified either masking nonmasking ag93 briefly put protocol masking faulttolerant users preliminary report research appears proceedings international conference parallel distributed processing techniques applications pdpta95 pp 3140 1995 observe illegitimate protocol behavior recovery fault errorcorrecting codes example mask faults within limit tolerances stabilizing protocols nonmasking meaning observer protocol witness corrupted output variables incorrect behavior point recovery complete superstabilization viewed partial masking technique likely cases transient faults reconfigurations retaining stabilization deal arbitrarily severe transient faults focus stabilization convergence stable legitimate behavior arbitrary initial state choice arbitrary initial state models worst case possibility transient failure system program counters internal registers channels could set unpredictable inconsistent values transient fault transient fault destroy code hardware fact enables system restore state convergence period proper behavior system behavior convergence typically concern since generally possible make guarantees beyond achieving convergence event severe transient fault superstabilization offers following refinement addition stabilization protocol may able guarantee certain safety properties period convergence following transient fault provided transient fault limited refinement attractive system unlikely encounter severe transient faults whereas certain limited transient faults occur relatively often application stabilization proposed dim93 domain dynamic systems initial state comes result online system reconfiguration dynamic system protocols network layer may required deal dynamic topology processors links added removed concurrently protocol operation stabilizing protocols deal initial state also applied situations dynamic reconfiguration superstabilization investigated dh95 assumption dynamic topology change events generate interrupts affected processors contribution research show principles superstabilization also applicable situations network reconfigurations interrupts fundamental familiar problem mutual exclusion investigated idea making safety guarantees cases limited transient faults system model oriented ring processors communicate using atomic link registers starting point version dijkstras stabilizing kstate protocol d74 adapted processorregister model class local transient faults consists processorlocal faults meaning transient fault change processors program counter internal variables assume processorlocal faults generate interrupts kind notification desirable passage predicate mutual exclusion property maintained meaning two simultaneous token holders system following processorlocal fault legitimate state passage predicate may feasible instance equate critical section execution tokenholding processorlocal fault could always set processors program counter processors next action occurs within critical section making impossible prevent two processors simultaneous execution critical sections following processorlocal fault impossible prevent two simultaneous token holders fault least system contain effect fault spurious token injected fault propagate processors note techniques used contain processorlocal faults might also useful context hierarchically layered system design desirable confine effect faults within layer module boundaries three protocols described paper successfully contain processor local faults thus critical section execution could placed higher layer token circulation protocol mask processorlocal faults elaborate layering paper instead concentrate following feasible passage predicate times one token holder single exception temporary spurious token located processorlocal fault observations preceding paragraph indicate faultmasking least level explored research incomplete following processorlocal fault protocol illegitimate state however illegitimate states observable circumstances satisfy passage predicate fault entirely masked blow softened perhaps notion faultcontainment crd95 n90 closer spirit superstabilization faultmasking although techniques existing work either faultmasking faultcontainment research may adapted purposes superstabilization additional constraint stabilization gives present research new twist faultmasking containment apparatus must able survive arbitrary transient fault well dealing limited faults primarily intended organization paper computing model processors atomic registers stabiliz ation superstabilization performance measures paper defined section 2 section 3 problem mutual exclusion ring introduced dijkstras stabilization mutual exclusion protocol presented processorregister model processorlocal faults introduced consider examples motivate techniques needed superstabilization section 3 also defines legitimacy passage predicate ring processors section ends proof impossibility superstabilization certain resource time constraints section 4 describes two unidirectional superstabilizing protocols neither protocols achieves optimum recovery time processorlocal fault section 5 presents results indicate optimum recovery time likely requires bidirectional protocol section 6 shows optimal recovery time processorlocal fault possible bidirectional ring section 7 contains concluding remarks system model system consists oriented ring n processors numbered 0 n gamma 1 neighbors processor processor identities conducted modulo n processors modeled conventional sequential machines program counters internal variables program statements refer variables unsubscripted names proofs denote location variable subscript instance variable finite domain possible values processors communicate reading writing registers register finite domain possible values written one processor read one processor implies instance processor writes register r ij processor j reads processor allowed read register r ij literature registers hv95 type register termed singlereader singlewriter register denoted 1w1r processor permitted read r ij well register would type 1w2r keeping ring topology register read j defined j gamma 1 ring unidirectional j every register r ij local state processor specification values program counter internal variables global state specification local states processors values registers state predicate specification set global states processor step execution local transition changing internal variables program counter register read register write processor step atomic initiating completing temporal overlap processor step step thus global state transition representable pair global states computation infinite sequence global states every consecutive pair states sequence processor step global state step enabled protocols notion infinite computation justified cases computation segment finite contiguous subsequence computation computation fair contains infinitely many steps processor arguments protocol behavior paper assume fair computations processorlocal fault processor atomic event sets variables program counter arbitrary values within domains processorlocal fault change value register processorlocal fault processor step computation includes fault reason fault tolerance proving properties computations begin state generated fault legitimate states protocol usually characterized predicate respect desired property let l weakest inclusive set states closed processor step starting state l results state l convergent every computation starting arbitrary state eventually contains state l every state l satisfies given property p call l set legitimate states protocol equivalently l called legitimacy predicate exists predicate l protocol respect given p say protocol stabilizing respect p p understood context simply call protocol stabilizing definition follows every protocol stabilizing respect predicate p j true mutual exclusion p specifies two processors program counters critical section note reactive protocols mutual exclusion predicate p inadequate describe desired properties need also specify prove liveness property holds computation eg every process obtains token infinitely many times definition stabilization extended include desired liveness properties useful results paper let oe legitimate state let oe 0 obtained applying processorlocal fault oe call oe 0 1faulty state protocol superstabilizing respect p q stabilizing respect p every computation starting 1faulty state satisfies predicate q states predicate q called passage predicate protocol p q understood context simply say protocol superstabilizing every stabilizing protocol superstabilizing respect passage predicate true superstabilization interesting passage predicate satisfy useful safety properties protocols paper specified programs infinitely iterate sequence statements including read write register statements segment computation called cycle processor contains steps processor corresponding complete iteration program first statement program jumps back first state ment note segment may start state oe program counter positioned middle iteration case steps must complete partial iteration complete entire iteration segment cycle depending choice oe cycle could thus contain one onehalf iterations cycle also observe one cycle processor could many cycles processor j asynchronous model processors registers use notion round measure concurrent time progress events computation informally round unit time sufficient processors complete cycle formally complete round computation segment includes least one cycle every processor minimal round complete round proper subsegment complete round sequel use round denote minimal round fair computation concatenation rounds enables us refer k th round computation stabilization time protocol worstcase number rounds initial state computation legitimate state reached superstabilization time protocol worstcase number rounds initial 1faulty state computation legitimate state reached stabilization time measures efficiently protocol copes worst case transient fault superstabilization time measures worstcase recovery time single processorlocal fault legitimate state following two definitions used describe bestcase times token circulation ring minimal round simple concatenation n segments contains steps one processor round linear simple concatenation n containing steps one processor first last segment steps processor 3 stabilizing mutex consider problem mutual exclusion unidirectional ring model processors registers problem mutual exclusion legitimate behavior computation every processor obtains access token critical section infinitely many times yet two processors simultaneous token access time call highlevel token behavior mutex property encode safety portion mutex predicate p stabilizing mutex protocol stabilizing respect predicate p specifies one processor accesses critical section legitimate state two perspectives evaluating efficiency stabilizing superstabilizing protocol efficiency absence faults normal behavior protocols efficiency recovering fault use rounds measure worstcase time recovery fault either stabilization superstabilization call computation segment complete token circulation every processor token state segment minimal token circulation complete token circulation proper subsegment computation segment complete token circulation sequel use token circulation denote minimal token circulation characterize efficiency protocols normal behavior investigate best worst case token circulation times best case described terms following definition useful impossibility proofs mutual exclusion protocol ring processors called klatent k minimum value every legitimate state oe exists token circulation begins oe contains k linear rounds protocol optimal respect latency 1latent meaning token circulate ring one round legitimate state efficient tokenpassing protocol one token passed two register operations writes r ii1 i1 reads r ii1 complete transfer token somewhat less efficient technique would passing token writes two registers r ii1 ii1 followed reading registers turns either techniques used construct 1latent protocol definition 1latency discriminate respect number registers used transferring token complicated technique transferring token following handshake mechanism first writes r ii1 reads q ii1 writes r ii1 finally complete token transfer handshake mechanism twophase interaction 1 protocol using handshake mechanism token circulation 1latent turns nlatent protocol section 6 intuitively 1latent protocol efficient interaction processors token passing minimal implementation registers based lowerlevel messages delay incurred p writing two registers r ii1 ii1 could roughly writing one register provided writes occur parallel handshake mechanism sequential interaction delay cannot hidden 31 basic ring protocol dijkstras kstate stabilizing protocol unidirectional ring adapted processor register model number definitions require adjustment roughly speaking statereading model used d74 corresponds unidirectional case nregister ring processors one key difference processor cannot read register writes whereas statereading model process read access variables writes instead associating mutual exclusion privilege enabledness action makes r ii1 perform critical section s5 6 s6 perform critical section s8 figure 1 mutex protocol processor sense given execution demon different representation necessary processor model similarly characterization legitimacy modified suit new representation mutual exclusion adaptation kstate stabilizing protocol presented figure 1 unidirectional ring implicit use 1w1r registers register n diagram figure 1 illustrates processor reads r igamma1i writes r ii1 protocol processor two internal variables n image register reads c image register writes processor zero plays role exceptional machine notation c denotes c statement s4 sequel require k larger total number variables registers contain token values protocol figure 1 requirement 1 k 3n protocol subsequent protocols paper state oe program counter processor p located critical section statement eg s3 s6 steps p alone starting state oe processor p execute critical section say p token holder state oe high level legitimate behavior protocol simple describe using mutex property predicate p formally specified choose constraint k 3n convenience proofs protocol correct smaller values k larger value k simplifies proofs shown v94 notation s3 denotes processor program counter set s3 ie processor executing critical section elsewhere paper notation used quantifications predicates op quantifier list dummy indices range delimits range dummies range may omitted dummy range understood term expression nested quantification definition p specifies two processors may simultaneously execute critical section sequel protocol paper stabilizing respect version p henceforth leave p implicitly understood definition differs protocols specific statement numbers critical sections defining legitimacy predicate l detailed affair simple specification p example legitimate state one would expect following hold 1 words 1 says cvalue processor equal value writeregister whenever program counter set s1 one would expect execution s8 s9 complete characterization legitimate state terms internal variable values register values program counters turns lengthy expression spare reader details leave l implicit concentrate following crucial component l ring protocol statereading model neither program counters registers lc characterization legitimate state lc predicate states every process either old value x c variable new value x new values present contiguous segment starting processor zero steps protocol unidirectionally copy new value replace old value adjacent result copy operation state satisfying lc old values replaced new value initially values lc satisfied choice existential quantification lc definition lemma 1 mutex protocol figure 1 stabilizing stabilization time proof proof consists showing convergence closure states satisfying lc verifying lc p consider arbitrary computation starting arbitrary initial state number rounds computation starting round zero completion round zero computation reaches state 1 holds processor executes s8 s9 least round zero generally processor completed cycle r ii1 equal c observation permits us reason using c variables rounds one higher prove detail closure lc convergence lc since would repeat known arguments see bound introduce predicate note g ngamma1 implies lc protocol completed round zero processors synchronized images registers program counters g ngamma1 holds protocol stabilized henceforth proof consider rounds one higher simple show induction g k holds round k processor zero execute s4 rounds k therefore s4 execute holds consequently case c 0 unique equal processors c variable g ngamma1 holds n gamma 1 additional rounds within many rounds c 0 value unique since n processes s4 increments modulo k pigeonhole principle c 0 becomes unique 3n executions s4 s4 introduce new c values system k 3n implies token value register variable combining observations g k see computation contains state satisfying lc round 4n based invariance lc straightforward details l concerning program counters internal variables follows p holds state following convergence structure lc also useful proving processor performs critical section infinitely often lemma 2 mutual exclusion protocol figure 1 1latent protocol circulates token n rounds proof consider legitimate state oe either token holder last processor hold token completed cycle every legitimate state least one processor construct linear round first scheduling steps processor completes current cycle schedule processor 1s cycle completing round inclusion cycle processor necessary schedule processor token holder linear round proof n rounds suffice token circulation follows arguments similar inductive reasoning used lemma 1 32 processorlocal faults consider event processorlocal fault legitimate state essentially two worstcase aspects fault fault set program counter processor s6 leaving internal variables unchanged b fault set program counter s8 value c arbitrary value possible first step computation following fault write operation processor writes r ii1 value injected processorlocal fault processorlocal faults combine aspects b also possible fault type b sense severe fault type one additional step processor protocol legitimate state moreover states violate mutual exclusion following fault processor processor invalidly critical section fault type b possible subsequent computation contains state three processors simultaneously critical section sketch scenario example ten processor ring showing values c variables legitimate state underscored value indicates processor token holder state consider processorlocal fault sets c variable 5 suppose first subsequent step writes c variable output register neighbor reads obtain state two processors token holders subsequent steps value 5 propagated state results processor inflicted processorlocal fault reads neighbor rewrites register lead state three processors token holders modifications protocol address concerns faults type b long activation critical section dependent internal variables program counter fault type impossible prevent strongest passage predicate one construct must allow possibility two processors token holders however one two processors processor inflicted processorlocal fault protocol satisfies mutual exclusion within cycle inflicted processor possible construct protocol satisfying mutex passage predicate provided effects type b fault managed remainder paper let qffi mutex passage predicate defined parametrically respect 1faulty global state ffi definition let cs 1 program counter critical section otherwise let cs 0 let prffi index processor inflicted fault state ffi note stronger passage predicate qffi desirable would prefer processor prffi execute critical section one time recovery period however qffi satisfied computation segment prffi executes critical section numerous times real token continues circulate principle stronger passage predicate could formally specified using auxiliary variables record fault computation history prefer simpler specification qffi paper protocols subsequent sections fact satisfy stronger passage predicate attempt address type b fault consider following replacement statement s6 protocol s6a s6b perform critical section strengthened precondition executing critical section eliminates scenario multiple token holders sketched however following situation still possible processorlocal fault subsequent steps although shown improved protocol longer possibility three token holders existing processorlocal fault legitimate state mutex passage predicate satisfied every case effect processorlocal fault contained single processor following theorem shows resources necessary order address concern theorem 1 1latent protocol mutual exclusion using fewer 2n 1w1r registers superstabilizing respect mutex passage predicate proof contradiction n 3 suppose 1latent protocol exists 2n gamma 1 registers superstabilizing respect mutex passage predicate order stabilize processor read access least one register write access least one register otherwise could token circulation registers type 1w1r processor p read access one register r p consider legitimate state oe processor q first statement cycle becomes token holder cycle also suppose q 6 p q writeaccess r p choice oe q possible n 3 protocol stabilizing mutual exclusion protocol assumption 1latency exists linear round starting oe every processor token holder first cycle linear round consists steps processor q ceases token holder second cycle round consists steps either q 1 include tokenholding processor proved contradiction second cycle r 62 illegitimate computation could constructed r initial cycle r q token holders state argument structure linear round continued establish path token holders q p given linearround construction clear exists state fl oe fl identical respect ps state r p contains value computation beginning fl containing steps p results p token holder therefore possible following processorlocal fault occur state oe program counter writer r p set write r p operation first step 1faulty state writes r p subsequent computation segment consisting solely steps p results p token holder existence processorlocal fault subsequent computation violates mutex passage predicate unidirectional superstabilizing protocols conditions impossibility theorem 1 suggest two ways one might hope construct superstabilizing protocol devise protocol klatent k 1 design protocol using least 2n registers possibilities subject following two subsections 41 nlatent protocol one way superstabilizing mutual exclusion possible increasing latency token rotation protocol presented uses n 1w1r registers size register larger used protocol figure 1 register mapped field k states fields represents token dijkstras protocol stabilizes sense protocol figure 1 one tokens called major token controls access critical section remaining n tokens called minor tokens processor ring plays exceptional role way processor zero exceptional dijkstras protocol one minor tokens main idea subsections protocol major token advances one position ring minor token circulates around ring one linear round major token advances one processor n linear rounds major token circulation completed let register r ij subdivided n 1 fields denoted r ij k processor three internal variables w boolean two variables c n register image variables fields r ij n cn nn represent major token fields r ij k ck nk represent minor token exceptional processor k presents protocol processor 6 0 protocol processor zero presented differs figure 2 statements s4 s12 s14 modification follows protocol figure 1 legitimate state nlatent protocol satisfies three key properties 1 major minor token values legitimate natural extension lc definition introduced proof lemma 1 appropriate fields 2 exactly one processor p either holds token releasing token waiting minor token circulate w p set false holds token 3 processor q waiting minor token circulate fields r ij q cq nq minor token value lemma 3 protocol figure 2 stabilizing 2 stabilization time nlatent token circulation n 2 rounds s5 w perform critical section figure 2 nlatent mutex protocol 6 0 see appendix proof theorem 2 protocol figure 2 superstabilizing respect mutex passage predicate superstabilization time see appendix proof although superstabilization guarantees passage predicate holds convergence following 1faulty state processorlocal fault disrupt normal order processors become major token holders instance easy construct examples number processors skipped order tokenholding minor tokens stabilize following processorlocal fault although protocol superstabilizing may entirely faultmasking processor p distance processorlocal fault suppose fault located processor p fault convergence legitimate state complete processor p could lose turn executing critical section whether protocol faultmasking processors depends users ability observe turn critical section lost computation disrupted fault specification observation power user needed formalize masking faulttolerance closely related work ukmf97 ideas superstabilizing protocol figure 2 improved presented statereading model d74 statereading model registers program counters replaced variables processlocal fault corrupt variables process superstabilizing protocol ukmf97 1 n2latent major token advance two processes minor token circulation n must even protocol space requirement also reduced combining minor tokens single minor token reduces token space lg n olg n also shown ukmf97 bn2clatent superstabilizing mutex protocol possible unidirectional ring statereading model 42 1latent protocol previous subsections protocol exploits increased latency achieve superstabilization approach suggested structure theorem 1 use 2n registers protocol presented subsection adds duplicate register q ij protocol figure 1 execution critical section dependent values two registers main idea processor 6 0 propagate values reads two registers unless values equal protocol specifies processor write value two registers without reading register two writes one way describe protocol say processor uses waiting strategy deal 1faulty states since waits input registers equal token values figure 3 presents protocol protocol let k value satisfying k 5n since five token entities per processor c n variables plus two output registers idea waiting cannot employed processors certain initial global states would lead deadlock processor zero therefore uses different strategy deal 1faulty states code processor zero uses function trval returning pair natural numbers defined follows pair c assigned trvaly c nm value c token value processor zero value counter value zero legitimate state 7n illegitimate state value 7n chosen simplify proof convergence first ifcase trvals definition addresses normal situation token processor zero increments token case registers written processor n gamma 1 valid call 7n cases corrective values c 0 provided case processorlocal fault corrupts c 0 unfortunately cases initial states corrective calculation c 0 repeatedly employed prevent stabilization token mechanism therefore counter added protocol corrective measure applied bounded number times computation since counter also subject corruption fault value circulated ring additional register field legitimate states states also satisfy l r define following processor p values c variable registers conform entry following table r fffi fffi ffff ffff fffi fifi fifi fifi fiff fiff ffff fifi convention table fi row r registers shows token field two values represent r pgamma1p r pp1 respectively table entry thus represents value relationships processor instance first entry shows processor p 6 0 input registers equal value ff c ps output registers equal fi final column p 6 0 heading permissible configuration case processor zero propagate token value either register order whereas order fixed processors looking definition l r reader may appreciate verification superstabiliza tion involves numerous subcases since entry table subject fault considerations proofs somewhat tedious postponed papers appendix lemma 4 protocol figure 3 stabilizing 2 stabilization time 1latent every token circulation n rounds see appendix proof conjunction lc l r lc predicate token values specified proof lemma 1 lemma 5 computation starting 1faulty state protocol figure 3 reaches state satisfying l o1 rounds mutex passage predicate holding every state see appendix proof theorem 3 protocol figure 3 superstabilizing respect mutex passage predicate 2 superstabilization time r ii1 s5 s6 perform critical section s8 protocol 6 0 t4 t5 perform critical section t11 perform critical section t13 goto protocol figure 3 unidirectional 2nregister protocol proof lemma 5 computation starting 1faulty state establishes invariant holds state legitimate see bound tight consider fault processor zero sets 0 n superstabilizing protocol given subsection improves nlatent protocol two ways first latency improved adding registers second although superstabilization time larger recovery processorlocal fault said take o1 time since l holds within o1 rounds following fault however even though l holds state legitimate system ready mask another processorlocal fault state legitimate considering convergence segment following fault see initial part segment recovers token variables fault latter part segment kind garbage collection adding sufficient robustness state another processorlocal fault tolerated 5 optimum latency superstabilization section describes certain limits superstabilizing mutex protocols 1latent results show 1latent protocols either require techniques beyond used previous sections require bidirectional communication begin observation regarding passing token superstabilizing protocol lemma 6 1latent protocol exists computation token circulates unidirectionally proof contradiction suppose 1latent protocol computation token circulates unidirectionally every suffix every computation token passed processor sigma 1 order token passing contradicts definition linear round lemma 6 covers case nondeterministic token circulation example choice passing token processor could nondeterministic protocol 1latent must possible legitimate state token circulation complete one linear round implies unidirectional token movement remainder section consider 1latent protocols restrict attention computations token circulation unidirectional define number token passing registers protocol minimum range number registers writes reads passing token processor processor 1 protocols section 31 section 41 use one token passing register number token passing registers protocol section 42 two superstabilizing mutual exclusion protocol uses fewer two token passing registers allows us concentrate computations token passing unidirec tional lemma proved using argument similar presented theorem 1 processorlocal fault cause write token passing register fools another processor executing critical section mutex passage predicate falsified lemma 7 implies 1latent protocol section 42 optimal number registers uses 1latent bidirectional protocol circulating token unidirectionally uses least three registers since least two registers required token passing remainder section presents definitions results particular type unidirectional protocol given 1latent unidirectional mutual exclusion protocol certain number registers say k written processor read processor 1 predicate exists describes legitimacy relation values local state processor output registers processor local state processor 1 call global state detectably corrupt inferred local state processor contents output registers processor suppose state oe detectably corrupt 1 two possible properties oe exists legitimate state output registers processor equal values state oe ii exists legitimate state local state processor equals state oe ii hold oe say oe spliced corrupt state since values output registers legitimate state 1 legitimate two legitimate different states oe result splicing together two legitimate states spliced corrupt state poses question design superstabilizing mutual exclusion protocol spliced corrupt state oe detectably corrupt 1 processor 1 alter state p holds two possible strategies processor 1 correcting waiting correcting strategy consists processor reading input registers detect p followed processor local state p longer holds waiting strategy consists processor 1 entering protocol phase 1 continues execute cycles p holding output registers change values processor detect p processor state p detectable waiting strategy processor waits situation corrected waits signal correct state fix problem stabilizing mutual exclusion protocol regular processor j 1 whenever p j detectable processor j uses one strategy correcting waiting response detecting p j words protocol regular processor j sometimes uses correcting strategy sometimes uses waiting strategy depending values local state j input registers note dijkstras protocol regular processor zero employs waiting strategy effectively ignoring values input registers unless appear legitimate processors use correcting strategy lemma 8 regular 1latent unidirectional stabilizing mutual exclusion protocol specifies least one processor use waiting strategy proof contradiction consider regular protocol processors use correcting strategies construct illegitimate state splicing together number legitimate states instance take one segment ff processors ring size n legitimate state ff token ff located within ff another segment fi n gamma processors legitimate state fi token fi located within fi two segments ff fi disjoint construct new state fl splicing two segments together possible computation starting fl following scenario round tokens advance one processor ring possible 1latency two processors execute correction strategy thus round two legitimate segments size n gamma persist protocol fails converge assumption processor uses correcting strategy therefore contradicts stabilization lemma 9 processor uses waiting strategy regular 1latent unidirectional super stabilizing mutual exclusion protocol protocol cannot o1 superstabilization time proof contradiction construct 1faulty state oe 0 legitimate state oe selecting processor j 1 employs waiting strategy corrupting state j oe 0 spliced corrupt state output registers j values oe oe 0 since j waiting strategy computation starting oe 0 remains illegitimate processor j writes register different value present state oe let us consider computation j completes many cycles j input registers since variables registers finite values js output registers periodic computation exist values js output registers repeat moreover values possible legitimate states protocol 1 rounds ie constant number rounds since processor j initially detects illegitimacy signal written j 1 circulate ring processor j within o1 rounds therefore construct computation processor j observe change input registers 1 rounds time j input registers values periodicity argument thus protocol converge 1faulty state legitimate state within o1 rounds contradicts claim o1 superstabilization time theorem 4 regular 1latent unidirectional mutual exclusion protocol superstabilizing o1 superstabilization time proof result follows two previous lemmas 6 bidirectional protocol 2nregister protocol given section 42 2 superstabilization time n register protocol section 41 superstabilization time section presents protocol o1 superstabilization time expense bidirectional communication bidirectional approach motivated theorem 4 basic idea protocol simple adaptation nregister superstabilizing protocol processor controls minor token however minor token circulates processors gamma 1 ring therefore bidirectional two 1w1r registers needed processor diagram shown figure 4 illustrates processors communicate protocol register two fields one major token value one minor token value processor uses c variable major token maintains two local variables minor token circulation represents minor token v contains image minor token value additional local variables n register field images legitimate progression minor token activity processor assigns executes subsequently executes read assigns v processor executes processor reads vfield r register variable finally processor implies completion minor token circulation addition variables token manipulation processor records two recently read values major minor token processor gamma 1 recording implemented history variables arrays w v twoelement arrays local index variable w toggles zero one whenever processor detects new value pair processor gamma 1 precisely processor observes minor token differs vw observes major token differs ww toggles w records major minor token values read history variables strengthen condition execution critical section major token must value two consecutive recordings critical section executed processor correction assignment s7 t7 correction assignment 6 0 identical respect major token normally executed s12 correction assignment t7 figure 4 standard major token assignment t12 possibility repeated execution t7 convergence complicates proof stabilization assume since seven major token variables fields per processor legitimacy protocol specified three components lc legitimacy major token l legitimacy minor tokens lw legitimacy history variables lw predicate defined follows asserts allowed values w v two situations end cycle processor statement s19 major token passed gamma 1 ffl c major token passed gamma 1 construction lw underlies design s15s16 t15t16 correct history variables processor fault protocol figure 4 stabilizing 3 stabilization time protocol nlatent token circulation 3n rounds r ii1 xy s5 wwvw n s7 c n perform critical section else protocol 6 0 t3 n 6 ww 6 vw t7 c n t11 perform critical section t13 else t17 protocol figure 4 bidirectional 2nregister protocol see appendix proof theorem 5 protocol figure 4 superstabilizing o1 stabilization time see appendix proof protocols presented paper demonstrate stabilization limited masking tolerance transient faults combined investigation indicates goals masking tolerance single fault rapid token circulation stabilization may collide require additional resources protocols given uses minimum number registers possible optimal sense nregister protocol optimal superstabilizing protocol 2nregister protocol optimal 1latent superstabilizing protocol bidirectional protocol optimal o1 superstabilization time open question suggested three presented protocols possibility protocol superstabilizing 1latent o1 superstabilization time possibly optimal stabilization time well limits given results section 5 suggest form protocol might bidirectional three registers per processor limitation investigation consider processorlocal faults definition 1faulty state precludes consideration transient fault corrupts register although processorlocal fault lead corruption register additional information event register corrupted transient fault set program counter write operation program counter set statement following write faultinduced event use fact constructions arranging protocols read verify variables following write operations likely techniques used paper extended cover case register faults well perhaps expense additional resources techniques used superstabilization paper basic methods fault tolerance replication data entities registers replication time implicit use minor tokens bidirectional acknowledgment different approach problem transient faults use techniques coding theory encryption reduce probability transient fault violate passage predicate paper y96 suggests publickey encryption used encode token makes unlikely transient fault could falsify mutex predicate fooling argument used theorem 1 practically refuted although present study limited problem mutual exclusion processor register ring model processorlocal faults results paper gghp96 show similar limitations statereading model general transformational programs paper gghp96 uses model process read states neighbors one atomic step nonreactive programs considered excludes mutual exclusion consideration result gghp96 goals optimum stabilization time o1 fault correction time 1faulty state conflict consideration passage predicate approach rapid stabilization following transient faults suited network model given kps97 nonreactive protocols consideration safety convergence papers gs95 cw97 consider limited forms change legitimate state stabilizing algorithm maximumflow trees considered capacities links asynchronously change form safe convergence new legitimate state guaranteed investigation paper limited mutual exclusion ring processorlocal faults contrast research gp93 dh95 ag93 combining stabilization forms faulttolerance considers general methodological problem systematic construc tion identifying conditions various techniques used modular form synthesize programs various fault tolerances nonmasking tolerance transient faults plus masking tolerance failstop processes forth general method gp93 applicable problem consider namely nonmasking tolerance worst case transient faults maintenance specified passage predicate single processorlocal faults general superstabilizing construction dh95 relies interrupts faults apply processorlocal faults method suggested ag93 based programming constraints specify details sufficient address superstabilization design superstabilizing protocols nontrivial sense stabilizing protocols stabilizing supervisor added protocol order make stabilizing must overcome transient faults strike supervisor similarly mechanism added maintain passage predicate following single local fault must guarantee safe behavior convergence fault well convergence general fault apparently simple solution adding redundant components using voting module mask single faults work voting module mask single faults variables program counters approach proposed ak97 develop programs layered methodology new statements successively added program using superposition operators deal different types faults approach general sense every faulttolerant program guarded command model computation shown layered composite structure elements corresponding fault detection correction various fault types problem devise faulttolerant programs remains however challenging task experience paper suggests refinement may appropriate methodology development superstabilizing programs protocols presented seen refinement dijkstras kstate protocol r designing masking faulttolerance via nonmasking fault tolerance highly safe selfstabilizing mutual exclusion algorithm hive fault containment sharedmemory multiprocessors closure convergence foundation faulttolerant computing gopal superstabilizing protocols dynamic distributed systems constructing 1writer multireader multivalued atomic variables regular variables latency optimal supersta bilizing mutual exclusion protocol propagated timestamps scheme stabilization maximum flow routing protocols maximum flow routing tr faulttolerant computing unifying selfstabilization faulttolerance closure convergence selfstabilization counter flushing constructing 1writer multireader multivalued atomic variables regular variables hive highly safe selfstabilizing mutual exclusion algorithm faultcontaining selfstabilizing algorithms timeadaptive self stabilization designing masking faulttolerance via nonmasking faulttolerance selfstabilizing systems spite distributed control selfstabilizing mutual exclusion presence faulty nodes ctr yoshiaki katayama eiichiro ueda hideo fujiwara toshimitsu masuzawa latency optimal superstabilizing mutual exclusion protocol unidirectional rings journal parallel distributed computing v62 n5 p865884 may 2002 yehuda afek shlomi dolev local stabilizer journal parallel distributed computing v62 n5 p745765 may 2002
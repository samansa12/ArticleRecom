component based design multitolerant systems abstractthe concept multitolerance abstracts problems system dependability provides basis improved design dependable systems abstraction source undependability system represented class faults corresponding ability system deal undependability source represented type tolerance multitolerance thus refers ability system tolerate multiple faultclasses possibly different way paper present component based method designing multitolerance two types components employed method namely detectors correctors theory detectors correctors interferencefree composition intolerant programs developed enables stepwise addition components provide tolerance new faultclass preserving tolerances previously added faultclasses illustrate method designing fully distributed multitolerant program token ring b introduction dependability increasingly relevant systemlevel requirement encompasses ability system deliver service desirable manner spite occurrence faults security intrusions safety hazards configuration changes load variations etc achieving ability difficult essentially engineering system sake one dependability property say availability presence faults often interferes another desired dependability property say security presence intrusions paper effectively reason multiple dependability properties introduce concept multitolerance source undependability treated class faults dependability property treated type tolerance thus multitolerance refers ability system tolerate multiple classes faults possibly different way although many examples multitolerant systems practice 1 gamma 3 exists growing body research presents instances multitolerant systems 4 gamma 9 aware previous work considered systematic design multitolerance towards redressing deficiency present paper formal method design multitolerant systems deal difficulty interference multiple types tolerances method based use components specifically multitolerant system designed using method consists intolerant system set components one desired type tolerance thus method reduces complexity design designing components correctly adding intolerant system moreover enables reasoning type tolerance interferences different types tolerance level components opposed involving whole system method reduces complexity adding multiple components intolerant system adding component stepwise fashion words method considers fault classes intolerant system subject fixed total order say f1 fn component added intolerant system tolerates f1 desirable manner resulting system augmented another component tolerates f2 desirable manner tolerance f1 preserved process adding new tolerance preserving old tolerances repeated n faultclasses accounted follows final system multitolerant respect f1 fn components used method built two building blocks namely detectors correctors occur albeit implicitly faulttolerant systems intuitively detector detects whether predicate satisfied system state corrector detects whether predicate satisfied system state also corrects system state order satisfy predicate whenever predicate satisfied detectors used ensure step system safe respect problem specification correctors used ensure system eventually reaches state problem specification resatisfied thus paper also able show components built detectors sufficient designing failsafe tolerance programs components built correctors sufficient designing nonmasking tolerance programs components built detectors correctors sufficient designing masking tolerance programs formally define terms shortly rest paper organized follows section 2 give formal definitions programs problem specifications faults faulttolerances sections 3 4 define detectors correctors discuss role design faulttolerant systems illustrate designed hierarchically efficiently section 5 present theory noninterference composing detectors correctors intolerant programs section 6 define multitolerance present formal method designing multitolerance section 7 illustrate method designing multitolerant token ring program finally discuss issues raised methodology section 8 make concluding remarks section 9 preliminaries section give formal definitions programs problem specifications faults fault tolerances formalization programs standard one specifications adapted alpern schneider 9 faults faulttolerances adapted earlier work first author mohamed gouda 10 exception portion failsafe tolerance new programs program set variables finite set actions variable predefined nonempty domain action unique name form guard action boolean expression program variables statement action execution atomically instantaneously updates zero program variables notation conveniently write action restriction another action use notation hname define action hname 0 whose guard obtained restricting guard action hnamei hguard 0 whose statement identical statement action hnamei operationally speaking hname 0 executed guard hnamei guard hguard 0 true likewise conveniently write program restriction another program use notation define program consisting set actions hguardi ac action ac hprogrami let p program definition state state p defined value variable p chosen predefined domain variable definition state predicate state predicate p boolean expression variables p note state predicate may characterized set states boolean expression state predicate true definition enabled action p enabled state iff guard state predicate true state definition computation computation p fair maximal sequences states j j 0 j obtained state j gamma1 executing action p enabled state j gamma1 fairness sequence means action p continuously enabled along states sequence eventually chosen execution maximality sequence means sequence finite guard action p false final state ie sequence cannot extended executing enabled action final state problem specification problem specification set sequences states suffix closed fusion closed suffix closure set means state sequence oe set suffixes oe fusion closure set means state sequences hff x fli hfi x ffii set state sequences hff x ffii hfi x fli ff fi finite prefixes state sequences fl ffi suffixes state sequences x program state note state sequences problem specification may finite infinite following alpern schneider 9 shown problem specification intersection safety specification suffix closed fusion closed liveness specification defined next definition safety safety specification set state sequences meets following condition state sequence oe set exists prefix ff oe state sequences fi fffi set fffi denotes concatenation ff fi definition liveness liveness specification set state sequences meets following condition finite state sequence ff exists state sequence fi fffi set defined examples problem specifications namely generalized pairs closures converges let r state predicates definition generalized pairs generalized pair fsg frg set state sequences j j 0 true j r true j1 definition closure closure set state sequences true j k k j true k definition converges converges r set state sequences intersection r true exists k k r true k note fsg converges program correctness respect problem specification let spec problem specification definition satisfies p satisfies spec iff computation p starts state true spec definition violates p violates spec iff case p satisfies spec exists computation p starts state true spec convenience reasoning programs satisfy special cases problem specifications introduce following notational abbreviations definition generalized hoaretriples fsg p frg iff p satisfies generalized pair fsg frg true definition closed p closed p iff p satisfies true note trivially true state predicates true false closed p definition converges p converges r p iff p satisfies converges r true informally speaking proving correctness p respect spec involves showing p satisfies spec state predicate course useful predicate false since problem specifications suffix closed may without loss generality restrict attention proving p satisfies problem specification closed state predicate call state predicate invariant p invariants enable proofs program correctness eschew operational arguments long subsequences states thus methodologically advantageous definition invariant invariant p spec iff closed p p satisfies spec notational remark henceforth whenever problem specification clear context omit thus invariant p abbreviates invariant p spec one way calculate invariant p characterize set states reachable execution p starting designated initial states experience shows however ease proofs program correctness one may prefer use invariants p properly include reachable set states key reason included initial states definition programs techniques design invariants articulated dijkstra 11 using notion auxiliary variables gries 12 using heuristics state predicate ballooning shrinking techniques mechanical calculation invariants discussed alpern schneider 13 faults faults program subject systematically represented actions whose execution perturbs program state emphasize representation possible notwithstanding type faults stuckat crash failstop omission timing performance byzantine nature faults permanent transient intermittent ability program observe effects faults detectable undetectable definition faultclass faultclass p set actions variables p let state predicate invariant p f faultclass p definition preserves action ac preserves state predicate iff execution ac state true results state true f span p iff closed p action f preserves thus state invariant p true f span p also true also like also closed p moreover action f executed state true resulting state also one true follows computations p start states true boundary state space p beyond state p may perturbed occurrence actions f notational remark henceforth ambiguously abbreviate phrase action f preserves closed f whenever program p clear context omit thus invariant abbreviates invariant p f faultclass abbreviates f faultclass p faulttolerances ready define means program p invariant tolerate faultclass f definition tolerant p f tolerant iff exists state predicate satisfies following three conditions ffl state true also true words ffl starting state true action p f executed resulting state also one true words closed p action f preserves ffl starting state true every computation p alone eventually reaches state true words since closed p converges p definition may understood follows state predicate f span p boundary state space p beyond state p may perturbed occurrence faults f faults f continue occur state p remains within boundary faults f stop occurring p converges boundary stricter boundary state space invariant true important note may multiple state predicates p meets three requirements multiple state predicates captures potentially different type faulttolerance p exploit multiplicity section 6 order define multitolerance types faulttolerances classify three types faulttolerances program exhibit namely masking nonmasking failsafe tolerance using definition f tolerance informally speaking classification based upon extent program satisfies problem specification presence faults three masking strictest type tolerance presence faults program always satisfies safety specification execution p execution actions f yields computation safety liveness specification p ie computation problem specification p nonmasking less strict masking presence faults program need satisfy safety specification faults stop occurring program eventually resumes satisfying safety liveness specification ie computation suffix problem specification failsafe also less strict masking presence faults program always satisfies safety specification faults stop occurring program need resume satisfying liveness specification ie computation safety specification necessarily liveness specification p formally three types tolerance may expressed terms definition f tolerance follows definition masking tolerant p masking tolerant f iff p f tolerant closed f words fault f occurs state true p continues state true definition nonmasking tolerant p nonmasking tolerant f iff p f tolerant closed f words fault f occurs state true p may perturbed state violated however p recovers state true definition failsafe tolerant p failsafe tolerant f iff exists state predicate r p f tolerant r r closed p f p satisfies safety specification problem specification r words fault f occurs state true p may perturbed state r true latter case subsequent execution p yields computation safety specification p necessarily liveness specification notation sequel whenever faultclass f invariant clear context omit thus masking tolerant abbreviates masking tolerant f detectors section define first two building blocks sufficient design faulttolerant programs namely detectors also present properties detectors show construct hierarchical efficient manner discuss role design faulttolerance mentioned introduction intuitively detector program detects whether given state predicate true current system state implementations detectors abound practice wellknown examples include comparators error detection codes consistency checkers watchdog programs snoopers alarms snapshot procedures acceptance tests exception conditions z state predicates program u state predicate closed say z detects x u iff following three conditions hold ffl safeness state u true z true x also true words u ffl progress starting state u x true every computation either reaches state z true state x false ffl stability starting state u z true falsifies z also falsifies x words fu zg fz xg safeness condition implies detector never lets predicate z witness detection predicate x incorrectly executed states u true progress condition implies computation starting state u true x true continuously eventually detects x truthifying z stability condition implies z truthified continues true unless x falsified remark detection predicate x closed definition detects relation reduces one given chandy misra 14 considered general definition accommodate case occurs instance nonmasking tolerance x denotes something bad happened case x supposed closed since subsequently corrected end remark sequel implicitly assume specification detector dn z detects x u respectively zn detects xn dn un also implicitly assume u un closed respectively dn properties detects relation reflexive antisymmetric transitive first two arguments lemma 30 let x z state predicates u state predicate closed following statements hold detects x u ffl z detects x u x detects z u u ffl z detects u detects x u z detects x u lemma 31 let v state predicate u v closed following statements hold ffl z detects x u z detects x uv ffl z detects x u v x zv detects x u ffl z detects x u z z detects xv u compositions regarding construction detectors cases detection predicate x cannot witnessed atomically ie executing one action detector program detect predicates give compositions small detectors yield large detectors hierarchical efficient manner particular given two detectors d1 d2 compose two ways parallel ii sequence parallel composition detectors parallel composition d1 d2 denoted d1d2 d1 d2 execute interleaved fashion formally parallel composition d1 d2 union variables actions programs d1 d2 observe commutative d1d2d3 distributes g theorem 32 let z1 detect x1 d1 u z2 detect x2 d2 u variables d1 d2 mutually exclusive z1z2 detects x1x2 d1d2 u proof safeness condition d1d2 follows trivially safeness d1 d2 progress condition consider two cases computation d1d2 falsifies x1 x2 ii computation d1d2 never falsifies x1 x2 first case progress satisfied trivially second case eventually z1 truthified stability d1 z1 continues true execution d1 moreover since variables d1 d2 disjoint z1 continues true d2 likewise z2 eventually truthified continues true thus progress satisfied finally stability condition satisfied since z1z2 falsified x1 x2 violated d1d2 since d1 d2 perform detection concurrently time required detection x1x2 maximum time taken detect x1 detect x2 assuming unit measuring time allows d1 d2 attempt execution action also space complexity d1d2 sum space complexity d1 d2 since state space d1d2 union state space d1 d2 sequential composition detectors sequential composition d1 d2 denoted d1 d2 d2 executes d1 completed detection ie witness predicate z1 true formally sequential composition d1 d2 program whose set variables union variables d1 d2 whose set actions union actions d1 z1d2 postulate axiom leftassociative d1 d2 observe commutative distributes d1 distributes g d1 suppose variables d1 d2 mutually exclusive case starting state x1x2 true continuously d1 eventually truthifies z1 z1 truthified actions d2 executed actions eventually truthify z2 since z2 truthified z1 hence x1 x2 true also follows u assume u theorem 33 let z1 detect x1 d1 u z2 detect x2 d2 ux1 variables d1 d2 mutually exclusive u z2 detects x1x2 d1 d2 u d1 d2 time respectively space taken detect x1x2 sum time respectively space taken detect x1 detect x2 extra time taken d1 d2 compared d1d2 warranted cases witness predicate z2 witnessed atomically z1z2 cannot example memory access let us consider simple memory access program obtains value stored given address cf figure 1 program subject two faultclasses first consists protection faults cause given address corrupted falls outside valid address space second consists page faults remove address value memory tolerance first faultclass detector d1 uses page table tbl detect whether address addr valid x1 tolerance second faultclass another detector d2 uses memory mem detect whether given address memory x2 d2 mem addr figure 1 memory access formally detectors follows simplicity assume tbl set valid addresses mem set objects form haddr vali thus may observe ffl z1 detects x1 d1 u1 1 ffl z2 detects x2 d2 u1 x1 2 note appropriate choice initial state u1 would one z1 z2 false note also u1 z1 truthified x1 true z2 truthified x1 x2 true detect x1x2 may compose d1 d2 sequentially d1 would first detect x1 d2 would detect x2 theorem 33 1 2 get ffl z2 detects x1 x2 d1 d2 u1 3 application design faulttolerance detectors suffice ensure program satisfies safety specification see recall safety specification essentially rules certain finite prefixes program computation consider prefix computation ruled safety specification execution program action starting prefix violate safety specification iff elongated prefix ruled safety specification words program action ac exists set computation prefixes execution ac violate safety specification follows exists detection state predicate execution ac state state predicate true violate safety specification fusion closure safety specification suffices state predicate characterize set states state st yields upon executing ac successor state st 0 state sequence safety specification st st 0 occur consecutively order detectors added program program action ac detection predicate ac witnessed program action restricted execute corresponding witness predicate true resulting program satisfies safety specification design failsafe tolerance f need ensure upon starting state true execution p presence f always yields computation safety specification p follows detectors suffice design failsafe tolerance likewise design masking tolerance f need ensure upon starting state true execution p presence f never violates safety specification execution p execution actions f always yields computation safety liveness specification p ie computation problem specification p fusion closure problem specification follows computation p safety specification suffix problem specification problem specification regarding safety suffices detectors added p regarding liveness suffices correctors added p discussed next section detectors also play role design nonmasking tolerance may used detect whether program perturbed state invariant false discussed next section detectors systematically composed correctors restore program state invariant true section discuss second set building blocks namely correctors manner analogous discussion detectors mentioned introduction intuitively corrector detector also corrects program state whenever detects detection predicate false current system state implementations correctors also abound practice wellknown examples include voters error correction codes reset procedures rollback recovery rollforward recovery constraint resatisfaction exception handlers alternate procedures recovery blocks z state predicates program c u closed c say z corrects x c u iff following four conditions holds ffl safeness state u true z true x also true words u ffl convergence starting state u true every computation c eventually reaches state x true subsequently x continues true thereafter words u converges x c starting state u x true every computation c either reaches state z true state x false ffl stability starting state u z true c falsifies z also falsifies x words fu zg c fz xg definition follows z corrects x c u z detects x c u also follows u x closed c cf convergence consequently starting state u x true every computation c reaches state z true cf progress moreover u z closed c cf stability remark witness predicate z identical correction predicate x definition corrects relation reduces one given arora gouda 10 considered general definition accommodate case occurs instance masking tolerance witness predicate z checked atomically correction predicate x cannot end remark properties corrects relation antisymmetric transitive first two arguments lemma 40 let x z state predicates c u state predicate closed c following statements hold ffl z corrects x c u x corrects z c u u ffl z corrects c u corrects x c u z corrects x c u lemma 41 let v state predicate u v closed c following statements hold ffl z corrects x c u z corrects x c u v ffl z corrects x c u v x zv corrects x c u compositions analogous detection predicates cannot witnessed atomically exist cases correction predicate x cannot corrected atomically ie executing one step action corrector correct predicates construct large correctors small correctors detectors parallel composition correctors parallel composition two correctors c1 c2 denoted c1c2 union variables actions programs c1 c2 theorem 42 let z1 correct x1 c1 u z2 correct x2 c2 u variables c1 c2 mutually exclusive z1z2 corrects x1x2 c1c2 u time taken c1c2 correct x1x2 maximum time taken correct x1 correct x2 space taken corresponding sum sequential composition correctors sequential composition correctors c1 c2 denoted c1 c2 program whose set variables union variables c1 c2 whose set actions union actions c1 z1 c2 theorem 43 let z1 correct x1 c1 u z2 correct x2 c2 u x1 variables c1 c2 mutually exclusive u z2 corrects x1x2 c1 c2 u time respectively space taken c1 c2 correct x1x2 sum time respectively space taken correct x1 correct x2 mentioned previous section one way design corrector x sequential composition detector corrector detector first detects whether x true using witness corrector establishes x theorem 44 let z detect x u z x correct x c u z 0 x closed fu zg c fz xg x corrects x z c u c atomic ie c satisfies progress convergence one step following corollary holds corollary 45 let z detect x u z x correct x c u z 0 x closed c atomic x corrects x c u another way design corrector x sequential composition corrector detector corrector first satisfies correction predicate x detector satisfies desired witness predicate z theorem 46 let x correct x c u z detect x u x closed z corrects x x c u atomic following corollary holds corollary 47 let x correct x c u z detect x u x closed c atomic z corrects x c u example memory access continued given address valid memory object form haddr gammai added memory omit details object obtained eg disk remote memory network thus corrector c formally specified follows addr d2 c figure 2 memory access thus may observe ffl x2 corrects x2 c true 4 ffl x2 corrects x2 c u1 5 ffl x2 corrects x2 c u1 x1 6 detector d2 witness value address memory corrector c execute hence compose c d2 sequentially corollary 47 2 6 ffl z2 corrects x2 c d2 u1 x1 7 moreover detector d1 witness address valid either corrector c detector d2 execute hence compose d1 c d2 sequentially recall section 3 z1 detects x1 d1 u1 also x1 closed d1 hence d1 started state satisfying u1 x1 eventually satisfy z1 follows z1 corrects x1 d1 u1 x1 therefore theorem 43 9 ffl z2 corrects x1 x2 d1 c d2 u1 x1 8 application design faulttolerance correctors suffice ensure computations program suffix problem specification see observe correction predicate corrector chosen invariant program corrector ensures program eventually reach state invariant true henceforth program computation problem specification design nonmasking tolerance f invariant need ensure upon starting state true execution p execution actions f always yield computation suffix problem specification follows correctors whose correction predicate invariant suffice design nonmasking tolerance likewise design masking tolerance f need ensure upon starting state true execution p presence f never violates safety specification execution p execution actions f always yields computation problem specification p latter guarantee suffices correctors added p former suffices detectors added p discussed previous section 5 composition detectorcorrector components programs section discuss detectorcorrector component correctly added program resulting program satisfies specification component far possible proof preservation simpler explicitly proving specification satisfied resulting program achieved compositional proof shows program interfere component ie program component executed concurrently violate specification component compositional proofs interferencefreedom received substantial attention formal methods community 15gamma19 last two decades drawing efforts identify several simple sufficient conditions ensure program p composed detector respectively corrector q safety specification q viz safeness stability liveness specification viz progress convergence violated sufficient conditions satisfying safety specification detector demonstrate p interfere safeness stability straightforward sufficient condition actions p subset actions q occurs instance program acts detector another straightforward condition variables p q disjoint general condition p reads writes variables q case p said superposed q sufficient conditions satisfying liveness specification detector three conditions given also suffice demonstrate p interfere progress q provided actions p q executed fairly yet another condition satisfying progress q require q atomic ie q achieves progress one step follows even p q execute concurrently progress q satisfied alternatively require p executes progress q achieved follows p cannot interfere progress q likewise require p terminates eventually follows p terminated execution q isolation satisfies progress generally require exists variant function f whose range wellfounded set execution action p q reduces value f progress q achieved follows even q executed concurrently p progress q satisfied sufficient conditions outlined formally stated table 1 sufficient conditions case corrector similar following theorems let z detect x q u let u closed p theorem 50 superposition q read write variable written p reads variables written q z detects x qp u theorem 51 containment actions p subset q z detects x qp u theorem 52 atomicity fu zg p fz xg q atomic z detects x qp u theorem 53 order execution fu zg p fz xg z detects x q p u theorem 54 termination fu zg p fz xg u converges v pq z detects x v pq u theorem 55 variant function fu 0f kg q f0f z detects x qp u table sufficient conditions interferencefreedom discussion addressed prove program interfere component component interfere program standard compositional techniques suffice purpose practice detectors snapshot procedures watchdog programs snooper programs typically read write state program added thus detectors interfere program likewise correctors reset rollback recovery forward recovery procedures typically restricted execute states invariant hand false thus correctors interfere program example memory access continued consider intolerant program p memory access assumes address valid currently present memory ease exposition let p access one memory location instead multiple locations thus p follows p interfere specification corrector d1 c d2 suffices p execute z2 witness predicate d1 c d2 satisfied hence d1 c d2 p composed sequence analogue theorem 53 case correctors p interfere d1 c d2 ffl z2 corrects x1 x2 d1 c d2 p u1 x1 6 designing multitolerance section first define multitolerance present method compositional stepwise design multitolerant programs let p program invariant f1fn n faultclasses l1 l2 ln types tolerance ie masking nonmasking failsafe say p multitolerant f1fn iff faultclass f j 1j n p ljtolerant f j definition may understood follows presence faults class f j p perturbed states f jspan predicate j true note exists potentially different faultspan faultclass faults f j stop occurring subsequent execution p always yields computation problem specification prescribed type tolerance lj example lj failsafe computation p starting state j true safety specification example memory access continued observe memory access program d1 c d2 p discussed section 5 multitolerant classes protection faults page faults failsafe tolerant former masking tolerant latter particular presence page fault always obtains correct data memory presence protection fault obtains data value compositional stepwise design method outlined introduction method starts faultintolerant program stepwise manner considers faultclasses fixed total order say f1fn first step intolerant program augmented detector andor corrector components l1tolerant f 1 resulting program augmented detectorcorrector components second step l2tolerant f2 l1tolerance f1 preserved nth step lntolerance fn added preserving l1lngamma1tolerances f1fngamma1 multitolerant program designed thus structure shown figure 3 detectors andor correctors fn faultintolerant program detectors andor correctors f1 detectors andor correctors f2 figure 3 structure multitolerant program designed using method first step let p intolerant program invariant calculating f 1span p detector corrector components designed satisfying l1tolerance f 1 discussed section 3 4 suffices add detectors design failsafe tolerance f 1 correctors design nonmasking tolerance f 1 detectors correctors design masking tolerance f 1 tolerant program nonmasking program failsafe correctors detectors correctors intolerant program masking tolerant program detectors tolerant figure 4 components suffice design various tolerances note detectors correctors added p also subject f hence tolerant f necessary masking tolerant f specifically suffices detectors added design failsafe tolerance failsafe tolerant f detectors satisfy liveness specification presence f resulting program made satisfy liveness specification p presence f likewise suffices correctors added design nonmasking tolerance nonmasking tolerant f long computations correctors suffixes safety liveness specification computations resulting program made suffixes safety liveness specification p lastly expected suffices detectors correctors added design masking tolerance masking tolerant f see figure 5 practice detectors correctors added p often possess desired tolerance f trivially one way design tolerant f analogous addition detectors correctors another way design self tolerant without using detector corrector components exemplified selfchecking selfstabilizing inherently faulttolerant designs tolerant program nonmasking components tolerant program intolerant program failsafe masking tolerant program nonmasking masking components figure 5 tolerance requirements components addition detector andor corrector components p remains show resulting program p1 components interfere p p interfere components note p1 may contain variables actions p hence invariants faultspans p1 may differ p therefore letting s1 invariant p1 t1 f 1span p1 s1 show following 1 absence f 1 ie states s1 true components interfere p ie computation p problem specification even executes concurrently new components 2 presence f 1 ie states t1 true p interfere components ie computation components components specification sense prescribed type tolerance even execute concurrently p addition detectors correctors may simplified using stepwise instance design masking tolerance may first augment program detectors augment resulting failsafe tolerant program correctors alternatively may first augment program correctors augment resulting nonmasking tolerant program detectors see figure 6 reasons space refer interested reader 20 formal details twostage approach designing masking tolerance000000000000000000000000000000000000000000000000000000111111111111111111111111111111111111111111111111111111111111111000000000000000000000000000000000000000000000000000000000000000111111111111111111111111111111111111111111111111111111tolerant masking tolerant program intolerant program correctors detectors program correctors program detectors failsafe nonmasking tolerant figure two approaches stepwise design masking tolerance second step step adds l2tolerance f2 preserves l1tolerance f 1 add l2 tolerance f 2 first step add new detector corrector components p1 account possible interference executions added components p1 specifically letting s2 invariant resulting program p2 t21 f 1span p2 s2 t22 denote f 2span p2 s2 show following 1 absence f1 f 2 ie states s2 true newly added components interfere p1 ie computation p1 problem specification even executes concurrently new components 2 presence f 2 ie states t22 true p1 interfere new com ponents ie computation new components new components specification sense prescribed type tolerance even execute concurrently p1 3 presence f 1 ie states t21 true newly added components interfere l1tolerance p1 f 1 ie computation p1 specification l1tolerant f 1 even p1 executes concurrently new components remaining steps remaining steps design add tolerance f3fn procedure second step generalized accordingly 7 case study multitolerance design token ring recall mutual exclusion problem multiple processes may access critical section provided time one process accessing critical section moreover process wait forever access critical section assuming process leaves critical section finite time mutual exclusion readily achieved circulating token among processes letting process enter critical section token token ring program particular processes organized ring token circulated along ring fixed direction case study design multitolerant token ring program program masking tolerant number k faults corrupt state process detectably tolerance continuous sense k state corruptions occur corrects state within thetak time thus quantitatively unique measure tolerance provided fk fk fault class causes k state corruptions processes detectable corruption state process mean corrupted state detected process action inadvertently accesses state state immediately corruption may however lost purposes irrelevant caused corruption ie whether due loss message duplication message timing faults crash subsequent restart process etc proceed follows first describe simple token ring program intolerant detectable state corruptions add detectors correctors achieve masking tolerance fault corrupts state one process progressively add detectors correctors achieve masking tolerance faultclass corrupts process states k k 1 times 71 faultintolerant binary token ring processes 0n organized ring token circulated along ring process j token successor j 1 section gamma modulo n1 process j maintains binary variable xj process j j 6 n token iff xj differs successor xj 1 process n token iff xn successor x0 program tr consists two actions process j formally actions follows invariant consider state process j token state since process token x value processes 0j identical x value processes j1n identical letting x denote string binary values x0 x1 xn x satisfies regular expression 0 l 1 n1gammal 1 l 0 n1gammal denotes sequence length n1 consisting zeros followed ones ones followed zeros thus invariant program tr 72 adding tolerance 1 state corruption based assumption state corruption detectable introduce special value process j detects state ie value xj corrupted resets xj readily design masking tolerance single corruption state process j ensuring value xj eventually corrected longer ii interim process particular j1 inadvertently gets token result corruption xj add corrector process j corrects xj value either 0 1 corrector j j 6 0 copies xj gamma 1 corrector corrector action j statement action tr j merge corrector tr actions ii add detector process detection predicate actions witness predicate detector case detection predicate used restrict actions program tr j hence actions tr j execute result execution actions tr always safe ie actions cannot inadvertently generate token augmented program ptr fault actions state xj corrupted xj set hence fault action proof interferencefreedom starting state tr true presence faults set x value process string x always satisfies regular expression 0 l 1 n1gammal 1 l 0 n1gammal thus invariant ptr sptr consider detector j detection witness predicates xj gamma 1 6 since detects relation trivially reflexive first two arguments follows ptr words detector interfered actions consider corrector j correction witness predicates xj 6 since program actions identical corrector actions theorem 51 corrector actions interfered actions tr also since detectors actions detectors processes j interfere corrector j moreover since one x value set xj thus corrector j enabled witness predicate detector j true hence corrector j interfered detector j consider program actions tr safety follows safety detectors described progress follows progress correctors ensure starting state sptr true process state corrupted every computation ptr reaches state tr true progress detectors ensures action tr indefinitely blocked executing observe proof mutual interferencefreedom illustrates reprove correctness tr new invariant observe also state process j corrupted within theta1 time corrector j corrects state j 73 adding tolerance 2n state corruptions proof noninterference program ptr generalized show ptr also masking tolerant faultclass twice corrupts process state generalization selfevident case state corruptions separated time first one corrected second one occurs case state corruptions occur concurrently say processes j k need show correctors j k truthify interference actions program let us consider two subcases j k nonneighboring ii j k neighboring first subcase j k correct xj xk predecessors jgamma1 kgamma1 respectively execution equivalent parallel composition correctors j k theorem 42 ptr reaches state xj xk second subcase letting j predessor k j corrects xj predecessor truthifies xj 6 terminates since corrector j read variables written corrector k thus analogue theorem 50 case correctors corrector j interfered corrector k xj 6 truthified corrector k corrects xk predecessor j theorem 44 corrector k interfered corrector j since correctors j k interfere follows program reaches state xj xk fact long number faults n exists least one process j xj 6 ptr ensures state j eventually causes j1 correct state xj corrections continue process x value set hence ptr tolerates n faults time required converge tr thetak k number faults 74 adding tolerance n state corruptions unfortunately n faults occur program ptr deadlocks iff reaches state x value processes masking tolerant faultclasses corrupt state processes n times corrector needed detects whether state processes corrects program state x value process say 0 equal 0 1 since x values processes cannot accessed simultaneously corrector detects sequential manner whether x values processes let detector added purpose process j denoted dj sequentially composed detector detects whether x values processes corrupted dn design dj add value domain xj dn detects xn equal sets xn likewise dj detects xj equal sets xj note since dj part sequential composition restricted execute j1 completed detection ie xj1 equal follows j completes detection x values processes jn corrupted particular d0 completes detection x values processes corrupted hence x0 set suffices corrector reset x0 0 ensure corrector executing process inadvertently gets token result corruption xj add detectors restrict actions ptr j1 execute states xj 6 true actions program ftr consists five actions process j like ptr first two actions ftr1 ftr2 pass token j j1 restricted trivial detectors execute xj gamma1 neither action ftr3 dn lets process n change xn action ftr4 dj j n action ftr5 corrector action process 0 lets process correct x0 0 formally actions follows invariant starting state sptr true detector change trailing values x thus ftr may reach state x satisfies regular expression 1 l 0 subsequent state corruptions may perturb x form 1 l 0 n1gammalgammam 0 l 1 n1gammalgammam since actions preserve last predicate invariant ftr 0 proof interferencefreedom design ftr added corrector actions ftr3 gamma 5 program ptr ensure j xj corrupted ie correction predicate corrector v corrector form dn dngamma1 d0 c0 dj atomic detector process j c0 atomic corrector process 0 detection predicate dn v witness predicate x0 show detector isolation satisfies specification observe 1 xn detects dn sftr 2 sftr 1 2 theorem 33 xn gamma1 detects using argument x0 detects dn observe sftr converges v dn violated execution eventually truthify x0 execution c0 truthify v thus v corrects v dn corrector interfered actions ftr1 ftr2 follows fact ftr1 ftr2 interfere dj c0 using theorem 52 program ftr also added detector process j detects xjgamma1 6 described 1 fault case detector interfere actions interfered actions finally consider actions program ptr safety follows safety detector described also starting state sftr program reaches state x value process corrupted starting state program ptr eventually program reaches state tr truthified ie action ptr permanently blocked thus progress actions follows theorem 70 program ftr masking tolerant invariant sftr faultclasses fk k 1 fk detectably corrupts process states k times moreover sftr converges tr ftr within thetak time remark emphasize program ftr masking tolerant faultclasses fk invariant sftr tr thus presence faults fk sftr continues true although tr may violated process j j n token iff xj differs xj1 neither xj xj1 corrupted process n token iff xn x0 neither xn x0 corrupted thus state sftr true one process token also starting state eventually program reaches state tr true starting state process get token thus starting state sftr computations ftr problem specification token ring section address issues method design multitolerance raised also discuss motivation design decisions made work formalization concept multitolerance uses abstractions closure convergence abstractions used formalize multitolerance advantages using closure convergence principle one formulate concept multitolerance using abstractions closure convergence pointed john rushby 21 approaches formulate faulttolerance classified two specification approaches calculational approaches specification approaches system regarded composition several subsystems standard specification one failure specifications system faulttolerant satisfies standard specification components one failure specifications components depart standard specification one example approach due herlihy wing 22 thus formulate graceful degradation special case multitolerance calculational approaches set computations permissible presence faults calculated system said faulttolerant set satisfies specification system acceptably degraded version approach calculational since compute set states potentially reachable presence faults faultspan approaches may used formulate design multitolerance aware formal methods design multitolerance using moreover experience structure imposed abstractions closure convergence proven beneficial several ways 1 enabled us discover role detectors correctors design tolerance properties cf sections 3 4 2 yielded simple theorems composing tolerance actions underlying actions interferencefree manner cf sections 5 6 3 facilitated design novel complex distributed programs whose tolerances exceed comparable programs designed otherwise 5 10 20 23 24 25 represented faults state perturbations representation readily handles transient faults also handle permanent faults intermittent faults detectable faults undetectable faults indeed represented state perturbations token ring case study illustrates use state perturbations various classes transient faults extended version paper 24 present case study treebased mutual exclusion illustrates analogous representation permanent faults detectable undetectable faults worth pointing representing permanent intermittent faults byzantine faults failstop repair faults may require introduction auxiliary variables 5 10 example represent byzantine faults affects process j may introduce auxiliary boolean variable byzj true iff j byzantine j byzantine executes normal actions otherwise executes abnormal actions byzantine fault occurs byzj truthified thus permitting j execute abnormal actions similarly represent failstop repair faults affects process j may introduce auxiliary boolean variable downj true iff j failstopped actions j restricted executed downj false failstop fault occurs downj truthified thus preventing j executing actions repair occurs downj falsified assumed problem specifications suffix closed fusion closed assumptions exploited design method assumptions restrict applicability method used assumptions three places 1 suffix closure problem specifications implies existence invariant state predicates 2 fusion closure problem specifications implies existence correction state predicates 3 suffix closure fusion closure problem specifications imply corresponding safety specifications fusion closed turn implies existence detection state predicates assumptions restrictive following sense let l set state sequences suffix closed andor fusion closed let p program shown adding history variables variables p exists problem specification l 0 following condition holds computations p start states initial state predicate true l iff p satisfies l 0 state predicate thus language problem specifications restrictive would method considering faultclasses oneatatime compare method considers altogether sense oneatatime altogether methods equivalent programs designed one method also designed method justify informally let us consider program p designed using altogether method tolerate faultclasses f 1 f 2 fn program p also designed using oneatatime method follows let p1 subprogram p tolerates f 1 program designed first stage oneatatime method likewise let p2 subprogram p tolerates f1 f 2 program designed second stage oneatatime method p designed complete argument equivalence remains observe program designed oneatatime nstage method trivially designed altogether method terms software engineering practice however two methods would exhibit differences towards identifying differences address three issues structure programs designed using two methods ii complexity using iii complexity programs designed using first issue stepwise method may yield programs better structured exemplified hierarchical token ring program consists three layers basic program transmits token corrector case least one process corrupted corrector case processes corrupted second issue since consider one faultclass time complexity step less complexity altogether program example token ring program first handled case state process corrupted handled case state processes corrupted thus step simpler case would need consider cases simultaneously third issue possible considering faultclasses time may yield program whose complexity sense optimal respect faultclass whereas oneat atime approach may yield program optimal faultclasses suggests two considerations use method one order faultclasses considered chosen care principle programs designed one order designed order practice different orders may yield different programs complexity programs may different two choosing design tolerance particular faultclass lookahead may warranted impact design choice design tolerances remaining faultclasses compositional method affect tradeoffs dependability properties method makes possible reason tradeoffs locally ie focusing attention components corresponding dependability properties opposed globally ie considering entire program thus method facilitates reasoning tradeoffs dependability properties moreover expected desired dependability properties impossibility cosatisfy follow exist components added program complying interferencefreedom requirements method compositional design method compare existing methods designing faulttolerant programs compositional design method rich sense subsumes various existing faulttolerance design methods replication checkpointing recovery schneiders state machine approach exception handling randells recovery blocks interested reader referred 20 24 detailed discussion properties replication agreement order designed interferencefree composition within method faultclasses derived method used difficult characterize faults system subject derivation faultclasses application specific begins identification faults program may subject faults formally characterized using state perturbations mentioned auxiliary variables may introduced formalization desired type tolerance fault specified finally faults grouped possibly overlapping faultclasses based characteristics faults corresponding types tolerance difficult characterize faults application user method obliged guess large enough faultclass would accommodate possible faults often reason designers choose weak models selfstabilization state may perturbed arbitrarily byzantine failure program may behave arbitrarily 9 concluding remarks future work paper formalized notion multitolerance abstract variety problems de pendability worthwhile point multitolerance related applications well one reason graceful degradation respect progressively increasing faultclasses another guarantee different qualities service qos respect different user requirements traffics third one reason adaptivity systems respect different modes environment behavior also presented simple compositional method designing multitolerant programs added detector corrector components providing desired type tolerance addition multiple components intolerant program made tractable adding tolerances fault classes one time avoid reproving correctness program every step provided theory ensuring mutual interferencefreedom compositions detectors correctors intolerant program knowledge first formal method design multitolerant programs method effective design quantitative well qualitative tolerances example quantitative tolerance presented token ring protocol recovers upto k faults time examples qualitative tolerances refer interested reader designs multitolerant programs barrier computations repetitive byzantine agreement mutual exclusion tree maintenance leader election boundedspace distributed reset termination detection 23 apply design method practice currently developing siefast simulation implementation environment enables stepwise implementation validation multitolerant distributed programs also studying mechanical synthesis multitolerant concurrent programs acknowledgments indebted anonymous referees detailed constructive comments earlier versions paper significantly improved presentation thanks also laurie dillon help review process r reliable computer systems design evaluation att case galileo case foundation faulttolerant computing superstabilzing protocols dynamic distributed systems maximal flow routing highly safe selfstabilizing mutual exclusion algorithm defining liveness closure convergence foundation faulttolerant computing discipline programming science programming proving boolean combinations deterministic properties parallel program design foundation existence refinement mappings proof technique communicating sequential processes stepwise refinement parallel programs proofs networks processes axiomatic proof technique parallel programs designing masking faulttolerance via nonmasking faulttolerance critical system properties survey taxonomy specifying graceful degradation multitolerance distributed reset multitolerance design constraint satisfaction basis designing nonmasking faulttolerance multitolerant barrier synchronization compositional design multitolerant repetitive byzantine agreement tr ctr anil hanumantharaya purnendu sinha anjali agarwal componentbased design compositional verification faulttolerant multimedia communication protocol realtime imaging v9 n6 p401422 december orna raz mary shaw approach preserving sufficient correctness open resource coalitions proceedings 10th international workshop software specification design p159 november 0507 2000 anish arora sandeep kulkarni murat demirbas resettable vector clocks proceedings nineteenth annual acm symposium principles distributed computing p269278 july 1619 2000 portland oregon united states anish arora sandeep kulkarni murat demirbas resettable vector clocks journal parallel distributed computing v66 n2 p221237 february 2006 paul c attie anish arora e allen emerson synthesis faulttolerant concurrent programs acm transactions programming languages systems toplas v26 n1 p125185 january 2004 robyn r lutz software engineering safety roadmap proceedings conference future software engineering p213226 june 0411 2000 limerick ireland anish arora marvin theimer modeling tolerating incorrect software journal high speed networks v14 n2 p109134 april 2005 iling yen farokh b bastani david j taylor design multiinvariant data structures robust shared accesses multiprocessor systems ieee transactions software engineering v27 n3 p193207 march 2001 anish arora paul c attie e allen emerson synthesis faulttolerant concurrent programs proceedings seventeenth annual acm symposium principles distributed computing p173182 june 28july 02 1998 puerto vallarta mexico axel van lamsweerde emmanuel letier handling obstacles goaloriented requirements engineering ieee transactions software engineering v26 n10 p9781005 october 2000 vina ermagan junichi mizutani kentaro oguchi david weir towards modelbased failuremanagement automotive software proceedings 4th international workshop software engineering automotive systems p8 may 2026 2007 felix c grtner fundamentals faulttolerant distributed computing asynchronous environments acm computing surveys csur v31 n1 p126 march 1999 anish arora sandeep kulkarni designing masking faulttolerance via nonmasking faulttolerance ieee transactions software engineering v24 n6 p435450 june 1998
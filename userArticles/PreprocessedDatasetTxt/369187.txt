optimal sequencing hybridization rounds sequencing hybridization sbh method reconstructing sequence small finite alphabet collection probes substrings substring queries arranged array sbh chip combinatorial method used construct sequence collection probes technological constraints limit number substring queries placed single sbh chip develop idea margaritis skiena propose algorithm uses series small sbh chips sequence long strings number probes used matches information theoretical lower bound constant factor b introduction consider following problem let alphabet letters given string drawn uniformly random n ability ask queries type x substring minimum set questions one ask high probability one reconstruct problem abstraction problem occurs sequencing dna molecules dna strands seen sequences drawn four letter alphabet nucleotides fa c g tg sequencing hybridization sbh bains smith 1988 drmanac et al 1989 lysov et al 1998 proposed alternative traditional gilbertsanger method sequencing gel electrophoresis surveys chetverin cramer 1994 pevzner lipshutz 1994 give overview technological algorithmic aspects method method applies complementary watsoncrick base pairing dna molecules given single stranded dna molecule hybridize complement strand sbh based use chip fabricated using photolithographic techniques active area chip structured matrix region assigned specic oligonucleotide biochemically attached chip surface solution uorescently tagged target dna fragments exposed chip fragments hybridize complementary fragment chip hybridized fragments identied using uorescence detector hybridization lack thereof determines whether fragment substring target string formulation assume hybridization chips give us answer ternary query whether string occur occurs occurs classical sequencing chip design cm contains single stranded oligonucleotides xed length pevzners algorithm pevzner 1989 reconstruction using classical sequencing chips interprets results sequencing experiment subgraph debruijn graph eulerian path corresponds possible sequence reconstruction therefore unique unless eulerian path unique examples found show order uniquely reconstruct members n using classical sequencing chip cm needs greater nsee skiena sundaram 1995 pevzner et al 1991 show experimentally classical c8 chip contains 65536 oligonucleotides suces reconstruct 200 nucleotide sequences 94 100 cases dyer et al 1994 arratia et al 1996 shown independently cm eective random strings length n needs chosen greater 2 log n words constant probability reconstruct string length n drawn uniformly random n using classical hybridization chip chip must contain least substrings compares information theoretical lower bound number ternary queries needed distinguish n elements n variety dierent methods suggested overcome negative results classical sbh chips using assumption universal dna bases synthesized preparata et al preparata et al 1999 preparata upfal 2000 give scheme size chip optimal ie broude et al 1994 suggest generating positional information along hybridization information psbh psbh analyzed algorithmically hannenhalli et al hannenhalli et al 1996 show nphardness general problem give ecient algorithm positional information constant model analyzed bendor et al bendor et al 1999 drmanac et al 1989 suggested sequencing large sequences obtaining spectra many overlapping fragments model analyzed algorithmically arratia et al 1996 giving bounds probability unique reconstruction shamir tsur 2001 recently improved analysis arratia et al 1996 furthermore gave algorithm case false negative errors occurred hybridization sequencing hybridization rounds interactive sequencing hybridization rst considered margaritis skiena 1995 assumption sequencing queries done adaptively results one hybridization round known new chip constructed original paper margaritis skiena give number upper lower bounds number rounds needed dependent number probes allowed round among results algorithm reconstructs sequence high probability using olog n chips containing queries main result paper improves result papers written isbh skiena sundaram 1995 showed single query could asked round nrounds necessary 1n rounds sucient string reconstruction kruglyak kruglyak 1998 gave algorithm worst case performance guarantee shows olog n rounds sucient queries placed chip round following theorem main result paper theorem 11 high probability string drawn uniformly random n reconstructed sequentially using seven hybridization chips containing substring queries notice result optimal number queries information theoretical sense constant multiple algorithm proceeds following manner initial step ask substring queries corresponding classical sbh chip construct debruijn graph way suggested pevzner proceed ask targeted queries order unravel string main result paper mathematical although may eventually practical relevance sequencing chips similar classical chips already production hyseq inc holds several patents procedure drmanac crkvenjakov 1993 chips used successfully denovo sequencing drmanac et al 1993 sequenc ing sequence unknown given many organisms sequenced another problem practical importance resequencing hybridization drmanac et al 1989 peer shamir 2000 problem template sequence known goal sequencing determine specic mutational variants sequence machines producing oligonucleotide arrays using inkjet printer technology pioneered blanchard et al 1996 currently manufactured agilent technologies technology may prove particularly useful interactive sequencing hybridization review dierent technologies dna array manufacturing see blanchard 1998 schena 1999 relevant technologies include aymetrix type arrays lockhart et al 1996 fodor et al 1991 southern array makers developed oxford gene technologies southern 1996 note technological constraints need considered practical implementation method developed paper particular realistic case false positive negative errors occur experiments needs considered organization paper follows next section give overview previous work motivate algorithm give simplied version section 3 give complete algorithm verify correctness section 4 prove complexity result section 5 demonstrate computational experience ctg figure 1 debruijngraph constructed substrings length 3 agc gct tgc ctg gca cat one occurs motivation basic algorithm 21 debruijn graphs section review debruijn graph construction rst considered pevzner unknown target string given answer ternary query strings r length whether r occurs construct associated edgelabeled digraph following manner vertex set consists edge x 1 2g case edge labeled 1 x 1 occurs 2 x 1 occurs follows call debruijn graph figure 1 shows construction debruijn graph also label nodes node x labeled 0 outedges labeled 1 one inedge one outedge labeled 1 labeled 2 otherwise let x denote label nodeedge x note unique path substring x k 1 namely path starting x 1 ending x k m2 x traverses edges x x 1g denote path px refer path corresponding x special case k 1 refer nodeedge corresponding x pevzner showed corresponds eulerian path graph dene eulerian path graph walk traverses edges label 1 exactly edges label 2 least twice graph figure 1 tell original string agctgcat gc gc gca gc gca gcat gc gca figure 2 examples mapping px ctg figure 3 debruijngraph constructed substrings length 3 agc gct cgc gcg tgc ctg gca cat one occurs debruijn graph may however one eulerian path case construction string ambiguous see figure 3 22 simplied algorithm algorithm proceeds constructing debruijn graph substrings xed length use information graph construct set substring queries enable us determine substrings length number larger iterate process noticing probability path increases ie attempt elongate strings corresponding nodes debruijn graph motivate algorithm let us look ambiguities elongation process notice node x debruijn graph label 1 strings corresponding outedges occurs elongation string corresponding inedge x hence unambiguous determined appending last character string corresponding outedge example graph tagt know string catagt occurs however node x one outedge need pair inedges outedges atac figure 4 node two outedges graph figure 4 tell two strings cataca catacg gacaca gacacg occur ones determine substrings length six would ask substring queries strings central question remainder paper determine conditions number queries generated way large edges graph labeled 1 would unique elongation determine elongation string catac k characters would sucient determine whether catac elongates cataca catacg determine elongation ataca atacg characters however catac elongates catacg atacg occurs two times atacg two elongations length k 1 cannot determine elongation catac see determine elongation particular edge e k characters sucient determine paths e either 1 length k 2 shorter end edge multiplicity one motivates denition cluster collection nodes edges label 2 eulerian path passes nodes edges label 2 determination string biguous set clusters graph set ambiguous parts graph denition 21 cluster containing x clx maximal connected subgraph containing x nodes edges task determine thought determining eulerian path start node end node notice internal node edge labeled 1 unique occurrence therefore unique elongation assuming know nodes start node end node reconstruct determining path start node edge labeled 1 determine continuation eulerian path edge unique elongation either another edge label 1 end node motivates following algorithm reconstructing let c positive constant q set queries placed dna chip algorithm 1 step 1 classical sbh chip ne ask queries q construct step 2 resolve ambiguities let c c choose node x c let c clx c let q set strings 1g step 3 reconstruct debruijn graph answers queries q 23 potential pitfalls let us look complications may face analysis algorithm cycle debruijn graph cannot determine whether given string passes cycle past add queries possible strings may cause us ask large number queries cycle example figure 5 loop aaa edge aaa aac label 2 cannot determine graph aaaa figure 5 example cluster along edges cluster nodes edges label 2 two strings taaaca taaact taaaaca taaaact caaaca caaact caaaaca caaaact occur algorithm add queries taaaa caaaa taaaca taaact caaaca taaaca aaaaca aaaact edge aaaa occurs graph rst determine whether taaaa caaaa occurs determine occurrence taaaaca taaaact caaaaca taaaact strings aaaaca aaaact occurs cluster contains cycles number queries generated algorithm grow number inedges times number outedges cluster cluster contains cycles may able determine often given path traverses cycle contains multiple cycles holds true one number queries generated algorithm may therefore grow exponentially number cycles cluster notice occurrence string corresponding node graph highly correlated occurrence strings corresponding neighbors interdependence makes algorithm dicult analyze complex clusters require large number queries reasonable probability occurring average number queries generated algorithm may fact large modied algorithm modify previous algorithm make limited number queries initiating given node graph using two rounds queries may hence able determine show high probability seven rounds sucient use following modication step 2 notice also modied version doesnt assume prior knowledge start end nodes add queries starting node cluster terminating node let k times let q set strings ask queries q construct 31 correctness algorithm let us clarify statement theorem 11 denition 31 say event occurs high probability whp occurs probability 1 o1 n 1 lemma 31 number substring queries generated algorithm satisfying conditions theorem 11 optimal information theoretical sense constant multiple proof n strings length n high probability sequence strings must able distinguish strings 3 possible answers ternary queries n algorithm generates o1 queries verify algorithm correct ie whp reconstructs lemma 32 single iteration step 2 0 allow us construct b applying step 2 0 whp reconstruct proof substring x length add query possible elongations either length k 0 x string multiplicity one case elongation x determined unique elongation b follows result arratia et al 1996 dyer et al 1994 whp debruijn graph random 2 n 4 complexity analysis proceed estimate expected number queries iteration main goal section prove following lemma lemma 41 expected number queries q generated single iteration step 2 0 start dening normal nodes section 41 show queries generated originating normal node form tree section 42 bound number trees section 43 consider relationship trees substrings section 44 summarize upper bound expected number queries generated originating normal strings section 45 show rare node normal hence prove lemma 41 finally section 46 show concentration expectation number queries 41 normal substrings denition 41 every node x 2 dene subgraph l x edge vertex sets sets edges vertices reachable x path x 1 1g say x l x normal l x tree contain end substrings p maximally maps 1 l x occur disjointly notice denition normal refers substrings ie node normal depending string example figure 5 l taa graph shown except node caa edge caaa l taa normal since contains cycle figure 6 shows laac 42 counting number trees bound expected number queries q whose initial string x l x normal notice case algorithm step 2 0 generate one query initial string x every node l x x 1 ie collection fy substring relation aaca aca act figure example figure 5 consider laac normal form aacaaact denotes string normal form aacaact since two strings overlap children also notice denition 41 l x normal contain cycle must therefore tree denition 42 say ary tree node children b ltree b branching nodes nodes one child single child nodes l leaves children node considered ordered make distinction two children node based ordering count expected number queries whose initial string x counting number dierent b ltrees section 43 estimating probability l x tree lemma 42 number distinct b ltrees proof number trees b branching nodes l leaves 1k1 since less number ary trees size k see knuth 1968 ex 234411 insert internal nonbranching nodes tree subdividing one existing edges tree adding new single child root node choice put internal nodes done ik 1 ways outedges internal nodes chosen ways 43 trees strings estimate probability l x takes form tree multiply number queries generated l x takes form avoid signicant overcounting number queries initial string x count number queries terminating leaf nodes queries initial string x terminate internal nodes counted estimating number queries generated l x takes form one subtrees dene partial ordering trees partial ordering ensures count queries internal nodes well denition 43 subtree 0 labeled tree incubating subtree node v either none children v occur 0 note denition children given node must removed time rephrasing descends 0 series incubation operations children given node appear operation purpose proof important thing note node leaf node incubating subtree following observation immediate denition 41 normal denition 43 lemma 43 given collection c nodes normal l x predecessor z exist disjoint substrings corresponding nodes c particular collection leaves incubating subtree l x collection relate trees l x substrings following definition gives minimal requirement occurrence strings corresponding nodes l x denition 44 say collection c strings string decomposition tree string corresponding edge occurs substring c strings corresponding edges incident root leaves occur twice substrings c string requirement labeling tree dened labeling e root edge edge branching node leaf otherwise 2 e le e b le show upper bound probability l x takes form four steps first give algorithm returns particular type string decomposition bound number possible string decompositions generated algorithm xed tree go bound probability contains disjointly given string decomposition finally show l x normal takes form incubating subtree contains disjointly substrings form one string decompositions generated algorithm let us x node x x given b xed integers b l furthermore let us dene mapping subgraph complete debruijn graph name root node x let us name nodes graph follows notice denition b ltrees node children make distinction two based predened ordering children therefore talk k th child node k number 1 possibly greater number xs children z k th child node named 1 edge 1 k th letter alphabet following algorithm generates string decomposition algorithm 2 label using string requirement labeling def 44 preorder nodes initialize c empty collection 9 e le 0 let v lowest ordered node positively labeled outedge e choose v nonleaf choose e one outedges v append character corresponding e add collection c return c rst upper bound number string decompositions generated algorithm lemma 44 number possible string decompositions generated algorithm 2 bounded r 2i1 number internal nonbranching nodes r dened denition 44 proof let us count number choices made algorithm let v branching node k sum labels vs outedges algorithm 2 arrive k times v whenever v chosen outer loop one vs outedge labels gets decreased one since inedge v label two arrive twice v inner loop rst time arrive v inner loop outedges v positive labels one decreased second time arrive v inner loop may choose edge chosen last time arrive v outer loop choice edge traverse times choice edge traverse number choices clearly less arrive node single child choice edge traverse next number string decompositions therefore b set branching nodes inequality veried noting labels outedges nodes one child always two except case root one child upper bound probability string decomposition lemma 45 c collection strings generated algorithm 2 probability strings c occur disjointly substrings upper bounded l r proof let set strings lemma 43 jdj l originally chosen strings length 1 furthermore append least r extra characters note probability string length j occurring n probability strings occurring bounded x2d jxj l x2d 1jxj l r relate l x string lemma 46 incubating subtree normal l x contains disjointly one collections generated algorithm 2 proof based actual string show algorithm 2 made construct collection disjoint substring denition normal incubating subtree l x l x normal e edge labeled k algorithm 2 must contain least k disjoint substrings corresponding e outer loop algorithm 2 hence always choose substring disjoint previously chosen let correspond inner loop make choice e based next characters j1 onwards ie j1 k e chosen kth child v since l x normal end string occur l x choice child hence always well dened since incubating subtree l x choice never return edge terminate leaf node 44 number normal queries combining results lemmas 42 44 45 gives following lemma lemma 47 probability l x contains b ltree incubating subtree l i1 l lemma 48 let large enough e 1 expected size set queries qn added q corresponding normal strings x bounded ne proof estimate expected number queries multiplying number nodes x probability l x b incubating subtree number leaves l summing b notice l b 1 get expected number queries q multiply number nodes sum possible ks number queries added tree b multiplied probability tree possible ks number ways choose initial node x ejqn 1x ne second inequality follows series algebraic manipulations noting k e k second equality well known identity geometric series rst equality less well known observed dierentiating identity geometric series k times slomson 1991 shown queries generated nodes x graph l x normal 45 remaining cases show unlikely l x normal use fact maximum number queries generated algorithm initial string corresponding given node graph bounded let us introduce terminology denition 45 1 say string 2 core string corresponds node node string substring x occurs substring node strings l x ie x k 0 cases l x normal end occurs l x l x cycle string decomposition l x consists strings nondisjoint end occur l x x number queries containing string corresponding end substring hence bounded 2 depth l x bounded k contains cycle period cycle must also bounded k 0 1 core x must therefore period k occurs node strings l x core x period less k call x lowperiodic core string simplify presentation also consider strings periodic period less 1log ne lowperiodic core strings extensions node string x appear disjointly core x occur twice starting positions j ji jj mk 0 1 1 length node strings current iteration step condition may therefore rewritten ji jj olog n happens say core x selfrepetitive count expected number queries q consider four cases first count expected number queries stemming strings lowperiodic core expected number elongations strings selfrepetitive core given core lowperiodic remainder strings normal terminal string occurring l x count number queries q originate low periodic core strings number node strings core period k determined degrees freedom outside core k 0 1 plus degrees freedom inside core k therefore k 0 k1 number extensions lowperiodic core node string hence 1log ne 1log nek1 1 look number query strings originating node strings whose core selfrepetitive lowperiodic expected number cores selfrepetitive lowperiodic number places rst core start number places second core start rst core bounded n olog n 1log ne log n expected number strings selfrepetitive core hence bounded 7 log n expected number queries added q case hence bounded 9 using lemma 48 shown lemma 41 expected number queries generated step 2 0 bounded ne 46 concentration expectation use azumas inequality see alon spencer 1992 show high probability step 2 0 linear number queries lemma 49 high probability queries added q iteration step 2 0 proof view sequence n independent random trials one characters want bound number queries may added removed q change one character changing one character may eect ne 5 log n strings denotes length node strings current iteration step 2 0 seen rst choosing position character change query string noting length query string c character changed let r m2 r characters immediately preceding following c q query string aected character change length q path q corresponds must pass one nodes corresponding substrings length 1 containing c particular character change occurred jth position q j 1 q characters positions characters position character rst positions characters character cases strings aected azumas equality 5 log n 2 putting completes proof computational results choice k 0 1log ne previous section done ease presentation may chosen slightly larger decrease number rounds test practicality method implemented variant algorithm presented stringent algorithm analyzed closer original algorithm step 2 variant limited length queries largest l total number queries round limited instead limiting length xed k 0 words step 2 modied line let q set strings v l chosen large possible ask queries q table 1 shows number sbh chips used base pairs generated randomly number query rounds signicantly lower number rounds guaranteed worstcase performance guarantee algorithm see initially use classical sbh chip containing oligonucleotides size dlog 4 ne 1 nish sequencing dna less 4n extra queries using single chip examples table 2 shows number sbh chips used sequence arbitrarily chosen virus sequences one examples algorithm sequence dna using classical chip containing strings length log extra round 4n queries 6 acknowledgements authors would like rravi magnus halldorsson dan iel f gudbjartsson anonymous referees reviewing paper alan frieze supported part nsf grant ccr9818411 bjarni v halldorsson supported merck computational biology chemistry program graduate fellowship merck company foundation r probabilistic method poisson process approximation sequence repeats novel method nucleic acid sequence determination complexity positional sequencing hybridization paterson synthetic dna arrays oligonucleotide arrays new concepts possibilities dna sequnence determination hybridization strategy ecien large scale sequencing probability unique solutions sequencing hybridization positional sequencing hybridization art computer programming fundamental algo rithms multistage sequencing hybridization expression monitoring hybridization highdensity oligonucleotide arrays spectrum alignment ecient resequencing hybridization towards dnasequencing hybridiza tion improved chips sequencing hybridization journal biomolecular structure dynamics optimal reconstruction sequence probes dna microarrays large scale sequencing hybridization reconstructing strings substrings journal computational biology dna chips analyzing sequence hybridization oligonucleotides large scale tr art computer programming volume 1 3rd ed sequencingbyhybridization informationtheory bound towards dna sequencing chips reconstructing strings substrings rounds ctr steven skiena sagi snir restricting sbh ambiguity via restriction enzymes discrete applied mathematics v155 n67 p857867 april 2007 eran halperin shay halperin tzvika hartman ron shamir handling long targets errors sequencing hybridization proceedings sixth annual international conference computational biology p176185 april 1821 2002 washington dc usa
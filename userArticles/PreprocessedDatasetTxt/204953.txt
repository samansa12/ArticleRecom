search problems decision tree model relative power determinism randomness nondeterminism search problems boolean decision tree model studied shown gaps nondeterministic randomized deterministic complexities arbitrarily large search problems interesting connection model complexity resolution proofs also mentioned b introduction ramseys theorem asserts every graph n vertices either complete graph independent set size 1log n natural search problem associated theorem find subgraph many problems like ones similar flavor given assignment n pigeons find two pigeons assigned hole given kchromatic graph coloring nodes fewer k colors find two neighbors color given unsatisfiable 3cnf formula assignment variables find clause satisfied hard solve search problems answer depends course representation computational model assume input encoded binary allowed probe input bits gives familiar boolean decision tree princeton university eotvos lorand university budapest weizmann institute part work done author ibm almaden research center z dimacs center hebrew u jerusalem x princeton university hebrew u jerusalem model adapted solving search problems rather computing boolean functions study relationship standard nondeterministic probabilistic deterministic variants model discover drastically different case function computation three measures polynomially related see 2 7 19 14 examples listed easy guess verify solution hence nondeterministic decision tree complexity small constant polylog decision tree computing function would imply randomized deterministic complexities small fact deterministic complexity thus randomized square nondeterministic complexity 2 7 19 turns search problems gaps arbitrary large investigation partly motivated similar study search problems communication complexity setting work karchmer wigderson 11 raz 18 similar phenomenon occurs extent another study search problems carried papadimitriou 15 complexity classes defined search problems investigated examples inspired work 8 10 examples may remind readers resolution proofs indeed resolution proofs viewed top yield boolean decision trees search problems fact seems folklore elaborated appendix thus exponential length lower bounds resolution proofs see eg 4 provide linear deterministic lower bounds even nondeterministic complexity constant however distinction resolution decision tree points view becomes clear trying make sense probabilistic model resolution one proves simultaneously every assignment falsifies clause unsatisfiable formula natural probabilistic analog decision tree approach one must find given input assignment clause falsifies natural randomized version indeed primarily concerned power probabilistic computation problems prove probabilistic complexity ends spectrum give explicit search problem probabilistic nondeterministic complexity constant deterministic linear hand provide two explicit problems large gap nondeterministic probabilistic complexities one first constant second 6 another first olog n second nearly linear finally present explicit problem simultaneous exponential gap nondeterministic versus randomized randomized versus deterministic complexities last example uses upper bound due irani 9 online coloring algorithms provide lower bound deterministic complexity note far know simultaneous gaps known model computation special case nondeterministic complexity 2 deserves special interest corresponds unsatisfiable 2cnf formulae characterize deterministic complexity structure formula note never exceed 1 log n show gap randomized complexity nondeterministic gap randomized complexity deterministic arbitrarily large paper organized follows section 2 give formal definitions search problems decision trees show cnf search problem complete variants decision trees section 3 construct search problems large gap deterministic randomized complexity randomized nondeterministic complexity simultaneous nondeterministic randomized deterministic complexity gaps section 4 discuss special case nondeterministic complexity 2 exact relationship resolution problem appears appendix search problem specified n variables collection witnesses addition collection must property every assignment n variables associated least one witness given input string assignment n variables goal find witness consistent formally definition 21 search problem n variables relation f f0 1g n theta w w finite set called set witnesses goal search input x 2 f0 1g n find w 2 w x w 2 f call w valid witness x special class search problems come dnf tautologies monomial conjunction literals variable set x let g dnf tautology set monomials g true every assignment variables g naturally defines search problem f0 1g x theta input truth assignment variables associated monomials satisfied class search problems defined dnf tautologies quite general indeed shall see every search problem f gives rise search problem associated dnf tautology gf turn equivalent f every monomial associate subcube cm points f0 1g x consistent ie evaluate 1 definition 22 let f f0 1g n theta w search problem set monomials associated f denoted f defined 2 f 9w 2 w 8x 2 cm x w 2 f words 2 f inputs x consistent share mutual witness w 21 let f f0 1g n theta w search problem let gf formula defined gf dnf tautology proof every input x witness w thus particular subcube contains single point x defines monomial f witness x f 0 2 thus gf defines valid dnf search problem f 0 f0 1g n theta f f 0 set pairs x x satisfies convenient though historical reasons consider ff unsatisfiable cnf formula associated search problem input assignment variables find unsatisfied clause observe natural correspondence witnesses f f 0 21 decision tree complexity search problems let f f0 1g n theta w search problem deterministic decision tree f algorithm may query value input bit step goal find consistent witness formally algorithm rooted binary tree every internal node labeled variable two outgoing edges labeled two possible values variable leaf labeled witness w 2 w every assignment variables determines path root leaf natural way tree valid decision tree every assignment path ends leaf labeled valid witness deterministic complexity f df minimum depth decision tree f nondeterministic complexity f nf minimum number variables must probed order find valid witness worst case input alternatively exactly maximum size inputs x smallest monomial f satisfied x randomized decision tree f distribution deterministic decision trees f complexity randomized decision tree expected path length worst case input randomized complexity f rf minimum randomized decision trees f facts 1 let f f0 1g n theta w search problem f 0 f0 1g n theta f associated search problem df natural correspondence decision tree f deterministic randomized nondeterministic corresponding decision tree f 0 thus f f 0 indeed restatement essentially problem throughout paper distinguish f associated f 0 2 every decision problem f observation chvatal szemeredi 5 search problem f lower bounds regular resolution process unsatisfiable formula ff imply lower bounds deterministic decision tree complexity f elaborate point appendix 3 relative power determinism randomization versus nondeterminism section present explicit search problems large gaps different decision tree complexity measures main task construct search problems nf df simultaneously another parameter consider case df versus number variables n obvious upper bound three measures complexity 31 gaps rf df present explicit search problem rf existence problem follows 4 probabilistic arguments let gu v e bipartite graph define search problem degg jej variables following way 01 assignment variables interpreted subgraph g 0 g defined edges assigned 1 search problem find vertex r whose degree g 0 one clearly sides graph equal jv j 6 ju vertex exists every subgraph g 0 thus long sides equal degg valid search problem lemma 31 e bipartite graph maximum degree ju proof nondeterministic complexity ndegg since every input subgraph must check incident edges guessed vertex consider following random decision tree pick random vertex u 2 u independently vertex edges incident two vertices ie 2d edges checked u v produce witness stop otherwise repeat process done claim probability witness discovered iteration leastd1 2nd d1 edges subgraph g 0 defined 1edges least n d1 vertices v degree least 2 case fact v 2 v chosen random proves claim hand g 0 less 2nd d1 edges least 2n d1 vertices u degree 0 g 0 thus fact u 2 u chosen random proves claim case conclude expected number iterations 2d edges probed yields upper bound 2 show infinite sequence bipartite graphs deterministic complexity omegagamma n e bipartite graph maximum degree ju additional expansion property every ae u jsj n4 graph exists large enough infinitely many n 0 efficiently constructed using expander graphs 13 taken 30 theorem 31 let g graph defined n proof fact already proved lemma 31 show adversary strategy going cause deterministic decision tree probe n edges adversary limited produce subgraph 8v 2 u 1 thus answer decision tree find vertex u need definitions u subgraph g 0 g ng 0 sg stage edges probed assigned 0 g probed 9e assigned 1 e e 0 6 g define g words g contains edges still possible adversary use final subgraph without violating limitation u define n subgraph g 0 g define ae u unmatchable ng 0 denote minimum cardinality unmatchable set g 0 finally call minimal unmatchable set step limitation adversary step subgraph g contains partial matching u v decision tree cannot know answer long isolated vertex g obviously vertex minimum unmatchable set initially definition graph js n4 strategy adversary make sure minimum unmatchable set size decrease fast formally step edge probed adversary computes minimum unmatchable set occurs 0 answer e 2 probed x 2 ug ie minimum unmatchable set occurs 1 answer e chooses answer e make i1 larger 0 heart argument following claim claim js minimal unmatchable set js proof claim assume e asked step 1 strategy js easy see cannot matched v g thus contains unmatchable set step cardinality complete proof theorem 31 following argument beginning js n4 end js claim cardinality minimal unmatchable set decrease factor 2 conclude step j n16 js j however expansion property g j since step n drop set least probed step j 2 32 gaps n section construct two search problems randomized complexity large nondeterministic complexity small nondeterministic complexity first problem constant randomized complexity 6 second problem olog n nondeterministic complexity randomized complexity omegagamma n log n proof lower bound randomized complexity first problem proving lower bound distributional complexity yao 21 shown sufficient proof second indirect reduction communication complexity game 321 problem nf let grid following problem variables consider 1 theta 1 matrix entry bottom left corner contains one top row rightmost column zero n input bits determine rest entries matrix 01 assignment rest matrix goal find entry one upper right neighbors zero hard see configuration always exists example inspired lower bound argument hirsch papadimitriou vavasis 8 finding brouwer fixed points discussions noga alon extending random case theorem 32 n proof fact clear theorem established following lemmata lemma 32 proof basic result yao 21 asserts order prove lower bounds randomized decision tree complexity sufficient show distribution inputs deterministic algorithm requires high expected number queries distribution claim lower bound defined follows random upward rightward path starting bottom left corner matrix ending top row right column picked uniformly paths entries along path receive value 1 rest receive value 0 claim deterministic algorithm queries average discover end point path point desired configuration occurs need following claim points matrix b manhattan distance least downward left direction c manhattan distance least b distribution paths 1 k dthe probability path passes given passes b avoids c k 2 proof claim let event path passes point b event passes event passes c bounded 1 since correspond max 1jd 0 let deterministic decision tree grid give additional information queries stage provide prefix path informally intuition following stage contiguous initial segment path known next query point distance far known prefix provide additional segment path segment long enough make sure knowing determine value query thus conditional probability future queries depend answer query hand queries point far away prefix path already know good chance get 0 answer learn little claim 31 formally stage provide prefix path length points path manhattan distance 23 origin bottom left corner length prefix determined follows start ith stage 0 largest number exists set queries 1 h q h point distance h j 23 origin provide points path distance j j case say contribute j note query contribute q r one r follows consider happens whenever execution discovers end point path less 1m 13 steps must first step k kth query distance larger j answered 1 let b end point prefix stage k gamma 1 ie distance j 23 origin let kth query let previous queries answered 0 distance j 31 1 k 14m 13 probability event occur 2 therefore probability event occur 1 k 14m 13 12 therefore expected number queries 2 replacing grid expander get problem sharper bounds let g 3regular expander n edges let u node g associate n inputs edges g thus every assignment inputs defines subgraph g 0 edges assigned 1 problem odd find node u odd degree g 0 find u even degree g 0 odd valid search problem fact every graph even number nodes odd degree therefore 3 using fact expanders rapidly mixing ie random walk expander gets node almost random olog n steps show rodd 3 intuition grid concentrate probability walks length n 23 start u query far enough point unlikely walk thus tree would ask many vertices along walk order find end advantage far enough becomes quite small olog n due mixing property conjecture however rodd thetan lemma 33 n proof deterministic decision tree complexity om solves problem asks entries b mcrow 1 entry must answer upper half matrix otherwise must answer lower part matrix decision tree probes next relevant half b mccolumn recurses respectivelylemma 34 proof simple adversary strategy force deterministic algorithm query least locations adversary maintains contiguous path 1s bottom left location initially path contains bottom left point also maintains direction path either horizontal vertical given query row column end point path row column direction vertical horizontal adversary answers 0 say row end point path direction horizontal columns end point current query point query made adversary answers 1 gives away 1s locations end point query point answers query 0 finds first column query yet made fills row 1s point switches direction vertical case treated similarly easy see strategy maintains invariant step current path augmented top row right column moreover adversary answers 1 row column columns rows current end point query points already queried every 1 j position discovered least maxi 322 problem nf next example nondeterministic complexity olog n randomized complexity log n lower bound randomized complexity based reduction problem communication complexity let k 3m complete graph 3m vertices let pm set mmatchings k 3m ie set pairwise disjoint edges let qm denote set gamma 1subsets vertices k 3m note every member p 2 pm every member q 2 qm edge e 2 p e search problem essentially find edge input p q 2 pm theta qm however use boolean encoding problem encode sets permutations explained permutations permutation networks permutation network graph realizes permutations formally let g directed acyclic graph k sources called input nodes k sinks called output nodes nodes called switches input node one outgoing edge output node one ingoing edge switch two ingoing two outgoing edges assigned select one two permutations map two ingoing edges two outgoing edges clearly setting switch defines k paths g input node output node thus defines mapping k inputs k outputs easy see mapping always permutation symmetric group k elements graph g called k permutation network every 2 k setting switches mapping defined details construction permutation networks see 12 16 fact every k kpermutation network size ok log k depth olog constructed efficiently eg shuffleexchange network simple construction formally define n variables search problem match let fix two disjoint kpermutation networks let n total number switches om log input assignment switches network interpreted two permutations elements first permutation encodes mmatching p matched 1 every 1 second encodes set q size 1g search problem find edge theorem 33 since one guess find j r edge p addition check j 2 q guessing takes olog probes lower bound randomized complexity follows result raz wigderson 18 complexity problem finding desired edge communication complexity setting one party p 2 pm input party q 2 qm input showed bits must transmitted ii fact lower bound communication complexity model also lower bound decision tree model since players simulate decision tree transmit current bit probed dont give detailed definition communication complexity model information see 11 18 1 33 simultaneous large gaps n section construct problem simultaneous exponential gaps nf df remark deterministic lower bound based interesting application upper bounds online coloring algorithm let r integer let e vertex graph r colorable log r rcoloring search problem g denoted col r g following variable problem every assignment log r variables interpreted rcoloring g goal find two neighbors color clearly configuration always exists call configuration monochromatic edge theorem 34 let e dregular mvertex ramanujan expander constructed lubotzky phillips sarnak 13 1 ncol r 2 rcol r r rcol r 3 dcol r proof first show search problem indeed valid prove g rcolorable well rest proof follow lemmata lemma 35 every rcoloring g exist least 8 edges proof set v let r color classes coloring v r colors number monochromatic edges thus however expansion properties g every 0 ae v jes 0 j ddeltajs number monochromatic edges least dm mr r lemma 36 rcol r log r rcol r r proof upper bound follows lemma 35 least 8 edges every rcoloring thus selecting edge random probing 2 log r bits define end points colors results witness probability least 8mrdm 2omegagamma4 r therefore get expected number queries log r lower bound follows showing hard distribution yao 21 distribution uniform rcolorings easy see birthday paradox deterministic tree must probe least r vertices order hit color twice constant probability particular find two neighbors color lemma 37 let every integer every induced subgraph g 0 g vertices vertex degree proof 13 g cycles length less smallest subgraph every vertex degree least 1 vertex v 2 g 0 g every u one neighbor igamma1 neighbors since otherwise g 0 cycle length smaller 2k however since degree every u least gives g 0 contains least vertices 2 lemma 38 dcol r g r lemma 36 every induced subgraph g 0 size omegagamma 1p r vertex degree follows online colored since irani 9 shown greedy algorithm performance means long decision tree probes nodes adversary correctly online color induced subgraph probed nodes monochromatic edge occurs 2 4 case n section investigate decision problems nf correspond unsatisfiable 2cnf formulae turns case situation different general case namely df nearly characterized follows also nvariables problems df n f however rf may still small comparison df let f unsatisfiable cnf formula say sub formula f 0 f critical unsatisfiable deletion clause makes satisfiable theorem 41 let f nvariables search problem represented 2cnf formula critical sub formula minimum number clauses let k number variables f 0 number clauses f 0 k m2 log log proof let decision tree f look set clauses leaves every input reaches one clauses falsifies sub formula f 0 defined clauses tree unsatisfiable ie least clauses conclude size least depth least log proves lower bound df prove upper bound define unsatisfiable 2cnf formula f standard directed graph gf associated set 2n literals every clause edges egf every single variable clause x edge gf 41 unsatisfiable 2sat formula f let gf graph variable x directed path x x directed path x x proof proof induction number variables f claim easily checked 2 variables formulae assume f unsatisfiable chose variable x f possible two clauses produce resolvant z formula obtained deleting every clause contains x x adding new clauses unsatisfiable induction hypothesis gf 1 path p 1 path p 2 however every edge u v gf 1 either edge gf result resolving two clauses form x u x v associated edges u x x v path u v gf thus every path b gf 1 corresponding path b gf particular let f 0 critical sub formula f let gf 0 associated directed graph claim variable x directed path p 1 x x directed path p 2 x x leads following decision tree f first x probed decision tree find edge p 1 directed 1 0 binary search along p 1 thing p 2 edge u v corresponds clause u v falsified since clause contributes two edges graph length paths 2m get bound log number probes binary search may take simple paths particular length paths bounded k one gets upper bound 1 log k well k m2 lower bound 2 corollary 41 every 2cnf search problem f n variables df 2 show randomized complexity much smaller determin istic cases largest possible let g 1 constant degree ramanujan expander n vertices type constructed 13 col 2 g 2coloring search problem defined section 33 theorem 42 log n proof fact ncol 2 g 1 clear definition problem fact g 1 two colorable rcol 2 g 1 follows arguments proof 35 36 2 proof dcol 2 g 1 log n follows theorem 41 since critical sub formula col 2 corresponds edges nontwo colorable subgraph g 1 particular must contain odd cycle however cycles g 1 lengthomegagammangt n 13 let g 2 odd cycle length n theorem 43 n proof obvious following yaos technique distribution uniformly concentrated n different inputs coloring ith one colors correctly edges except ith edge deterministic tree average depth must least 12 inputs reaching leaves depth 2d special set n inputs since 2 2d leaves depth 2d least n inputs arrive leaf however two inputs special set arrive leaf since every input different witness n 2 2d1 r complexity classes communication complexity theory canonical expressions boolean algebra many hard examples resolution computing procedure quantification theory robustness nonisomorphism npcomplete sets exponential lower bound finding brouwer fixed points decision trees downward closure monotone circuits connectivity require super logarithmic depth introduction parallel algorithms architectures arrays explicit expanders ramanujan conjecture graph theoretic lemmata complexity classes handbook theoretical computer sci ence machineoriented logic based resolution principle monotone circuits matching require linear depth query complexity general purpose parallel architectures probabilistic computation tr ctr alexander razborov avi wigderson andrew yao readonce branching programs rectangular proofs pigeonhole principle transversal calculus proceedings twentyninth annual acm symposium theory computing p739748 may 0406 1997 el paso texas united states
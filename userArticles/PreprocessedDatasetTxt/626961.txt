distributed reset reset subsystem designed embedded arbitrary distributed system order allow system processes reset system necessary design layered comprises three main components leader election spanning tree construction diffusing computation components selfstabilizing following sense coordination upprocesses system ever lost due failures repairs processes channels component eventually reaches state coordination regained capability makes reset subsystem robust tolerate failstop failures repairs processes channels even reset progress b introduction describe paper augment arbitrary distributed system processes reset system predefined global state deemed necessary augmentation introduce new processes new communication channels system merely introduces additional modules existing processes added modules communicating one another existing channels comprise call reset subsystem ideally resetting distributed system given global state implies resuming execution system starting given state characterization however reset distributed system achieved global freeze system seems rather limiting many applications strict needed therefore adopt lax characterization resetting distributed system given global state implies resuming execution system global state reachable system computation given global state many occasions desirable processes distributed system initiate resets example ffl reconfiguration system reconfigured instance adding processes channels process system signaled initiate reset system appropriate initial state ffl mode change system designed execute different modes phases case changing current mode execution achieved resetting system appropriate global state next mode ffl coordination loss process observes unexpected behavior pro cesses recognizes coordination processes system lost situation coordination regained reset ffl periodic maintenance system designed designated process periodically initiates reset precaution case current global state system deviated global system invariant processes channels fail reset progress led designing reset subsystem faulttolerant particular reset subsystem tolerate loss coordination different processes system may caused transient failures memory loss also tolerate failstop failures subsequent repairs processes channels ability regain coordination lost achieved making reset subsystem selfstabilizing following sense reset subsystem global state coordination processes lost reset subsystem guaranteed reach within finite number steps global state coordination restored coordination restored maintained unless later failure causes lost cycle repeats 6 7 ability tolerate failstop failures subsequent repairs processes channels achieved allowing process channel system either ensuring ability system selfstabilize affected processes channels reset subsystem designed simple modular layered manner design consists three major components leader election spanning tree construction diffusing computation components selfstabilizing tolerate process channel failures repairs admits boundedspace implementations features distinguish design components earlier designs 1 9 10 redress following comment made lamport lynch 15 page 1193 selfstabilizing algorithm translates distributed system designed fixed arbitrary network one works changing network using finite number identifiers would quite useful know algorithm rest paper organized follows next section describe layered structure reset subsystem structure consists three layers spanning tree layer wave layer application layer three layers discussed sections 3 4 5 respectively section 6 discuss implementation issues particular exhibit bounded low atomicity implementations layer finally make concluding remarks section 7 2 layers reset subsystem make following assumptions concerning distributed system augmented reset subsystem system consists k processes named p1 pk instant process either binary irreflexive symmetric relation defined processes call relation adjacency relation adjacent processes communicate one another set processes adjacency relation defined change time simplicity however assume adjacency relation never partitions processes system clearly partitioning occur reset request initiated partition result resetting state partition process pi system consists two modules adji appli see figure 0a task module adji maintain set ni indices processes adjacent pi details implementation adji outside scope paper one possible implementation however adji communicate periodically adjj module every potentially adjacent process pj employ timeout determine whether index j process pj ni task module appli application specific perform task appli communicate module applj j 6 j ni one state appli distinguished together distinguished states appli module comprise predefined global reset state distributed system augmenting distributed system reset subsystem consists adding two modules treei wavei process pi system see figure 0b treei modules adjacent processes communicate order maintain rooted spanning tree involves processes system henceforth two terms process process used interchangeably constructed tree maintained consistent current adjacency relation system thus changes adjacency relation eventually followed corresponding changes spanning tree treei module keeps index father process fi maintained tree information used local wavei module executing distributed reset distributed reset executed wavei modules three phases waves first phase appli requests system reset local wavei forwards request root spanning tree reset requests made processes requests also forwarded root process convenient think requests forming one request wave second phase module wavei root process receives request wave resets state local appli state appli predefined global state initiates reset wave reset wave travels towards leaves spanning tree causes wavej module encountered process reset state local applj state applj predefined global state reset wave reaches leaf process reflected completion wave travels back root process wave comprises third phase finally completion wave reaches root reset complete new request wave started whenever appli deems necessary description follows states different appli modules reset different times within distributed reset cause problem appli whose state reset communicates adjacent applj whose state yet reset avoid problem provide session number sni appli global state distributed reset progress session numbers equal reset state appli accompanied incrementing sni require two adjacent appli modules communicate unless equal session numbers requirement suffices ensure characterization distributed reset distributed reset given global state yields global state reachable system computation given global state treei modules different processes constitute tree layer discussed section 3 wavei modules constitute wave layer discussed section 4 appli modules constitute application layer discussed section 5 21 programming notation program process form begin hmodulei hmodulei end module form module hmodule namei var hvariable declarationsi parameter hparameter declarationsi begin hactioni hactioni thus module process defined set variables set parameters set actions defined detail next variable variable set module updated ie written modules process variable read modules process modules adjacent processes parameter parameter set module ranges finite domain function parameter define set actions one parameterized action example let j parameter whose value 0 1 2 parameterized action actj action set module abbreviates following set three actions action action set module form hguardi gamma hassignment statementi guard boolean expression variables parameters module variables one adjacent process assignment statement updates one variables module operational semantics system processes follows state system defined value every variable processes system action whose guard true state system said enabled state computation system maximal fair sequence system steps step action enabled current state executed thereby yielding next state computation maximality computation implies computation proper prefix another computation fairness computation means continuously enabled action eventually executed computation 12 3 tree layer task tree layer continually maintain rooted spanning tree even changes set processes adjacency relation solution described accommodate changes ensuring tree layer performs task irrespective state starts solution rooted spanning tree represented father relation processes treei module maintains variable fi whose value denotes index current father process pi since layer start state initial graph father relation induced initial values fi variables may arbitrary particular initial graph may forest rooted trees may contain cycles case initial graph forest rooted trees trees collapsed single tree giving precedence tree whose root highest index achieved follows treei module maintains variable rooti whose value denotes index current root process pi rooti lower rootj adjacent process pj treei sets rooti rootj makes pj father pi case initial graph cycles cycle detected removed using bound length path process root process spanning tree achieved follows treei module maintains variable di whose value denotes length shortest path pi prooti detect cycle treei sets di dfi1 whenever fi 2 ni di k net effect executing action cycle exists di value process pi cycle gets bumped repeatedly eventually di exceeds k gamma 1 k maximum possible number processes since length path adjacency graph bounded kgamma1 cycle detected remove cycle detected treei makes pi father assumption initial state arbitrary need consider cases initial values fi rooti di inconsistent one possibility initial values locally inconsistent one following hold rooti rooti 6 di 6 0 fi ni case treei makes locally consistent setting rooti fi di 0 another possibility rooti may inconsistent respect state father process pi rooti 6rootfi may hold last case treei corrects value rooti rootj module treei given figure 1 module var begin figure 1 module treei show appendix starting state ie one could reached number changes set processes adjacency relation tree layer guaranteed eventually reach state satisfying state predicate g state g process pi rooti equals highest index among processes fi shortest path process pi root process prooti passes father process pfi di equals length path therefore rooted spanning tree exists also note state g fixedpoint ie treei modules reach state g action treei modules enabled proof employs convergence stair method 13 exhibit finite sequence state predicates h0 h1 hk iii l 0 l k hl closed system execution hl holds arbitrary system com putation continues hold subsequently iv l 0 l k upon starting arbitrary state hl system guaranteed reach state also show convergence state g occurs within ok rounds deg maximum degree nodes adjacency graph dia diameter adjacency graph informally speaking round minimal sequence system steps wherein process attempts execute least one action conclude section remark problems leader election spanning tree construction received considerable attention literature see example 15 16 17 algorithms based assumption processes start execution designated initial state restriction severe purposes lifted designing tree layer selfstabilizing ie insensitive initial state note selfstabilizing spanning tree algorithm recently described 9 however algorithm 9 based simplifying assumption times exists special process knows root made assumption root process fails remaining processes elect new root 4 wave layer outlined section 2 task wave layer perform diffusing computation 10 appli module resets state diffusing computation uses spanning tree maintained tree layer consists three phases first phase appli module requests local wavei initiate global reset request propagated wave modules along spanning tree path process pi tree root pj second phase module wavej tree root resets state local applj initiates reset wave propagates along tree towards leaves whenever reset wave reaches process pk local wavek module resets state local applk third phase reset wave reaches tree leaves reflected completion wave propagated along tree root diffusing computation complete completion wave reaches root record current phase wavei module maintains variable sti three possible values normal initiate reset module wavei propagated completion wave last diffusing computation waiting request wave next diffusing computation module wavei propagated request wave ongoing diffusing computation waiting reset wave reset module wavei propagated reset wave ongoing diffusing computation waiting completion wave variable sti updated follows initiate new diffusing computation local appli module updates sti normal initiate propagate request wave wavei likewise updates sti normal initiate propagate reset wave wavei updates sti value reset reset lastly propagate completion wave wavei updates sti reset normal possible appli update sti normal initiate completion wave last diffusing computation reaches root process thus multiple diffusing computations progress simultaneously distinguish successive diffusing computations wavei module maintains integer variable sni denoting current session number wavei recall operation wave layer subject changes set processes adjacency relation accommodate changes ensuring layer performs task irrespective state starts solution starting arbitrary state wave layer guaranteed reach steady state sni values equal sti value reset particular diffusing computation progress steady state sni values equal sti value normal furthermore diffusing computation initiated steady state sni value guaranteed terminate steady state achieved requiring reset wave wavei module increments sni resets state local appli module module wavei given figure 2 module five actions action 1 propagates request wave process father spanning tree request wave reaches root process action 2 starts reset wave root process action 3 propagates reset wave father process process action 4 propagates completion wave children process process four actions wavei modules collectively perform correct diffusing computation provided wave layer steady state steady states wave layer wavei satisfies gdi action 5 ensures selfstabilization wave layer steady states module begin stinormal stiinitiate fi gamma sti sni reset sni1 2 figure 2 module wavei show appendix b starting state wave layer guaranteed eventually reach steady state satisfying 8i snin sti 6reset integer n proof consists showing starting arbitrary state system guaranteed reach state gd ii state predicate gd closed system execution iii starting arbitrary state gd root process pk guaranteed reach state 8i snin sti 6reset also show diffusing computation initiated state gd terminate ie starting state satisfying gd system guaranteed reach state gd lastly show convergence gd state occurs within oht rounds diffusing computations terminate within omin htthetadg n rounds ht height spanning tree constructed tree layer dg maximum degree nodes spanning tree n number processes system 5 application layer application layer given distributed system composed appli modules shown figure 0 section discuss two modifications application layer reset subsystem correctly added given distributed system first modification augment appli module actions allow request distributed reset discussed section 4 actions set variable sti initiate enabled normal holds distributed reset necessary situations distributed resets necessary application specific one situation however global state application layer erroneous erroneous states may detected periodically executing selfstabilizing global state detection algorithm 8 14 towards end note possible implement selfstabilizing global state detection minor modifications reset subsystem second modification restrict actions appli module application layer continue execution distributed reset progress recall one objective design avoid freezing execution given distributed system performing resets modification based observation distributed reset appli modules continue executing actions long communication modules one reset another reset equivalently appli modules communicate session number sn values therefore require expression sni snj conjoined guard appli action accesses variable updated applj 6 j net effect modification upon completion distributed reset collective state appli modules reachable application layer execution given collective state appli modules reset 6 implementation issues section discuss two issues related implementations modules treei wavei first show statespace process bounded second show refine high atomicity actions employed thus far low atomicity ones 61 boundedspace construction treei module 2f1 kg updates three variables requiring log k bits contrast module wavei uses unbounded session number variable bounded construction also possible wavei transformed making sni type f0n gamma1g n arbitrary natural constant greater 1 replacing increment operation first action increment operation modulo n arithmetic thus wavei module implemented using constant number bits proof correctness transformed module similar proof presented appendix b left reader 62 transformation readwrite atomicity thus far design treei wavei modules taken account atomicity constraints actions modules high atomicity actions read variables updated processes instantaneously write variables refine design implement modules using low atomicity actions consider following transformation variable xi updated process pi introduce local variable xji process pj j 6 reads xi replace every occurrence xi actions pj xji add read action xji xi actions pj based transformation readwrite atomicity modules treei wavei presented next along proofs correctness code readwrite atomicity implementation module treei shown figure 3 show appendix c starting state tree layer guaranteed eventually reach state satisfying state predicate g structure proof identical proof presented appendix exhibit finite sequence state predicates h0 h1 hk iii l 0 l k hl closed system execution hl holds arbitrary system com putation continues hold subsequently iv l 0 l k upon starting arbitrary state hl system guaranteed reach state module var rootij begin rootij rootij dij rootj fj dj figure 3 implementation treei using readwrite atomicity code readwrite atomicity implementation module wavei shown figure 4 show appendix starting state wave layer guaranteed eventually reach state satisfying 8i sni n sti 6 reset integer n structure proof identical proof presented appendix b exhibit state predicate gd starting arbitrary state system guaranteed reach state gd ii gd closed system execution module begin snij gamma sti sni reset stij 6reset sni snij gamma sni snij stij figure 4 implementation wavei using readwrite atomicity iii starting arbitrary state gd root process pk guaranteed reach state 8i snin sti 6reset also show diffusing computation initiated state gd terminate ie upon starting state satisfying gd integer n system guaranteed reach state gd note similar proof exists bounded construction low atomicity wavei module sni replaced variable type arbitrary natural constant greater 3 increment operation first action replacing increment operation modulo n arithmetic conclusions presented algorithms enable processes arbitrary distributed systems perform distributed resets algorithms novel selfstabilizing tolerate failstop failures repairs arbitrary processes channels even distributed reset progress two comments order regarding choice fair nondeterministic interleaving semantics first requirement fairness respect continuously enabled actions necessary used simplifying proofs correctness second design remains correct even weaken interleaving requirement follows step arbitrary subset processes execute enabled action long two executed actions access shared variable 2 3 5 comment also order regarding methodology achieving faulttolerance distributed systems one way achieve system faulttolerance ensure faults occur system continues satisfy inputoutput relation systems designed thus mask effects faults hence said masking faulttolerant alternative way achieve system faulttolerance ensure faults occur inputoutput relation system violated temporarily words system guaranteed eventually resume satisfying inputoutput relation paper latter nonmasking approach faulttolerance adopted give three reasons sometimes preferring nonmasking faulttolerance masking faulttolerance designing distributed systems first distributed systems masking faulttolerance may impossible achieve example masking faulttolerant distributed system whose processes communicate asynchronously reach consensus binary value even one processes fail 11 second even possible implement masking faulttolerance cost may prohibitive example amount redundancy synchronization required may infeasible implement third requiring masking faulttolerance may strict desirable example callback telephone service eventually establishes connection may quite useful even mask initial failure establish connection course practical use nonmasking faulttolerant distributed systems designed time taken resume satisfying desired inputoutput relation faults occur within acceptable bounds envisage several applications distributed resets nonmasking faulttolerance useful currently implementing distributed operating system programs based distributed resets including example system programs multiprocess resynchronization also currently studying reconfiguration protocols high speed networks note distributed resets provide systematic method making arbitrary distributed systems selfstabilizing cf 14 application layer modules augmented perform selfstabilizing global state detection periodically request distributed reset upon detecting erroneous global states thereby making distributed system selfstabilizing distributed resets also used transform arbitrary selfstabilizing program equivalent selfstabilizing program implemented readwrite atomicity several issues need investigated one issue transformation readwrite atomicity programs cf figures 3 4 message passing programs analysis resulting programs note message passing programs predefined global reset state includes addition states appli module state channel system therefore addition resetting local state module appli wavei module send possibly empty sequence application messages tagged new session number every outgoing channel pi another issue study design efficient mechanism maintaining timely consistent state neighboring process indices third issue security problems involved allowing application process reset distributed system protection mechanism necessary enforce application processes interact reset subsystem desired manner finally observing selfstabilizing systems one type nonmasking faulttolerant systems desirable investigate alternative nonmasking faulttolerant solutions distributed reset problem less robust selfstabilizing solutions even efficient acknowledgements thank george varghese helpful discussions paper anonymous referees suggestions r applying static network protocols dynamic networks foundation faulttolerant computing convergence iteration systems distributed reset extended abstract relaxing interleaving assumptions token systems selfstabilize uniform selfstabilizing rings distributed snapshots determining global states distributed systems selfstabilization dynamic systems assuming readwrite atomicity termination detection diffusing computa tions impossibility distributed consensus one faulty process stabilizing communication protocols selfstabilizing extensions messagepassing systems distributed computing models methods algorithm distributed computation spanning tree extended lan correctness proof topology information maintenance protocol distributed computer network tr uniform selfstabilizing rings token systems selfstabilize selfstabilizing extensions messagepassing systems selfstabilization dynamic systems assuming readwrite atomicity distributed computing stabilizing communication protocols foundation faulttolerant computing impossibility distributed consensus one faulty process distributed snapshots algorithm distributed computation spanningtree extended lan correctness proof topology information maintenance protocol distributed computer network distributed reset extended abstract ctr jorge cobb mohamed g gouda stabilization general loopfree routing journal parallel distributed computing v62 n5 p922944 may 2002 hongwei zhang anish arora gs3 scalable selfconfiguration selfhealing wireless sensor networks computer networks international journal computer telecommunications networking v43 n4 p459480 15 november wilfried steiner michael paulitsch hermann kopetz ttas approach resilience transient upsets realtime systems v32 n3 p213233 march 2006 franck petit vincent villain optimal snapstabilizing depthfirst token circulation tree networks journal parallel distributed computing v67 n1 p112 january 2007 christian boulinier franck petit vincent villain graph theory helps selfstabilization proceedings twentythird annual acm symposium principles distributed computing july 2528 2004 st johns newfoundland canada neeraj mittal prajwal k mohan prioritybased distributed group mutual exclusion algorithm group access nonuniform journal parallel distributed computing v67 n7 p797815 july 2007 mohamed g gouda marco schneider maximizable routing metrics ieeeacm transactions networking ton v11 n4 p663675 august mohamed g gouda marco schneider memory requirements silent stabilization proceedings fifteenth annual acm symposium principles distributed computing p2734 may 2326 1996 philadelphia pennsylvania united states alain cournier ajoy k datta franck petit vincent villain optimal snapstabilizing pif algorithms unoriented trees journal high speed networks v14 n2 p185200 april 2005 mehmet hakan karaata selfstabilizing strong fairness weak fairness ieee transactions parallel distributed systems v12 n4 p337345 april 2001 anish arora mikhail nesterenko unifying stabilization termination messagepassing systems distributed computing v17 n3 p279290 march 2005 mehmet hakan karaata optimal selfstabilizing strarvationfree alternator journal computer system sciences v71 n4 p480494 november 2005 mehmet hakan karaata stabilizing algorithm finding biconnected components journal parallel distributed computing v62 n5 p982999 may 2002 fatima belkouch marc bui liming chen ajoy k datta selfstabilizing deterministic network decomposition journal parallel distributed computing v62 n4 p696714 april 2002 mikhail nesterenko anish arora stabilizationpreserving atomicity refinement journal parallel distributed computing v62 n5 p766791 may 2002 joffroy beauquier maria gradinariu colette johnen memory space requirements selfstabilizing leader election protocols proceedings eighteenth annual acm symposium principles distributed computing p199207 may 0406 1999 atlanta georgia united states sandeep kulkarni ravikant stabilizing causal deterministic merge journal high speed networks v14 n2 p155183 april 2005 azzedine boukerche kaouther abrougui efficient leader election protocol mobile networks proceeding 2006 international conference communications mobile computing july 0306 2006 vancouver british columbia canada anish arora paul c attie e allen emerson synthesis faulttolerant concurrent programs proceedings seventeenth annual acm symposium principles distributed computing p173182 june 28july 02 1998 puerto vallarta mexico albert mo kim cheng seiya fujii selfstabilizing realtime ops5 production systems ieee transactions knowledge data engineering v16 n12 p15431554 december 2004 yehuda afek shlomi dolev local stabilizer journal parallel distributed computing v62 n5 p745765 may 2002 yehuda afek anat bremler selfstabilizing unidirectional network algorithms powersupply proceedings eighth annual acmsiam symposium discrete algorithms p111120 january 0507 1997 new orleans louisiana united states felix c grtner fundamentals faulttolerant distributed computing asynchronous environments acm computing surveys csur v31 n1 p126 march 1999 hongwei zhang anish arora gs3 scalable selfconfiguration selfhealing wireless networks proceedings twentyfirst annual symposium principles distributed computing july 2124 2002 monterey california arora p dutta bapat v kulathumani h zhang v naik v mittal h cao demirbas gouda choi herman kulkarni u arumugam nesterenko vora miyashita line sand wireless sensor network target detection classification tracking computer networks international journal computer telecommunications networking v46 n5 p605634 5 december 2004
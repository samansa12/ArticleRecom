formal requirements analysis avionics control system abstractwe report formal requirements analysis experiment involving avionics control system describe method specifying verifying realtime systems pvs experiment involves formalization functional safety requirements avionics system well multilevel verification first level verification demonstrates consistency specifications whilst second level shows certain system safety properties satisfied specification critically analyze methodological issues large scale verification propose practical ways structuring verification activities optimizing benefits b introduction paper reports experiment use formal methods producing analyzing software requirements safetyrelated system work conducted part safefm project 3 4 collaboration gec marconi avionics mission avionics di vision aea technology consultancy services safefm project intended support practical use formal methods high integrity systems producing new theories integrating formal methods existing development assessment practice project focused particular class application realtime control systems work based avionics case study digital system controlling variable geometry surfaces aircraft paper describes application formal approach specification analysis safefm case study requirements case study realistic system inspired existing air data computer adc realtime control system consists two independent control channels primary channel performs adc functions normal operation backup channel takes primary fails two channels perform complex control failure detection functions satisfy safetycritical properties work case study supported pvs specification verification system 5 6 specified functional requirements case study pvs using data flow approach purely definitional style work partially funded uk department trade industry safeit programme epsrc grant dti project ied19013 authors department computer science queen mary westfield college university london mile end rd london e1 4ns uk email brunodcsqmwacuk victoriadcsqmwacuk adopted strong typing mechanisms pvs give us strong assurance concerning internal consistency functional specifications addition performed various verifications proving socalled putative theorems typechecking putative theorems correspond first level validation second level verified safetycritical requirements satisfied requires systemwide perspective relevant aspects properties system control physical environment included purpose used approach based explicit time easy implement pvs assumptions safety properties written pvs verifications performed interactively pvs theorem prover potential formal methods improve system dependability recognized several certification au thorities use recommended mandated emerging standard safety critical sector 1 2 main objective work get indication feasibility benefits limitations formal approach applied realistic example substantial size complexity remainder paper structured follows section ii gives overview safefm case study main functional nonfunctional requirements summarized together architecture faulttolerance features system section iii presents pvs main formalization principles adopted experiment section iv describes successive stages case study formalization functional requirements formulation safety properties assumptions verifica tion section v draw lessons experiment discuss perceived benefits limitations formal approach adequacy tools experiment identify several sources difficulty inefficiency propose possible improvements ii case study safefm case study avionics controller inspired existing air data computer adc embedded fighter aircraft system computes air data parameters altitude airspeed mach number also charge several aerodynamical control surfaces plane case study concentrates one critical functions adc control variable geometry wings wings swept aft forward order optimize flight performance adc computes optimal wing sweep angle according values aero ieee transactions software engineering vol xx month 1997 control surfaces auxiliary backup channel primary channel wing sweep fig 1 adc architecture dynamical parameters commands pilot well mechanical constraints order tolerate mechanical failures wing sweep actuators controlled two independent servos adc must detect signal possible failure servos required tolerate failure accordingly adc composed two control channels connected different servo architecture shown fig 1 asymmetric primary channel performs adc functions normal operation backup channel takes primary fails channels fail pilot still control wing sweep using emergency mechanical device two channels independent separate power supplies receive input different sources synchronization two channels two independent clocks different frequencies cross channel communication discrete signal indicating failures primary channel backup channel wing sweep commands continuously computed two channels servos individually enabled disabled ensure one channel control time adc must ensure normal mode primary servo enabled backup servo enabled primary channel fails two channels detect failures continuously monitoring feedback signals servos actuators difference wing sweep commands responses servos actuators exceeds threshold long enough period mechanical elements deemed failed adc reports failure pilot faulty channel deacti vated faulty channel continues normal computations associated servo stays disabled way reactivate channel pilot reset whole sys tem clears failure monitoring mechanisms restores initial configuration adc primary channel active backup servo disabled main safety requirement system prevent contact different sets flaps located trailing edge wings fuselage severely damage flaps lead loss mission order prevent adc maintains wing sweep angle certain limits flaps extended purpose adc receives signals mechanical sensors indicate whether flaps extended case study realistic example class applications safefm project aimed address inspired existing system already developed gecmarconi service several years case study typical avionics control systems realtime system redundant fault tolerant architecture communicates interacts complex environment meet safety mission critical requirements facts well dual channel architecture render adc substantially complex software requirements case study describe various control failure detection functions implemented two channels wing sweep commands computed according complex control laws combining numerical calculations logical constraints specific commands depend many parameters altitude speed plane position flaps mechanical elements control mode selected pilot hand timing requirements relatively simple correspond delays failure detection mechanism originally software requirements expressed mixture english descriptions mathematical formulas various graphs 7 objective produce precise rigorous specifications requirements adopt multilevel verification approach increasing confidence correctness first wanted check internal consistency specifications ensure various requirements contradict second important level verification involved checking safety critical properties satisfied adc effectively prevents contact flaps fuselage iii methods tools needs analyzing control application adc requires considering controller environment safety requirements properties wings flaps cannot verified without knowledge system control make assumptions wing sweep sensors servos actuators well behavior different flaps formalizing assumptions requires notation capable representing continuous evolution physical mechanical variables model controller specify software requirements various control failure detection functions implemented also need consider elements communication two channels presence two different clocks system general specifications applications adc structured controller specifications model system control critical properties want verify need expressive specification language able cover three aspects applications interested realtime interactive systems also hybrid systems since involve physical variables digital components formalism must allow us manipulate continuous discrete vari ables express quantitative timing requirements deal multiple clocks verification applications size complexity adc practical tool support efficient mechanical proof tool needed order make verification possible chose use pvs powerful theorem prover rich specification language b introduction pvs pvs specification verification environment integrates tools creation analysis formal specifications interactive theorem prover 6 8 pvs used successfully produce substantial complex proofs hardware fault tolerant clock synchronization algorithms 9 10 5 also used domains compiler verification 11 construction validation realtime systems 12 13 pvs specifications written extension classical higherorder logic organized hierarchy theories parameterized theory usually contains type constant function definitions collection lemmas theorems also possible state assumptions theory parameters introduce ax ioms pvs analyzed specifications syntax type correctness user attempt prove theo rems system provides l e x generator various tools analysis specifications proofs pvs rich type system includes constructors tuples records supports dependent types abstract data types powerful subtyping mechanism features make language expressive facilitate specification type checking becomes undecid able proof obligations known type checking conditions tccs may generated type checker discharged order establish type consis tency cases proofs tccs performed automatically pvs theorem prover complex situations manual assistance may required pvs theorem prover based sequent calcu lus starting initial sequent user progressively develops proof tree applying commands deductive rules every stage proof particular sequent goal displayed proof commands apply sequent commands either complete proof current goal expand tree generating subgoals turn proved proof rules available propositional quantifier reasoning pvs provides set high level commands complex reasoning example commands induc tion manipulating automatic rewrite rules heuristic instantiation quantifiers system also includes powerful simplification decision procedures linear arithmetic equality commands combined form proof strategies allowing several proof rules applied one step pvs specifications built collection standard types functions constants defined prelude set primitive theories prelude also introduces fundamental axioms provides set preproved theorems standard numerical types reals rationals integers natural numbers primitive defined prelude organized hierarchy natural numbers form subtype integers subtype rationals subtype reals unlike systems hol 14 pvs construct numerical types starting natural numbers defines properties axiomatically numbers important types sets lists sequences predefined prelude c realtime specifications pvs several authors proposed different ways applying pvs realtime systems method based extension hoare triples presented 12 approach allows construction correct realtime systems successive refinements pvs used define semantics formalism implement proof refinement rules another application pvs specification verification realtime programs described 13 program behaviors represented infinite sequences states include quantitative timing information state labeled time occurrence temporal operators defined pvs used assert properties sequences pvs also provides tool support duration calculus dc realtime interval temporal logic 15 16 dc partly embedded pvs several theories define semantics calculus dc proof rules introduced pvs theorems dedicated interface makes encoding largely transparent user specifications written syntax close standard dc verification performed using dc proof rules directly 17 first two methods mostly designed program verification construction assume systems evolve step step fashion characterized succession states discrete model suit purpose well duration calculus extensions see 18 19 intended development embedded systems use continuous time however dc tends focus controlintensive applications complex timing requirements logic includes modalities express temporal properties without explicit usage time variables case study require sophisticated timing formalism instead specifications based straightforward easy implement timedependent quantities manipulated explicitly functions time temporal properties 4 ieee transactions software engineering vol xx month 1997 written using explicit time indices model terminology use inspired partly semantics duration calculus partly realtime data flow languages lustre signal 20 21 distinguish two classes timedependent variables similar state variables dc others closer notion data flow lustre signal state variables total functions time domain value domain represent continuous variables application physical parameters altitude mechanical variables wing sweep angle input signals received pilot data flows used formalize software requirements model discrete behavior digital com ponents assume components fixed interface composed finite number input output ports activated regular intervals clock known frequency activation phase component performs internal computations delivers new value output ports behavior digital component characterized sequences values produced output ports clock determines values produced represent clocks infinite sets instants every element clock interpreted instant activation component output signals well internal variables used specifications modeled data flows functions clock domain values example wing sweep commands computed primary channel form data flow wscmd1 defined successive instants primary clock wscmd1tn command produced nth activation primary channel last elements needed specification conversion functions transform discrete data flows state variables conversions used model communication discrete components physical en vironment example wing sweep angle physical variable represented total function time wspos describe wspos relates discrete commands two channels purpose convert data flow wscmd1 similar wscmd2 backup channel piecewise constant state variables cmd1 cmd2 depending status two channels actual command cmdt transmitted wings either equal cmd1t cmd2t model actuator assumptions relating cmd wspos effect conversion functions give us convenient way mix data flows different clocks wscmd1 wscmd2 single state variable cmd conversions also similar use modelling communication software modules different clocks case study specifications based set pvs theories introduce notions time clocks definitions rely pvs subtyping facilities time domain subtype reals clock parameterized subtype time domain basic theories also introduce operators facilitate definition data flows several predicates simplify expression verification properties addition also needed general purpose theories provide background knowl edge example theories contain properties real numbers theorems bounded finite sets define functions absolute value maximum minimum two reals c1 time domain duration calculus use nonnegative reals time domain 0 initial instant corresponding type time defined follows nonneg first line introduces nonnegative reals subtype predefined type real time declared synonymous non neg containing clause specifies non neg nonempty type simplifies type checking reduces number tccs generated pvs c2 state variables state variables declared manipulated pvs functions example state variable representing position wings declared follows function time ws range latter type represents domain values wing sweep angle defined subtype reals assumptions system control introduced axioms specifications correspond constraints relations values state vari ables example upper bound rate rotation wing sweep actuator produce assumption formalized axiom variation ws axiom specifies constant max rate maximal rate variation wing sweep angle axiom pvs formula free variables delta considered universally quantified c3 clocks specifications rely simple model clocks clocks assumed fixed period positive number clock period k represented set successive multiples period starting 0 pvs clock subtype time defined parameterized theory clocks clocks begin clock parameter k strictly positive real represents clock period definition specifies instant type clock multiple k several basic operations clock elements useful constructing reasoning data flows like type clock functions parameterized clock period defined theory clocks among oper ations following three fundamental ffl init indicates whether clock element initial instant clock ffl pre gives immediate predecessor element ffl next gives immediate successor element pvs functions total pre function defined subtype clock excludes initial element three functions defined noninitelem noninitelem type checking definitions pvs generates two proof obligations first requires showing k type clock ensure definition pre consistent tcc states expression k nonnegative multiple k second tcc similar ensures type correctness next elements clock form ascending sequence instants another useful function assigns clock element x rank sequence unique natural number n pvs requires showing division yields natural number number functions similar pre next defined clocks theory also contains several lemmas theorems correspond elementary properties clocks example lemma asserts clock bounded another states time two successive clock elements important theorems proved clocks general induction rules clockinduction implies simply means invariance predicate p function clock booleans 1 shown proving p holds initially maintained every clock step proposition easily derived predefined induction theorem natural numbers using function rank summarise theory clocks includes set elementary functions list useful properties clocks basis formalizing software functional quirements particular main mechanisms used expressing verifying functional specifications recursion induction supported functions properties developed clocks c4 data flows software requirements case study structured modules pvs theory specifying function adc example module describes primary wing sweep control another describes backup failure monitoring module clock list input signals defines collection data flows representing output intermediate variables every module assigned one two channels determines clock module input signals either state variables channel receives external environment data flows defined modules channel use pvs importing mechanism specify clock module input signals given parameters theory data flows defined module functions modules clock data type since module expected software implementable certain restrictions imposed form data flow definitions roughly module data flows intended specify abstract state machine whose state clock time vector behavior machine specified initial conditions transition relation defines state x 1 function previous state current value input variables definition x allowed refer previous current clock times general initial instant clock value x time depend ffl current value input signals 1 type predclock equivalent clockbool 6 ieee transactions software engineering vol xx month 1997 ffl current previous values flows x j j 6 ffl previous value x many cases data flows specified simple pvs definitions example wsch range subtype reals pvs generates tcc check righthand side expression allowed type complex cases x depends pret data flows defined recursively pvs definition recursive function takes special form one provide measure used decide whether function well defined thereby ensuring recursion always terminates measure assigns arguments function value well ordered type usually natural numbers recursion sound shown measure strictly decreasing every recursive call type checker generates corresponding proof obligations called termination tccs recursive data flows based functions init pre associated clock use function rank measure following definition typical example recursive constructions case study deselectautot false elsif selectautot initt true else endif boolean flow auto mode represents state variable controlled two flows select auto deselect auto default auto mode initially true overridden deselect auto subsequently auto mode set according two control flows remains unchanged false termination tcc associated definition following automodetcc2 obligation easily discharged definition auto mode sound since recursive data flows measure definitions similar terminations tccs always discharged using lemma clockrecur initx implies property proved theory clocks using form data flow specifications software functional requirements expressed purely definitional style strong evidence concerning consistency requirements provided tccs discharged know data flows well defined functions hence risk parts functional requirements contradictory since functions total risk incompleteness ei combination values input signal internal output variables specified value hand form specification reduce users flexibility writing requirements restrictions due rules pvs specification language example pvs allow definition mutually recursive data flows restrictions due underlying state machine model data flow definition refer current previous instant restrictions important getting confidence feasibility software requirements state machine model fact adopted many approaches software development including recent work pvs specification space shuttle software 22 state machine model also widely used formalisms b vdm 23 24 incorporate software development methods whole data flow specification software requirements provides solid basis subsequent develop ment type checking ensures completeness consistency feel restrictions form specifications price worth paying considering potential benefits iv experiment work formalisation verification case study spread period two years experiment went several successive phases first specifications functional requirements formal verification last safety property functional requirements first stage work formal specification functional software requirements starting point report describing informally adc architecture main functions system 7 original document describes two channels interfaces specifies redundancy management mechanism report also specifies fairly precise terms different control failure detection functions implemented notation used mix english descriptions mathematical formulas equations various tables graphs document produced software engineers previous experience systems similar case study requirements therein inspired large subset existing avionics system developed gecmarconi main effort early phases work focused defining specification approach developing pvs support theories choice data flow style largely motivated form informal requirements made rapidly however theories defining time domain clocks underwent several modifications reaching final form particular started general model clocks required complex pvs definition given section iiic3 clock unbounded countable set instants 25 general model prove convenient useful later largely simplified basic support theories evolving throughout whole project fairly stable version obtained end formalization software requirements time definitions time domain clocks clock operators form described preceding section modifications introduced later phases adjunction lemmas needed perform safety verification building blocks formalization identified specification functional requirements straightforward informal requirements translated list data flow definitions without difficulty certainly due quality precision original document 7 also aided vdm specification case study developed separately within safefm project 26 vdm specification direct contact gecmarconi resolved ambiguities found informal requirements document structure pvs specifications follows closely informal document organization six software modules described four primary channel two backup channel modules corresponds one main function adc specified separate pvs theory fig 2 illustrates general structure functional modules main data flow specified theory wscmd1 wing sweep command produced primary channel data flow depends various input signals modules altitude mach intermediate data flows auto mode functions defined wing sweep primary discrete flows clock clockprimary period clock primary channel type checking functional specifications straight forward tccs generated simple properties could discharged automatically theorem prover others termination tccs associated recursive definitions data flows simple fact proving type correctness specifications gives us first level confidence consistency completeness also ensures simple errors range values division zero elimi nated however order get greater confidence functional specifications also need check high level safety properties b assumptions safety properties second major step safefm experiment formalize safety properties model system control two main safety requirements selected case study upper limits wing sweep angles two different sets flaps extended two properties given original requirement document extracted failure mode begin deselectautot false elsif selectautot initt true else endif end wingsweepprimary fig 2 general organisation functional modules effect analysis performed system inspired case study safety requirements properties system control cannot verified without making assumptions controlled system expressed terms physical variables namely wing sweep angle degree extension different flaps need describe external variables relate input output signals adc first attempts prove safety properties satisfied largely unsuccessful origin problem lack information components system control particular flaps anarchic behavior flaps makes impossible adc ensure safety requirements wing sweep control implicitly based assumption flaps extend wrong time unfortunately little information flaps requirements doc ument original requirements destined primarily software engineers focus functionality software aspects contain limited information system control information needed order develop software believe problem pervasive verification systems methodology needed overcoming cannot prove safety properties software without changing way overall requirements traced system components solution consult systems engineers much wider view system including hardware software components well safety mecha nisms also got information expected behavior wing sweep flap control systems various documents including pilots manual interaction systems engineers new sources information helped us clarify safety requirements formulate correct assumptions 8 ieee transactions software engineering vol xx month 1997 new elements particular mechanical interlocks included model controlled system locks mentioned initial requirements although play essential role since prevent extension flaps wings swept certain limits crucial assumption enabled verification main safety properties assumptions formalized axioms pvs specifications example following assumption relates wing sweep angle wspos time eps wing sweep command cmd time case none interlocks active wingslockedinintervalt implies axioms describe evolution wings locks active constraints flap extensions initial position wings flaps new assumptions system control posed different problem role mechanical interlocks prevent violation main safety properties case adc fails consequently original safety properties derived fmea trivially sat isfied faced following dilemma ffl interlock assumptions sufficient guarantee safety properties whatever behavior adc ffl without assumptions safety properties order check adcs functional specifications formulate safety properties solution reformulate safety properties directly terms wings flap positions constraints wing sweep commands issued channels reworked safety requirements state adc must issue commands would force wings mechanical locks final difficulty taking account absence synchronization two channels certain cir cumstances cause substantial difference wing sweep commands computed backup primary channel backup channel takes control difference large may momentarily produce commands force locks end safety requirements refined three properties ffl primary channel control maintains system safe state ffl backup channel assumes control converges safe state within specified period time ffl backup channel control safe state stay safe state safe states wing sweep commands produced cannot exceed limits permitted mechanical locks first property ensures safety initialization system possible failure primary channel second property corresponds transition phase instant primary channel fails instant backup channel reaches safe state phase channel may temporarily issue commands force interlocks latter ensures wing sweep angle exceed limits third property ensures safe state reached backup channel maintain safety properties formalized easily pvs example first safety property written implies c verification final phase case study experiment involved formal verification properties software functional specifications whole control system two categories lemmas theorems proved putative theorems allowed us check formalization whilst others directly used proof three main safety properties putative theorems either related software specifications model system control typically express simple properties expected true system thus providing simple means ensuring formalization reasonable also constituted collection lemmas simplified verification complex properties none theorems posed particular difficulty following lemma typical putative theo rems states successive commands computed primary channel within specified rate limit initt resett abswscmd1pret wscmd1t ratelimitt remainder verification focused establishing three main safety properties proofs properties significantly complex putative theorems three safety theorems required formulation proof several dozens lemmas sublemmas verification three top level safety properties required proof total 124 propositions least straightforward three safety properties convergence backup channel safe state proof based case analysis several modes evolution whole system identified analyzed separately possible transitions different modes examined mode characterized parameters status flaps extended retracted position wings internal state backup channel past values relevant data flows lemmas showed within mode global system always evolves smoothly towards safe state analysing transitions showed property preserved whole although simpler proofs two safety properties based similar form reasoning essentially elaborate case analyses results proofs one error found formalization functional requirements wing sweep command definition channels relies lower upper limit certain combinations input pa rameters lower limit greater upper limit leads incorrect wing sweep command unexpected situation discovered failing prove putative theorem error traced back original informal requirements possible inversion two limits completely overlooked mistake present vdm specifications given 26 derived informal requirements error discovered proofs simple correction putative theorems three important safety properties formally proved whole specification consists approximately 4500 lines pvs comments blank lines includes library basic theories time clocks formal specification functional requirements toplevel theory contains assumptions lemmas theorems needed verify three main safety properties total 385 proofs performed include 106 proof obligations tccs discharged automatically rest proved hand amount effort involved estimated around person months approximately 6 person months necessary write formal functional specifications support libraries remaining 12 person months spent formalizing assumptions carrying verification bulk verification work spent three main safety properties consumed 9 person months effort v lessons benefits formal requirements analysis case study analysis involved two separate activities formal specification adc functional requirements validation specifications proof experiment clearly demonstrated benefits pvs specifications original informal doc ument formal requirements concise precise unambiguous also confident use type checking definitional style adopted pvs specifications consistent respect safefm case study confirmed authors conclusions value formal specifications example see 22 27 existence vdm specification substantial experience gecmarconi engineers system meant pvs formalization likely uncover previously unknown problems main benefits formal approach realised later stages validating specifications case study illustrated formal specifications clear unambiguous consistent also wrong proofs provide essential means detecting errors requirements generally proof process requires thorough analysis requirements gives profound understanding system behavior among positive results proofs attempted case study cite ffl clarification external conditions adc work correctly controller requirements based implicit assumptions system control elements interlocks flaps early attempts check safety properties failed lack information external elements explicit formulation assumptions essential step understanding control system ffl deep analysis rare unexpected behaviors system among cite behavior adc primary channel failed initial quirements certainly clear global system would behave case formal analysis showed backup channel may momentarily unsafe state eventually reach safe state analysis also gave us bound time would take ffl detection error formal requirement spec ifications wing sweep command defined pvs specifications wrong circumstances proofs effective means detecting errors early stage software development error also found vdm specification via animation 28 independently discovery verification however animation always possible cases provide partial validation ffl verification major safety properties system showing safety critical requirements satisfied essential increasing confidence specifications alternative formal proof performing verification validation techniques review testing animation cannot offer degree confidence general proof process essential analyzing complex interactions two channels external components comprehending global system failed proofs always useful revealing subtle properties adc thereby helping understand behavior whole system identifying causes failure often revealed unexpected behavior exceptional circumstances failed proofs due special cases anticipate caused complex combinations events environment controller obviously identifying cause proof failure hard problem cannot solved mechanically theory failing prove conjecture necessarily mean false practice however proofs failed ending visibly unprovable goal could exhibit counterexample either convinced us belief conjecture wrong pointed possible error specifications final diagnosis often required help gecmarconis engineers b tool support important conclusion case study formal methods applied practice requirement analysis real industrial systems size specifications number proofs performed experiment represents major effort formal verification experiment shown large scale verification feasible corroborated reports industrial uses pvs 9 verification effort would succeeded without effective tool support tools necessary simply cope size specifications also essential supporting proof process requirements case study include numerical computations logical temporal constraints state space system infinite numerical relations linear reasoning systems fully automatic proof support exist user rely interactive proof assistants validation phase pvs theorem prover used refute many incorrect proofs much verification performed rely sophisticated argument usually requires lengthy detailed case analysis expe rience fairly easy get almost correct proof failed due obscure cases doubt without tool forces examination de tails bad cases would gone unnoticed therefore tools necessary gaining high level confidence proofs systems adc available tools interactive theorem provers tools real help practice low level steps proofs must automated far possible purpose two features pvs essential decision procedures possibility installing automatic rewrite rules general level case study showed flexibility ease modification important practical sues already mentioned lot effort spent failing prove properties subsequently trying identify correct causes failure often meant specifications changed assumptions added new lemmas introduced propositions rewritten user must free make modifications without much effort particular without manually reexamine proofs pvs system keeps scripts existing proof attempts edited rerun extremely useful usually simple adjustments scripts sufficient changes specifications c difficulties encountered safefm case study confirmed benefits formal analysis high level requirements also shown formal methods applied realistic complex systems largescale verification feasible ever another lesson experiment proof process expensive difficult estimate took us eighteen months complete work instead six months originally planned delays attributed lack familiarity pvs experienced users would undoubtedly completed formal analysis less time factors also explain time overrun ffl little guidance apply pvs effectively realtime control applications nonnegligible part work write basic pvs theories supporting specification approach theories modified updated several times ffl absence general libraries another problem since spend time proving simple properties sets real numbers present prelude ffl initial requirements document written software engineering point view focused functionality contained little information system control early proof attempts showed information crucial several iterations required formulating correct assumptions getting precise safety requirements ffl proofs safety properties lot harder expected largely due difference levels abstraction safety software requirements safety requirements global system properties related physical system expressed terms position wings flaps safety perspective externally observable behavior controller relevant hand functional requirements explicit description software components inside controller already depend implementation decisions dual channel architecture large gap two levels description difficulty relating output variables two channels actual position wings complexity arose different elements layers interactions involved better difficulties case study work due lack maturity pvs prover order reduce effort involved formal verification necessary provide general purpose pvs libraries necessity already identified new version pvs comes largely expanded prelude general properties prove present prelude pvs2 also includes new features creating handling libraries however available present developing libraries still essential making verification less labor intensive example found library stating basic properties continuous functions could helped aspects case study verification similarly developing theories designed tailor pvs towards specific classes applications would important improvement case realtime systems similar case study theories defining clocks elementary notions could provide basic support however existing form theories still fragmentary need expanded completed offer sufficient help case study requirement analysis largely exercise posteriori verification validation consisted proving properties software requirements already available large gap high level safety properties comparatively low level functional specifications main source complexity safety proofs order simplify verification solution may adopt constructive approach gradually developing software specifications high level requirements whole system allow localised form rea soning proving safety properties highest level description focusing correctness refinement whatever techniques used formal general improvement validation software specifications complex systems would address issue requirements traceability order analyse validate software specifications essential know assumptions system designers made part safety requirements responsibility software discovering information one time consuming activities experiment whole verification effort would much less resourceintensive started precise assumptions system control clear safety properties vi conclusions case study experiment confirmed potential benefits formal methods requirements analysis safety critical systems formal specification provides clear advantages clarity precision main benefit experiment feasibility thorough analysis via proof formal verification help uncover errors misunderstandings subtle unexpected properties could easily escape means scrutiny review animation right circum stances increased confidence requirements specification obtained proving safetyrelated properties purpose crucial adopt start wide point view consider system whole precise knowledge system control environ ment clear specification safety requirements essential narrow perspective software developer sufficient existing formal methods proof tools mature enough applied large systems substantial com plexity main value tools help identify correct wrong arguments proof process specification debugging via proof principal activity requirements validation lot learnt case study failed proofs corrections spite potential benefits amount effort time spent case study may still seen obstacle however believe difficulties encountered due particular context study experience gained application pvs realtime controllers amount effort required verification decrease main issue pvs community develop make available libraries could provide background general notions results well guidance support theories facilitating description realtime systems acknowledgements work described would possible without support project partners particular thanks due gecmarconi colleagues educate us avionics systems r procurement safety critical software defence equip ment draft iec standard 1508 functional safety safetyrelated systems safefm project developing assessing safety critical systems formal methods safefm way formal verification faulttolerant architectures prolegomena design pvs tutorial introduction pvs safefm case study report user guide pvs specification verification system formal verification aamp5 microprocessor case study industrial use formal methods formal verification avionics microprocessor automated code generator verification based algebraic laws correctness real time systems construc tion verification realtime systems using pvs hol theorem proving environment higher order logic specifying verifying requirements realtime systems calculus durations towards duration calculus proof assistant pvs extended duration calculus hybrid realtime systems design embedded realtime computing sys tems synchronous data flow programming language lustre pro gramming realtime applications signal formalizing space shuttle software requirements systematic software development using vdm b method large software specification design coding case study coherent specifications formal techniques analysis design ml animation test case generation tr ctr kirsten hansen anders p ravn victoria stavridou safety analysis software requirements ieee transactions software engineering v24 n7 p573584 july 1998 r j wieringa traceability modularity software design proceedings 9th international workshop software specification design p87 april 1618 1998 simin nadjmtehrani janerik strmberg formal verification dynamic properties aerospace application formal methods system design v14 n2 p135169 march 1999 constance heitmeyer james kirby bruce labaw applying scr requirements method weapons control panel experience report proceedings second workshop formal methods software practice p92102 march 0405 1998 clearwater beach florida united states robyn r lutz software engineering safety roadmap proceedings conference future software engineering p213226 june 0411 2000 limerick ireland judith crow ben di vito formalizing space shuttle software requirements four case studies acm transactions software engineering methodology tosem v7 n3 p296332 july 1998 guoqing shu fengdi wang min chen weiqing requirements specifications checking embedded realtime software journal computer science technology v17 n1 p5663 january 2002 angelo gargantini angelo morzenti automated deductive requirements analysis critical systems acm transactions software engineering methodology tosem v10 n3 p255307 july 2001
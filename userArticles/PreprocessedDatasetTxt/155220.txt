analysis orparallel execution models discuss fundamental limitations orparallel execution models nondeterministic programming languages orparallelism corresponds execution different nondeterministic computational paths parallel natural way represent state parallel execution nondeterministic program means orparallel tree identify three important criteria underlie design orparallel implementations based orparallel tree constanttime access variables constanttime task creation constanttime task switching term constanttime means time operations independent number nodes orparallel tree well size node prove three criteria cannot simultaneously satisfied orparallel execution model based finite number processors unbounded memory discuss detail application result class logic programming languages show result serve useful way categorize various orparallel methods proposed field also discuss suitability different orparallel implemenation strategies different parallel architectures b introduction paper explores fundamental limitations orparallel execution models nondeterministic programming languages use term nondeter minism automatatheoretic sense dont know nondeterminism rather sense dont care nondeterminism orparallel execution nondeterministic programs involves parallel exploration multiple search paths arising due nondeterministic choices important subclass languages class logic programming languages languages execution involves solution goals respect set clauses orparallelism arises whenever goal unies one clause head case corresponding clause bodies executed parallel general exploiting orparallelism useful way speed solution search problems articial intelligence applications symbolic computation reasoning theorem proving natural language analysis etc natural way represent state parallel execution nondeterministic program means orparallel tree paper analyze execution models based orparallel tree base analysis upon following three criteria ideal orparallel execution model 1 cost environment creation constanttime 2 cost variable access binding constanttime 3 cost task switching constanttime use term constanttime mean time operations independent number nodes orparallel tree well size node connection criteria might appear remote rst actually derived three principal operations nondeterministic programming system sequential parallel procedure call involves environment creation assignment statements parameter transmission involves variable access binding resumption success failure involves task switching criteria essentially state principal operations orparallel execution model performed eciently ie constanttime would ideal one could satisfy three criteria show paper ideal cannot achieved orparallel model using nite number processors constanttime addressable memory appreciate result consider sequential execution logic pro grams sequential execution model viewed special case orparallel execution model provides constanttime environment creation constanttime variable access binding constanttime task switching latter operation also known backtracking requires undoing bindings variables number variables constant general since depends upon depth search path might appear orparallel model perform back tracking hence three criteria satised reasoning correct nite processor assumption orparallel tree orparallel tasks available processors hence need task switching one make task switching constanttime operation directory tree method hc86 see achieved expense two operations important dierence sequential implementation orparallel implementation must support multiple bindings values variable multiple bindings possible variable passed reference procedure call dierent nondeterministic search paths arising call assign dierent values variable logic programs unication plays role parameter transmission multiple bindings main cause nonconstant time variable access obvious without additional bookkeeping binding applicable variable accessed arbitrary node orparallel search tree attempts make variable access constanttime operation lead nonconstant overheads operations example order facilitate constanttime variable access record binding variable applicable given node node environment creation aected general nonconstant number variables information must recorded fact least one criteria must sacriced explains retrospect many orparallel execution models logic programs proposed literature a88 ak90 b84 c87 dlo87 hc83 hc86 h87 k86 l84 t89 w84 w87a three criteria provide natural scheme classifying various orparallel methods proposed literature namely according proper subset criteria satisfy treatment general dhd warren w87b examined orparallel methods especially variants argonne model dlo87 sri model w87a well hausman ciepielewski hc86 examined several variations directory tree method hc83 study encompasses orparallel methods based orparallel search tree three criteria brie mentioned works researchers w87a h87 hc86 main contributions work lie stating criteria present form ii proving criteria cannot satised together iii using basis classication remainder paper organized follows section 2 introduces essential concepts terminology orparallel models form denitions remarks section 3 proves main result aid lemmas considering possible ways solving problem showing one criteria fail case section 4 discusses detail result context logic programs section 5 uses result basis classifying several orparallel execution models nally section 6 presents brief summary conclusions 2 notation terminology keep paper selfcontained provide section denitions technical terms also introduce notation used later sections denition nondeterministic program query nondeterministic program set procedure denitions form head body head form idpars procedure id may appear head one procedure denition syntactic category pars stands possibly empty list formal param eters assumed without loss generality reference parameter callbyreference query form procedure body consists sequence statements either procedure call assignment formal parameter remarks following assumptions made simplify discussion aect technical results declarations variables given domain data values also left unspecied ii nested procedure denitions free nonlocal variables appearing procedure denitions iii control structures ifthenelse etc absent denition singleassignment property variable bound nondeterministic computational path remarks generalization wellknown singleassignment property nondeterministic languages suces restrict attention case since results easier prove without restriction 21 orparallel tree following denitions n stands possibly innite set nodes orparallel tree v possibly innite set variables set domain terms values p set processors set memory locations multiprocessor system let ps denote powerset set jsj cardinality denition orparallel tree local environment orparallel tree given nondeterministic program query tree nodes associated continuation local environment 1 root node tree query associated continuation set variables appearing query local environment 2 nonroot node n created result choosing dierent procedure denition execute rst call body ns parent node continuation node n consists statements body chosen procedure denition followed statements rst call parent n statements assumed interpreted environment n b local environment ln n set variables present chosen procedure denition l remarks nodes orparallel tree need number children nodes ie branching factor nodes ii branching factor bounded constant determined program iii assume unbounded supply variables variables denition uniquely renamed call sets variables two local environments disjoint one another denition two nodes n 1 orparallel tree say n lie path root tree either n 1 n 1 closer root n 2 latter case say n remarks partial order ii sometimes write n instead n denition global environment global environment gn node n orparallel tree union set variables local environments lying path root tree n v 2 lxg remarks assume n 1 since may introduce one distinct dummy variable local environment node denition owner node access node binding node variable v local environment node n 1 unique owner node v dened n 2 subset n called access nodes v access node n 3 subset access nodes called binding nodes v characterized terms partial function species binding node variable v global environment node n due singleassignment property stated earlier function b satises requirement node undened bv set binding nodes mg remarks access node variable v value v accessed binding node variable v value assigned v ii characterization orparallel tree terms owner binding access nodes based observation three basic operations performed variables environment creation variable binding variable access iii every binding node access node since variable must accessed bound ie variable binding special case variable access proposition 1 uniqueness property binding nodes variable v two distinct binding nodes n 1 lie path root proof let n 1 two distinct binding nodes ie n 1 suppose derive contradiction denition binding node n 1 bv hence bv n 2 bv n 2 since binding node hence n 1 contradiction end proof corollary binding node variable given global environment unique exists denition value cell value variable v local environment node n 1 set value cells v value cell memory location used storing value v created corresponding binding node use partial function vc v n denes value cell v global environment node n function vc satises requirement vcv undened ov 2 onetoone correspondencey set binding nodes v set values set values specied partial denes value v global environment node n binding node v ov valv undened b ov valv unbound c valv remarks note value cell always refer cell allocated v local environment owner node v rather value cell memory cell allocated holding binding generated binding node ii function valv n cannot described algorithmically would able predict value given variable particular environment even variable gets bound denition conditional binding conditional variable binding variable v said unconditional either bv ov branching factor every node ov excluding binding node v one case variable v said unconditionally bound otherwise binding said conditional v referred conditionally bound variable conditional variable denition complete orparallel tree complete orparallel tree one 1 leaf node l continuation l either empty success leaf node rst call l cannot processed due undened procedure failure leaf node 2 nonleaf node n child node present orparallel tree corresponding procedure denition program used execute rst call ns continuation remarks incomplete orparallel tree one leaf nonleaf node extended creating child node ii possible complete orparallel tree given query program nontermination 22 computational model assume model computation unbounded number memory locations accessed constanttime assume nite number processors ie jp j nite cooperatively assume two identical bindings generated dierent binding nodes distinguishable say use tags construct orparallel tree creating children nodes long tree incomplete order create child node node n processor must rst move current node location node n processors may assumed located root orparallel tree initially following denitions focus three important operations model computation task creation task switching variable access denition task site task site incomplete orparallel tree node n least one untried procedure denition rst call ns continuation denition task creation n task site processor said create task node n constructs global environment continuation child node corresponding untried procedure denition n time taken construct global environment child node n called cost task creation remarks lowerbound cost task creation cost creating local environment child node n ii certain parallel schemes c87 l84 variable bindings copied child nodes local environment parent nodes local environment completion call regard work part task creation next call denition current environment current environment processor located node n gn denition task switching processor said taskswitch moves node n 1 node n 2 orparallel tree time taken processor change current environment n 2 called cost taskswitching denition access cell every variable v accessible processor p node n memory location called access cell used looking binding v variable access partial function denes access cell v environment processor p node n function ac satises requirement acv p undened ov remarks dierence access cell value cell former used looking binding v variable access whereas latter used storing binding v variable binding ii value cell variable accessible processors since contains binding generated variable hence value cells cannot maintained privately processor contrary processor maintain access cell particular binding variable v hence vc function p ac iii every v n p value associated access cell acv p n identical value cell vcv n thus orparallel model ensure contents value cells ected access cells given environment methods ensure value cell access cell share physical memory location hc83 b84 methods keep physically separate copy binding value cell access cell variable binding generation w87 h87 denition variable access process locating access cell acv p n processor p node n variable v gn called variable access time taken processor operation called cost variable access remarks locating nal binding variable twostep process variable access applicable access cell located b derefer encing contents binding cell used obtain nal binding dereferencing may involve indirection thus general would nonconstant time denition variable access include dereferencing conclude section restating three criteria ideal orparallel implementation light discussion 1 cost task creation constanttime 2 cost variable access constanttime 3 cost task switching constanttime constanttime mean time taken operations depend either size orparallel tree size continuation similarly consider size set nonconstant cardinality proportional depth size orparallel tree size continuation size terms created execution example size set conditional variables global environment node nonconstant since cardinality proportional depth tree 3 main result section prove three criteria cannot simultaneously satised conventional strategy proof would construct constanttime reduction known problem desired property problem hand known problem solved problem hand solved however aware problem could serve basis reduction therefore present alternative essentially consider possible ways problem could solved show one criteria violated proof divided two main cases 1 access cells value cells identical since onetoone correspondence values binding nodes accessing value reduces determining binding nodes proved corollary 1 methods show general binding node determined without violating one criteria lemma 1 considers case information needed locate binding node kept somewhere orparallel tree ie combination owner nodes binding nodes access nodes lemma 2 considers case information maintained datastructures independent nodes theorem 1 combines lemmas 1 2 together 2 access cells value cells separate methods show lemma 3 taskswitching always nonconstant time operation finally conclusions lemmas 1 2 3 theorem 1 used prove theorem 2 main result constanttime arguments hinge following basic proposition proof obvious proposition 2 given arbitrary set property p px true one x 2 determining x satises px cannot done constanttime ie time independent jsj lemmas assume variable treated uniformly environments example particular binding variable particular environment stored value cells allocated binding node bindings v environments also stored value cells allocated respective binding nodes easy extend proofs include nonuniform treatment variables dierent environments include sake simplicity brevity access cells value cells identical information regarding binding node bv n variable v global environment node n associated either owner node binding node access nodes either bv n cannot determined constanttime processor node n nonconstant overhead incurred task creation proof consider possible places information bv n recorded orparallel tree since three operations performed variablecreation bindingunbinding accessing valuewe consider rst three cases information maintained exclusively either owner creation nodes binding nodes access nodes consider case information maintained combination three types nodes association v n bv n kept binding node since one binding node v global environment gn n since nonconstant number nodes gn follows proposition 2 determining bv n constanttime operation binding node v gn fact also cannot determined constanttime proposition 2 since number nodes ov n constant general ii association v n bv n kept owner node case owner node v maintains set binding nodes v mg order processor n determine applicable binding node bv n n must determine x 2 bv x n since bv set nonconstant size searching x x n nonconstant time operation proposition 2 iii association v n bv n kept access nodes since access nodes cannot determined advance association would maintained every node ie node k would need store binding pair hw bw ki conditional variable w accessible since number conditional variables accessible particular k would general constant creation k would become nonconstant time operation binding pairs ks parent would copied k instead copying pairs node k shares parent node access pairs hence access binding nodes would become nonconstant time operation since ks parent might share binding pairs parent etc worst case determine binding node variable ancestors k would also searched thus case degenerates case thus either determining binding node becomes nonconstant time operation nonconstant overhead incurred taskcreation iv association v n bv n stored combination binding owner access nodes let c set conditional variables global environment node n general c would set nonconstant size let c 1 set possibly empty conditional variables case true c 2 set possibly empty conditional variables case ii true c 3 set possibly empty conditional variables case iii true thus assuming c nonempty least one c 3 nonempty since c nonconstant size least one c 1 c 3 nonconstant size thus reasoning cases ii iii used prove case end proof lemma 2 let access cells value cells identical let c set conditional variables global environment node n information regarding binding node bv n variable v 2 c recorded datastructures independent orparallel tree either accessing binding node nonconstanttime operation nonconstant time overhead incurred taskcreation taskswitching proof suppose processor records datastructures value bv n variables v2 c accessible n make assumption structures could array hash table etc general case arbitrary number datastructures independent orparallel tree global subset processors two extreme cases general case one single datastructure common processors one private datastructure processor show former case either accessing binding node taskcreation non constanttime operation latter case taskswitching nonconstant time operation show general case combination extreme cases single global datastructure common processors processor create node n must ensure bv n v 2 recorded global datastructure two occasions done bv n values recorded either time n created ii incrementally individual bv n value needed one descendent nodes n consider case turn bv n values variables gnc accessible node n recorded global datastructure creation node n taskcreation nonconstant time operation since general nonconstant sized subset variables would accessible n bv n values recorded incrementally needed accessing would nonconstant time operation would nd ancestor node n bv n bv entry exists global datastructure cannot done constanttime proposition 2 since size gn global datastructure constant ii datastructure private processor taskswitching nonconstant time operation since time processor switches task record private datastructure entries variables accessible new nodes processors path number new nodes accessible processor taskswitch well number variables accessible newly accessible nodes dependent depth node corresponding new task thus constant hence taskswitching nonconstant time operation general case reduces combination cases ii let set processors p divided disjoint subsets p datastructure recording bv n reasoning similar case either taskcreation accessing binding node nonconstant time operation similar case ii processor switched another branch created processors q 62 p taskswitching nonconstant time operation since information new binding nodes ps path recorded datastructure set processors p also possible split datastructure part global part private processor since c nonconstant size either set variables recorded global datastructure set variables recorded private datastructures would nonconstant size hence case ii one taskcreation binding node access taskswitching nonconstant time end proof theorem 1 let access cells value cells identical let c set conditional variables global environment node n binding node bv n variable v 2 c cannot determined processor node n constant time without incurring nonconstant overhead taskcreation taskswitching proof function b cannot described algorithmically since would allow us predict binding node given variable particular environment even variable gets bound means evaluate function bv n association variable v binding node environment gn explicitly maintained two ways maintain association either orparallel tree combination owner binding access nodes independent orparallel tree datastructures independent tree let c set variables association information stored orparallel tree let c set variables association information stored independent orparallel tree since c set nonconstant size least one c c also nonconstant size c nonconstant size lemma 1 either binding nodes cannot accessed constant time nonconstant overhead incurred taskcreation c nonconstant size lemma either binding nodes cannot accessed constant time nonconstant overhead incurred taskcreation taskswitching thus either case nonconstant overhead incurred end proof corollary 1 let access cells value cells identical let c set conditional variables global environment node n possible processor access node n access valv n v 2 c vcv n constant time without incurring nonconstant overhead taskcreation taskswitching proof since relation functions b val oneone nding valv n constant time without incurring nonconstant time taskcreation overheads means bv n also found constant time without incurring nonconstanttime taskcreation overheadsy clearly possible according theorem 1 end proof lemma 3 access cells distinct value cells taskswitching nonconstant time operation proof let c set conditional variables size therefore constant taskswitch arbitrary processor p bindings applicable conditional variables c may change due change current global environment p hence p ensure access cells correctly established conditional variables suppose p switches node k 1 node k 2 let k least common ancestor node k 1 let k set nodes path k 1 k 2 via k kg variable w aected task switch w 2 c 0 set c partitioned two subsets c 1 c 2 g conditional variables c 1 processor uses physical memory location access cell irrespective environment ie allocate new one ii g new physical memory location allocated environment k 2 access cell conditional variable set c 2 since c nonconstant size least one c 1 c 2 also nonconstant size case access cells updated conditional variable c 1 least aected conditional variables c 0 c 1 similarly case ii access cells created updated conditional variable c 2 least aected conditional variables c 0 c 2 c 2 nonconstant size general c 0 would nonconstant size taskswitching nonconstant time operation end proof theorem 2 implementation method bounded number processors satises three criteria c nonconstant sized set conditional variables orparallel tree given moment partition set c two disjoint sets c c b c subset c access cells value cells distinct c b subset c cells identical clearly either c c b must nonconstant number variables lemma 3 c nonconstant size taskswitching example binding generated record address binding node value cell access variables binding value cell means automatic access corresponding binding node extra cost nonconstant time operation hence consider case c b nonconstant corresponds set access cells value cells identical variables accessing variables amounts accessing values valuecells corollary 1 c b nonconstant size values variables c b cannot accessed constant time without incurring nonconstant overhead taskcreation end proof 4 orparallel execution logic programs apply results previous section orparallel execution logic programs noted earlier nondeterminism logic programs arises multiple clause heads may unify procedure call goal since unication essentially twoway patternmatching unbound variables calling environment may bound unication aspect unication coupled nondeterminism eectively makes possible multiple bindings variable local environment noted lemmas 1 2 theorem 1 main task orparallel execution model determine binding node variable access seen suces restrict attention singleassignment languages purpose deriving results imperative languageswhere variable bound nondeterministic pathdetermining applicable binding node complicated since several binding nodes variable given global environment given access node variable applicable binding node would one closest path access node root orparallel tree dierent methods dier identify binding node central aim methods identify binding node eciently value cells accessed constant time variable access environmentupdate taskswitching example methods simplify operation nding binding node variable allocating value cells binding node eg binding arrays method w84 w87a version vectors method h87 hashing windows method b84 schemes assign unique id binding node record id binding example time stamping method t89 variable bindings organized fashion binding node known corresponding binding eciently accessed methods proposed literature orparallel execution logic programs either set c c b described theorem 2 empty set however proof general subsumes even methods may c c b nonempty consider methods see satisfy theorem 2 process see illustration proof lemmas theorem binding arrays method binding arrays method w84 w87 value cells access cells allocated memory space separately access cells allocated space binding array private processor value cells allocated space binding lists binding node since slot used access cell particular conditional variable xed irrespective global environment content updated taskswitch results taskswitching time becoming nonconstant accordance lemma 3 thus theorem 2 holds binding arrays method similar reasoning see version vectors h87 method also nonconstant taskswitching time thus satises theorem 2 binding arrays method value sets c c b described theorem 2 c set conditional variables orparallel tree given time also value sets c 1 described lemma 3 c 1 note lemma 3 parameterized p k 1 thus variation standard binding arrays method conceived certain pair nodes k 1 processor decides update binding array place c 1 certain pair nodes k 3 k 4 leaves old binding array stationed k 3 constructs new one k 4 corresponds case binding arrays number processors ownership binding array change time time case order optimize taskswitching time processor may build new binding array branch sees orparallel tree become big obviously modied binding array method satises lemma 3 thus theorem 2 note necessary binding arrays versions vectors method record value cells binding nodes value cells recorded using dierent scheme say example time stamping method t89 give us variation binding arrays versions vector method variations binding arrays method manchesterargonne argonnesri models also satisfy theorem 2 given w87b muse kabuwake delphi randomized parallel backtracking muse system ak90 binding environment processor distinct ie shared others processor switches another node orparallel tree constructs whole stack node root node memory copy stack regarded private datastructure alluded lemma 2 accessing variable bindings result case ii lemma 2 corollary 1 taskswitching becomes nonconstant time operation taskswitching also nonconstant time operation kabuwake method k86 delphi method ca88 randomized parallel backtracking method ja88 l89 latter two cases taskswitch processor constructs datastructure mentioned lemma 2 recomputing nodes root orparallel tree node tasksite located thus stack reconstructed rather copied although recomputation results less interaction processors overall strategy incur overhead general recomputing would involve work copying stacks avoid repeated recomputing delphi method uses optimization based comparing socalled oracles oracles essentially node identiers indicating path taken reach node root since oracles size proportional depth nodes orparallel tree comparing nonconstant time operation hence even optimization taskswitching still remains nonconstant time operation directory tree method directory tree method hc83 binding environment represented using directories contexts node directory contains number contexts one ancestor nodes context corresponds clause space variables clause node branches create new directories copies nodes contexts children nodes method value cells access cells identical allocated space access nodes node copy contexts hence lemma 1 corollary 1 task creation nonconstant time operation thus theorem 2 holds directory tree method note method value sets c c b described theorem 2 c similar reasons theorem 2 holds environment closing method c87 environment representation scheme used ropm rk89 nonconstant taskcreation time hashing window method hashing windows method b84 access cell value cell identical allocated space binding node hence lemma 1 corollary 1 variable access nonconstant time operation insure fast access variable bindings within binding node value cell allocated cell hash window whose address obtained hashing variable address thus hashing window method also satises theorem 2 similar reasons theorem 2 holds argonne model dlo87 w87b however argonne model hash window constant size 32 contents hash window node shared children results bucket hashwindow large number variables mapped stored list thus nonconstant cost traversing tree upwards towards root nding binding node ected cost locating value cell bucket tree binding node v towards end list bucket would value cell v theorem 2 also holds variation hashing windows method adopted representing environments pepsys model wr87 model conditional variable accessed node binding copied hashing window access node future accesses variable descendent nodes traverse fewer nodes thus scheme also satises theorem 2 virtue lemma 1 case iii corollary 1 time stamping method time stamping method t89 records id processor unique time stamp variable binding hpid timestampi pair regarded id binding node created binding id later used accessing bindings value cells identical access cells method organized datastructure independent orparallel tree thus accordance lemma 2 corollary 1 variable access nonconstant time operation actually time stamping method taskswitching nonconstant time operation ancestor stack viewed representation association variables binding nodes constructed taskswitching information recorded nodes thus due lemma 2 corollary 1 taskswitching non constant time operation method andor parallel methods theorem 2 also holds orparallel component andor parallel sys tems example consider following three methods incorporating independent andparallelism orparallelism single framework reduceor parallel model rk87 ii pepsys model wr87 iii authors andor parallel model gj89 g91 note environment representation scheme used three methods sacrice taskcreation variableaccess taskswitching criteria respectively 5 classication orparallel models logic programs fact three criteria cannot simultaneously satised partly reason many methods proposed literature orparallel execution logic programs based criteria one chooses satisfy one dierent execution model orparallelism one also use basis classifying various orparallel execution models since three criteria satised principle 2 classes methods according classication see figure 1 proved methods exists class 1 corresponds methods providing constanttime three operations ie task creation variable access task switching class 8 methods uninteresting since three operations nonconstant time none methods proposed literature fall class 7 corresponds nonconstant task creation well nonconstant taskswitching time although theoretically possible create orparallel method would fall class unlikely practice task creation nonconstant time likely environment already replicated nodecreation thus need environment updating taskswitch since branch orparallel tree private environment true false true false cva cva cva cva true true class 1 class 2 class 3 class 4 class 5 class 6 class 7 class 8 true true true false false false false false method eg directory tree eg binding arrays eg hashing windows eg time stamping method eg variable import constant time task switch constant time variable access theorem figure 1 classication orparallel methods theoretically reason method sacrice one criterion although methods eg variable importation method l84 time stamping method t89 distribute cost multiple environment representation two operations instead one overall performance may eventually remain unchanged may even improve example time stamping method t89 worst case variable bindings would accessed global datastructure searching entire datastructure however keeping ancestor stack results nonconstant time taskswitching fraction global datastructure accessed thus although two criteria may sacriced particular method necessarily mean inferior method sacrices one criterion method ctc cva cts version vectors h87 binding arrays w84 w87a p p argonnesri model w87b manchesterargonne timestamping t89 hashing windows b84 p p naive model w87b argonne model dlo87 p p directory tree hc83 environment closing c87 p p variable import l84 kabuwake k86 p p bcmachine a88 muse ak90 p p abstract model randomized method ja88 p p table 1 criteria satised various methods table 1 give table showing particular criteria satised dierent methods column indicates criterion corresponding column satised method methods falling class directly compared best one among determined makes sense compare methods within class rather methods belonging dierent classes example directory tree method environment closing method duplicate environment taskcreation however environment closing duplicates smaller fraction environment since duplicate variables already bound directory tree method thus although two orparallel methods might theoretically equivalent practice one may ecient similarly binding arrays method superior versions vectors methods far executions costs concerned reasons given w87a sharedmemory multiprocessors methods sacrice constant time taskswitching tend superior sacrice constanttime taskcreation variableaccess number task creation variableaccess operations program dependent number taskswitching operations dependent scheduling policy employed runtime system thus cost taskswitching carefully controlled implementor optimizing granularity stance possible taskcreation variable access demonstrated aurora muse system lwh90 employ sophisticated schedulers ak90 cs89 s89 b90 minimize cost taskswitching distributed memory systems methods nonconstant time task creation likely perform better relevant part environment needed carrying parallel execution another processor made available explicit copying task creation processor example environment closing method c87 directory tree method hc83 accesses variables processor use copy available locally however advent distributed shared memory systems lh89 wh88 may make methods sac ricing constanttime taskswitching competitive distributed systems sacricing constanttime taskcreation mentioned earlier since performance methods former class less dependent behavior logic programs might even outperform methods latter class distributed memory systems 6 conclusions presented three criteria ideal orparallel system sat isfy constanttime access variables constanttime task creation constanttime taskswitching signicance criteria correspond naturally three fundamental operations nondeterministic programming language procedure call involves environment creation assignments parameter transmission involves variable access binding resumption success failure involves task switching showed given nite number processors orparallel execution method based upon orparallel tree method satisfy three criteria simultaneously believe result also applies orparallel models based upon orparallel tree leave formal proof conjecture open question notwithstanding restriction models based upon orparallel tree believe result signicance since wellknown orparallel implementations logic programs based upon approach sucient derive results class nondeterministic singleassignment languages since easier satisfy three criteria destructive assignments present although results rst formulated logic programs gj90 reformulating general nondeterministic languages hope accessible researchers interested parallelizing applications symbolic computation reasoning exhibit substantial orparallelism symbolic integration program syn thesis natural language analysis theoremproving gametree searching etc technology parallel execution logic programs advanced point several practical parallel prolog implementations lwh90 ak90 t92 much done organize subject systematic way paper provides framework could serve valuable reference implementors logic languages compared existing work results provide greater insight nature orparallel execution models facilitate meaningful comparisons acknowledgements thanks david hd warren feliks kluzniak comments suggestions earlier version paper thanks also due anonmyous referees whose comments spurred us generalize earlier result broaden scope paper work supported part nsf grant dcr 8603609 gopal gupta also supported uk science engineering research council grant grf 27420 performed work university bristol r 2nd international logic prog conf tr method efficiently executing horn clause programs using multiple processors randomized parallel backtracking algorithm performance orparallel logic programming system finding lowest common ancestors simplification parallelization orparallel execution models prolog memory coherence shared virtual memory systems aurora orparallel prolog system muse orparallel prolog model performance parallel execution logic programs shared memory multiprocessors ctr enrico pontelli karen villaverde haifeng guo gopal gupta stack splitting technique efficient exploitation search parallelism sharenothing platforms journal parallel distributed computing v66 n10 p12671293 october 2006 enrico pontelli gopal gupta parallel symbolic computation ace annals mathematics artificial intelligence v21 n24 p359395 1997 gopal gupta enrico pontelli khayri ali mats carlsson manuel v hermenegildo parallel execution prolog programs survey acm transactions programming languages systems toplas v23 n4 p472602 july 2001
faulttolerant routing mesh architectures important distributed computing system able route messages aroundwhatever faulty links nodes may present present faulttolerant routingalgorithm assures delivery every message long path betweenits source destination algorithm works many common mesh architecturessuch torus hexagonal mesh proposed scheme also detect thenonexistence path pair nodes finite amount time moreover thescheme requires node system know state faulty eachof links performance routing scheme simulated square andhexagonal meshes varying physical distribution faulty components isshown shortest path source destination message istaken high probability path exists usually found quickly b introduction processors distributed computing system communicate sending messages network faults network prevent delivery messages unless network provides faulttolerant routing however distributed systems pay little attention potential problem provide simple efficient routing algorithms algorithms usually work properly faults present network paper propose simple efficient faulttolerant routing algorithm used many meshtype distributed system architectures obvious way handle faulttolerant routing node keep track faults system node expected know state failed links algorithms proposed 6 broadcast information faulty components nodes system information messages always routed shortest paths two main problems approach first amount memory may needed store information especially system large second overhead induces standard routing algorithms systems allow routing decisions made simple circuitry using information message header allows optimizations like virtual cutthrough 4 speed message delivery avoiding buffering intermediate nodes information must consulted message must buffered message delivery delayed therefore restrict situation node knows state links work already done faulttolerant routing hypercube 1 3 5 7 algorithms either take advantage specific mathematical properties hypercube therefore inapplicable meshes use form global information want avoid authors 1 present algorithm use global information relies properties specific hypercubes cannot tolerate n faults n dimension hypercube date know faulttolerant routing strategy meshtype distributed systems systems require node know condition faulty nonfaulty links routing scheme deliver message successfully long path source destination require assumption number faults fault patterns exist path source destination nodes routing scheme able detect finite amount time paper organized follows section 2 briefly describe two representative mesh architectures section 3 outlines faulttolerant routing algorithm works cases section 4 cases algorithm work examined fix presented section 5 performance algorithm simulated several mesh types paper concludes section 6 homogeneous mesh architectures mesh architectures provide number advantages distributed architectures hypercube mesh number links per node constant increase mesh size increases number links per node hypercube increases number nodes high number communication links corresponding high throughtraffic overload nodes large systems also number nodes mesh quadratic function mesh dimension whereas hypercube exponential function hypercube dimension two mesh architectures consider paper torus hexagonal mesh meshes several characteristics common mesh architectures must order routing algorithm work mesh must regular unwrapped must planar wrapped must homogeneous link associated vector one must able change order links vectors path without changing destination one arrive node regardless whether one takes two hops x direction followed one hop direction one hop x direction followed one hop direction followed one hop x direction addition assume routing done hopbyhop basis routing decisions made intermediate nodes instead path chosen node message originated assume message system based storeandforward approach may employ techniques virtual cutthrough 4 possible order avoid overhead buffering message individual node messages buffered intermediate nodes outgoing links wish use busy assume node enough buffer space deadlock problem algorithm could used circuitswitched environment consider possibility paper 21 torus unwrapped square mesh dimension theta j contain ij nodes laid rectangular nodes along horizontal edge j nodes along vertical edge wrapped square mesh becomes torus right link node right edge mesh connected node left edge row downward link figure 1 hexagonal mesh dimension 3 node bottom edge mesh connected node top edge mesh column node mesh four oriented directions one think right link x direction downward direction left top links become gammax gammay directions set shortest paths two nodes expressed offsets two directions example shortest paths nodes 10 7 would defined offsets 2 xdirection gamma1 ydirection given offsets message routed simply sending along link reduce one offsets 22 hexagonal mesh unwrapped hexagonal mesh hmesh set nodes laid hexagonal grid central node inside series nested hexagons hexagon one node edge one immediately inside edge dimension e mesh defined number nodes one side outermost hexagon shown 2 number nodes edimensional hmesh 3e node unwrapped hmesh six oriented directions one corresponding six links without loss generality link pointing horizontally right thought x direction link 60 degrees counterclockwise direction link 120 degrees counterclockwise z direction remaining three links point gammax gammay gammaz directions respectively hmesh edge dimension e wrapped using ctype wrapping 2 produces homogeneous mesh example cwrapped hmesh edge dimension 3 given fig 1 figure 2 detouring hexagonal mesh theta1 algorithm presented 2 give shortest paths two nodes cwrapped hmesh returns three integers x z represents distance traveled corresponding direction least one offsets guaranteed zero jm x e dimension mesh torus routing done simply sending message along link reduce one offsets detouring structure system important factor routing algorithm faulttolerant routing algorithms hypercube take advantage systems unique mathematical properties logical take advantage simple regular structure mesh systems consider link failures since node failure modeled failure links torus hmesh provide obvious method detouring around single faulty link link forms one side square triangle whose sides form convenient detour link fail example consider hexagonal mesh fragment fig 2 link 0 failed message could detour around failed link using path 7 0 path 11 0 recursive example link 7 also failed detour could 6 7 0 message one two modes free mode faults obstructing path detour mode messages path blocked faults routing done node follows algorithm ftroute 1 message detour mode current node closer destination node entered detour mode put message free mode 2 message free mode select set links along shortest paths destination message detour mode select link immediately counterclockwise link message entered node 3 selected links nonfaulty send message along link 4 links node already selected tested halt otherwise select link counterclockwise set previously selected links go step 3 accounting algorithm simple message need keep track destination node current state free detour distance destination message entered detour mode one problem algorithm halt message reaches destination current node nonfaulty links way detect unreachable destination intuitively seems message unreachable destination get cycle following theorems show message attempting reach unreachable des tination form cycle also show cycle take place entirely detour mode cycle include node message last entered detour mode link left node detecting cycle simple remembering node message entered detour mode link exited node message leave detour mode returns node entered detour mode leave node link cycle reach destination lemma 1 given message nonfaulty link node n nonfaulty link node n enters n detour mode remains detour mode leave n link entered link proof let first nonfaulty link clockwise one nonfaulty link node rest proof follows trivially description algorithm 2 lemma 2 finite mesh message never reaches destination eventually reach point never return free mode proof hop message makes free mode results transition detour mode free mode reduce one minimum distance message destination call hop reducing hop hop reducing hop must made detour mode message starts finite distance destination finite number reducing hops made message message reach destination theory undergo infinite number hops thus must last reducing hop path hops made message last reducing hop reducing hops message must detour mode 2 given show message must cycle theorem 1 finite homogeneous mesh message reach destination eventually cycle proof lemma 2 message reach destination eventually reach point never return free mode consider message reach destination entered detour mode permanently lemma 1 clear knowing current node outbound link enough determine future routing behavior message outbound link determines next node inbound link next node therefore outbound link next node turn determines outbound link next node call current node selected outbound link state message lemma 1 clear given current state sequence future states determined always whenever message state since finite number nodes finite number available outbound links per node finite number states message reach destination pass infinite number states must therefore pass state twice within finite amount time clearly constitutes cycle message returned observation return go sequence states continue return indefinitely since sequence states following always 2 show cycle must include node message entered detour mode theorem 2 message cycle return node message entered detour mode exit node via link proof assume message entered detour mode permanently cycle node could appear tour cycle node appears time message reaches node must exit node via different link used therefore step cycle may specified node outgoing link pick nodelink pair cycle find first occurrence pair last free node call n 1 since message detour mode lemma 1 shows nodelink pair n 2 preceding n 1 precede subsequent occurrences n 1 therefore n 2 cycle argument applies n 3 node message entered detour mode k link exited theorem follows 2 theorem 2 redefine step 3 ftroute detect cycles halt 3 selected links faulty go step 4 message detour mode entered detour mode node later left node selected link message cycle halt otherwise send message selected nonfaulty link point faulttolerant routing algorithm may cause message cycles presence cycles increase likelihood deadlock several reasons first message runs tail fit conditions theorem 2 therefore considered undeliverable discarded later consider modifications routing algorithm try deliver messages fit conditions theorem 2 even modifications deadlock still problem since message system based storeandforward system may employ virtual cutthrough message runs tail may buffered allow tail catch 4 cycles theorems 1 2 show routing algorithm always terminate remains us show fail deliver messages reachable destinations section consider types cycles exist imply regards reachability destination 41 types cycles cycles detected checking current node outgoing link node message entered detour mode corresponding outgoing link however tells us little cycle information gained exploiting directional properties links mentioned section 2 link corresponding vector vector correspond distance usually 1 one meshs available directions example torus right link vector length one x direction hmesh link degrees counterclockwise vertical vector length one z direction figure 3 circle define mesh vector sum path sum available directions vectors individual links path reducing appropriate example torus path goes right twice twice left mesh vector sum gamma2y reducing sum important hmesh example 1x 0y 1z equivalent 0x 1y 0z mesh vector sum traversed links kept message cycles divided two types first kind cycle characterized zero mesh vector sum message returns node cycle started kind cycle called circle case fig 3 message sent node 0 node 11 would travel along perimeter isolated mesh component return node 0 circle indicates mesh become disconnected shown later case circle destination reachable second kind cycle characterized nonzero mesh vector sum message returns node cycle started kind cycle called incision fig 4 shows example incision message sent node 0 node 1 would head upward nodes 8 9 17 5 12 back 0 incision necessarily indicate mesh become disconnected example shows destination may fact reachable path contains faults incisions possible unwrapped meshes mesh vector sum cycle plane must zero rest section assume cycle encounters faulty links ie faulty links checked least course cycle presence faults doesnt affect course cycle fixing make reachable destination unreachable figure 4 incision 42 circles circle indicates mesh become disconnected message tracing perimeter one connected components easier work planar graphs graph wrapped may longer planar however take advantage fact unwrapped graph planar wrapped graph homogeneous unroll graph form infinite planar graph result much like fig 4 extended infinitely directions theorem 3 message circle destination reachable proof jordan curve continuous nonselfintersecting curve whose origin terminus coincide union edges cycle planar graph form jordan curve path circle thus form jordan curve except cases link traversed twice derive true jordan curve connecting midpoints faulty links order tested routing algorithm curve run alongside path cycle since doesnt intersect true jordan curve also property links intersects faulty pass nodes jordan curve partition nodes planar graph two disjoint sets internal nodes external nodes path internal node external node must cross jordan curve unwrapped mesh single jordan curve two disjoint sets nodes wrapped mesh infinite number jordan curves curve define internal nodes finite set nodes external nodes rest plane links cross jordan curve faulty faultfree path cross jordan curve thus faultfree paths internal node node corresponding set external nodes remains show nodes cycle path destination node different sets assume nodes cycle internal nodes case external nodes similar consider node cycle closest destination link connected node shortest path destination must faulty started cycle nodes ends links external nodes since side jordan curve also closer destination node cycle consider shortest path one nodes destination faulty links path one nodes connected edge must cycle since faulty links checked course cycle would therefore closer destination node cycle closest destination since exists fault free path external node destination destination must external node faultfree path node cycle destination 2 43 incisions theorem 3 assures us message circle path destination noted incisions possible unwrapped mesh systems ftroute always deliver message reachable destination example fig 4 shows true wrapped meshes systems must modify algorithm try alternate routes destination main difficulty deciding alternate routes tried subsection consider method selecting alternatives 1 endpoint vector path mesh vector sum path endpoint distance path length endpoint vector definition 2 characteristic vector incision endpoint vector single trip cycle may easier think characteristic vector actual vector direction length infinite plane representation used discussing circles lemma 3 two incisions different characteristic vectors cross proof lemma obvious next theorem need introduce concept subdivision graph graph g contains subdivision graph h node h corresponding node g exists set nodedisjoint paths p g every link two nodes h path corresponding nodes g essentially nodes h replaced nodes g links h replaced nonintersecting paths g theorem 4 faulty links caused message go incision removed graph resulting graph planar proof graph planar contain subdivision either k 5 complete graph 5 vertices k 33 complete bipartite graph two sets 3 vertices show subdivision k 5 k 33 exists original mesh cross incision consider k 5 first least two paths corresponding edges k 5 must use wrap links mesh fact must two incisions nonparallel characteristic vectors subdivision k 5 see take subdivision k 5 complete mesh cut selected links resulting graph unwrapped mesh choose links cut fewest possible links subdivision k 5 cut resulting graph irregular mesh fragment much like fig 5 without wrap links resulting graph unwrapped incisions possible however cut links k 5 subdivision possible circles inherently planar circles subdivision k 5 untouched cutting therefore disrupted incisions single incision number parallel ones restored wrap links similar fig 5 graph remains planar since k 5 nonplanar must two nonparallel incisions subdivision similar argument holds k 33 must two nonparallel incisions subdivision k 33 since two nonparallel incisions subdivision k 5 least one incisions must nonparallel message incision lemma 3 message incision incision subdivision k 5 must cross similarly subdivision k 33 one incisions must cross message incision since subdivision k 5 k 33 crosses message incision must contain faulty links faulty links removed subdivisions longer possible since subdivisions k 5 k 33 present mesh faulty links removed resulting mesh must planar 2 planar embedding graph incision shown fig 4 shown fig 5 theorem 4 assures us message incision system graph planar tell us diameter graph resulting graphs much like figure 5 planar embedding faulty hmesh fig 5 irregular mesh fragment surrounded wrap links one edge mesh fragment formed incision distance two edges may vary must bounded properties original wrapped mesh definition 3 width mesh respect incision length shortest incision parallel width respect incision easy calculate x theta mesh either depending smaller whether incision parallel xaxis yaxis neither hmesh width always 2e gamma 1 e edge dimension mesh easily verified distance two edges mesh fragment always less width mesh respect incision width respect incision w path destination path destination one nodes cycle endpoint distance less w modify step 3 ftroute properly handle incisions 3 selected links faulty go step 4 message detour mode enter detour mode node later leave node selected link send message selected nonfaulty link otherwise message cycle cycle incision message incision compute w width mesh respect incision b node cycle find endpoint vectors length less w corresponding paths destination c determine many unique alternatives contained within vectors eliminate vectors point destination replicate message sending one copy alternative since copies taking shortest path destination recompute shortest path stick one modification guarantees messages reach destination destination reachable however comes price previous version algorithm usually implemented dedicated hardware network interface work involved modification usually require attention nodes main processor causes considerable overhead delay also another flag must maintained tell whether message original copy flag affect message routed whether message discarded runs incision practice unlikely properly handling incisions worth extra cost show next section incisions rare occur large number failures present 5 simulation simulation used determine performance ftroute simulations done torus cwrapped hexagonal mesh routing algorithm used simpler version effort made find alternate routes case incision done partly proper handling incisions adds great deal complexity algorithm therefore simulator partly intuitive notion incision failures would extremely rare intuition borne simulation results simulations link failures assumed uniform random distribution node failure equivalent failure links resulting distribution link failures nonuniform test simulations node failures results improved unexpected node failures resulting mesh regular fewer dead ends blind alleys found link failures simulation results 8torus 5dimensional hmesh plotted fig 6 8torus 64 node system 128 links 5hmesh 61 node system 183 links figs 6a 6b plot percentage messages deliverable percent actually delivered percentage links faulty upper line percentage messages deliverable ie destination reachable curve messages actually delivered simple routing algorithm percentage messages percent links faulty deliverable delivered messages vs percent percentage messages percent links faulty deliverable delivered b messages vs percent f f f f f f f f f f f f average number extra hops percent links faulty f 8torus c mean extra hops vs percent faulty 8torus f f f f f f f f f f f f f f f f f average number extra hops percent links faulty f 5hmesh mean extra hops vs percent figure algorithm performance small systems time indistinguishable deliverable curve figs 6c 6d show average difference length path routing algorithm took shortest path percentage links faulty remains small reasonable numbers failures results show simple algorithm works surprisingly well length little difference deliverable delivered curves agreeing intuition incision failures would rare path lengths encouraging also curve begin climb steeply nearly 20 links failed note advantage gained hmesh 50 percent links per node deliverable curve stays higher longer extra hops curve stays lower longer corresponding curves torus results fig 6 good relatively small systems also ran simulations 32torus 1024 nodes 19hmesh 1027 nodes results runs plotted fig 7 percentage messges percent links faulty deliverable delivered messages vs percent percentage messages percent links faulty deliverable delivered b messages vs percent f f f f f f f f f f average number extra hops percent links faulty f 32torus c mean extra hops vs percent faulty 32torus f f f f f f f f f f average number extra hops percent links faulty f 19hmesh mean extra hops vs percent figure 7 algorithm performance large systems graphs much smaller systems ways improvement larger systems figs 7a 7b deliverable delivered curves nearly indistinguishable slight gap curves seen figs 6a 6b present also seen deliverable delivered curves reach 0 faster smaller systems largely result mesh diameter larger systems paths destination paths much longer therefore likely contain faults greater number paths offset increased probability path faulty figs 7c 7d see peak extra number hops curve increased faster mesh size unexpected since larger mesh opportunities turn blind alleys offset somewhat fact extra hops curves large meshes begin rapid climb much later 6 conclusion paper presented faulttolerant routing algorithm use multicomputers mesh type interconnections works wrapped unwrapped meshes simulations show messages delivered nearminimal paths even presence large numbers link failures almost cases message reach destination destination reachable cases message reach destination algorithm determine within finite amount time rare cases wrapped meshes message delivered destination reachable happen unless fairly large number faults present algorithm extended considerable expense complexity properly handle cases considered square hexagonal meshes paper algorithm work mesh types require unwrapped version mesh planar graph wrapped mesh homogeneous r adaptive faulttolerant routing hypercube multicomputers addressing routing broadcasting hexagonal mesh multiprocessors hyperswitch network hypercube computer virtual new computer communication switching technique adaptive packet routing hypercube distributed fault tolerance large multiprocessor systems faulttolerant routing permutations extrastage networks tr hyperswitch network hypercube computer adaptive packet routing hypercube addressing routing broadcasting hexagonal mesh multiprocessors adaptive faulttolerant routing hypercube multicomputers distributed faulttolerance large multiprocessor systems
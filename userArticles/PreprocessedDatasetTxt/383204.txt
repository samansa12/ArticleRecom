strobe algorithms multisource warehouse consistency warehouse data repository containing integrated information efficient querying analysis maintaining consistency warehouse data challenging especially data sources autonomous views data warehouse span multiple sources transactions containing multiple updates one sources eg batch updates complicate consistency problem paper identify discuss three fundamental transaction processing scenarios data warehousing define four levels consistency warehouse data present new family algorithms strobe family maintain consistency warehouse updated various warehousing scenarios algorithms incremental handle continuous overlapping stream updates sources implementation shows algorithms practical realistic choices wide variety update scenarios b introduction data warehouse repository integrated information distributed autonomous possibly heterogeneous sources figure 1 illustrates basic warehouse architecture source monitor collects data interest sends warehouse monitors responsible identifying changes source data notifying warehouse warehouse integrator receives source data performs necessary data integration translation adds extra desired informa tion timestamps historical analysis tells warehouse store data effect warehouse caches materialized view source data13 data readily available user applications querying analysis current commercial warehousing systems eg prism redbrick focus storing data efficient access providing extensive querying facilities warehouse ignore comple work partially supported rome laboratories air force contract f3060294c0237 equipment grant digital equipment corporation monitor data warehouse monitor monitor integrator user applications figure 1 data warehouse architecture mentary problem consistently integrating new data assuming happens line queries run course discovering many customers international operations multiple time zones convenient time night weekend recent updates batched processed together materialized views recomputed furthermore updates occur time window may longer sufficient process updates 7 thus substantial interest warehouses absorb incoming updates incrementally modify materialized views warehouse without halting query processing paper focus process ensure queries see consistent data crux problem arriving update may need integrated data sources stored ware house processing updates may arrive warehouse causing warehouse become inconsistent following example illustrates inconsistencies may arise simplicity assume warehouse sources use relational model materialized view kept warehouse contains key participating relation example update separate transaction one sources also assume integrator tightly coupled warehouse therefore although view maintenance computation done integrator actual view operation done warehouse use term warehouse wh denote combination integrator warehouse figure 1 example 1 view maintenance anomaly multiple sources view v defined three relations residing sources x z respectively initially relations materialized view warehouse consider two source updates u 2 using conventional incremental view maintenance algorithm 2 following events may occur wh 1 wh receives u source generates query r 3 evaluate q 1 wh first sends query 3 source x 2 wh receives 1 3 source x query sent source z evaluation 3 wh receives u source x since current view empty action taken deletion 4 wh receives 2 3 4 source z final answer q 1 since pending queries updates answer inserted mv final view incorrect 2 example interleaving query q 1 updates arriving sources causes incorrect view note even warehouse view updated completely recomputing view approach taken several commercial systems bull pyramid warehouse subject anomalies caused interleaving updates recomputation two straightforward ways avoid type inconsistency argue general neither one desirable first way store copies relations warehouse example could atomically evaluated warehouse causing tuple 1 2 3 4 added mv arrives tuple deleted mv yielding correct final warehouse state solution may adequate applications believe several disadvantages first storage requirement warehouse may high instance suppose r 3 contains data companies eg name stock price profit history copy r 3 warehouse need keep tuples companies exist anywhere world currently interested tracking keep data companies future may able answer query refers new company company previously track unable atomically update warehouse second warehouse must integrate updates source data data interest company example would need update stock prices companies prices change represent high update load 4 much data may never need third due cost copyright security storing copies source data may feasible example source access charges may proportional amount data track warehouse second straightforward way avoid inconsistencies run update actions needed incrementally integrate warehouse distributed transaction spanning warehouse sources involved example runs part distributed transaction read consistent snapshot properly update warehouse however distributed transactions require global concurrency control mechanism spanning sources may exist even sources may unwilling tolerate delays come global concurrency control instead approach make queries appear atomic processing intelligently warehouse without requiring warehouse copies relations example warehouse notes deletion u 2 arrived warehouse processing query q 1 therefore answer 1 may contain tuples reflect deleted r 1 tuple indeed 1 contains 1 2 3 4 exist deleted r 1 thus warehouse removes tuple leaving empty answer materialized view left empty correct state updates take place example gives flavor solution present details explain algorithms note intelligent processing updates warehouse depends sources run transactions sources run transactions need treat updates whether came one source multiple sources atomic units combining updates atomic warehouse actions introduces additional complexities handled algorithms since wish assume particular transaction scenario paper cover three main possibilities sources run transac tions sources run local global transac tions sources run global transactions although fairly broad transaction scenarios consider make two key simplifying assumptions assume warehouse views defined relational project select join psj op erations assume views include keys relations involved believe psj views common therefore good subproblem focus initially believe requiring keys reasonable assumption since keys make easier applications interpret handle warehouse data furthermore userspecified view contain sufficient key information warehouse simply add key attributes view definition developed view maintenance algorithms case key data present discussed substantially complex ones presented another reason including keys view previous work 17 considered restricted scenario warehouse data arrived single source even simple case consistency problems developed algorithms solving however realistic multisource scenario becomes significantly complex maintain consistent views instance eca ecakey algorithms 17 provide consistency example 1 lead incorrect execution shown particular complexities covered earlier work follows ffl update one source may need integrated data several sources however gathering data corresponding one view update atomic operation matter fast warehouse generates appropriate query sends sources receiving answer atomic parts come different autonomous sources nonetheless view updated sources queried atomically ffl individual sources may batch several updates single sourcelocal transaction example warehouse may receive entire days updates one transaction updates integration data sources appear atomically warehouse fur thermore updates several sources may together comprise one global transaction must handled atomically complexities lead substantially different solutions particular main contributions paper 1 define discuss update transaction scenarios require increasingly complex algorithms 2 identify four levels consistency warehouse views defined multiple sources increasing order difficulty guarantee note concurrent query update processing warehouses becomes common warehouse applications grow beyond statistical analysis concern users consistency data accessing 7 thus believe important offer customers variety consistency options ways enforce 3 develop strobe family algorithms provide consistency transaction scenarios implemented strobe algorithms warehouse prototype 16 demonstrating algorithms practical efficient 4 map space warehouse maintenance algorithms figure 2 algorithms present paper provide wide number options consistency distribution space remainder paper organized follows discuss related work section 2 section 3 define three transaction scenarios specify assumptions order messages events warehouse environment section 4 define four levels consistency correctness discuss might desirable describe new algorithms section 5 apply algorithms examples also demonstrate levels consistency algorithm achieves different transaction scenarios section 6 adapt algorithms warehouse reflect every update individually show algorithms terminate conclude section 7 outlining optimizations algorithms future work related research work describe paper closely related research three fields data warehousing data consistency incremental maintenance materialized views discuss turn data warehouses large repositories analytical data recently generated tremendous interest industry general description data warehousing idea may found 11 companies red brick prism built specialized data warehousing software almost database vendors sybase oracle ibm targeting existing products data warehousing applications warehouse holds copy source data essentially distributed database system replicated data however autonomy sources traditional concurrency mechanisms often applicable 3 variety concurrency control schemes suggested years environments either provide weaker notions consistency eg 6 exploit semantics applications algorithms present paper exploit semantics materialized view maintenance obtain consistency without traditional distributed concurrency control furthermore offer variety consistency levels useful context warehousing many incremental view maintenance algorithms developed centralized database systems eg 2 9 5 good overview materialized views maintenance found 8 solutions assume single system controls base relations understands views hence intelligently monitor activities compute information needed updating views showed example 1 centralized algorithm applied warehouse warehouse user may see inconsistent views source data inconsistent views arise regardless whether centralized algorithm computes changes using old base relations 2 using new base lations 5 crux warehouse problem exact state base relations old new incremental changes computed sources unknown algorithms filter add recent modifications dynamically previous distributed algorithms view mainte nance 14 12 rely timestamping updated tuples warehousing environment sources legacy systems cannot assume help transmitting necessary data attaching timestamps hull zhou 10 provide framework supporting distributed data integration using materialized views however approach first materializes base relation relevant portion computes view materialized copies hand propose algorithms maintain joined views directly without storing auxiliary data compare definition consistency section 4 another recent paper baralis et al 1 also uses timestamps maintain materialized views warehouse however assume warehouse never needs query sources data hence circumventing consistency problems address warehouse often processes updates one transactions batch mode conventional algorithms way ensure entire transaction reflected view time batch representing entire day hour week minute updates propagated view simul taneously paper present view maintenance algorithms address problems finally mentioned section 1 17 showed provide consistency restricted singlesource environment study general case multiple sources transactions may span sources 3 warehouse transaction environment complexity designing consistent warehouse algorithms closely related scope transactions sources larger scope trans action complex algorithm becomes section define three common transaction sce narios increasing order complexity spell assumptions warehouse environment particular address ordering messages sources warehouse define source event use relational model simplicity update therefore consists single tuple action inserting deleting tuple 31 update transaction scenarios three transaction scenarios consider paper 1 single update transactions single update transactions simplest update comprises transaction reported warehouse separately actions legacy systems transactions fall category change detected source monitor sent warehouse single update transaction 2 sourcelocal transactions sourcelocal transaction sequence actions performed source together comprise one transac tion goal therefore reflect actions atomically warehouse assume source local serialization schedule sourcelocal transactions single update transactions special cases sourcelocal transactions database sources example likely sourcelocal transactions also consider batches updates reported together single sourcelocal transaction 3 global transactions scenario global transactions contain actions performed multiple sources assume global serialization order global trans actions matter order transactions warehouse goal therefore reflect global transactions atomically warehouse depending much information warehouse receives transaction goal less achiev able example unless global transaction identifiers entire transaction reported single source warehouse cannot tell sourcelocal transactions together comprise global transaction transaction scenario make slightly different assumptions content messages 32 messages two types messages sources warehouse reporting update returning answer query one type message direction warehouse may send queries sources assume single update transaction sourcelocal transaction reported one message time transaction commits exam ple relational database source might trigger sending message transaction commit 15 however batching multiple transactions message affect algorithms section 5 global transactions updates delivered variety ways example site commits transaction may collect updates send warehouse commit point alternative site may send updates knows global transaction committed section 54 discuss implications different schemes 33 event ordering source action plus resulting message sent warehouse considered one event ex ample evaluating query source sending answer back warehouse considered one event assume events atomic ordered sequence corresponding actions 18 discuss assumption hold also assume two messages sent one source warehouse delivered order sent enforced numbering messages place restrictions order messages sent different sources warehouse delivered 34 discussion practice update transaction scenario seen warehouse depends primarily capabilities underlying sources example currently common practice report updates source pe riodically instead reporting change monitor might send changes occurred last hour day warehouse single batch transaction periodic snapshots may way monitor unsophisticated legacy source report changes monitor might choose report updates lazily warehouse need kept strictly date general smarter monitors help group classify updates coordinate global transactions save warehouse processing may enable warehouse achieve higher level consistency see section 54 believe today warehouse transaction environments support either singleupdate transactions sourcelocal transactions communication coordination sources still completeness believe important understand global transaction scenario may likely future 4 correctness consistency describing algorithms first define means algorithm correct environment activity sources decoupled view warehouse particular concerned means warehouse view consistent original source data since source update may involve fetching data multiple sources order update warehouse view first define states sources warehouse 41 source warehouse states warehouse state ws represents contents warehouse warehouse state changes whenever view updated let warehouse states assume final warehouse state activity ceases consider one view v warehouse defined set base relations one sources view state ws j v ws j let u sources source unique id x 1 x u source state ss vector contains u elements represents visible state source given instant time x th component ssx state source x source states represent contents source base relations assume source updates executed serializable fashion across sources ie serial schedule represents execution dates however constitutes transaction varies according scenario assume ss q final state completes v ss result computing view v source state ss relation r source x contributes view v ss evaluated r state ssx source transaction guaranteed bring sources one consistent state another serial schedule r use resultr refer source state vector results execution 42 levels consistency assume view warehouse initially synchronized source data ie v ss ws 0 define four levels consistency warehouse views level subsumes prior levels definitions generalization ones 17 multisource warehouse environment 1 convergence finite executions last update activity ceased view consistent source data 2 weak consistency convergence holds ws exists source state vector ss j v ws source x exists serial schedule subset transactions warehouse state reflects valid state source locally serializable schedule source achieves state however source may reflect different serializable schedule warehouse may reflect different set committed transactions source 3 strong consistency convergence holds exists serial schedule r mapping warehouse states source states following properties serial schedule r equivalent actual execution transactions sources defines sequence source states ss reflects first j transactions ie ss r prefix j transactions ii ws iii ws warehouse state reflects set valid source states reflecting globally serializable schedule order warehouse states matches order source actions 4 completeness addition strong consis tency every ss j defined r exists ws mws complete orderpreserving mapping states view states sources hull zhous definition consistency replicated data 10 similar strong consistency except also require global timestamps across sources also strong consistency less restrictive require fixed order two nonconflicting actions definition compatible standard serializability theory fact consistency definition rephrased terms serializability theory treating warehouse view evaluation read transaction sources 18 although completeness nice property since states view tracks base data exactly believe may strong requirement unnecessary practical warehousing scenarios cases convergence may sufficient ie knowing eventually warehouse valid state even passes intermediate states invalid cases strong consistency desir able ie knowing every warehouse state valid respect source state next section show algorithm may achieve different levels consistency depending update transaction scenario applied algorithms section present strobe family algorithms strobe algorithms named strobe lights periodically freeze constantly changing sources consistent view warehouse algorithm designed achieve specific level correctness one three transaction processing scenarios discuss algorithms increasing level complex ity strobe algorithm simplest achieves strong consistency single update trans actions transactionstrobe algorithm achieves strong consistency sourcelocal transactions globalstrobe algorithm achieves strong consistency global transactions section 6 present modifications algorithms attain completeness respective transaction scenarios 51 terminology first introduce terminology use describe algorithms view v warehouse n relations defined projectselectjoin psj expression two relations may reside different sources relational algebra expression constructed project select join operations transformed equivalent expression form moreover although describe algorithms psj views ideas used adapt existing centralized view maintenance algorithm warehousing environment mentioned introduction assume projection list contains key attributes relation expect applications require anyway added view warehouse view defined multiple sources update one source likely initiate multisource query q warehouse since cannot assume sources cooperate answer q warehouse must therefore decide send query first suppose given query q needs evaluated function next sourceq returns pair x next source contact q portion q evaluated x q need evaluated x nil answer received warehouse response subquery q query qha denotes remaining query answer incorporated query q 2 psj queries next source always choose source containing relation joined known part query rather requiring source ship entire base relation warehouse may even possible see later queries generated algorithm also unions psj expressions queries next source simply selects one expressions evaluation improvement would find common subexpressions example 2 using next source let relations r reside sources x spectively let update relation r 2 received ware house therefore query next warehouse receives answer 1 x qha 1 r 3 next since one relation left join query 2 final answer 2 example query sent source x first alternatively next one possible relation join intermediate result next source may use statistics used query optimizers decide part query evaluate next ready define procedure source evaluate loops compute next portion query q final result answer ceived procedure wq working query portion query q ie part q yet evaluated procedure source evaluateq x nil source x x returns let end procedure procedure source evaluateq may return incorrect answer concurrent transactions sources interfere query eval uation example example 1 saw delete occurs source subquery evaluated final answer computed may skipped final query result subtle problems result two subqueries query sent source evaluation different times join different relations use different source states two subqueries evaluated two different sources states inconsistent key idea behind strobe algorithms keep track updates occur query evaluation later compen sate introduce strobe family basic algorithm simplicity consider insertions deletions algorithms conceptually modifications tuples updates sent warehouse treated warehouse simply deletion old tuple followed insertion new tuple however consistency performance delete insert handled time algorithms easily extended type processing discussion treat modification insert delete may found 8 52 strobe strobe algorithm processes updates ar rive sending queries sources necessary however updates performed immediately materialized view mv instead generate list actions al performed view update mv sure applying actions al single transaction ware house bring view consistent state occurs outstanding queries received updates processed warehouse receives deletion generates delete action corresponding tuples matching key values mv insert arrives warehouse may need generate process query using procedure source evaluate q query answered sources updates may arrive warehouse answer obtained may missed effects compensate keep set pendingq updates occur q processed qs answer fully compen sated insert action mv generated placed action list al definition unanswered query set uqs set queries warehouse sent source yet received answerdefinition operation key deleter u deletes relation r tuples whose key attributes values u 2 denotes view expression v tuple u substituted u relation 2 algorithm 1 strobe algorithm source executing update u send u warehouse upon receipt query q compute answer ssx current source state send warehouse warehouse initially al set empty h upon receipt update u deletion add key deletemv u al insertion apply apply al mv single transaction without adding duplicate tuples mv reset end algorithm 1 following example applies strobe algorithm warehouse scenario example 1 intro duction specifically shows deletion needs applied answer previous query previous querys answer arrives warehouse later deletion example 3 strobe avoids deletion anomaly example 1 let view v defined three relations residing sources x z respectively initially relations materialized view consider two source updates u apply strobe algorithm 1 wh receives u source generates query 2 3 r 3 evaluate q 1 wh first sends query 3 source x 2 wh receives 1 3 source x query sent source z evaluation 3 wh receives u source x first adds u 2 pendingq 1 adds key deletemv u 2 al resulting 4 wh receives 2 3 4 source z since pendingq empty wh applies resulting answer therefore nothing added al pending queries wh updates mv applying resulting final view correct strongly consistent source relations 2 example demonstrates strobe avoids anomaly caused ecakey conventional view maintenance algorithms incorrect remembering delete end query strobe able correctly apply query result updating view mv deletion u 2 received q 1 1 sent source x 1 would empty extra action would necessary strobe algorithm provides strong consistency singleupdate transaction environments correctness proof given 18 intuition time mv modified updates quiesced view contents obtained evaluating view expression current source states fore although source states reflected view view always reflects consistent set source states 53 transactionstrobe transactionstrobe tstrobe algorithm adapts strobe algorithm provide strong consistency sourcelocal transactions tstrobe collects updates performed one transaction processes updates single unit batching updates transaction makes easier enforce consistency also reduces number query messages must sent sources update list transaction ult contains inserts deletes performed order ilt ult insertion list contains insertions performed 2 denotes key attributes inserted deleted tuple u u u j denote tuple although attributes may modified 2 source actions tstrobe therefore present warehouse ac tions first wh removes pairs insertions deletions tuple first inserted deleted removal optimization avoids sending query insertion later delete answer next wh adds remaining deletions action list al finally wh generates one query insertions deletions arrive wh query generated subtracted query result following example demonstrates strobe algorithm may achieve convergence tstrobe algorithm guarantees strong consistency sourcelocal transactions strobe algo algorithm 2 transactionstrobe algorithm warehouse initially upon receipt ult transaction u insertion u k deletion u ult ffi every deletion u 2 ult add u pendingq j add key deletemv u al set pendingq apply al mv without adding duplicate tuples mv reset end algorithm 2 rithm understand transactions may provide view corresponds middle transaction source state however strobe eventually provide correct view transaction commits therefore convergent example 4 tstrobe provides stronger consistency strobe consider simple view one source defined assume attribute key relation r 1 originally relation r initially 2 consider one source strobe algorithm applied sce nario warehouse firsts adds deletion al since pending updates al applied mv mv updated consistent r 1 either 1 warehouse processes insertion updates mv correct view tstrobe algorithm hand updates mv updates transaction processed therefore mv updated directly correct view tstrobe algorithm inherently strongly consistent respect source states defined sourcelocal transaction 1 tstrobe also pro 1 note incidentally modifications treated deleteinsert pair tstrobe process pair within single transaction easily avoiding inconsistencies however performance reasons may still want modify tstrobe handle modifications third type action processed cess batched updates necessarily generated transaction sent warehouse time source case tstrobe also guarantees strong consistency define consistent source states corresponding batching points sources since common practice today send updates sources periodically batches believe strobe probably useful algorithm singleupdate transactions tstrobe reduces algorithm 54 globalstrobe tstrobe algorithm strongly consistent sourcelocal transactions weakly consistent global transactions present 18 present example illustrates develop new algorithm globalstrobe gstrobe guarantees strong consistency global transactions g strobe tstrobe except updates mv actions al following three conditions met tstrobe requires condition 1 let tt set transaction identifiers warehouse received since last updated mv 1 2 transaction tt depends concurrency control sense another transaction also tt 3 updates transactions tt received processed due space limitations present g strobe 6 completeness termination algorithms problem strobe tstrobe gstrobe continuous source updates algorithms may reach quiescent state uqs empty materialized view mv updated address problem section present algorithm complete strobe cstrobe update mv source update example c strobe propagate updates mv particular batch updates received long period time gone without natural quiescent point simplicity describe cstrobe enforcing update mv update case cstrobe achieves completeness extension update mv arbitrary number updates straightforward enforces strong consistency force update mv update u arrives warehouse need compute resulting view however concurrent updates sources complicate problem particular consider case u insertion compute next mv state warehouse sends query q sources time answer arrives warehouse stated earlier describe straightforward extension warehouse may received processed updates may reflect effects later updates use update mv warehouse must subtract effects later updates else get consistent state one later updates say u j insert remove corresponding tuples however u j delete warehouse may need add tuples compute missing tuples must send additional queries sources answers additional queries arrive warehouse may also adjusted updates saw reflected mv fortunately show process converge eventually warehouse able compute consistent mv state follows u updates mv warehouse processes u i1 fashion presenting algorithm need definitions denotes set queries sent warehouse compute view insertion update queries sent response update u j occurred computing answer query q used distinguish query q ij q ijk 2 scenario insert u first generate q ii0 answer ii0 arrives deletion u j received ii0 requires us send another query identified q ijnew j algorithm new j used generate next unique integer queries caused u j context processing u processing update u separately action list al necessary strobe tstrobe algorithms al keeps track multiple updates whose processing overlaps cstrobe algorithm outlined update compensated subse quent held updates applied directly view cstrobe extended shown force updates mv periodically batch overlapping updates action list al necessary remember actions applied entire batch resulting query updated tuple u replaces base relation q base relation u appear q set changes need applied mv one insertion update note delta computed would correspond single insertmv delta action al kept action list deletion updates applied directly mv insertions must compensated first delta collects compensations 2 also use slightly different version key delete delete delta u k deletes delta tuples match u k key nonkey attributes key attributes finally add tuples delta allow tuples key values different nonkey values added tuples violate key condition appear delta temporarily however important keep delta algorithm work cor rectly reason changes subtract updates seen q ii0 first compensate deletes inserts may two tuples key one added compensation delete deleted compensate inserts algorithm cstrobe source behavior remains strobe algorithm describe actions warehouse cstrobe complete mv updated update resulting warehouse state corresponds source state update prove correctness cstrobe 18 algorithm 3 complete strobe warehouse initially updates arrive placed holding queue process update u order arrival deletion apply key deletemv u insertion repeat ijk add ijk delta without adding duplicate tuples ffi deletions u p received u j ijk answer arrives process starting 4 lines insertions u k received u last answer 9u j u k u j deletion u j u k refer tuple apply key delete delta u k end algorithm 3 compensating process loop al gorithm always terminates expression one fewer base relation us assume k updates arrive time query sent answer received n base relations process insertion u send query q get answer may send k compensating queries base relations queries k queries relations may sent thus total number queries sent loop k ngamma2 algorithm eventually finishes processing u updates mv number compensating queries may significantly reduced combining related queries ex ample compensate q ii0 algorithm sends k queries however since n base relations group queries queries combined query groups queries generated update base relation continue group queries base relation see total number compensating queries cannot exceed ngamma1thetangamma2theta cstrobe update mv queries evaluated view involves small number relations bound relatively small course maximum number queries occurs extreme conditions continuous stream updates apply cstrobe algorithm warehouse scenario example 1 show cstrobe processes scenario differently strobe algorithm shown example 3 example 5 complete strobe examples 1 3 let view v defined three relations residing sources x z respectively initially relations materialized view consider two source updates u apply cstrobe algo rithm two possible orderings events warehouse consider one next example discuss 1 wh receives source u generates query q 2 3 r 3 evaluate q 110 wh first sends query 3 source x 2 wh receives 1 3 source x query sent source z evaluation 3 wh receives u source x saves update queue 4 wh receives source z final answer q 110 received q 110 110 deletion wh generates query sends source z also adds 110 delta 5 wh receives add delta since duplicate tuple remains wh updates view 7 next wh processes u 2 next update queue since u 2 deletion applies example mv updated twice steps 6 7 step 6 mv equal result evaluating v u 1 u 2 occurs similarly step 7 mv corresponds evaluating v updates occur final source state example next example consider case u 2 occurs evaluation query corresponding u 1 show compensating queries necessary example applied different timing updates let view definition initial base relations source updates example 5 consider different set events wh 1 wh receives source u generates query q 2 3 r 3 evaluate q 110 wh first sends query 3 source x 2 wh receives u source x saves update queue 3 wh receives 1 source x implies received q 110 110 wh generates compensating query q sends source z also adds 110 delta still empty 4 wh receives adds delta 5 since uqs wh updates view 6 wh processes u 2 since u 2 deletion applies key delete mvu 2 mentioned earlier cstrobe extended update mv periodically processing every k dates case periodically stop processing updates placing holding queue process answers queries uqs cstrobe apply action list al view mv tstrobe algorithm also made complete periodic similar way call algorithm ctstrobe describe conclusions paper identified three fundamental transaction processing scenarios data warehousing developed strobe family algorithms consistently maintain warehouse data figure 2 summarizes algorithms discussed paper correctness figure conventional refers conventional centralized view maintenance algo rithm eca ecakey algorithms 17 conv entional single update trans global trans single source consistent weakly consistent ecakey conv entional ecakey transaction scenarios centralized inconsistent convergent tstrobe gstrobe tstrobe ctstrobe cgstrobe cstrobe complete correctness multiple sources figure 2 consistency spectrum figure 2 algorithm shown particular scenario level consistency l achieves l consistency scenario furthermore algorithm l also achieves lower levels consistency achieves l consistency scenarios less restrictive scenarios left example strobe strongly consistent single update transactions multiple sources therefore weakly consistent convergent definition scenario similarly strobe strongly consistent centralized single source scenarios regarding efficiency algorithms presented four important points make first variety enhancements improve efficiency substantially 1 optimize global query evaluation ex ample procedure source evaluate warehouse group queries one source one find order sources minimizes data transfers also use key information avoid sending queries sources 2 find optimal batch size processing batching together updates reduce message traffic sources however delaying update processing means warehouse view date clear tradeoff would like explore 3 although argued keeping copies base relations warehouse may make sense copy frequently accessed ones portions thereof large expensive keep date also increases number queries answered locally second point regarding efficiency even someone determines none algorithms efficient enough application still important understand tradeoffs involved algorithms exemplify inherent cost keeping warehouse consistent given costs users determine best given consistency requirements transactional scenario third updates arrive infrequently warehouse periodic batches large gaps strobe algorithms efficient conventional algorithms 2 introduce extra complexity updates must processed updates arriving ware house conventional algorithms cannot guarantee consistent view fourth strobe algorithms relatively inexpensive implement incorporated whips warehousing information prototype stanford prototype 16 implementation strobe algorithm 50 lines c code conventional view maintenance algo rithm cstrobe another 50 lines code core algorithms 400 lines c code including evaluating query ability guarantee correctness strobe ability batch transactions ability update view consistently whenever desired without quiescing updates cstrobe cost approximately 100 lines code one programmer day part ongoing warehousing work currently evaluating performance strobe tstrobe algorithms considering optimizations mentioned also extending algorithms handle general type views example views insufficient key information views defined complex relational algebra expressions future work includes designing maintenance algorithms coordinate updates multiple warehouse views acknowledgments would like thank jennifer widom jose blakely discussions led ideas paper r conservative timestamp revised materialized view maintenance data warehouse efficiently updating materialized views multidatabase system tracking retrieval financial data algorithms deferred view mainte nance improving performance replicated databases relaxed coherency maintenance materialized views problems maintaining views incrementally framework supporting data integration using materialized virtual approaches rdbvms developing data warehouse snapshot differential refresh algo rithm special issue materialized views data warehousing updating distributed materialized views system prototype warehouse view maintenance view maintenance warehousing environment strobe algorithms multisource warehouse consistency tr ctr clemente garcia real time selfmaintenable data warehouse proceedings 44th annual southeast regional conference march 1012 2006 melbourne florida lyman pamela drew wei jin vish jumani david van rossum issues developing large data warehouses proceedings 24rd international conference large data bases p633636 august 2427 1998 j labio yue zhuge janet l wiener himanshu gupta hctor garcamolina jennifer widom whips prototype data warehouse creation maintenance acm sigmod record v26 n2 p557559 june 1997 chingming chao incremental maintenance objectoriented data warehouses information sciencesinformatics computer science international journal v160 n14 p91110 22 march 2004 bin liu elke rundensteiner david finkel maintaining large update batches restructuring grouping information systems v32 n4 p621639 june 2007 ding xin zhang elke rundensteiner mre wrapper enabling incremental view maintenance data warehouses defined multirelation information sources proceedings 2nd acm international workshop data warehousing olap p3035 november 0206 1999 kansas city missouri united states miranda chan hong incremental update aggregated information data warehouses internet proceedings 3rd acm international workshop data warehousing olap p5764 november 0611 2000 mclean virginia united states ki yong lee jin hyun son myoung ho kim efficient incremental view maintenance data warehouses proceedings tenth international conference information knowledge management october 0510 2001 atlanta georgia usa kenneth salem kevin beyer bruce lindsay roberta cochrane roll join asynchronous incremental view maintenance acm sigmod record v29 n2 p129140 june 2000 stanoi agrawal el abbadi h phatak b r badrinath data warehousing alternatives mobile environments proceedings 1st acm international workshop data engineering wireless mobile access p110115 august 2020 1999 seattle washington united states magalhes pequeno vnia maria ponte vidal using full match classes selfmaintenance mediated views enterprise information systems iv kluwer academic publishers hingham zohra bellahsene schema evolution data warehouses knowledge information systems v4 n3 p283304 july 2002 zohra bellahsene view adaptation fragmentbased approach ieee transactions knowledge data engineering v16 n11 p14411455 november 2004 agrawal el abbadi singh yurek efficient view maintenance data warehouses acm sigmod record v26 n2 p417427 june 1997 ken c k lee hong v leong antonio si incremental maintenance dynamic databasederived html pages digital libraries proceedings seventh international conference information knowledge management p2029 november 0207 1998 bethesda maryland united states wang maria orlowska weifa liang efficient refreshment materialized views multiple sources proceedings eighth international conference information knowledge management p375382 november 0206 1999 kansas city missouri united states khalil ahmed nagwa elmakky yousry taha effective data mining data warehousebackboned architecture proceedings 1998 conference centre advanced studies collaborative research p1 november 30december 03 1998 toronto ontario canada kyriakos karenos george samaras panos k chrysanthis evaggelia pitoura mobile agentbased services view materialization acm sigmobile mobile computing communications review v8 n3 july 2004 gianluca moro claudio sartori incremental maintenance multisource views proceedings 12th australasian database conference p1320 january 29february 01 2001 queensland australia h engstr chakravarthy b lings maintenance policy selection heterogeneous data warehouse environments heuristicsbased approach proceedings 6th acm international workshop data warehousing olap november 0707 2003 new orleans louisiana usa yingwei cui jennifer widom janet l wiener tracing lineage view data warehousing environment acm transactions database systems tods v25 n2 p179227 june 2000 xin zhang lingli ding elke rundensteiner parallel multisource view maintenance vldb journal international journal large data bases v13 n1 p2248 january 2004 songting chen bin liu elke rundensteiner multiversionbased view maintenance distributed data sources acm transactions database systems tods v29 n4 p675709 december 2004 dimitri theodoratos timos k sellis data warehouse configuration proceedings 23rd international conference large data bases p126135 august 2529 1997 dimitri theodoratos mokrane bouzeghoub general framework view selection problem data warehouse design evolution proceedings 3rd acm international workshop data warehousing olap p18 november 0611 2000 mclean virginia united states waiman cheung gilbert babin metadatabaseenabled executive information system part flexible adaptable architecture decision support systems v42 n3 p15891598 december 2006 andreas koeller elke rundensteiner historydriven approach evolving views meta data changes knowledge information systems v8 n1 p3467 july 2005 ladjel bellatreche kamalakar karlapalem mukesh mohania issues design data warehousing systems data warehousing web engineering irm press hershey pa 2002
syntactic theory dynamic binding dynamic binding traditionally always associated lisp still semantically obscure many even though programming languages favour lexical scope dynamic binding remain interesting expressive programming technique specialised circumstances also key notion formal semantics article presents syntactic theory enables programmer perform equational reasoning programs using dynamic binding theory proved sound complete respect derivations allowed programs dynamicenvironment passing style theory derive sequential evaluation function contextrewriting system refine evaluation function two popular implementation strategies deep binding shallow binding value cells afterwards following saying deep binding suitable parallel evaluation present parallel evaluation function futurebased functional language extended constructs dynamic binding finally exhibit power usefulness dynamic binding two different ways first prove dynamic binding adds expressiveness purely functional language second show dynamic binding essential notion semantics used define exceptions b introduction dynamic binding traditionally associated lisp dialects appeared mccarthys lisp 10 24 bug became feature succeeding implemen tations like instance maclisp 2 28 gnu emacs lisp 23 even modern dialects language favour lexical scoping provide form dynamic variables special declarations common lisp 43 even simulate dynamic binding lexicallyscoped variables mitschemes fluidlet 18 lexical scope become norm imperative languages also functional languages scheme 39 common lisp 43 standard ml 26 haskell 21 scope name binding text occurrences name refer binding lexical scoping imposes variable expression refers innermost lexicallyenclosing construct declaring variable rule implies nested declarations follow block structure organisation contrary scope name said indefinite 43 references may occur anywhere program hand dynamic binding refers notion dynamic extent dynamic extent expression lifetime expression starting ending control enters exits expression dynamic binding binding exists used dynamic extent expression dynamic variable refers latest active dynamic binding exists variable 1 expression dynamic scope convenient refer indefinite scope variable dynamic extent 43 dynamic binding initially defined metacircular evaluator 24 later formalised denotational semantics gordon 15 16 also part research supported part epsrc grant grk30773 authors address department electronics computer science university southampton southampton so17 1bj united kingdom email lmoreauecssotonacuk least interpreted mode folklore exists translation dynamicenvironment passing translation translates programs using dynamic binding programs using lexical binding 36 p 180 like continuationpassing transform 35 dynamicpassing translation adds extra argument function dynamic environment every reference dynamic variable translated lookup current dynamic environment late eighties saw apparition syntactic theories new semantic framework allows equational reasoning programs using nonfunctional features like firstclass continuations state 10 11 12 44 frameworks later extended take account parallel evaluation 9 14 29 30 purpose paper present syntactic theory allows user perform equational reasoning programs using dynamic binding contribution fivefold first dynamicenvironment passing translation construct inverse translation using sabry felleisens technique 40 41 derive set axioms define calculus prove sound complete respect derivations accepted dynamicenvironment passing style section 3 second devise sequential evaluation function ie algorithm prove return value whenever calculus evaluation function relies contextrewriting technique 11 presented section 4 third order strengthen claim dynamic binding expressive programming technique useful notion semantics give formal proof expressiveness use definition exceptions section 5 define relation observational equivalence using evaluation function prove dynamic binding adds expressiveness 8 purely functional programming language establishing dynamic binding cannot macroexpressed callbyvalue lambdacalculus section 6 use dynamic binding semantic primitive formalise two different models exceptions nonresumable exceptions ml 26 resumable ones common lisp 43 34 fourth refine evaluation function strategy called deep binding facilitates creation restoration dynamic environments section 7 fifth extend framework parallel evaluation based future construct 14 17 30 section 8 define parallel evaluation function also relies deep binding technique deriving calculus motivate work describing three broad categories use dynamic binding conciseness control delimiters distributed computing let us insist purpose denigrate qualities lexical binding essence abstraction block structure organisation present syntactic theory allows equational reasoning dynamic binding claim dynamic binding expressive programming technique used sensible manner show dynamic binding elegantly used define semantics constructs let us note dynamic binding found lisp also e x 22 perl 45 unix tm shells practical uses dynamic binding 21 conciseness typical use dynamic binding printing routine printnumber requires basis numbers displayed one solution would pass explicit argument call printnumber however repeating programming pattern across whole program source programming mistakes addition solution scalable later require printnumber routine take additional parameter indicating font numbers displayed would modify whole program scheme io functions take optional inputoutput port procedures inputfromfile withoutputtofile 39 simulate dynamic binding parameters gnu emacs 23 example large program using dynamic variables contains dynamic variables current buffer current window current cursor position avoid pass parameters functions refer examples illustrate felleisens conciseness conjecture 8 according sensible use expressive programming constructs reduce programming patterns programs order strengthen observation prove dynamic binding actually adds expressiveness purely functional language section 5 22 control delimiters even though standard ml 26 lexicallyscoped language raised exceptions caught latest active handler usually programmers install exception handlers duration expression ie handler dynamically bound extent expression maclisp 28 common lisp 43 catch throw eulisp letcc 34 examples exceptionlike control operators dynamic extent generally control delimiters used create partial continuations whose different semantics tolerate various degrees dynamicness 5 20 31 38 42 23 parallelism distribution parallelism distribution usually considered possible mean increasing speed programs execution however another motivation distribution exacerbated ubiquitous www quest new resources computation migrate site 1 another site 2 2 holds resource accessible 1 explanatory purpose consider simple resource name computer several solutions model name running host language last one entirely satisfactory lexical variable hostname could bound name computer whenever process created unfortunately variable may closed closure always return value even though evaluated different site ii primitive hostname defined function arguments ffi 35 cannot return different values different contexts unless defined nondeterministic function would prevent equational reasoning iii special form hostname could satisfy goal contradiction minimalist philosophy scheme avoids adding unnecessary special forms furthermore would define special form every resource would natural abstract unique special form parameterised resource name introduces new name space exactly dynamic binding offers iv solution dynamically bind variable hostname name computer processcreation time every occurrence variable would refer latest active binding variable besides control tasks paralleldistributed setting usually relies notion dynamic extent sponsors 33 37 allow programmer control hierarchies tasks 3 calculus dynamic binding figure 1 displays syntax u language accessible end user let us observe purpose u capture essence dynamic variables propose new syntax themthe language u based two disjoint sets variables dynamic static lexical variables consequence programmer choose lexical abstractions x lexically bind parameter applied dynamic abstractions x dynamically bind parameter former represent regular abstractions calculus 3 latter model constructs like common lisp abstractions special variables 43 dynamicscope 6 fig 1 user language u paramount importance clearly state naming conventions adopt language following barendregt 3 consider terms equal renaming bound static variables equivalent contrary two terms differ dynamic variables considered equivalent e ddlet fig 2 dynamicenvironment passing transform figure 2 dynamicenvironment passing translation call program transformation maps programs u target language deps extended callbyvalue calculus based lexical variables figure 3 intuitively abstraction static dynamic u translated abstraction taking extra dynamic environment argument target language contains variable e denotes unknown environment result application protocol target language changed accordingly operator values applied pairs translation application dynamic environment e used translations operator operand also passed argument operator dynamic abstractions translated abstractions extend dynamic environment dynamic variable translated lookup corresponding constant current dynamic environment source language extends u dlet construct dlet x d1 stands dynamic let construct inaccessible programmer used internally system model bindings dynamic variables x di values syntax input language called appears figure 5 binding lists defined concatenation operator x satisfying following property vn vn evaluation target language based set axioms displayed second part figure 3 applications binary abstractions require double fi v reduction modelled rule fi theta environment lookup implemented lk 1 lk 2 following sabry felleisen purpose rest section derive set axioms perform terms reductions allowed terms language deps e j yp p term e unknown env variable axioms lookup xd extend e xd w lookup xd extend e xd1 w e xd1 6 xd lk 2 j theta fig 3 syntax axioms depsd calculus fig 4 inverse dynamicenvironment passing transform gamma1 deps precisely want define calculus equationally corresponds calculus deps following definition equational correspondence taken verbatim 40 definition 1 equational correspondence let r g two languages calculi xr xg also let f g translation r g h translation g r finally let g calculus xr equationally corresponds calculus xg following four conditions hold 1 2 xg figure 4 contains inverse dynamicenvironment passing transform mapping terms deps terms first case worth explaining term w 1 w 2 represents application operator value w 1 pair dynamic environment e operand value inverse translation application inverse translations w 1 w 2 scope dlet inverse translation e following cases inverse translation removes environment argument added abstractions translates occurrence dynamic environment dletexpression state space binding list primary axioms dlet dlet dlet dlet dlet derived axioms dlet compatibility dlet fig 5 syntax axioms calculus apply dynamicenvironment passing transform term immediately translate result back gamma1 find first six primary axioms figure 5 explanatory purpose prefer present derived axioms dlet intro 0 dlet propagate 0 axiom dlet intro 0 counterpart fi v dynamic abstraction applying dynamic abstraction value v creates dlet construct dynamically binds parameter argument v body abstraction rule dlet propagate 0 rewritten using syntactic sugar let tells us transform application appearing inside scope dlet dlet operator operand separately evaluated inside scope dynamic environment application operator value operand value also appears inside scope dynamic environment interpretation dlet merge dlet elim 1 dlet establish following properties concerning composition lemma 2 term 2 value v 2 v alue list bindings bind environment e 2 deps let term p 2 deps value w 2 depsv alue dynamic environments applying inverse translation gamma1 axiom deps obtain four last primary axioms figure 5 rules lookup 1 lookup 2 immediate correspondent lk 1 lk 2 deps fi 0omega j v axioms discovered sabry felleisen applying technique calculi continuations assignments 40 intuition set axioms explained follows absence dynamic abstractions behaves callbyvalue calculus whenever dynamic abstraction applied dlet construct created rule dlet propagate 0 propagates dlet leaves syntax tree replaces occurrence dynamic variable value dynamic environment lookup 1 lookup 2 rule dlet propagate 0 also guarantees dynamic binding remains accessible extent application dynamic abstraction ie deleted dlet us also observe parallel evaluation possible dynamic environment duplicated operator operand reduced independently property used section 8 define parallel evaluation function obtain following soundness completeness results lemma 4 soundness terms e 2 deps deps lemma 5 completeness terms p following theorem consequence lemmas 2 5 theorem 1 calculus equationally corresponds calculus deps 2 within calculus define partial evaluation relation value program v prove equals v calculus definition 6 eval c program 2 0 definition give us algorithm states specification must satisfied evaluation procedure purpose next section define procedure 4 sequential evaluation sequential evaluation function defined figure 6 relies notion evaluation context 11 evaluation context e term hole place next subterm evaluate use notation e denote term obtained placing inside hole context e four transition rules necessary dlet intro dlet elim derived calculus rule lookup replacement dlet propagate dlet merge dlet lookup 1 dlet lookup 2 calculus state space alued xs j xsm j xdm value e j e evaluation context transition rules evaluation function program 2 0 error 7 dynamically bound variables stuck terms fig 6 sequential evaluation function intuitively value dynamic variable given latest active binding variable framework latest active binding corresponds innermost dlet binds variable dynamic extent dlet construct period time apparition dlet intro elimination dlet elim evaluation algorithm introduces concept stuck term defined occurrence dynamic variable evaluation context contain binding evaluation function defined total function returning value evaluation terminates evaluation diverges error stuck term reached correctness evaluation function established following theorem relates eval c eval let us observe eval c may return value v 0 differs value v returned eval calculus perform reductions inside abstractions theorem 2 program 2 0 eval c implement lookup would start dynamic variable evaluated search innermost enclosing dlet contained binding variable would return associated value otherwise would proceed next enclosing dlet behaviour exactly corresponds search value associative list assoc scheme strategy usually referred deep binding section 7 refine sequential evaluation function making associative list explicit beforehand show dynamic binding adds expressiveness functional language 5 expressiveness section 21 stated dynamic binding expressive programming technique used sensible manner could reduce programming patterns programs section give formal justification statement proving dynamic binding adds expressiveness 8 purely functional language first define notion observational equivalence definition 7 observational equivalence given programming language l evaluation function eval l two terms observationally equivalent context c 2 l cm 1 cm 1 programs l eval l 1 defined equal v eval l 2 defined equal v 2 shall denote observational equivalences callbyvalue calculus calculus v respectively order prove dynamic binding adds expressiveness 8 purely functional language let us consider following lambda terms assuming existence primitive cons construct pairs cons v f dv terms observationnally equivalent v calculus ie 1 v 2 1 example shows dynamic binding enables us distinguish terms callbyvalue calculus cannot distinguish result v 6ae using felleisens definition expressiveness 8 thm 314 conclude proposition 1 v cannot macroexpress dynamic binding relative 6 semantics exceptions firstclass continuations state simulate exceptions 13 show exceptions defined terms firstclass continuations dynamic binding semantics ml 26 raised exception returns exceptional value distinct normal value effect prune evaluation context handler able deal exception merging mechanism aborts computation mechanism fetches handler exception handler longer executed dynamic environment exception raised result approach cannot used give semantics kinds exceptions like resumable ones 43 order model abortive effect extend sequential evaluation function figure 6 felleisen friedmans abort operator 11 sake simplicity assume exists one exception type discrimination kind exception performed handler also assume existence distinguished dynamic variable x ed figure 7 give semantics mlstyle exceptions exception raised latest active handler called escapes applies f dynamic environment handle dynamic environment exception raised 3 hand exist kinds exceptions like resumable exceptions eg common lisp resumable errors 43 eulisp resumable conditions 34 essentially offer opportunity resume computation point exception raised sequel present variant queinnecs monitors 36 3 usage firstclass continuation appears rule handle duplicates evaluation context e let us also observe continuation used downward way amounts popping frames stack exed va ef v fig 7 mlstyle exceptions p 255 give essence resumable exceptions primitives monitorsignal play role handlerraise mlstyle exceptions let us note signal binary function takes value also boolean r indicating whether exception raised resumable emonitor f 7d e xed let old xed r x esignal r v 7d exed r v fig 8 resumable exceptions like handle monitor installs exception handler duration computation exception signalled latest active handler called dynamic environment signalled exception exception signalled handler handled handler existed monitor called x ed shadowed duration execution handler f accessible normal computation resumes exception signalled resumable ie first argument signal true value returned handler returned signal computation continues exactly dynamic environment 4 approach define semantics exception two advantages least first model effect appropriate primitive abortion handler installation dynamic binding ability model different kinds semantics exceptions second defining semantics exceptions assignments weakens theory 12 assignments break equivalences would hold presence exceptions definition provides precise characterisation theory exceptions refinement refine evaluation function representing dynamic environment explicitly associative list separating evaluation context dynamic environment facilitate design parallel evaluation function section 8 figure 9 displays state space transition rules deep binding strategy dynamic environment represented new dlet construct appear outermost level configuration called state list bindings ffi regarded global stack initially empty evaluation starts binding pushed binding list every time dynamic abstraction applied popped end dynamic extent application section 4 dlet construct also modelling dynamic extent dynamicabstraction application dlet construct longer appears inside terms introduce pop term playing role created dynamic abstraction applied destroyed end dynamic extent popping top binding binding list theorem 3 establishes correctness deep binding strategy 4 semantics assumes exists initial handler evaluation proceed state space binding list e j e evaluation context transition rules dlet dlet dlet dlet ffixx v evaluation function db dlet error dlet 7 stuck state 2 stuck db fig 9 deep binding theorem 3 eval deep binding technique simple implement bindings pushed binding list ffi application time dynamic abstractions popped end extent however lookup operation inefficient requires searching dynamic list operation linear length exist techniques improve lookup operation shallow binding technique consists indexing dynamic environment variable names 1 optimisation called shallow binding value cell associate dynamic variable fixed location contains correct binding variable lookup operation simply requires read content location 8 parallel evaluation section 3 observed axiom dlet propagate 0 particularly suitable parallel evaluation allowed independent evaluation operator operand duplicating dynamic environment wellknown deep binding strategy adapted parallel evaluation associative list representing dynamic environment shared different tasks previous work 30 follow parallelism annotation approach programmer uses annotation future 17 indicate expressions may evaluated parallel semantics future described purely functional framework 14 presence firstclass continuations assignments 30 figure 10 present semantics future presence dynamic binding 14 30 set terms augmented future construct add set values placeholder variable represents result computation progress addition new construct flet p double goal first let binds p value second models potential evaluation parallel component mandatory term first would evaluated evaluation sequential speculative value known needed terminates state space transition rules dlet ae dlet dlet dlet dlet ae dlet dlet dlet ffixx v dlet error error dlet dlet dlet dlet dlet evaluation function program 2 0 dlet dlet error dlet 7 error fig 10 parallel evaluation differences figure important observe future valid evaluation context otherwise evaluation allowed proceed inside future body could possibly change dynamic environment would make fork unsound instead rule ltc stands lazy task creation 27 7 replaces future expression fmark interpreted mark indicating task may created runtime elects create new task fork creates flet expression whose mandatory component argument fmark ie future argument whose speculative component new state evaluating context fmark filled placeholder variable scope duplicated dynamic environment ffi 1 runtime elect spawn new task evaluation proceed fmark argument rules ltc future id specify sequential behaviour future value future value fmark value argument evaluation mandatory component terminates rule join substitutes value placeholder speculative state rule speculative indicates speculative transitions allowed flet body following 14 figure 10 defines relation 1 7 nm meaning n steps involved reduction 1 2 among mandatory correctness evaluation function follows modified diamond property observation number pop terms state always smaller equal length dynamic environment theorem 4 eval far implementation concerned rule ltc seems indicate dynamic environment duplicated refinement system indicates suffices duplicate pointer associative list long list remains accessible shared store rule ltc adds overhead every use future duplicating dynamic environment even dynamic variables used feeley 7 describes implementation avoids cost lazily recreating dynamic environment task stolen due orthogonality assignments dynamic binding previous results 30 assignments merged within framework adding assignments permits definition mutable dynamic variables construct like dynamicset 34 due purely dynamic nature semantics presence mutable dynamic variables offers less parallelism observed 30 interaction dynamic binding continuations however beyond scope paper 19 9 related work conference history programming languages mccarthy 25 relates observed behaviour dynamic binding program higherorder functions bug fixed introducing funarg device function con struct32 cartwright 4 presents equational theory dynamic binding language extended explicit substitutions assumes callbyname parameter passing technique motivation work fundamentally differs goal derive homomorphic model functional languages considering combinator axioms derived oecalculus axioms constructed proof equational correspondence calculus authors 6 discuss issue tailrecursion presence dynamic binding observe simple implementations fluidlet 18 tailrecursive restore previous dynamic environment evaluating fluidlet body therefore propose implementation strategy essence dynamicenvironment passing style solution programs dynamicenvironment passing style characterised fact require growth control state dynamic binding however require growth heap space analogy continuationpassing translation generates program function calls terminal position although mean cpsprograms iterative feeley 7 queinnec 36 observe programs dynamicenviron ment passing style reserve special register current dynamic environment since every nonterminal call saves restores register strategy penalises programs use dynamic binding especially bytecode interpreters marginal cost extra register high prefer solution penalise programs price growth control state every dynamic binding consequently believe implementors decide whether dynamic binding increase control state case result noniterative behaviour tradition syntactic theories continuations assignments present syntactic theory dynamic binding theory helps us deriving sequential evaluation function refined implementation like deep binding also integrate dynamicbinding constructs framework parallel evaluation futurebased programs besides prove dynamic binding adds expressiveness purely functional language show dynamic binding suitable tool define semantics exceptionslike notions furthermore believe single framework integrating continuations sideeffects dynamic binding would help us proving implementation strategies fluidlet presence continuations 19 acknowledgement many thanks daniel ribbens christian queinnec anonymous referees helpful comments r anatomy lisp shallow binding lisp 15 lambda calculus syntax semantics lambda ultimate combinator abstracting control dynamic identifiers neat efficient general implementation futures large scale sharedmemory multiprocessors expressive power programming languages reduction semantics imperative higherorder languages syntactic theory sequential state syntactic theory sequential control revised report syntactic theories sequential control state controlling effects semantics future use program optimization operational reasoning denotational semantics towards semantic theory dynamic binding mit scheme reference manual embedding continuations procedural objects continuations concurrency report programming language haskell gnu emacs lisp reference manual recursive functions symbolic expressions computation machine history lisp definition standard ml lazy task creation maclisp reference manual sound evaluation parallel functional programs firstclass contin uations semantics scheme future partial continuations difference continu ations function function lisp funarg problem called environment problem speculative computation multilisp eulisp definition lisp small pieces design concurrent distributed lan guage dynamic extent control operator partial continuations revised 4 report algorithmic language scheme formal relationship direct continuationpassing style optimizing compilers synthesis two paradigms reasoning programs continuationpassing style control delimiters hierarchies language rum intensional theory function control abstractions programming perl tr ctr christian queinnec influence browsers evaluators continuations program web servers acm sigplan notices v35 n9 p2333 sept 2000 matthias neubauer michael sperber emacs lisp dynamic scope analysis acm sigplan notices v36 n10 october 2001 gavin bierman michael hicks peter sewell gareth stoyle keith wansbrough dynamic rebinding marshalling update destructtime acm sigplan notices v38 n9 p99110 september zena ariola hugo herbelin amr sabry typetheoretic foundation continuations prompts acm sigplan notices v39 n9 september 2004 oleg kiselyov chungchieh amr sabry delimited dynamic binding acm sigplan notices v41 n9 september 2006 magorzata biernacka olivier danvy syntactic correspondence contextsensitive calculi abstract machines theoretical computer science v375 n13 p76108 may 2007
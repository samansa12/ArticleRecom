structural fault testing embedded cores using pipelining purpose paper develop global design test methodology testing corebased system entirety achieved introducing bypass mode core data transferred core input port output port without interfering core circuitry interconnections thoroughly tested used propagate test data patterns signatures system system modeled directed weighted graph accessibility core input output ports solved shortest path problem finally pipelined test schedule made overlap accessing input ports send test patterns output ports observe signatures experimental results show higher fault coverage shorter test time b introduction progress deep submicron vlsi technology enables integration large predefined macros cores together user defined logic udl single chip leads design paradigm shift single asic design systemonchip design full scale leverage thirdparty intellectual property ipbhgv96de97 several advantages core based design reduction overall system design time productivity increase accelerating timetomarket increasing competitive superiority design test corebased systems important challenging problem facing semiconductor industry next several years major difficulty concerns accessibility embedded cores io terminals system entails mapping standalone test requirements provided core vendor embedded cores basic technique suggested many rd groups access embedded core testing isolation others kowa97 vsi97 bhgv96 however number disadvantages isolation approach isolation testing test systemonchip whole example address testing interconnects interfaces cores consider interaction cores testing effect testing one core surrounding cores vice versa surrounding cores also may affect core test implementing protection safeguards costly increasing test overhead isolation method even topo97 11 background loosely speaking core highly complex logic block fully defined terms behavior also predictable reusable chpa96 cores distinguished several categories terms design flexibility ip protection test development programmability characteristics soft cores reusable blocks terms synthesizable rtl description firm cores reusable blocks supplied netlist library cells range technologies finally hard cores reusable blocks optimized terms power performance supplied layout form specific technology clearly soft cores flexible type hard cores provide ip protection test development viewpoint cores mergeable nonmergeable mergeable cores use expandable test scheme thus merged mergeable cores composite structure tested whole terms programmability cores characterized fully programmable eg microprocessor cores partially programmable eg applicationspecific integrated processors asip little nonprogrammable eg asic cores number test methods apply asic cores based design test dft techniques eg scan bist scanbist test points without dft using precomputed testing facilitate test integration number preliminary proposals industry eg using test sockets macro test corelevel boundary scan kowa97 remark issues decoupled fact related significant effect system testing also issues apply soft hard cores however hard cores limit flexibility designer significantly systemlevel test solutions basic testing strategy suggested industrial groups systemonchip test embedded core one one rather system whole strategy requires accessibility ie controllability observability core ios system ios number core isolation techniques proposed imra90 ensure accessibility may provide good match particular cores internal test method muxbased isolation core mapping precomputed tests ffl boundary scan type approach accessing cores within systemonchip apply cores embedded scan bist dft ffl test wrapper collar dft hardware inserted isolation isolation method global bist controller usually employed test schedule cores embedded bist structures shorten test time test bus also proposed affect accessibility techniques proposed number disadvantages may incur significant overhead isolationrelated test structures performance possibly power consumption penalty also incurred due structures moreover isolation techniques address testing system whole specifically faults interfaces interconnects user logic cores remain undetected shortcomings isolation techniques motivate coordinated approach testing systemonchip basic goal test system whole means testing cores well testing interface type cores system eg soft hard etc test data set available predefined deterministicallyempirically computable handled method main contribution work twofold first define bypass core data transferred core input port output port without interfering core circuitry since test data travel existing interconnections core interface thoroughly tested second model coreport accessibility problem finding shortest path directed weighted graph minimize testing time overlapping time consumed access paths conceptually method generalization scan approach system level allowing use system interconnects various bit widths test data distribution signature collection paper organized follows section 2 presents bypass mode test overhead cost section 3 models accessibility problem finding shortest path directed graph section 4 discusses algorithm overlap execution paths minimize test time details design example step step experimental results section 5 finally concluding remarks summarized section 6 using bypass mode 21 core environment distinguish faults respect core environment given core definition environment core inputoutput connections fromto primary inputsoutputs cores system using ticker lines shown environment core 1 system pictured figure 1 system primary inputs system primary outputs figure 1 environment core 1 also differentiate isolated core isolated core environment isolated core refers core shaded core figure 1 example without components system isolated system mechanism multiplexors tristate buffers hand figure 1 shows core 1 isolated core environment includes core connections tofrom isolated appropriate mechanism distinction plays important role discussion since example fault interconnect core captured isolated core testing may caught testing isolated core environment 22 inputoutput test overall objective use existing wires topology system establish path carry test data two test points system called source sink core testing two types test paths input test path access core input ports system primary inputs output test path access core output ports system primary outputs figure 2a shows core test core two paths corresponding source sink also shows general view establish route two test points using existing wires figure 2b blowup picture core inputoutput test path core k shown symbolically showed inputs bypassed output without interfering core circuitry used normal mode shortly elaborate matching bit widths packetization real implementation bypass circuitry basic idea bypass mode core independent route around core carry test data eg predefined test patterns core signatures port k bit wide port j n j k bit wide core core k goal establish shortest path fastest route carry packets test data source sink note formulation accessibility core inputs system primary inputs core outputs system primary outputs similar problems ie identifying shortest path source sink test source source sink sink input test path output test path bin bout bit length test data system primary output system primary input b bitmatch port j port ik jk figure 2 test paths inputoutput test paths b typical core test paths important benefit bypass take advantage existing connections among cores existing wires transfer multibit data source sink worst case equivalent conventional scan transfers patterns serially using separate routing system considering multibit interconnections among cores fact use separate scan chain expect average case quite superior terms time comparable terms hardware overhead bypass mode use different identity mode imode introduced abadir breuer abbr85 many ways abbr85 authors define imode ipath rtl components eg alus muxes registers transfer data unaltered one port another example adder one data value zero creates imode approach physical bypass routes data transferred one point another additionally imode many mode definitions including transfer mode tmode sensitized mode smode control components efficiently realize one form partial scan test modes ipaths used transmitting data scan registers input ports block test transmitting signatures scan registers shifted approach use scan registers offers totally different test methodology allowing use system interconnects various bit widths test data distribution signature collection would like also point many core providers philips mabd98mari98 already devised bypass mode part p1500 core test standardization standard well justified providing considerable flexibility designer reasonable cost additionally bypass mode easily incorporated within soft hard cores core providers mabd98 core come bypass mode mode required bitmatch circuitry explained section added externally designer benefit testing 23 packetizing technique data transfer figure 2a clearly shows bit width inputsoutputs cores change path two test points requires sort bit matching lets assume need transfer b bit pattern source sink general transfer b bit test data port k bit port j n j k bit core k need packetize data match available bit width send several iterations example core bit input port test data 4 iterations assume data packetization transfer synchronized system clock note also core k point view matter bbit data gets inputs come eg many packets eg b number iterations cycles core k consumes bypass data change however affect nm stages sp circuit n mbit mbit mbit figure 3 serialtoparallel sp bit match circuit scheduling bypass activities discuss present cost hardware time overhead due bypass bit matching circuit simplicity shown k j k subscripts bit width variables 231 case 1 input output n serialtoparallel figure 3 shows first type bitmatch circuit required assemble larger pattern different packets data circuit consists n e stages cascaded mbit registers eg flip flops controlled clock circuit like shift register bank bits serialtoparallel sp behavior whose worst case terms time corresponds equivalent traditional scanin discipline note n e packets bit data parallelized n bit n cycles bbit data need iterate b times overall n briefly based implementation bypass bbit data mbit input port nbit output port core following cost values time cost b area 1 dff denotes dtype flip flop one possible implementation 1bit register equations clearly shows depending b participating core may spend less time bypassing data output wires n may needed example suppose data transferred 1 cycle using two eight available output wires data transferred 8 cycles using eight wires 232 case 2 input output n paralleltoserial figure 4 shows second type bitmatch circuit required disassemble large pattern different packets data circuit consists n stages parallel multiplexors 1bit registers eg flip flops controlled clock circuit paralleltoserial ps behavior whose worst case terms time corresponds equivalent traditional scanout discipline multiplexors need dlog ee bit select lines since actual data transferred depends b assumed selfstarting counter controlled test controller controls number iterations actually needed note e packets n bit data produced clock cycles bbit data need iterate b briefly based implementation bypass bbit data mbit input port nbit output port core following cost values mn mn mn log mn stages ps circuit n 1bit 1bit 1bit counter selfstarting figure 4 paralleltoserial ps bit match circuit time cost b area 2 depending b participating core may spend less time bypassing data input wires mux inputs may needed example suppose 2 data transferred 1 cycle using two eight available input wires data transferred 8 cycles using eight wires equations 2 1 joined together follows time cost b minfmng e cycles area 233 complete bypass circuitry addition sp ps bit match circuit complete bypass circuitry includes tristate buffers additional logic gates control core activities shown figure 5 tristate buffers needed protect core bypasses data safeguard mechanism ensure bypass mode core receive new data change state note many input ports bypassed single output port one time logically speaking 1 although figure 5 showed bypass circuitry bypassing port port j delta delta delta shows may additional bypass routes decided shortest path algorithm explain section 3 summary new routes bypass input port port j adds one gate one buffer one entry gate introduction glue logic among cores order bypass test data may slightly degrade timing characteristics core due additional delay experiments using 08micron cmos library compass design automation tool comp93 additional delay less 35 nanosecond sp ps bit match port port 3state buffer enable core k port port bypass circuit bus port input stopk figure 5 core bypass circuit port port j bypass shown mode stopk bypassk function core k run bypass table 1 different modes modified core bypass core accepts inputs forwards output output port core performs functionality mode thus call normal mode core test even still perform normal functionality bypass hand disconnects input core bypasses data output port based selected route determined bypass ij k test controller make sure conflict bypassing different input ports one output port simultaneously signal allows global clock reach core stop masks clock core leave present state signal used interactive testing freeze system temporarily read core outputs issue pursued paper note purpose normal bypassing operations could considered bypass however intentionally separated core provide capability bypassing data even core test able bypass data core k test cores even core k test reduce overall test time specifically application test time core long clarify later section 4 table 1 summarizes operation modes 24 cost calculation sourcesink paths previous section presented two cost functions time area see equation 3 bypass circuitry pertaining single cores work decided focus test time optimization heuristics proposed based area cost look system testing another angle based equation 3 core k participates test path bypassing data test data source sink time overhead proportional source 1st test point 2nd test point ijk b bitwidth test data input pattern output signature cycles ik jk figure pipelinelike structure sourcesink path cycles cores char interface cost high cycles cores c char interface cost low cycles cores b c2 char function 22c1 interface cost medium source 1st test point 2nd test point figure 7 example bypass scheduling e cycles however distribution cycle activities another issue whole path shown figure 6 similar pipeline system n stages stage requires cycles difference however conventional pipelines scheduling method conventional pipelining ston90 define pipeline clock period equal slowest stage delay schedule activities accordingly problem dont want devise many registers interface cores pile data packets instead implement innovative mechanism bypassing performed soon packet appropriate size ready make point clear lets consider example figure 7 sink input port core test requires test data three cores sourcesink path time cost 4 4 2 respectively cost values correspond time overhead required packetize serial parallel parallel serial test data example 16bit test data would disassembled four packets 4bit 4 cycles transfer core 1 three bypass scheduling choices shown used spacetime table similar reservation table ston90 pipelining row corresponds core column corresponds time step entry c1 c2 c3 table shows corresponding core bypassing packet data cycle example three schedules shown figure core 1 bypasses packet 4bit data first four cycles figure 7a taking advantage pipelinelike structure activity one core starts previous one finished importantly need expensive hardware interface cores pile packets four packets 4bit data data sending next core path obviously bad choice figure 7b pictures case need cheaper interface two packets 4bit data consumes 7 cycles figure 7c pictures superior choice minimizes cost eg registers used anyway bit match circuits data transfer time 6 cycles shortly show finding optimized schedule possible constructing characteristic function path factorizing much possible starting outside without changing order core variables functions shown also figure 7 argument example clear given shortest path bounds total bypass scheduling time path consists n cores upper bound e cycles lower j assumed single specific input output ports core k respectively data bypassed 241 path characteristic function bounds presented equation 4 used data transfer time evaluation heuristics identify shortest path two test points although upper lower bound may suggest different solutions example suppose two paths source sink first path four cores equal 4 4 3 3 second path three cores equal 6 1 1 upper bound selects second path shortest cost 6 compared 4 lower bound heuristic chooses first path shortest cost 4 compared 6 briefly speaking overall time cost bypass scheduling depends time distribution activities among cores example shows need mechanism evaluate actual time needed bypass scheduling data packetized based available bit widths transferred one core another needed overall time evaluation also complete bypass schedule test controller test session tell cores behave defined path characteristic function pcf pcf written starting factorizing coefficients starting outmost possible factor continuing inside type factorizing would lead different suboptimal schedule example figure 7 start equation 4c1 corresponds schedule figure 7 interpret pcf sign sequential activity function means first core 1 bypass data 4 cycles core 2 bypasses data 4 cycles finally data 2 cycles factorize 2 become 22c12c2c3 pcf corresponds schedule figure 7 b note factor parenthesis reflects number repetitions sequencing starts p cycles another p largest coefficient inside parentheses 2 pcf finally continue factorizing terms 22c1 c2c3 pcf corresponds figure 7 c consumes less time 6 cycles requires cheaper interface according 22c1 suggests schedule core 2 bypasses data core 1 sequence repeated twice followed bypassing data core 3 finally whole thing repeated twice briefly general formula pcf function note function superscript r denotes level factorized function r r coefficient outside parenthesis factoring f factorized terms inside rth f r table 2 example pcf recursive formula level parenthesis form innermost terms f 0 similar 2c1 c3 terms appeared example figure 7 following recursive formula simple way computing overall scheduling time f r based pcf function example consider pcf corresponding example figure 7 c 22c1c2c3 table shows get f r overall scheduling time graph modeling shortest path problem objective model port accessibility cores within system directed weighted graph shortest path two points called source sink reflects fastest route transfer packets data two points testing perspective model find fastest route transfer test data predefined random pattern system primary inputs core input ports similarly find fastest route transfer test data signature core output ports system primary output equation 3 defines cost associated bypassing data p ort p ort j core graph modeling node corresponds port edge corresponds interconnects ports bypass possibilities edges reflecting bypass choices form bipartite subgraph core whose cost weight determined based equation 3 cost edge corresponding bypass delay shows time required transfer packetized data one point another time cost existing interconnections cores assumed zero since additional circuitdelay packetizing transfercontrol needed figure 8a shows system made four cores different ports bit widths test consistency showed test pattern generator tpgr signature analyzer misr also cores system four cores two primary inputs going core 1 core 4 three primary outputs core 2 core 3 core 4 figure 8b shows corresponding core bypass graph cbg recall equation 3 time cost depends bit width test data b desire transfer depending bit width test data b different cost values used finding shortest paths example figure 8b near edge shown two cost values cost values outside parenthesis ij e showing time overhead transfer 8bit test data similarly cost values inside parenthesis ij tpgr misr1616816816168164 sink global global source b tpgr misr time cost global global source figure 8 corebased system bit widths b cbg graph repeat f select unmarked vertex vq sq minimal mark vq foreachunmarked vertex vertices marked figure 9 dijkstra algorithm e reflecting time overhead transfer 16bit test data edges without cost value correspond existing interconnect cores assumed time cost zero ignore resistance capacitance wires packet data transferred almost immediately shortest path algorithm many wellknown solutions proposed literature graph theory operation research texts bellman dijkstra bellmanford liaowong algorithms demi94 bomu76 whose running time 2 3 n number nodes edges capability finding single shortest path finding shortest path pairs work used dijkstra algorithm greedy algorithm providing exact solution computational complexity ojejjv jlogjv jej total number nodes edges graph respectively one fastest among algorithms cycles also considered dijkstra algorithm pseudocode algorithm shown figure 9 algorithm keeps list tentative shortest paths iteratively refined initially vertices unmarked fs thus path weights vertex either weights edges source infinity algorithm iterates following steps vertices marked selects marks vertex head path source whose weight minimal among paths whose heads unmarked corresponding tentative path declared final updates tentative path weights computing minimum previous tentative path weights sum final path weight newly marked vertex plus weights edges vertex details found many graph theory synthesis books bomu76 demi94 shortest test path algorithm summarized figure 10 algorithm first constructs cbg graph finds time cost values corresponding edges cbg uses dijkstra algorithm construct core bypass graph cbg compute time cost values ie e apply dijkstra algorithm find input test shortest paths 1 nin k apply dijkstra algorithm find output test shortest paths 1 figure 10 shortest path algorithm applied cbg tpgr misr global global source time cost input test shortest paths output test shortest paths figure 11 four inputoutput shortest paths core 1 using dijkstra algorithm find inputoutput test shortest paths show process continue running example applying dijkstra algorithm cbg graph figure 8b core 1 note carefully core 1 two 8bit two 16bit ports consider appropriate cost edges accordingly cost values outside parenthesis test point core 8bit port cost values inside parenthesis test point core 16bit port result summarized figure 11 shows shortest paths global source core input ports thick solid broken lines figure 11 also shows shortest paths two output ports 1 global sink using two different dotted lines 4 structural testing find shortest paths core inputoutput ports apply bypass scheduling method explained section 2 core finally using path scheduling method combine path schedules overlap test activities minimize test time much possible different steps structural test process summarized pseudocode figure 12 briefly algorithm finds best schedule input test path schedules according factorized form characteristic function highest concurrency test time minimization scheduling test path starts first possible time step 1 input test paths transferring test patterns core test time step core output signature becomes ready test output paths work employed simple soon possible scheduling method consider scheduling cores order path scheduled pipeline fashion explained section 4 asap strategy used overlap path execution times structural test inputoutput test shortest construct factorize characteristic functions input test paths construct factorize characteristic function output test paths core schedule asap input test paths 1 nin k based available bypassconnections test pathsg ttest application core schedule asap output test paths 1 based available bypassconnections figure 12 structural test algorithm 41 possible extensions considered unidirectional interconnects buses work graph modeling nbit bidirectional bus modeled two pbit qbit p buses although extension graph model straight forward shortestpath formulation needs changed also decide best value p q order minimize transfer time bitmatch overhead moment take bidirectional buses account values p q fixed eg n2 dont address general case paper intend consider near future pursued paper sophisticated scheduling methods implemented higher perfor mance example relax two assumptions ie asap fixed ordering moreover selecting set k disjoint necessarily shortest paths selected bypass test data k different pairs points concurrently test time reduced even systems using busses eg vsi alliance bus wrapper design mainly three busses responsible connecting cores system test scheme shows lower efficiency still used find best order bus access optimize test time 42 completing running example figure 13 shows input output test shortest paths four cores example time cost shown within shaded circles attached core path figures 14 show complete schedules shortest paths core 1 core 4 respectively assumed core 1 2 3 4 require 9 9 11 25 cycles respectively test application time shaded area figures 14 note also clarify role signals introduced section 2 listed signals 0 table means signal active low logic level entries 1 2 3 4 show active signal high logic level applied corresponding time step used different symbols 1 4 refer core test example entries 4 show signals active core 4 test empty locations table correspond theta dont care situation used logic optimization implementation test controller note bypass ij k signals defined 0 guarantee data conflict port j figure 15 shows final schedule according scheduling method explained scheduling po1 po1 po1 po1 po2 po2 po2 misr tpgr tpgr tpgr tpgr tpgr tpgr misr misr misr misr misr misr b c infinity infinity infinity infinity infinity infinity infinity infinity infinity infinity infinity 44 infinity infinity tpgr infinity 4core 4 figure 13 inputoutput shortest paths basically obtained overlapping four schedules figure 14 time adjustment port bypassing route available schedule shows structural test session input data packets test patterns output data packets signatures somehow scrambled overlap activities test data transfer test session importance core capability bypass executes test pattern clear figure specifically core test bypass routes transfer test data cores kind overlapping reduces test time dramatically note also figure 15 bypass 12 1 bypass 22 2 bypass 12 3 omitted corresponding bypass routes never needed removals reduce hardware overhead bypass circuitry 5 experimental results section demonstrate approach using system made four cores circuits synthesized high level descriptions using syntest synthesis system hpcn92 logic level synthesis done using asic synthesizer compass design automation suite tools 08micron cmos library comp93 fault coverage curves found resulting logic level circuits using atts gentest fault simulator gent93 probability aliasing within misrs neglected faults within tpgrs test circuitry since standard core benchmarks introduced yet decided design four example circuits cores eight bit wide datapaths first core core 2 evaluates third degree polynomial examples implement three high level synthesis benchmarks differential equation solver core tpgr misr stop4 stop3 stop2 stop1 sendport1 readport1 readport2 readport3 sendport2 cores signal name 17 test time steps tpgr misr stop4 stop3 stop2 stop1 sendport1 readport1 readport2 readport3 sendport2 cores signal name 17 test22 time steps bypass schedule core 1 b bypass schedule core 2 tpgr misr stop4 stop3 stop2 stop1 sendport1 readport1 readport2 readport3 sendport2 cores signal name 17 test time steps tpgr misr stop4 stop3 stop2 stop1 sendport1 readport1 readport2 readport3 sendport2 cores signal name 17 time steps c bypass schedule core 3 bypass schedule core 4 figure 14 bypass schedules four cores tpgr misr stop4 stop3 stop2 stop1 sendport1 readport1 readport2 readport3 4 44 cores signal name time steps222 figure 15 complete bypass schedule pipelined fashion four cores core circuit normal transistor total faults fault test name schedule count faults detected coverage time poly 9 8684 899 804 8943 932 table 3 statistics four cores tested separately full scan test structural test parameter value parameter value test overhead output 4484 bit match 3548 test controller 1045 test controller 6062 test per pattern core 2 101 core 2 overlapped 15 one iteration 501 one iteration 34 fault coverage 8844 fault coverage 9143 test test statistics transistor transistor test time 57363 test time 9180 table 4 comparison scan proposed structural test facet example core 1 gdwl92 fifth order elliptical filter core 4 kuwk85 note core consists datapath controller made testable using bist applied syntest integrated fashion hpcn92nocp97 also fit cores port specification figure 8a shows grouped replicated actual inputsoutputs circuit table 3 summarizes transistor count fault coverage test time core tested nonembedded circuit separately note test time expressed terms clock cycle execute corresponding schedule core fault coverage curve saturated example diffeq core schedule consists 11 cycles fault simulation process requires 70 iterations set random patterns curve saturated put fours together obtained fault simulation whole system based scan structural test table 4 summarizes fault coverage statistics two methods scan testing order cores scanin scanout chain affects test time experiments assumed single scanin chain order 4 single scanout chain order assumed core 1 lower fault coverage scan expected method capture interconnect faults proposed structural test approach requires slightly test circuitry 54 full scan mainly due test controller overall structural test overhead 2318 system cost example note test methods individual cores datapath controller achieve fault coverage range 8797 9281 see table 3 thus regardless method employed system testing achieving high fault coverage system without redesigning cores would possible using structural multiplechain structural test test controller trans 4810 6062 test time cycle 15390 9180 tester pin table 5 comparison multiplechain scan method test approach fault coverage increased almost 3 mainly due detecting interconnect faults real advantage structural method test time since bypass scheduling overlap transferring test data test points using existing interconnections resulted almost 84 test time reduction compared scan note table 4 compared method singlechain scan using multiplechain scan obviously improve test time expense overhead control wiring specific result using maximum number scan chains four example one chain core summarized table 5 basic idea using multiple chains apply scan different partitions parallel independent multiple chains require dedicated control increases test control overhead factor almost 4 overall test overhead circuitry remain quite high importantly independent chains require separate scanin scanout coreselect testnormal increases tester pins 4 four chains compared one testnormal method test time reduction depends bottleneck core one largest test time depends inputsoutputs bit width core execution time number test patterns required fact example bottleneck core core 1 48 bits inputsoutputs requires 270 test patterns resulted test time 15390 cycles still 675 higher proposed structural core testing method 6 summary proposed test methodology testing corebased system entirety bypass mode circuitry added core used transfer test data source data generation point sink data consumption point existing interconnections system modeled directed weighted graph accessibility core input output ports solved shortest path problem test data distribution collection signatures scrambled pipelined fashion minimize test time experimental results promising terms test time quality testing interconnections among cores r knowledge based system designing testable vlsi chips finding defects fault models testability concepts digital ics unifying methodology intellectual property custom logic testing graph theory applications test methodology embedded cores protects intellectual property testability analysis insertion rtl circuits based pseudorandom bist testing systems chip user manuals compass vlsi v8r44 synthesis optimization digital circuits user manuals gentest 20 introduction chip system design syntest environment systemlevel design test direct access test scheme design block core cells embedded asics testsockets framework systemonchip design vlsi modern signal processing structured scalable mechanism test access embedded reusable cores structured scalable mechanism test access embedded reusable cores scheme integrated controllerdatapath fault testing test synthesis behavioral domain test responses compaction accumulators rotate carry adders application specific integrated circuits high performance computer architecture testing embedded cores using partial isolation rings 08micron cmos vsc450 portable library version 10 tr ctr tomokazu yoneda hideo fujiwara design consecutive testability systemonachip builtin self testable cores journal electronic testing theory applications v18 n45 p487501 augustoctober 2002 tomokazu yoneda masahiro imanishi hideo fujiwara interactive presentation soc test scheduling algorithm using reconfigurable union wrappers proceedings conference design automation test europe april 1620 2007 nice france tomokazu yoneda kimihiko masuda hideo fujiwara powerconstrained test scheduling multiclock domain socs proceedings conference design automation test europe proceedings march 0610 2006 munich germany mohammad hosseinabady abbas banaiyan mahdi nazm bojnordi zainalabedin navabi concurrent testing method noc switches proceedings conference design automation test europe proceedings march 0610 2006 munich germany rainer dorsch hansjoachim wunderlich reusing scan chains test pattern decompression journal electronic testing theory applications v18 n2 p231240 april 2002 rika cota luigi carro marcelo lubaszewski reusing onchip network test corebased systems acm transactions design automation electronic systems todaes v9 n4 p471499 october 2004 rika cota luigi carro marcelo lubaszewski alex orailolu searching global test costs optimization corebased systems journal electronic testing theory applications v20 n4 p357373 august 2004 qiang xu nicola nicolici modular rapid testing socs unwrapped logic blocks ieee transactions large scale integration vlsi systems v13 n11 p12751285 november 2005
efficient boolean manipulation obdds extended fbdds obdds stateoftheart data structure boolean function manipulation basic tasks boolean manipulation equivalence test satisfiability test tautology test single boolean synthesis steps performed efficiently terms fixed ordered obdds bottleneck obddapplications size represented boolean functions since total computation merely remains tractable long obddrepresentations remain reasonable size since well known obdds restricted fbdds free bdds ie bdds test path input variable fbddrepresentations often much sometimes even exponentially concise obddrepresentations propose work general fbddbased data structure show fbdds fixed type provide similar obdds fixed variable ordering canonical representations boolean functions basic tasks boolean manipulation performed terms fixed typed fbdds similarly efficient terms fixed ordered obdds order demonstrate power fbddconcept show verification circuit design hidden weighted bit function proposed bryant carried efficiently terms fbdds principal reasons impossible terms obdds b introduction need data structures boolean functions becomes obvious one applications mind circuit design optimization verification testing etc let us consider eg basic problems logic verification means hardware description languages circuits described high level abstraction allows designer specify behavior circuit realizing order validate specifications order verify designed circuit respect specification formal methods developed lead problem descriptions terms boolean functions verification problem solved analyzing manipulating functions let us consider example problem determining whether combinational circuit c correctly implements given specification test whether functions realized c respectively one possibility eg eve91 ffk88 mwbs88 first construct representations fc f usually terms primary inputs second perform equivalence test functions terms representations hence efficient algorithms solving verification task consideration require ffl efficient algorithms deriving representations involved boolean functions eg circuit description well ffl efficient algorithms solve equivalence test similar tests satisfiability tautology terms representations past great variety representations boolean functions truth tables disjunctive dnf conjunctive normal forms cnf reedmullerexpansions various types formulas boolean circuits branching programs inves tigated however demand supporting mentioned basic tasks boolean manipulation became obvious computer applications really started work complex boolean functions order come full understanding fundamental tradeoff succinctness representation efficiency solving basic tasks observe complexity measured length representations input functions hence working eg truthtables one much time computations however representation requires case space ressources exponential number primary inputs side working eg formulas one often obtains succinct consequently space efficient representations solving eg equivalence test becomes conphard unfortunately systematic inspection different succinct representation schemes eg gm92a shown allmost support efficient solutions boolean manipulation basic tasks worse performing basic tasks often requires solution nphard problems exceptions seem bddbased boolean function representations eg ake78 bry86 mei91 gm92a provide socalled obdds stateoftheart data structure boolean functions allow 1 canonical representations hence efficient solutions equivalence test similar tests satisfiability tautology test allow 2 efficient performance binary boolean synthesis steps hence efficient procedures deriving obddrepresentation boolean function given circuit description due nice properties obdds successfully used many applications example sequential circuit verification eg mb90 bcm90 fil91 testing eg bec92 kbs93 logic optimization kar89 survey see bry92 unfortunately obddrepresentations succinct hence spaceefficient arises question whether sophisticated bdd representations first succinct spaceefficient obdds second allow efficient solutions basic tasks boolean manipulation similarly obdds number obddextensions proposed aim overcome mentioned disadvantages obdds eg adg91 jphs91 bjaaf92 however obtained increase spaceefficiency representation paid mentioned approaches conpcompleteness equivalence test gm92a natural candidate obddextension allows efficient equivalence test least probabilistical bcw80 bdds read input variables course computation socalled fbdds since obdds special structured bdds readonceonly property fbdds indeed generalize obddconcept bddbased data structures boolean functions bddbased data structures boolean functions use following representations schemes binary decision diagram bdd set x boolean variables directed acyclic graph one source two sinks labeled 0 1 nonsink node v labeled boolean variable lv 2 x n two outgoing edges one labeled 0 1 computation path input starts source inner node label x outgoing edge label chosen bdd p represents boolean function computation path input leads sink label fa f sometimes denoted f p bdd called path variable tested ordered binary decision diagram obdd fbdd property path variables tested fixed order examples fbdd obdd given figure 1 generally draw bdds way edges labeled assume left edge labeled 0 right edge 1 gammapsi r gammapsi r au deltaff au deltaff gammapsi r gammapsi au deltaff au phi x 40a b figure 1 example fbdd obdd b function fx 1 remarkable property logarithm bddsize corresponds turing machine space name branching programs bdd representations extensively studied complexity theory eg weg87 mei89 theoretical interest fbddrepresentations known complexity theory readonceonly branching programs arises similar correspondence eraser turing machine space well known boolean function f 2 ib n x n represented terms bdds terms fbdds variable ordering terms obdds optimal bddrepresentations comparison twolevelrepresen tations dnfs cnfs multilevelrepresentations boolean formulas succinct spaceefficient eg mei89 however succinctness makes often difficult sometimes even infeasible perform basic tasks boolean manipulation example conpcomplete problem test whether two bdds represent boolean function chs74 situation changes dramatically one works restricted types bdds sometimes possible perform efficiently basic tasks boolean manipulation although restriction properties maintained course computation bryant bry86 first observed obdds property detail obdds possess following outstanding properties fact 1 bry86 1 respect fixed variable ordering representation boolean function means reduced obdd canonical ie uniquely determined 2 let p 0 p 00 two obdds variable ordering binary boolean synthesis step performed time osizep due properties obdds defined fixed variable ordering well suited used data structure boolean functions bry86 indeed nowadays obdds stateoftheart data structure boolean functions utilized various packages applications cad eg brb91 however disadvantage obdd data structures often low space efficiency obdd representations although wide classes practically important boolean functions possess least respect wellsuited variable orderings spaceefficient ie polynomial size obddrepresentations many important functions without succinct representations example exist boolean functions integer multiplication hidden weighted bit function hwb indirect storage access function isa represented obdds polynomial size fhs78 bry91 bhr91 variable ordering computational advantages fbdds although many boolean functions eg symmetric functions optimal fbddrepresentations obdds many important functions restriction fbdds obdds causes exponential increase size going discuss boolean functions property variable ordering obddsize exponential fbddsize first idea construct examples boolean functions small ie polynomial fbddsize large ie exponential size obddsize consider boolean functions form f 0 f 1 polynomial size obdds variable orderings 0 1 exponential size obdds 1 0 respectively replace single multiplexer variable x 0 larger figure 2 take functions f polynomial size obdds good variable ordering common get large class boolean functions small fbddsize large obddsize figure 2 due similar idea fortune hopcroft schmidt constructed fhs78 fbdd p size smaller 3n 2 obdd least 2 n2gammalog 3 n12 verification methods circuit realizations fhs presented jbaf92 second interesting example indirect storage access function isa isa defined variables follows let let variables isa partitioned 1 groups p output isa x j 0 otherwise breitbart hunt iii rosenkrantz proven obdd computing isa size least 2 nlogngamma1 bhr90 hand shown isa computed fbdd even decision tree size 2n 2 logn gammapsi x lgamma1k x lgamma1k1 x memory register figure 3 indirect storage access function isa finally going discuss detail hidden weighted bit function hwb discussed bryant bry91 let wtx number ones input assignment although obddrepresentation hwb exponential size bry91 computed polynomial even quadratic size fbdd explain use construction due bryant bry92b based computation appropriately chosen restrictions hwb x ij represents one easily verify main idea explained figure 4 simultaneously compute h 1n g 1n restrictions level merged together since level k fixed 2n nodes level furthermore source tosinkpath variable tested hence fbdd size hwb r gammapsi r gammapsi r gammapsi r gammapsi r phi g 1n g 2n figure 4 construction fbdd phwb computes hidden weighted bit function hwb seen important functions small size fbdds whose obddsizes respect variable ordering exponential let us mention computational advantage fbdds boolean function repre sentations due bcw80 assign fbdd signature allows test functional equivalence fbdds probabilistically polynomial time property applied obdds basis efficient hash techniques used extensively efficiently working obddpackages package brace bryant rudell brb90 signatures boolean functions found many applications ybaf92 kri93 kbs93 since signatures computed fbdds similarly obdds hash techniques used work fbdds remark similar property known compact boolean function representations 4 fbdd types order extend efficient manipulation obdds fbdds show possible perform single boolean synthesis steps terms fbdds similar efficiently ie polynomial time case obdds precise let boolean operator 2 ib 2 denote problem constructing fbdd p function f 00 given fbddrepresentations p 0 p 00 f 0 f 00 sometimes suppress operator write easily sy n fbdd sy nobdd denotes similar problem obdds unfortunately investigations complexity sy n fbdd shown performing boolean synthesis steps terms fbdds nphard gm92a reason intractability sy n fbdd caused different ways input fbdds test variables indeed considering obdds instead fbdds effect observed performing boolean synthesis step sy nobdd obdds different variable orders nphard gm92a however restrict problem obdds variable order sy n obdd problem becomes efficiently solvable time goal section introduce formally notion type fbdd generalizes linear variable ordering obdds allows canoncially represent boolean functions terms fbdds respect given complete type ffl efficiently perform single boolean synthesis step fbdds fbddtype defined similarly fbdd exception possesses merely one sink labeled symbol p fbdd tpp derived easily p identifying sinks p r gammapsi j omega omega omega omega ae omega omega omega omega ae au omega omega omega omega omega ae au r r gammapsi gammapsi omega omega omega omega omega ae au omega omega omega omega ae au figure 5 fbdd p type tpp two syntactical reduction rules usually applied bdds fbdds obdds types order reduce sizes without functional change important observation reductions change substantially way bdd fbdd obdd tests input variables reason use reductions generalize notion variable order fbdds merging rule two nonterminal nodes u v label v0 eliminate one two nodes redirect incoming edges node figure 6 illustrates application merging rule type tpp figure 5 observe input assignment sequence variable tests remains invariant wrt applications merging rule moreover one considers bdds algebraical structure application merging rule defines congruence relation set nodes bdd reason sometimes speak merging rule algebraical reduction deletion rule nonterminal node v eliminate v redirect incoming edges v0 figure 7 illustrates application deleting rule node deletion rule applied called simple reducible opposite merging rule deletion rule decreases information contained type r r gammapsi omega omega omega omega omega ae au omega omega omega omega omega ae au z z z z z z z z z z z z ae ae ae ae ae ae ae ae ae ae ae ae ae ae r gammapsi x 400111 figure 6 application merging rule tpp figure 5 z z z z z z z z z z z z z z ae ae ae ae ae ae ae ae ae ae ae ae ae ae r gammapsi x 400111 z z z z z z z z z z z z ae ae ae ae ae ae ae ae ae ae ae ae ae ae theta theta theta theta theta theta theta theta theta thetafl figure 7 application deleting rule type figure 6 reduced fbdds types fbdd p called reduced neither merging rule deletion rule applied p fbdd p said algebraically reduced merging rule applied p z z z z z z z z z z z z z z ae ae ae ae ae ae ae ae ae ae ae ae ae ae r gammapsi red tpp figure 8 algebraical reduced type type tpp figure 5 proposition 1 unique reduction reduced fbdd obtained fbdd p applying merging deletion rule uniquely determined computed linear time similarly algebraically reduced fbdd algebraically reduced type obtained applying merging rule uniquely determined computed linear time proof fbdd p denote reduced fbdd redp algebraical reduced fbdd red p similar type denote red algebraical reduced type red first prove red p red uniquely determined two nodes u said algebraical congruent u v 1 2 u0 v0 u1 v1 u v inner nodes obviously defines equivalence relation interpreting leftsonrelation v0 rightsonrelation v1 unary operations set nodes labels lv unary predicates set fx 1 means simple axioms p considered algebra checked easily fact congruence relation factorization relation produces red p red respectively true since fbdds types rooted algebraical congruent nodes isomorphic hence two merging sequences maximal length merge concruent nodes single node lead result red p red algebraical idea behind proof uniqueness red p red applied directly redp since fundamental difference merging deletion rule terms universal algebra difference explained fact relation defined merging rule congruence relation relation defined following means merging deletion rule merely equivalence relation two nodes u v fbdd p said equivalent u v 1 u v algebraical congruent u v 2 one successor node p 3 exist nodes observe neither deletion rule merging rule affect equivalence two nodes p however clear application merging deletion rule merges together two different equivalent nodes easy see order prove uniqueness redp suffices prove p transformed fbdd whose equivalent nodes merged together proof done easily induction difference sizep number equivalence classes p difference zero ie exist two different equivalent nodes p nothing merge together p reduced difference positive always find two equivalent nodes merged together means deletion rule merging rule next step use induction hypothesis complexity constructing redp red p red reductions bdds already discussed akers ake78 efficient algorithm construction redp developed bryant bry86 way obddpackages eg brb90 use separate reduction procedures however reduction performed average means linear many arithmetical operations finally algorithm bryant improved sw92 run deterministic linear time replacing sorting procedure linear time bucket sort technique order identify fbdds testing variables similar way suffices compare types define notion subtype analogy notion linear suborder let type type 0 called subtype constructed applying merging deletion rule r r gammapsi gammapsi omega omega omega omega omega ae au omega omega omega omega ae au z z z z z z z z z z z z ae ae ae ae ae ae ae ae ae ae ae ae theta theta theta theta theta theta theta theta figure 9 type subtype 0 easy see respect set types constitutes partially ordered set complete type fbdd type complete sourcetosink path variable x n tested let complete type fbdd p type exists type 0 red 0 red due definition type fbdd always assume algebraically reduced sometimes write fbdd indicate fbdds complete type obviously single fbdd belong several types variable orderings provide simply structured complete types socalled obddtypes example see figure 10 however section 3 shown important functions obddtypes optimal give interesting example type fbdd deduce type fbdd phwb hidden weighted bit function hwb described section 3 since variable tested source sink path hwb complete type figure 11 shows hwb giving types h 1n hwb g 1n figure 10 example obddtype proposition 2 efficient typecheck fbdds let p fbdd p let complete type checked efficiently whether p type proof since apply algorithm presented section 5 produces always fbdds consistent given type practical applications need check whether fbdd belongs predefined type hence suffice scetch test whether exists type 0 two fbdds type 0 gm92b particular answer question whether p type node v fbdd type characterized set v variables tested vtosink path v computed straightforward traverse algorithm time linear output say two nodes u v consistent lu 6 lv case lu 2 v well run algorithm synthesis apply procedure described section 52 taking p 0 p 00 inputs check whether sources every recursive call synthesis consistent let us remark case procedure synthesis needs input type work binary boolean operation since resulting fbdd interest induction easily proved checked pairs nodes consistent exists common r gammapsi r gammapsi r r r r gammapsi gammapsi gammapsi gammapsi r gammapsi r r gammapsi au deltaff deltaff au au deltaff gammapsi au theta theta deltaff au bn deltaff theta theta r au bn deltaff theta theta gammapsi au bn deltaff theta theta r r au bn deltaff theta theta gammapsi gammapsi z z z z z z z z z z z z z z z ae ae ae ae ae ae ae ae ae ae ae ae ae ae ae r au deltaff figure 11 type fbdd hidden weighted bit function given section 3 given means types h 1n hwb g 1n hwb roots source labeled x 7 efficient solutions basic tasks boolean manipulation terms fbdds 51 canonical fbdd representations ready prove respect given complete type reduced fbdds similarly reduced obdds provide canoncial representation boolean functions order start following easy observation input variable x exists bdd consists exactly one nonterminal node labelled x 0sink 1sink let us call bdd actually obdd standard representation x proposition 3 let complete type x n let x 2 x n standard representation x type proof since complete type nodes labelled x form cut means deletion rule eliminate predecessors nodes labeled x iterated applications merging rule get type 0 single node labelled x predecessor sink finally using deletion rule successively construct 0 standard representation x theorem 4 canonical fbdd representation let complete type x n let f 2 ib n isomorphism exactly one reduced fbdd type represents f proof exactly one complete binary decision tree f red red let p fbdd f type easy see tpp tpt since p represent boolean function p constructed applying merging deletion rules consequence proposition 1 get redp easy consequence theorem 4 proposition 1 obtain efficient algorithm solves equivalence problem equ fbdd corollary 5 equ fbdd equivalence two fbdds p 0 p 00 type decided linear time osizep let us mention best result solving equ fbdd probabilistic polynomial time algorithm bcw80 52 efficient performance boolean synthesis steps following show efficient apply procedure obdds variable ordering bry86 extended fbdds type meantime similar results could obtained sw92 theorem 6 efficient boolean synthesis fbdds let binary boolean operation let p 0 p 00 two fbdds complete type fbdd p type representing boolean function constructed time osize proving theorem remark many cases binary boolean synthesis steps fbdds performed quadratic instead cubic time true instance consider fbdds bounded width types least one input fbdds large enough ie variable appears source tosink path eliminate factor size obtain time bound osizep 0 sizep 00 quadratic upper bound osizep 0 sizep 00 obtained also require result fbdd type gm92b however since also small size fbdds standard representations ie fbdds size 1 certain types result synthesis size osize hope eliminate factor size general upper bound proof start brief sketch synthesis algorithm algorithm sy n fbdd input binary boolean operation 2 ib complete type two fbdds p 0 p 00 type output fbdd p type represents begin compute p redq returnp end give short recursive description procedure synthesis p generalization apply procedure proposed bry86 let top denote top variable label source j topff type rooting ffsuccessor ff 2 f0 1g source similar notations used case fbdds terminal case reached one two input fbdds p 0 p 00 represents constant recursion stops output fbdd derived modifying sinks fbdd instance p 0 1sink fisink p 00 replaced 1g begin p 0 p 00 sink terminal case return result construction p straightforward else construct p topp returnp 2 ib 2 means classical shannon expansion applied form recursion step synthesis easily verified let us remark p 0 p 00 type type j xff since modifications sinks fbdd change type get result fbdd p type improve running time use global table size size theta sizep 0 theta us consider call synthesis 0 p 0 p 00 q since restrictions qj xff property either x topq x appear q sources 2 correspond nodes p 0 p 00 respectively synthesis supported table v contains pointer result corresponding synthesis call nil synthesis called nodes save much computation bound running time size let us remark important property straightforward synthesis algorithm procedure synthesis generates result fbdd p reduced moreover variable appears sourcetosink path p next call synthesis applied p p new input p new fbdd type need anymore type information always encoded repeated applications synthesis get quadratic upper bound new running time example let us mention fbdd phwb hidden weighted bit function described sections 3 encodes informations type hwb section 4 hence working phwb need type hwb application refer section 6 finally remark algorithm presented proof theorem 6 optimal programming techniques used eg obddpackage developed brace rudell bryant brb90 applied also case fbdds instance help appropriate hash table force synthesis produce reduced fbdds hence reduction algorithm needed 6 fbdds versus obdds let us start comparision fbdd data structure obdd data structure general remark since data structures provide canonical repre sentations since binary boolean synthesis steps performed cases quadratic time least large inputs interesting case practice since fbdds provide sometimes even exponentially concise representations obdds application based properties makes sense use fbdds instead obdds however since obdds especially easily structured fbdds since great variety reasonable heuristics eg fs90 brkm91 designing efficient obdds seems meaningful strategy work obdds long fit computer obdds became large one work efficient sophisticated structure fbdds start demonstrate power fbddconcept showing verification circuit design hidden weighted bit function hwb given bry91 efficiently carried terms fbdds let us present ideas perform efficiently variable quantification terms fbdds 61 fbdds variable quantifications first insights beside performing twovalued logical synthesis applications obdds based possibility efficient performance variable quantification eg cmb90 bry92 x 2 x n f 2 ib n variable quantifications defined identities starting obdd f operations performed deriving obdds restrictions f j x0 f j x1 carrying according boolean synthesis step however terms fbdds situation difficult starting fbdd p f similarly case obdds one easily construct fbdds p 0 p 1 restrictions f j x0 f j x1 f deleting p node v labelled x obtain p 0 replacing 0successor node v0 obtain p 1 1successor node v1 get trouble since general p 0 p 1 fbddtype efficient algorithm performing necessary boolean synthesis step p 0 p 1 known gm92b nevertheless many important situations also terms fbdds efficient quantification possible following describe two paradigmatic situations first let us consider fbdd p type let nodes labeled variable x simple reducible ie reduced means deletion rule guaranteed fbdds restrictions constructed p type hence quantification performed efficiently similar case obdds order illustrate importance observation let us discuss interesting application verification switchlevel circuits fmk90 modeling method transistor switch follows switch transistor source drain value hence circuit shown figure 12 modeled switch using propositional logic internal signal c e figure 12 transitorlevel circuit since observable outside circuit considered existential quantified variable get relationship external signals b c e internal signal must eliminated logical description circuit eg 1 expressed terms fbdds operation efficiently implemented quantification internal signals efficiently performed since beginning external signals known following heuristic designing wellsuited fbddtypes guarantees quantification internal signals done efficiently separately create ffl appropriate fbddtype e complete respect variables corresponding external signals ffl appropriate order variables corresponding internal signals obviously defines obddtype complete respect internal variables starting e complete fbddtype designed including occasion demands piecewise e result get type quantify restrict compose internal variables without problems without going details mention merely technique generally successfully applied approaches based verifying modularized circuits second general situation variable quanitification perform efficiently terms fbdds following assume set x n variables partitioned blocks x consider types segmented ie consists segments r k segment r starts exactly one node tests variables x r see figure 13 example p fbdd segmented type easy see restricting simultaneously variables block provides fbdds type hence due theorem 6 variables block simultaneously quantified efficiently although course restricting single variables block emerge fbdds general type let us mention many application quantify single variables blocks variables example consider fbdd p type cited figure 13 restrict x k1 0 1 respectively obtain two inconsistent fbdds whose types incomparable true since input assigment x variable x k2 ist tested x k3 p j x k1 1 variable x k3 ist tested x k2 figure 14 shows type j x k1 0 p j x k1 0 type j x k1 1 deltaff gammapsi au r ae ae ae ae ae ae ae ae omega omega omega omega omega omega omega ae ae ae ae ae z z z z x x k2 x k3 x k3 x k2 x k4 figure 13 segment segmented type deltaff gammapsi au r ae ae ae ae bbn theta theta theta theta theta z z z z z z z z x k4 x k2 x k3 x k3 x k2 deltaff gammapsi au r ae ae ae ae bn theta theta theta theta theta theta thetafl j z z z z z z z z x k4 x k2 x k3 x k3 x k2 figure 14 segments restrictions j x k1 0 j x k1 1 type cited figure 13 62 power fbdds circuit verification hidden weighted bit function following review result described detail gm93b shows verification circuit design proposed bryant bry91 hidden weighted bit function hwb carried efficiently polynomial space using fbdds demonstrates power fbddconcept since bry91 shown working obdds exponential space needed recall section 3 hidden weighted bit function hwb mathematically specified means recursive equations description fbdd phwb hwb derived easily see section 3 type hwb drawn section 4 circuit design c hwb given bry91 leads nearly optimal vlsi implementation area theta time 2 complexity 1ffl ffl 0 main idea design illustrated figure 15 a666hwbx 1 figure 15 circuit design c hidden weighted bit function hwb w weight figure becomes obvious c looks like n 2 simplicity assume 1 case log order verify c terms fbdds type hwb construct reduced fbdd pc type hwb function fc computed c test equivalence fact equality since fbddrepresentations fixed type canonical phwb constructing pc introduce motivated logical structure c satisfy equation fbdd p cited figure 16 exactly mirrors main design idea c obviously omega omega omega ae j bbbn omega omega omega ae theta theta j jj omega omega omega ae j omega omega omega ae omega omega omega ae j omega omega omega ae j omega omega omega ae j omega omega omega ae j figure 16 output function circuit hwb terms fbdd primary inputs new internal variables let us consider type cited figure 17 easy see p fbdd type start eliminate internal variables order going prove fbdds arising elimination process small size let us mention example section 61 quantify restrict compose internal variables let f denotes boolean function computed p elimination order describe f fbdd consider shannon decomposition f illustrated tree cited figure 18 figure 17 definition type omega omega omega ae j bbbnomega omega omega ae theta theta j jj omega omega omega ae jomega omega omega ae omega omega omega ae j omega omega omega ae j figure 18 visualization cofactors shannon expansion f wt function f k described easily following way partition set input variables x 0 denotes constant groups 2 mgammai variables wt x choose appropriate group k offset need determine output variable k depends w extract c fbdd pc output following start construct fbdd type wmgamma1 eliminate wmgamma1 p means compose operation second step means compose operation eliminate manner wmgamma2 last step eliminate get fbdd pc type hwb circuit c detail begin p construct successively fbdds functions assumption use single synthesis step programming techniques hash table hashbased cash etc presented brb90 usual practical implementations expected space complexity extracting pc equals size maximal reduced fbdd derived one mentioned functions since c computes hwb since pc reduced fbdd type hwb equal phwb hence quadratic size space complexity verification least quadratic fbddsizes functions f w order estimate fbddsize functions f process sufficient design small fbdds type f k using tree figure 18 size resulting factor n larger size hwbfbdd f k let us mention useful properties hwb exclude last two levels sink predecessors node hwb labeled function g ij h ij source labelled h 1n claim number ones tested path h 1n h ij g ij equals respectively hence consider hwb counting schema proof claim follows easily induction 0successor 1successor h ij1 g igamma1j respectively induction hypothesis holds h ij1 g igamma1j true h ij g ij easy consequence mentioned counting property hwb symmetric boolean function including functions w realized means fbdds type hwb quadratic size going design hwbfbdd f k without loss generality let us take respect uniquely determined complete decision tree f 0 type hwb consider restrictions f 0 computed level l number ones tested path source node level l labeled x two values w number ones u v u v correspond restriction x w div 2 mgammaigamma1 value sourcetou sourcetov paths altogether nodes level l labeled x compute four different restrictions hence number restriction level l 4n hence size hwbfbdd f 0 4n 2 analogously obtain upper bound f k k fbdd f size 4n 3 remark size reduced similarities hwbfbdds f k merged together altogether shown c verified terms fbdds type hwb low degree polynomial space time since principal reasons impossible terms obdds example makes power fbddconcept evident conclusions paper extend feasible manipulation terms obdds fbdds detail shown ffl fbdds provides much sometimes even exponentially efficient representations boolean functions obdds section 3 reduced fbdds fixed type provide canonical representations theo rem 4 ffl basic tasks boolean manipulation performing boolean synthesis step testing equivalence satisfiability tautology performed similar efficiently terms fbdds terms obdds theorem 6 corollary 5 instead giving experimental evidence prove formally problem size n benchmark circuit hidden weighted bit function proposed bry91 verified terms cubic size fbdds section 52 shown bryant verification terms obdds case needs exponential space complexity spellt difficult terms fbdds terms obdds operations based restrictions eg variable quantification composition however characterized section 5 situations frequently occure practical applications operations performed efficently terms fbdds open interesting problem develop heuristics creation good types course extension problem determining good variable orders obdd applications since much greater freedom define types define orders problem seems trickery however know obdds used working fbdds example useful strategy work fbdds work obdds extremely easy structed fbdds long obdds consideration fit computer obdds became large one try work efficient sophisticated fbdds r binary decision diagrams boolean satisfiability equivalence checking using general binary decision diagrams synthesis testability binary decision diagrams equivalence free boolean graphs decided probabilistically polynomial time efficient implementation bdd package complexity vlsi implementations graph representations boolean functions applications integer multipli cation symbolic boolean manipulation ordered binary decision diagrams symbolic model checking states beyond sequential circuit verification using symbolic model checking efficient verification multiplier different functions using ibdds heuristics compute variable orderings efficient manipulation ordered binary decision diagrams verifying temporal properties sequential machines without building state diagrams verifikation digitaler systeme complexity equivalence containment free single program schemes evaluation improvements boolean comparison method based binary decision diagrams method symbolic verification sunchronous circuits automatic semiautomatic verification switchlevel circuits temporal logic binary decision diagrams finding optimal variable ordering binary decision diagrams computers intractability analysis manipulation boolean functions terms decision graphs efficient analysis manipulation obdds extended readonceonly branching programs frontiers feasible probabilistic feasible boolean manipulation branching programs combinational logic verification fbdds functional partitioning verification related problems extended bdds using ifthenelse dags multilevel logic minimization plato tool computation exact signal probabilities modified branching programs computational power branching programs efficient data structure computeraided circuit design logic verification using binary decision diagrams logic synthesis environ ment graph driven bdds new data structure boolean functions complexity boolean functions tr graphbased algorithms boolean function manipulation modified branching programs computational power finding optimal variable ordering binary decision diagrams using ifthenelse dags multilevel logic minimization complexity vlsi implementations graph representations boolean functions application integer multiplication efficient implementation bdd package sequential circuit verification using symbolic model checking shared binary decision diagram attributed edges efficient boolean function manipulation heuristics compute variable orderings efficient manipulation ordered binary decision diagrams symbolic boolean manipulation ordered binarydecision diagrams boolean satisfiability equivalence checking using general binary decision diagrams complexity equivalence containment free single variable program schemes synthesis testability frontiers feasible probabilistic feasible boolean manipulation branching programs analysis manipulation boolean functions terms decision graphs verifying temporal properties sequential machines without building state diagrams gatedelayfault testability properties multiplexorbased networks ctr j jain k mohanram moundanos wegener lu analysis composition complexity obtain smaller canonical graphs proceedings 37th conference design automation p681686 june 0509 2000 los angeles california united states chunghee kim luciano lavagno alberto sangiovannivincentelli free mddbased software optimization techniques embedded systems proceedings conference design automation test europe p1419 march 2730 2000 paris france sieling ingo wegener comparison free bdds transformed bdds formal methods system design v19 n3 p223236 november 2001 olaf schrer ingo wegener theory zerosuppressed bdds number knights tours formal methods system design v13 n3 p235253 nov 1998 wolfgang gnther rolf drechsler efficient manipulation algorithms linearly transformed bdds proceedings 1999 ieeeacm international conference computeraided design p5054 november 0711 1999 san jose california united states r drechsler sarabi theobald b becker perkowski efficient representation manipulation switching functions based ordered kronecker functional decision diagrams proceedings 31st annual conference design automation p415419 june 0610 1994 san diego california united states sieling complexity minimizing learning obdds fbdds discrete applied mathematics v122 n13 p263282 15 october 2002 wolfgang gnther rolf drechsler minimization free bdds integration vlsi journal v32 n13 p4159 november 2002 wolfgang gnther rolf drechsler efficient minimization manipulation linearly transformed binary decision diagrams ieee transactions computers v52 n9 p11961209 september jayram thathachar separating readktimes branching program hierarchy proceedings thirtieth annual acm symposium theory computing p653662 may 2426 1998 dallas texas united states christoph meinel anna slobodov unifying theoretical background bddbased data structures formal methods system design v11 n3 p223237 oct 1997 beate bollig simple function requires exponential size nondeterministic graphdriven readonce branching programs information processing letters v86 n3 p143148 16 may bogdan j falkowski chiphong chang forward inverse transformations haar spectra ordered binary decision diagrams boolean functions ieee transactions computers v46 n11 p12721279 november 1997 jawahar jain william adams masahiro fujita sampling schemes computing obdd variable orderings proceedings 1998 ieeeacm international conference computeraided design p631638 november 0812 1998 san jose california united states henrik reif andersen henrik hulgaard boolean expression diagrams information computation v179 n2 p194212 december 15 2002 amit narayan jawahar jain fujita sangiovannivincentelli partitioned robddsa compact canonical efficiently manipulable representation boolean functions proceedings 1996 ieeeacm international conference computeraided design p547554 november 1014 1996 san jose california united states randal e bryant binary decision diagrams beyond enabling technologies formal verification proceedings 1995 ieeeacm international conference computeraided design p236243 november 0509 1995 san jose california united states amit narayan adrian j isles jawahar jain robert k brayton alberto l sangiovannivincentelli reachability analysis using partitionedrobdds proceedings 1997 ieeeacm international conference computeraided design p388393 november 0913 1997 san jose california united states adnan darwiche compiler deterministic decomposable negation normal form eighteenth national conference artificial intelligence p627634 july 28august 01 2002 edmonton alberta canada stephen ponzio lower bound integer multiplication readonce branching programs proceedings twentyseventh annual acm symposium theory computing p130139 may 29june 01 1995 las vegas nevada united states beate bollig stephan waack philipp woelfel parity graphdriven readonce branching programs exponential lower bound integer multiplication theoretical computer science v362 n1 p8699 11 october 2006 ingo wegener bdds design analysis complexity applications discrete applied mathematics v138 n12 p229251 29 march 2004 adnan darwiche decomposable negation normal form journal acm jacm v48 n4 p608647 july 2001 rina dechter robert mateescu andor search spaces graphical models artificial intelligence v171 n23 p73106 february 2007
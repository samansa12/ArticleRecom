typed compilation recursive datatypes standard ml employs opaque generative semantics datatypes every datatype declaration produces new type different type including identically defined datatypes natural way accounting consider datatypes abstract interpretation applied typepreserving compilation however unfortunate consequence datatype constructors cannot inlined substantially increasing runtime cost constructor invocation compared traditional compiler paper examine two approaches eliminating function call overhead datatype constructors first consider transparent interpretation datatypes away generativity altering semantics sml second propose interpretation datatype constructors coercions runtime effect cost faithfully implement sml semantics b introduction programming language standard ml sml 9 provides distinctive mechanism defining recursive types known datatype declaration example following declaration defines type lists integers datatype intlist nil cons int intlist datatype declaration introduces type intlist two constructors nil represents empty list cons combines integer list produce new list instance expression cons 1 cons 2 cons 3nil type intlist corresponds list 1 23 values datatype deconstructed case analysis examines list determines whether constructed nil cons latter case extracting original integer list important aspect sml datatypes generative every datatype declaration defines type distinct type including produced possibly identical datatype declarations formal definition sml 9 makes precise stating datatype declaration produces new type name associate name defini tion sense datatypes similar abstract types harper stone 7 hereafter hs give typetheoretic interpretation sml exhibiting translation sml simpler typed internal language translation faithful definition sml sense wellknown exceptions translates sml program welltyped il program sml program wellformed according definition consequently consider hs suitable foundation typedirected compilation sml furthermore seems likely suitable typetheoretic interpretation ie one faithful definition encounter issues explore analysis harper stone capture datatype generativity translating datatype declaration module containing abstract type functions construct deconstruct values type thus setting hs interpretation datatypes abstract types generativity datatypes poses challenges typedirected compilation sml particular although hs interpretation easy understand faithful definition sml inefficient implemented navely problem construction deconstruction datatype values require calls functions exported module defining datatype unacceptable given ubiquity datatypes sml code conventional compilers disregard type information initial typechecking phase may dispense cost inlining functions may replace function calls actual code corresponding functions eliminate call overhead typedirected compiler however option since optimizations including inlining must type preserving moving implementation datatype constructor across module boundary violates type abstraction thus results illtyped intermediate code made precise section 2 paper discuss two potential ways handling performance problem present alternatives context tiltml compiler developed cmu 11 14 relevant however tilt understanding definition language typepreserving compilation general first approach away datatype generativity alto gether replacing abstract types hs interpretation concrete ones call approach transparent interpretation datatypes clearly compiler implementation standard ml show although modified language admit inlining datatype constructors unexpected properties particular case every wellformed sml program allowed transparent interpretation contrast second approach adopted recent version tilt compiler offers efficient way implementing datatypes typed setting consistent particular since value recursive type typically represented run time way unrolling observe mediating functions produced hs interpretation behave like identity function run time replace functions special values distinguished ordinary functions introduction coercion types call coercion interpretation datatypes argue allows compilation strategy generates code runtime efficiency comparable would attained datatype constructors inlined paper structured follows section 2 gives details hs interpretation datatypes also refer opaque interpretation datatypes illustrates problems inlin ing section 3 discusses transparent interpretation section 4 gives coercion interpretation discusses properties section 5 gives performance comparison three interpretations section 6 discusses related work section 7 concludes 2 opaque interpretation datatypes section review parts harper stones interpretation sml relevant discussion datatypes par ticular defining notation use internal language give example hs elaboration datatypes refer example throughout paper also review way harper stone define matching structures signatures discuss implications datatypes important section 3 show differences signature matching sml signature matching transparent interpretation datatypes types st recursive types terms e x roll e unroll e typing contexts g e figure 1 syntax isorecursive types x metavariable figure 2 shorthand definitions 21 notation harper stone give interpretation sml translation called elaboration sml typed internal language il give complete formal description internal language use paper instead use mllike syntax examples employ standard notation function sum product types complete discussion elaboration including thorough treatment internal language refer reader harper stone 7 since focusing attention datatypes recursive types particular importance therefore give precise description semantics form recursive types use syntax recursive types given figure 1 recursive types separated syntactic subcategory ranged mostly matter notational convenience many times wish make clear particular type recursive one recursive type form j type variable may appear free 1 n intuitively type ith system n mutually recursive types isomorphic j replaced jth component recursive bun dle formally isomorphic following somewhat unwieldy type usual denote ts 1 n 1 n simultaneous captureavoiding substitution 1 n 1 n since writing types often use notational conventions make things clearer shown figure 2 using shorthands type may written judgment forms static semantics internal language given figure 3 rules relevant recursive types given figure 4 note rule used judge two recursive types equal requires two types question ith projection bundles length whose respective components equal particular un wellformed context wellformed type equivalence types wellformed term figure 3 relevant typing judgments figure 4 typing rules isorecursive types rolling rule stating expandd type theories equality holds said equirecursive types significantly complex 5 recursive types theory iso recursive types isomorphic equal expan sions isomorphism embodied roll unroll operations term level former turns value type expandd one type latter inverse 22 elaborating datatype declarations hs interpretation sml includes full account datatypes including generativity main idea encode datatypes recursive sum types hide implementation behind opaque signature datatype declaration therefore elaborates structure exports number abstract types functions construct deconstruct values types example consider following pair mutually recursive datatypes representing expressions declarations abstract syntax toy language datatype letexp dec exp dec valdec var exp seqdec dec dec hs elaboration declaration given figure 5 using mllike syntax readability construct value one datatypes program must use corresponding function functions take element sum type un rolling datatype produce value datatype concretely implement constructors exp dec follows notice types exp dec held abstract opaque signature ascription captures generativity datatypes since abstraction prevents expdecexp expdecdec judged equal types however mentioned section 1 abstraction also prevents inlining structure expdec sig type exp type dec val exp var val exp exp var val dec var exp dec dec dec val dec dec var exp dec dec struct fun exp fun exp fun dec fun dec figure 5 harperstone elaboration expdec example functions example attempt inline exp definition varexp get illtyped outside expdec module fact exp recursive type visible thus performing inlining welltyped code lead illtyped code say inlining across abstraction boundaries typepreserving therefore acceptable strategy typed compiler problem since cannot inline functions compiler must pay runtime cost function call every time value datatype constructed caseanalyzed since operations occur frequently sml code performance penalty significant one strategy alleviate somewhat hold implementation datatype abstract elaboration expose underlying implementation elaboration code defined compilation unit calls constructors locallydefined datatype safely inlined setting wholeprogram compilation approach potentially eliminate constructor call overhead datatypes except appearing arguments functors however context separate compilation clients datatype generally access implementation rather specifications constructors shall see section 3 specifications datatypes constructors provide sufficient information correctly predict datatype actually implemented compilation strategy limited success true separate compilation setting 23 datatypes signature matching standard ml makes important distinction datatype dec larations appear top level structures datatype specifications appear signatures seen hs interpretation elaborates datatype declarations opaquely sealed structures datatype specifications translated specifications structures example signature datatype intlist nil cons int intlist contains datatype specification elaborates follows struct intlist sig type intlist val intlist intlist intlist val intlist intlist intlist structure match contains structure intlist appropriate signature 1 particular clear structure definition produced hs interpretation datatype intlist defined section 1 signature datatype declaration matches specification necessary general datatype declaration match specification interpretation since datatype declarations translated opaquely sealed structures datatype specifications translated structure specifications matching datatype declaration spec boils matching one signature one opaquely sealing declaration structureagainst another signature suppose wish know whether signature matches signature whether structure signature may also given signature intuitively must make sure every specification specification compatible instance contains value specification form must also contain specification val abstract type specification form type occurring must check specification also appears furthermore specification transparent one say imp checking remainder specifications may assume signatures imp transparent type specifications similar added requirement specification type spec specification type imp must equivalent returning specific question datatype matching specification form datatype may sum types elaborates specification structure following signature sig val val n n n val datatypes match datatype spec ifications actual hs elaboration must use name datatype cannot guessed programmer structure expdec sig specifications functions structure figure 6 transparent elaboration exp dec order match signature structure corresponding datatype declaration must define types named 1 n must contain functions appropriate type note structure produced elaborating datatype declaration interpretation abstract types thus example n datatype declaration datatype matches specification since necessary sufficient types functions match types mentioned specification 3 transparent interpretation datatypes natural approach enabling inlining datatypes typepreserving compiler away generative semantics datatypes context hs interpretation corresponds replacing abstract type specification signature datatype module transparent type definition call modified interpretation transparent interpretation datatypes tid 31 making datatypes transparent idea transparent interpretation expose implementation datatypes recursive sum types elaboration rather hiding expdec example corresponds changing declaration shown figure 5 shown figure 6 continue use mllike syntax readability importantly change must extend datatype specifications well datatype declarations thus structure exports datatype must export implementation transparently using signature similar one figureotherwise datatype inside structure would appear generative outside structure would little point new interpretation mentioned altering interpretation datatypes expose implementation recursive types really creates new language neither subset superset standard ml example obvious difference seen figure 7 figure two datatypes defined seemingly identical declarations sml datatypes generative two types list1t list2t distinct since variable l type list1t passed list2cons expects list2t function switch illtyped transparent interpretation however implementations datatypes exported transparently aunit int thus interpretation list1t list2t equal switch welltyped function clear many programs like one fail typecheck sml succeed transparent interpretation less structure struct datatype cons int structure struct datatype cons int fun switch switch list1cons obvious programs opposite true discuss two main reasons 32 problematic datatype matchings recall according hs interpretation datatype matches datatype specification types datatypes functions match types functions speci fication note types functions match types functions match hereafter refer functions transparent interpretation ever also necessary recursive type implementing datatype match one given specification trivial requirement give two examples matchings succeed sml fail transparent interpretation 321 simple example simple example problematic matching following opaque interpretation matching structure struct datatype u u b int signature sig datatype v b int amounts checking type function u defined structure matches expected signature u u substituted v signature definition substituted u since abstract structure sub stitution type required signature function exactly type function given structure matching succeeds transparent interpretation however structure defines u u imp int signature specifies u int order matching succeed two types must equivalent substituted u imp u imp v spec ification required observe type right none aexpandu imp notice also bound variable appear free body type hereafter write types wildcard place type variable indicate used body equivalence hold isorecursive types matching fails 322 complex example another example datatype matching legal sml fails transparent interpretation found reconsidering running example exp dec opaque interpretation structure containing pair datatypes matches following signature hides fact exp datatype sig type exp datatype seqdec dec dec datatype specification elaborated transparent interpretation however resulting il signature looks like sig type exp dec spec elaboration declarations exp dec hand produces structure figure 6 signature sig define exp imp dec imp matching structure containing datatypes signature succeed dec spec dec imp assumption exp exp imp equivalence hold two types different numbers components 33 problematic signature constraints module system sml provides two ways express sharing type information structures first type modifies signature patching definition type signature originally held abstract second sharing type asserts two type names possibly different structures refer type forms constraints restricted multiple inconsistent definitions given single type name case sharing type example required names flexible must either abstract defined equal another type abstract opaque interpretation datatypes abstract therefore flexible meaning shared transparent inter pretation datatypes concretely defined hence never shared example following signature legal sml type datatype type datatype sharing type write equivalent signature replacing sharing type line type also valid sml neither signatures elaborates successfully transparent interpretation datatypes since interpretation datatypes transparent therefore ineligible either sharing type another example following signature signature type val datatype sharing type construct analogous example type since name bt flexible opaque interpretation transparent code legal sml must rejected transparent interpretation 34 relaxing recursive type equivalence describe way weakening type equivalence ie making equate types problematic datatype matchings described section 32 succeed transparent interpretation help problematic sharing constraints section 33 ideas section based upon equivalence algorithm adopted shao 8 flintml compiler begin consider simple uv example section 321 recall example matching datatype declaration spec required proving equivalence type righthand side expandu imp simple variations example easy show general transparent interpretation permissive opaque following recursive type equivalence must hold refer boxedunroll rule says recursive type equal unrolling boxed alternative formulation equivalent first one transitivity makes two recursive types equal unrollings equal ie intuitively rule needed datatype matching succeeds opaque interpretation whenever unrolled form datatype implementation equals unrolled form datatype spec supposed describe domain function although boxedunroll equivalence necessary transparent interpretation datatypes admit matchings admitted opaque one sufficient see consider problematic expdec matching section 322 problematic constraint example dec spec dec imp dec substituting exp imp exp dec imp effect since variable appear free expanding definitions types get constraint avar exp imp boxedunroll rule insufficient prove equivalence order apply boxedunroll prove two types equivalent must able prove unrollings equivalent words var exp imp var exp imp dec imp dec imp cannot prove without first proving dec spec dec imp exactly set prove first place boxedunroll rule therefore unhelpful case trouble proving premise boxedunroll rule equivalence expandd 1 expandd 2 may require proving conclusion equivalence 1 2 similar problems addressed context general equirecursive types setting deciding type equivalence involves assuming conclusions equivalence rules proving premises 1 2 applying idea provides natural solution problem discussed previous section maintain trail type equivalence assumptions deciding equivalence two recursive types add equivalence trail comparing unrollings formally equivalence judgement becomes ga set assumptions form 1 2 equivalence rules static semantics must modified account trail rules except recursive types trail simply passed unchanged conclusions premises two new rules handle recursive types first rule allows assumption trail used second rule enhanced form boxedunroll rule adds conclusion assumptions premise clear trail necessary order resolve expdec anomaly described comparing unrollings dec spec dec imp add assumption dec spec dec imp trail use assumption avoid cyclic dependency encountered fact trailing version boxedunroll rule sufficient ensure transparent interpretation accepts datatype matchings accepted sml see consider datatype spec ification datatype may sum types may occur suppose implementation matches spec opaque interpretation implementation type must recursive type furthermore type function given spec type implementation matching succeeds opaque interpretation know types equal substituted thus know expandd specification elaborated transparent interpre tation however resulting signature declares implementation appropriate projection recursive bundle determined spec transparently specified order implementation match transparent specification thus sufficient prove following theorem theorem 1 1n g 1n g proof see appendix given formal argument trailing version boxedunroll rule flexible enough allow datatype matchings sml typecheck transparent interpreta tion precise maintaining trail relates rest type equivalence fact work regarding trails aware seminal work amadio cardelli 1 subtyping equirecursive types later coinductive axiomatization brandt henglein 2 conducted context simplytyped lcalculus trailing boxedunroll rule viewed restriction corresponding rule amadio cardellis trailing algorithm applicable types compared recursive types clear though trails affect complex type systems contain type constructors higher kind gi rards f w 6 addition higher kinds mil middle intermediate language tilt employs singleton kinds model sharing 13 proof mil typechecking decidable rather delicate involved implemented trailing algorithm tilt experimental purposes see section 5 interaction trails singletons wellunderstood remaining conflict transparent interpretation type sharing one might argue solution broaden smls semantics sharing constraints permit sharing rigid components problem kind sharing would necessary make examples section 33 typecheck transparent interpretation would require form type unification difficult determine draw line smls sharing semantics full higherorder unification undecidable moreover unification would constitute significant change smls semantics disproportionate original problem efficiently implementing datatypes 4 coercion interpretation datatypes section discuss treatment datatypes based coercions solution closely resemble harperstone interpretation thus require boxedunroll rule trail algorithm incur runtime cost function call constructor application sites either 41 representation datatype values calculus discussed paper given usual structured operational semantics expression form roll v value v value assume metavariable v ranges values fact shown without difficulty closed value datatype must form roll v v closed value type expandd thus roll operator plays similar role inj 1 operator sum types far highlevel language semantics concerned although specify behavior programs language formal operational semantics intent programs compiled machine code execution forces us take slightly different view data rather working directly highlevel language values compiled programs manipulate representations values compiler free choose representation scheme uses provided basic operations language faithfully performed representations exam ple compilers construct value inj 1 v attaching tag value v storing new object somewhere tagging necessary order implement case construct particular representation value type must carry enough information determine whether created inj 1 inj 2 recover representation injected value requirements representations values recursive turns somewhat weaker sums elimination form recursive types unroll unlike case need extract information argument original rolled value fact requirement representation v extracted representation roll v thus one reasonable representation strategy represent roll v exactly v companion technical report 15 give precise argument rea sonable making use two key insights first invariant tilt compiler representation value fits single machine register anything larger 32 bits always stored heap means possible complications sizes recursive values avoided second define representations values types define set machine words represent value v structural induction v rather defining set words represent values type induction might expected tilt compiler adopts strategy identifying representations roll v v pleasant consequence roll unroll operations noops instance untyped machine code generated compiler expression roll e need differ code e alone since latter evaluates v former evaluates roll v types terms e l afold l aunfold v te figure 8 syntax coercions representations two values reverse happens unroll turn important consequence datatypes since functions produced hs elaboration datatypes nothing roll unroll arguments code generated function identity function hence runtime cost incurred using function construct datatype value overhead function call remainder section explain eliminate cost allowing types functions reflect fact implementations trivial 42 coercion interpretation mark functions runtime noops use coer cions similar functions except known noops therefore code needs generated coercion applications incorporate coercions term level language introduce special coercion types belong figure 8 gives changes syntax calculus note far confined discussion monomorphic datatypes general case polymorphic datatypes require polymorphic coercions syntax give essentially used tilt compiler address nonuniform datatypes extend type level language type possibly polymorphic coercions value type coercion takes length type arguments change value type 1 one type 2 course variables appear either types empty similarly extend term level possibly polymorphic coercion values l afold l aunfold take place roll unroll expressions coercions applied type value arguments expression form v te v coercion type arguments e value coerced note coercion syntactically restricted value makes calculus amenable simple code generation strategy discuss section 43 typing rules coercions essentially ordinary polymorphic functions shown figure 9 modifications language place elaborate datatypes exp dec using coercions instead functions implement operations result elaborating pair datatypes shown figure 10 note interface exactly hs interface shown section 2 except function arrows replaced coercion arrows interface implemented defining exp dec way hs interpretation implementing coercions appropriate fold unfold values elaboration constructor application superficially similar opaque interpretation coercion application generated instead function call instance letexpde elaborates exp ininj 2 de 43 coercion erasure ready formally justify claim coercions may implemented erasure sound compiler consider coercions retyping operators ignore generating code first describe operational semantics coercion constructs added internal language next give translation calculus untyped one coercion applications disappear finally state theorem guaranteeing translation safe operational semantics coercion constructs shown figure 11 extend class values fold unfold coercions well application fold coercion value canonical forms coercion types recursive types respectively two inference rules shown figure 11 define manner coercion applications evaluated evaluation coercion application similar evaluation normal function application applicand already value rule left specifies argument reduced value applicand fold application value applicand unfold argument must recursive type therefore canonical forms consist fold applied value v rule right defines unfold left inverse fold hence evaluates v already discussed data representation strategy tilt code needs generated compute foldv v compute result cancelling fold unfold thus seems intuitive generate code coercion application v te compiler simply generate code e result datatype constructors destructors coercion interpretation runtime costs harper stones functions would inlined make precise define erasure mapping translate terms typed internal language untyped language coercion application untyped nature target language machine language important treating v foldv would destroy subject reduction property typed language figure 12 gives syntax untyped target language coercionerasing translation target language intended essentially typed internal language except types coercion applications removed contains untyped coercion values fold unfold coercion application form erasure translation turns expressions type annotations expressions without labstraction coercion values shown figure removes coercion applications erasure v te erasure e particular value v v foldv identified translation consistent intuition compiler operational semantics target language analogous source language coercions important typesafety property term welltyped evaluation get stuck important theorem coercionerasing translation preserves safety welltyped programs theorem 2 erasure preserves safety g e e safe e f f stuck proof see companion technical report 15 g type g type figure 9 typing rules coercions structure expdec sig type exp type dec val exp var val exp exp var val dec var exp val dec dec var exp struct val exp foldexp val exp unfoldexp val dec fold dec val dec unfold dec figure 10 elaboration exp dec coercion interpretation values v l afold l aunfold l afold sv figure 11 operational semantics coercions fold unfold l afold l aunfold unfold figure 12 target language syntax type coercion erasure test life 8233 2161 2380 leroy 5497 4069 3986 boyer 2031 1559 1364 simple 1506 1003 0908 tyan 16239 8477 9512 msort 1685 0860 1012 pia 1758 1494 1417 lexgen 11052 5599 5239 figure 13 performance comparison note value restriction coercions crucial soundness coercion erasure interpretation since divergent expression given arbitrary type including coercion type semantics coercion expression evaluated applied fails typesafe thus arbitrary expressions coercion type could appear application positions compiler would generate code since values cannot diverge effects free ignore coercion applications generate code performance evaluate relative performance different interpretations datatypes discussed performed experiments using three different versions tilt compiler one implements nave harperstone interpretation construction nonlocallydefined datatype requires function call 2 one implements coercion interpretation datatypes one implements transparent interpretation compiled ten different benchmarks using version compiler running times resulting executables averaged three trials shown figure 13 tests run ultrasparc enterprise server times reported cpu time seconds measurements clearly indicate overhead due datatype constructor function calls nave hs interpretation significant optimizations afforded coercion transparent interpretations provide comparable speedups opaque interpretation order 37 comparing total running times given two optimized approaches coercion interpretation entirely faithful semantics sml since theory coercion types simpler orthogonal extension hs type theory trailing algorithm section 34 believe coercion interpretation robust choice 6 related work trail algorithm weakened recursive type equivalence based one implemented shao flint intermediate language standard ml new jersey compiler 12 typing rules section 34 based formal semantics flint given league shao 8 although first give formal argument trailing algorithm actually works important note smlnj implements transpar particular implement strategy described end section 22 ent interpretation internally opaque interpretation employed elaboration datatype specifications made transparent afterward examples section 33 illustrate programs typecheck according sml transparent interpretation even trailing equivalence unclear smlnj elaboration cases happens final example section 33 valid sml rejected smlnj compiler curien ghelli 4 crary 3 defined languages use coercions replace subsumption rules languages subtyp ing crarys calculus coercions includes roll unroll recursive types since focus paper subtyping explore potential uses coercions detail nev ertheless notion coercion erasure proof safety preservation theorem based crarys implementation typed assembly language x86 architecture talx86 10 allows operands annotated coercions change types representations coercions include roll unroll well introduction sums elimination universal quantifiers intermediate language differs include coercions term level language rather treating specially syntax simplifies presentation coercion interpretation datatypes simplified implementation required smaller incremental change earlier versions tilt compiler however including coercions term level bit unnatural planned extension tilt typepreserving backend likely involve full coercion calculus 7 conclusion generative nature sml datatypes poses significant challenge efficient typepreserving compilation generativity correctly understood interpreting datatypes structures hold type components abstract exporting functions construct deconstruct datatype values interpretation inlining datatype construction deconstruction operations typepreserving hence cannot performed typed compiler tilt paper discussed two approaches eliminating function call overhead typepreserving way first away generativity making type components datatype structures transparent results new language different neither less permissive standard ml lost expressiveness regained relaxing rules type equivalence intermediate language expense complicating type theory fact transparent interpretation forbids datatypes appear sharing type type signature constraints unfortunate possible revision semantics constructs could remove restriction second approach replacing construction deconstruction functions datatypes coercions may erased code generation eliminates function call overhead without changing static semantics external language however erasure coercions makes sense setting recursivetype value unrolling represented run time coercion interpretation datatypes implemented tilt compiler although presented analysis sml datatypes context harperstone tilt compiler idea co ercion types one think generally useful terms serve retyping operations pervasive typed intermediate languages usually described coercions eliminated running code however applications informal coercions cannot general erased way distinguish coercions ordinary functions types problem especially presence true separate compilation contribution provide simple mechanism permits coercive terms recognized applications safely eliminated without requiring significant syntactic metatheoretic overhead r subtyping recursive types coinductive axiomatization recursive type equality subtyping typed compilation inclusive subtyping coherence sub sumption recursive subtyping revealed formal semantics flint intermediate language david mac queen realistic typed assembly language implementing tilt internal language overview flintml compiler deciding type equivalence language singleton kinds typed compilation recursive datatypes tr subtyping recursive types coinductive axiomatization recursive type equality subtyping deciding type equivalence language singleton kinds typed compilation inclusive subtyping recursive subtyping revealed ctr derek dreyer recursive type generativity acm sigplan notices v40 n9 september 2005 vijay menon neal glew brian r murphy andrew mccreight tatiana shpeisman alireza adltabatabai leaf petersen verifiable ssa program representation aggressive compiler optimization acm sigplan notices v41 n1 p397408 january 2006 dimitrios vytiniotis geoffrey washburn stephanie weirich open shut typecase proceedings 2005 acm sigplan international workshop types languages design implementation p1324 january 1010 2005 long beach california usa
transparent distributed processing rendering rendering particular computation global illumination uses computationally demanding algorithms consequence many researchers looked speeding computation distributing number computational units however almost cases completely redesign relevant algorithms order achieve high efficiency particular distributed parallel environment time global illumination algorithms gotten sophisticated complex often several basic algorithms combined multipass arrangements achieve desired lighting effects result becoming increasingly difficult analyze adapt algorithms optimal parallel execution lower levels furthermore bottomup approaches destroy basic design algorithm polluting distribution logic thus easily make unmaintainable paper present topdown approach designing distributed applications based existing objectoriented decomposition distribution logic case based corba middleware standard introduced transparently existing application logic design approach demonstrated using several examples multipass global illumination computation raytracing results show good speedup usually obtained even minimal intervention existing applications b introduction usually distributed algorithms differ considerably nondistributed versions order achieve optimal performance care weichselgarten 9 91058 erlangen germany email kipferinformatikunierlangende gates building 3643b stanford ca 94306 usa ful attention paid issues loadbalancing communication patterns data task management issues easily dominate core application logic distributed algorithms particular true systems allow flexible combination different distributed algorithms runtime loss application logic sea complex distribution issues severe growing problem reasons increased application complexity increased maintenance cost simply educational purposes particular maintenance portability different hardware architectures always major issue distributed applications also development debugging pur poses often desirable run code nondistributed serial fashion often impossible code designed distributed applications distribution logic deeply embedded code finally probably important reason keeping distribution issues transparent application programmer need add distributed computation existing application need add new features little impact existing application possible creating transparent distribution infrastructure avoids many options optimization thus likely offer inferior performance distribution code deeply integrated application thus work partly relies fact increased availability cheap highperformance computers allows us trade nonoptimal efficiency simpler cleaner maintainable application code course within limits objectoriented design application main starting point achieving transparent distribution basic idea objectorientation encapsulation data algorithms units communicate via messages carries nicely distributed systems objects live separate address spaces needs changed way objects communicate need aware fact peer object may actually located different computational unit objectoriented middleware like corba omg98a already provides much required distribution infrastructure location communication network transparency however programmers perspective corba still highly visible due corbaspecific types interface definitions requirements distributed objects proxies derive corbaspecific classes furthermore interfaces work well colocated objects result high communication costs objects get separated across network raises need transparently adapt interfaces objects may distributed remainder paper present several design patterns hiding distribution infrastructure distributed objectoriented systems patterns emerged work speedingup existing large system rendering global illumination ss95 distributing across network computers educational purposes required distribution infrastructure highly invisible normal programmer practical reasons could afford redesign whole system around intrusive distribution framework thus concentrated encapsulating distributed nondistributed modules providing interface adaptors take care distribution issues result system highly configurable distribution infrastructure mostly invisible programmer user still achieves good parallel perfor mance although concentrate distributed processing across network computers paper design patterns also used parallel execution modules within address space computers multiple cpus see section 4 11 previous work large number papers parallelization distribution rendering lighting simulation algorithms good surveys available rcj98 cr98 cro98 papers concentrate lowlevel distribution achieving high performance eg using tools pvm gbd 94 mpi gls94 one exceptions paper heirich arvo ha97 describing objectoriented approach based actor model although system provides location communication transparency distribution infrastructure still highly visible programmer several objectoriented frameworks supporting parallel distributed programming suggested eg poet jez93 poet c toolkit separates algorithms details distributed computing user code written callbacks operate data data distributed transparently user code called particular nodes data available although poet well frameworks abstracts underlying message passing details requires adapt algorithms given structure framework thus transparent programmer approaches view local resources part possibly worldwide distributed system computational grids worldwide virtual computer instance globus fk97 legion glfk98 certainly vital contribution distributed computing demands code significant means transparent programmer main goal efforts distribution following present integrated approach parallelization distribution application modules based fact objectoriented systems usually composed several quite independent subsystems contrast addressing parallelization level individual objects larger subsystems objects usually offer better suited granularity distributing computation across computers subsystems often accessed interface single object using facade design pattern ghjv95 application based common design approach facade classes easily mapped corba interfaces omg97 providing basis distributing applica tion however initial step solve problem corbaspecific code would introduced heart application want details distribution visible developer ideally developers able concentrate problem instead unnecessarily forced consider distributionspecific issues like network latencies corbatypes requestbundling optimized transport marshaling object se rialization mapping class creation requests factory methods handling communicating threads asynchronous operations template access implementation traditional serializer proxy object packer back front figure 1 wrapping existing implementations promotes code reuse enabling traditional classes communicate distributed system services provided wrapper services emulate traditional interfaces contained class help templates requires almost manual coding chosen build new distribution interface completely hides corba distribution infrastructure appli cation new interface provides illusion traditional nondistributed classes outside internally implementing optimized distributed object invocations based asynchronous communication multithreaded requestcallback scheme enable maximum parallelism additionally framework performs load balancing bundling requests avoid network latencies key concepts allow us optimally make use corba current synchronous method invocation paradigm new corba messaging specification omg98b add asynchronous method invocation becoming available encapsulating existing interfaces framework provides base classes provide management services object creation communication transport control synchronization many services see wrapper subsystems contain rendering illumination algorithms use inherit base classes example main management class controls overall execution rendering task must able define certain synchronization points ensure distributed objects view whole system occurs example waiting distributed rendering objects finish setup scene parsing routines invoking rendering com mands additionally management classes provide host machine information scripting engine configuring distribution objects resource locking access facades managed subsystem hiding use corba completely next three subsections address basic patterns used implement approach 21 wrapping distribution order actually reuse existing object implementations within distributed environment distribution framework provides wrappers entire subsystems wrapper actually consists two halfwrappers encapsulate subsystem corba client calling server called assume subsystem represented least one abstract c facade class defines interface subsystem also assume subsystem communicates outside interfaces defined similar facade classes replicate interfaces corba idl using struc lightingcomputerbase self delegate getillumination serialize delegate illumrep external polymorphism adapter new connect illumrepconverter new figure 2 specific method calls forwarded implementation pseudopolymorphic way general functions like serialization request packets inherited template base classes turn implement abstract interface declaration see also figure 6 tures pack relevant object data needs transferred object value extension corba available recently often also define new methods allow bundling multiple requests calling side implement server side forwarding requests wrapped facade object pseudopolymorphic way cs98 serializing bundled messages arrive managing asynchronous calls see figure 1 client role wrapped subsystem need instantiate c classes derive distributed c proxy template translate calls old c interface calls use corba object references layer also responsible bundling individual calls using new asynchronous interface methods bundled requests within corba interface although wrapping seems complicated require small amount manual coding work delegated generalized template abstract base classes see figure 2 viewed outside encapsulated subsystem looks like distributed corba object using equivalent corba idl interface contained object wrapper looks exactly like part traditional system using old c interfaces biggest benefit using kind wrappers possibility reusing existing code take advantage parallelization within subsystem enables distribution parallelization different subsystems great value particular multiple memoryintensive algorithms separated across multiple machines interfaces provided wrappers finally allow wrapped traditional objects transparently cooperate distributed objects introduced section 23 22 replication requestmultiplexing order old code use distributed subsystems need additional wrapper interface derived old c facade interface translates messages corresponding calls distributed corba objects eg section 21 mentioned translation several aspects one translates traditional corba types object data needs copied idl structures second small individual requests may accumulated sent across network bundles thus avoiding network traffic overhead addition take opportunity wrapper perform multiplexing repacketing requests across pool functionally identical corba servers enables us distribute multiplexer 2 host n host 0 processor n multiplexer 1 processor 0 direct lighting request thread raytracer manager raytracer asynchronous communication thread request manager figure 3 multiplexers distribute requests equally functionally equivalent objects either distributed across network dataparallel raytracers running different threads colocated lighting ob jects note multiplexers contain computation classes rather supply requests manage transport responses embedded request managers use questcallback model thread pool achieve asynchronous communication computational load evenly using load balancing performed wrapper however current synchronous nature corba method calls multiplexing needs use request callback scheme sv96 provided base classes load balancing performed sending requests server lowest load end servers maintain fifos requests balance network latencies filllevel fifos communicated back wrappers piggypacked data returned callbacks using scheme multiplexed classes look outside like single powerful instance subsystem benefit approach using wrappers multiplexers existing code fairly easily wrapped replicated thereby sped multiplexers fan requests wrappers section 21 automatically combine concentrate asynchronous requests multiple clients note patterns perfectly meet goal distribution transparency alter application logic remaining system following pseudocode shows multiplexer lighting computations inherits interface lighting base class overloads computation request method implementing scheduling strategy see also figure 6 idl interface lightop void computeilluminationsin sequence req interface multiplexer lightop void addlightopin lightop op c class multiplexer public idlmultiplexerinterface virtual void addlightoplightop op lightoplistpushbackop virtual void computeilluminationsrequest req int idx determinebestserver lightoplistidxcomputeilluminationsreq protected vector lightoplist 23 transparent services subsystems computational bottlenecks promise offer substantial speedup completely reimplemented request thread manager photon map particle tracer distributed lighting class kdtree figure 4 distribution parallelization services provide support implementing advanced computation algorithms take advantage distribution framework provides distribution parallelization services within wrapper classes go beyond plain data transportation interface adaption threadpool handling mutexes factories onetomany manytoone operating threads synchronization runtime system state type information pattern powerful form creating new computation object distributed system however require knowledge design behavior distribution ser vices wrapper classes provide corba interface traditional subsystems framework distributed parallel implementation subsystem easily access directly good example class performs distributed lighting computation using photonmap algorithms jen96 see figure 4 shows implementation reuse existing code tracing photons light sources reconstructing illumination information reused object implementations wrapped patterns described algorithm aware distributed parallel nature steer adapt computational requirements eg adding new particle tracer threads multiprocessor machine adding new instances distributed objects scheme allows programmer gradually make selected subsystems aware distribution infrastructure without compromising remaining system way possibility reusing existing classes simplifies creation new distributed subsystems straightforward buildingblock manner however drawback approach dedication distributed computing making new subsystem difficult use running application serial singlethreaded fashion 24 discussion patterns introduced offer several benefits ffl new developments within traditional framework immediately distributable wrapper pattern offers speedup replication multiplexing ffl need developers algorithms bother distribution parallelization issues distribution framework alter interfere application logic ffl distribution parallelization services offered framework provide developer advanced computation classes basic functionality guaranteed conform overall design multi lighting gradients combine irradiance direct multiplexer map photon combine figure 5 logical data flow within example distributed lighting network performing direct indirect caustic illumination different lightops replicated use multiplexer speedup ffl learning effort beginners reduced dramatically transparent distribution infrastructure particular compared distribution frameworks large number new software concepts introduced ffl distribution framework transparently supports modularization helps structure framework toolkits well defined interfaces help reduce overall programming effort promotes better understanding big picture pattern typical case applica tion like modular objectoriented program viewed various levels granularity patterns support buildingblock design strategy distribution infrastructure uses consistent interfaces patterns combined applied traditional class implementations configuration script especially research development purposes offers tremendous flexibility note multiplexer used easily handle new parallel implementation computation class turn constructed using wrappers distributed classes multiplexers 3 implementation vision rendering architecture ss95 objectoriented system physicallybased realistic image synthesis lighting network within vision framework provides objectoriented way dealing functional decomposition lighting calculations implements lighting subsystem vision decomposing global illumination computations set lighting operators perform partial lighting simulation conceptually lightops take representation light distribution environment input generate new representation output connecting lightops right way lighting simulation configured flexibly simulating lightpaths multipass fashion crmt91 lighting network acts data flow network much spirit avs ufk 89 similar systems figure 5 shows example simple distributed lighting network uses two basic lightops perform direct lighting adds individual contributions performs indirect lighting computa tions result sum direct indirect illumination also see figure 8 direct illumination light sources obtained raytracing photonmap algorithm jen96 computes caustic light paths indirect illumination computed irradiance gradients algorithm wh92 whole lighting network managed special object called multilighting implements lighting subsystem interface towards vi implementations corba idl interfaces skeleton multilighting skeleton skeleton lightingcomputer lightingcomputerbase lightopbase skeleton multilighting figure multiple layers abstract interface declarations complemented c definitions give consistent interfaces components lighting subsystem sion subsystems behaving according facade design pattern ghjv95 renderer subsystem vision framework encapsulates various screen sampling techniques computes intersections visible objects scene queries lighting subsystem incident illumination point illustrates clear separation independent computation within vision rendering framework applied presented distribution framework rendering lighting network subsystem vision allow individual renderer lightop objects distributed across network run parallel use threads figure 6 shows inheritance relations interfaces lightops multilighting facade asynchronous communication patterns services implemented within base classes note wrapping traditional code c class lower left pseudopolymorphic wrapper template 1 requires manual coding figure 7 shows running distributed vision system note hosts 1 2 contain multiple concurrent lightops within lighting network therefore multiple processors enable functional parallelism basic operating system functions accessed via portable operating system adaption layer interface ace library sch94 communication remote object creation done using corba implementation visibroker inprise facilitate development maintenance design base classes follows guidelines several design patterns ghjv95 cs98 ls96 shp97 mck95 1 external polymophism pattern cs98 allows treating nonpolymorphic classes proper inheritance relationship providing classes method simply delegates calls sufficiently global template signature adapter thats called external turn calls method performs task section demonstrates flexibility presented distribution parallelization framework applied vision rendering system several distributed lightops implemented using design patterns section 2 discuss typical configurations order reuse traditional implementations efficiently several multiplexer classes available along different scheduling strategies allows building distributed lighting networks functionally distribute lighting calculations configuration distributed objects usually specified tcl configuration file using existing scripting engine traditional vision system avoiding introduction second tier abstraction configuring distributed system compare phi99 41 efficiency asynchronous communication first example show benefits asynchronous communication pattern used throughout corba implementation base classes heart distribution infrastructure table 1 compares packeted data transfer within small lighting network using asynchronous requests equivalent network using original interface fine granularity cases use wrapped traditional lightops host configuration sgi onyx onyx o2 processors r10k mhz 196 195 195 renderer theta lighting irr grad direct combine main reason speedup 33 low number method calls transfer requests 100 mbits network case asynchronous communication compared synchronous invocations second case networks transfer identical 227 mb request data corba marshaling synchronous protocol corba blocks client server completed method call responsible poor performance second case shows clearly important fact latency almost entirely hidden using asynchronous protocol provided distribution base classes 42 distributed rendering optimize rendering times case calculating previews testing new computation class implementations pick example section 22 see figure 3 following configuration distributed vision system shows best achievable speedup found using framework uses 4 hosts total 8 processors 8 raytracers work dataparallel mode 6 lighting modules group controlled multi plexer distribution framework ensures communication two multiplexers done asynchronously sgi onyx onyx o2 o2 processors r10k mhz 196 195 195 195 renderer lighting lighting hosts execute traditional implementation irradiance gradients wh92 lightop wrapped distribu tion additionally wrappers multiprocessing machines also include multiplexer executes incoming requests parallel using thread pool multiple threads per light hostmanager light vision op light op light op light op host 5 host 4 host 3 host 2 host 1 host 0 master renderer slave vision slave renderer slave hostmanager hostmanager vision vision hostmanager renderer lighting op vision hostmanager hostmanager netmanager master renderer figure 7 example running distributed vision system master renderer controls dataparallel activity slave renderers hosts 3 4 5 multilighting host 0 facade lighting subsystem lighting network residing hosts 1 2 also distributed shown later examples entry point masterlightop controls lightops note functional parallelization also communicates asynchronously pipeline fashion indicated solid arrows enabling parallel execution host multiple processors single netmanager hostmanager host responsible bootstrapping system onto network providing initial object factory methods dashed arrows cpu multiplexer synchronizes order overload machine configuring system required name hosts lightop parameters configuration file tcl scripts system setup take care distributing objects using net hostmanager figure 7 distributed system compared traditional vision system single thread control running fastest machine single address space calculating lighting lightop implementation table 2 shows speedup obtained near theoretical maximum 125 overhead 90 seconds consists seconds session setup 5 seconds additional parsing corba startup client another 5 seconds delay allowing hosts clean corba objects main corba startup client shuts vision instances subtracting overhead obtain penalty 13 rendering phase distributed system believe good result given general unintrusive distribution infrastructure 43 distributing complex lighting computations functional decomposition lighting network offers biggest potential distribution parallelization risk high communication costs shown section 41 asynchronous requestcallback communication paradigm able provide partial solution problem following example make heavy use patterns sections 23 21 configuration uses 3 hosts total 7 processors lighting onyx 196 4 photon map direct combine onyx 195 2 theta photon map irrad grad octane setup reconstruction method photon map lightop takes much time process request lightops lighting network consequently multiplexer used distribute lightop onto 3 hosts contrast three lightops executed multiprocessor machines reconstruction method fast communication optimized corba implementation supports object collocation order drive complex lighting subsystem two hosts execute rendering objects controlled multiplexer dataparallel way one see table 3 speedup obtained setup good first example even advantage nondistributed version running single address space outweigh communication overhead distributed system profiling shows performance difference theoretical maximum 143 mainly due process idle times occurs example calculation one upstream lightop sufficiently delayed since underlying lighting network entirely pulldriven pipeline blocked try cope problem extent allowing asynchronous interface drive three parallel streams time additionally resource handling within base classes allows running rendering computation concurrently lighting computation resulting kind interleaving cpuusage scheme lighting pipeline host stall example shows cases full transparency distribution infrastructure cannot hide inherent limitations due coarse grained communication patterns existing subsystems note however behavior mostly problem nondistribution aware algorithms lighting network much general drawback distribution frame work however even limited success still get speedup without change application logic apart form one also take account traditional system performs quite well case terms execution speed severely limited hosts memory resources especially photonmap lightop needs store many photons shot scene working large scene descriptions distributed photonmap lightops example memory three hosts disposition initial shooting particles done parallel reducing lighting setup time needed one seventh 7 processors three hosts great value simulating high quality caustics wallclock asynchronous wrappedonly seconds lightops lightops async host 2 host host async async multilighting session renderer combine distributed direct distributed distributed irradiance gradasync sync sync host 2 host 1 host multilighting renderer combine direct gradients irradianceparsing scene 580 567 lighting setup 156 168 renderer setup 030 034 render frame 192206 291695 total 197736 297492 table 1 packeted asynchronous data transfer within lighting network compared lightops using corbas synchronous request invocation wallclock distributed traditional seconds system vision host host raytracer host host host raytracer host raytracer raytracer lighting gradients irradiance lighting gradients irradiancegradients irradiance lighting host raytracer parsing scene 561 lighting setup 014 renderer setup 036 render frame 31703 235920 total 38741 238015 table 2 distributed system using two multiplexers controlling dataparallel renderers lighting objects left side compared traditional singlethreaded system although certainly price pay flexibility distribution strategy obtain high degrees freedom configuring distributed system adapting challenges specific lighting network presented general approach providing transparent infrastructure distributing objectoriented systems used infrastructure distribution parallelization rendering lighting computations created several design patterns hide corba distribution infrastructure average system programmer system provides distribution services advanced application programmer still offers access basic distribution classes sophisticated tuning necessary use corba middleware allowed us abstract much underlying communication infrastructure contrary popular believe runtime overhead using corba minimal however synchronous nature corba messages major problem work around using nontrivial requestcallback scheme based multithreading addition asynchronous messaging corba help tremendously implementation distribution functionality within base classes makes distribution issues totally transparent application programmer demonstrated approach examples vision rendering framework provides transparent dataparallelism distribution existing object struc ture developers new computation classes free use distribution infrastructure add distribution aware modules wrap existing algorithms distribute across network computers distribution infrastructure proven practical sta ble offers welldefined interfaces without imposing limitations remaining parts vision system distributed lighting networks simply constructed configured scripts specify location parameterization specific modules network figure 8 gives impression flexible structure allows configuration whole distributed system different purposes ranging speeding preview renderings experimenting complex lighting networks consisting many different distributed lighting simulation algorithms future work distribution infrastructure concentrate recovering efficiency lost process particular would useful system would take care distribution modules across network autometically perform better loadbalancing however due dynamic nature application requires knowledge computational characteristics different modules making available wrapping level runtime would allow us statically allocate maybe dynamically move modules across network 6 acknowledgements would like thank thomas peuker developed initial idea distribution framework also marc stamminger provided considerable support integrating new scheme existing vision system would like thank anonymous reviewers helped improve initial version document r parallel distributed photorealistic rendering progressive multipass method global illumination parallel graphics visualization technology external polymorphism object structural pattern transparently extending c concrete data types metacomputing infrastructure toolkit pvm parallel virtual machine john vlis sides architectural support extensibility autonomy widearea distributed object systems using mpi portable parallel programming messagepassing interface parallel rendering actor model global illumination using photon maps epee eiffel environment program distributed memory parallel computers active ob ject object behavioral pattern concurrent program ming poet parallel objectoriented environment toolkit enabling highperformance scientific computing parallel hierarchical radiosity complex building interiors selecting locking primitives parallel programs object management group object management group messaging omg tc document orbos980505 edition universit des sciences et technologies de lille overview parallel photorealistic graphics adaptive communication envi ronment objectoriented network programming toolkit developing communication software vision architecture global illumination calculations lighting networks new approach designing lighting algorithms distributed callbacks decoupled communication corba application visualization system computational environment scientific visualization irradiance gradients tr progressive multipass method global illumination using mpi pvm parallel virtual machine active object global illumination using photon maps vision architecture global illumination calculations application visualization system composite lighting simulations lighting networks architectural support extensibility autonomy widearea distributed object systems ctr nathan carr jesse hall john c hart ray engine proceedings acm siggrapheurographics conference graphics hardware september 0102 2002 saarbrucken germany
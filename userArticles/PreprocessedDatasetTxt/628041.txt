effect buffering performance rtrees abstractpast rtree studies focused number nodes visited metric query performance since database systems usually include buffering mechanism propose number disk accesses realistic measure performance develop buffer model analyze number disk accesses required spatial queries using rtrees model used evaluate quality rtree update operations various node splitting tree restructuring policies measured query performance resulting tree use model study performance three wellknown rtree loading algorithms show ignoring buffer behavior using number nodes accessed performance metric lead incorrect conclusions quantitatively also qualitatively addition consider problem many levels rtree pinned buffer b introduction rtrees 3 common indexing technique spatial data widely used spatial multidimensional databases typical applications include computeraided design geographic information systems computer vision robotics multikeyed indexing traditional databases temporal databases scientific databases significant amount effort devoted development better rtree construction algorithms 9 1 8 4 5 6 work focused proposing comparing new algorithm previous ones little work done methodology comparing algorithms notable exceptions work kamel faloutsos 4 theodoridis sellis 10 4 authors develop analytical model prediction query performance model provides good insight problem especially establishing quantitative relationship performance total area perimeter minimum bounding rectangles mbrs tree nodes suffers one major drawback primary objective function comparison number nodes visited real databases portion tree buffered main memory buffering portions tree significantly affect performance consequently propose better metric average number disk accesses required satisfy query work theodoridis sellis 10 provides fully analytical model requiring minimum bounding rectangles rtree nodes input work also focuses number nodes visited model could coupled model done model kamel faloutsos order derive model based number disk accesses borrow techniques developed bhide et al 2 context modeling databases uniform access within several partitions develop new buffer model model used evaluate quality rtree update operation node splitting policies 3 packing algorithms 8 4 measured query performance resulting tree model accurate simple understand making easy researchers integrate studies furthermore applicable rtrees easily modified model btree performance main contributions paper first buffer model methodology second demonstration importance considering buffer third insight large buffer used fourth showing effect pinning top levels rtree buffer emphasize inclusion buffer changes quantitative performance algorithms cases changes qualitative ordering algorithms buffer model analytic model based simple probability theory overall performance model hybrid model start using packing algorithm create actual rtrees various data sets compute minimum bounding rectangles tree nodes use input buffer model rest paper organized follows section 2 provide background information rtrees describe three loading algorithms chosen test results since choice means exhaustive emphasize purpose paper draw irrevocable conclusions best loading algorithm although allows comparisons chosen ones rather demonstrate need utility buffer model section 3 present query performance models kamel faloutsos modification region query model new buffer model section 4 present validation model section 5 contains results model experiments section 6 concludes 2 overview rtree loading algorithms section provide brief overview rtree loading algorithms detailed understanding loading algorithms useful necessary rest paper reader interested detailed description referred articles listed bibliography 21 rtrees rtree hierarchical data structure derived btree designed efficient execution intersection queries rtree stores collection rectangles change time insertion deletion rectangles arbitrary geometric objects also handled representing object smallest upright rectangle enclosing rtrees generalize easily dimensions higher two notational simplicity describe 2d case node rtree stores maximum n entries entry consists rectangle r pointer p leaf level r bounding box actual object pointed p internal nodes r minimum bounding rectangle mbr rectangles stored subtree pointed p note path along tree corresponds sequence nested rectangles figure 1 sample rtree input rectangles shown solid last actual data object note also rectangles level may overlap rtree set rectangles means unique figure 1 illustrates 3level rtree assuming maximum 4 rectangles fit per node assume levels numbered 0 root 1 2 leaf level 64 rectangles represented small dark boxes 64 rectangles grouped 16 leaf level pages numbered 1 16 note mbr enclosing leaf node smallest box fully contains rectangles within node mbrs serve rectangles stored next level tree example leaf level nodes 1 4 placed node 17 level 1 mbr node 17 nodes 181920 purposely drawn slightly larger needed clarity root node contains 4 level 1 nodes 17 18 19 20 perform query q rectangles internal intersect query region must retrieved accomplished simple recursive procedure starts root possibly follows several paths along tree node processed first retrieving rectangles stored node intersect q node internal node subtrees pointed retrieved rectangles processed recursively otherwise node leaf node retrieved rectangles simply reported illustration consider query q example figure 1 processing root node determine nodes 19 20 level 1 must searched search proceeds nodes cases determined query region intersect rectangles within two nodes two subqueries terminated rtree shown figure 1 fairly well structured inserting rectangles rtree based insertion algorithms guttman 3 would likely result less well structured tree algorithms create well structured trees developed described section 22 algorithms attempt cluster rectangles minimize number nodes visited processing query rest paper assume exactly one node fits per page hereafter use two terms interchangeably 22 loading algorithms section describe three loading algorithms first based inserting tuple time using one insertion algorithms proposed guttman 3 tupleatatime algorithm inserts one tuple time rtree using quadratic split heuristic guttman 3 note resultant rtree worse space utilization structure relative two algorithms discussed next thus node disk accesses may necessary satisfy query following two packing algorithms use similar framework based preprocessing entire data file determine group rectangles nodes following assume data file r rectangles stored tree n rectangles per node whole processes similar building btree collection keys leaf level 7 general algorithm 1 preprocess data file r rectangles ordered drne consecutive groups n rectangles group n intended placed leaf level node note last group may contain less n rectangles 2 load drne groups rectangles pages output tuples mbr pagenumber leaf level page temporary file pagenumbers needed setting child pointers nodes one level 3 recursively pack mbrs nodes next level root node remains algorithms differ rectangles level ordered nearestx algorithm proposed 8 rectangles sorted xcoordinate details given paper assume xcoordinate rectangles center used rectangles packed nodes using ordering hilbert sort hs fractal based algorithm proposed 4 algorithm orders rectangles using hilbert fractal space filling curve center points rectangles sorted based distance origin measured along hilbert curve determines order rectangles placed nodes rtree 3 model description kamel faloutsos 4 introduced analytical model computing average response time query function geometric characteristics rtree model consider effect buffer performance measured number rtree nodes accessed practice query performance mainly affected time required retrieve nodes touched query reside buffer cpu time required retrieve process buffer resident nodes usually negligible start describing model kamel faloutsos modify model better fit definition uniformly distributed queries fixed size finally extend model take account existence buffer including handle pinning buffer top levels rtree section consider 2dimensional data set consisting rectangles stored rtree h1 levels labeled 0 h input rectangles normalized fit within unit square assume queries rectangles q size q x theta q uniformly distributed unit square note point query corresponds case q description concentrates 2d generalizations higher dimensions straightforward throughout section use following notation number pages ith level total number pages ie jth rectangle ith level xextent r ij yextent r ij area r ij ie q probability r ij accessed query q number accesses r ij sum areas mbrs sum xextents mbrs sum yextents mbrs number queries performed far expected number queries required fill buffer number distinct pages levels accessed n queries expected number pages buffer resident accessed performing query size q x theta q expected number disk accesses performing query size q x theta q 31 model kamel faloutsos kamel faloutsos consider bufferless model performance measured number nodes accessed independent whether currently reside buffer observe uniform point queries probability accessing r ij area r ij namely ij point level r ij resides immaterial rectangles containing q must retrieved accordingly point query expected number nodes retrieved derived kamel faloutsos 1 sum areas rectangles leaf level mbrs well mbrs internal nodes turn attention region queries let ha b c di denote upright rectangle bottom left top right corners b c respectively consider rectangular query modified notation 4 make consistent notation used paper b figure 2 two data rectangles region query q b corresponding extended rectangles equivalent point query q tr q tr top right corner q inside extended rectangle r illustrated figure 2 kamel faloutsos infer probability accessing r performing q area r 0 region query q equivalent point query q tr rectangles extended outlined thus expected number nodes retrieved derived 4 equation 2 illustrates fact good packing algorithm cluster rectangles minimize total area total perimeter rectangles internal nodes rtree point queries hand q minimizing total area enough 32 modification model region queries consider set uniformly distributed region queries size q x theta q query rectangle prescribed dimensions fits entirely within unit square otherwise rectangle would equivalent possibly much smaller rectangle two potential problems using equation 2 analyzing performance queries fixed size b figure 3 domain q tr query size 03 theta 03 u 0 area shaded b three data rectangles probability accessing r area r 0 divided area u 0 formula 2 uses area r 0 shown dashed instead 1 uniformly distributed rectangular queries size q x theta q top right corner q tr query region q cannot arbitrary point inside unit square entire query region fit within unit square rather q tr must inside box u 2 probability accessing rectangle area r value bigger one rather access probability percentage u 0 covered rectangle r q difference formulas 2 3 small q small becomes much larger size q increases illustrated figure 3 region query size 03 theta 03 considered note q tr must fall inside u 0 ie outside shaded area figure 3a three rectangles r 1 r 2 r 3 sizes 01 theta 02 01 theta 01 005 theta 005 respectively shown figure 3b r 3 equation 2 compute probability equation 3 probability q access r 1 modified model 20 resp 16 original model kamel faloutsos difference arguably matter interpretation point original model predicts probability accessing rectangle h01 01 09 09i query size 03 theta 03 121 modification probability accessing rectangle 100 point model probability access input rectangles longer uniform rectangles within shaded region figure 3a less likely accessed rectangles inside u 0 alternative guarantees uniform access probability allow q tr fall uniformly inside still requires correction model kamel faloutsos namely q query windows could partially lie outside area interest thus effectively reducing actual query size since want model measure performance function specific query size rest paper use former interpretation even though means data along edges data set might accessed less frequently buffer model well experiments performed validate access probabilities computed using equation 3 use q ij denote probability rectangle r ij accessed performing query q probability computed applying formula 3 note q point ij simply ij area r ij 33 buffer model bhide et al 2 analyze lru buffer replacement policy databases consisting number partitions uniform page access within partition modeling performance buffer warmup observed buffer hit probability end warmup period good estimator steady state buffer hit probability conjectured similar behavior would occur context rtrees applying lru replacement policy namely steady state buffer hit probability virtually buffer hit probability buffer first becomes full conjecture verified experimentally discussed section 4 uniformly distributed point queries probability accessing rectangle r ij performing query ij accordingly probability r ij accessed next n queries expected number distinct pages accessed n queries note may may bigger b buffer initially empty first becomes full performing n queries n smallest integer satisfies dn b value n determined simple binary computen high high low high2 dn dn low n else high n return n buffer full probability r ij buffer equal p b ij 1 probability random query requires disk access since steady state buffer hit probability approximately buffer hit probability n queries expected number disk accesses point query steady state derivation also holds region queries provided q ij used instead ij see formula 3 summarize results section expected number disk accesses required satisfy uniformly distributed random query q size q x theta q q q ij probability q intersects r ij given equation 3 finally point easy extend results model buffer management policy pins top levels rtree buffer simply reduce number buffer pages number pages pinned levels omit top levels model 4 model validation validated model comparing simulation simulation models lru buffer like model takes input list mbrs nodes levels generates bufsize simul model dif simul model dif simul model dif 50 23120 22682 1189 22060 21651 1185 15892 15807 053 100 17008 16862 086 16288 16166 075 12336 12275 049 200 11627 11599 024 11194 11172 020 08720 08710 011 table 1 validation average number disk accesses per query model simulation random point queries unit square checks nodes mbr see contains point mbr contain point node requested buffer pool node buffer pool least recently used node buffer pushed new node put top lru stack note simulation accurate sense rtree implementation retrieves rectangles internal intersect region query confidence intervals collected using batch means 20 batches 1000000 queries resulting confidence intervals less 3 90 confidence level ran comparisons three different rtrees 6 different buffer sizes tree rtrees 1668 nodes mbrs nodes different produced three different packing algorithms table 1 report average number pages required disk per point query predicted simulation model percent difference relative simulation results within 2 less confidence intervals returned simulation comparison experiments shown resulted agreement within 2 less simulation region queries gave similar results 5 model results section present performance results predicted model consider two types queries point queries region queries point query specifies point unit square finds rectangles contain point region queries specify region given size find rectangles intersect region query rectangle size q x theta q whose upper right corner contained region u 0 described section 32 51 need consideration buffer impact figure 4 plots number disk accesses versus buffer size long beach data set extracted tiger system u bureau census assuming rtrees 100 rectangles per node left plot point queries right region queries consider top two curves right plot small buffer sizes tat algorithm requires fewer disk access nx algorithm buffer size 200 performance two algorithms crosses nx algorithm becomes better algorithm hence ignoring buffering would result incorrect conclusion tat better nx thus underscoring importance including buffer effects comparison studies second experiment shows considering buffer impact introduce significant errors figure 5 present results synthetic data uniformly distributed data sets created containing 10000 300000 rectangles rectangle lower left corner uniformly distributed unit square rectangles squares length chosen uniformly 0 ffl value ffl fixed data set sizes equal 2 02510000 thus 10000 rectangle data set sum rectangle areas equal 025 unit square 100000 rectangles total area equals 25 times unit square similar experimental methodology used 4 top left graph plots number nodes visited ie buffering considered versus number rectangles data set top right graph plots number disk accesses versus data set size buffer size 10 bottom graph buffer size 300 ignoring buffer impact top left leads conclusion querying rtree 300000 rectangles expensive querying rtree 25000 rectangles could cause query optimizer produce poor query plan buffering considered fact larger trees expensive evident 52 choosing buffer size rtrees section study reduction disk accesses obtained increasing buffer size since main memory valuable resource insight gains allocating buffer space needed consider figure 4 number disk accesses versus buffer size plotted point region queries run long beach tiger data set data set 53145 rectangles actually line segments node size 100 rectangles assumed resulting hs nx algorithms 532 pages leaf level 6 pages level 1 1 root node buffer size varied 2 500 pages 04 928 rtree left plot point queries curves plotted top bottom tat nx hs rtree produced tat algorithm poorly structured result seems benefit significantly increase buffer size hs tree much better structured experiencing halving number required disk accesses buffer size 10 additional buffer increases help modestly nx algorithm experience much reduction needed disk accesses small buffer sizes hs algorithm hypothesize better rtree structure capable capitalize small amounts buffer point queries whereas worse rtree structure linear reduction disk accesses right plot 1 region queries note region queries none curves data size level 1 root level 2 level 3 level 4 table 2 number nodes per level well defined knee thus based experiment appears possible executing region queries reductions disk accesses increasing buffer size linear point queries 53 choosing number levels pinned past buffer management studies shown btrees root maybe first level pinned buffer pool pinning nodes decreases buffer size available pages guarantees pinned pages buffer present experiments investigate gains performance expected pinning rtree nodes many levels pinned experiments section wanted get deeper rtrees keeping experiment time reasonable created synthetic data sets 40000 250000 rectangles used rtree nodes size 25 resulted 4 level rtrees numbers nodes per level shown table 2 figure 6 plot number disk accesses point queries versus data size three buffer sizes trees created hs algorithm results algorithms similar plot top left buffer 500 pages top right buffer 1000 pages bottom graph buffer 2000 pages number disk access remains roughly pinning pinning first root level pinning first two levels three scenarios plotted single top line three graphs bottom line pinning third level addition first two levels general rule thumb pinning level makes big difference total number pages pinned within factor two buffer size total number pages pinned less one third buffer size marginal benefits seen smaller relative number pinned pages lru replacement policy succeeds keeping top levels buffer without explicit pinning example buffer size 500 data size 250000 rectangles pinning three levels pins 417 pages results 53 fewer disk accesses data size 80000 rectangles 135 pages pinned saving 4 buffer size 2000 pinning first three levels makes almost difference since number pages pinned less one fourth buffer size thus point queries pinning advantageous total number nodes pinned within factor 2 buffer size note pinning never hurts performance hence fixed size buffer dedicated rtree application many levels possible pinned buffer shared among many applications benefit pinning must compared applications buffer model used predict benefit accrued pinning number rtree levels region queries experiments date shown resulted modest 25 improvement pinning thus appears pinning may mostly benefit point queries even special scenarios 6 conclusions developed new buffer model predict number disk accesses required per query given input rtree specified minimum bounding rectangles node tree model shown experimentally agree simulation within 2 numerous test cases model simple implement quick solve thus providing useful methodology studies order develop model first modified earlier rtree region query model modified query model used component overall model predict number disk accesses required per query model demonstrated using number nodes accessed per query performance metric sufficient ignores buffer effects show buffer effects taken account quantitative predicted performance change qualitative predictions change well particular actual ordering policies differ buffering considered versus considered thus essential consider buffer effects performance study rtrees use number disk accesses primary metric addition used model determine data considered small amounts buffer superlinearly improve performance well structured rtrees point queries poorly structured trees experience linear improvement performance due increase buffer space addition find region queries even well structured rtrees result linear improvement buffer added finally show cases pinning top levels rtree little effect performance relative using lru buffer point queries find certain scenarios buffer size times larger number nodes level pinning level significantly improve performance acknowledgments would like thank jeff edgington developing rtree packing algorithm code would also like thank ken sevcik useful discussions preliminary version work r simple analysis lru buffer replacemtn policy relationship buffer warmup transient rtrees dynamic index structure spatial searching packing rtrees hilbert rtree improved rtree using fractals simple efficient algorithm rtree packing time space optimality btrees direct spatial search pictorial databases using packed rtrees model prediction rtree performance tr ctr shuching chen xinran wang naphtali rishe mark allen weiss webbased spatial data access system using semantic rtrees information sciencesinformatics computer science international journal v167 n14 p4161 2 december 2004 yongjin choi junki min chinwan chung cost model spatiotemporal queries using tprtree journal systems software v73 n1 p101112 september 2004 yufei tao dimitris papadias jun zhang cost models overlapping multiversion structures acm transactions database systems tods v27 n3 p299342 september 2002 jignesh patel yun chen v prasad chakka stripes efficient index predicted trajectories proceedings 2004 acm sigmod international conference management data june 1318 2004 paris france victor teixeira de almeida ralf hartmut gting indexing trajectories moving objects networks geoinformatica v9 n1 p3360 march 2005 byunggu yu thomas bailey processing partially specified queries highdimensional databases data knowledge engineering v62 n1 p177197 july 2007 antonio corral yannis manolopoulos yannis theodoridis michael vassilakopoulos cost models distance joins queries using rtrees data knowledge engineering v57 n1 p136 april 2006
specifying verifying broadcast multicast snooping cache coherence protocol paper develop specification methodology documents specifies cache coherence protocol eight tables states events actions transitions cache memory controllers use methodology specify detailed modern threestate broadcast snooping protocol unordered data network ordered address network allows arbitrary skew also present detailed specification new protocol called multicast snooping better illustrate utility tablebased specification methodology finally demonstrate technique verification multicast snooping protocol sketch manual proof specification satisfies sequentially consistent memory model b 1 highlevel specification cache controller since high level cache coherence protocols simply finite state machines would appear first glance would easy specify verify common three state msi broadcast snooping protocol unfortunately level detail required actual implementation even seemingly straightforward protocols numerous transient states possible race conditions complicate tasks specifica tion verification example single cache controller simple msi protocol specify section 21 11 states 8 transient 13 possible events 21 actions may perform system components similarly complicated interactions components difficult specify verify verification important rigorous verification important since complexity lowlevel implementable protocol makes difficult design without errors many protocol errors uncovered simulation simulation random testing shown effective finding certain classes bugs lost protocol messages deadlock conditions 27 however simulation tends effective uncovering subtle bugs especially related consistency model subtle consistency bugs often occur unusual combinations circumstances unlikely undirected random simulation drive protocol situations thus systematic perhaps formal verification techniques needed expose subtle bugs verification requires detailed lowlevel specification systematic verification implementable cache coherence protocol requires lowlevel detailed specification entire protocol exist numerous verification techniques techniques seek show implementable specification meets certain invariants verifying abstract specification shows abstract protocol correct example verification highlevel specification omits transient states may show invariants hold abstraction protocol show implementable version protocol obeys invariants current specifications sufficient specifications published literature sufficiently detailed implementation purposes thus suitable verification pur poses academia protocol specifications tend highlevel complete lowlevel specification may necessary goal publishing research 4713 moreover complete lowlevel specifica tion without concise format lend publication academia industry lowlevel detailed specifications necessary exist best knowledge none published lit erature specifications often match hardware closely complicates verification limits alternative implementations eliminates problem verifying implementation satisfies specification new tablebased specification technique sufficient verification address need concise lowlevel specifications developed tablebased specification methodology system component participates coherence protocol table specifies components behavior respect given cache block illustrative example table 1 shows specification sim plified atomic cache controller rows table correspond states component enter columns correspond events occur entries actions taken resulting state occur combination state event actions coded letters defined table example entry denotes load event cache controller block state causes cache controller perform get shared enter state simple example however show power specification methodology include many transient states possessed realistic coherence protocols simple atomic proto cols traditional specification approach drawing state transition diagrams tractable however nonatomic transactions cause explosion state space since events occur 1 simplified atomic cache controller transitions event state load store gets getx cm di perform getshared send data requestor c perform getexclusive send data memory request issued completes numerous transient states used capture behavior section 2 illustrates methodology realistic broadcast snooping protocol multicast snooping protocol 5 methodology proving tablebased specifications correct using tablebased specifica tion methodology present methodology proving specification sequentially consistent show methodology used prove multicast protocol satisfies sc method uses extension lamports logical clocks 16 timestamp load store operations performed protocol timestamps determine operations reordered witness sc intended designer protocol thus associated execution augmented protocol sequence timestamped operations witnesses sequential consistency execution logical clocks associated timestamping actions effect conceptual augmentation protocol specified using tablebased transition tables protocol note set possible operation traces protocol equals augmented protocol logical clocks purely conceptual devices introduced verification purposes never implemented hardware consider process specifying logical clocks actions intuitive designer protocol indeed process valuable debugging tool right straightforward invariant augmented protocol guarantees protocol sequentially consistent namely executions augmented protocol associated timestamped sequence lds sts consistent program order operations processors value ld equals recent st prove invariant numerous support invariants added needed shown executions protocol satisfy invariants induction length execution involves tedious casebycase analysis possible transition protocol invariant summarize strengths methodology process augmenting protocol timestamping useful designing correct protocols easilystated invariant augmented protocol guarantees sequential consistency however methodology also involves tedious casebycase proofs transitions respect invariants knowledge automated approach known avoids type case analysis problem verifying sc undecidable automated approaches proved work limited class protocols finite state observer reorder operations order find witness sequential consistency 14 include protocols paper discuss verifications techniques compare section 4 contributed paper makes four contributions first develop new tablebased specification methodology allows us concisely describe protocols second provide detailed lowlevel specification threestate broadcast snooping protocol unordered data network address network allows arbitrary skew third present detailed lowlevel specification multicast snooping 5 better illustrate utility tablebased specification methodol ogy specification complicated protocol thorough enough warrant verification fourth demonstrate technique verification multicast snooping protocol sketch manual proof specification satisfies sequentially consistent memory model specifying broadcast multicast snooping protocols section demonstrate protocol specification methodology developing two protocols broadcast snooping protocol multicast snooping protocol protocols msi modified shared invalid use eight tables document specify states events actions transitions cache controller states events actions transitions memory controller controllers state machines communicate via queues events correspond messages processed incoming queues actions taken controller services incoming queue including enqueuing messages outgoing queues considered atomic 21 specifying broadcast snooping protocol section shall specify behavior msi broadcast snooping protocol 211 system model assumptions broadcast snooping system collection processor nodes memory nodes possibly collocated connected two logical networks possibly sharing physical network shown figure 2 processor node contains cpu cache cache controller includes logic implementing coherence protocol also contains queues cpu cache controller mandatory queue contains loads lds stores sts requested cpu ordered program order ld st entries addresses sts data optional queue contains readonly readwrite prefetches requested cpu entries addresses loadstore data queue contains ldst mandatory queue associated data case ld diagram processor node also shown figure 2 processor node address network fifo mandatory queue fifo cache controller optional queue fifo tbes loadstoredata cpu data network broadcast address network point point data network 2 broadcast snooping system memory space partitioned among one memory nodes responsible responding coherence requests data current owner ie processor node block modified also receives writebacks processors stores data memory two logical networks totally ordered broadcast network address messages unordered unicast network data messages address network supports three types coherence requests gets getshared getx getexclusive putx dirtywriteback protocol transactions address messages contain data block address coherence request type getx gets putx id requesting processor data messages contain data data block address components system make transitions based current state current event eg incoming request specify states events transitions component rest section many components make transitions many blocks memory transitions happen concurrently assume however system appears behave transitions occur atomically 212 network specification network consists two logical networks address network totally ordered broadcast network total ordering however imply messages delivered time example asynchronous implementation path one node may take longer path another node address network carries coherence requests transition address network modeled atomically transferring address message output queue node input queues nodes thus inserting message total order address messages data network unordered pointtopoint network delivering responses coherence requests transition data network modeled atomically transferring data message output queue node input queue destination node nodes connected networks via queues assume queues address queues network nodes served fifo order data queues address queues nodes network served without restriction example allows processor nodes getx pass putx victim block 213 cpu specification transition cpu occurs places ld st mandatory queue places prefetch optional queue removes data ldst data queue perform transitions time 214 cache controller specification transition cache controller may inspect heads incoming queues inject new messages queues make appropriate state changes assume serving incoming queues queue starved address mandatory optional queues served strict fifo order actions taken queue served considered atomic done another queue including queue served actions taken however cache controller checks ensure resources space outgoing queue allocated tbe available actions sum resources required actions available cache controller aborts transition performs none actions waits resources become available define cache block available ldst either referenced block already exists cache exists empty slot accommodate referenced block received external sources exception rule available block cache situation handled treating ld st prefetch cache block available replacement event victim block request head mandatory optional queue cannot serviced block present correct permissions transaction block outstanding requests queue serviced optional requests discarded without affecting correctness cache controller keeps count outstanding coherence transactions issued node transaction one transaction buffer entry tbe reserved transactions issued space outgoing address queue already outstanding transaction block tbe contains address block requested current state transaction data received1 1 data field tbe may required implementation may able use caches data array buffer data block modification reduces size tbe avoids specific actions transferring data tbe cache data array 2 broadcast snooping cache controller states stable states transient states state cache state description invalid shared modified isad busy invalid issued gets seen gets data yet isa busy invalid issued gets seen gets seen data isd busy invalid issued gets seen gets seen data yet imad busy invalid issued getx seen getx data yet ima busy invalid issued getx seen getx seen data imd busy invalid issued getx seen getx seen data yet mia modified issued putx seen putx yet iia modified issued putx seen putx saw gets getx reachable mia possible block states descriptions states listed table 2 note two types states cache block stable state transient state stable state one modi fied shared invalid recorded cache indicates state block latest outstanding transaction block started transient state shown table 2 recorded tbe indicates current state outstanding transaction block future tables refer state block understood state obtained returning transient state tbe outstanding transaction block else outstanding accessing cache obtain stable state blocks present cache assumed stable state transient state associated cache state shown table 2 assuming tag matches cache cache state busy implies tbe entry block state transient state mia iia represent transient states symbolically developed encoding transient states consists sequence two stable states initial intended zero pending states second state superscript denotes parts transaction address andor data still outstanding example processor block b state sends gets addressout queue sees data response yet seen gets would b state isa gets arrives state becomes events cache controller depend incoming messages events listed described table 3 note case replacements block b refers address victim block allowed cache controller actions listed table 4 cache controller behavior detailed table 5 entry contains list actions next state tuples current state block corresponds row 3 broadcast snooping cache controller events event description block b load readonly prefetch store readwrite prefetch mandatory replacement optional replacement gets getx putx gets getx putx data ld head mandatory queue readonly prefetch head optional queue st head mandatory queue readwrite prefetch head optional queue ldst head mandatory queue cache block available readwrite prefetch head optional queue cache block available occurs observe gets request global order occurs observe getx request global order occurs observe putx request global order occurs observe gets request another processor occurs observe getx request another processor occurs observe putx request another processor data block data network address ld head mandatory queue address readonly prefetch head optional queue address st head mandatory queue address readwrite prefetch head optional queue address victim block ldst head mandatory queue address victim block prefetch head optional queue address transaction head incoming address queue address data message head incoming data queue entry next event corresponds column entry specified actions performed state block changed specified new state next state listed action required shaded cases impossible memory node specification one advantages broadcast snooping protocols memory nodes quite simple memory nodes system like synapse 9 maintain state block memory node home order make decisions send data requestors state includes state block current owner block memory states listed table 6 events table 7 actions table 8 transitions table 9 22 specifying multicast snooping protocol section specify msi multicast snooping protocol methodology used describe broadcast snooping protocol multicast snooping requires less snoop bandwidth provides 4 broadcast snooping cache controller actions action description allocate tbe addressb c set cache tag equal tag block b deallocate tbe f issue gets insert message outgoing address queue typegets addressb sendern issue getxinsert message outgoing address queue typegetx addressb sendern h service ldst cache hit cache ld enqueue data ldst data queue incoming address queue incoming data queue l pop optional queue send data tbe memory send data cache memory issue putx insert message outgoing address queue typeputx addressb sendern q copy data cache tbe r send data cache requestor save data data field tbe service ld tbe pop mandatory queue enqueue data ldst data queue ld head mandatory queue block service ldst tbe pop mandatory queue ld enqueue data ldst data queue ldst head mandatory queue block w write data data field tbe cache send data tbe requestor z cannot handled right higher throughput address transactions thus enabling larger systems possible broadcast snooping 221 system model assumptions multicast snooping described bilir et al 5 incorporates features broadcast snooping directory protocols differs broadcast snooping coherence requests use totally ordered multicast address network instead broadcast network multicast masks predicted processors must always include processor directory block directories yet 5 broadcast snooping cache controller transitions cafi cafis cagi cagi sad ad mad mad hk l agim agim ad ad hk l hk l aqpm aqpm ia ia isad imad z z z z z z z z z z z z iisd sjisa sjima iimd isa ima z z z z z z z z z z z z uwdis vwdi mia iia z z z z z z z z z z z z isd imd z z z z z z z z z z z z suwdj svwdj state load rperaedfeotcnhly store rmeoepparplndaetdfciewoaetnmtcoraheirltnyet gpguetxs pguetxs getx data z z change cache state tag matches allowed incorrect gets mask incorrect omits current owner getx mask incorrect omits current owner current sharers scenario resolved simple directory detect mask mispredictions retry requests improved mask behalf requestors multicast snooping protocol described differs specified bilir et al couple significant ways first specify msi protocol instead mosi protocol second specify protocol lower detailed level third directory protocol retry requests incorrect masks behalf original requester multicast system shown figure 3 processor nodes structured like broadcast snooping protocol instead memory nodes though multicast snooping protocol directory nodes memory nodes extra protocol logic handling retries also shown figure 3 next two subsections specify behaviors processor directory components msi multicast snooping protocol 6 broadcast snooping memory controller states state description msa msd shared invalid modified modified seen getsputx seen data modified seen gets putx seen data 7 broadcast snooping memory controller events event description block b home gets putx requestor putx requestor owner data request arrives block whose home memory gets head incoming address queue getx head incoming address queue putx owner head incoming address queue putx nonowner head incoming address queue data head incoming data queue address transaction head incoming address queue address message head incoming data queue 8 broadcast snooping memory controller actions action description c z owner equal directory send data message requestor address queue data queue owner equal requestor write data memory delay transactions block 9 broadcast snooping memory controller transitions state wkmsa home gets pipsrueoqtwuxneesrtor requestor owner data directory node multicast address network point point data network address network fifo directory block state memory data network 3 multicast snooping system 222 network specification data network behaves identically broadcast snooping protocol address network behaves slightly differently name implies address network uses multicasting instead broadcasting thus transition address network consists taking message outgoing address queue node placing incoming address queues nodes specified multicast mask well requesting node memory node home block requested nodes already part mask address messages contain coherence request type gets getx putx requesting node id multicast mask block address retry count data messages contain block address sending node id destination node id data message type data nack data block retry count request triggered data message 223 cpu specification cpu behaves identically cpu broadcast snooping protocol 224 cache controller specification cache controllers behave much like broadcast snooping protocol except must deal retried nacked requests aggressive processing incoming requests added complexity leads additional states tbe fields protocol actions protocol transitions additional states multicast protocol specified due aggressive processing incoming requests instead buffering incoming requests z action transient states cache controller protocol ingests requests thereby moving new transient states example state imdi occurs processor state imd ingests incoming getx request another processor instead buffering notation signifies processor started waiting data go go immediately except cases forward progress issues require processor perform ld st relinquishing data discussed also three additional states necessary describe situations processor sees nack request seen yet four additional fields tbe forwardprogress forwardid retrycount forwardidre trycount forwardprogress bit set processor sees request satisfies head mandatory queue flag used determine processor must perform single load store cache line relinquishing block2 example data arrives state imdi processor service ld st block forwarding block forwardprogress set forwar field records node processor must send block cases example forwardid equals id node whose getx caused processor go imd imdi retry count records retry number recent message forwardidretrycount records retry count associated block forwarded node specified forwardid use tabledriven methodology used describe broadcast snooping protocol tables 10 11 12 13 specify states events actions transitions respectively processor nodes 225 directory node specification unlike broadcast snooping multicast snooping protocol requires simplified directory handle incorrect masks directory node addition incoming outgoing queues maintains state information block memory controls state information includes block state id current owner state bit vector encodes superset sharers state possible block states directory listed table 14 refer stable states others transient states initially blocks state set owner set memory bitvector set encode empty set sharers state notation processor nodes although state mxa refers situation directory receives data seen corresponding coherence request yet therefore know care whether putx data data processor downgrading response another processors gets directory node inspects incoming queues address data networks removes message head queue depending incoming message current block state directory may inject new message outgoing queue may change state block simplicity directory currently delays requests block putx downgrade outstanding3 2 another viable scheme would set bit processor observes address request request corresponds address head mandatory queue also legal set forwardprogress ldst gets head mandatory queue outstanding transaction yet seen address request however sequential consistency preserved scheme forwardprogress set data returns request address request matches address head mandatory queue 10 multicast snooping cache controller states state cache state description invalid shared modified isad busy invalid issued gets seen gets data yet imad busy invalid issued getx seen getx data yet smad busy shared issued getx seen getx data yet isa busy invalid issued gets seen gets seen data ima busy invalid issued getx seen getx seen data sma busy shared issued getx seen getx seen data isa busy invalid issued gets seen gets seen nack ima busy invalid issued getx seen getx seen nack sma busy shared issued getx seen getx seen nack mia modified issued putx seen putx yet iia modified issued putx seen putx saw gets getx isd busy invalid issued gets seen gets seen data yet isdi busy invalid issued gets seen gets seen data saw getx imd busy invalid issued getx seen getx seen data yet imds busy invalid issued getx seen getx seen data yet saw gets imdi busy invalid issued getx seen getx seen data yet saw getx imdsi busy invalid issued getx seen getx seen data yet saw gets saw getx smd busy shared issued getx seen getx seen data yet smds busy shared issued getx seen getx seen data yet saw gets directory events actions transitions listed tables 15 16 table 17 respectively action z delay transactions block relies fact directory delay address messages given block arbitrarily waiting data message conceptually one directory per block since one block per directory implementation would able delay transactions specific block note consecutive gets transactions block could coalesced 3 restriction maintains invariant one data message per block directory receive thus eliminating need buffers preserving sanity protocol developers 11 multicast snooping cache controller events event description block b load readonly prefetch store readwrite prefetch mandatory replacement optional replacement gets getx gets getx putx gets getx putx data data ld head mandatory queue readonly prefetch head optional queue st head mandatory queue readwrite prefetch head optional queue ldst head mandatory queue cache block available readwrite prefetch head optional queue cache block available occurs observe gets request global order occurs observe getx request global order occurs observe gets request global order retry count gets match retry count tbe occurs observe getx request global order retry count gets match retry count tbe occurs observe putx request global order occurs observe gets request another processor occurs observe getx request another processor occurs observe putx request another processor data block arrives data block arrives retry count data message match retrycount tbe address ld head mandatory queue address readonly prefetch head optional queue address st head mandatory queue address readwrite prefetch head optional queue address victim block ldst head mandatory queue address victim block prefetch head optional queue address transaction head incoming address queue address message head incoming data queue address message head incoming data queue 3 verification snooping protocols section present methodology proving specification sequentially consistent show methodology used prove multicast protocol satisfies sc method uses extension lamports logical clocks 16 timestamp load store operations performed protocol timestamps determine operations reordered witness sc intended 12 multicast snooping cache controller actions action description allocate tbe addressb forwardidnull retrycountzero forwardidretrycountzero wardprogress bitunset b set forwardprogress bit request head address queue satisfies request head mandatory queue c set cache tag equal tag block b deallocate tbe e record id requestor forwardid record retry number transaction forwardidretrycount f issue gets insert message outgoing address queue typegets addressb sendern retry countzero issue getx insert message outgoing address queue typegetx addressb sendern retrycountzero h service loadstore cache hit cache ld enqueue data ldst data queue incoming address queue incoming data queue l pop optional queue send data tbe memory send data cache memory data forwardidretrycount tbe processor indicated forwardid issue putx insert message outgoing address queue typeputx addressb sendern q copy data cache tbe r send data cache requestor save data data field tbe copy retry field message head incoming data queue retry field tbe set null set forwardidretrycountzero service ld tbe pop mandatory queue enqueue data ldst data queue ld head mandatory queue block v treat either h z optional cache hit cache hit pop mandatory queue w write data tbe cache x forwardprogress bit set service ld tbe pop mandatory queueand enqueue data ldst data queue send data tbe requestor z cannot handled right either wait discard request discard request optional queue copy retry field message head incoming address queue retry field tbe set null set forwardidretrycountzero service ldst tbe pop mandatory queue ld enqueue data ldst data queue ldst head mandatory queue block st store data tbe l optionally service ldst tbe forwardprogress bit set service ldst tbe pop mandatory queueand ld enqueue data ldst data queue 13 multicast snooping cache controller transitions caf caf cag cag isad isad imad imad hk l ag ag hk l hk l aqp aqp mia mia isad imad z l z z z z z l z l z z l z l z z bi isd imad sj stj tj tj isa isa isa isa sj stj tj tj ima ima ima ima sj stj tj tj sma sma sma sma isa ima z l z z z z z l z l z z l z l z z isa ima z l z z z z z l z l z z l z l z z uwdi mia iia l z l z z z z z z z z z isd isdi imd imds imdi imdsi z l z z z z z z z z z z z l z l z z z l z z z z z z z z z z z z z z z z z l z l z z z l z z z z imds imdi si smds imdi imdsi suwdj stjisa dji tj sxdji stjisa dji tj sgwdj stj dji tj sdom stj dji tj wdjs ima sdodj stj dji tj ima sdomd stj dji tj ji ima sgwdj stj djs tj sgom stj djs tj wdjs sma state load readwonrliyteprreefefetctch store mandatory replacement optional replacement gets getx gets mismatch getx mismatch putx gpuetxs getx data nack bi imd bi dii dis gwdi gwdi mdii dii aiisd aiimd aiimd aiimd aismd change state tag matches 14 multicast snooping memory controller states state description invalid processors invalid shared least one processor shared modified one processor modified rest invalid mxa modified seen getsputx seen data msd modified seen gets seen data mid modified seen putx seen data 15 multicast snooping memory controller events event description block b gets getsretry getsnack getxretry getxnack putx requestor requestor data gets successful mask head incoming address queue getx successful mask head incoming address queue gets unsuccessful mask head incoming queue room outgoing address queue retry gets unsuccessful mask head incoming queue room outgoing address queue retry getx unsuccessful mask head incoming queue room outgoing address queue retry getx unsuccessful mask head incoming queue room outgoing address queue retry putx owner head incoming address queue putx nonowner head incoming address queue data message head incoming data queue address transaction head incoming address queue address message head incoming data queue designer protocol logical clocks associated timestamping actions conceptual augmentation protocol specified using tablebased transition tables protocol note set possible operation traces protocol equals augmented protocol process developing timestamping scheme valuable debugging tool right exam ple early implementation multicast protocol include forwardprogress bit tbe upon receiving data getx request state imdi always satisfied op head mandatory queue forwarding data attempts timestamp op reveal need forward 16 multicast snooping memory controller actions action description c clear set sharers send data message requestor retrycount equal retrycount request address queue data queue owner equal requestor send nack requestor retrycount equal retrycount request q add owner set sharers r retry reissuing request reissuing directory improves multicast mask increments retry field transaction reached maximum number retries multicast mask set broadcast mask add requestor set sharers w write data memory x set owner equal directory z delay transactions block 17 multicast snooping memory controller transitions dsjs dmjm dsj cdmjm qsxjmsd mj wkmxa mxa qsxjs mj rj nj rj nj xji j msd mid z z z z wks wki state gets unsuccessful mask unsuccessful mask requestor owner requestor owner data progress bit roughly ensure op indeed timestamped appears occur time getx ops logical timestamp also respects program order brief methodology proving sequential consistency consists following steps augment system logical clocks associated actions assign timestamps ld st operations logical clocks purely conceptual devices introduced verification purposes never implemented hardware associate global history execution augmented protocol roughly history includes configuration node system states tbes cache contents logical clocks queues totally ordered sequence transactions delivered network memory operations serviced far program order along logical timestamps using invariants define notion legal global history invariants quite intuitive expressed using logical timestamps follows immediately definition legal global history corresponding execution sequentially consistent finally prove initial history system legal transition protocol maps legal global histories legal global histories entries labelled impossible protocol speci fication tables indeed impossible follows induction protocol sequentially consistent first step augmenting system logical clocks done hand hand development protocol thus valuable debugging tool second step straightforward also straightforward select core set invariants third step strong enough guarantee execution corresponding legal global history sequentially consistent final step proof methodology requires proof every transition protocol every invariant may necessitate addition invariants definition legal step proof diffi cult certainly tedious rest section describe first three steps process detail namely multicast protocol augmented logical clocks global history legal global history include examples cases covered final proof step appendix 31 augmenting system logical clocks section shall describe augment system specified earlier logical clocks actions increment clocks timestamp operations data timestamps make future defini tions global states legal global states simpler intuitive augmentations change behavior system originally specified 311 augmented system system augmented following counters initialized zero one counter global pulse number associated multicast address network two counters global local clocks associated processor node system one counter pulse number added data field forwardid field tbe one counter pulse number field added data message one counter global clock associated directory node system 18 processor clock actions action description set global clock equal pulse transaction handled set local clock zero increment local clock timestamp ldst set equal associated global local clock values pulse equal transaction pulse optionally treat h data message pulse equal tbe forwardid pulse data pulse equal pulse incoming data message first op mandatory queue ld block increment local clock timestamp ldst set equal associated global local clock values first op mandatory queue ldst block increment local clock timestamp ldst set equal associated global local clock values x forwardprogress bit set ie head mandatory queue ld block clock update set global timestamp ld equal pulse incoming data message set local clock value equal 1 set data message pulse equal transaction pulse z x allow ld st block 312 behavior augmented system augmented system clocks get updated timestamps pulses assigned operations data upon transitions protocol according following rules network new address transaction appended total order address transactions network causes global pulse number increment 1 new value pulse number associated new transaction processor tables describe global local clocks updated tbe counter used record timestamp request cannot satisfied data arrives data arrives owner sends data timestamp saved tbe directory briefly upon handling transaction directory updates clock equal global pulse transaction pulse attached data message set value directorys clock 32 global histories global history associated execution protocol 3tuple transseqconfigops trans records information sequence transactions requested date type transaction requester address mask retrynumber pulse possibly undefined status successful unsuccessful nack unde termined config records configuration nodes state per block cache contents queue contents tbes logical clock values ops records properties operations generated cpus date operations along address timestamp possibly undefined value rank program order 19 processor clock updates processorcache request see see see retry match retry mismatch gy gy isad imad isa ima isa ima mia iia gy gy gy gy isd isdi imd imds imdi imdsi zot zot zot zot current state ld mreadndowanrtloiytreyprrreefefpetlctachchement optional replacement getsx getsx getsx rmreattrcyh mismatch rmreattrcyh mismatch global history defined inductively sequence transitions execution initial global history transseq ops empty config processors state blocks empty queues tbes clocks initialized zero blocks directory state owner set directory list sharers empty incoming queues empty upon transition trans seq ops config updated manner consistent according actions transition 33 legal global configurations legal global histories several requirements global history transseqconfigops legal briefly follows first requirement sufficient imply sequential consistency remaining four requirements supply additional invariants useful building proof first requirement holds ops legal respect program order following hold 331 ops respects program order two operations o1 o2 o1 smaller timestamp o2 ops o1 must also appear o2 program order 332 every ld returns value recent st address timestamp order transseq legal describe type constraints transseq must satisfy introduce notion astate vectors astate vector corresponding transseq given block b records processor n whether transseq confers shared modified access block b processor n example system three processors transseq consists successful gets block b processor 1 followed unsuccessful getx block b processor 2 followed successful gets block b processor 3 corresponding astate block b sis constraints transseq require example getx block b successful mask include processors upon completion transaction prior getx may shared modified access b transseq consist transseq followed getx block b astate block b corresponding transseq mask getx contain processors whose entries equal precise definition legal transaction sequence included appendix ops legal respect transseq intuitively operations op ops op performed processor n global timestamp astate processor n logical time either op st config legal respect transseq involves several constraints since many components config example processor n state isad block b gets block b requested n timestamp greater n undefined transseq config legal respect ops blocks b nodes n following hold 333 n processor state block b one mia smad sma value block b ns cache equals recent st ops relative ns clock recent st relative ns clock mean st whose timestamp less equal ns clock 334 n processor block b one ns tbes value equals recent st ops relative p00 p pulse data field tbe 335 data block b ns incoming data queue value equals recent st ops relative datas timestamp ns current time 336 n directory block b block b n owner value equals recent st ops relative ns clock 34 properties legal global histories hard show global history system initially legal main task proof show following theorem 1 protocol transition takes system legal global history legal global history illustrate theorem 1 proved include appendix proof transition entry table 13 cache controller transitions maps legal global history transseqopsconfig new global history transseqopsconfig transseq legal 20 classification related work manual semiautomated automated complete method lazy caching2 dash memory model 12 lamport clocks 25 21 6 15 lamport clocks paper term rewriting 24 incomplete method rmo testing19 origin2000 coherence8 flash coherence 20 alpha 2126421364 3 hp runway testing11 18 4 related work focus papers specify prove complete protocol correct rather efforts focus describing many alternative protocols consistency models 1 10 large body literature subject formal protocol verification4 classified taxonomy along two independent axes automation completeness 23 distinguish verification methods based level automation support manual semiautomated automated manual methods involve humans read specification construct proofs semiautomated methods involve computer programs model checker theorem prover guided humans understand specification provide programs invariants lemmas prove automated methods take human loop involve computer program reads specification produces correctness proof completely automatically also distinguish techniques complete proof system implements particular consistency model incomplete proof coherence selected invariants table 20 provides summary taxonomy discuss column table separately 4 formal methods involve construction rigorous mathematical proofs correctness informal methods include techniques simulation random testing guarantee correctness consider formal methods review manual techniques lazy caching 2 one earliest examples formal specification verifica tion protocol lazy caching implemented sequential consistency authors use io automata formal system models provide manual proof lazy caching system implements sc use history variables proof similar manner use lamport clock timestamps proofs gibbons et al 12 provide framework verifying shared memory systems implement relaxed memory models method involves specifying system verified well operational definition memory model io automata proving system automaton implements model automaton example provide specification stanford dash memory system manually prove implements release consistency memory model tablebased specification methodology complementary could also used describe io automata previous papers 25 21 6 15 specified various shared memory systems directory bus protocols high level employed manual proofs using lamport clocks technique show systems implemented various memory models sc tso alpha paper latest effort demonstrates technique applied detailed tablebased specifications snooping protocols shen arvind 24 propose using term rewriting systems trss specify verify memory system protocols verification technique involves showing system consideration operational definition memory model expressed trss simulate proof technique similar io automata approach used gibbons et al 12 trss tablebased specification method used modular flexible fashion drawback trss lack visual clarity tablebased specification although current proofs manual mention possibility using model checker automate tedious parts proof semiautomated techniques park dill 19 provide executable specification sun rmo memory model written language murj model checker language similar typical imperative programming language unambiguous necessarily compact use specification check correctness small synchronization routines eiriksson mcmillan 8 describe methodology integrates design verification common state machine tables drive model checker generators simulators documentation protocol specification tables describe designed consumed automated generators rather humans describe format text specifications generated tables use smv model checker accepts specifica tions temporal logic prove coherence protocol used sgi origin 2000 however system verified one cache block sufficient prove coherence consistency pong et al 22 verify memory system sun s3mp multiprocessor using murj ssm symbolic state model model checkers verified system one cache block thus cannot verify whether system satisfies memory model park dill 20 express definition memory model system verified specification language use aggregation map system specification model specification similar use trss shen arvind24 io automata gibbons et al 12 example specify stanford flash protocol language pvs theorem prover language typed highorder logic use aggregation technique prove delayed mode flash memory system sequentially consistent akhiani et al 3 summarize experience using tla form temporal logic combination manual proofs tla model checker tlc specify verify compaq alpha 21264 21364 memory system protocols although find bug would caught simulation model checking manual proofs quite large small portion could finished even 4 people 7 personmonths effort tla specifications complete formal nearly two thousand lines long nalumasu et al 11 18 propose extension colliers archtest suite provides collection programs test certain properties memory model extension creates effect infinitely long test programs thus checking possible interleavings test programs abstracting test programs nondeterministic finite automata drive formal specifications system verified automata implementations specified verilog vis symbolic model checker used verify various invariants satisfied system driven automata technique useful practice applied commercial systems hp pa8000 runway bus protocol however incomplete invariants tested imply sc necessary sufficient automated techniques henzinger et al 14 provide completely automated proofs lazy certain snoopy cache coherence protocol using mocha model checker protocol specifications system expressed language similar typical imperative programming language proof requirements expressed temporal logic augmented specification finite observer reorder protocol transactions order produce witness ordering satisfies definition memory model provide observers two protocols specify paper however general problem verifying sequential consistency undecidable finite observers exist protocols specify paper protocols used modern highperformance sharedmemory multiprocessors best knowledge published examples completely automated proof correctness system specified low level abstraction conclusions paper developed specification methodology documents specifies cache coherence protocol eight tables states events actions transitions cache memory controllers used methodology specify detailed lowlevel threestate broadcast snooping protocol unordered data network ordered address network allows arbitrary skew also presented detailed lowlevel specification multicast snooping protocol 5 shown utility tablebased specification methodology lastly demonstrated technique verification multicast snooping protocol sketch manual proof specification satisfies sequentially consistent memory model acknowledgments work supported part national science foundation grants eia9971256 mips 9625558 mip9225097 ccr 9257241 cda9623632 wisconsin romnes fellowship donations sun microsystems intel corporation members wisconsin multifacet project contributed significantly improving protocols protocol specification model presented paper especially anastassia ailamaki ross dickson charles fischer carl mauer r designing memory consistency models sharedmemory multiprocessors parallel computer architecture hardwaresoftware approach memory consistency models sharedmemory multiprocessors computer architecture quantitative approach tr cache coherence protocols evaluation using multiprocessor simulation model class compatible cache consistency protocols support ieee futurebus proving sequential consistency highperformance shared memories extended abstract lazy caching designing memory consistency models sharedmemory multiprocessors executable specification analyzer verifier rmo relaxed memory order verification flash cache coherence protocol aggregation distributed transactions memory consistency models sharedmemory multiprocessors verification techniques cache coherence protocols lamport clocks using myampersandldquotest modelcheckingmyampersandrdquo verify runwaypa8000 memory model design verification s3mp cachecoherent sharedmemory system computer architecture 2nd ed multicast snooping systemlevel specification framework io architectures formal automatic verification cache coherence multiprocessors relaxed memory models time clocks ordering events distributed system introduction automata theory languages computation verifying multiprocessor cache controller using random test generation cache coherence verification tla test modelchecking approach verification formal memory models multiprocessors verifying sequential consistency sharedmemory multiprocessor systems using formal verificationanalysis methods critical path system design origin system design methodology experience using lamport clocks reason relaxed memory models ctr collin mccurdy charles fischer using pin memory reference generator multiprocessor simulation acm sigarch computer architecture news v33 n5 december 2005 collin mccurdy charles fischer localizing directory coherence protocol proceedings 3rd workshop memory performance issues conjunction 31st international symposium computer architecture p2329 june 2020 2004 munich germany ahmed louri avinash karanth kodi optical interconnection network modified snooping protocol design largescale symmetric multiprocessors smps ieee transactions parallel distributed systems v15 n12 p10931104 december 2004 milo k martin daniel j sorin bradford beckmann michael r marty min xu alaa r alameldeen kevin e moore mark hill david wood multifacets general executiondriven multiprocessor simulator gems toolset acm sigarch computer architecture news v33 n4 november 2005 felix garciacarballeira jesus carretero alejandro calderon jose perez jose garcia adaptive cache coherence protocol specification parallel inputoutput systems ieee transactions parallel distributed systems v15 n6 p533545 june 2004 milo k martin pacia j harper daniel j sorin mark hill david wood using destinationset prediction improve latencybandwidth tradeoff sharedmemory multiprocessors acm sigarch computer architecture news v31 n2 may michael r marty mark hill coherence ordering ringbased chip multiprocessors proceedings 39th annual ieeeacm international symposium microarchitecture p309320 december 0913 2006
complete calculus multialgebraic functional semantics nondeterminism current algebraic models nondeterminism focus notion possibility rather necessity consequently equate nondeterministic terms one would intuitively consider equal furthermore existing models nondeterminism depart radically standard models equational specifications deterministic operators one would prefer specification language nondeterministic operators based extension standard model concepts preferably way reasoning system possibly nondeterministic operators becomes standard equational one whenever restricted deterministic operatorsthe objective minimize departure standard frameworks article define specification language nondeterministic operators multialgebraic semantics first complete reasoning system specifications introduced also define transformation specifications nondeterministic operators derived specifications deterministic ones obtaining computational semantics nondeterministic specification adopting standard semantics derived specification semantics original one semantics turns refinement multialgebra semantics calculus shown sound complete also respect new semantics b introduction notion nondeterminism arises naturally describing concurrent systems various approaches theory specification systems instance ccs milner 1980 csp hoare 1985 process algebras bergstra 1986 event structures winskel 1988 include phenomenon nondeterminism nondeterminism also natural concept describing sequential programs either means indicating dont care attitude among number computational paths actually uti lized particular computation eg dijkstra 1976 means increasing level abstraction meldal 1989 walicki 1994a present work proceeds theory algebraic specifications ehrig 1985 wirsing 1990 generalizes applied describing nondeterministic operations main concern make extension nonintrusive ie change existing framework particular reduces standard deterministic theory deterministic operations present specification terms satisfiability allowing nondeterminism quite distinct underspecification latter though admitting distinct models still insists function always returning specific value given particular list arguments case nondeterministic operators longer true 1 also nondeterminism turns useful abstraction tool whenever gratefully acknowledge financial support received norwegian research council 1 interest clarity shall let term function denote deterministic operator term operation denote nondeterministic well deterministic operators hidden state components system description methodologically technically inaccessible particular level abstraction illustrate section 6 also walicki 1994a underspecification provide equally powerful abstraction mechanism basic concept classical algebraic specifications notion function classical specifications describe programs viewed abstractly inputoutput functions particular input uniquely determines output value resulting evaluating program 2 hold nondeterministic programs input program uniquely determine resultant output since nondeterministic program cannot modeled inputoutput function set approach hesselink 1988 kaplan 1988 kapur 1980 maibaum 1977 subrahmanyam 1981 generalizes standard algebraic notion programs functions regards nondeterministic programs functions multialgebra program denotes function instead returning single values returns sets values particular nondeterministic operator f argument term fa denotes set values possibly returned f thus set approach nondeterministic specification programs modeled structures describing possible behaviors sort let settt denote operator makes nondeterministic choice among elements set telements instance 0 1 may return either values 0 1 need return value every application set approach semantics term 0 1 constant term 0 1 denotes set 0 1 possible results consequently equality 0 10 1 hold since sides interpreted setvalued constant consider evaluation program making use equality instance expression 0 10 1 5 else 6 fi according intuition result evaluating expression could either 5 6 depending whether two applications 0 1 returned value according set semantics equality result always 5 term 0 1 denotes one setvalued constant equality 0 10 1 interpreted test whether set 0 1 equals set 0 1 always true hesselink 1988 kaplan 1988 kapur 1980 maibaum 1977 subrahmanyam 1981 thus set semantic interpretation equality implies possibility two terms returning result guarantee results actually produced leads particular difficulties treating properly notions example observability hennessy 1980 nipkow 1987 implementation qian 1993 equality view necessary equality must hold every evaluation program specification correspond set equality identity 1element sets thus simple formula ts considered true multistructure iff interpreted one set addition one element indicate modified interpretation use symbol instead usual identity besides problems construct ing adequate algebraic model set approach originally forced one consider even simple equa tional specifications full first order theories subrahmanyam 1981 kapur 1980 course led reasoning systems whose efficiency observation extends reactive systems well see kahn 1974 simplicity could match existing systems equational reasoning see eg odonell 1977 dershowitz 1990 references difficulty set approach sketched inability distinguish equivalence terms equivalence application terms distinction consequence deterministic case every term necessarily identifies single value evaluating term always yield result hand distinct applications nondeterministic operator typically yield different results distinction terms operations applications merely technical reflection distinction programs computations distinction whose relevance became obvious advent parallel nondeterministic computing writing specifications primarily interested constraints computations importance constraints acceptable programs secondary concern arising fact program identifies set possible computations interested programs pieces text rather happens evaluated specification serves purpose abstractly describing legal computations contrast algebras possibilities represented set approach offer algebras actual computations particular computation abstract computation sense algebra inputoutput functions way preserve basics classical algebraic theory believe view relevant actual use paper presents function oriented view refines notion equality multialgebraic semantics result nondeterministic operator considered single rather set value namely result particular application distinct occurrences particular term denote single value necessarily one equality 0 10 1 longer holds instead restore meaning equality necessary relation must hold particular evaluation program new semantics nondeterminism reflected existence distinct computations realizing distinct possibilities nondeterministic operators simple facts x result applying 0 1 x0 x1 expressible provable sys tem natural interpretation computational model 3 semantics also satisfies secondary concern specification formalism deals nondeterminism sensible intuitive way also preserves notions results standard algebraic approaches deterministic constructs important two reasons 1 formalism behaves expected ways within usual domains formal specifications thus specifier need exposed new possibly exotic semantic concepts long stays within deterministic domain discourse 2 existing tool base created cater standard equationally defined algebras dershowitz 1990 odonell 1977 retained 3 may seem trivial fact hard enough require introduction full first order logic early deduction systems kapur 1980 subrahmanyam 1981 classes structures proposed semantics nondeterminism allow models disjunctive equations valid satisfied making additional semantic restrictions humann 1990humann 1993maibaum 1977mosses 1989a extending tool base cover nondeterminism well one hope reusing much existing software time show replacing notion set equality element equality two semantics compatible multialgebraic semantics seen convenient abstraction function oriented one calculus introduced paper sound complete respect semantics thus allows one reason abstract level terms thought sets possible results main results present modified view equality multialgebraic semantics nondeterminism calculus neq sound complete respect multialgebraic semantics behaves identically standard equational calculus birkhoff 1935 deterministic case new functional semantics nondeterministic specifications refines multialgebraic one soundness completeness neq respect new semantics transformation procedure allowing one interpret specifications nondeterministic operators underspecified deterministic functions structure paper section 2 introduce specification language l neq provides nondeterministic operators section 3 class multimodels specification l neq defined section 4 show specifications nondeterministic operators l neq transformed specifications deterministic ones translating language l deq usual language deterministic conditional equations extended disjunction define loose functional semantics original specification class standard models derived l deq specification subsection 43 compares two semantics section 5 introduces calculus neq discusses features states soundness completeness neq respect multialgebraic functional semantics section 6 contains example specification access types section 7 summarizes results comments briefly lated work proofs omitted paper given full walicki 1993a except soundness completeness theorems proved appendix 2 writing specifications nondeterministic operators section present specification language l neq user expected write specifications also explain informally intended semantics l neq discuss relation interpretation terms applications possibly nondeterministic operations sets possible results 21 syntactic preliminaries specification l neq pair signature pair sets f sorts operation symbols f arguments result sorts exists denumerable set v variables every sort syntactic entity term formula set formulae x vx denote set variables x letters end latin alphabet x z used variables set terms signature variable set x denoted w x always assume every sort set ground terms sort w empty 4 p set clauses clause c set literals ie ordering multiplicity literals matter written 1 n possibly within clause interpreted disjunction literals sometimes write explicitly 1 n usually use uppercase latin letters single clauses uppercase greek letters sets clauses lowercase latin letters e literals comma indicates concatenation set union clauses semicolon collection eg c c 1 c n 1 literal identified atomic clause brevity c denotes conjunction two clauses c denotes clause c 1 clause c 1 c conjunction c p c denotes set clauses p extended clause c literal atomic clause either equation ts inclusion ts inequality ts terms sw x equations inclusions called positive literals atoms inequalities negative literals 5 use negaton inclusion explained inequalities play role complement equalities inclusions clause pr thought conditional formula ts p r stating p included r whenever necessarily distinct clause exactly one positive literal called horn formula horn formula negative literals simple formula variables occurring clause implicitly universally quantified whole clause clause satisfied every assignment variables least one literals true specification sp l neq sp restriction l neq w v 22 l neq specifications informal semantics multialgebraic semantics humann 1993 kapur 1980 interprets specifications form power structures nondeterministic operations correspond setvalued functions means ground term interpreted set possibilities denotes set possible results corresponding operation hand want formulae express necessary ie facts hold every evaluation program specification think occurrence term l neq referring particular arbitrary application operation returns one possible results operation thus two occurrences syntactically identical terms refer two potentially dis tinct applications operation syntactic identity terms 4 address problem empty sorts present calculus works assumption sorts empty usually give signatures least one constant every sort ways restricting signatures goguen 1981 huet 1980 ensuring nonemptiness goguen 1981 goguen 1987 used instead seems also flexible approach generalizes calculus introducing explicit variables goguen 1981 goguen 1982 ehrig 1985 adapted framework 5 equivalent original formulation syntax following results could use sequents b atoms equalities corresponding atoms b equalities inclusions formulation complicates calculus proofs choose present syntax clauses general imply semantic iden tity every two syntactic occurrences term thought possibly distinct applications nondeterministic terms means may denote two distinct values distinction deterministic nondeterministic terms captured multialgebraic semantics modified notion equality interpret according discussion section 1 necessary equality although multialgebras interpret terms sets possible results hence two terms denoting set equal sets make clause tt hold two applications return result ie deterministic equivalence relation terms tt valid exactly deterministic terms denoted sp x variables always interpreted deterministically occurrences particular variable clause denote value see definition 33 discussion consequences allowing variables interpreted nondeterministically see walicki 1994awalicki 1994b consider loss referential transparency implied reinterpretation equality intrinsic feature nondeterminism eg qian 1993 consequence proof system allows restricted form substitutivity observe operators arguments theories deterministic operations always denote constants need constant l neq operator c distinct meanings depending whether determinacy axiom cc valid follows specification c denotes usual deterministic constant c corresponds possibly unbounded nondeterministic choice set elements sort together inclusion limited negation expressed allows us utilize nondeterminism defining reasoning subsort hierarchies term level way reminiscent unified algebras 1989a interpreted multialgebras st means possible results contained set possible results intuition preserved interpreted particular applications whole sets possible results requirement result returned arbitrary application also returned application subtle difference set interpretation consider user defined choice operation two terms 0 1 0 1 2 one would expect set possible results former included set possible results latter validity clause 0 1 0 1 2 depend specification unless inclusion axiom consequence axioms valid since evaluation 0 1 require evaluation 0 1 2 acceptable implementation would former always returning value 0 latter could always return 2 thus necessarily every evaluation term 0 1 exists evaluation 0 returning value insisted fairness requirement computation particular term evaluated sufficiently often possible results would realized st would coincide subset relation result sets set approach explore issue fair nondeterminism paper interpretation contradict facts like 0 1 0 1 inclusion always valid application 0 1 left application 0 1 right namely one two return result besides necessity aspect possibility present l neq use clauses disjunctive lae specifications following section introduce multialgebraic semantics section 4 refined function oriented semantics expresses directly notion particular applications operations means oracle arguments 3 multialgebraic semantics define semantics l neq specifications using multistructures definitions similar used authors pickett 1967 hesselink 1988 humann 1990 humann 1993 kapur 1980 nipkow 1986 bauer 1985 except notion equality definition 31 multistructures let sp l neq specification sp multistructure 1 carrier ssorted set 2 every f 1 n f corresponding function operations applied sets refer unique pointwise extensions let mstrsp denote class spmultistructures distinguished term structure definition 32 term structure term multistructure w specification sp defined 1 ss w set ground terms sort 2 f 1 n f w definition 33 let spmultistructure b x assignment set variables x psatisfies literal b iff st bs bt st bs st bs bt ab iff b 1element set psatisfies clause c p c iff b psatisfies least one literal c spmultimodel spmultistructure satisfies axioms sp mmodsp denotes class multimodels sp let denote standard satisfiability relation annotate p indicate particular definition satisfiability used notice although different occurrences given nondeterministic term denote one set interpretation make tt false set contains one element reason using empty intersection set inequality interpretation negative literals using elementwise equality interpretation since avoid set equality positive sense natural negative form seems one chosen interpretation denotes necessary equality denotes necessary inequality ie valid never return value deterministic terms st st ie deterministic negative literals correspond exactly equational deterministic conditions initiality term multistructure mstrsp depends definition multi homomorphism known fact humann 1993 mosses 1989a general case one expect exis tence initial multimodels humann 1993 humann shown multimodels may exist even specification language restricted simple formulae therefore allow general clauses specifications concentrate whole class multimodels specification discussion structure class multistructures lack initiality results reader referred humann 1993 walicki 1993a present context significance term structure expressed lemma 34 spmultistructure every set variables x assignment b xm exists unique function b w observe consequence definition multistructures operations mono tonic ie bsbt bfsbft 6 according definition 33 variables assigned single elements carrier always denote individual values means instance clause st equivalent xs xt considering x individual set x may understood familiar xt thus may treat notation abbreviation elaborate formulae two negated membership relations one new variable occurring rest clause special role literals form xt xv play call bindings simple example formalism important role bindings consider following specification example 35 nat f 0 nat zero nat nat successor natnat nat binary nondeterministic choice 1 00 2 sxsx 3 10 usual abbreviate n 0 n 4 010 011 6 reason calling multistructures distinguishing power structures operations go power sets power sets rather sets power sets operations need monotonic first two axioms make zero successor deterministic third makes 0 distinct 1 thus serves limited form negation writing clause 4 one could intended require application 01 returns either 0 1 according interpretation terms arbitrary applications operation actually states arbitrary two applications term 01 returning values n 1 n 2 respectively n 1 0 n 2 1 since arbitrary pairs applications ef fect would either every application 01 returns 0 every application returns 1 ie choice really nondeterministic merely underspecified get desired meaning need state axiom 4 holds occurrences 01 refer application means binding particular application operation could obtained introducing additional constructs let c01 prefer keep language compact possible desired effect obtained 1 observing semantics l neq requires assign single values variables ie within particular clause variable denote one specific value 2 making identification particular term application variable negative literal variable may used clause referring value returned particular application example 35b replace axiom 4 example 35 axiom 4 states given value x x either impossible result 01 x 0 1 viewing 01 set possible results represents conditional x1 terms application operations axiom indicates whenever x result returned application 01 equals 0 1 general choice natural nondeterministic operator unless indicated otherwise assume takes nonempty finite set argument satisfies following axioms returns 1element set adds adds element set choice notice last formula operational interpretation clause evaluation choice set adds amounts either taking evaluating choice set 7 order elaborate unnecessary details assume following examples specifications needed sorts finite sets set finite sequences seq operations given 4 deriving deterministic specifications section define alternative semantics specifications model specification particular computation precisely standard deterministic algebra nondeterministic operation interpreted set deterministic functions describe transformation nondeterministic l neq specification underspecified determin istic specification equational language l deq transformation preserves validity l neq clauses sense model class derived specification satisfies clause c iff class multimodels satisfies c transformation goes via intermediary language l l l neq without inclusion existentially quantified equations l deq simply l neq equality inequality primitives semantics l neq specification sp defined alternatively terms semantics l deq transform sp advantage semantics nondeterministic specifications given terms standard algebraic constructions also consider validitypreserving refinement specification language transition l neq l deq together semantics latter plausible model observable nondeterminism results presence invisible parameters 41 transforming l neq specifications deterministic specifications following l neq syntactic entity x signature term equation inclusion clause let x denote l transform x l deq transform x main step transforming l neq specifications trans formation nondeterministic operators underspecified deterministic functions done equipping every operator symbol additional argument called index 8 index arguments l l deq term identifies application l neq operators term refers thus first step extend l neq signature new index sort modify profiles operations definition 41 index sort given l neq signature f derived l signature pair f new sort every f 1 i1 f converted corresponding f 1 i1 fi 9 note index operations also ones supposed deterministic 8 terms intended interpretation indices correspond oracles level derived deterministic specification however merely additional arguments operations therefore prefer semantically neutral word index 9 walicki 1993a construction introduced one also added new constant l sort ensure sort empty extension also important consequences existence initialquasi initial semantics studied merely assume sorts empty ifthenelse function index sorts necessary one special case proof soundness distinguishes deterministic operations nondeterministic ones l neq specification validity simple equations form f xfx saying every application term fx evaluates value every application term f x l terms translates assertion index argument f affect result application thus corresponding distinct variables since index value represents particular application operation arbitrary application represented arbitrary index value different occurrences terms indexed distinct index variables notational convenience shall often omit indices deterministic terms transformation equalities inequalities general conform schema inclusion lr mean every evaluation l exists evaluation r returning result terms indices amounts existence every index l index j r li rj evaluate result transform l neq axioms according definition 42 l transform c given l neq obtained follows 1 introduce distinct index variables nonvariable subterms c obtaining 1 2 every inclusion l r c every index variable introduced r add existential quantifier front clause obtained 1 3 finally symbols replaced instance let j axiom choice example x adds xy x l transform j note consequence second point definition existential quantifiers refer index variables positive literals c definition 43 sp obtained sp extending definition 41 taking c c sp deterministic specification clauses may contain existential quantifiers obtain equational specification l deq skolemize l clauses existential quantifiers occur introduce new indexing skolem function every existential quantifier l deq clause corresponding clause j new skolem function skolem functions simplified removing redundant arguments eg depend 2 add deterministic x determined similarly variables occurring unique bindings eliminated substitution constructing c simplifications bearing possible implementations concerned definition 44 derived specification given l neq specification sps f derived l deq specification sp f skolemized version c indexing function 42 computations sp sp ordinary first order theories classes structures strsp defined usual way eg chang 1977 models structures satisfy axioms definition model classes modsp resp modsp usual one standard argument concerning preservation satisfiability process skolemization chang 1977 two model classes equal sense every modsp turned modsp supplying interpretation indexing functions every mmodsp turned modsp forgetting interpretation course main concern class modsp since sp close equational specification get definition 45 l neq specification sp class sp computational structures cstrsp defined class strsp loose semantics sp compsp defined class modsp 10 since mmodsp corresponds particular choice functions satisfying sp call members compsp computations sp like mmodsp general possess initial object level l deq specifications one cannot hope find initial algebra appropriate interpretation general clauses reason well illustrated meseguer meseguer 1990 meseguer 1992 wirsing wirsing 1989 consequence fact disjunctive equations none alternatives maximal valid models admit initial models one however obtain initial algebras banning disjunctions ie allowing horn formulae done humann 1993 mosses 1989a instead looking initial algebras exclusively therefore consider class structures sat isfying axioms specification proponents initial semantics may find partial satisfaction proposals generalizing notion quasiinitiality goguen 1988 kaplan 1987 volger 1989a volger 1989b wolter 1992 quasiinitiality yields multiple non 10 term computational structure confused computation structure used instance wirsing 1989 latter synonym reachable structure computational structures defined new kinds models nondeterminism isomorphic structures nevertheless conforms dictum junk confusion cited main justification initial seman tics results wolter 1992 directly applicable level computations equa tional specification gentzen formulae sp admits quasiinitial semantics mild restriction specifications allows us lift quasi initial semantics multialgebra level walicki 1993a order relate classes compsp mmodsp define means computational structure satisfy l neq sp formula least two alternatives record definition 46 let c l neq sp clause mcstrsp satisfies c possibility tighten requirements satisfiability inclusions recall existential quantifiers c bound index variables introduced inclusions instead considering inclusion st satisfied index value exists index value making two equal may require index must function index denotable indexing functions translated specification definition 47 let c l neq sp clause 1 z existentially quantified variables c mcstrsp c satisfies c c c iff exist l deq index terms 1 z mc c existential quantifiers removed denotes standard satisfaction assignments elements variables clause notice 1 z arbitrary terms also single variables possibly occurring c illustrate difference two definitions let two constants sort let indexing function introduced translated specification sp 9 let mcstrsp follows b1 consider inclusion obviously j sitj 2 si ts n n requirement existence indexing terms 1 z rather existence elements carrier make clause c valid exists corresponding l deq clause index terms 1 z valid explains relevance c satisfiability validity l deq clause c imply validity corresponding l neq clause c former examined using standard techniques course one still left problem finding appropriate index terms obviously given two definitions equivalent c c implies c vice versa however interesting consequence completeness theorem notions validity coincide class computations corollary 53 43 compsp mmodsp introduced computational models opinion offer operationally intuitive interpretation l neq specifications multialgebras latter seen convenient abstraction computations intermediate level external specification internal semantics lemma 48 define operator p cstrspmstrsp 1 2 f pm every ff mcompsp pmmmodsp p operator 11 abstracts away information indices maps operations respective result sets lemma every computation determines multimodel many computations multimodel definition 49 relation defined compsp ab iff papb equivalence relation equivalence class corresponds classification elements possible computations program specification modeled multialgebra pa easy see general equivalence class possess initial terminal elements nonexistence computations hardly surprising may even say opposite would desirable one expect find best generic initial computation nondeterministic program since computations realize incommensurable possibilities program thus opposite transition mmodsp compsp cannot defined uniquely unless choose arbitrary member equivalence class shown mmodsp contains redundant models ie models computational interpretation every multimodel obtained applying p computation lemma 410 mmmodsp acompsp pam following lemma easy consequence definition 48 poperator lemma 411 acstrsp clause c c iff pa p c together previous lemmas leads lemma 412 clause c compsp c iff mmodsp p c consequence completeness theorems reported next section able strengthen equivalence comp mmod corollary 53 11 easily extended functor look compsp mmodsp categories 5 l neq calculus neq specifications nondeterministic operators rules neq r1 xy xy b xt xt x yv x x x x x righthand side c cut either r5 x one x c x denotes c substituted x comments regarding rules may order relation equality inclusion since variables x individuals two rules correspond respectively xy xy x xt also capture fact partial equivalence relation reflexive variables see per paramodulation rule allowing replacement deterministic terms case holds second assumption particular allows derivation standard substitution rule substituted terms deterministic prevents substitution nondeterministic terms variables r3 allows specialization clause substituting term another term included restriction occurrences substituted dont occur righthand side c needed prevent instance unsound conclusion p premises pt st implies negation st st r4 allows us resolve complementary literals r5 allows one weaken premise clause extending additional disjuncts r6 eliminates redundant bindings namely bind application term occurring rest clause write p c indicate c provable p calculus neq following derived rules allow us rename variables clause substitute deterministic terms variables introduce bindings ie exchange several occurrences applications term one unique application x z v w x per xx b tt proof r1a resp r1b r6 x proof x x x x proof z c z z x z x z x x righthand side proof x intr rule allows binding several applications occurrences term instance conclude h g g fg hx xfg x g bindings reflect computational interpretation operations returning unique results crucial completeness neq following example illustrates humann 1993 walicki 1993a example 51 let sp f f b g f 1 aa 2 bb 3 ag 4 xhx x 5 hx xfx mmodsp p gfg semantic reasoning effect goes follows mmmodsp mm 4 5 mg f monoton bindings elim rule inclusion would derivable r3 obtain xfx r5 gives xg xfx since gg derivable cannot substitute g x reasoning proceed consider elementwise transitions derivation neq proceeds follows intr example illustrates significance making explicit distinction operations applications since distinction plays crucial role semantic level main new result concerning two semantics calculus theorem 52 every l neq specification sp clause cl neq sp soundness proven induction length proof c completeness 1 proven directly via derived deterministic semantics completeness 2 corollary 53 every l neq specification sp clause cl neq compsp c c iff compsp implications left right easy consequences definitions satisfiability completeness theorems yield equivalence mmodsp p c iff compsp c c implies c perhaps surprising view fact compsp closed subalgebras thus computations satisfy clause c ie existentially quantified version reachable computations satisfy c particular initial covering class compsp ie computations initial respective component class satisfy c means index terms whose interpretation quasi initial object 0 gives 0 c c used validate c computations exists unique homomorphism 0 corollary 53 significantly strengthens argument obvious difficulty applying argument negative formulae necessarily preserved ho momorphisms lyndon 1959 importantly reasoning guarantee existential quantifier c exist one index term terms may different different components compsp corollary implies computations multimodels result set operation included result set operation computing really depends computing exists index term di sitdi corollary shows also compsp mmodsp satisfy l neq sp formulae hence former constitutes refinement mmodsp far language concerned contains detailed description operations using new indexing functions present l neq 6 example example formalism give specification access data type nondeterminism provides invaluable abstraction mechanism releases specifier burden describing exactly mechanism allocating new pointers leads abstract specification also avoids problems distinguishing structures supposed observational behavior motivation example comes meldal 1987 meldal 1989 first illustrate problems arising case usual deterministic underspecification show avoided introducing nondeterministic operations following sorts operations sort accessed values sort p access values pointers sort c collection access values p collections introduced hoare wirth hoare 1973 access value serves index set referenced type changes referenced object well allocation new objects considered changes collection way quite similar treatment arrays operation init produces new empty collection store takes collection access value object allocates object given access value returning new collection next gives access value next object allocated current collection access accesses value given access value finally operation new allocates new object given access value collection returns extended collection simplify example ignore things like nil pointers accessed value deallocation problems limited storage space first give deterministic underspecified version illustrate need sophisticated abstraction mechanism mimic far possible expressiveness l neq allow use equalities inequalities disjunctions dpointer p c error value next c p new c c x p b v p 1 ststc x b ststc b x xy 2 ststc x acc 3 accstc x accc x xy 4 accstc x x 5 accinit x next 6 accc nextc new 7 newc stc nextc first axiom tells order objects allocated inessential long different access values 2 makes last st operation access value x override previous ones two ax ioms equivalent conditional ststc x b xy stc b else ststc b x accessing value x goes along nesting st access value equal x found init collection reached latter case returned indicating x allocated axiom 6 ensures next return allocated value axiom 7 defines new operation expected way since operation fully defined terms st next might considered merely convenient abbreviation however natural assume operation actually interested operation next needed define observe new return pointer merely modifies collection general assumption algebraic specifications operations return result one sort hence one wanted define one operation modifies collection returns new pointer one would define additional sort corresponding cartesian product c p appropriate projection functions 1 2 although might closer programmers intuition would unnecessarily complicate example introducing operation alloc c c p would require instance reformulation axiom 6 acc c cluttering example projection functions refrain making complication operations new next play role projections one may easily introduce sort c p operation alloc later stage development implementation specification dpointer seems underspecification dpointer puts reasonable restrictions possible implementations particular axiom 1 makes collections abstract sequence new objects allocated essential however consider following two expressions ab constant accessed values 1 newnewc b ststc nextc nextstc nextc b 2 newnewc b ststc nextc b nextstc nextc b former stores first next access value b next latter stores first b simple equational reasoning yields 1a acc newnewc b nextc 2a acc newnewc b nextc ab implies antecedent following implication follows nextcnextc congruence axiom newnewc bnewnewc b illustrate problem may rephrase terms imperative program assume pascallike language command allocatevar coll c v return p call allocatec v three things 1 returns access value new object col lection c 2 stores value v object 3 changes c appropriately may thought operation virtue 2 3 implements new 1 z c 2 z c program variable z used capture state collection allocations occur terms operations specification might formulate 1 z c 2 z c b nextc c stc b x nextc c stc x two sequences commands equivalent purposes yet executing sequence 1 xnextz case execution 2 yields xnextstz nextz b problem function next essentially counts number objects stored identifying uniquely access value place sequence allocations language deterministic operations expressive forcing us consider details beyond necessary purposes problem might avoided designing specific storage structures would suitable definition programming language semantics rather specification alternatively one might introduce abstract notion observational equivalence hupbach 1983 sannella 1985 eg respect operation acc order consider two programs equivalent example illustrates general problem abstraction lowlevel details irrelevant actual level description underspecification allow general abstraction conceptually invisible entities hidden state timing interaction human case forces one distinguish two expressions internal structure arguments order allocating pointers may correspond hidden state discuss problem detail walicki 1994a simple way avoid identifying different occurrences nextz referring always unique value ie consider nondeterministic operation change specification dpointer would last axiom pointer dpointer stc x astc x new 7 newc stc nextc acc st deterministic since next become nondeterministic new operation becomes nondeterministic also longer identity nextcnextc equivalence per nextcnextc 12 defined accessed value reasonable admit axiom using axioms 4 6 obtain intr acc st c x next st c x x next st c x acc st c x x x next st c x acc st c x x acc st c x x x next st using fact get two clauses 1b 2b lead following conclusion assuming ab 12 st abbreviation two inclusions st ts b x next c acc st st c x next st c x b x b x next c acc st st c x next st c x b x acc st st c x b next st c x b x x next c acc new st last line obtained two applications r3 axiom 7 however imply newnewc b newnewc b observe also conclusion follows identified bindings xnextc 1b 2b x conclusion supposed returned nextc called stc nextc stc nextc b thus cannot establish two collections disjoint distinct cannot prove identical either ie pointer 0 newnewc b newnewc b even simpler equality stc nextc stc nextc would strong follow pointer axioms since two applications nextc may allocate different access values adding axiom newnewc b newnewc b would make two collections equivalent sense whatever collection resulting newnewc b could also obtained newnewc b vice versa would newnewc b newnewc b still could prove formula instead one might wish specify ideal access type analogy typical specifications natural numbers unlimited resource access values upointer pointer next 8 nextstc x nextc 9 xnextc x nextstc b xy according axiom 8 access value allocated stc x ie returned nextstc x allocated c either returned nextc well 9 reverse saying access value x available possible result nextc also available extended collection stc b provided x different interestingly axioms establish instance equivalence nextstc x nextstc x b says choice next access value allocated depend accessed values stored collection z next st c x z next st c x b z x x next st c x x z z next st c x z next st c x z next st c x b next st c x next st c x b ntr direction proved ren 7 conclusions related work defined formalism suitable specifying nondeterministic operators distinguishing terms applications focused observational aspect programs computations one observes evaluating program introduced calculus neq given first proof completeness multialgebraic semantics given procedure interpreting specification nondeterministic system terms underspecified equational system within classical conditional equational logic extended dis junction translation yields specification refined language enables us define function oriented computational semantics feel latter plausible computational interpretation reflects intuition evaluations nondeterministic programs computational semantics nonintrusive respect algebraic semantics deterministic constructs sense require change existing models contrast move relation set valued model impact model deterministic functions whereas understand ing nondeterminism retains standard function oriented model deterministic interpretation nondeterministic specifications found earlier works kapur 1980 subrahmanyam 1981 used simple equations interpreted set equalities specified nondeterministic operation f means associated characteristic predicate expressing x possible result f translation equation semantically equivalent intermediary translation step def 43 two inclusions characteristic predicates used binding results applications nondeterministic terms derived specifications based skolemization formulae yield new semantics nondeterminism made explicit form index arguments furthermore kapur 1980 subrahmanyam 1981 address problem referential opacity nondeterministic terms level specification language reasoning carried level derived deterministic formulae full firstorder logic also shown refinement specification language level indexed functions compatible multialgebra semantics one hand multimodel computational interpretation multisemantics used correct abstraction tool cases abstraction computational semantics needed multimodels functional models specification sp satisfy formula l neq sp recent work algebraic specifications nondeterminism bears similarities approach presented paper elegant construction unified algebras proposed mosses mosses 1989a mosses 1989b unified algebras provide quite general flexible semantic tools nondeterministic choice modeled separate sort comprising exactly possible results similar nondeterministic constants language allows variables refer arbitrary applications operations bindings case must interpreted individuals unique results semantic domain addition unified algebras represent one algebraic approaches supporting singular plural calltimechoice runtime choice semantics parameter passing given account distinction multi poweralgebraic framework walicki 1994awalicki 1994b spite similarities language level semantics leading flexibility different particular completely changes traditional notion model also cases specifications involve deterministic functions humann 1988 humann 1993 humann uses standard generalization algebras multialgebras semantics nondeterminism primitives specification language analogous primitives language l neq comprise inclusions determinacy predicate assertion dett corresponds rewriting systems designed specifications provide excellent example constructive approach reasoning nondeterminism unfortunately several restrictions must put specifications order prove even limited form completeness full completeness result still lacking neq used show extensions needed humanns calculus theorem 52 yields desired completeness theorem walicki 1992 language calculus given humann constructed special cases fact general clauses language calculus restricted instance single positive formula without impairing results obtained general case open problem whether system implemented humann humann 1985 accommodated general context recent work kriauciukas 1994 alternative extended version neq given also includes rewriting unlike approach mosses humann succeed construction initial models however turns initial semantics nondeterministic specifications tend introduce redundant elements thus violating junk dictum original initial approach walicki 1993b formalism disjunction provides sufficient means eliminating junk leads intuitive semantics acknowledgment paper significantly improved thanks suggestions anonymous referees particularly grateful one referee whose proposal recast original sequent based presentation terms clauses made logic proofs simpler elegant first author thanks norwegian research council financial support work paper r testing equivalencies event structures munich project cip wide spectrum language cip algebra communicating processes structure abstract algebras model theory rewriting systems discipline programming fundamentals completeness manysorted equational logic universal realization persistent interconnection implementation abstract modules remarks remarks manysorted equational logic unification observing nondeterminism concurrency observing processes mathematical approach nondeterminism data types axiomatic definition programming language pascal rapid prototyping algebraic specifications rap system users manual nondeterministic algebraic specifications nonconfluent term rewriting nondeterminism algebraic specifications algebraic programs equations rewrite rules survey behavioural equivalence data types semantics simple language parallel programming conditional rewriting rewriting nondeterministic choice operator towards theory abstract data types reasoning rewriting setrelations ground case properties preserved homomorphism semantics nondeterminism allocations objects considered nondeterministic expressions abstract axiomatization pointer types conditional rewriting logic deduction models concurrency conditional rewriting logic unified model concurrency calculi communicating systems unified algebras institutions unified algebras action semantics nondeterministic data types models implementations observing nondeterministic data types computing systems described equations homomorphisms subalgebras multialgebras referential opacity nondeterministic data refinement observational equivalence nondeterminism abstract data types semantics disjunctive deductive databases semantics disjunctive deductive databases calculii nondeterministic specifications three completeness results algebraic specifications nondeterminism initialitynondeterminism junk multialgebras power algebras complete calculi identities inclusions singular plural nondeterministic parameters multialgebras introduction event structures beyond conditional equations tr communicating sequential processes nondeterministic data types models implementations munich project cip volume wide spectrum language cipl observational equivalence algebraic specification remarks remarks manysorted equational logic testing equivalences event structures mathematical approach nondeterminism data types rewriting nondeterministic choice operator observing nondeterministic data types unified algebras action semantics fundamentals algebraic specification 2 module specifications constraints unified algebras institutions semantics disjunctive deductive databases algebraic specification conditional rewriting logic unified model concurrency nondeterminism algebraic specifications algebraic programs referential opacity nondeterministic data refinement calculus communicating systems computing systems described equations discipline programming multialgebras power algebras complete calculi identities inclusions nondeterminism abstract data types universal realization persistent interconnection implementation abstract modules nondeterministic algebraic specifications nonconfluent term rewriting reasoning rewriting setrelations process theory based bisimulation semantics introduction event structures conditional rewriting logic observing nondeterminism concurrency observing processes allocations objects considered nondeterministic expressions towards abstract axiomatics access types completeness manysorted equational logic ctr yngve lamo micha walicki quantifierfree logic nondeterministic theories theoretical computer science v355 n2 p215227 11 april 2006 michal walicki manfred broy structured specifications implementation nondeterministic data types nordic journal computing v2 n3 p358395 fall 1995 beata konikowska rasiowasikorski deduction systems computer science applications theoretical computer science v286 n2 p323366 17 september 2002 stefan ratschan convergent approximate solving firstorder constraints approximate quantifiers acm transactions computational logic tocl v5 n2 p264281 april 2004 andrea corradini fabio gadducci functorial semantics multialgebras partial algebras applications syntax theoretical computer science v286 n2 p293322 17 september 2002 micha walicki sigurd meldal algebraic approaches nondeterminisman overview acm computing surveys csur v29 n1 p3081 march 1997
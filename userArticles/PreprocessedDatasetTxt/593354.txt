fourier elimination compiling constraint hierarchies linear equality inequality constraints arise naturally specifying many aspects user interfaces requiring one window left another requiring pane occupy leftmost 13 window preferring object contained within rectangle possible interactive use need solve similar constraint satisfaction problems repeatedly screen refresh successive problem differing previous one position input device previous state system present algorithm solving systems constraints using projection solution compiled efficient constraintfree code parameterized new inputs producing straightline constraintfree code sort important number applications example provide predictable performance realtime systems allow companies ship products without including runtime constraint solver compile java applets downloaded run remotely without include runtime solver applications runtime efficiency particularly important even less timecritical user interface applications smooth performance resulting code pleasing code produced using current techniques b introduction constraints natural tool user interface toolkits kinds interactive graphical systems important uses application area include specifying layout geometric information maintaining consistency application data view data maintaining consistency among multiple views important able express preferences well requirements interactive constraint systems one important use express desire stability moving parts image things stay unless reason move second use process potentially invalid user inputs graceful way example user tries move gure outside bounding window reasonable gure bump side window stop rather signalling error third use balance con icting desires example laying graph constraints needed specify maintain layout information typically linear equalities inequalities real numbers 2 inequality constraints particular needed express relationships inside leftof overlaps example express requirement window1 left window2 constraint window1rightside window2leftside layout constraints requirements others preferences interactive systems typical requirement resatisfy constraints repeatedly user moves part gureeach time screen refreshed constraints must resatised constraint satisfaction problems diers previous ones values constants constraints example mouse position one strategy achieving required interactive response times compile constraint satisfaction plan block code executed repeatedly resolve constraints different input parameters view kind partial evaluation constraint solving algorithm long done local propagation solvers eg 1 recently simultaneous linear equations 4 acyclic sets inequality constraints 2 however systems compile plans systems constraints including cyclic set simultaneous equalities inequalities lack addressed original motivation work constraint solving user interface toolkits kinds graphical interactive systems technique useful two reasons rst produces code requires runtime support constraint solving second code ecient technique also useful applications either considerations factor ability get rid runtime support important many real software tasks one example sort constraintbased authoring environment producing java applets behaviour applet partially specied using constraints applet written tested authoring environment constraint compiler used produce straight java code shipped net run remote machine without requiring runtime constraint solver remote machine preliminary work application done 6 used constraint compiler produce java code several applets include interactive demonstration geometric theorem abacus simulation included web documents second example building embedded realtime engine controller predictable performance needed compiled code provide calls runtime constraint solvers generally cannot finally developing product company might use constraints developing application want ship proprietary constraint solving package application 8 compiled code also ecientour measurements show speeds 5 20 times faster test cases performed using runtime solver based simplex algorithm 7 runtime solver reasonably ecient well many applications constraint solving time dominated graphics refresh time either technique however cases simplex solver markedly varying response timesmuch time extremely fast succession pivots required slows considerably giving rise overall jerky quality interaction people prefer uniform response times varying ones additional speed could important cases well example compiled code run slower processor paper show use fourier elimination compile heirarchical constraint solving 3 section 2 introduce notion solving constraints projection show used produce compiled code review notion constraint hierarchies expressing preferential constraints section 3 showing adapt projection algorithm handle hierarchical constraints section 4 section 5 address issue redundancy management section 6 discuss extensions algorithm examine compiletime runtime properties prototype implementation section 7 section 8 present theoretical complexity results algorithm finally section 9 conclude 2 solving constraints using projection section brie illustrate projection used nd solutions linear equality inequality constraints moment ignore preferential constraints also ignore issues compilation primitive constraint context linear inequality equality constraint set primitive constraints assume every primitive constraint written simplied form variable appears twice primitive constraint let varsc denote set variables appearing constraint c similarly let varsc denote set variables appearing equation inequality c denote 9w f existential quantication variables f except w formula 9v 1 9v 2 9v k f w set variables variable x 2 varsc partition c following way let c 0 x set primitive constraints c 2 c x 62 varsc let x set equations c 2 c x 2 varsc let c x set inequalities c 2 c c equivalent inequality form x e e linear expression involving x finally let c x set inequalities c 2 c c equivalent inequality form e x e linear expression involving x projection algorithm figure 1 eliminates variable x constraint c returns constraint 9xc using either gaussian elimination fourier elimination solve constraints project variable turn using project variables remain resulting constraint c 0 equivalent 9 c none primitive constraints c 0 involve variables hence straightforwardly determine whether c 0 satisable answers satisability question exists c 2 x c every occurrence x replaced e else c 2 c c 2 c x c e x end end return figure 1 combined fouriergaussian projection x l0 100 figure 2 simple constrained picture c use intermediate constraints c produced 1 applications project well variables x order elimination build solution c 1 n case varsc g cn contains variable xn hence contains constraints form satisable nd valuation xn solution cn extend solution c i1 solution c follows consider constraints c involve x one equation equivalent x e e expression involving variables let contains inequalities containing x written form x e j e k x e j e k expression involving variables fx g using valuation determine minimum u e j maximum l e k value l u gives valid solution c new solution thus g figure 3 constraint projection example give example constraint solving using projection using illustration figure 2 constraints follows xm constrained midpoint line x l x r x l constrained least 10 left x r variables must lie range 0 100 represent using constraint c 1 shown figure 3 solve constraint using variable elimination start c 1 select variable project continue variables remain suppose rst select x l project using equation yielding constraint c 2 project x r yielding constraint c 3 eliminated simple redundancy finally eliminating xm obtain c 4 clearly satisable show construct solution constraints inspecting know pick value 5 95 xm say 50 next examine constraints c 2 involving x r fxm 100g given 100g thus pick value x r range 55100 say 70 finally examining constraints c 1 equation involving x l namely x use equation directly set x l 30 use information compile sequence statements constructs solution constraints returns triple illustrated figure 4 stands sequence statements isnt interesting since solves one problem however section 4 show use similar technique compile code parameterized appropriate inputs 3 constraint hierarchies discussed earlier interactive graphics applications important able express preferences well requirements constraint system particular desire minimizing change gure manipulated use constraint hierarchies 5 specifying desired solutions collection required preferential constraints independent particular algorithm involved x l x u choose xm 2 x l x l x u r min f 2xm 100 choose x r 2 x l r x u r return figure 4 code solve constraints figure 2 obtained fourier elimination labelled primitive constraint primitive constraint labelled strength written sc strength c primitive constraint strengths nonnegative integers clarity give symbolic names dierent strengths primitive constraints strength 0 symbolic name required always reserved required constraints purposes paper shall use following symbolic names strengths strong 1 general approach works number strength levels note higher integer strength indicates weaker constraint constraint hierarchy multiset labelled primitive constraints given constraint denotes multiset required primitive constraints h labels removed way dene multisets h strengths since dealing nonrequired constraints valuations interest may satisfy constraints hence need able measure degree constraint satised assume primitive constraint c error function ec returns nonnegative real number indicating nearly primitive constraint c satised valuation work described domain reals error function returns value varies depending nearly constraint satised example error error x max0 x set solutions hierarchy dened follows 0 set valuations h 0 constraints hold form eliminating potential valuations worse potential valuation using comparator predicate better assume use local comparators better compare two solutions primitive constraint primitive constraint section 6 look extend approach certain kinds global comparators valuation locallybetter another valuation primitive b c figure 5 demonstrating theorem quadrilaterals constraints strength level k 1 error applying equal applying level k error strictly less least one primitive constraint less equal rest locallybetter locallybetter comparator error function known locallyerror better traditional demonstration constraintbased graphics quadrilateral theorem illustrated figure 5 screen snapshots taken smalltalk implementation uses code produced projection algorithm side quadrilateral bisected lines drawn midpoints inner lines always form parallelogram expressed constraint midpoint lie halfway endpoints line addition points constrained least 10 pixels sides window north vertex constrained least 30 pixels south vertex east vertex constrained least 30 pixels right west vertex latter two quadrilateral cannot collapse point taken together constraints dicult ui constraint solvers since involve cyclic equality inequality constraints figure 5a picked one midpoints mouse begun move temporarily adding edit constraint equating position midpoint mouse constraint strongly preferred requiredwe violate necessary corner points weakly constrained stay stay constraints constraint heirarchy representing quadilateral problem shown figure 6 n x coordinates north east south west vertices respectively coordinates midpoints ne x ne se x se sw x sw nw x nw mouse x mouse current coordinates mouse oldn x oldn required 2ne required 2ne required 2se required 2se required 2sw required 2sw required 2nw required 2nw required n required e x w x required required strong se strong se figure 6 constraint heirarchy representing quadrilateral problem etc give old coordinates points want stay strong edit constraints ensure south east midpoint tries follow mouse weak stay constraints try maintain corner points old positions figure 5b mouse moved right keep midpoint constraint satised east vertex moved well continue moving right figure 5c east vertex run imaginary wall resulting constraint least 10 pixels window boundary move result order maintain midpoint constraint south vertex moving instead finally figure 5d mouse moved beyond permitted region midpoint midpoint moved close mouse possible thus causing two endpoints line pressed boundary well formally stay edit constraints example simply constraints form constant b however come compile code repeatedly solving collection constraints important handle constraints eciently since value b change solution stay constraints value v previous step edit constraints come external input constraints remain unaltered step 4 compiling projection hierarchies describe complete algorithm compiling code repeatedly nd locallyerrorbetter solution constraint hierarchy given series input values assume constraint hierarchy hierarchical normal form form kind preferential constraints ones form variable v constant b constraints required ie must satisfy solution practice original problem usually already form easy transform arbitrary linear constraint hierarchy form adding error variables example stronge b e linear expression becomes requirede b e new error variable recall hierarchical constraint h separated parts h contain primitive constraints strength h hierarchical normal form 1 h contain equations form variable b constant use information build strength partitioning variables let v dened follows contains variables whose strongest nonrequired primitive constraint strength simplicity assume every variable involved nonrequired constraint normally case constraintbased graphics applications add weak stay constraintweaker existing constraintsto variable otherwise involved nonrequired constraint locallyerrorbetter solution new hierarchical constraint also locallyerrorbetter solution original constraint consider solving constraints figure 2 augmented preferential constraints strongx h g strength partitioning variables gives g use projection algorithm build code solving hierarchical normal form constraints problem diers others values constants b nonrequired primitive constraints problem corresponds solution constraint heirarchy required determine positions objects screen refresh manipulation diagram apply projection algorithm eliminate variables set v j eliminating variables v j total ordering x 1 x 2 xn variables x hierarchical normal form constraint h respects hierarchy returning example solving constraints figure 2 augmented l ordering respects heirarchy xm x r x l full algorithm generating code takes ordering variables required constraint c solve constraint c conjunction h 1 h 2 h k variable x l select constraint arbitrarily choose one highest strength nonrequired constraints x determine value b making choice correct locallyerrorbetter comparator minimising error one strongest nonrequired constraints always give locallyerrorbetter end n 1 exists c 2 c c x else minset maxset primitive constraint c 2 c x c e x minset else c x e maxset end emit else b x l end emit return figure 7 code generation algorithm lution choosing dierent constraint strength would compute dierent still valid locallyerrorbetter solution code produced algorithm figure 7 either set x b legitimate choice given solution determined far set x lower upper bound whichever closest value b theorem 1 correctness code generate let c constraint variables g given variable ordering x 1 x 2 xn variables constraint c solution returned code produced code locallyerrorbetter solution constrain weaker strength proof value variable chosen available range values variable determined fouriergaussian elimination thus correctness fouriergaussian elimination algorithm always produces solutions satisfy required constraints c remains show solution produced also locallyerrorbetter assume contrary locallyerrorbetter solution constraints exists another solution 0 n locallyerror better largest index 0 examine selection value variable x j correctness fouriergaussian elimination 9 fx j x ng c ng c given variables x take values respectively clearly solutions x j c j range x l hence error equation greater solution 0 means n locallyerrorbetter since greater error equation x error every nonrequired equation higher strength otherwise b j x l j 0 j must range x l error constraint x greater 0 implies 0 n locallyerrorbetter remaining case b j x u j similar continuing running example compiling constraints figure 2 augmented strongx l resulting code shown figure 8 note high similarity code figure 4 suppose midpoint line selected mouse move position 60 remaining points constrained stay x 70 imposes constraints strongx code figure 8 generates answer 60 70 50 mouse moves position 70 edit stay constraints translate code generates answer 70 75 65 mouse moves position 0 code generates answer 5 10 0 5 redundancy management one problems fourier elimination large number constraints produced potentially exponential number many redundant constraint compiler based fourier elimination succeed crucial x l x u else xm x l else xm x u x l x u r min f 2xm 100 r x u r else b r x l r x r x l else x r x u return figure 8 code midpoint example constraints issue redundant constraints addressed detecting eliminating redundancy practical number types redundancy cheap detect still eective keeping number redundant constraints one quasisyntactic redundancy primitive constraint quasisyntactically redundant respect c 2 1 x case c 1 dropped without aecting result test inexpensive log n testing n primitive constraints yet allows us get rid signicant number redundant constraints main class redundancy detect eliminate targets output constraints projection process best known constant bounds maintained variable variable say x eliminated constraints yield upper lower bounds x examined constraint shown redundant respect another using bounds information accumulated earlier discarded redundancy elimination point drastically reduce size crossproduct formed elimination x also directly reduces number compiled constraints bounds information used evaluating minimum maximum values expression take subject known bounds best use made examining expressions say upper bounds x pairwise fashion evaluating dierence expressions minimum possible value dierence nonnegative rst expression guaranteed smaller second maximum value nonpositive guaranteed larger cases one constraints may discarded redundant otherwise redundancy information deduced evaluating dierence constraints fashion rather constraint individually one able obtain much redundancy information example suppose bounds x x 2y x 10 know 5 5 rst bound deduce lies 10 10 second 5 15 since 5 10 cannot guarantee rst constraint always tighter second however look dierence 10 work lies 15 5 thus guarantee rst constraint always tighter second discard latter redundant second main approach managing redundancy try minimise number redundant constraints generated rst place done clever order variables eliminated algorithm stands leaves us reasonable freedom choice variable eliminate choose variables strength order like simple heuristics variable eliminate next make substantial dierence number constraints generated obvious useful heuristic choose variable appearing equation gaussian elimination used rather fourier variables choosing x minimises x jjc x j work well minimises next step sum number output constraints number constraints remaining prior redundancy elimination actual heuristic use counts number linear terms constraints rather number constraints since discourages formation constraints many terms particularly problematic fourier elimination based reasoned approach selecting variable eliminate next results theorem 4 see section 8 often allows us process relatively small groups variables constraints given time limits scope producing redundant constraints practice approach seems work well 6 renements section discuss renements solver would appear increase class problems solve implemented simply altering input main algorithm required required required x l 0 required xm 0 required xr 0 required x l 100 required xm 100 required xr 100 strong x figure 9 midpoint examplelocal comparator version 61 optimising function rather returning solution satisfying input constraints possible optimise linear objective function done introducing new variable representing value objective function plus required constraint relating variables depends constraint appropriate strength try set value objective function suitably large small minimise value 4 note one actually many objective functions many dierent strengths one wants instance one could optimise particular function subject required constraints optimise another subject rst remaining optimal add nonrequired constraints values variables apply nal optimisation assigning appropriate strengths note normally objective function would share strength anything else example two objective functions assigned strength solver would free choice optimise rst allowing choice would usually make sense unless objective functions independent 62 global comparators sections 3 4 assumed working local comparators however possible achieve eect equivalent using linear global comparator way done similar introduction objective except time function terms error variables may require introduction extra error variables needed well required nonnegativity constraints error variables required required required x l 0 required xm 0 required xr 0 required x l 100 required xm 100 required xr 100 strong x required x l l required xm required xr r required e l 0 required e l 0 required e required e 0 required e required e r 0 required e l figure 10 midpoint exampleglobal comparator version consider simple midpoint example added weak stay constraints x l xm x r plus strong constraint x l constraints shown figure 9 suppose wish minimise sums errors constraints medium strength error weak constraint x jx r rj cannot encode error directly using linear constraint due modulus instead introduce pair new variables represent error one dierence negative one positive variables constrained nonnegative sum used represent error 5 thus x r r e r 0 e r 0 taking consideration weak constraints global error l g minimise also add medium strength nal result shown figure 10 note kept stay constraints ensure variables set particular values seen surprisingly using global comparators comes cost terms size number constraints compiled 7 computational results projectionbased compilation algorithm implemented tested prototype implementation mercury 14 includes module easily adapted generate code dierent target languages current implementation produces smalltalk code stored le smalltalk environment code loaded incorporated graphics application execution advantages using smalltalk smalltalk includes extensive graphics library making easy test interactive graphical programs also smalltalk implementation cassowary simplexbased solver allows headtohead comparison run times two algorithms investigated performance algorithm several mediumsized examples constraints interactive graphics boxcars benchmark number boxes horizontal row box constrained right previous one constrained stay within specied horizontal range binary tree benchmark complete binary tree given height pair children constrained height must least minimum distance parent must separated minimum distance parent nodes must centred children nally every node must lie within certain bounding box formulation redundancywe could specied left child minimum distance parent rather left right children since children height however redundancy arises naturally specication grid benchmark n n grid points every point constrained imaginary vertical line points horizontal line points left right point within given distance neighbours points lie within given box specication leads redundancy constraints compilation results shown table 1 benchmark give following information number variables original formulation number primitive constraints original formulation typical number primitive constraints compiled code number inequalities used minset maxset calculations plus equations used emit calculation code typical choice edit variables typical cpu time required mercury program produce smalltalk code compilations done dec alphaserver 8400 eight 300 mhz 21164 processors compiled versions suer exponential blowup number primitive constraints indeed contain fewer constraints input reduction due redundancy elimination performed projection code produced extremely ecient also predictable performance irrespective input values table 2 gives measurements execution speed compiled code compared execution speed cassowary constraint solver 7 uses ecient simplexbased algorithm specically adapted repeatedly solving constraints arising interactive graphics applica tions timings done using oti smalltalk version 40 running ibm thinkpad 760el laptop computer table 1 compilation statistics problem size variables primitive compiled time constraints constraints secs boxcars 50 50 149 100 07 100 100 299 200 14 200 200 599 400 45 binary tree 5 62 199 111 05 9 1022 3319 1910 462 table 2 runtime statistics problem time milliseconds avg pivots fourier cassowary graphics cassowary 50 boxcars 10 50 380 011 infrequent collisions 50 boxcars 10 160 380 051 frequent collisions depth 5 tree 53 686 460 155 frequent collisions depth 5 tree 53 1245 460 377 v frequent collisions times shown average number milliseconds perform one update ie solve constraint problem new value mouse position fourier cassowary times without graphics refresh additional refresh time shown graphics column finally cassowary last column gives average number simplex pivots per update two dierent runs given boxcars example one input varying slowly collisions boxcars relatively infrequent another rapidly varying input causing collisions time run fourier code cases however frequent collisions cassowary time per update increases substantially reason collision generally requires pivot simplex tableau expensive collision tableau updated eciently pivoting required also two runs tree example used tree node displays closely spaced many collisions moving node bumping stationary one cases second run involved moving mouse quickly generate even collisions examples fourier code approximately 5 20 times faster runtime simplex solver relatively simple constraints boxcars example graphics refresh time substantially time required satisfy constraints tests however using simplex solver tree example constraint solving time becomes signicant compared graphics refresh time addition simplex solver variable solving time quite apparent mouse moved quickly example often update extremely fast numerous pivots needed slows giving less pleasant jerky quality interaction fairness simplex approach possible extrapolate current direction mouse movement presolve pivots done current systems addition use realtime systems predictable response provided compiled fourier code essential 8 complexity analysis variable elimination algorithms bad worst case complexities projecting one variable system linear inequalities produces om 2 inequalities worst case hence eliminating n variables primitive constraints om 2 n however empirical results far shown quite reasonable performance practical problems section attempt analyse situation point reasons one major factor reasonable performance algorithm many practical problems primitive constraint involves small number vari ables hence worst case arise also number restricted cases much reasonable worst case complexities one restricted case constraint involves 2 variables grid benchmark falls category following result due nelson 12 theorem 2 let c set inequalities involving n variables inequality involves 2 variables fourier elimination omn d2 log ne3 log n another example worst case phenomena cannot occur almost constraints equations theorem 3 let c constraint involving n variables linearly independent equations l inequalities choice variable elimination order fourier elimination onmm proof use equations eliminate variables leaving l inequalities n variables result follows also appears many practical constraint problems interactive graph ics constraints tightly connected examine class constraint graph tightly connected constraint graph constraint c undirected graph constructed follows nodes variable primitive constraint c 2 c edge variable node v primitive constraint node c v 2 varsc two nodes x graph g biconnected exist two nodedistinct paths g x biconnected component graph g maximal set nodes n biconnected g constraint graph g kbiconnected biconnected components g k variable nodes binary tree benchmark example constraint graph 3biconnected theorem 4 let c constraint involving n variables primitive constraints whose constraint graph kbiconnected choice variable elimination order slightly modied fourier elimination algorithm quasisyntactic redundancy elimination onm 2 k proof start forming biconnected component graph cluster clusters form tree forest original graph fully connected proceed eliminate clusters one time starting leaves leaf cluster connected rest tree via single node node represents variable say x task easy simply project constraints cluster onto x possible resultant constraints x bounds using quasi syntactic redundancy two l x x u bounds added parent cluster hand connecting node represents constraint introduce temporary variable split constraint rst let constraint form op either e 1 linear expression containing variables included cluster e 2 linear expression containing variables cluster constraint split e 1 former added current leaf cluster latter replacing original constraint variable added parent cluster project constraints current leaf cluster onto add resulting bounds parent cluster note introduction temporary variables increase number variable nodes cluster temporary variable appears exactly one equation two bounds constraints though note one temporary variable may appear equation original constraint cut node several biconnected components met eliminate temporary variables rst easy see equation involving temporary variables yields two inequalities involving remaining variables elimination ol l temporary variables involved leaves cluster k variables standard fourier elimination applied eliminating variables leaf cluster never adds constraints parent cluster eliminated leaf hence maximum number constraints cluster given time maximum number variables eliminated cluster standard algorithm applied k hence processing one cluster standard algorithm om 2 k n clusters tree thus n temporary variables introduced hence complexity result holds theorem 4 particular constrains order variables elimi nated interactive graphics problems typically two variables edit constraints x coordinates point moved variables must eliminated last compatible ordering required theorems x constraints independent case examples many cases well however problem includes constraints relating x coordinates eg shape square may unable use complexity guarantees provided theorems 9 conclusions fourier elimination used generate fast constraintfree code solve problems arising interactive graphical applications approach useful applications realtime systems need predictable performance smoothing response time interactive system producing applications run without employing runtime constraint solver execution speed important approach compiling constraint solving projection applied constraint domain variable elimination function projects one variable constraint along method nding solutions conjunction constraints one variable constraint domains meet requirements include boolean constraints unit two variable per inequality integer constraints 11 partial order constraints current algorithm batch one direction future research design incremental version would reuse part previous solution accommodating changes constraint beyond simply changing constants previous work involved hybrid constraint solving algorithms partition set constraints regions turned appropriate subsolver class constraint constraint topology 3 compilation based fourier elimination promising candidate use architecture handle cyclic collections linear equality inequality constraints theorem 4 particularly interesting shows structure constraints solved exploited make actual solving ecient sabin freuder 13 also studied structure constraint graph exploited case demonstrate substantial improvements solving time random binary csps identifying approximation cycle cutset constraint graph seems interesting area explore acknowledgements project funded part national science foundation grant iis9975990 australian research council large grant a10017012 alan bornings visit university melbourne sponsored part fulbright award notes 1 current address whicparcicacuk icparc william penney laboratory imperial college exhibition road london sw7 2az united kingdom 2 note user interface objects mapped particular pixel locations display thus coordinates theory integral practice usually necessary desirable applications rounding real coordinates nearest integer point quite appropriate locations screen treated reals make constraint solving easier work assume coordinates reals note nonlinear constraints arise user interface applications attributes areas angles nite domain constraint also arise handling fonts cases sophisticated techniques required eg 9 3 earlier version paper appears 10 4 maxfloat similar sucient applications would trivial change solver implement feature directly 5 strictly sum accurate representation error least one variables zero guaranteed minimising global error r programming language aspects thinglab indigo local propagation algorithm inequality constraints oti constraint solver constraint library constructing interactive graphical user interfaces ultraviolet constraint satisfaction algorithm interactive graphics constraint hierarchies constraints web solving linear arithmetic constraints user interface applications object technology international compiling constraint solving using projection n log n algorithm twovariableperconstraint linear programming satis ability problem understanding improving mac algorithm execution algorithm mer cury ecient purely declarative logic programming language tr ctr jakob mauss frank seelisch mugur ttar constraint solver modelbased engineering ai communications v17 n2 p7592 april 2004
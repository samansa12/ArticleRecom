modular termination contextsensitive rewriting contextsensitive rewriting csr recently emerged interesting flexible paradigm provides bridge abstract world general rewriting applied setting declarative specification programming languages obj cafeobj elan maude natural approach study properties programs written languages model contextsensitive rewriting systems especially interested proving termination systems thereby providing methods establish termination eg obj programs proving termination contextsensitive rewriting exist transformation methods reduce problem termination transformed ordinary term rewriting system trs transformations however serious drawbacks particular seem support modular analysis termination problem paper show substantial part wellknown theory modular term rewriting extended csr via thorough analysis additional complications arising contextsensitivity precisely mainly concentrate termination properties obtained modularity results correspond nicely fact languages modular design programs specifications explicitly promoted since also complemented modular analysis techniques b introduction programmers usually organize programs components modules components program easier de velop analyze debug test eventually programmer wants interesting computational properties like termination hold whole program could proved individual components program roughly speak ing modular property means contextsensitive rewriting csr 26 restriction rewriting forbids reductions selected arguments functions way termination behavior rewriting computations improved pruning infinite rewrite sequences several methods developed formally prove termination csr 8 12 13 25 43 47 termination innermost contextsensitive rewriting recently related termination declarative languages obj cafeobj maude 27 28 languages exhibit strong orientation towards modular design programs specifications setting achieving modular proofs termination desirable instance borrowing appendix c5 16 figure 1 show specification program using lazy lists modules truthvalue nat introduce sorts constructors boolean natural numbers module idnat provides specialization builtin syntactical identity operator 1 obj see module identical appendix 1 definition binary predicate meaningful provided rules attempted top bottom quite reasonable assumption obj implementation point view nevertheless discussion termination program depend fact way obj truthvalue obj nat nat obj idnat protecting truthvalue var obj lazylist list list list list assoc idr nil strat 0 obj inf protecting lazylistnat list strat 1 0 obj take protecting lazylistnat list list strat 1 2 0 figure 1 modular specification obj3 d3 16 module inf specifies function inf able build infinite object list natural numbers following number n module take specifies function take able select first n components lazy list given second argument take fi nally module length introduces function computing length finite list use strategy annotation strat 0 list constructor cons module lazylist intended 1 allow real terminating behavior program due disallowing recursive call infsn definition inf 2 avoiding useless reductions first component list computing length instance possible obtain value ss0 lengthtakes0infs0 without risk nontermination 2 although simple program figure 1 provides claim justified using results 31 30 teresting application modularity results instance whereas possible prove termination program using automatic techniques proving termination knuthbendix polynomial recursive path orderings see 1 5 pretty simple separately prove termination modules idnat inf take length modularity results permit formal proof termination ultimately relies use purely automatic techniques recursive path ordering see example 9 moreover automatic tools proving termination cime 20 system 3 also used prove termination corresponding modules way user allowed ignore details termination proofs techniques relying use software tools going details let us mention exists already abundant literature rewriting contextsensitive related strategies cf eg 3 7 9 10 11 40 2 preliminaries 21 basics subsequently assume general familiarity basic theory term rewriting cf eg 1 5 given set pa denotes set subsets given binary relation r set denote reflexive closure r transitive closure r reflexive transitive closure r element rnormal form exists b r b nfr set r normal forms say b rnormal form b rnormal form r b say r terminating infinite sequence a1 r a2 r a3 say r locally confluent every b c whenever r b r c exists b r say r confluent every b c whenever r b r c exists r confluent terminating say r complete throughout paper x denotes countable set variables f denotes signature ie set function symbols f g fixed arity given mapping ar f n set terms built x said linear multiple occurrences single variable terms viewed labelled trees usual way positions p q represented chains positive natural numbers used address subterms given positions p q denote concatenation pq positions ordered standard prefix ordering given set positions p maximal p set maximal positions p wrt p position q set positions denote empty chain set positions term post positions nonvariable symbols denoted posf posx positions variables subterm position p denoted p ts p term subterm position p replaced symbol labelling root denoted roott rewrite rule ordered pair l r written l r l r varl lefthand side lhs rule l r righthand side rhs trs set rewrite rules 3 available httpcimelrifr lr denotes set lhss r instance l lhs l rule redex set redex positions posrt trs r leftlinear l lr l linear term given trss let r r trs rewrites position p written r rule l r r p post substitution trs terminating terminating say innermost rewrites written p innermost terminating 22 contextsensitive rewriting given signature f mapping f pn replacement map fmap f f f 1 arf 26 let mf mr determines considered symbols set fmaps sake simplic ity apply replacement map mf symbols signature f assuming whenever f f replacement map specifies argument positions reduced symbol f accordingly set replacing positions pos set positions replacing redexes contextsensitive rewrite system csrs pair r r trs replacement map contextsensitive rewriting csr 26 contract replacing redexes rewrites r p pos example 1 consider trs r 2 csrs r corresponds obj3 program figure 1 cons replaced see 27 details correspondence since 22 pos takes00infs0 redex infs0 cannot rewritten normal forms called r normal forms csrs r terminating resp locally confluent conflu ent complete terminating resp locally confluent confluent complete slightly abusing terminology shall also sometimes say trs r terminating csrs r terminating innermost csr contract maximal positions replacing redexes r p maximal pos r say r innermost terminating terminating 3 modularproofsoftermination csr transformation subsequently assume basic familiarity usual notions notations terminology modularity rewriting cf eg 45 33 17 38 39 4 say property csrss modular disjoint constructor sharing composable unions whenever two resp disjoint constructor sharing composable csrss r1 r2 2 property union r1r2 1 property 5 two csrss r1 1 disjoint signatures r1 dis joint csrss r1 1 r2 2 constructor sharing share constructor symbols see definition 7 details finally csrss r1 1 r2 2 composable share defined symbols provided share defining rules cf 39 note disjoint trss sharing constructor sharing constructor trss composable termination csrss r usually proved demonstrating termination transformed trs r obtained r using transformation 6 8 12 13 25 43 47 simplest trivial correct transformation proving termination csrss identity r terminating r terminating every replacement map considering interaction modularity transformations proving termination csrs r imagine two main scenarios first modularize next transform mt first given r look decomposition modularity eg disjointness constructorsharing composability etc prove termination transformation first transform next modularize tm first transform r r look suitable decomposition termination ensures termination r hence r second approach tm actually standard problem able achieve modular proof termination first approach mt succeeds 1 st way termination implies termination entails termination 2 transformation compatible ie possibly modularity criterion way termination would imply termination 4 relevant works modularity mentioned elsewhere include list highly incomplete 22 23 24 5 typically inverse implication trivial 6 see httpwwwdsicupvesuserselpslucasmuterm tool muterm 10 implements transformations indeed first requirement satisfied transformations reported literature fact modular definition based individual rule symbol signature disregarding interaction ie actually transformations hand second requirement fulfilled many transformations general according review main nontrivial correct transformations proving termination csr regarding suitability modular proofs termination 31 contractive transformation let f signature mf replacement map contractive transformation 25 non replacing arguments symbols f removed new contracted signature f l obtained possibly reducing arity symbols function drops nonreplacing immediate subterms term constructs contracted term joining also transformed replacing arguments corresponding operator f l csrs r contracted r example 2 consider csrs r example 1 takes according definition dicult see given trss l also clear ms implies ms compos ie usual criteria modularity preserved transformation 32 zantemas transformation zantemas transformation marks nonreplacing arguments function symbols disregarding positions within term 47 given z consists two parts first part results r replacing every function occurring left righthand side f fresh function symbol arity f included f occurs nonreplacing argument function symbol directly new function symbols used block reductions posi tion addition variable x occurs nonreplacing position lhs l rewrite rule l r occurrences x r replaced activatex activate new unary function symbol used activate blocked function symbols second part r z consists rewrite rules needed blocking unblocking function symbols every f f together rule activatex x problem activate new defined symbol defining rule new blocked symbol appearing signature means starting composable modules z z composable blocked symbols example 3 consider trss correspond modules inf idnat figure 1 viewed modules sharing constructor let example 1 composable problem z blocked present z note since rule activatex x present every transformed system composability best achieve applying transformation instance disjoint trss lose disjointness applying transformation 8 ferreira ribeiro propose variant zantemas transformation proved strictly powerful zantemas one see 13 transformation problems regarding modularity 33 giesl middeldorps transformations giesl middeldorp introduced transformation explicitly marks replacing positions term using new symbol active given trs trs r active mark r consists following rules l r r f f markfx1 xk 12 unfortunately unless r transformation never yield pair composable trss note two dier ent composable systems r cannot share symbols defined symbols ie rules must coincide renaming variables hence r implies dier least constructor symbol however eg f fr fs new rule markfx1 xk r gm gm since mark defined gm gm composable thus proven following theorem 1 let r dierent composable csrss r gm gm composable note since disjoint trss sharing constructor sharing constructor trss composable follows giesl middeldorps transformation provide possibility mtanalysis termination csrss least regarding modularity criteria considered 12 giesl middeldorp suggest slightly dierent presentation r mgm previous transformation presentation symbol active used anymore however since regarding modularity conflicts due use symbol mark new transformation exactly problem giesl middeldorp also introduced transformation complete ie every terminating csrs r transformed terminating trs r c 12 given trs replacement map proper top r consists following rules see 12 detailed explanation l r r f f activefx1 x xk properc okc properfx1 xk unfortunately dicult see regarding mtmodular analysis termination due rules defining proper following theorem 2 let r dierent composable csrss r c c composable 34 anontransformational approach modularity previous discussion shows contractive transformation seems suitable choice performing modular analysis termination csrss however consider obj program figure 1 represented csrs r example 1 note direct proof termination r possible contractive transformation shown example 2 r l termi nating course setting modularity useful either hand note z example 3 kboterminating resp rpoterminating therefore r z contains z z either kbo rpoterminating moreover attempts prove termination r z using cime failed every considered combination including techniques potentially deal nonsimply terminating trss like use dependency pairs together polynomial orderings proof criteria similarly termination r gm r c cannot proved either using kbo rpo see 2 formal justification claim fact could even prove simply terminating see 31 hand results section shows mt tm approaches able provide simpler proof termination r hence termination r remains dicult automatically prove following section shows situation dramatically changes using direct modular analysis termination csr 4 modular termination csr main section investigate whether known modularity results ordinary term cf eg early pioneering work toyama 45 44 later surveys stateoftheart modularity rewriting like 33 37 19 extend contextsensitive rewriting since trs r viewed csrs r modularity results trss cover specific case csrss namely replacement restrictions yet interesting case course arises proper replacement restrictions paper concentrate termination properties first study obtain criteria modularity termination csrss later well also consider weak termination properties surprisingly may help guarantee full termination con fluence conditions generalize setting consider also extent certain nondisjoint combinations ordinary term rewriting deep understanding disjoint union case appears indispensable properly treating nondisjoint unions reason mainly focus case disjoint unions practical purposes obvious nondisjoint combinations much interesting yet lessons learned nowadays fairly well understood modularity analysis term rewriting suggest extremely careful seemingly plausible conjectures obvious facts 41 modularity termination disjoint unions section investigate modularity termination disjoint unions csrss simplicity kind global assumption assume considered csrss finite results also hold systems arbitrarily many rules first positive results modularity termina tion negative ones 45 44 given rusi nowitch 41 showed absence collapsing rules absence duplicating rules suce termination disjoint union two terminating trss later middeldorp 32 refined generalized criterion showing suces one system doesnt collapsing duplicating rules careful inspection proofs actually shows results also csrss even interestingly additional source gener alization consider eg following variant toyamas basic counterexample example 4 systems terminating csrss well disjoint union latter consequence theorem 3 toyamas original version union nonterminating restrictions collapsing duplicating careful inspection two csrss interaction shows duplicating rrule problem regarding nontermination first two occurrences x rhs r1 rule become blocked applying rule particular extraction subterms two positions crucial toyamas counterexample work prohibited 3 observation naturally leads conjecture blockedinactive variables rhss shouldnt count duplication definition 1 rule l r csrs r non duplicating every x varl multiset replacing occurrences x r contained multiset replacing occurrences x l r nonduplicating rules course order sensibly combine two csrss one require basic compatibility condition regarding respective replacement restrictions definition 2 two csrss r1 said compatible replacement restrictions shared function symbols ie disjoint csrss trivially compatible theorem 3 let r1 two disjoint terminating csrss let r union following hold r terminates r1 noncollapsing ii r terminates r1 nonduplica ting iii r terminates one systems non collapsing nonduplicating proof sketch proof idea point differences trs case three properties follow immediately following observations infinite r derivation s1 s2 minimal rank ie minimal counterexample infinitely many outer reduction steps b infinitely many inner reduction steps destructive level 2 c infinitely many duplicating outer reduction steps b proved trss cf eg minimal counterexample approach 17 c proved 38 small adaptation instead wellfounded measure shown decreasing namely multiset ranks special subterms level 2 take active ie count special subterms active positions modification proof goes result able explain termination example 4 without use sophisticated proof method combined system fact case trss syntactical conditions noncollapsingness nonduplication turned special cases precisely consequences abstract structure theorem characterizes minimal counterexamples cf 17 7 csrss powerful result also holds show first need another definition r mean r provided r dis joint definition 3 trs r said terminating fpterminating short rgx r said fpterminating r gx x gx theorem 4 extends 17 theorem 7 let r1 two disjoint terminating csrss union r nonterminating one systems fpterminating system collapsing proof quite nontrivial proof practically trss careful inspection 17 reveals abstracting constructions resulting transformation minimal counterexample disjoint union counterexample one systems extended free projection rules fresh binary operator work already shown trss abstract powerful structure result lot less straightforward direct indirect consequences corollaries mention two corollary 1 termination modular nondeterministically collapsing 9 disjoint csrss corollary 2 fptermination modular disjoint csrss next look modularity weak termination properties 7 construction 17 involved trss must finitely branching practice always satisfied case infinitely branching systems handled 38 similar involved abstraction function based underlying idea extracting relevant information deeper alien subterms 8 important property later called ce termination 38 however isnt really telling natural slightly dierent property 17 called termination preserving nondeterministic collapses precise rather lengthy prefer use fptermination since naturally expresses rewrite system addition projection rules free ie fresh function 9 csrs nondeterministically collapsing term reduces two distinct variables finite number contextsensitive rewrite steps 42 modularity weak termination proper ties weak termination properties clearly interesting since full termination may unrealistic need really correspond computational process modelled certain processes programs inherently non terminating still one may wish compute normal forms certain inputs guarantee existence hand interestingly trss turned weak termination properties helpful order obtain modular way full termination property certain assumptions definition 4 let r csrs r said weakly terminating wn weakly ter minating r weakly innermost terminating win innermost contextsensitive rewrite relation weakly terminating strongly innermost terminating sin innermost contextsensitive rewrite relation strongly terminating ordinary trss wellknown dicult prove weak termination weak innermost termination strong innermost termination modular properties cf eg 6 17 18 wrt disjoint unions surprisingly hold general csrss shown following counterexample example 5 consider disjoint csrss innermost terminating fact even terminating union r neither terminating innermost terminating ever r weakly innermost terminating hence also weakly terminating fa b ga b fga b ga b latter term r normal form even win wn modular general csrss next illustrate modified version example 5 example 6 consider disjoint csrss fb x fx x x wn sin even sn union r neither win wn first innermost r step issuing innermost reduce first argument f second one vice versa subsequent innermost step must using one first four necessarily yielding cycle therefore fa b ga b doesnt innermost r normal form also r normal form careful inspection goes wrong well inspection corresponding proofs contextfree case shows problem comes innermost redexes point blocked inactive forbidden position become unblocked active later condition needed prevent phenomenon following definition 5 conservatively blocking csrs r said conservatively blocking cb short following holds every rule l r r every variable x occurring l inactive position occurrences x r inactive 10 condition properties win wn sin turn indeed modular csrss theorem 5 modul crit win wn sin win modular disjoint csrss satisfying cb b wn modular disjoint csrss satisfying cb c sin modular disjoint csrss satisfying cb proof b c proved structural induction case trss cf eg 18 19 condition cb ensures innermost term rewrite derivation constructed proofs induction step also still innermost ie proof goes csrss well 43 relating innermost termination ter mination trss powerful criterion known sin implies hence equivalent termination sn namely equivalence holds locally confluent overlay trss 18 via modularity sin trss gave rise immediate new modularity results termination com pleteness case contextfree rewriting cf 18 tunately equivalence criterion sin sn also extends csrss directly nontrivial proof requires careful analysis subtle additional assumption vacuously satisfied trss 11 definition 6 csrs r said context sensitive overlay system overlay csrs overlaying critical pairs 12 l1 r2 r1 active nonroot position l 1 r lefthomo geneous replacing variables lhrv short every replacing variable x l occurrences x l r replacing 13 formally every rule l r r every variable x l pos 11 similar claim recently made 14 without proof remains unclear whether claim without condition lhrv true rewrite rules variable common nonvariable position l 1 l 1 l 2 unifiable general unifier observe definition overlay trs overlay csrs vice versa considering csrs r trs r 13 formally every l r r every x var l pos theorem 6 local completeness criterion let r locally confluent overlay csrs satisfying lhrv let innermost terminating terminating proof since proof uses essentially approach construction one 18 trss focus dierences problems arising due context sensitivity basically proof minimal counterexam ple suppose infinite r derivation issuing dicult see one construct infinite minimal derivation following form nonterminating proper subterms terminating hence complete since reduction steps strictly p1p2 p finitely often pos sible eventually must root reduction step idea transform infinite derivation infinite innermost derivation way reduction steps still proper nermost reduction steps using rules whereas reductions technically achieved trss transformation uniquely normalizes complete subterms given term doesnt touch top parts given nonterminating term formally 14 t1 tn maximal terminating hence complete subterms crucial subtle issue make sure guarantee rule l r applied i1 still applicable position p1 p ie pattern l destroyed case trss guaranteed overlay property combined completeness general case overlay csrss may contextfree rewrite steps pattern l strictly root would invalidate argument account problem slightly modify definition follows t1 tn maximal terminating hence complete subterms active positions ie maximal complete subterms inactive positions left untouched almost done however still problem namely variable parts lhs l rule l r trs case get l csrss may problem nonleft linear rules synchronization normalization within variable becomes impossible eg one occurrence x active another one inactive consequently resulting transformed term l would instance l l r applicable avoid need additional requirement lhrv also 14 note normalization performed accounts enabling synchronization nonlinear vari ables adaptations modifications proof finally goes trs case 15 clearly stronger local version directly implies global completeness criterion corollary theorem 7 global completeness criterion let r locally confluent overlay csrs satisfying lhrv r innermost terminating also terminating hence complete 44 modularity completeness combining previous results get another new criterion modularity termination csrss fact also modularity completeness theorem 8 modularity crit completeness let r1 two disjoint terminating csrss satisfying lhrv cb suppose r1 locally confluent overlaying disjoint union r also overlaying terminating confluent hence complete proof termination r clearly implies innermost termination r 2 theorem 5 thus yields innermost termination r r overlay csrs definition notion similarly lhrv cb also hold r since syntactical properties purely rulebased assumption missing need apply theorem 7 local confluence indeed guaranteed critical pair lemma 26 theorem 4 pp 25 csrss turn crucially relies condition lhrv hence applying theorem 7 yields termination r together local confluence shows via newmans lemma confluence completeness 45 extensions constructorsharing case case trss justified hope many modularity results hold disjoint unions also extended general combinations natural next step constructor sharing unions concentrate case constructor sharing csrss slightly general setting unions composable csrss beyond scope present paper touched expect approach analysis also applicable setting already trss technically rather complicated definition 7 csrs r set defined function symbols r r set constructors currently counterexample statement theorem 6 without lhrv assumption current proof doesnt seem work without remains investigated whether imposing linearity restrictions would help observe also lhrv property plays crucial role known local global confluence criteria csrss little known prove local confluence csrss without lhrv cf 26 c2 d1 d2 denoting respective signatures sets constructors defined function symbols r1 r2 1 said constructor sharing set shared constructors rule l r r said shared constructor lifting rootr c 2 r said shared constructor lifting constructor lifting rule 1 2 rule l r r said shared lifting rootr variable shared constructor r said shared symbol lifting collapsing constructor lifting rule r layer preserving shared symbol lifting trss main problems disjoint unions arise additional interference two systems mixed terms interference stems nonleft linearity b rewrite steps destroy lay ered structure mixed terms thereby potentially enabling new rewrite steps possible usually severe problem dealt synchronizing steps however b serious issue main source almost problems disjoint unions destructive steps possible via collapsing rules cf eg theorems 3 4 constructor sharing unions interference fusion previously separated layers also possible via shared constructor lifting rules basic example term rewriting following variant toyamas counterexample example 7 two constructor sharing trss terminating union admits cycle observe application two constructor lifting rules enables application rule previously possible taking additional source interference account namely besides collapsing rules also constructor lifting rules results disjoint unions also extend constructor sharing case first let us look illuminating example example 8 consider two constructor sharing csrss shared constructor c systems obviously terminating union admits cycle observe csrs r1 shared symbol lifting nonduplicating trs duplicating csrs whereas r2 constructor lifting nonduplicating csrs next general result need additional definition definition 8 let f r f csrs f f say f fully replacing n arity f ready generalize theorem 4 constructor sharing case cf 17 theorem 34 theorem 9 theorem 4 extended let r1 two constructor sharing compat ible terminating csrss shared constructors fully replacing union r nonterminating one systems fpterminating system shared symbol lifting ie collapsing constructor lifting proof sketch proof idea proof similar one trs case ie theorem 34 17 given minimal counterexample union ie infinite ground derivation minimal rank lets say top layer f1 abstracting transformation defined abstracts concrete syntactical inner parts terms retains relevant syntactical f1information may eventually pop fuse topmost f1 layer dierence recursive definition abstraction function use r instead 17 abstracted f1information collected brought unique syntactical form via fresh binary function symbol g fresh constant preparations dicult show contains infinitely many outer reduction steps b outer step translates corresponding outer r1 1step using rule position c contains infinitely many inner reduction steps destructive level 2 hence must r2 2 steps inner step destructive level 2 translates nonempty sequence rewrite steps using projection rules g ie inner step destructive level 2 hence r1 1 r2 2step translates possibly empty sequence rewrite steps using r1 gx x gx observe without assumption shared constructors fully replacing properties b e need hold general 17 c implies r2 2 shared lifting b e obtain infinite r1 gx x gx derivation means r1 1 fp terminating note case trss result holds finite csrss also finitely branching ones contrast disjoint union case doesnt hold infinitely branching systems cf 38 corresponding counterexample infinitely branching constructor sharing trss roughly speaking failure due fact nonfully replacing constructors contextsensitivity makes abstracting transformation interfere reduction steps nonmonotonic way without assumption statement theorem hold general witnesses example clearly csrss r1 r2 example fpterminating union even terminating note shared constructor c fully replacing next let us consider extension syntactical modularity criteria theorem 3 constructor sharing unions theorem 10 let r1 two constructor sharing compatible terminating csrss let r union following hold r terminates r1 layerpre serving ii r terminates r1 nonduplica ting iii r terminates one systems layer preserving nonduplicating proof proof essentially analogous one theorem 3 one disjoint csrss example 9 ready give modular proof termination obj program figure 1 consider csrs r example 1 constructor sharing compatible union note rpoterminating use precedence true false hence terminating hand takes rpoterminating use precedence take nil inf length 0 hence terminating also polynomial termination easily proved using cime 20 system since layerpreserving nonduplicating theorem 10 conclude termination r according 27 implies termination obj program example 10 consider two constructor sharing trss c ie termination using wellfounded polynomial ordering together 12 giesl middeldorp show termination r1 cannot proved existing transformation complete one see section 33 however proof termination r1 reported literature yet able give simple modular proof note r1 ter minating hence r1 r2 terminating since r1 layerpreserving nonduplicating termination r1 theorem 10 trss theorem 9 whole number direct indirect corollaries stating concrete modularity criteria termination case constructor sharing unions detail rather focus results along lines sections 42 44 course negative counterexamples section 42 examples 5 6 immediately extend constructor sharing case yet positive results regarding modularity weak termination properties win wn sin extend disjoint csrss constructor sharing ones theorem 11 theorem 5 extended win preserved unions constructor sharing csrss satisfying cb b wn preserved unions constructor sharing csrss satisfying cb c sin preserved unions constructor sharing csrss satisfying cb proof proofs b c essentially theorem 5 namely structural induction case analysis dierence case shared constructor root may topwhite topblack principal subterms common modularity terminology cf eg 17 constructor symbol root doesnt disturb reasoning proofs condition cb ensures innermost term rewrite derivation constructed proofs induction step also still innermost ie proofs go csrss well similarly obtain theorem 12 theorem 8 extended let r1 two constructor sharing compati ble terminating csrss satisfying lhrv cb suppose r1 1 r2 2 locally confluent overlay ing constructor sharing union r also overlaying terminating confluent hence complete proof analogous proof theorem 8 using theorem 11 instead theorem 5 5 related work far know results first deal analysis modular properties csrss properties csrss fairly well investigated especially regarding termination proof techniques also concerning properties verification criteria cf eg 25 26 28 27 29 31 30 47 8 12 13 15 14 recent interesting developments include particular approach giesl middeldorp proving innermost termination csrss via transformations ordinary trss along lines 12 well rpostyle approach 2 directly proving termination csrss without intermediate transformations without recurring ordinary trss comparison results approach latter ones mentioned remains done 51 perspectives open problems paper started systematically investigate modular aspects contextsensitive rewriting almost exclusively focussed termination properties course beginning research done shown taking additional complications arising contextsensitivity carefully account indeed possible extend couple fundamental modularity results trss general case csrss sense obtained results quite encouraging also seem indicate considerable amount structural knowledge modularity term rewriting taken contextsensitive rewriting however also turned couple new phenomena ugly properties crucially interfere traditional approach trss particular turns syntactical restrictions cb lhrv replacement play crucial role conditions certainly considerable restriction practice hence also thoroughly investigated apart disjoint union case also shown obtained results disjoint unions extend nicely case shared construc tors hand course modularity results always help simple example following example 11 two csrss constructor sharing termi nating union r terminating however none modularity results applicable reader invited verify intuitively reason nonapplicability generic modularity results lies fact termination proof r must somehow exploit internal termination arguments bit precisely decrease first argument second rule lexicographically dominates happens second argument make explicit consider also following semantically meaningless variant clearly r3 also terminating however union constructor sharing csrss r1 r3 becomes nonterminating nthsx failure modularity criteria becomes comprehensible namely syntactical modularity structure combined r3 former case got termination latter one nontermination thus unrealistic expect applicability general modularity result particular example yet consider still another system consider union terminating composable csrss might wish conclude termination combination modularity criterion seem hopeless words expect many results hold constructor sharing csrss also extend unions composable csrss additionally may share defined function symbols provided share defining rules cf 39 extent also hierarchical combinations csrss cf eg 21 4 however since modularity known errorprone domain concrete claim carefully verified subject future work 6 conclusion presented first steps thorough modularity analysis contextsensitive rewriting paper mainly focussed termination properties results obtained encouraging remains lot work done 7 r rewriting recursive path orderings contextsensitive principles maude hierarchical termination rewriting operator evaluation strategies termination rewriting local strategies principles obj2 overview cafe specification environment algebraic approach creating transformation techniques contextsensitive rewrite systems transforming contextsensitive rewrite systems innermost termination contextsensitive rewriting transformation techniques contextsensitive rewrite systems introducing obj generalized su abstract relations restricted termination confluence properties rewrite systems termination confluence properties structured rewrite systems modularity confluence simplified proof modular proofs completeness hierarchical term rewriting systems modularity simple termination term rewriting systems shared constructors termination combination composable term rewriting systems modularity noncopying term rewriting termination contextsensitive rewriting rewriting termination ondemand rewriting termination obj programs termination rewriting strategy annotations transfinite rewriting semantics term rewriting systems termination canonical contextsensitive rewriting modular properties term rewriting systems modular properties conditional term rewriting systems completeness combinations conditional constructor systems completeness combinations constructor systems modular properties composable term rewriting systems modularity termination term rewriting systems modular properties composable term rewriting systems termination direct sum term rewriting systems counterexamples termination direct sum term rewriting systems churchrosser property direct sum term rewriting systems termination direct sums leftlinear complete term rewriting systems termination contextsensitive rewriting tr churchrosser property direct sum term rewriting systems counterexamples termination direct sum term rewriting systems termination direct sum termrewriting systems sufficient condition termination direct sum term rewriting systems modularity simple termination term rewriting systems shared constructors completeness combinations constructor systems modularity confluence modular properties conditional term rewriting systems completeness combinations conditional constructor systems modularity termination term rewriting systems modular proofs completeness hierarchical term rewriting systems modularity noncopying term rewriting modular termination italicritalicconsistent leftlinear term rewriting systems modular properties composable term rewriting systems termination direct sums leftlinear complete term rewriting systems rewriting principles obj2 contextsensitive rewriting strategies termination rewriting strategy annotations termination contextsensitive rewriting rewriting contextsensitive acrewriting transforming contextsensitive rewrite systems transfinite rewriting semantics term rewriting systems termination canonical contextsensitive rewriting termination contextsensitive rewriting recursive path orderings contextsensitive hierachical termination termination ondemand rewriting termination obj programs overview cafe specification environmentan algebraic approach creating verifying maintaining formal specifications networks ctr beatriz alarcn ral gutirrez jos iborra salvador lucas proving termination contextsensitive rewriting muterm electronic notes theoretical computer science entcs 188 p105115 july 2007 bernhard gramlich salvador lucas simple termination contextsensitive rewriting proceedings 2002 acm sigplan workshop rulebased programming p2942 october 05 2002 pittsburgh pennsylvania jrgen giesl aart middeldorp transformation techniques contextsensitive rewrite systems journal functional programming v14 n4 p379427 july 2004 salvador lucas contextsensitive rewriting strategies information computation v178 n1 p294343 october 10 2002 salvador lucas proving termination contextsensitive rewriting transformation information computation v204 n12 p17821846 december 2006
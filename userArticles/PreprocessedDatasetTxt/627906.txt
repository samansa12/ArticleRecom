efficient data mining path traversal patterns abstractin paper explore new data mining capability involves mining path traversal patterns distributed informationproviding environment documents objects linked together facilitate interactive access solution procedure consists two steps first derive algorithm convert original sequence log data set maximal forward references filter effect backward references mainly made ease traveling concentrate mining meaningful user access sequences second derive algorithms determine frequent traversal patternsie large reference sequencesfrom maximal forward references obtained two algorithms devised determining large reference sequences one based hashing pruning techniques improved option determining large reference sequences batch reduce number database scans required performance two methods comparatively analyzed shown option selective scan advantageous lead prominent performance improvement sensitivity analysis various parameters conducted b introduction due increasing use computing various applications importance database mining growing rapid pace recently progress barcode technology made possible retail organizations collect store massive amounts sales data catalog companies also collect sales data orders received noted analysis past transaction data provide valuable information customer buying behavior thus improve quality business decisions put sale merchandises placed together shelves customize marketing programs name essential collect sufficient amount sales data meaningful conclusion drawn therefrom result amount processed data tends huge hence important devise efficient algorithms conduct mining data note various data mining capabilities explored literature one important data mining problems mining association rules 3 4 13 15 example given database sales transactions desirable discover associations among items presence items transaction imply presence items transaction also mining classification approach trying develop rules group data tuples together based certain common features explored ai domain 16 17 context databases 2 6 12 mining spatial databases conducted 14 another source data mining ordered data stock market point sales data interesting aspects explore ordered data include searching similar sequences 1 19 eg stocks similar movement stock prices sequential patterns 5 eg grocery items bought set visits sequence noted data mining applicationdependent issue different applications explored require different mining techniques cope proper problem identification formulation therefore important part whole knowledge discovery process paper shall explore new data mining capability involves mining access patterns distributed information providing environment documents objects linked together facilitate interactive access examples information providing environments include world wide web www 11 online services prodigy compuserve america online users seeking information interest travel one object another via corresponding facilities ie hyperlinks provided clearly understanding user access patterns environments help improve system design eg provide efficient access highly correlated objects better authoring design pages etc also able lead better marketing decisions eg putting advertisements proper places better customeruser classification behavior analysis etc capturing user access patterns environments referred mining traversal patterns paper note although efforts elaborated upon analyzing user behavior 8 9 10 little result reported dealing algorithmic aspects improve execution traversal pattern mining part explained reason information providing services though great potential mostly infancy customer analysis may still remain coarser level user occupationage study addition important note pointed 8 since users traveling along information providing services search desired information objects visited locations rather content showing difference traversal pattern problem others mainly based customer transactions unique feature traversal pattern problem unavoidably increases difficulty extracting meaningful information sequence traversal data however information providing services becoming increasingly popular nowadays growing demand capturing user behavior improving quality services result problem mining traversal patterns become important address immediately consequently shall explore paper problem mining traversal patterns solution procedure consists two steps first derive algorithm called algorithm mf standing maximal forward references convert original sequence log data set traversal subsequences defined section 2 traversal subsequence represents maximal forward reference starting point user access explained later step converting original log sequence set maximal forward references filter effect backward references mainly made ease traveling enable us concentrate mining meaningful user access sequences second derive algorithms determine frequent traversal patterns termed large reference sequences maximal forward references obtained large reference sequence reference sequence appeared sufficient number times database note problem finding large reference sequences similar finding large itemsets association rules 3 large itemset set items appearing sufficient number transactions however different reference sequence mining traversal patterns consecutive references maximal forward reference whereas large itemset mining association rules combination items transaction consequence although several schemes mining association rules reported literature 3 4 15 difference two problems calls design new algorithms determining large reference sequences explicitly devise two algorithms determining large reference sequences first one referred fullscan fs algorithm essentially utilizes techniques hashing pruning solving discrepancy traversal patterns association rules mentioned although trimming transaction database proceeds later passes algorithm fs required scan transaction database pass contrast properly utilizing candidate reference sequences second algorithm devised referred selectivescan ss algorithm able avoid database scans passes reduce disk io cost involved specifically algorithm ss option using candidate reference set generate subsequent candidate reference sets delaying determination large reference sets later pass database scanned since ss scan database obtain large reference set pass database scans saved experimental studies conducted using synthetic workload generated based referencing logged traces performance two methods fs ss comparatively analyzed shown option selective scan advantageous algorithm ss thereby outperforms algorithm fs general sensitivity analysis various parameters also conducted paper organized follows problem formulation given section 2 algorithm mf identify maximal forward references described section 31 two algorithms fs ss determining large reference sequences given section 32 performance results presented section 4 section 5 contains summary problem formulation pointed earlier information providing environment objects linked together users apt traverse objects back forth accordance links icons provided result node might revisited location rather content example www environment reach sibling node user usually inclined use backward icon forward selection instead opening new url consequently extract meaningful user access patterns original log database naturally want take consideration effect backward traversals discover real access patterns interest view assume paper backward reference mainly made ease traveling browsing concentrate discovery forward reference patterns specifically backward reference means revisiting previously visited object user access backward references occur forward reference path terminates resulting forward reference path termed maximal forward reference maximal forward reference obtained back track starting point forward referencing resume another forward reference path addition occurrence null source node also indicates termination ongoing forward reference path beginning new one deferring formal description algorithm determine maximal forward references ie algorithm mf section 31 give illustrative example maximal forward references suppose traversal log contains following traversal path user g h g w u v g shown figure 1 verified algorithm mf set maximal forward references user fabcdabegh g maximal forward references users obtained map problem finding frequent traversal patterns one finding frequent occurring consecutive subsequences among maximal forward references large reference sequence reference sequence appeared sufficient number times set maximal forward references number times reference sequence appear order qualified large reference sequence called minimal support large kreference large reference sequence k elements denote set large kreferences l k candidate set c k c k obtained l kgamma1 4 contains kreferences may appear l k explicitly c k superset l k worth mentioning large reference sequences determined maximal reference sequences obtained straightforward manner maximal reference sequence large reference sequence contained maximal reference sequence example suppose fab beadcgghbgg set large 2references ie l 2 fabecghg set large 3references ie l 3 resulting maximal reference sequences adbgabe cgh maximal reference sequence corresponds hot access pattern information providing service entire procedure mining traversal patterns summarized follows procedure mining traversal patterns step 1 determine maximal forward references original log data g figure 1 illustrative example traversal patterns step 2 determine large reference sequences ie l k k 1 set maximal forward references step 3 determine maximal reference sequences large reference sequences since extraction maximal reference sequences large reference sequences ie step straightforward shall henceforth focus steps 1 2 devise algorithms efficient determination large reference sequences 3 algorithm traversal pattern shall describe section 31 algorithm mf converts original traversal sequence set maximal forward references mapping problem finding frequent traversal patterns one finding frequent consecutive subsequences develop two algorithms called fullscan fs selectivescan ss mining traversal patterns 31 maximal forward references general traversal log database contains link traversed pair source desti nation part log database called referer log 7 beginning new path linked previous traversal source node null given traversal sequence user shall map multiple subsequences represents maximal forward reference algorithm finding maximal forward references given follows first traversal log database sorted user ids resulting traversal path user pairs ordered time algorithm mf applied user path determine maximal forward references let f denote database store resulting maximal forward references obtained algorithm algorithm find maximal forward references string null initialization string used store current forward reference path also set flag indicate forward traversal step 2 let equal null beginning new traversal begin write current string null database f string go step 5 step 3 b equal reference say jth reference string crossreferencing back previous reference begin f equal 1 write string database f discard references jth one string go step 5 step 4 otherwise append b end string continuing forward traversal f equal 0 set step 5 set 1 sequence completed scanned go step 2 consider traversal scenario figure 1 example verified first backward reference encountered 4th move ie c point maximal forward reference abcd written f step 3 next move ie c b although first conditional statement step 3 true nothing written f since flag meaning reverse traversal subsequent forward references put abegh string written f reverse reference h g table 1 example execution algorithm mf move string output f 9 abeg abegh 14 ao aou encountered execution scenario algorithm mf input figure 1 given table 1 noted cases traversal log record obtained contains destination references instead pair references example www browsing request message may contain destination url traversal sequence form fd user even input still convert set maximal forward references difference case cannot identify breakpoint user picks new url begin new traversal path meaning two consecutive maximal forward references example abeh wxy z may treated one path ie abehwxyz certainly constraint ie without ids source nodes could increase computational complexity paths considered become longer however constraint little effect identifying frequent reference subsequences since logical link h w subsequence containing hw unlikely occur frequently hence reference containing pattern hw unlikely emerge large reference later therefore algorithm mf fact employed cases ids source nodes available 32 determining large reference sequences database containing maximal forward references users f constructed derive frequent traversal patterns identifying frequent occurring reference sequences f sequence 1 n said contain r 1 r k consecutive subsequence exists k example bahpm said contain ahp sequence k references r 1 r k called large kreference sequence sufficient number users maximal forward references f containing r 1 r k consecutive subsequence pointed problem finding large reference sequences different finding large itemsets association rules thus calls design new algorithms consequently shall derive paper two algorithms mining traversal patterns first one called fullscan fs algorithm essentially utilizes concept dhp 15 ie hashing pruning solving discrepancy traversal patterns association rules dhp two major features determining association rules one efficient generation large itemsets effective reduction transaction database size scan although trimming transaction database proceeds later passes fs required scan transaction database pass contrast properly utilizing candidate reference sequences second algorithm referred selectivescan ss algorithm improved option determining large reference sequences batch reduce number database scans required 321 algorithm full scan algorithm fs utilizes key ideas dhp algorithm details dhp found 15 example scenario determining large itemsets candidate itemsets given appendix 1 shown 15 utilizing hash technique dhp efficient generation candidate itemsets particular large 2itemsets thus greatly improving performance bottleneck whole process addition dhp employs effective pruning techniques progressively reduce transaction database size recall l k represents set large kreferences c k set candidate kreferences c k general superset l k scanning f fs gets l 1 makes hash table ie count number occurrences 2reference similarly dhp starting fs generates c k based hash table count obtained previous pass determines set 1 example technique hashing employed dhp reduce number candidate itemsets shown large kreferences reduces size database next pass makes hash table determine candidate 1references note mining association rules set candidate references c k generated joining l kgamma1 denoted l due difference traversal patterns association rules modify approach follows two distinct reference sequences l join together form kreference sequence either r contains dropping first element one sequence last element sequence remaining two identical note k small especially case deriving c k joining l kgamma1 result large number candidate references hashing technique thus helpful case k increases size l decrease significantly 15 found generally beneficial fs generate c k directly l using hashing k 3 count occurrences kreference c k determine l k need scan trimmed version database f set maximal forward references determine among kreferences c k large kreferences scan entire database kreferences c k count exceeding threshold become l k l k nonempty iteration continues next pass ie pass k 1 dhp every time database scanned database trimmed fs improve efficiency future scans 322 algorithm selective scan ss algorithm ss similar algorithm fs also employs hashing pruning techniques reduce cpu io costs different latter algorithm ss properly utilizing information candidate references prior passes able avoid database scans passes thus reducing disk io cost method ss avoid database scans reduce disk io cost described recall algorithm fs generates small number candidate 2references using hashing technique fact small c 2 used generate candidate 3references clearly c 0 3 generated c 2 c 2 instead l 2 l 2 size greater jc 3 j c 3 generated l 2 l 2 however jc 0 3 j much larger jc 3 j c 2 c 0 3 stored main memory find l 2 l 3 together next scan database performed thereby saving one round database approach generating ck directly lkgamma1 proposed algorithm apriori 4 generating candidate itemsets association rules scan seen using concept one determine l k two scans database ie one initial scan determine l 1 final scan determine large reference sequences assuming c 0 generated c 0 kept memory note minimum support relatively small potentially large references long c k l k could become large c 0 generated c 0 may cost much cpu time generate subsequent c 0 candidate sets large references since size c j may become huge quickly thus compromising benefit saving disk io cost illustrative example appendix c 3 determined c 2 c 2 instead l 2 l 2 c 3 would ffabcg fabeg faceg fbcegg fact suggests timely database scan determine large reference sequences fact pay database scan one obtain large reference sequences determined thus far say lm construct set candidate 1references cm1 based lm point according experiments found jc 0 k 2 usually beneficial database scan obtain l k1 set candidate references becomes big fs time database scanned database trimmed ss improve efficiency future scans derive c 0 k2 l k1 note c 0 k2 fact equal c k2 use c 0 j derive k2 process continues set candidate j1references becomes empty illustrative examples fs ss given table 2 number reference paths minimum support extensive experiments conducted section 4 example run fs performs database scan pass determine corresponding large reference sequences resulting six database scans hand ss scans database three times skipping database scans passes 2 4 5 able obtain result cpu disk io times fs 1948 seconds 308 seconds respectively whereas ss 1875 seconds 178 seconds respectively considering cpu io times execution time ratio ss fs 073 showing prominent advantage ss performance results assess performance fs ss conducted several experiments determine large reference sequences using rs6000 workstation model 560 methods used table 2 results example run fs ss algorithm fs algorithm ss root leaf node 25 go back parent node 75 jump internal node parent node jump internal node 3 internal nodes parent node children nodes internal jump node b figure 2 traversal tree simulate www generate synthetic data described section 41 performance comparison two methods given section 42 sensitivity analysis conducted section 43 41 generation synthetic traversal paths experiment browsing scenario world wide web www environment simulated generate synthetic workload determine values parameters referenced logged traces collected gateway working location 18 first traversal tree constructed mimic www structure whose starting position root node tree traversal tree consists internal nodes leaf nodes figure 2a shows example traversal tree number child nodes internal node referred fanout determined uniform distribution within given range height subtree whose subroot child node root node determined poisson distribution mean h height subtree whose subroot child internal node n determined poisson distribution mean equal fraction maximum height internal node n height tree controlled value h traversal path consists nodes accessed user size traversal path picked poisson distribution mean equal jp j first node root node traversal path generated probabilistically within traversal tree follows internal node determine next hop according predetermined probabilities essen tially edge connecting internal node assigned weight weight corresponds probability edge next accessed user shown figure 2b weight parent node assigned p 0 generally 1 n number child nodes probability traveling child node p determined exponential distribution unit mean normalized sum weights child nodes equal internal node internal jump weight jump p j changed p 0 corresponding probability child node changed sum probabilities associated node remains one path arrives leaf node next move would either parent node backward probability 025 internal node aggregate probability 075 internal nodes tree internal jumps go nodes number internal nodes internal jumps denoted n j set 3 internal nodes general cases sensitivity varying n j also analyzed nodes internal jumps decided randomly among internal nodes table 3 summarizes meaning various parameters used simulations 42 performance comparison fs ss figure 3 represents execution times two methods fs ss 01 hxpy means x height tree average size reference paths d200k means number reference paths 200000 tree h10 obtained height tree 10 fanout internal node 4 7 root node consists 7 child nodes number internal nodes 16200 number leaf nodes 73006 number internal nodes internal jumps thus 16200 thetan j 486 note cpu time sec minimum support c c ss theta theta theta theta theta theta io time sec minimum support c c c ss theta theta theta theta theta theta theta51525 cpu time sec minimum support c c c c c c ss theta theta theta theta theta theta io time sec minimum support c c c c c c ss theta theta theta theta theta theta theta103050 cpu time sec minimum support c c c ss theta theta theta theta theta theta io time sec minimum support c c c c c c ss theta theta theta theta theta theta theta figure 3 execution times fs ss table 3 meaning various parameters h height traversal tree f number child nodes fanout n j number internal nodes internal jump backward weight probability parent node probability internal jump parameter zipflike distribution hxpy x height tree jdj number reference paths size database forward references l k candidate kreference sequences large kreference sequences size reference paths total number nodes increases height tree increases make experiment tractable reduced fanout 2 gamma 5 tree h20 height 20 tree contained 616595 internal nodes 1541693 leaves figure 3 left graph hxpyd200k represents cpu time find large reference sequences right graph shows io time find disk io time set 2 mbsec 1 mb buffer used main memory seen figure 3 algorithm ss general outperforms fs performance difference becomes prominent io cost taken account provide insights performance addition table 2 section 3 table 4 shows results two methods table 4 fs scans database eight times find large reference sequences whereas ss involves three database scans note initial scans disk io involved fs ss include disk read disk write ie writing trimmed version database back disk io time two methods shown figure 4 considering cpu io times total execution time fs 14394 seconds ss 10089 seconds note execution time ratio fs ss 070 case slightly better one associated table 2 figure 5 shows scaleup experiments cpu io times method increase linearly database size increases experiment traversal tree 10 levels fanout internal nodes 4 7 minimum support set 075 seen ss consistently outperforms fs database size increases table 4 number large reference sequences execution times h20p20 algorithm fs algorithm ss ss skips database scans k24567 io time second fs ss figure 4 io cost fs ss pass 200k 400k 600k 800k 1000k execution time sec database size c c c c c sscpu theta theta theta theta theta theta figure 5 execution time fs ss database size increases 43 sensitivity analysis since algorithm ss general outperforms fs without loss generality shall conduct section sensitivity analysis various parameters algorithm ss performance evaluation carried condition database size 200000 average size traversal paths 10 ie jp minimum support 075 figure 6 shows number large reference sequences probability backward internal node p 0 varies 01 05 probability increases number large reference sequences decreases possibility forward traveling becomes smaller figure 7 shows number large reference sequences number child nodes internal nodes ie fanout f varies three corresponding traversal trees height 8 tree consists 483 internal nodes 1267 leaf nodes tree second bar consists 11377 internal nodes 62674 leaf nodes one third bar consists 74632 internal nodes 634538 leaf nodes results show number large reference sequences decreases degree fanout increases larger fanout traversal paths likely dispersed several branches thus resulting fewer large reference sequences clearly large reference sequences decreases execution time find p001 p002 p003 p004 p0052060100number large reference sequences figure number large reference sequences backward weight p 0 varied also decreases figure 8 gives number large reference sequences probability traveling child node internal node determined zipflike distribution different values parameter zipflike distribution considered zipflike distribution branching probabilities child nodes generated follows probability p ith child node accessed traversal path normalization constant n number child nodes internal node get p normalized section 41 setting parameter pure zipf distribution highly skewed whereas corresponds uniform distribution results show number large reference sequences increases corresponding probabilities skewed table 5 shows performance results ss number internal nodes internal jumps n j varies 3 27 total internal nodes number large reference sequences decreases slightly n j increases meaning less likely large reference f 2 4 f 5 11100300500number large reference sequences figure 7 number large reference sequences fanout f varied degree skew number large reference sequences figure 8 number large reference sequences parameter zipflike distribution varied table 5 number large reference sequences percentage internal jumps n j varied 9 table number large reference sequences height traversal tree h varied sequences jumps traversal paths noted performance ss less sensitive parameter others table 6 shows results ss height traversal tree varies fanout 2 5 height increases numbers internal nodes leaf nodes increase exponentially height traversal tree increased 3 20 height traversal tree increases number candidate nodes l 1 increases execution time find l 1 thus increases hand jl decreases height tree increases since average visit node decreases number large reference sequences slightly decreases 1 k 3 height tree increases 5 20 5 conclusion paper explored new data mining capability involves mining traversal patterns information providing environment documents objects linked together facilitate interactive access solution procedure consisted two steps first derived algorithm mf convert original sequence log data set maximal forward references filtered effect backward references concentrated mining meaningful user access sequences second developed algorithms determine large reference sequences maximal forward references obtained two algorithms devised determining large reference sequences one based hashing pruning techniques improved option determining large reference sequences batch reduce number database scans required performance two methods comparatively analyzed shown option selective scan advantageous algorithm ss thus general outperformed algorithm fs sensitivity analysis various parameters conducted acknowledgements ms chen part supported national science council project nsc 862621e002 023t taiwan roc j park supported grants professors sungshin womens university 1997 korea r efficient similarity search sequence databases interval classifier database mining applications mining association rules sets items large databases fast algorithms mining association rules large databases mining sequential patterns knowledge mining imprecise querying classificationbased approach hypertext transfer protocolhttp10 backtracking multiplewindow hypertext environment browsing hypertext cognitive study characterizing browsing strategies worldwide web world wide web unleashed discovery multiplelevel association rules large databases efficient effective clustering methods spatial data mining effective hash based algorithm mining association rules analysis presentation strong rules induction decision trees personal communication combinatorial pattern discovery scientific data preliminary results tr ctr avramouli j garofalakis j kavvadias c makris panagis e sakkopoulos popular web hot spots identification visualization special interest tracks posters 14th international conference world wide web may 1014 2005 chiba japan holmquist n hari narayanan tightly coupling authoring evaluation integrated tool support iterative design interactive hypermedia educational manuals proceedings conference designing interactive systems processes practices methods techniques p155164 august 1719 2000 new york city new york united states wenwu lou hongjun lu efficient prediction web accesses proxy server proceedings eleventh international conference information knowledge management november 0409 2002 mclean virginia usa huafu li suhyin lee mankwan mining webclick streams path traversal patterns proceedings 13th international world wide web conference alternate track papers posters may 1921 2004 new york ny usa jianchih ou changhung lee mingsyan chen web log mining adaptive support thresholds special interest tracks posters 14th international conference world wide web may 1014 2005 chiba japan alexandros nanopoulos yannis manolopoulos maciej zakrzewicz tadeusz morzy indexing web accesslogs pattern queries proceedings 4th international workshop web information data management november 0808 2002 mclean virginia usa mao chen andrea lapaugh jaswinder pal singh predicting category accesses user structured information space proceedings 25th annual international acm sigir conference research development information retrieval august 1115 2002 tampere finland tiffany tang gordon mccalla student modeling webbased learning environment data mining approach eighteenth national conference artificial intelligence p967968 july 28august 01 2002 edmonton alberta canada kunta chuang mingsyan chen frequent pattern discovery memory constraint proceedings 14th acm international conference information knowledge management october 31november 05 2005 bremen germany hai zhuge jie liu fuzzy collaborative assessment approach knowledge grid future generation computer systems v20 n1 p101111 january 2004 brenda f miles vir v phoha bipartite clique topological paradigm wwweb user search customization proceedings 43rd annual southeast regional conference march 1820 2005 kennesaw georgia ajumobi udechukwu ken barker reda alhajj framework representing navigational patterns full temporal objects acm sigecom exchanges v5 n2 p2333 november 2004 wenchih peng mingsyan chen shared data allocation mobile computing system exploring local global optimization ieee transactions parallel distributed systems v16 n4 p374384 april 2005 minos n garofalakis rajeev rastogi kyuseok shim spirit sequential pattern mining regular expression constraints proceedings 25th international conference large data bases p223234 september 0710 1999 tzungshi chen shihchun hsu mining frequent treelike patterns large datasets data knowledge engineering v62 n1 p6583 july 2007 yunjuan xie vir v phoha web user clustering access log using belief function proceedings 1st international conference knowledge capture october 2223 2001 victoria british columbia canada tseng cingfu tsui efficient method mining associated service patterns mobile web environments proceedings acm symposium applied computing march 0912 2003 melbourne florida chengru lin changhung lee mingsyan chen philip yu distributed data mining chain store database short transactions proceedings eighth acm sigkdd international conference knowledge discovery data mining july 2326 2002 edmonton alberta canada anindya datta kaushik dutta helen thomas debra vandermeer krithi ramamritham accelerating dynamic web content generation ieee internet computing v6 n5 p2736 september 2002 akihiro inokuchi takashi washio hiroshi motoda complete mining frequent patterns graphs mining graph data machine learning v50 n3 p321354 march changhung lee chengru lin mingsyan chen sliding window filtering efficient method incremental mining timevariant database information systems v30 n3 p227244 may 2005 garofalakis r rastogi k shim mining sequential patterns regular expression constraints ieee transactions knowledge data engineering v14 n3 p530552 may 2002 karuna p joshi anupam joshi yelena yesha using warehouse analyze web logs distributed parallel databases v13 n2 p161180 march qinbao song martin shepperd mining web browsing patterns ecommerce computers industry v57 n7 p622630 september 2006 chinchen chang chihyang lin henry chou perfect hashing schemes mining traversal patterns fundamenta informaticae v70 n3 p185202 april 2006 alexander mikroyannidis babis theodoulidis theoretical framework implementation architecture self adaptive web sites proceedings 2004 ieeewicacm international conference web intelligence p558561 september 2024 2004 roderick l lee web mining creating structure chaos managing data mining technologies organizations techniques applications idea group publishing hershey pa yenliang chen yahan hu constraintbased sequential pattern mining consideration recency compactness decision support systems v42 n2 p12031215 november 2006 wenchih peng mingsyan chen developing data allocation schemes incremental mining user moving patterns mobile computing system ieee transactions knowledge data engineering v15 n1 p7085 january alexandros nanopoulos yannis manolopoulos efficient similarity search market basket data vldb journal international journal large data bases v11 n2 p138152 october 2002 minos garofalakis rajeev rastogi scalable data mining model constraints acm sigkdd explorations newsletter v2 n2 p3948 dec 2000 kamal ali steven p ketchpel golden path analyzer using divideandconquer cluster web clickstreams proceedings ninth acm sigkdd international conference knowledge discovery data mining august 2427 2003 washington dc shaoshin hung tingchia kuo damon shingmin liu efficient mining clustering algorithm interactive walkthrough traversal patterns proceedings 2004 ieeewicacm international conference web intelligence p356362 september 2024 2004 qiankun zhao sourav bhowmick le gruenwald wamminer search web access motifs historical web log data proceedings 14th acm international conference information knowledge management october 31november 05 2005 bremen germany changhung lee chengru lin mingsyan chen slidingwindow filtering efficient algorithm incremental mining proceedings tenth international conference information knowledge management october 0510 2001 atlanta georgia usa jun wook lee ok hyun paek keun ho ryu temporal moving pattern mining locationbased service journal systems software v73 n3 p481490 novemberdecember 2004 yihung wu arbee l p chen prediction web page accesses proxy server log world wide web v5 n1 p6788 2002 huang fuchun peng aijun dale schuurmans dynamic web log session identification statistical language models journal american society information science technology v55 n14 p12901303 december 2004 weiyang lin sergio alvarez carolina ruiz efficient adaptivesupport association rule mining recommender systems data mining knowledge discovery v6 n1 p83105 january 2002 zhixiang chen ada waichee fu frank chihung tong optimal algorithms finding user access sessions large web logs world wide web v6 n3 p259279 september ali amiri dare share protecting sensitive knowledge data sanitization decision support systems v43 n1 p181191 february 2007 igor cadez david heckerman christopher meek padhraic smyth steven white modelbased clustering visualization navigation patterns web site data mining knowledge discovery v7 n4 p399424 october jos borges mark levene fine grained heuristic capture web navigation patterns acm sigkdd explorations newsletter v2 n1 p4050 june 2000 yenliang chen shihsheng chen pingyu hsu mining hybrid sequential patterns sequential rules information systems v27 n5 p345362 july 2002 george pallis lefteris angelis athena vakali validation interpretation web users sessions clusters information processing management international journal v43 n5 p13481367 september 2007 weiguang teng chengyue chang mingsyan chen integrating web caching web prefetching clientside proxies ieee transactions parallel distributed systems v16 n5 p444455 may 2005 singlepass mining path traversal patterns streaming web clicksequences computer networks international journal computer telecommunications networking v50 n10 p14741487 14 july 2006 janming ho entropybased link analysis mining web informative structures proceedings eleventh international conference information knowledge management november 0409 2002 mclean virginia usa shaoshin hung damon shingmin liu efficient reduction access latency object correlations virtual environments eurasip journal applied signal processing v2007 n1 p178178 1 january 2007 alexandros nanopoulos dimitrios katsaros yannis manolopoulos data mining algorithm generalized web prefetching ieee transactions knowledge data engineering v15 n5 p11551169 september holmquist n hari narayanan integrated architecture tightly coupled design evaluation educational multimedia information sciencesinformatics computer science international journal v140 n1 p127152 january 2002 karuna p joshi anupam joshi yelena yesha raghu krishnapuram warehousing mining web logs proceedings 2nd international workshop web information data management p6368 november 0206 1999 kansas city missouri united states hungyu kao shianhua lin janming ho mingsyan chen mining web informative structures contents based entropy analysis ieee transactions knowledge data engineering v16 n1 p4155 january 2004 pranam kolari anupam joshi web mining research practice computing science engineering v6 n4 p4953 july 2004 anthony j lee yaote wang efficient data mining calling path patterns gsm networks information systems v28 n8 p929948 december jose pea intelligent web mining intelligent exploration web physicaverlag gmbh heidelberg germany
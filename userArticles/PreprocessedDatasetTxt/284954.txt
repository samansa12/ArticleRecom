approximation algorithms feedback vertex set problem applications constraint satisfaction bayesian inference feedback vertex set undirected graph subset vertices intersects vertex set cycle graph given undirected graph g n vertices weights vertices polynomialtime algorithms provided approximating problem finding feedback vertex set g smallest weight weights vertices g equal performance ratio attained algorithms 42n improves previous algorithm achieved approximation factor osqrtlog n case general vertex weights performance ratio becomes min2delta2 4 log2 n delta denotes maximum degree g special case planar graphs ratio reduced 10 interesting special case weighted graphs performance ratio 42n achieved one prescribed subset vertices socalled blackout vertices allowed participate feedback vertex setit shown algorithms improve search performance constraint satisfaction problems application area bayesian inference graphs blackout vertices also presented b introduction e undirected graph let weight function vertices g cycle g path whose two terminal vertices coincide feedback vertex set g subset vertices f v g cycle g passes least one vertex f words feedback vertex set f set vertices g removing f g along edges incident f forest obtained minimum feedback vertex set weighted graph g w feedback vertex set g minimum weight weight minimum feedback vertex set denoted g w weighted feedback vertex set wfvs problem defined finding minimum feedback vertex set given weighted graph g w special case w constant function 1 called unweighted feedback vertex set ufvs problem given graph g integer k problem deciding whether g 1 k known npcomplete gj79 pp 191192 hence natural look efficient approximation algorithms feedback vertex set problem particularly view recent applications algorithms artificial intelligence show sequel suppose algorithm finds feedback vertex set fa given undirected weighted graph g w denote sum weights vertices fa wfa performance ratio g w defined ra g g performance ratio r n w w supremum ra g w graphs g vertices weight function w w constant function 1 call r n 1 unweighted performance ratio finally performance ratio r n supremum r n w weight functions w defined graphs n vertices approximation algorithm ufvs problem achieves unweighted performance ratio 2 log 2 n essentially contained lemma due erdos posa ep62 result improved monien schulz ms81 achieved performance ratio log n section 2 provide approximation algorithm ufvs problem achieves unweighted performance ratio 4 gamma 2n algorithm draws upon theorem simonovits si67 analysis uses result voss vo68 actually consider generalization ufvs problem prescribed subset vertices called blackout vertices allowed participate feedback vertex set problem subcase wfvs problem wherein allowed vertex unit weight blackout vertex infinite weight interest graphs blackout vertices motivated loop cutset problem application updating problem bayesian inference explored section 4 section 3 present two algorithms wfvs problem first devise primaldual algorithm based formulating wfvs problem instance set cover problem algorithm performance ratio 10 weighted planar graphs 4 log 2 n general weighted graphs ratio achieved extending erdos posa lemma weighted graphs second algorithm presented section 3 achieves performance ratio weighted graphs deltag maximum degree g result interesting low degree graphs notable application approximation algorithms ufvs problem artificial intelligence due dechter pearl follows dp87 de90 given set values finite domain also every given constraint subset r ij theta j defines allowable pairs values taken pair variables task find assignment variables constraints r ij satisfied instance problem associate undirected graph g whose vertex set set variables constraint r ij strictly contained theta j ie r ij edge g connecting x x j resulting graph g called constraint network said represent constraint satisfaction problem common method solving constraint satisfaction problem backtracking repeatedly assigning values variables predetermined order backtracking whenever reaching dead end approach improved follows first find feedback vertex set constraint network arrange variables variables feedback vertex set precede variables apply backtracking procedure values variables feedback vertex set determined backtracking procedure algorithm switches polynomialtime procedure solvetree solves constraint satisfaction problem remaining forest solvetree succeeds solution found otherwise another backtracking phase occurs complexity modified backtracking algorithm grows exponentially size feedback vertex set feedback vertex set contains k variables domain size 2 procedure solvetree might invoked 2 k times procedure solvetree runs polynomialtime developed dechter pearl also proved optimality tree algorithm dp88 consequently approximation algorithm finding small feedback vertex set reduces complexity solving constraint satisfaction problems modified backtracking algorithm furthermore domain size variables varies solvetree called number times bounded product domainsizes variables whose corresponding vertices participate feedback vertex set take logarithm domain size weight vertex solving wfvs problem weights optimizes complexity modified backtracking algorithm case domain size allowed vary 2 unweighted feedback vertex set problem best approximation algorithm prior work ufvs problem attained performance ratio log n ms81 use results si67 vo68 order obtain approximation algorithm ufvs problem attains performance fact actually consider slight generalization ufvs problem mark vertex graph either allowed vertex blackout vertex graphs feedback vertex sets cannot contain blackout vertices denote set allowed vertices g ag set blackout vertices bg note problem reduces ufvs problem feedback vertex set found graph g blackout vertices every cycle g contains least one allowed vertex graph g property called valid graph motivation dealing modified problem clarified section 4 use algorithm developed herein reduce computational complexity bayesian inference throughout section g denotes valid graph nonempty set vertices v g partitioned nonempty set ag allowed vertices possibly empty set bg blackout vertices set edges eg possibly parallel edges self loops use g shorthand notation g w w assigns unit weight allowed vertex infinite weight blackout vertex neighbor v vertex connected v edge eg degree delta g v v g number edges incident v g selfloop vertex v contributes 2 degree v degree g denoted deltag largest among degrees vertices g vertex g degree 1 called endpoint vertex degree 2 called linkpoint vertex higher degree called branchpoint graph g called rich every vertex v g branchpoint notation delta g stand largest among degrees vertices ag degree vertex ag takes account incident edges including lead neighbors bg rich valid graph delta g 3 two cycles valid graph g independent vertex sets share blackout vertices note size feedback vertex set g bounded largest number pairwise independent cycles found g cycle gamma g called simple visits every vertex v g clearly set f feedback vertex set g intersects every simple cycle g graph called singleton contains one vertex singleton called selflooped contains least one self loop singleton g selflooped g otherwise graph g connected every two vertices connecting path g every graph g uniquely decomposed isolated connected components similarly every feedback vertex set f g partitioned feedback vertex sets f feedback vertex set g hence 23subgraph valid graph g subgraph h g degree h every vertex ag either 2 3 degree vertex belonging bg h restricted 23subgraph exists valid graph forest maximal 23subgraph g 23subgraph g subgraph 23subgraph g maximal 23subgraph easily found applying depthfirstsearch dfs g linkpoint v 23subgraph h called critical linkpoint v allowed vertex cycle gamma g fvg refer cycle gamma g witness cycle v note assume witness cycle simple verifying whether linkpoint v h critical linkpoint easy remove set vertices g incident edges apply breadthfirstsearch bfs check whether cycle v remaining graph cycle valid graph g branchpointfree pass allowed branchpoints branchpointfree cycle passes allowed linkpoints blackout vertices g rest section devoted showing following algorithm correctly outputs vertex feedback set achieves unweighted performance ratio less 4 algorithm subg23 input valid graph g output feedback vertex set f g g forest f else begin using dfs find maximal 23subgraph h g using bfs find set x critical linkpoints h let set allowed branchpoints h find set w covers branchpointfree cycles h covered x end note isolated cycles h w consists one vertex cycle elaborate set w computed bg 6 let h 0 graph obtained h removing set x along incident edges let h b subgraph induced allowed linkpoints blackout vertices h 0 every isolated cycle h b arbitrarily choose allowed linkpoint cycle w next replace maximal respect containment chain allowed linkpoints h b edge resulting graph h b assign unit cost edges corresponding chain allowed linkpoints zero cost edges compute minimumcost spanning forest h b add w one linkpoint chain allowed linkpoints h b corresponds edge h straightforward verify complexity subg23 linear jegj following two lemmas generalize claims used proof theorem 1 si67 used prove subg23 outputs feedback vertex set valid graph g h maximal 23subgraph valid graph g let gamma simple cycle g one following holds gamma witness cycle critical linkpoint h allowed branchpoint h c gamma cycle h consists blackout vertices allowed linkpoints h proof let gamma simple cycle g assume contrary neither ac holds implies particular gamma cannot entirely contained h distinguish two cases 1 gamma intersect h 2 gamma intersects h blackout vertices allowed linkpoints h case 1 case could join gamma h obtain 23subgraph h g contains h proper subgraph however contradicts maximality h case 2 gamma intersects h blackout vertices case 1 join gamma h contradict maximality h suppose gamma intersects h allowed linkpoints h note case gamma must intersect h least two distinct allowed linkpoints h else gamma would witness cycle intersecting critical linkpoint since gamma contained h assumption find two allowed linkpoints v 1 v 2 v gamma v h connected path p along gamma p entirely contained h joining p h obtain 23subgraph g contains h proper subgraph thus contradicting maximality h h maximal 23subgraph g let gamma 1 gamma 2 witness cycles g two distinct critical linkpoints h independent cycles namely proof let v 1 v 2 critical linkpoints associated respectively assume contrary v contains allowed vertex path p g runs along parts cycles gamma 1 gamma 2 starting passing u ending v 2 witness cycles g since v 1 v 2 distinct critical linkpoints vertex u cannot possibly coincide either therefore path p entirely contained h joining p h obtain 23subgraph g contains h proper subgraph thus reaching contradiction theorem 3 every valid graph g set f computed subg23 feedback vertex set g proof let gamma simple cycle g follow three cases lemma 1 show gamma witness cycle critical linkpoint h construction critical linkpoints h f allowed branchpoint h construction allowed branchpoints h f c gamma cycle h consists blackout vertices allowed linkpoints contains critical linkpoint subg23 selects linkpoint feedback vertex set f otherwise cycle gamma must entirely contained graph h b used create w show w covers cycles h b assume contrary let gamma cycle h b covered w recall construction h b chain allowed linkpoints gamma replaced edge unit cost let resulting cycle h b since w cover gamma unitcost edges gamma necessarily chosen minimumcost spanning forest hand since contain cycles must least one zerocost edge gamma contained hence deleting one unitcost edges gamma inserting instead particular zerocost edge gamma obtain new spanning forest 0 b however cost 0 smaller contradicts assumption minimumcost spanning forest reduction graph g 0 undirected graph g graph obtained g sequence following transformations ffl delete endpoint incident edge ffl connect two neighbors linkpoint v selflooped singleton new edge remove v graph two incident edges reduction graph valid graph g necessarily valid since reduction process may generate cycle consisting blackout vertices interested reduction sequences transformation yields valid graph lemma 4 let g 0 reduction graph g g 0 valid proof let g sequence reduction graphs h obtained removal one linkpoint possibly endpoints h igamma1 since g 0 valid h valid graph well let v linkpoint removed h obtain h i1 first show g 0 g suppose f feedback vertex set h i1 cycle h passes v reduction gamma obtained replacing linkpoint v gamma edge connecting neighbors v yields cycle h i1 vertex set gamma intersects set f hence f also feedback vertex set h implies h show g 0 g suppose f minimal feedback vertex set h f contain v f also feedback vertex set h i1 otherwise write claim set f 0 cannot fail cover one cycle h i1 failed would two distinct cycles gamma 1 gamma 2 h contain v case cycle h induced v would covered f thus contradicting fact f feedback vertex set h follows minimality f set f 0 fails cover exactly one cycle h i1 cycle contains least one allowed vertex u h i1 valid graph therefore set f 0 fug feedback vertex set h i1 hence h reduction graph g graph g minimal g valid graph proper reduction graph g 0 g valid lemma 5 g minimal reduction graph g g contain blackout linkpoints every feedback vertex set g contains allowed linkpoints g proof recall g valid graph g contains blackout linkpoint removal creates valid reduction graph contradicts minimality g assume f feedback vertex set g v allowed linkpoint f removal v yields graph valid v must included f removal v yields valid graph g minimal next lemma needed order establish performance ratio subg23 variant lemma 4 vo68 lemma 6 let g valid graph blackout linkpoints vertex degree less 2 every feedback vertex set f g contains linkpoints g proof suppose g case jv gj 3jv therefore lemma holds trivially assume jf j jv gj denote set edges eg whose terminal vertices vertices f denote set edges eg whose terminal vertices vertices x also let e fx denote set edges g connect vertices f vertices x clearly e f ex e fx form partition eg graph obtained deleting f g nonempty forest x therefore je however vertex x branchpoint g linkpoints assumed f vertices degree less 2 therefore ie hand combining last two inequalities obtain main claim section follows theorem 7 unweighted performance ratio subg23 4 gamma 2jv gj proof let f feedback vertex set computed subg23 valid graph g forest show jf j 4 2 theorem follows immediately inequality let h x w subg23 suppose cycles g pass allowed vertex v g vertex v critical linkpoint h v linkpoint h h cycle otherwise one readily verify h must contain exactly two branchpoints either case jf j 2 assume g 2 every v 2 x let gamma witness cycle v g lemma 2 cycles gamma pairwise independent therefore minimum number vertices needed cover cycles jxj let fgamma j g set branchpointfree cycles h contain critical linkpoints h note cycle gamma j independent witness cycle gamma claim smallest set w 0 vertices v h intersects vertex set gamma j must size jw j see note w 0 contains allowed linkpoints h remove h b edges correspond linkpoints belonging w 0 clearly end forest construction minimum number edges allowed linkpoints needed removed h b make forest jw j recalling every cycle gamma j independent witness cycle gamma set w 0 cannot possibly intersect cycles gamma hence order cover cycles fgamma g need least jxj vertices therefore hand recall jf distinguish following two cases case 1 case 2 feedback vertex set g size g let w 0 smallest subset f intersects vertex set gamma clearly w 0 consists allowed linkpoints h showed earlier proof jw h 1 subgraph h obtained removing critical linkpoints h linkpoints w 0 deleted linkpoint also remove recursively resulting endpoints h obtaining h 1 thus deletion linkpoint h decrease number branchpoints 2 hence number branchpoints left h 1 least furthermore graph h 1 contain endpoints 1 minimal reduction graph h 1 let h 2 valid graph obtained removing singleton components h 1 since h 1 contain endpoints number branchpoints h 1 preserved h 1 h 2 therefore graph h 2 contains least jy branchpoints hand since h 1 minimal reduction due lemma 5 blackout linkpoints h 1 every feedback vertex set h 1 contains allowed linkpoints h 1 furthermore graphs h contain endpoints follows apply lemma 6 h 2 feedback vertex set h 2 thus obtaining equality due lemma 4 therefore recall w 0 chosen subset smallest feedback vertex set f g let x 0 smallest subset f covers witness cycles fgamma g let z 0 smallest subset f covers cycles h 1 since h 1 contain critical linkpoints h witness cycle gamma independent cycle h 1 also follows previous discussion addition construction h 1 thus follows combining 1 obtain desired result weighted feedback vertex set section consider approximation wfvs problem described section 1 given undirected graph g weight function w vertices find feedback vertex set g w minimum weight previous section assume g may contain parallel edges selfloops weighted reduction graph g 0 undirected graph g graph obtained g sequence following transformations ffl delete endpoint incident edge ffl let u v two adjacent vertices wu wv v linkpoint connect u neighbor v remove v graph two incident edges following lemma easily verified see eg proof lemma 4 weighted reduction graph g w g weighted reduction graph g graph g minimal weighted reduction graph g 0 g equal g graph called branchy endpoints addition set linkpoints induces independent set ie linkpoint either isolated selflooped singleton connected two branchpoints clearly minimal weighted reduction graph must branchy note complexity transforming graph branchy graph linear jegj ready present algorithms finding approximation minimumweight feedback vertex set given weighted graph section 31 give algorithm achieves performance ratio 4 log 2 jv gj section 32 present algorithm achieves performance ratio 31 primaldual algorithm basis first approximation algorithm next lemma generalizes lemma due erdos posa ep62 lemma 3 lemma obtained erdos posa estimating smallest number edges graph contains given number pairwise independent cycles later ep64 provided bounds value g 1 terms largest number pairwise independent cycles g tighter bounds g 1 obtained simonovits si67 voss vo68 lemma 9 shortest cycle branchy graph g least two vertices length proof let smallest even integer 2 delta 2 t2 jv gj apply bfs g depth starting vertex v claim search hits vertex twice exists cycle length 2t g indeed induced bfs tree would contain least 2 delta 2 t2 distinct vertices g contradiction iteration proposed algorithm first find minimal weighted reduction graph find cycle gamma smallest number vertices minimal weighted reduction graph algorithm sets ffi minimum among weights vertices v gamma value ffi subtracted turn weight vertex v gamma vertices whose weight becomes zero added feedback vertex set deleted graph iteration repeated graph exhausted algorithm miniwcycle input g w output feedback vertex set f g w h forest begin find minimal weighted reduction graph find cycle gamma 0 h 0 smallest number vertices remove x incident edges h end finding shortest cycle done running bfs vertex cycle found selecting smallest efficient approach finding shortest cycle described ir78 hard see miniwcycle computes feedback vertex set g analyze algorithm employing techniques similar used ho82 ho83 khvy94 note algorithm also analyzed using local ratio theorem baryehuda even baev85 theorem 10 performance ratio algorithm miniwcycle 4 log 2 jv gj proof assume jv gj 1 given feedback vertex set f g w let indicator vector f namely x denote c set cycles g problem finding minimumweight feedback vertex set g w formulated terms x integer programming problem follows minimize ranging nonnegative integer vectors 2 let c v denote set cycles passing vertex v g consider following integer programming packing problem maximize ranging nonnegative integer vectors gamma2c clearly linear relaxation 3 dual linear relaxation 2 dual variables weighted reduction graph computed iteration algorithm miniwcycle cycle follows vertices v gamma 0 belong g otherwise unfold transformation steps performed obtaining h 0 h backward order ie h 0 back h step add gamma 0 chains linkpoints connecting vertices deleted process finishes cycle gamma 0 h 0 transforms cycle gamma g show miniwcycle interpreted primaldual algorithm first show computes dual feasible solution 3 certain maximality prop erty initial dual feasible solution one dual variables gamma zero cycle chosen iteration miniwcycle let gamma associated cycle g may view computation iteration miniwcycle setting value dual variable gamma weight ffi lightest vertex v gamma 0 updated weight wh 0 v every precisely slack dual constraint corresponds v clear choice ffi values dual variables gamma end iteration miniwcycle satisfy dual constraints 4 corresponding vertices thus follows dual constraints hold vertices let v vertex removed h obtain h 0 iteration miniwcycle remains show dual constraint 4 corresponding vertex holds iteration j algorithm every j show backward induction j previous discussion follows constraints corresponding vertices exist last iteration hold suppose dual constraints corresponding vertices v h 0 iteration j violated show dual constraints corresponding vertices v iteration also violated let c chain linkpoints h iteration j let v 1 v 2 two branchpoints adjacent c let u vertex minimum weight among v 1 v 2 vertices c note weighted reduction procedure deletes vertices c except possibly one representative depending whether u c one adjacent branchpoints observe set cycles pass linkpoint c linkpoints c contained set cycles pass v 1 also contained set cycles pass v 2 implies dual constraint corresponding u violated dual constraints corresponding vertex c also violated algorithm essentially constructs primal solution x dual solution selects feedback vertex set vertices corresponding dual constraints tight ii iteration constraint first became tight corresponding vertex belonged graph stated earlier construction yields feasible solution let x denote optimal primal dual fractional solutions respectively follows duality theorem wv wv gamma2c gamma2c hence prove theorem suffices bound ratio lhs rhs 5 first note gamma 6 0 cycles gamma g associated cycles gamma 0 chosen iteration miniwcycle construction x clear dual variable gamma cycle gamma contributes value v vertices hence gamma2c iteration graph h 0 branchy graph therefore lemma 9 jv gamma 0 j 4 log 2 jv gj hence theorem proved proposition 11 planar graphs weighted performance ratio miniwcycle 10 proof first notice weighted reduction process preserves planarity fore iteration algorithm miniwcycle remain planar graph claim every rich planar graph g must contain face length 5 assume contrary summing lengths faces get 2jej 6jzj z denotes set faces g eulers formula hence however since degree vertex least 3 get contradiction furthermore implies branchy planar graph must contain cycle length 10 32 lowdegree graphs algorithm presented section based following variant lemma 6 lemma 12 let g branchy graph every feedback vertex set f g proof let f feedback vertex set g assume without loss generality f contains branchpoints since assumption decrease jf j let g 0 minimal unweighted reduction graph g ie g 0 contains branchpoints isolated selflooped singletons clearly f also feedback vertex set g 0 thus g 0 f satisfy conditions lemma 6 delta delta yielding since g 0 branchy graph number linkpoints g deltag 0 hence present weighted greedy algorithm finding feedback vertex set graph g algorithm wgreedy input g w output feedback vertex set f g w h forest begin find minimal weighted reduction graph h 0 h wh f remove u h 0 incident edges end subset v let ws denote sum weights vertices prove following theorem theorem 13 let g branchy graph denote f feedback vertex set computed algorithm wgreedy f minimumweight feedback vertex set g proof assume number iterations loop executed algorithm wgreedy p define following weight functions w g weight function w defined 1 p follows subset let w denote sum weights vertices weight function w clearly suppose one weighted reduction steps algorithm wgreedy chain c equal weight linkpoints reduced single vertex say v either belongs c one two branchpoints adjacent c suppose v added f f also contains vertex chain c without loss generality assume vertex replaced v let obviously 1 claim p assume case respect order vertices entered f algorithm wgreedy let u first vertex u 2 f removed graph weighted reduction step means u time removal linkpoint adjacent vertex u 0 smaller weight exchanging u u 0 f obtain feedback vertex set smaller weight contradicting optimality f hence vertex therefore notice graph h 0 weight function w assigns weight vertices hence lemma 12 w theorem follows follows lemma 8 performance ratio algorithm wgreedy g w 2delta 2 g graph g 4 loop cutset problem application section 41 consider variant wfvs problem directed graphs section 42 describe application bayesian inference 41 loop cutset problem underlying graph directed graph undirected graph formed ignoring directions edges loop subgraph whose underlying graph cycle vertex v sink respect loop gamma two edges adjacent v directed v every loop must contain least one vertex sink respect loop vertex sink respect loop gamma called allowed vertex respect gamma loop cutset directed graph set vertices contains least one allowed vertex respect loop problem find minimumweight loop cutset given directed graph weight function denote w sum weights vertices loop cutset greedy approaches loop cutset problem suggested suc90 st90 methods shown performance ratio bad omegagamma n4 certain planar graphs st90 application approximation algorithms loop cutset problem area bayesian inference described later section approach take reduce weighted loop cutset problem weighted feedback vertex set problem solved previous section given weighted directed graph w define splitting weighted undirected graph w follows split vertex v two vertices v v incoming edges v become undirected incident edges v outgoing edges v become undirected incident edges v addition connect v v undirected edge set w v w v wv set vertices x define x set obtained replacing vertex v v x respective vertex v vertices originated algorithm easily stated algorithm loopcutset input w output loop cutset f w construct apply miniwcycle w obtain feedback vertex set x f x note loop associated unique cycle viceversa straightforward manner let gamma denote loop image cycle gamma 1 k denote cycle image loop k clear mapping next lemma shows algorithm loopcutset outputs loop cutset w lemma 14 let w directed weighted graph w splitting graph f feedback vertex set w finite weight f loop cutset w w u loop cutset set u obtained u replacing vertex v 2 u vertex v feedback vertex set proof prove proof ii similar let gamma loop prove lemma show allowed vertex respect gamma belongs f let 1 gamma unique cycle image gamma since f cycle cover finite weight must vertex v 2 f 1 gamma clear vertex v 2 gamma v originated allowed vertex respect gamma needed complete proof finiteness must w vertex f follows lemma 14 addition due theorem 10 applied graph since number vertices twice number vertices get following bound performance ratio algorithm loopcutset theorem 15 performance ratio loopcutset 4 log 2 2jv dj show unweighted loop cutset problem achieve performance ratio better 4 case vertex v 2 weight v 2 one unit weight v 2 1 falls within framework considered section 2 since vertices infinite weight treated blackout vertices therefore apply subg23 loopcutset algorithm instead applying miniwcycle obtain following improved performance ratio theorem using subg23 unweighted performance ratio loopcutset 4 gamma 2jv dj proof equality due lemma 14 inequality due theorem 7 since dj claim proved 42 application conclude section application approximation algorithms loop cutset problem let p distribution u draws values finite set called domain u directed graph directed cycles called bayesian network p 11 mapping fu vertices associated vertex p written follows source vertices incoming edges vertex worth noting bayesian networks useful knowledge representation schemes many artificial intelligence tasks bayesian networks allow wide spectrum independence assumptions considered model builder practical balance established computational needs adequacy conclusions complete exploration subject see pe88 suppose variables fv among fu assigned specific values respectively updating problem compute probability principle computations straightforward bayesian network defines joint probability distribution conditional probabilities computed dividing appropriate sums however computations inefficient time space unless use conditional independence assumptions defined eq 6 shall see next approximation algorithms loop cutset problem reduce computations needed solving updating problem trail bayesian network subgraph whose underlying graph simple path vertex b called sink respect trail exist two consecutive edges b b c trail active set vertices z 1 every sink respect either z descendant z 2 every vertex along outside z otherwise trail said blocked z verma pearl vepe88 proved bayesian network p trails vertex fr vertex fs blocked g corresponding sets variables fu r 1 independent conditioned fu 1 g furthermore geiger pearl gp90 proved converse theorem results presented extended gvp90 using close relationship blocked trails conditional independence kim pearl kip83 developed algorithm updatetree solves updating problem bayesian networks every two vertices connected one trail updatetree views vertex processor repeatedly sends messages neighboring vertices equilibrium reached vertex contains conditional probability distribution p computations reach equilibrium regardless order execution time proportional length longest trail network pearl pe86 solved updating problem bayesian network follows first set vertices selected two vertices network connected one active trail z z subset vertices updatetree applied combination value assignments variables corresponding finally results combined algorithm called method conditioning complexity grows exponentially size note according definition active trails set pearls algorithm loop cutset bayesian network paper developed approximation algorithms finding domain size variables varies updatetree called number times bounded product domain sizes variables whose corresponding vertices participate loop cutset take logarithm domain size weight vertex solving weighted loop cutset problem weights optimizes pearls updating algorithm case domain sizes allowed vary useful relate feedback vertex set problem vertex cover problem order establish lower bounds performance ratios attainable feedback vertex set problem vertex cover undirected graph subset vertex set intersects edge graph vertex cover problem find minimum weight vertex cover given graph simple polynomial reduction vertex cover problem feedback vertex set problem given graph g extend g graph h adding vertex v e edge e 2 eg connecting v e vertices g e incident g easy verify always exists minimum feedback vertex set h whose vertices v g feedback vertex set also minimum vertex cover g essence reduction replaces edge g cycle h thus transforming vertex cover g feedback vertex set h due reduction follows performance ratio obtainable feedback vertex set problem cannot better one obtainable vertex cover problem latter problem attracted lot attention years far resisted approximation algorithm achieves general graphs constant performance ratio less 2 note reduction retains planarity however planar graphs baker bak94 provided polynomial approximation scheme pas vertex cover problem ufvs problem examples showing 4 tightest constant performance ratio algorithm subg23 another consequence reduction lower bound unweighted performance ratio following greedy algorithm greedycyc feedback vertex set problem iteration greedycyc removes vertex maximal degree graph adds feedback vertex set removes endpoints graph similar greedy algorithm vertex cover problem presented jo74 lo75 latter algorithm shown unweighted performance ratio better omegagammahan jv gj jo74 due reduction cycle cover problem lower bound holds also greedycyc demonstrated graphs jo74 tight upper bound worstcase performance ratio greedycyc unknown finally one notice following heuristics may improve performance ratios algorithms example iteration miniwcycle chooses place cover zeroweight vertices found smallest cycle choice might rather poor especially many weights equal may useful case perturb weights vertices running algorithm similarly algorithm subg 23 point taking blindly branchpoints h appropriate heuristic may pick branchpoints one one decreasing order residual degrees furthermore subgraph h constructed contains many high degree vertices possible remark preliminary version paper presented bagnr94 conjectured constant performance ratio attainable polynomial time algorithm wfvs problem recently verified beg94 babf94 performance ratio 2 obtained acknowledgment would like thank david johnson bringing ep62 attention samir khuller helpful discussions r constant ratio approximations weighted feedback vertex set problem undirected graphs approximation algorithms npcomplete problems planar graphs localratio theorem approximating weighted vertex cover problem approximation algorithms feedback vertex set problem applications constraint satisfaction bayesian inference approximation algorithms loop cutset prob lem cycle cutset method improving search performance ai enhancement schemes constraint processing backjumping maximal number disjoint circuits graph independent circuits contained graph logic causal models independence bayesian networks approximation algorithms set covering vertex covering problems efficient bounds stable set finding minimum circuit graph approximation algorithms combinatorial problems primaldual parallel approximation technique applied weighted set vertex cover computational model combined causal diagnostic reasoning inference systems ratio optimal integral fractional covers four approximation algorithms feedback vertex set problem probabilistic reasoning intelligent systems networks plausible infer ence new proof generalizations theorem erdos posa graphs without k heuristics finding loop cutsets multiply connected belief networks cooper g semantics expressiveness properties graphs containing k independent circuits tr ctr paola festa panos pardalos mauricio g c resende algorithm 815 fortran subroutines computing approximate solutions feedback set problems using grasp acm transactions mathematical software toms v27 n4 p456464 december 2001 rudolf berghammer alexander fronk exact computation minimum feedback vertex sets relational algebra fundamenta informaticae v70 n4 p301316 april 2006 rudolf berghammer alexander fronk exact computation minimum feedback vertex sets relational algebra fundamenta informaticae v70 n4 p301316 december 2006 ioannis caragiannis christos kaklamanis panagiotis kanellopoulos new bounds size minimum feedback vertex set meshes butterflies information processing letters v83 n5 p275280 15 september 2002 mawshang chang chinhua lin chuanmin lee new upper bounds feedback vertex numbers butterflies information processing letters v90 n6 p279285 camil demetrescu irene finocchi combinatorial algorithms feedback problems directed graphs information processing letters v86 n3 p129136 16 may rastislav krlovi peter ruika minimum feedback vertex sets shufflebased interconnection networks information processing letters v86 n4 p191196 31 may jiong guo jens gramm falk hffner rolf niedermeier sebastian wernicke compressionbased fixedparameter algorithms feedback vertex set edge bipartization journal computer system sciences v72 n8 p13861396 december 2006 venkatesh raman saket saurabh c r subramanian faster fixed parameter tractable algorithms finding feedback vertex sets acm transactions algorithms talg v2 n3 p403415 july 2006 reuven baryehuda keren bendel ari freund dror rawitz local ratio unified framework approximation algorithms memoriam shimon even 19352004 acm computing surveys csur v36 n4 p422463 december 2004
computational complexity knowledge complexity study computational complexity languages interactive proofs logarithmic knowledge complexity show languages recognized cal bppcal np prior work languages greaterthanzero knowledge complexity trivial computational complexity bounds known course proof relate statistical knowledge complexity perfect knowledge complexity specifically show honest verifier hierarchies coincide logarithmic additive term b introduction notion knowledgecomplexity introduced seminal paper goldwasser micali rackoff gmr85 gmr89 knowledgecomplexity kc intended measure computational advantage gained interaction satisfactory formulations knowledge complexity case zero recently appeared gp91 natural suggestion made goldwasser micali rackoff classify languages according knowledgecomplexity interactiveproofs gmr89 feel worthwhile give suggestion fair try lowest level knowledgecomplexity hierarchy class languages interactive proofs knowledgecomplexity zero better known zeroknowledge actually three hierarchies extending three standard definitions zeroknowledge namely extended abstract paper appeared 26th acm symposium theory computing stoc 94 held montreal quebec canada may 2325 1994 department applied mathematics computer science weizmann institute science rehovot israel email odedwisdomweizmannacil supported grant 9200226 united states israel binational science foundation jerusalem israel z computer science division university california berkeley international computer science institute berkeley ca 94720 email rafailcsberkeleyedu supported nsf postdoctoral fellowship icsi x computer science department technion israel institute technology haifa 32000 israel email erezcstechnionacil perfect statistical computational let us denote corresponding hierarchies pkcdelta skcdelta ckcdelta assuming existence oneway functions third hierarchy collapses namely differently zero level computational knowledgecomplexity extends maximum possible anyhow rest paper interested two hierarchies previous works provided information concerning zero level hierar chies fortnow pioneered attempts investigate computational complexity perfectstatistical zeroknowledge f89 followed aiello hastad ah87 results summarized following theorem bounds computational complexity languages zeroknowledge proofs theorem f89 ah87 coam hence languages statistical zeroknowledge must lie second level polynomialtime hierarchy needless say function k particular k j 0 hand allow polynomial amount knowledge revealed every language ip proven theorem lfkn90 sh90 indicated gp91 first equality property adequate definition knowledge complexity rather result paper study class languages interactiveproofs logarithmic knowledgecomplexity particular bound computational complexity languages showing recognized probabilistic polynomialtime machines access np oracle main theorem recall bpp np contained third level polynomialtime hierarchy ph believed ph proper subset pspace thus assuming ph ae pspace result yields first proof exist languages pspace cannot proven interactiveproof yields olog n bits knowledge words exist languages interactive proofs interactive proofs superlogarithmic knowledgecomplexity prior work solid indication 1 would contradict possibility languages pspace interactiveproofs yield one bit knowledge alas one willing assume languages pspace interactive proofs logarithmically many rounds assumption consider unreasonable result bp92 would yielded proof pspace contained skc1 provided ph ae pspace attempt bound computational complexity languages interactive proofs low knowledgecomplexity done bellare petrank yet work refers languages interactive proofs rounds low knowledge complexity bp92 specifically showed language l rnround interactiveproof knowledgecomplexity log n language recognized bpp np proof main theorem consists two parts first part show procedure described bellare petrank bp92 suffices recognizing languages interactive proofs logarithmic perfect knowledge complexity end use careful analysis one used bp92 second part proof transform interactive proofs statistical knowledge complexity kn interactive proofs perfect knowledge complexity knlog n transformation refers knowledgecomplexity respect honest verifier suffices since first part proof applies knowledgecomplexity respect honest verifier yet transformation interesting sake words place question whether statistical zeroknowledge equals perfect zeroknowledge one better known open problems area question open also case zeroknowledge respect honest verifier show every polytime computable function k n7n particular k j result may considered indication two hierarchies may collide techniques used stated first part proof consists presenting careful analysis existing procedure namely procedure suggested bellare petrank bp92 procedure turn culmination two sequences works discussed bellow first sequence originates fortnows definition simulatorbased prover f89 fortnow f89 consequently aiello hastad ah87 used simulatorbased prover order infer way contradiction bounds sizes specific sets explicit usage simulatorbased prover introduced bellare micali ostrovsky specifically suggested use pspaceimplementation simulatorbased prover instead using original prover unbounded complexity witnessing existence zeroknowledge interactive proof system thus obtained bound complexity provers required zeroknowledge proof systems ostrovsky ost91 suggested use implementation interaction verifier simulationbased prover procedure deciding language furthermore assuming oneway functions exist used universal extrapolation procedures ilu90 ile90 approximate behavior simulatorbased prover thus assuming oneway function exists presented efficient procedure decides languages skc0 inferred oneway functions essential nontriviality statistical zeroknowledge bellare petrank distilled decision procedure context oneway functions showing simulatorbased prover implemented using perfect universal extrapolator also known uniform generation procedure bp92 error implementation directly related deviation uniform generation procedure second sequence works deals two related problems approximating size sets uniformly generating elements problems related jerrum et al jvv86 procedures approximating size sets invented sipser si83 stockmeyer st83 improved gs89 ah87 using hashing paradigm hashing technique basis universal extrapo lation procedures ilu90 ile90 however output procedures deviates objective ie uniform distribution target set nonnegligible amount ie 1polyt running time hand jerrum et al also pointed perfect uniform generation done bpp sigma p bellare petrank combined hashingbased approximation methods ideas jvv86 obtain bpp np procedure uniform generation exponentially vanishing error probability bp92 actually procedure allowed halt output constant exponentially vanishing probability output distribution exactly uniform target set motivation studying kc addition selfevident fundamental appeal knowledge complexity wish point practical motivation considering knowledgecomplexity greater zero particular cryptographic protocols release small ie logarithmic amount knowledge may practical value especially applied one obtain subadditive bounds knowledge complexity repeated executions note typically single application subprotocol leaking logarithmically many bits knowl edge compromise security entire protocol reason logarithmically many bits guessed nonnegligible probability turn means attack due leaked bits simulated nonnegligible probability without use low knowledgecomplexity protocols one use zeroknowledge ones see gmw86 gmw87 reason nonzeroknowledge protocols may efficient andor may require weaker computational assumptions see example ovy91 remarks remark concerning two definitions throughout paper skckdelta pkckdelta denote classes knowledgecomplexity respect honest verifier note main theorem strengthen whereas transformation mentioned indeed weaker furthermore interactive proof mean one error probability negligible ie smaller polynomial fraction words justification appear section 2 remark concerning fortnows paper f89 course research found proof skc0 coam appears f89 correct particular flaw amprotocol presented f89 complement language see appendix however paper aiello hastad provides necessary machinery proving fortnows result well ah87 h94 needless say basic approach presented fortnow ie looking simulatorbased prover valid inspired subsequent works eg ah87 bmo90 ost91 bp92 ow93 well current one preliminaries let us state definitions conventions use paper throughout paper use n denote length input x function f called negligible every polynomial p sufficiently large ns pn 21 interactive proofs let us recall concept interactive proofs presented gmr89 formal definitions motivating discussions reader referred gmr89 protocol computationally unbounded prover p probabilistic polynomialtime verifier v constitutes interactive proof language l exists negligible function ffl 1 completeness x 2 l 2 soundness x 62 l prover p remark usually definition interactive proofs robust sense setting error probability bounded away 1does change expressive power since error probability reduced repetitions however standard procedure applicable knowledgecomplexity measured since even sequential repetitions may increase knowledgecomplexity question thus right definition definition used quite standard natural certainly less arbitrary setting error favorite constant eg 1 function eg 2 gamman yet techniques yield nontrivial results also case one defines interactive proofs nonnegligible error probability eg constant error probability example languages interactive proofs error probability 14 perfect knowledge complexity 1 also bpp np details see appendix b also note allowed twosided error probability strengthens main result weakens statistical perfect transformation 2 suppose transformation onesided case given twosided interactive proof statistical knowledge complexity could transformed onesided error proof knowledge complexity cf gms87 applying transformation onesided case would yielded even better result 22 knowledge complexity throughout rest paper refer knowledgecomplexity respect honest verifier namely ability simulate honest verifiers view interaction prover stronger definition one considers ability simulate point view efficient verifier interacting prover let denote random variable represents v view interaction p common input x view contains verifiers random tape well sequence messages exchanged parties begin briefly recalling definitions perfect statistical zeroknowledge perfect zeroknowledge resp statistical zeroknowledge language l probabilistic polynomial time simulator every x 2 l random variable mx distributed identically statistical difference mx p v x negligible function jxj next present definitions perfect resp statistical knowledgecomplexity use sequel definitions extend definition perfect resp statistical zero knowledge sense knowledgecomplexity zero exactly zeroknowledge actually two alternative formulations knowledgecomplexity called oracle version fraction version formulations coincide zero level differ additive constant otherwise gp91 intuition motivation see gp91 convenient use definitions paper 3 oracle formulation knowledgecomplexity protocol number oracle bit queries needed simulate protocol efficiently definition 21 knowledge complexity oracle version let k n n say interactive proof language l perfect resp statistical knowledge complexity kn oracle sense exists probabilistic polynomial time oracle machine oracle 1 input x 2 l machine queries oracle kjxj bits 2 x 2 l machine produces output probability least 1 given halts output x identically distributed resp statistically close fraction formulation simulator given explicit help instead one measures density largest subspace simulators executions ie coins identical resp close definition 22 knowledge complexity fraction version let ae n 0 1 say interactive proof language l perfect resp statistical knowledgecomplexity log 2 1aen fraction sense exists probabilistic polynomialtime machine following good subspace property x 2 l subset ms possible random tapes x 3 analysis bp92 procedure easier using fraction version whereas transformation statistical perfect easier using oracle version 1 set x contains least aejxj fraction set possible coin tosses mx 2 conditioned event mxs coins fall x random variable mx identically distributed resp statistically close x namely perfect case means every c mx denotes output simulator input x coin tosses sequence mentioned two measures almost equal theorem gp91 fraction measure oracle measure equal additive constant since none results sensitive difference additive constant measure ignore difference subsequent definition well statement results definition 23 knowledge complexity classes languages interactive proofs perfect knowledge complexity kdelta languages interactive proofs statistical knowledge complexity kdelta 23 simulation based prover important ingredient proof notion simulation based prover introduced fortnow f89 consider simulator outputs conversations interaction prover p verifier v define new prover p called simulation based prover selects messages according conditional probabilities induced simulation namely partial history h conversation p outputs message ff probability denotes distribution induced tlong prefixes conversations length prefix means number messages important note behavior p necessarily close behavior original prover p specifically knowledge complexity greater 0 consider simulator guaranteed fraction definition p p might quite different behavior main objective show even case p still behaves manner benefit 3 perfect case section prove main theorem holds special case perfect knowledge complexity combining result transformation theorem 2 subsequent section get main theorem theorem 1 pkcolog n bpp np proof follows procedure suggested bp92 turn follows approach f89 bmo90 ost91 introducing new uniform generation procedure builds ideas si83 st83 gs89 jvv86 see introduction suppose interactive proof perfect knowledge complexity olog n languages l let simulator guaranteed fraction formulation ie definition 22 consider conversations original verifier v simulationbasedprover p see definition section 23 going show probability interaction p accepting negligible x 62 l greater polynomial fraction x 2 l proof differs bp92 analysis case x 2 l thus get stronger result although use procedure separation cases x 62 l x 2 l amplified sequential repetitions protocol p remains observe sample p probabilistic polynomialtime access np oracle observation originates bp92 justified follows clearly v part interaction produced polynomialtime also uniform generation procedure bp92 implement probabilistic polynomial time machine access np oracle actually implementation may fail negligible probability matter thus remains prove following lemma lemma 31 1 x 2 l probability p outputs accepting conversation least2 2 x 62 l probability p outputs accepting conversation negligible remark bp92 weaker lemma proven specifically show probability p output accepting conversation x 2 l related 2 gammak deltat number rounds protocol note proof could arbitrary polynomial number rounds proof second part lemma follows soundness property thus concentrate first part fix arbitrary x 2 l rest proof allow mention sequel discussion notation let q number coin tosses made denote q set possible coin tosses good subspace ie density 2 gammak inomega chosen uniformly simulator outputs exactly distribution interaction consider conversations output simulator 2 probability get conversation simulator run uniformly selected omegagamma least 2 gammak claim probability get conversations interaction p also least 2 gammak obvious since distribution produced p identical distribution produced uniformly selected 2 omegagamma necessarily identical distribution produced uniformly selected 2 however provers moves p distributed case simulator selects uniformly omegagamma whereas verifiers moves p distributed case simulator selects uniformly thus surprising claim proven however need claim enough p conversations origin must accepting well note obvious since simulates interactive proof may twosided error density accepting conversations good subspace high ie need show case also p actually show probability p conversation accepting origin least let us begin formal argument notations possible history interaction h define subsets random tapes simulator ie subsets omegagamma h set 2omega cause simulator output conversation prefix h h subset inomega h also h set h also accepting thus letting denote tmessage long prefix output simulator coins get h let c random variable representing p indicator conversation c accepting aim prove note c c expression exactly expectation value jac j thus need show expectation possible conversations c produced interaction equation 1 proven done denote empty history prove equation 1 suffices prove since using ja j proof equation 2 induction number rounds namely round show expected value ja h j possible histories h rounds ie length greater equal expected value expression histories h 0 rounds order show induction step consider two cases 1 current step prover ie p 2 current step verifier ie v cases show history h expectation possible current moves given history h produced interaction p technical claim following technical claim used deriving inequalities cases positive reals proof cauchyschwartz inequality asserts setting since positive b rearranging terms get desired inequality 2 prover step denoted ff given history h prover p sends ff next message probability thus ff ff inequality justified using technical claim noting verifier step denoted fi perfectness simulation restricted good subspace know given history h verifier v sends fi next message probability js hffifi j thus inequality justified using technical claim noting jomega h j proven equation 3 cases equation 2 follows lemma 2 4 transformation section show transform statistical knowledge complexity perfect knowledge complexity incurring logarithmic additive term transformation combined theorem 1 yields main theorem theorem 2 every polytime computable k n 7 n stress knowledge complexity classes refer honest verifier dont know whether result holds analogous knowledge complexity classes referring arbitrary polytime verifiers proof use oracle formulation knowledge complexity see definition 21 start overview proof suppose given simulator produces output statistically close real proververifier interaction change interactive proof simulation produce exactly distribution space take advantage fact prover interactive proof oracle assists simulator infinitely powerful thus modification provers program augmentation oracle need efficiently computable stress modification simulator efficiently computable also maintain original verifier interactive proof thus resulting interactive proof still sound furthermore resulting interaction statistically close original one x 2 l therefore completeness property original interactive proof maintained although error probability may increase negligible amount preliminaries guaranteed interactive proof without loss gener ality may assume messages length 1 messagelength convention merely matter encoding recall definition 21 guarantees simulator produces output probability 1 yet employing proposition 38 gp91 get exists oracle machine asking kn log log n queries always produces output output statistically close interaction p v let denote associated acle let simulationbased prover verifier 4 induced 0 ie rest presentation fix generic input x 2 l omit notation notations let b random variable representing imessage ibit long prefix interaction b common input x implicit notation denote ah random variable representing message sent interactionhistory h thus th message sent write b denote fact random variables x statistically close using notations may write every h 2 f0 1g oe 2 f0 1g similarly 41 distribution induced p statistically close distributions induced proof definition distributions produced statistically close thus prove p statistically close p induction length interaction assuming p wish prove 1 distinguish two cases case st move prover get use induction hypothesis case st move verifier get 4 simulatorbased verifier defined analogously simulatorbased prover fictitious entity necessarily coincide v first justified induction hypothesis two others eq 4 stress since induction hypothesis used induction step statistical distance linear number induction steps rather exponential 2 motivating discussion note statistical difference interaction p simulation due solely difference proper verifier ie verifier induced simulator ie v 0 difference due v 0 putting much probability weight certain moves thus also little weight sibling messages recall message interaction contains one bit follows deal two cases first case difference behavior v 0 induced 0 behavior verifier v tiny case receives attention going use oracle order move weight verifier message fi gets much weight history h sibling message fi phi 1 gets little weight history h simulation specifically new simulator 00 invokes 0 comes conversation h ffi fi prefix simulator 00 help oracle output different conversation prefix h ffi fi phi 1 instead outputting original conversation simulator 00 probability exactly compensates difference v 0 v leaves one problem new simulator 00 come conversation prefix h ffi fi phi 1 cost letting oracle supply rest conversation known prefix hffifi phi1 high adopt brutal solution truncate conversations prefix truncation takes place interaction p stops conversation fi phi 1 special stop message simulation oracle recognizes cases simulator 00 output truncated conversation changes make 00 v behave exactly messages difference v 0 v tiny naturally v immediately rejects p 00 stops interaction abruptly make sure change foil ability p 00 convince v input x 2 l turns truncations happen negligible probability since truncation needed difference v v 0 tiny thus p 00 convinces v x 2 l almost probability p 0 second possible case difference behavior v v 0 tiny case looking full conversation c get tiny differences sum small difference probability c distributions 0 distribution correct differences lowering probabilities conversations new simulator probability conversation lowered relative weight relatively conversations equal relative weight interaction p technically done 00 producing output certain cases 0 produce output technical remark oracle used allow simulator toss bias coins simulator know bias suppose simulator needs toss coin comesup head probability n n integers simulator supplies oracle uniformly chosen r 2 f0 1g oracle answers head r among first n strings f0 1g tail otherwise similar procedure applicable implementing lottery two apriori known values using procedure get extremely good approximations probability spaces cost related apriori known upper bound size support ie oracle answer logarithmic size support ot number rounds interaction ffl let h partial history interaction fi possible next move verifier say fi weak respect h ffl conversation respect igood note conversation iweak th move verifier move ffl conversation iweak jgood every conversation icocritical conversation obtained c complementing th bit icritical note conversation icritical single yet may icocritical many ffl conversation weak iweak otherwise good conversations negligible probability proof recall p holds also prefixes conver sations namely 1 p us define prefix h 2 f0 1g conversation bad either ffl claim follows combining two facts fact 43 probability p outputs conversation bad prefix negligible set bad prefixes length statistical closeness get negligible fraction fl hand delta bounded bellow definition b least thus fact follows 2 fact 44 conversation contains bad prefix proof suppose fi bad prefix done otherwise holds using fact fi weak respect h get implies h ffi fi bad prefix c 2 combining facts 43 44 claim 42 follows 2 conversation probability c output 0 least 1 gamma ffl dt2e delta probp igood every proof see case write probabilities step step conditioned history far note provers steps happen equal probabilities sides inequality therefore reduced since relevant verifiers steps weak get mentioned inequality actual proof proceeds induction k gamma l clearly claim holds note k gamma l 1 claim also holds since step k conversation either prover step kgood verifier step show induction step use induction hypothesis 2 namely include one prover message one verifier message assume without loss generality prover step k gamma 1 since p 0 simulator based prover get since step k verifier good also combining equations 5 6 7 induction step follows done 2 dealing weak conversations start modifying prover p 0 resulting modified prover denoted p 00 stops gets verifier message weak respect current history otherwise namely definition modified prover p 00 stop fi weak respect assume verifier v stops rejects immediately upon receiving illegal message prover particular upon receiving stop message next modify simulator outputs either good conversations truncated conversations originally icritical jumping ahead stress truncated icritical conversations generated icritical icocritical conversations modified simulator denoted 00 proceeds follows 5 first invokes 0 obtains conversation queries augmented oracle c oracle answers probabilistically answers form oe 2 f1 tg oe 2 f0 1g probability distribution specified point wish remark oracle returns pairs oe one following three conditions holds 1 c good good icocritical oracle always answers way 2 c icritical 3 c icocritical oe 1 finally new simulator 00 halts outputting case prefix c note may smaller case 00 outputs truncated conversation always icritical otherwise 00 outputs nontruncated conversation note oracle message contains 1 log bits length interaction p 0 v remains specify oracles answer distribution let us start considering two special cases first case conversation generated 0 icritical jcocritical j case oracle always answers 0 consequently simulator always outputs ibit long prefix however prefix still output low probability corrected second case hereby described second case conversation c generated 0 good icocritical single means ibit long prefix given much probability weight whereas prefix obtained complimenting th bit gets little weight correct oracle outputs 1 probability q q specified happens 00 output icomplimented prefix higher probability appeared 0 value q determined follows denote setting q allows simulator output prefix right probability 5 stress p 00 necessarily simulatorbased prover 00 general case conversation generated 0 may icocritical many well jcritical single j case jcritical icocritical us consider sequence indices 1 l generated conversation critical cocritical ie conversation k cocritical k l either l critical l cocritical consider two cases cases q k set example namely q phi 1 phi 1 1 generated conversation cocritical every k l l critical case distribution oracle answers follows every l pair k 1 returned probability pair appears probability stress pair appears distribution 6 2 generated conversation cocritical every k l case distribution oracle answers follows every k l pair returned probability pair 0 appears probability appears distribution 1 p 2 conversation p conversation truncated ie critical one output 00 probability least 3fraction probability appears p proof weak conversations negligible output distribution p 42 difference p originates different behavior p 00 weak conversations specifically p 00 truncates p 0 yet distribution good conversations remains unchanged therefore distribution p statistically close distribution p done part 1 part 2 let us start intuitive discussion may help reading formal proof follows first recall behavior simulation 0 prover steps identical behavior interaction p steps follows simply fact p 0 simulation based prover 0 show property still holds new interaction p new simulation 00 noting two different cases one case prover step conducted p 00 exactly done p 0 00 behaves exactly 0 second possible case prover step contains special message stop shall note occurs exactly probability distribution p distribution 00 next consider verifier steps construction 00 p 00 considered behavior 0 v verifier steps made changes differences tiny called message fi weak respect history h simulator assigns message fi outputting h probability smaller factor probability verifier v outputs message fi history h 6 indeed reader easily verify probabilities sum 1 make changes messages whose difference weight simulation 0 interaction smaller proof consider two cases first message fi weak respect history h clearly sibling message fi phi 1 getting much weight simulation 0 definition 00 made adjustments move weight prefix h ffi fi phi 1 prefix h ffi fi show transfer weight exactly cancels difference behavior v behavior 0 namely weak messages siblings assigned exactly probability 00 v thus show weak step involved behavior behavior 00 exactly equivalent remains deal messages difference conditional behavior v 0 tiny considered far case 00 behaves like 0 however since difference tiny get even accumulate differences throughout conversation sum multiplicative factor 34 stated claim let us begin formal proof writing probability p 00 c product conditional probabilities steps namely probability 00 outputs conversation c show induction step conversation produced 00 least times probability step p interaction shown done clearly claim holds null prefix prove induction step consider two possibilities party making st step st step prover consider conditional behavior 00 given history far show behavior identical behavior p 00 partial history delicate point note may talk behavior 00 prefix prefix appears positive probability output distribution 00 however induction hypothesis prefix output p appears positive probability 00 partition analysis two cases 1 first consider case last message verifier weak respect history precedes namely fi weak respect h 0 case interaction p simulation 00 next message prover set stop probability 1 namely 2 possible case last message verifier weak respect preceding history case simulator 00 behaves like 0 prover note changes critical cocritical steps apply verifier steps thus summarize conditional behavior 00 prover steps conditional behavior p 00 exactly equal st step verifier consider conditional behavior 00 given history far let us recall second modification applied 0 deriving 00 modification changes conditional probability verifier steps distribution 0 order add weight steps low probability simulation note modification made critical cocritical steps verifier consider history h might appear interaction p possible response fi v h induction hypothesis h positive probability output simulation 00 therefore may consider conditional behavior 00 history h three cases considered corresponding whether either fi fi phi 1 none weak respect h start simplest case neither fi fi phi 1 weak wrt h case behavior 00 identical behavior 0 since oracle never sends message case however fact fi weak get done simple case turn case fi weak wrt h case given 00 produced prefix h produces h ffifi whenever 0 produces prefix h ffifi furthermore conditional probability q defined 00 produces prefix h ffi fi also case produces prefix h ffi fi phi 1 define simulation 0 based verifier may also write also recall q defined pgammap 0 using notations using equation 8 get finally turn case fi phi 1 weak wrt h means fi cocritical c given 00 produced prefix h produces h ffi fi 0 produces prefix h ffi fi furthermore 00 probability q defined denote p p 0 respect critical message fi phi 1 namely thus recalling completes proof claim 46 2 lowering probability simulator outputs handling differences 0 p tiny make last modification deal tiny differences lowering probability simulator outputs conversation case outputs conversation frequently appears p 00 v modified simulator denoted 000 runs 00 obtain conversation c note 00 always produces output using furtheraugmented oracle 000 outputs c probability c note p c 1 holds due part 2 claim 46 1 000 produces output probability 3 2 output distribution 000 ie case output identical distribution proof probability 000 produces output exactly part 2 note probability conversation c output 000 exactly4 simulator halts output probability exactly 3 get given 000 halts output outputs c probability exactly done 2 important point explicitly addressed far whether modifications applied simulator preserve ability implemented probabilistic polynomialtime bounded access oracle clearly case respect 00 expense additional regarding last modification subtle points needs addressed specifically need verify definition 000 implementable namely 000 help augmented oracle sieve conversations exactly desired probability note method presented technical remark may yield exponentially small deviation desired probability get close perfect simulation yet achieve end modify sieving process suggested technical remark deal specific case first modify p 00 makes random choices case flipping polynomial number unbiased coins 7 rounding change bit behavior p 00 deviation made small assertions specifically claim 46 still hold consider specific sieving probability need cd observation c number coin tosses lead 00 output c ie using notation previous section j observing b size probability space p using modification p 00 rewrite p c 3ad c nonnegative integers note oracle allow simulator sieve conversations probability e c following way 000 sends oracle random tape tossed 00 oracle sieves e possible c random tapes lead 00 output c general case p c2 f deal writing c implement sieve 000 supplies oracle uniformly chosen fbit long string addition oracle sieves q randomtapes 00 uses extra bits order decide sieve case equals specific different randomtape combining claims 41 46 part 1 47 conclude p 00 interactive proof system perfect knowledge complexity olog n l completes proof theorem 2 7 implementation p 00 discussed explicitly possible p 00 uses infinite number coin tosses select next message either 0 1 however infinite number coin tosses really needed since rounding probabilities polynomial number coins suffices causes exponentially small rounding errors concluding remarks consider main result first step towards classification languages according knowledge complexity interactive proof systems indeed much known first mention two questions seem ambitious first try provide evidence npcomplete languages cannot proven within low say logarithmic even constant knowledge complexity possible avenue proving conjecture show languages logarithmic knowledge complexity coam rather bpp np recall np unlikely coam see also bhz87 second suggestion try provide indications languages pspace interactive proofs linear rather logarithmic knowledge complexity reader easily envision moderate ambitious challenges direction another interesting question whether levels greater zero knowledge complexity hierarchy contain strictly languages previous levels partial collapse occurs example open whether constant even logarithmic knowledge complexity classes collapse zero level regarding transformation statistical knowledge complexity perfect knowledge complexity ie theorem 2 interesting questions arise firstly cost transformation reduced bellow olog n bits knowledge result special case statistical zeroknowledge almost interesting secondly one present analogous transformation preserves onesided error probability interactive proof note transformation introduces negligible error probability completeness condition finally one present analogous transformation applies knowledge complexity respect arbitrary verifiers transformation applies knowledge complexity respect honest verifier 6 acknowledgement thank leonard shulman providing us simpler proof claim 32 r true complexity statistical zeroknowledge making zeroknowledge provers efficient complexity perfect zeroknowledge interactive proof systems provers never fail random selection proofs yield nothing validity methodology cryptographic protocol design play mental game completeness theorems protocols honest majority quantifying knowledge complexity knowledge complexity interactive proofs knowledge complexity interactive proofs public coins interactive proof systems better ways generate hard np instances picking uniformly random direct minimumknowledge computations random generation combinatorial structures uniform distribution algebraic methods interactive proof systems fair games allpowerful adversary complexity theoretic approach randomness complexity approximate counting tr ctr amos beimel paz carmi kobbi nissim enav weinreb private approximation search problems proceedings thirtyeighth annual acm symposium theory computing may 2123 2006 seattle wa usa oded goldreich salil vadhan avi wigderson interactive proofs laconic prover computational complexity v11 n12 p153 january amit sahai salil vadhan complete problem statistical zero knowledge journal acm jacm v50 n2 p196249 march
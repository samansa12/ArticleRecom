improved implementations binary universal operations present algorithm implementing binary operations type unary loadlinked storeconditional sc operations performance algorithm evaluated according sensitivity measuring distance operations graph induced conflicts guarantees influence step complexity sensitivity implementation ologast n n number processors system operations logast n apart graph induced conflicts delay constant sensitivity achieved operations used implement heaps arraybased linked listswe also prove problem solved o1 steps using binary llsc operations requires olog logast n operations unary llsc operations used indicates nonconstant gap unary binary llsc operations b introduction algorithm nonblocking processor delayed processor making progress nonblocking algorithms avoid performance bottlenecks due processors failures delay asynchronous shared memory systems nonblocking algorithms require use universal operations loadlinked storeconditional sc 14 ease programming convenient write nonblocking algorithms using universal operations access several memory words atomically 4 13 18 22 however existing commercial architectures provide unary operations access single memory word 23 26 multiword operations implemented using unary universal operations eg 14 15 implementations efficient efficiency implementation evaluated isolation ie interference operations contending memory words 19 however provides indication implementations behavior presence contention ie operations compete access memory words clearly hot spot ie memory word contention high implementation operations trying access word delayed long time one even argue case operations delayed even supported hardware 5 24 however hot spot delay far away operations paper proposes evaluate implementations sensitivity measuring distance hot spot influences performance operations roughly stated sensitivity longest distance one operation another operation influences performance eg change number steps needed order complete operation concentrate implementations binary operations unary llsc binary operations induce conflict graph nodes represent memory words edge two memory words belong data set operation ie pair memory words accessed operation hot spot corresponds node high degree required two operations whose distance conflict graph larger sensitivity interfere step complexity whether execute parallel present algorithm implementing arbitrary binary operations unary sc operations sensitivity olog n algorithm uses llsc convenience since supported several contemporary architectures eg 23 26 algorithm extended rely unary universal operations particular o1 implementation llsc compareswap 3 employed core algorithm implements binary operation manner similar known algorithms 3 7 19 25 27 processor locks words data set binary operation applies operation unlocks data set operations help complete thus ensuring algorithm block new feature algorithm processor may lock data set two directionseither starting lowaddress word starting highaddress word sensitivity core algorithm depends orientation conflict graph according locking directions two common data structuresan arraybased linked list heapwe priori determine locking directions induce constant sensitivity general however processors dynamically decide locking directions achieved encapsulating core algorithm decision algorithm coordinating order processors lock data sets lowaddress word first highaddress word first first present decision algorithm based deterministic coin tossing technique cole vishkin 9 simplified case conflict graph path show synchronization method breaks conflict graph arbitrary topology paths adapted deterministic coin tossing technique applied combined previous algorithm implementation arbitrary binary operations unary llsc olog n sensitivity also show problem solved o1 steps using binary llsc operations requires olog log n steps unary operations type used proof adapts lower bound linial 20 shows message passing model maximal independent set nring found less omegagammaan n rounds lower bound indicates implementation binary llsc unary operations incur nonconstant overhead following original publication work 6 10 afek merritt taubenfeld touitou 1 presented algorithm implementing kword object unary oper ations algorithm waitfree guaranteeing every operation eventually terminates algorithm uses algorithmic ideas implementation addition employs base case recursive construction herlihy moss 16 introduce transactional memory hardwarebased scheme implementing arbitrary multiword operations three schemes 3 19 25 present software implementations transactional memory singleword atomic operations israeli rappoport 19 shavit touitou 25 present nonblocking implementations arbitrary multiword operations using unary llsc anderson moir 3 give waitfree implementation kcompareswap ksc shavit touitou 25 present simulation results indicating algorithm performs well practice israeli rappoport 19 analyze step complexity operation anderson moir 3 measure step complexity kcompareswap ksc operations analysis three implementations shows sensitive contention distant operations example two operations executing two ends linked list increase others step complexity turek shasha prakash 27 show general method transforming concurrent implementation data structure nonblocking one method employs compareswap process blocked due lock held another process helps blocking process releases lock help continues recursively blocking process also blocked another process barnes 7 presents general method constructing nonblocking implementations concurrent data structures method words needed operation cached private memory thus operations access data structure concurrently contend methods similar software transactional memory 3 19 25 sensitivity high algorithm uses helping 3 7 19 25 27 decreases sensitivity increases parallelism minimizing distance operation helps herlihy 15 introduces general method converting sequential data structure shared waitfree one herlihys method extension suggested alemany felten 2 allow parallelism concurrent operations inherently sequential anderson moir 3 present universal construction allows operations access multiple objects atomically implementation uses multiword operations employed efficiently implement certain large shared objects saves copying allows parallelism nonblocking implementations multiword operations induce solutions wellknown resourceallocation problem solutions short waiting chains small failure locality 8 additional discussion relations two problems appears 1 preliminaries 21 asynchronous sharedmemory model sharedmemory model processors communicate applying memory access operations short operations set memory words processor p modeled possibly infinite state machine state set q containing distinguished initial state q 0i configuration vector local state processor value memory word j initial configuration processors local initial states memory words contain default value operation type defines number input output arguments allowable values functional dependency inputs sharedmemory state processor state one hand output arguments new states processor memory hand operation instance operation type data set operation set memory words accesses example unary sc defined follows return value scm new write successful sc since previous llm new return success else return failure event computation step single processor denoted index processor event processor determines memory operation perform according local state determines next local state according value returned operation operations atomic operation seems occur certain point two operations occur point therefore computations system captured sequences configurations configuration obtained previous one event single processor detail execution segment ff finite infinite sequence every configuration oe k event application oe k results c k1 oe result applying p transition function p state c k applying p memory access operation memory c k execution execution segment c c 0 initial configuration constraints interleavings events different processors manifesting assumption processors asynchronous bound relative speeds implementation highlevel operation type h lowlevel operations type l procedure using operations l intuitively processors distinguish h implementation l assume processor p invokes procedure implementing operation op terminates let oe f oe l first last events respectively executed processor p procedure op interval op execution segment operation terminate interval infinite execution segment two operations overlap intervals overlap invocation operation may result different intervals depending context execution example two intervals operation may differ even return different values first executed isolation second overlaps operations let ff interval p step complexity ff denoted stepff number events p ff op op 3 figure 1 simple conflict graph execution fi linearizable 17 total ordering implemented operations fi preserving order nonoverlapping operations response satisfies semantics h given responses previous operations total order implementation nonblocking point processor pending operation completes within bounded number steps 22 sensitivity conflict graph execution segment ff represents dependencies data sets operations ff undirected graph denoted g ff node g ff represents memory word edge two nodes j corresponds operation data set fm whose interval overlaps ff g ff may contain parallel edges ff contains several operations data set 1 example 1 let ff finite interval operation opm overlapped shows g ff next consider conflict graph interval operation op measure distance edges representing op operations delay execution op maximum distance measured intervals implementation determines sensitivity detail assume ff interval operation op let op operation ops connected component g ff distance op op ff number edges shortest path g ff whose endpoints edges representing op op intuitively sensitivity measures minimum distance guaranteeing two operations interfere say operation op 2 interfere operation op 1 step complexity op 1 whether op 2 executed parallel definition modified sensitivity depends complexity measures eg set memory words accessed earlier version work 6 10 defined contention graph execution nodes represent operations edges represent memory words data sets dual conflict graph contention graph captures dependencies operations somewhat accurately conflict graph easier work interval ff operation op sensitive distance interval ff 0 op exactly one operation ie edge g ff distance edge representing op step complexity op increases single operation added ff distance op sensitivity interval ff maximum ff sensitive distance means step complexity op increase single operation added ff distance 1 maximum exist sensitivity 1 sensitivity implementation maximum sensitivity intervals sensitivity captures noninterference operations following sense sensitivity implementation distance two operations conflict graph step complexity measure consider operations whether execute parallel 23 related complexity measures disjointaccess parallelism 19 requires operation complete constant number steps operations contend memory words sensitivity strengthens notion allows evaluate behavior implementation also presence contention afek et al 1 suggest two complexity measures 1 algorithm dlocal step complexity number steps performed interval ff bounded function number operations within distance g ff 2 algorithm dlocal contention two operations access memory word distance conflict graph joint interval clearly sensitivity 1 implies dlocal step complexity however converse true example suppose data set operation op contains hot spot accessed operations suppose also path operations length sensitivity 1 allow operations path influence ops performance 1local step complexity op may still help distant operations path local contention orthogonal sensitivity local step complexity evaluated addition either however operations access memory words associated operations help dlocal contention follows sensitivity 1 contention locality algorithm discussed end section 4 dwork herlihy waarts 12 suggest measure step complexity algorithms taking contention account assuming concurrent accesses memory words penalized delaying response good complexity measure evaluate solutions specific problems however implementations multiword operations inevitably result concurrent accesses words creating hot spots complexity measure propose sensitivity appropriate evaluating multiword implementations measures influence hot spots 3 leftright algorithm general scheme implementing multiword operations 3 7 19 25 27 operation locks pair memory words executing operation helps stuck operations avoid blocking section introduce variant scheme leftright algorithm operations lock memory words different orders show sensitivity liveness leftright algorithm depend orientation conflict graph induced locking orders overlapping operations end section discuss data structures operations inherent asymmetry data structures leftright algorithm directly applied achieve constant sensitivity next section show break symmetry general situations govern locking directions reduce sensitivity 31 overview known scheme implementing multiword operations unary operations 7 19 25 27 requires processor go following stages locking lock memory words execution apply operation memory words unlocking unlock memory words operation assigned unique identifier memory word locked operation operations id written word word unlocked contains memory word locked operation operation modifies memory word unlocked operation blocked finds words needs locked another blocking operation case processor executing blocked operation helps blocking operation figure 2 scenario high sensitivity order helped operations details published invoked state maintained execution helping implies one processor may execute operation initiating processor processor invoking operation executing processors processors helping complete although one processor perform operation advanced processor point execution performs operation executing processors effect blocking operation helped either locking stage already execution stage unlocking stage operation execution unlocking stages already locked words operation locked data set never blocked therefore operation helping blocking operation passed locking stage guaranteed blocked contrast operation still locking stage blocked third operation turn blocked fourth operation therefore help blocking operation locking stage may continue transitively nonblocking implementation guarantees operation eventually terminates transitive helping stops yet sensitivity high illustrated next example example 2 consider scenario n overlapping operations op data set op fm assume every operation op locks lowaddress word tries lock highaddress word 2 op delayed locked op 2 op 1 help op 2 since highaddress word op 2 locked recursively help op 3 etc thus sensitivity simple implementation least n gamma 1 example 2 operations symmetric try lock memory words order lowaddress word first main idea leftright algorithm implemented operations binary asymmetry introduced operations lock memory words two directions either left rightlowaddress word first right lefthighaddress word first example 3 consider example 2 assume oddnumbered operations op lock lowaddress word first evennumbered operations op address word first op odd locks lowaddress word finds highaddress locked another operation must op i1 op i1 already locked data set therefore op help op i1 execution unlocking stage operations operation decides locking direction locking stage operation terminates unlocking stage resets sharedmemory areas used decision algorithm thus two new stages decision postdecision encapsulating algorithm section focus locking unlocking stages leaving decision postdecision stages algorithms next section 32 pseudocode simplify code description separate sharedmemory area used locking unlocking stages size area size data area memory word locking area corresponds memory word data area algorithm uses shared array opdetails initiating processor publishes operations description operation starts initiating processor also sets operation id opid used later stages opid composed id initiating processor timestamp generated timestamp function returns unique id time invoked algorithm follows general scheme discussed earlier except locking done either left right right left operation discovers word locked another operation helps blocking operation executing stages unlocks words operation tries pseudocode appears algorithm 1 locking unlocking stages executed several processors behalf operation therefore synchronization needed ensure errors caused concurrent processors executing operation algorithm 2 presents details shared procedures used locking unlocking user responsible avoiding synchronization errors execution stage local variable tmp used procedures holds last value read shared memory main synchronization mechanismguaranteeing advanced executing processor actually makes progressis timestamp part operation id field written initiating processor beginning operation cleared beginning unlocking stage operation valid timestamp set invalid timestamp set executing processor finding operation invalid timestamp set skips directly unlocking stage ensures memory word unlocked operation locked operation similar considerations apply unlocking word memory word initially locked operation contains id procedure lock locks two memory words order given parameters single memory word locked celllock attempts lock word operation algorithm 1 leftright algorithm code processor p record lowword highword data set ts timestamp direction locking direction shared state opdetailsn procedure atomically write opdetailsi publish ts decidem decide locking direction helpopid help procedure helpopid locking stage opdetailsopidpiddirection left locklow high opid left right else lockhigh left opid right left executionlow high opid execution stage unlocklow high opid unlocking stage postdecisionlow high opid clean memory still valid word locked another operation procedure rereads word word locked operation procedure returns true word locked another operation executing processor helps blocking operation tries operation becomes invalid procedure returns false help another operation blocked operation invokes help blocking opera tions id argument blocked operation becomes executing processor blocking operation goes stages procedure unlock invalidates operation resetting ts field prevents executing processors locking words unlocks two memory words cellunlock unlocks single word still locked operation success sc checked fails word already unlocked another executing processor procedure validate compares timestamp passed operation id timestamp ts field operations entry opdetails operation valid equal algorithm 2 leftright algorithm shared procedures processor p procedure lockx opid celllockx opid celllocky opid procedure celllockaddr opid try lock locked tmp opid return true else helptmp validateopid return false check operation ended procedure validateop opdetailsoppidts opts return true else return false procedure unlockx opid invalidate operation cellunlockx opid unlock words cellunlocky opid procedure cellunlockaddr opid procedure decidem function decide makes sure first executing processor return decision left unspecified writes decision operations details 2 mentioned responsibility user avoid synchronization errors execution stage user use timestamp operation may add state information necessary example implemented operation sc2 need check write operation still valid manner similar celllock function needed point decision stage executed initiating processor 33 proof correctness proof algorithm linearizable follows general schemes eg 7 19 25 27 locking unlocking shown behave correctly thus show data set operation locked execution stage unlocked operation terminates executing processor returns celllock either memory word locked operation operation invalid operation becomes invalid executing processor reaches unlocking stage previously completing locking stage therefore first executing processor returns celllock word locked operation proves next lemma lemma 31 data set operation op locked first executing processor op completes locking stage procedure cellunlock checks word first thus word unlocked executing processor operation locked implying following lemma lemma 32 data set operation op remains locked first executing processor op reaches unlocking stage next lemma proves executing processor unlocks memory word executing processor locks lemma 33 data set operation op remains unlocked first executing processor op reaches unlocking stage proof executing processor op starts unlocking stage initializing timestamp field opdetails thus invalidating op performs llm scm another executing processor op tries lock afterwards validates op performing llm finds operation valid value read executing processor try lock thus lock field locked word written order unlock implies two things first sc cellunlock fails another executing processor unlocked second executing processor lock 34 progress sensitivity liveness properties algorithm sensitivity depend orientation conflict graph according locking directions figure 3 reducing sensitivity helping directions let ff interval operation op helping graph ff h ff mixed graph representing helping among operations overlapping ff nodes h ff memory words accessed operations overlapping ff edge e nodes 1 2 constitute data set operation ff direction e operations ff data set fm direction e operations ff data set fm otherwise e undirected h ff partially oriented version g ff conflict graph ff lemma 34 let fi execution leftright algorithm operation completes helping graph interval fi contains either undirected edge directed cycle proof must point fi operation completes let ff interval blocked operation op fi leftright algorithm op blocked lock data set since op terminate blocking operation blocked another blocked operation since number processors finite processor one pending operation number blocked operations fi also finite therefore cycle blocked operations op 2 algorithm blocked operation helps blocking operation two operations blocking helping implies data set lock different directions undirected edge h ff l 2 three operations blocking helping directed cycle h ff next analyze sensitivity algorithm consider two operations op 1 data set fm op 2 data set fm g assume helping graph edge 1 2 directed 2 edge 2 3 also directed 2 see figure 3 op 1 helps op 2 code celllock 2 locked op 2 however op 2 locks 3 locking 2 passed locking stage thus op 1 helps op 2 execution unlocking stages argument generalized next lemma lemma 35 let ff interval operation op let op j overlapping operation directed path memory word op memory word op j h ff exists another interval op ff 0 overlapping operations except op j proof let op set operations op helps directed paths op operations op implies directed path memory word operation op memory word op j h ff since directed path memory word op memory word op j h ff thus operations op help op j argued lemma construct execution ff 0 without op j ff 0 op performs sequence steps ff moreover operations op lock words order ff ff 0 execution leftright algorithm let op k first operation op locks word ff ff 0 algorithm happens another operation holds lock word however add new operations ff 0 omit op j sequence locking op k locking ff 0 ff thus word unlocked ff also unlocked ff 0 op k succeeds locking word performs sequence steps ff ff 0 length directed paths h ff bounded operations distance 1 increase number steps taken operation lemma 35 lemma 36 let ff interval leftright algorithm length directed path h ff sensitivity ff 1 35 data structures constant sensitivity discuss two data structures memory access patterns operations structured therefore locking directions determined priori obtain constant sensitivity linked list linked list implemented inside array data set operation i1 let locking direction operation determined parity lowaddress word locking direction operation accessing left even right odd clearly neighboring operations conflict graph lock opposite directions therefore maximum length directed path one lemma 34 implementation nonblocking lemma 36 sensitivity two v v b figure 4 binary operations heap v g even depth heap israeli rappoport 18 present implementation heap supporting bubble bubble using unary binary sc2 operations implementation data set binary operation always parent node one children order implement binary operations use leftright algorithm let locking direction operation parity depth higher node lock clearly operations data set locking direction see length directed path two let v g v f v v b four nodes heap v g parent node v f v f parent node v v b see figure 4 two kinds paths formed contending operations first kind depths monotone eg case neighboring operations lock opposite directions hence directed path v v g v b v g formed second kind depths monotone eg case neighboring operations lock direction determined depth v f directed path formed v v b therefore longest directed path length one lemma 34 algorithm nonblocking lemma 36 sensitivity two 4 decision algorithm access patterns known advance processors dynamically decide locking directions section present algorithm choosing locking directions gathering information memory access patterns minimize sensitivity simplicity separate sharedmemory area used decision stage size area size locking area data area memory word decision area corresponds word locking data areas op op figure 5 locking directions highaddress word equal lowaddress word op op figure locking directions lowaddress words equal consider simple example data set op fm data set op 0 assume data sets intersect highaddress word op lowaddress word op 0 locking directions op op 0 different order avoid directed path see figure 5 lowaddress word op lowaddress word op 0 locking directions op 1 op 2 equal order avoid directed path see figure 6 similarly highaddress word op highaddress word op 0 example leads us concentrate monotone paths highaddress word one operation lowaddress word another operation figure 5 situation want neighboring operations lock different directions much possible first describe algorithm restricted case single monotone path handle general case decomposing arbitrary conflict graph monotone paths 41 monotone paths operations op initiated processor id pid data set op operations lower indices op called downstream neighbors operations higher indices op called upstream neighbors situation similar one depicted figure 2 assume operation chooses locking direction according following rule smaller pid upstream neighbor pid i1 op decides left otherwise op decides right edge operation upstream neighbor decides left rule directed paths correspond ascending descending chains pids example operations decide left pids appear ascending order key insight length longest chain ascending descending pids depends range pids range pids reduced ensuring adjacent operations different pids rule guarantees short directed paths reduce range pids using deterministic coin tossing technique cole vishkin 9 symmetry breaking algorithm synchronous rings adapt monotone paths asynchronous system colevishkin algorithm works phases phase range reduced logarithmic factor range small range reduced rule applied although new pids unique fact pids adjacent operations different ensures operations decide locking directions see order perform k range reduction phases operation know pids k operations operations without k neighbors decide left called edge operations 3 algorithm guarantees alternation propertyadjacent pids equal assume pids phase k range lg alternation property length ascending descending sequence pids l however since may chain l operations locking direction monotone paths simplify description assuming operations start together b operation waits locking stage operations finish locking stage later remove assumptions first describe single phase algorithm reducing range pids olog n memory operations applying ideas repeatedly reduces range olog n using olog n memory operations 411 single phase operation begins phase writing pid lowaddress word since operations start together memory words written together since operation waits operations finish locking stage memory words overwritten operation choosing direction pids induce pointers consecutive words path pid lowaddress word leads operations details record highaddress word operation found 3 edge operations may also decide according parity distance end path figure 7 reduction pids single phase assume op reads three pids pid i1 i2 denoted respectively binary representations processors pids strings length dlog ne bits numbered 0 dlog ne gamma 1 going least significant bit significant bit let j index least significant rightmost bit binary representations pid 0 pid 0 represented binary string length dlog log ne concatenation binary representation j b j value jth bit pid 0 note length pid 1 dlog log ne similar manner op computes pid example 4 consider figure 7 example pid 0 01010101 85 pid 11111101 254 pid 0 i2 01111101 126 index rightmost bit differ 3 value pid 0 0 thus pid 1 0110 6 index rightmost bit pid 0 differ 7 value pid since memory word modified decision stage op op i1 use pid 0 1 implies single phase consistentthe new pid computed operation op equal new pid computed op downstream neighboras stated next lemma lemma 41 op op i1 neighboring operations path calculate value pid 1 1 thus refer pid 1 without mentioning processor calculates described pid 1 composed bit part denoted pid 1 ibit index part denoted pid 1 iindex pid 1 thus pid 0 pid 0 bit position pid 1 contradicting fact pid 1 iindex rightmost bit pid 0 pid 0 differ proves following lemma lemma 42 op op i1 neighboring operations path pid 0 6 pid since initial pids distinct lemma implies consecutive values pid 1 equal proving alternation property 412 multiphase algorithm describe idea applied repeatedly reduce pids three bits long guarantees longest monotone sequence pids contains eight operations denote 0 n dlog ne let j fn smallest integer j j n 3 note operation starts writing pid lowaddress word reads upstream memory words edge operation without neighbors chooses left without calculation let pids read op pid 0 pid 0 1 iterating operation computes pid k j pid kgamma1 j pid 1 every j singlephase algorithm section 411 lemma 41 immediately implies algorithm consistent lemma 43 op op i1 neighboring operations path calculate value pid k 1 every k alternation property proved induction applying lemma 42 every iteration lemma 44 op op i1 neighboring operations path pid 0 6 pid proof proof induction phases local computation denoted k 0 fn base case 1 assumption induction step assume lemma holds phase k every consecutive pair pid k different values since iteration onephase algorithm lemma 42 implies pid k1 6 pid represented less three bits thus represented three bits however x 3 shows iteration pids length strictly reduced fn iterations length three showing every value pid fngamma1 three bits long thus eight consecutive operations ascending descending pid fn values range pids reduced operation chooses locking direction comparing pid pid upstream neighbor following rule edge operations without neighbors decide left 8 consecutive operations decide left eight consecutive operations decide right proves following theorem theorem 45 length directed path 8 42 general topology order apply range reduction technique previous section general topologies disentangle arbitrary combination overlapping contending operations collection monotone paths achieve operation first checks whether data set may create nonmonotone path operation stalls helping operations otherwise applies algorithm monotone path explain idea need define monotone paths precisely assume memory words l form undirected path conflict graph memory word local minimum local maximum local minimum created two operations lowaddress word figure 6 local maximum created two operations highaddress word path monotone contain local minima maxima decision stage operation preceded separate marking stage marking stage operations check memory access patterns trying lock memory words detect local minima maxima avoid nonmonotone paths one operations forming local minimum local maximum continues others stall marking stage maintains variant conflict graph shared memory nodes marked memory words word either marked low lowaddress word operation marked high highaddress word operation word marked low high lowaddress word one operation high address word another operation marked memory word data set operation stalled operation starts trying mark lowaddress highaddress words marking succeeds operations data set monotone path operation decides locking direction manner similar section 41 marking fails operations data set creates nonmonotone path operation stalls helping operations word two special fieldsfor low marking high marking operation marks word writing id instead lowhigh field marking fails relevant field operation succeeds marking low field lowaddress word tries mark high field highaddress word operation unmarks data set unlocking word cannot marked high twice low twice implying two overlapping operations highaddress word lowaddress address word one succeeds marking word stalls consequently local minima maxima avoiding nonmonotone paths operation mark memory word low even word already marked high another operation respect marking different locking since word locked two different operations marked two different operations two problems arise due dynamic nature conflict 1 new operations join end marked path locking stage starts edge operation may help upstream operations finds end path increase sensitivity locking stage 2 operation may unmark data set another operation data set may take place yield inconsistencies downstream operations use first operations pid local computations downstream operations use second operations pid problems handled mechanism operation finding end path prunes path placing special end symbol low field last word path operation later mark last word low hence new operation appended end path operation unmarks data set replaces id end low field lowaddress word word marked high ie downstream neighbor way path cut word data set unmarked new operations able mark word confuse downstream operations high field unmarked low field marked end fields cleared set 421 pseudocode memory word contains two fields marking low high may contain operation id end initially binary intersection field added record containing operations details field set operation intersected ie highaddress word already marked high another operation part another monotone path intersection field cleared beginning marking stage set operation cleared operation terminates operation holds local array idarray pids upstream operations collected local computation monotone path algorithm section 41 tmp variable contains last value read low highlevel functions functionality local variables clear code highlevel procedures decision postdecision stages appear algorithm 3 algorithms 4 5 detail code synchronizing access shared data structures operation starts initializing local variables see code clearing intersection field operation tries mark lowaddress word using first marking fails first operation helps operation whose id marking word low word unmarked tries marking succeeds operation continues advance next memory word operation extracts initiating processors id operation id current word reads highaddress word record opdetails array next word monotone path operation also stores initiating processors id idarray local computation operation marks highaddress word using next high low fields empty operation tries mark high field word put end mark low field successful operation marked end path returns left high field empty low field tries mark high field word successful continues upstream words otherwise intersection another path operation sets intersection flag unmarks lowaddress word helps operation written high field word starts intersected operation first unmarks lowaddress word operations helping continue help upstream operations operation op uses next access upstream words parameters passed next address last word accessed op current address op j id operation whose highaddress word hence op helps op j mark highaddress word note op finds op j intersected op acts discovers end path since op j going unmark lowaddress word operation unmarks lowaddress word unmarklow highaddress word unmarkhigh procedure unmarklow replaces id end low field low address word high field lowaddress address word ie downstream neighbor otherwise clears low field algorithm 3 general algorithm decision postdecision stages local id myopid id operation executed local id lastopid id last operation read local id idarrayfn2 local computation reduced id local addr current prev current previous addresses local int index index idarray local addr tmp persistent used advance procedure decisionm opdetailsopidpidintersecting lowaddress word advance next word tmplow tmp set first inside current nextprev current opid return left edge operation return according local computation idarray monotone path algorithm procedure firstaddr opid repeatedly try mark lowaddress word marklowaddr opid return else helpaddrlow procedure nextprev addr opid repeatedly try mark upstream words markendaddr opid return true edge operation markhighaddr opid return false continue next word path setintersectionaddr opid intersected operation initiating processor unmarkwordprev unmark lowaddress word get opid intersected operation restart operation get new timestamp clear intersection flag else return true initiating processor validateopid return true edge operation procedure postdecisionm algorithm 4 general algorithm lowlevel procedures decision stage procedure marklowaddr opid tmplow opid return true marking successful else tmplow 6 return false marked another operation procedure markendaddr opid checkintersectionopid intersected scaddropid end mark ending tmphigh opid return true marking successful else tmphigh 6 return false marked another operation procedure markhighaddr opid checkintersectionopid intersected tmphigh opid return true marking successful else tmphigh 6 return false marked another operation procedure checkintersectionopid scopdetailsopidpidintersection tmp touch intersection flag else return false procedure setintersectionaddr opid scopdetailsopidpidintersection true return opdetailsopidpidintersection algorithm 5 general algorithm lowlevel procedures postdecision stage procedure unmarklowaddr opid tmplow opid downstream operations ending mark low else scaddr else return procedure unmarkhighaddr opid tmphigh opid tmplow end edge operation ending mark else scaddr tmplow unmark high field else return 422 proof correctness proof correctness concentrates properties marking stage prove data set operation marked first executing operation enters locking stage unmarked first executing processor completes operation operation marks lowaddress word first tries mark highaddress word first call next nonintersected operation returns next marks word passed parameter intersected operation restarts return next therefore highaddress word marked first call next returns implies next lemma lemma 46 data set operation op marked first executing processor op enters locking stage word unmarked postdecision stage reached initiating processor finds operation intersected next restarts operation implies next lemma lemma 47 data set operation remains marked operation completes next prove data set operation remains unmarked operation completes problem may occur executing processors set intersection flag executing processors mark highaddress word setintersection write high markhigh readintersection figure 8 illustration proof lemma 48 case 1 lemma 48 intersection flag operation set highaddress word marked proof three procedures access high fieldmarkend markhigh unmarkhigh procedure unmarkhigh mark unmarked word therefore markend markhigh mark previously unmarked operation consider markhigh proof applies markend synchronization structure let highaddress word operation op consider memory accesses setintersection markhigh call checkintersection expanded setintersection markhigh h5 scmhigh case 1 suppose marked high mintersection set s3 precedes h5 scmhigh markhigh h5 reached readmintersection markhigh h4 returns hence h4 precedes scmintersection setintersection s3 since llmhigh markhigh h1 returns precedes readmhigh setintersection s2 returns non value see figure 8 therefore intervening write mhigh llmhigh matching scmhigh markhigh sc fails case 2 suppose mintersection set marked high h5 precedes s3 scmintersection setintersection s3 succeeds scmintersection markhigh precedes llmintersection setintersection s1 see figure 9 since llmhigh markhigh returns readmhigh setintersection s2 returns non value intervening write mhigh llmhigh matching scmhigh markhigh sc fails setintersection write high markhigh figure 9 illustration proof lemma 48 case 2 lemma 49 data set operation op remains unmarked op terminates proof lowaddress word op marked initiating processor op processor starts executing op thus executing processor op marks unmarked proves lemma lowaddress word op assume highaddress word op op terminates postdecision stage op invalidated ts field reset data set unmarked unmarkword op terminates since intersected next intersection flag set operation invalidated initiating processor lemma 48 memory word marked intersection flag set therefore prove unmarked highaddress word marked op invalid markend markhigh mark highaddress word proof lemma 48 consider markhigh assume way contradiction markhigh marks unmarked op invalid since markhigh validates operation marking op invalidated validation scmhigh operation markhigh moreover operation markhigh reads mlow mhigh lemma 46 marked first executing processor op reaches locking stage unmarked operation invalidated thus marked write mhigh llmhigh matching scmhigh markhigh sc fails 423 analysis algorithm lemma 410 monotone paths exist locking stage proof data set operation marked first executing process enters locking stage lemma 46 remains marked first executing process completes postdecision stage lemma 47 memory word marked low twice marked high twice different operations code marklow markhigh markend thus two operations low address highaddress words cannot locking stage together local minima maxima monotone paths exist locking stage lemma 411 let op downstream neighbor op i1 assume op op i1 decide local computation last fn entries idarray first fn entries idarray i1 proof lemma 410 data sets op op i1 monotone path op i1 read different values memory word j operation unmarked j reads j without loss generality let op operation reads j unmarked argue op j exits edge operation induction distance conflict graph contradicts assumption op op i1 decide local computation proves lemma base case distance 1 data set op op marks j ending word op edge operation claim proved another operation op 0 marks j ending word since lowaddress word marked highaddress word also marked op 0 thus op j mark data set therefore stalls claim follows induction step assume lemma holds distance j assume distance l op reads end j op edge operation claim follows since j unmarked op reads operation op writes marked end op claim follows induction hypothesis otherwise op finds op invalid therefore next returns true op exists edge operation decision algorithm monotone path general decision algorithm differ marking phase lemma 411 implies new pid computed operation op equal new pid computed op downstream neighbor since algorithms local computation theorem 45 implies lemma 412 length directed path nonedge operations eight end path fn1 operations edge operation new operations join end path marking low field last word since contains end therefore edge operation helps operations distance smaller equal fn 1 lemma 413 edge operation help upstream operations distance larger theorem 414 sensitivity decision stage locking stage olog n proof sensitivity decision stage fn since operation advances fn words path conflict graph contains highaddress word directed path length nine locking stage operations lock right left decide local computation contradicts lemma 412 directed path length 9 locking stage operations lock left right edge operation path distance larger fn1 end path lemma 412 contradicts lemma 413 lemma 36 sensitivity locking stage fn algorithm guarantee local contention defined 1 two operations may access entry opdetails different operations processor although far away conflict graph happens since opdetails array indexed processors ids easily fixed indexing opdetails operations ids done 1 5 step complexity implementing binary llsc section prove omegagamma22 log n lower bound number steps required implementing binary sc operation using unary operations lower bound proved showing problem solved o1 operations using binary llsc requires omegagammaequ log n operations unary operations type used separating problem variant maximal independent set mis problem defined follows set n processors organized virtual ring processor assigned initialized memory word gets input address memory word clockwise neighbor next every processor terminate either member nonmember required two consecutive processors members b nonmember processor least one neighbor halt member problem trivially solved binary synchronization operations sc2 processor loadlinks loadlinks next tries sc2 pid atomically next p succeeds exists member otherwise exists nonmember next show maximal independent set algorithm uses unary operations execution processor performs least omegagammaast log n operations linial proved omegagammaat n rounds required solve mis problem messagepassing model 20 modify proof sharedmemory model get smaller bound linial uses fact messagepassing model round processor knows addresses pids processor distance true sharedmemory model assume computation proceeds rounds round processor performs single memory operation processor knows addresses neighbors rounds round processor accesses memory word processor distance k knows addresses k neighbors 1 however next lemma proves best may happen lemma 51 round processor ring knows pids addresses processors distance 2 proof lemma proved induction round number base case round processor knows receives input addresses two words knows address clockwise neighbor induction step assume lemma holds round prove lemma 1 induction assumption round processor p knows pids addresses processors distance 2 thus round 1 processor p access single processor distance 2 learn pids addresses processor knows therefore know pids addresses processors distance rest proof closely follows linial 20 first argue algorithm finding maximal independent set ring converted 3coloring algorithm one operation processor decides membership checks decision right neighbor decide nonmembers picks color decides member neighbor decides nonmember picks color 2 otherwise picks color 3 let v set vectors v v mutually distinct processors ids 3coloring algorithm mapping c v f123g construct graph b xn whose set nodes v edges b xn form v nodes regular graph degree mapping 3coloring b xn see suppose c maps v color 3coloring algorithm ring fails labeling happens contain segment u v result linial 20 chromatic number b xn n therefore color xn three colors must x omegagamma323 n log n implies omegagammaat log n steps needs order solve mis problem together o1 algorithm solves mis problem using binary llsc proves following theorem theorem 52 implementation binary llsc operations unary operations must omegagammae1 log n step complexity 6 discussion paper defines sensitivity implementing binary operations unary operations sensitivity distance terms intersecting data sets two concurrent operations guarantees interfere clearly sensitivity implementation low operations execute concurrently less interference context say one operation interfere operation one delayed however notion interference modified example one add requirement set memory words accessed operation change executes concurrently another operation present algorithm implementing binary operation type unary sc operations sensitivity olog n algorithm employs symmetry breaking algorithm based deterministic coin tossing 9 practical purposes simple nondeterministic symmetry breaking technique could employed however care taken avoid deadlocks scheme interestingly core algorithmlocking memory words two directionsis similar leftright dining philosophers algorithm cf 21 pp 344349 problem n philosophers sit around table fork pair philosophers time time philosopher gets hungry pick two forks sides order eat leftright dining philosophers algorithm philosopher sitting oddnumbered place first picks left fork philosopher sitting evennumber place first picks right fork implementation linked list guarantees short waiting chains many philosophers hungry also prove implementation binary llsc unary operations incur nonconstant overhead step complexity lower bound tight since step complexity waitfree extension algorithm 1 least olog n acknowledgments authors thank shlomo moran lihu rappoport gadi tauben feld helpful comments previous version paper r disentangling multiobject opera tions performance issues nonblocking synchronization sharedmemory multiprocessors universal constructions multiobject operations primitives asynchronous list compression performance spin lock alternatives sharedmemory multipro cessors universal operations unary versus binary method implementing lockfree data structures localizing failures distributed synchronization deterministic coin tossing applications optimal parallel list ranking universal operations unary versus binary alpha architecture handbook contention shared memory systems synergy nonblocking synchronization operating system structure methodology implementing highly concurrent data objects transactional memory architectural support lockfree data structures correctness condition concurrent objects efficient waitfree implementation concurrent priority queue locality distributed graph algorithms distributed algorithms powerpc architecture specification new family risc processors hot spot software transactional memory alpha axp architecture locking without blocking making lock based concurrent data structure algorithms nonblocking tr deterministic coin tossing applications optimal parallel list ranking linearizability correctness condition concurrent objects waitfree synchronization locality distributed graph algorithms performance issues nonblocking synchronization sharedmemory multiprocessors locking without blocking alpha axp architecture methodology implementing highly concurrent data objects transactional memory method implementing lockfree shareddata structures powerpc architecture primitives asynchronous list compression disjointaccessparallel implementations strong shared memory primitives synergy nonblocking synchronization operating system structure localizing failures distributed synchronization universal operations disentangling multiobject operations extended abstract contention shared memory algorithms universal constructions large objects distributed algorithms performance spin lock alternatives sharedmoney multiprocessors efficient waitfree implementation concurrent priority queue
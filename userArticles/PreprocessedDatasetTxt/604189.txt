typed interface garbage collection important consideration certified code systems interaction untrusted program runtime system notably garbage collector certified code systems treat garbage collector part trusted computing base dispense issue using collector whose interface program simple enough pose certification challenges however approach rules use many sophisticated highperformance garbage collectors present language lgc whose type system capable expressing interface modern highperformance garbage collector use lgc describe interface one collector involves substantial amount programming type constructor level language b introduction certified code system executable programs shipped producer client accompanied certificates material based work supported part nsf grants ccr 9984812 ccr0121633 nsf fellowship opinions findings conclusions recommendations publication authors reflect views agency permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copies bear notice full citation first page copy otherwise republish post servers redistribute lists requires prior specific permission andor fee tldi03 january 18 2003 new orleans louisiana usa acm 1581136498030001 500 provide evidence safety validity cer tificate mechanically verified client implies associated program safe execute examples certified code frameworks include typed assembly language 6 proofcarrying code 7 8 past research certified code focused safety untrusted mobile code however also important consider safety implications runtime system code linked two options dealing issue one choice treat runtime system part untrusted code certify safety choice simply assume runtime system correctie treat part trusted computing base includes certificate verifier course even runtime assumed correct interaction program runtime must certified conform appropriate interface important part runtime system many modern languages garbage collector frameworks runtime system must certified must use certification technology capable proving garbage collector safe work approach includes wang appel 10 9 monnier et al 4 systems take second approach many assume existence trusted conservative garbage collector advantage application interface conservative collector simple almost ignored performance benefits gained using precise collector ever interface collector subtle issue certifying program conformance interface longer ignored order use better garbage collector certified code applications interface collector must described expressed type system topic paper specification interface particular modern garbage collector namely cheng blelloch 1 2 implemented tiltml runtime system informally describing behavior collector interface running program present language whose type system express inter language called lgc built simple stack based language call lgc extension typing constructs necessary express various elements collectors interface present lgc describe interface chengs garbage collector precise definition involves substantial amount programming language type constructors finally discuss expressiveness lgc language int g g newer frames fs locals gs arguments gs locals fs frame gs frame older frames fs arguments return address return address f int f figure 1 frames stack 11 garbage collectors interface first part garbage collectors job find root setthose registers globals stack locations contain pointers heap task part garbage collection requires compiler cooperation part makes assumptions behavior program section describe simplified form rootfinding algorithm used tiltml ignore complications optimization calleesave registers assume roots stored stack therefore ignore additional work finding roots among registers global variables garbage collector assumes stack laid sequence frames belonging particular function created frame contains number data slots including function arguments local variables temporaries well return address section stack illustrated figure 1 usual stack shown growing downwards figure function f called function g thus return address position gs frame contain location somewhere inside code f fact return address found gs frame uniquely identifies point program g called therefore also determines layout frame garbage collector uses property parse stack program compiled compiler emits type information collected runtime system gc table mapping return addresses iden tifying function call sites information stack frame function containing call site collector begins looking roots newest frame stack collector return address frame looked gc table find description next frame belongs untrusted program collector moves stack performing following steps frame 1 using return address frame examined find gc table entry describes frame 2 using gc table entry determine following information locations pointers current frame roots location return address within current frame size current frame 3 using information find start next frame look gc table entry steps repeated base stack reached clearly correct gc table essential operation garbage collector incorrect value table could lead variety errors single root pointer ignored derailment entire stackparsing pro cess put another way crucial program structure use stack consistently frame descriptions gc table paper present language stacks layout precisely controlled giving us ability guarantee structure stack collection consistent collectors expectations 2 language gc interface main goal paper describe type system shape program stack made fit pattern expected garbage collector must therefore language stack manipulation explicit expressive enough describe stack precise terms section begin describe language call lgc start simple core language call lgc simple stackbased language sophisticated type constructs support garbage collection discuss refinements necessary enforce compliance gc table syntax typing rules full lgc given appendix 21 core language syntax lgc given figure 2 language essentially polymorphic calculus integers booleans tuples sum types plus stack handled much way stackbased typed assembly language stal 5 details language directly relate garbage collection particularly important purposesindeed many possible language designs would work equally welland discuss aspects briefly throughout paper consider expressions dier names bound variables identical denote ee1 enx1 result simultaneous captureavoiding substitution e1 en variables x1 xn e programs lgc program consists sequence mutually recursive code block definitions followed ex pression block form spe indicating must instantiated number kind type constructor arguments specified may invoked whenever stack type invoking block results evaluation e notice data stack passed block means kinds k st constructors c int bool code 0 1 n 1 null values v x n b vc pack c v expressions e halt v jump v v e1 else e2 case v inj 1 x1 e1 inj n xn en let e declarations blocks b spe programs p letcode type contexts k contexts x memory types figure 2 syntax lgc function arguments results must passed stack return address function call must also passed stack leading continuationpassing style programs also code blocks program appear top level programs must undergo closure conversion translation lgc expressions body block expression expressions lgc include halt instruction stops computation jump instruction takes code label transfers control corresponding block thenelse construct case analysis sums form letbinding performs one operation possibly binding result variable continues another expres sion bindings may occur let simple value binding arithmetic operations injection sum types allocation tuples projection tuples unpacking values existential type binds new constructor variable addition variable x stack operations stack operations reading writing spi v pushing value onto stack push v popping values stack pop syntactic values language variables x numerals n boolean constants b code labels instantiations polymorphic values constructors vc packages containing constructor value pack c v existential type types kinds type theory two kinds st classify constructors constructors kind called types describe values constructors kind st called stack types describe stack constructors include constructor variables base types int bool code label types code 0 nary products 1 n sums 1 types k empty stack type null nonempty stack types form stal one writes nil respectively lgc prefer use mllike list notation actual lists constructors metavariable c used range constructors also use names intend constructor named type stack type respec tively extend kind constructor levels type system later paper order precisely describe shape stack static semantics typing rules simple language generally expected ones due space considera tions present generally similar full lgc language whose rules appendix however discuss typing rules turning examine programs language interact garbage collector one simplest typing rules expressions language one unconditional jump instruction rule states legal jump fullyinstantiated code pointer one expect constructor arguments provided stack type expected code pointer current stack type jump polymorphic code pointer one must first instantiate applying appropriate number kind type arguments rule following another simple typing rule one binding value variable read algorithmically rule understood follows check expression let e valid first find type value v check e valid assumption x type 22 requirements garbage collection goal certifying interaction garbage collec tor lgc unacceptably simplistic fact syntax typing rules discussed far appear ignore collector completely section begin identify specific shortcomings language done remainder paper devoted adding necessary refinements language resulting full lgc type system already explained program language work properly garbage collector collector must able find roots whenever invoked practice garbage collector usually invoked program attempts create new object heap insucient space available expressions language perform allocation tuple formation injection sum types means garbage collector may need able find root set evaluation expression form let let e discuss tuples since modifications necessary sums exactly analogous nave version typing rule tuple allocation would following x1 n sp e two main changes must made rule first must force roots stack found collector second must force stack structure collector parse first problem stems fact variables language stack allocated want assume sake simplicity garbage collector scans stack looking roots free occurrence variable expression e could denote pointer pointer could used evaluation e copy pointer stack garbage collector may identify live solution force program dump contents variables stack whenever collection might occur accomplish require continuation e closed except result x allocation rule looks like note realistic abstract machine would registers instead variables order support gc table certification machine would apply techniques discuss remainder paper register file well stack seems straightforward sake simplicity limit discussion paper collector find roots stack second modification must made allocation rule significantly dicult formulate fact rest paper devoted adding single additional premise rule namely one stipulates stack type parsable must describe structure stack must order scanned collector express structure way enforced type system type system lgc task continuing must endow expressive power meet needs 23 enriching constructor language order able give typing constraint allocation rule precisely describes required structure stack must enrich constructor level lan guage purpose add number constructs kinds k j k1 k2 k1 k2 k1 jk 1 constructors c kc c1 c2 c1 c2 c unit void c c figure 3 kinds constructors lx crary weirichs lx type theory 3 additions language shown figure 3 addition function spaces products sums kinds k1 k2 k1 k2 k1 k2 lx provides inductive kinds jk j kind variable may appear positive positions within k type constructor level change syntax product sum types c c case c constructor kind j1tj represents list types keep notation lgc simple allow syntax lgc serve shorthand defined follows analogous notation used sums finally kind 1 whose sole element constructor add types unit void language type unit sole element type void contains values introduction forms elimination forms arrows sums products constructor level usual ones inductive kinds introduced fold construct eliminated primitive recursion constructors form prj k j k c wellformed constructor function kind jk k jkj c body function may appear parameter name function used recursive calls example define kind senting natural numbers define function iter follows constructor iter function taking function types types type natural number returning result iterating function given type specified number times clearly pr notation somewhat unwieldy read write use mllike notation working lx constructor language many purposes combine notions inductive sum kind define datakinds akin mls datatypes example could write definition n follows datakind function iter would readably expressed ml curried function notatin way iter succ iter often write functions style careful write functions expressed primitive recursion notation lx simplify presenta tion also use familiar ml constructors list option stand analogous datakinds 24 approaching garbage collection language lx originally designed intensional type analysis basic methodology define datakind analyzable constructors call tr type representation function interp tr turn constructor representation suitable analysis actual type suitable adorning variable binding turn constructor type value represented run time addition explaining somewhat mysterious operation runtime type analysis primitive terms eect isolating particular subset types analysis types appeared image interp mapping could passed analyzed run time garbage collection want something similar want isolate set stack types structured collector parse stack using algorithm outlined section 11 add appropriate stack structure condition allocation rule asserting current stack type lies set remainder paper define following lx objects 1 datakind sd stack descriptor whose elements passed around programs place stack types 2 datakind dd data descriptor whose elements static representations gc tables every program language designate one particular constructor static gc table sgct constructor sgct kind dd 3 constructor interps dd sd st turn stack descriptor stack type provided uses stack frames whose shapes determined particular static gc table careful write interps constructors sd stacks type interps sgct always parsable definitions ensuring stack parsable garbage collection simple current stack type need require exist constructor sd course want typechecker guess appropriate change syntax slightly make programmers responsibility next version allocation rule modulo definitions new lx ex pressions one development rule section 31 order expression interface garbage collector terms sgct guarantee correct programs must sure actual data structure used gc table agrees static representation lx capable expressing type gc table guarantees chosen simpler approach rather forcing program provide gc table static constructor form dynamic value form assume typechecker certified code system transforms static gc table real gc table provides latter runtime system program starts thus consider generation gc table static representation part trusted computing base remaining sections paper present definitions kinds sd dd describe behavior interps auxiliary functions needed define definition interps nontrivial involves unusual amount programming type constructor level language complete code special kinds constructors used gc interface found appendix b 3 describing stack since collector requires stack structured sequence frames lx representation stack type essentially list frame descriptors represent constructors another datakind called fd frame descriptor must allow two major operations 1 since lists descriptors passed around program instead stack types must possible interpret descriptor get partial stack type represents 2 since structuring stack way ensure agreement gc table must possible check descriptor entry table individual entries static representation gc table constructors kind called ft frame template also define shortly 31 labels singletons mentioned key property stack layout required garbage collector return address one frame determines via gc table expected shape next older frame result order constraint stacks type collection guarantee proper functioning collector must ensure value stored return address position frame corresponds via static gc table type next frame make happen must able reason labelsie pointers codeat constructor level language therefore lift label literals value level language constructor level add new primitive kind l classify addition add construct forming singleton types labels using construct able force return address stored stack frame precisely value must order correctly predict shape next frame stack syntax typing rules labels singletons shown figure 4 c label code block type type contains instances c order make use values singleton type introduce kinds k l constructors c figure 4 syntax typing labels coercion blur forgets identity singleton value yielding value appropriate operand jump instruction since values singleton type code labels usually polymorphic found necessary add way apply label constructor argument maintaining singleton type accomplished writing vc sensitivity garbage collector labels found stack raises another issue must addressed typing rule allocation order collector begin process scanning stack must able find gc table entry callers frame ie newest program frame therefore necessary associate label allocation site require first frame descriptor stack descriptor correspond label since label intended denote return address call garbage collector must assume labels program distinct also define function retlab kind dd sd l extracts label newest frame given stack descriptor making one final change syntax allocation include label final typing rule follows 32 stack descriptors general structure kind sd given figure 5 along illustration interpretation constructor kind stack type interps validity checking performed interps discussed next section kind definitions show stack descriptor either emptyin case carries label identifying return address top frameor consists frame descriptor descriptor rest stack frame descriptor consists label identifies point program owns frame 1 return address currently pending function call executed function instance created frame kind kind list slot list datakind base l cons fd sd figure 5 structure interpretation stack descriptors turn type function whose frame two lists slots kind slot slots defined address definition next section slot describes single location stack constructor kind slot must support 1 interpretation type fashion indicated arrows illustration 2 examination determine specification slot gc table ought first list slots frame descriptor corresponds slots come return address second list describes slots return address shown diagram interps builds frame stack type interpreting slots types constructs return address using functions return type specified frame descriptor forming singleton label associated next frame code interps appendix b keeping usual lx methodology intention lgc programs pass constructors kind sd programs gcignorant language would pass stack types example code function takes two integers returns boolean comparison func might type unfortunately type quite capture relationship return address type code callers frame hidden inside code block type unable perform allocation return address singleton type order give return address singleton type must extract label calling frame using function retlab mentioned section 31 use following accurate type place detailed example use stack descriptors allocation shown figure 6 interesting part function shown figure recursive call let return address recursive call factcode factreturn type specifies slot type int define codeint interps sgct 0 b return address stack pop 2 clear away frame call blurra return else push x push argument push factreturn push return address call int interps sgct consfactframe pop 3 clear away frame push result call blurra return figure using stack frame descriptors observe retlab sgct consfactframe factreturn type address call instruction see stack type code type matches current stack call site observe first value stack return address whose type already seen equal one required call second value stack argument recursive call type int finally 1 describes functions frame preexisting stack particular r int0 r stands type original return address unknown base portion stack checking frame validity addition enforcing property stack sequence frames condition must also guarantee frames correctly described gc table accomplish ensure equality hold frame descriptors consistent information contained sgct gc tables constructorlevel representation since actual gc table mapping return addresses frame layout information makes sense structure sgct mapping labels frame layouts well basic structure dd kind sgct given figure 7 static gc table structured list pairs consisting label constructor kind ft stands frame template frame template essentially lx constructor representation information real gc table entry consists two lists table kind kind list tslot list datakind consdd l ft dd figure 7 structure static gc table slots constructors kind tslot correspond two lists slots frame descriptor checking frame descriptor validity therefore consists looking label frame descriptor sgct checking slots fd table slots ft give definitions slot tslot discuss consistency checking shortly first however must make one final addition lgc order able write allimportant lookupdd function finds frame template given label constructor language must able compare labels equality syntax semantics label equality constructor level given figure 8 constructor definitionally equal c3 labels c1 c2 c4 note reduction rules ifeq apply c1 c2 label literals equational theory remains wellbehaved constructs place lookupdd easy write using primitive recursion 41 monomorphic programs section give definitions slot tslot allow monomorphic programs written lgc constructors figure 8 label equality datakind knownslot tr datakind trace 1 notrace 1 true 1 false 1 figure 9 monomorphic slots table slots monomorphic mean programs values function places stack frame types known compile time 2 type every value functions stack frame nonvariable type determined statically whether slot frame contains pointer must traced importantly traceability slot every instance function consequently gc table needs one bit slot needs checked allocation site whether types slots traceabilities specified table definitions slot tslot given figure 9 along kinds two constructor functions use check frames case monomorphic code slot simply type representation usual style lx table slot simply flag indicating whether location traceable discuss definition tr representation types coded lx purposes paper ever assume existence usual interpretation representation functions usual lx interp turns type representation type represents r turns type representation type value representing type stack interpretation function interps must make use interp translate slot really type representation type use r next section cover polymorphic programs function checkfd checks frame descriptor valid respect static gc table first must look frame descriptors label get corresponding frame template one frame template label descriptor rejected invalid 2 note nontrivial program stackbased language really totally monomorphic since every function must parametric stack type called time con con figure 10 static gc table factorial example function slot2tslot simply decides whether given type representation traceable given frame template checkfd applies slot2tslot slots frame descriptor uses eqtslot determine whether resulting tslot matches corresponding one frame template ensure stack parsed garbage collector interpretation function interps calls checkfd frame descriptors sees portion code interps essentially following cons fd case checkfd sgct fd true false void null case frame descriptor valid respect sgct body interps reduces void null unsatisfiable stack type since type void uninhabited stack type interps sgct reachable program point obviously interps sgct must inhabited therefore reduction definition must taken false branch follows frame descriptors must valid sense checkfd static gc table factorial example figure 6 shown figure 10 course bit unrealistic since shown program one function call site result one entry gc table add anything factorial program main program body calls function factcode gc table static representation would augmented descriptions new call sites introduced 42 polymorphic programs little dicult adapt lgc certifying polymorphic programs programs function may arguments local variables whose types dierent time function called tilt garbage collector handles stack locations requiring instance polymorphic frame value representing type slots available slot gc table corresponding location whose type statically un known rather directly giving traceability information tells collector representation found tilt allows flexibility representations stored stack heapallocated record pointer record stack global storage purposes assume simple flat ar rangment type representations frame stored frame new definitions slot tslot account polymorphism shown figure 11 also slightly modify definition fd kind frame descriptors frame polymorphic program general parametric number unknown types since frame descriptors must interpretable give type stack datakind datakind knownslot tr varslot n repslot n kind list slot list tr list datakind trace 1 notrace 1 var n rep n list n tr figure 11 frames tables polymorphic programs frame descriptor represents single instance polymorphic frame therefore version fd polymorphic programs includes list type representations instan tiate frame descriptor providing representations unknown types values frame individual slot frame descriptor may take one three forms may slot whose type known compile time may slot whose type one unknown types associated frame may slot holds representation one types three possibilities reflected new definition slot case unknowntype representation slots frame descriptor carry natural number indicating type parameters gives type represented slot similarly four choices slot static gc table slot may known traceable may known un traceable may contain value variable type may contain representation four possibilites correspond arms new tslot datakind interpretation slots types bit complicated well slots known type operation unchanged variable representation slots interps must look appropriate type representation list given frame descriptor representation obtained variable slots turned types using interp representation slots turned types using r function described therefore write function interpsl interprets single slot given list type representations frame descriptor fun interpsl trs knownslot interpsl trs varslot case nth trs n tr interp tr none void interpsl trs repslot case nth trs n tr r tr none void notice slots specifying invalid indices list representations given type void ensure frame described invalid descriptor cannot occur run time addition possibility bad indices variable representation slots another new way frame descriptor may invalid definition fd allows frame contain varslot contain corresponding repslot fortunately property set indices given varslot contained set indices given repslot easy check primitive recur sively responsibility falls polymorphic version function checkfd example simple polymorphic function lgc shown figure 12 code figure defines function type representation takes value type interp boxes itthat allocates returns onefield tuple type interp containing value stack descriptor provided allocation site adds descriptor current frame preexisting stack descriptor new frame descriptor contains two slots corresponding two values return address make functions stack frame first repslot zero describes runtime representation type r second varslot zero describes argument function type 5 expressiveness order experiment expressive power lgc implemented typechecker language including prelude constructor kind definitions giving meanings tr sd dd interps also implemented translation gcignorant source language lgc demonstrating lgc expressive enough form basis target generalpurpose compiler syntax source language shown figure 13 design driven solely goal removing explicit gcrelated constructs enabling straightforward translation lgc briefly mention issues shaped design source language since highlight unusual properties language designed garbage collection interface mind implicit stack operations since garbage collector requires stack certain structure would inconvenient allow source program unrestricted use stack manipulation operations therefore chose remove stack almost completely syntax source language sourcelevel functions accept arguments return results usual manner translation lgc takes care turning parameterpassing stack nipulation addition since return addresses play critical role scanning stack cannot allow source programs manipulate either result source language abandons continuationpassing style familiar return instruction merge halt instruction since semantics similar locals since source program cannot manipulate stack support storing intermediate results must built language somewhat unfortunate consequence decisions stored stack must made translation lgc design lgc applied compiler targeting typed assembly language would correspond fact register allocation must completed generation gc tables begin order use stack space local variables temporary storage code block source program begins lalloc indicates block wishes allocate mutable local variables stack special forms declarations expression level provide access locals pop 3 push cell call blurra figure 12 polymorphic allocation example types int bool ns codee 1 n 1 n 1 n expressions e return v v e1 else e2 let e declarations blocks b xe e 1 n lallocie programs p letcode type contexts contexts x memory types figure 13 syntax source language closures since lgc requires code blocks closed hoisted top level translation higherlevel language functions may nested must perform closure conversion part translation lgc since interface garbage collector seems little impact closure conversion transformation chose keep sourcetolgc translation simple assuming closure conversion already performed therefore source language also requires code blocks top level however include existential types source language providing representations types hidden existentials would add bloat associated translation since many representations turn unnecessary find economical introduce existential types closures time translation lgc include source language special types closures 1 n operations creating every code block expects special argument environment closure code pointers made functions using closure operation packs code value together environment 6 conclusion presented language whose type system interface modern highperformance garbage collector expressed demonstrated code certification indeed compatible use sophisti cated accurate garbage collection technology described interface one collector language implemented prototype typepreserving translation gcignorant source language target language alert reader noticed absence operational semantics safety proof paper operational semantics completely straightforward except two rules perform heap allocation must additional side condition requiring stack parsable type safety proof boilerplate based proof lx crary weirich 3 except cases injection allocation must shown typing conditions stack imply parsable however clear give formal definition parsability simpler specification appendix b proof would unenlightening interface garbage collector subtle expressing interface type system requires fair amount programming level type constructors typechecking programs language turn involves deciding equivalences lot large constructors many reduction steps away normal form prototype typechecker lgc decides equivalence using straightforward recursive weakheadnormalize compare algorithm implementation yet serious enough reach conclusions eciency preliminary results indicate amount work involved unreasonably large paper examined garbage collector interface based one used tiltml compiler considerably simpler however believe described sucient handle issues arise real collector instance appear di cult account registers tilt treats essentially stack slots global variables whose types fixed proofofconcept implementation address possibility translating higherorder polymorphism lgc higherorder polymorphism arises setting compiling full ml language abstract parameterized types occur tilt able use similar gc table format one described even higherorder polymorphic programs performs program transformation called reification introduce variable bindings types registers stack locations unknown compile time believe performing something similar reification translate programs higherorder polymorphism lgc remains topic future work r scalable realtime parallel garbage collection symmetric multiprocessors parallel flexible type anal ysis principled scavenging system f typed assembly language safe untrusted agents using proofcarrying code managing memory types tr proofcarrying code flexible type analysis system f typed assembly language typepreserving garbage collectors principled scavenging parallel realtime garbage collector managing memory types ctr feng zhong shao alexander vaynberg sen xiang zhaozhong ni modular verification assembly code stackbased control abstractions acm sigplan notices v41 n6 june 2006 andrew mccreight zhong shao chunxiao lin long li general framework certifying garbage collectors mutators acm sigplan notices v42 n6 june 2007
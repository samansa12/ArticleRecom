hard equality constrained integer knapsacks consider following integer feasibility problem given positive integer numbersa0a1 n gcd a1 n exist vectorxz n 0satisfyinga x a0 prove coefficientsa1 nhave certain decomposable structure frobenius number associated witha1 n ie largest value ofa0 whicha x a0 nonnegative integer solution close known upper bound instances consider takea0 frobenius number furthermore show decomposable structure ofa1 nmakes solution lattice reformulation problem almost trivial since number lattice hyperplanes intersect polytope resulting reformulation direction last coordinate going small branchandbound instances difficult solve since infeasible large values ofa0 1 n illustrate results computational examples b introduction 11 problem statement summary results past decade substantial progress computational integer programming many large complex instances solved however still many small instances seem extremely hard tackle standard methods branchandbound branchand cut still quite unclear makes instances hard examples socalled market share problems cornuejols dawande 1999 aardal et al 2000a feasibility problems reported aardal et al 2000b certain portfolio planning problems louveaux wolsey 2000 related following simple problem let 0 n positive integer numbers problem p contain integer vector 2 components x may take integer value problem easy exists vector x 2 z n satisfying 0 integer multiple gcda nonnegativity requirement x makes problem npcomplete study focus infeasible instances rule search algorithm terminates fast found feasible solution luck largest value 0 instance 2 given input infeasible called frobenius number denoted f infeasible instances large ratios 0 hard branchandbound context address two topics first one provide sufficient explanation certain coefficients yield large frobenius numbers others comparable sizes theorem 1 demonstrate frobenius number relatively large possible decompose acoefficients large compared p jr j leads second topic give sufficient condition lattice reformulation using projection suggested aardal hurkens lenstra 2000b work significantly better branchandbound instances type 2 show 0 reformulation aardal hurkens lenstra computationally easy solve way similar lenstras algorithm hw lenstra jr 1983 since projected polytope thin direction last coor dinate demonstrated section 32 instances difficult branchandbound easy first reformulated according aardal hurkens lenstra reformulation based lattice basis reduction briefly described section 2 also see instances acoefficients decompose general way n large compared p jr j easy solve applying reformulation decompo sition however yet able prove leads large frobenius numbers illustrate observations report modest computational study infeasible instances literature infeasible instances generated half instances acoefficients decompose discussed section 3 others random coefficients comparable sizes instances 5 n 10 computational results presented section 4 clearly confirm theoretical observations presenting results following subsection give short description known results integer programming 12 integer programming branching hyperplanes polytope p r n defined 1 dimension fulldimensional fulldimensional case following known let fulldimensional polytope r n given integer input width along nonzero vector defined w sg notice different definition geometric width polytope consider problem polytope contain vector x integer lattice z n khinchine 1948 proved contain lattice point exists nonzero integer vector w bounded constant depending dimension h w lenstra jr 1983 developed algorithm exploiting fact determining whether given polytope contains integer vector algorithm either finds integer vector lattice hyperplane h cn lattice hyperplanes parallel h intersect cn constant depending dimension n intersection lattice hyperplane gives rise problem dimension n gamma 1 lowerdimensional problems solved recursively determine whether contains integer vector one illustrate algorithm search tree n levels number nodes created level bounded constant depending dimension level hence algorithm polynomial fixed dimension search node pruned given direction lattice hyperplane intersecting polytope defined search node aware implementation lenstras algorithm cook et al 1993 implemented integer programming algorithm lovasz scarf 1992 similar structure lenstras algorithm observed instances number search nodes created lovaszscarf algorithm much less number nodes branchandbound tree compute good search direction node however time consuming computing lprelaxation raises question understanding situations good search directions determined fast related one results presented paper demonstrate class difficult infeasible instances ie instances decomposable acoefficients outlined projection proposed aardal hurkens lenstra yields integer direction projected polytope provably thin case direction last coordinate direction apply tree search algorithm lenstras projected polytope branch coordinate directions order decreasing variable indices instances become easy 13 notation conclude section introducing definitions notation euclidean length vector x 2 r n denoted jxj n theta n identity matrix n zero p theta q matrix 0 pthetaq dimensions omitted clear context theta n matrix said hermite normal form form c mthetam 0 mthetangammam c lower triangular nonnegative matrix diagonal element unique maximum row entry hermite normal form matrix denoted hnf unique full row rank set form linear independent vectors r n l n called lattice set vectors fb l g called lattice basis lattice two different bases l 1 infinitely many l 1 determinant dl lattice l defined det b b b basis l b denotes transpose matrix b lattice l fulldimensional bj rank rk l lattice l dimension euclidean vector space spanned l rk dl defined equal one integer width polytope ae r n nonzero integer direction defined number lattice hyperplanes direction intersect equal w contain integer vector 2 reformulation search algorithm starting point reformulation 2 suggested aardal hurkens lenstra 2000b sign relaxation g relaxation x rewritten x integer vector satisfying basis lattice l 0g integer vector x f vector x 2 x written sum x f vector x 0 integer know vector x f exists paper aardal et al shown x f b 0 conveniently determined polynomial time using lattice basis reduction let fy problem 2 restated q contain integer vector polytope q fulldimensional formulation ie dimension mentioned previous section apply lenstras lenstra 1983 algorithm integer programming algorithm q consider tree search algorithm inspired lenstras algorithm using unit directions search ith unit vector let assume recursively define feasibility search process searchs set j follows empty output point fk j g j2j print feasible quit otherwise pick 2 compute l compute integers k interval l searchs n fig print infeasible quit feasibility search defined searchj example search tree see figure 1 notice search tree created way similar search tree lenstras algorithm number levels tree number variables problem instance number nodes created certain level corresponds integer width polytope chosen search direction l u l l u figure 1 search tree instance prob2 cf section investigate class instances exceptionally hard solve branchandbound using original formulation x variables become easy solve applying branching scheme described reformulated problem yvariables 3 implementation algorithm searchs always choose index highest index set step pick index 2 ie branch order 1 done width unit direction e ngamma1 small class instances demonstrated following section give example instance example 1 let vector x f basis b 0 instance gamma3 gamma1222 polytope q fy moreover w q e 1 consider search direction e 2 first immediately conclude solve formulation xvariables branchandbound objective function 0 using default settings cplex 65 takes 1262532 search nodes verify infeasibility 2 instance one given example 1 may seem quite artificial however instances reported cornuejols dawande 1999 aardal et al 2000ab louveaux wolsey 2000 stem applications show similar behavior practical point view therefore relevant try explain behavior 3 class instances 31 coefficient 0 polytope p given 1 nsimplex instance problem 2 particularly hard solve branchandbound infeasible intersection points nsimplex coordinate axes large values branchandbound forced enumerate many possible combinations x since instance infeasible cannot get lucky search may happen instance feasible chance chosen objective function takes us feasible solution quickly example 1 previous section illustrates hard infeasible instance similar larger instances virtually impossible solve using stateoftheart branchandbound algorithm implemented cplex create infeasible instances maximum values 0 choose 0 frobenius number f computing frobenius number given natural numbers appendix 1 discuss algorithm used computational study known f 1 2 matics educational times additional papers solutions sylvester published problem proving 1 2 relatively prime integers exactly 12a nonnegative integers ff less 1 nonnegative integer solution solution problem provided curran sharp volume 41 1884 journal precise reference sylvester 1884 see also schrijver 1986 p 376 frobenius number computed polynomial time see selmer beyer 1978 rodseth 1978 greenberg 1988 kannan 1992 developed polynomial time algorithm computing frobenius number every fixed n algorithm based relation frobenius number covering radius certain polytope upper bounds frobenius number also known 1 showed f upper bounds provided erdos graham 1972 selmer 1977 determine lower bound f express lower bound function p r highest order term quadratic large values relatively small values p jr j term dominant theorem 1 let let r k p k g assume 1 1 2 3 5 obtain fp proof upper bound gp r derived result brauer 1942 f proof lower bound introduce following notation lattice l 0 defined b z n section 2 lattice l 0 contained parallel hyperplanes generated c figure 2 b c l 0 idea behind proof follows define homomorphism delta rzsuch x 2 z maps 0 vector x exists integer number 0 contained image delta map provides lower bound frobenius number define homomorphism first defining projection z along vector z z plane delta 1 consider rz show kernel f l 0 c due first isomorphism theorem see eg hungerford 1996 p 44 know b divided ker f ie bl 0 c isomorphic rz image z isomorphism bl rzturns interval l u rz finally determine integer number tl tu contain integer point integer yields lower bound frobenius number conditions given theorem first define linear mapping z satisfies z notice gammaz 62 c next define homomorphism rzgiven x 7 px mod 1 claim kernel f first show l 0 implies px 2 z hence px mod next show ker f l 0 c notice element b written c absolute value element 2 interval gamma12 12 since fcy 1 2 0 since contradicts 2 62 c ay ry 2 since py 2 integral ry 2 integer multiple observe since absolute value element 2 less 12 due assumption 3 theorem ry therefore possible solution concludes proof claim due first isomorphism theorem homomorphism f induces rz determine image delta 1 composition mappings rz composition mappings homomorphism use v denote vertex delta 1 vertex v vector ith component v applying linear mapping v yields z v next isomorphism r k p k g since delta 1 convex hull vertices homomorphism image z interval j k length demonstrate exists integer b 1gamma2d j l c interval td contain integer point implies l c lower bound frobenius number notice due assumption 4 c interval length less equal 1 gamma 2d j let number k 0 k yields interval 0 0is integral interval 0 contain integer since length 0 2 less equal length interval since 0 1 integral define k claim interval contain integer point prove claim first assume k 0 integer k due assumption 5 implies k 2d j next assume k 0 fractional case obtain 0 due reasoning finishes proof claim finally notice k b 1gamma2d j conclude b 1gamma2d j lower bound frobenius number obtain acoefficients example 1 decompose follows let 12223 theorem 1 yields lower bound frobenius number equal 149 381 362 upper bound equal 448192961 frobenius number instance 149 389 505 close lower bound 2 instances decompose vectors p r short compared frobenius number large see computational study section 4 computed lower bound frobenius number instances cases close actual value would interesting investigate whether possible use similar techniques tighten upper bound frobenius number instances sort following subsection demonstrate instances acoeffi cients decompose large relatively short p r trivial solve using reformulation outlined section 2 instances extremely hard solve branchandbound due large frobenius numbers 32 coefficients analysis class instances wish express determinant lattices l 0 sublattice l 0 terms input presenting results introduce notation two definitions present known results details see instance cassels 1997 lattice euclidean vector space e let k subgroup l exists subspace e k called pure sublattice lattice r n dual lattice l defined follows suppose k pure sublattice lattice l following holds lattice l dual l let l lattice dual l let k pure sublattice l write theorem proof take l lattice z n k lattice l 0 equation 4 equivalently equation 5 6 obtain z n l 0 since dual lattice z n z n l g since exactly lattice la basis obtained result also mentioned section 32 survey nguyen stern 2000 remark 1 notice dl 0 also computed basis l 0 write denote orthogonal complement hyperplane spanned p r proof theorem 1 denote lattice c z n lc proposition 3 lattice l 0 contains lattice lc rank lattice lc equal n gamma 2 proof assume x 2 z n satisfies shows l 0 lc prove rk create contradiction p r linearly dependent write write integer multiple g ie z express gmg f integer contradicts gcda hence r linearly independent implies rank lc equal 2 2 let theorem 4 proof proof follows lines proof theorem 2 choose lattice l definitions 1 2 lattice z n sublattice k lattice lc since z n g basis l c vectors p r linearly independent see proof proposition belong lattice l c generated b c implies dlp summarize determinant lattice lp equal 0 basis l 0 assume without loss generality basis vectors ordered b 1 0 form basis lattice lc hence b 0 belong lc let h distance b 0 h notice h jb j corollary 5 proof following holds suppose p r short relative lovasz basis reduction algorithm lenstra et al 1982 yields basis basis vectors ordered according increasing length certain factor basis b 0 l 0 generate first vectors form basis lattice lc vectors short since basis reduced since determinant lattice lc bounded length last vector b 0 bounded according corollary 5 example 3 recall decomposition acoefficients examples 1 2 let first column b 0 0 gamma3 1 short vector orthogonal p r second last column b 0 12224 gamma1222 gamma3667 long 2 summarize determinant lattice l 0 large due large value large value basically contributed last vector b long vector b 0 implies small value integral width q unit direction e ngamma1 fact often zero one lattice hyperplanes intersect q direction instances consider example 1 observed w q e 2 immediately gave us certificate infeasibility argument regarding length columns b 0 presented also holds general case acoefficients decompose follows n assumed large compared p jr j computational results illustrate results solved various instances type 2 instances given table 1 first column instance name given instances instance frobenius number cuww1122246111989643481 cuww2366794890873365cuww3242693640760683cuww4132125284479268104723595 table 2 value instances cuww15 yielding short p r cuww1 cuww2 cuww3 cuww4 cuww5 next column coefficients given last column frobenius number found instances computed frobenius number using algorithm described appendix 1 instances divided two groups first group contains instances cuww1cuww5 prob1prob10 second group consists instances prob11prob20 instances cuww1cuww5 generated cornuejols ur baniak weismantel wolsey 1997 remaining instances generated study instances cuww1cuww5 decomposition vectors p r table 2 give values yield short vectors p r instances instances generated acoefficients decomposition r randomly generate uniform distribution u10000 20000 n u1000 2000 p u1 10 r u gamma10 10 contrast second group instances prob11prob20 randomly generated acoefficients size prob1prob10 necessarily decompose short vectors p r chose size acoefficients since yields values dl 0 approximately size instances prob1prob10 instances prob11prob20 coefficient randomly generated computational results verifying infeasibility instances reported table 3 instance used frobenius number righthand side coefficient 0 instances computed dl 0 length basis vectors basis number lattice hyperplanes intersecting q coordinate directions e 1 e ngamma1 applied integer branching algorithm described section 2 q number nodes generated computing time seconds given columns search tree nodes time finally attempted solve instances using original formulation p standard linear programming based branchandbound using cplex version 653 number nodes needed branchand bound computing time seconds reported columns bb nodes bb time branchandbound algorithm set node limit 50 million nodes instance solved within node limit indicated 50 theta 10 6 column bb nodes time needed evaluate 50 million nodes indicated column bb time computations carried sun ultra 60 model 2360 workstation two ultrasparcii 359 mhz processors implementation sequential 512 mb memory make following observations first frobenius number instances cuww1cuww5 prob1prob10 two orders magnitude larger frobenius number instances prob11prob20 see table 1 infeasible instances typically harder solve feasible ones larger intersection points 0 nsimplex p coordinate axes harder instance becomes branchandbound class first group instances harder branchandbound table 3 see instances cuww1cuww5 prob1prob10 considerably harder solve branchandbound instances prob11prob20 presolver cplex able verify infeasibility instances cuww2 prob10 none instances first group solved within node limit 50 million nodes instances prob11prob20 solved branchandbound within half million search nodes one minute computing time also observe shape polytope q much influenced decomposition acoefficients coefficients decompose short vectors p r relative width corresponding polytope q unit direction e ngamma1 small made instances trivial tree search algorithm applied q instances solved using less twenty search nodes fraction second computing time instances prob11prob20 acoefficients generated randomly certain interval observe width q size unit directions general greater two tree search algorithm applied q therefore needed nodes longer computing times first group instances still none instances needed 126 nodes tenth second computing time table 3 verification infeasibility instance wi wi search time tree nodes nodes time 81393 77975 79126 54115 prob1020222224116522002prob113645464761500593 prob1444404751567012434 prob1536413948603080494 prob1640374246972080614 prob1746424640574150241 presolve determines problem unbounded acknowledgments want thank hendrik lenstra valuable suggestions particular outline proof theorem 1 also wish thank bram verweij providing framework code based general enumeration library integer branching algorithm research first author partially financed project tmrdonet nr erb fmrxct980202 european community r towards solution cornuejols dawande instances solving system diophantine equations lower upper bounds variables problem partitions problem frobenius introduction geometry numbers implementation generalized orsa journal computing 5 class hard small 01 programs decomposition integer programs generating sets solution linear diophantine equation nonnegative integers lattice translates polytope frobenius problem quantitative formulation kroneckers theory approximation russian generalized mathematics operations research 17 combining problem structure lattice reduction cryptology theory linear integer programming linear diophantine problem frobenius tr ctr k fukuda n jensen n lauritzen r thomas generic grbner walk journal symbolic computation v42 n3 p298312 march 2007
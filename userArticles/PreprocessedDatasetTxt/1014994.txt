test sequence generation model checking using dynamic transition relations task finding set test sequences provides good coverage industrial circuits infeasible size circuits small critical subcircuits design however designers create set test sequences achieve good coverage sequences cannot used full design inputs subcircuit may accessible work present efficient test generation algorithm receives test sequence created subcircuit finds test sequence full design reproduces given sequence subcircuit algorithm uses new technique called dynamic transition relations increase efficiency common expensive step algorithm computation set predecessors set states make computation efficient exploit partitioning transition relation set simpler relations every step use necessary resulting smaller relation original one different relation used step hence name dynamic transition relations idea used improve symbolic model checking temporal logic ctlwe implemented new method smv run several large circuits experiments indicate new method provide gains two orders magnitude time space verification results show dynamic transition relations make possible verify circuits previously unmanageable due size complexity b introduction recent years seen rapid growth complexity size industrial de signs verification task systems become extremely complex requiring new techniques handle large scale designs formal methods example new technology gained popularity recently context one method symbolic model checking successful hardware verification model checkers able find several previously unknown errors industrial circuits many companies starting use symbolic model checking design cycles complement dynamic validation propose new technique based symbolic model checking called dynamic transition relations enhances formal verification dynamic validation dynamic validation simulation checks given run system correct inputing sequence signals test sequence design observing resulting outputs since number runs infinite method cannot exhaustive ie cannot check possible runs thus important obtain set test sequences provides good coverage design however task might feasible design large creating set test sequences covering behaviors circuit extremely difficult due large number behaviors exhibit situations however set test sequences assumed exist ffl important test small critical subcircuits extensively small circuits easier generate efficient test sequences critical circuits worth extra effort identify test sequences provide good coverage ffl subcircuits frequently reused new designs cases test sequences often developed ffl subcircuits also verified separately using simulation formal methods example error found subcircuit designer must check real error may exist full design sequence inputs lead error never occur complete circuit ffl important conditions full design often stated test sequences example violation mutual exclusion stated condition internal signals eg granted 0 granted 1 seen test sequence length one however test sequences subcircuits cannot used directly full system inputs subcircuit internal signals full circuit may accessible exterior design address problem creating test sequence full design reproduce test sequence small subcircuit thus achieve good coverage subcircuit running tests full design problem defined follows see figure 1 let large design set inputs let sub relatively small critical subcircuit set inputs sub single clock synchronous circuit equivalently transformed one assume designer produces set test sequences guarantees good coverage interior parts design sub design figure 1 schematic view test generation problem sub general inputs sub accessible exterior thus need provide test generation algorithm given test sequence pi sub either produces test sequence pi induces pi sub reports sequence exists latter case means pi sub never occur sub run within test generation algorithm performs task two phases first backwards search creates sequence sets states reverse order last first computation path goes sets induces required pi sub second phase traverses sets first last determining one path choosing appropriate state set states sequence inputs pi corresponds chosen path projected path resulting pi correct input simulation tool reproduce pi sub path algorithm returns false dynamic transition relations main operator backwards search algorithm p reda computes set predecessors states state defined assignment values valuation variables model variable output latch state holding signal circuit addition inputs p reda uses model transition relation defining value system variables next state formula value system variables current state operation might costly transition relation large avoid problem exploit partition transition relation simpler relations relation defines value next state single system variable computing predecessors apply relations define next value variables depends thus transition relation used backwards search determined dynamically application p red according set applied new dynamic operator called p redd search proceeds number variables depends may grow larger smaller sizes dynamic transition relations vary accordingly search applied second phase uses step transition relation determined dynamically backwards search p redd particularly useful algorithm implemented symbolically using bdd 2 representation design bdds often provide concise representations ever size tend grow number variables depend next value variable typically depends small number variables dynamic transition relations involve fewer variables global transition relation result bdd representations often smaller computation p redd faster dynamic transition relations model checking introduction dynamic transition relations p redd operator motivated testgeneration algorithm depends however operation finding set predecessors set also core operation algorithms manipulate finitestate machines prominent example model checking finitestate machine models system checked given specification prove works correctly find counterexample show idea dynamic transition relations used order improve symbolic model checking 3 temporal logic ctl similarly test generation algorithm one common expensive steps symbolic model checking algorithms computation p red usually referred temporal operator ex replacing p red p redd reduces space time consumption allows verification larger systems partial transition relations computed dynamically application p redd note result computation exact ie obtain set states would used global transition relation changes affect intermediate results method proposed several advantages opposed several algorithms frequently used test sequence generation dynamic transition relations guarantee test sequences found exist also gains obtained using little model possible automatic need manually decide signals consider potentially never consider large parts circuit affect behavior subcircuit consideration applied much larger circuits methods moreover method changes p red function affecting behavior tool way consequence applied addition optimizations partitioned transition relations assumeguarantee others even better results experimental results implemented dynamic transition relations test sequence generation algorithm within symbolic model checking tool smv 13 obtained significant improvement time space variety examples pci local bus 4 distributed heterogeneous realtime system 5 model checking test sequence generation several intel circuits new algorithm ran average 20 times faster original static one maximum speedup 50 times using 16 memory moreover algorithm able determine test sequences show exist many cases static algorithm unable static algorithm cases used 800m memory could finish dynamic algorithm hand finished average 16 seconds using 51m memory results show dynamic transition relations provide significant gains test sequence generation symbolic model checking enable analysis larger systems previously possible cases able complete analysis 50 times faster savings 200 times memory fact changes p red function enables use minimal changes several verifiers related work test sequence generation precomputed tests studied context symbolic model checking 14 6 12 11 15 10 however techniques depend internal structure circuit tested eg cases rely regular bus structure design consequently general one presented context model checking problem addressed 9 work concerned mostly expressing test sequence complexity dealing large circuits fact 9 authors state used method small examples another work relating model checking test sequence generation 1 however work atpg algorithms automatic test pattern generation used perform model checking atpg algorithms guarantee eventually find test sequence even cases exist one important aspect work build model complete circuit beforehand may never actually construct model aspect relates techniques partitioned transition relations 7 differs however case partitions used every iteration may necessary examples techniques may consider parts circuit cone influence reduction 7 however techniques static sense determine parts circuit ignored method dynamically taking advantage parts circuit relevant iterations method produces better results since use less circuit iterations fact cone influence seen upper bound behavior algorithm paper organized follows section 2 first presents test generation algorithm using global transition relation shows convert test generation algorithm use dynamic transition relations explains algorithm implemented bdds next section 3 show dynamic transition relations used model checking section 4 present experimental results show usefulness ideas finally section 5 gives conclusions work future directions research test sequence generation model synchronous hardware designs finite state machines let sub set inputs subcircuit set circuit input variables let v set circuit variables inputs sub v assume circuit variables boolean use boolean formulas represent sets states transition relations state finite state machine representing circuit assignment values variables represents set states assignments satisfy f transition relation represented formula r assignment satisfies r represents edge v use letter set states transition relation formula represents finite state machine modeling circuit tuple ffl set states set valuations v ffl init set initial states ffl transition relation defined set functions n defining nextstate value global transition relation assume every n deterministic total function note inputs unrestricted trace sequence set variables partial assignment respect u assignment gives values variables u opposed state assignment gives values variables circuit partial assignment oe respect u represents set states agree oe u ie every v 2 u oev projection state u partial assignment u agrees projection pi u trace obtained taking projection state pi u expansion oe u 0 st u ae u 0 partial assignment oe 0 u 0 agrees oe u test sequence u series partial assignments u formally problem defined follows given set sub variables v inputs critical subcircuit sub test sequence pi sub must produce initial state init 2 test sequence pi every partial assignment let trace generated pi init require projection sub identical pi sub 1 notice transition relation r defines nextstate value variables v choosing nextstate value inputs deterministically define successor state therefore init pi together r uniquely determine pi 21 basic static algorithm section present algorithm uses global transition relation r determine test sequence circuit algorithm two stages first backwards search creates series sets states computation path goes sets starting initial state solution problem given pi construct series sets states reverse order ie start computing set n end every 1 every state 2 successor i1 see figure 2 using slight abuse notation view every test sequence set states set states assignments variables agree creating sets 0 make sure thus 0 represent set traces agree pi sub order make sure trace runs sets created starting initial state continue compute gamma2 arrive set initial state initial state found know trace pi point reproduces test sequence pi sub however arrive set conclude input sequence pi used initial state reproduce pi report second stage traverse sets n find one suitable trace test sequence pi generates trace created taking projections states along pi output algorithm initial state sequence inputs algorithm uses operator p red computes set predecessors set states according transition relation r defined p informally interpreted exists state assignment true state end transition r ri v assignment predecessors expressed terms v 13 also uses function choosea receives set produces single state assignment function succs returns set successors state according r stage 1 n n 2 3 j 4 endfor 5 7 j 8 10 endwhile stage ii 13 print sequence generation failed 14 else projection 17 n 19 j projection j 20 endfor sm init rn figure 2 data structure created test sequence generation algorithm 22 dynamic transition relations efficient algorithm algorithm presented previous section might practical large circuits circuits transition relation r big even represented bdd result set states operation p red becomes expensive possible however exploit partition transition relation functions n define next state variables v 0 recall state model gives values variables v say set states independent variable v every state state differs v also case exclude function n computation p reda say formula f independent variable v every two assignments oe oe 0 differ v oe notice formula f independent v set states represents independent v let f formula representing set states transition relation let support f set variables f depends define f depends vg sup 0 depends v 0 g therefore supf set currentstate variables f depends sup 0 f set nextstate variables f depends define dynamic version p red called p redd operator set predecessors states according partial transition relation transition relation includes n depends v operator p redd therefore defined p redd lemma 1 set p proof assume variable v appear support start definition p red v 0 depend v av 0 depend v 0 move 9v 0 quantifier get v 0 assume every n total function ie every v exists v 0 v 0 shows every variable v appear support drop term v 0 transition relation part p reda without changing result variables support get p redd 2 nextstate value variable depends variables often case circuits support sets compute remain small recall given state application r determines nextstate values variables v variables input variables chosen arbitrarily environment dynamic algorithm uses partial assignments oe instead full states partial transition relations r instead r output sequence generated algorithm series partial assignments perhaps variables give value variable v 2 means v influence parts circuit considered value chosen arbitrarily dynamic algorithm use following functions ffl choosea u accepts set states represented formula set variables u supa u returns partial assignment oe u satisfies view oe sets chosen oe subset notice given partial assignment resulting oe assignment u agrees notice also function choose used algorithm previous subsection call function receives partial assignment oe set variables u set variables u 0 u expands oe create partial assignment u 0 values variables u 0 n u chosen arbitrarily ffl projects u receives state set variables returns projection former later ie returns partial assignment u agrees receives partial transition relation r partial assignment oe partial transition relation form r set variables u result partial assignment oe 0 u every stage 1 n n 2 3 r j1 v 4 j 5 endfor 7 8 j 12 endwhile stage ii 14 15 print sequence generation failed else 23 j chooseoe 24 endfor 26 n chooseoe n 27 endif stage algorithm creates sets created previous algorithm uses p redd instead p red notice end stage every use expand lines 1822 apply lines 2125 stage ii forward search path done using partial assignments instead states full assignments every partial assignment oe represents set states differ variables support moving oe igamma1 oe lines 21 25 use partial transition relation r used create igamma1 see figure 2 applying r expand result support r i1 line 22 apply r i1 next iteration loop output algorithm initial state init inputs inputs calculated algorithm necessarily give values input variables giving inputs simulation need decide values input variables therefore expand every choosing arbitrary values extra input variables following theorems state correctness dynamic algorithm proofs omitted brevity found full paper theorem 21 assume test generation algorithm returns false computation produces theorem 22 assume test generation algorithm returns initial state init sequence inputs computation generated running simulation using init ngamma1 inputs 23 bdd implementation algorithm easily implemented using bdd representations components init n l model represented using bdds usual manner addition sets j computed algorithm represented bdds input algorithm sequence binary vectors straight forward translate vector bdd represents set needed algorithm bdd libraries include function compute sup sup 0 simply sets current next state variables appear bdd operations used algorithm standard bdd operations bdd implementation algorithm mostly benefit use partial transition relations size bdd representing set generally related size supa many cases n depend variables v thus taking fewer n result smaller support partial transition relation result bdds computed intermediate stages computation p red using partial transition relation depend less variables therefore often smaller 3 symbolic model checking 31 model checking using dynamic transition relations model checking problem finding set states finitestate machine given temporal formula true one efficient approaches solving problem symbolic algorithm uses bdds 2 representing transition relation representation often concise allowing verification large complex systems verification performed efficient search algorithm core algorithm temporal operator ex given model set states represented bdds determines set predecessors states ex operator part temporal logic ctl computation tree logic 8 frequently used model checkers formulas ctl express properties states system built atomic propositions boolean connectives temporal operators operator consists two parts path quantifier followed temporal modality path quantifiers indicate property true paths starting given state path given state e temporal modalities describe events ordered respect time along path specified path quantifier example means p holds next state f p means p holds future state g p means p holds states path common ctl operators ag p true state p globally true paths current state ie p invariant ef p true p holds sometime future path ie p reachable demonstrate symbolic model checking algorithm works showing algorithm ef p algorithm temporal operators similar nature object construct bdd represents set states satisfy ef p algorithm starts bdd states satisfy p step add set predecessors computed ex algorithm terminates states added expensive computation step algorithm application ex operator notice ex operator exactly p red operator defined previous section therefore replace computation ex operator p redd uses partial transition relation like compute partial transition relation dynamically according set ex applied assume n defined small number unprimed variables thus referring smallest number n resulting set states depend small number variable treatment also handles model checking fairctl logic ctl extended fairness constraints restrict set paths model required satisfy given formula 8 3 4 implementation experimental results implemented dynamic transition relations method smv 13 tested method models already verified smv pci local bus 4 addition applied method several large intel circuits table summarizes results obtained following examples ffl 1 simplified cache coherence protocol derived pci local bus ffl 2 model pci local bus discussed 4 ffl 3 10 circuits intel first two examples applied model checking ones computed test sequences examples one result run different parameters different length test sequences different width test vectors different inputs subcircuit times given seconds unless otherwise stated measures space given megabytes dyn columns relate dynamic transition relations algorithms st columns relate static algorithm using circuit vec column subcircuit input vector width seq column shows length test sequence subcircuit columns number variables used total number variables represent respectively maximum number variables support sets set states considered iteration total number variables circuit last column indicates algorithm determined test sequence successful sequence exist fail run 19 different tests eleven successful determining test se quences six reported test sequences subcircuits unreachable two model checking examples twelve examples finished executing dynamic static algorithms twelve obtained average speedup 20 times 2 memory usage 16 original gain times examples finished dynamic transition relations executed average seconds using 51m memory experiments killed process whenever used memory available 800m conclude examples obtained gain memory consumption greater 150 times 80051 another important result derived table average algorithm consider 25 variables circuit description expected new algorithms better suited large examples smallest ones first three gains impressive happens necessary reconstruct transition relation iteration small examples may take time space due intermediate computations simply creating transition relation complete circuit 2 numbers table rounded averages computed correct numbers time space vec seq variables sf dyn st dyn st used total 73 2301 25 595 8 5 figure 3 experimental results example number five however puzzling since gains clearly average medium large examples even saving significantly number variables 17 90 still need space even though less time complete test sequence generation indicates method efficient types circuits others future work includes characterization good circuits bad ones results show dynamic transition relations method provide significant gains verification time space cases two orders magnitude expected work way kinds circuits experiments seem indicate works extremely well several types circuits used industry today conclusions presented two major results paper first efficient testgeneration algorithm enables designers translate test sequences created small subcircuits test sequences full design algorithm guarantees test sequence found exists second introduction dynamic transition relations enhance operation finding set predecessors operation source stateexplosion testgeneration algorithm symbolic model checking algorithms improvement efficiency prove useful implemented new method smv run several large circuits experiments indicate new method provide gains time space verification two orders magnitude results show dynamic transition relations make possible verify circuits previously unmanageable due size complexity work extended several ways one inefficiency method recreates transition relation iteration however may cases transition relation already constructed optimization consists implementing algorithm reuses previously used transition relations another extension apply idea dynamic transition relations operators besides p red symbolic model checking p red operator called ex dual operator ax given set operator ax computes set states successors easy show idea applied operator another direction plan pursue deal asynchronous model com putation model verified system either asynchronous hardware design distributed program represented set processes step one processes chosen executed transition relation model disjunction relations rather conjunction synchronous case plan adjust testgeneration algorithm dynamic version p red computational model forward search algorithm also defined using dynamic transition relations determine transition relations use according support set operating time however choose n according current state support next state support unfortunately case may take account states necessarily reachable transition n may conflict another transition n j therefore exist global model however variable v support set states consideration v j dynamic transition relations algorithm would allow transition n taken identifying unreachable states reachable however model checking set reachable states used simplify model verification eg traverse reachable states case upper approximation introduce errors speed verification r model checking based sequential atpg symbolic model checking 10 20 states beyond verifying performance pci local bus using symbolic techniques selective quantitative analysis interval model checking verifying different facets system model checking automatic verification finitestate concurrent systems using temporal logic specifications test generation intelligent networks using model check ing testability strategy silicon computers architectural level test generator hierarchical design environ ment architectural level test generator hierarchical design environment based nonlinear equation solving symbolic model checking approach state explosion problem hierarchical testing using precomputed tests modules multiple path sensitization hierarchical circuit testing tr
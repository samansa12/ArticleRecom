fundamentals scheduling performance video tape libraries robotic tape libraries popular applications high storage requirements video servers study throughput tape library system design new scheduling algorithm socalled relief compare olderstraightforward ones like fcfs maximum queue length mql unfair one bypass roughly equivalent shortest job first proposed algorithm incorporates aging mechanism order attain fairness prove certain assumptions minimizes average startup latency extensive simulation experiments show relief outperforms competitors fair unfair alike 203 improvement throughput rejection ratio b introduction even though secondary storage devices based magnetic disks become cheaper increased storage capacity remarkable rates still cannot satisfy economically storage requirements videobased databases many demanding applications videoondemand digital libraries teleteaching video broadcasting etc tertiary storage particular tape libraries offer economical solution example tape storage even considering highend tape library products ampex dst812 robotic library costs less 3 centsmb highend disk array products maximum strategys gen5 product cost centsmb furthermore figures cover capital costs include high maintenance costs disk storage reported work partially supported esprit long term research project hermes project number 9141 costas georgiadis peter triantafillou department electronics computer engineering technical university crete crete greece email addresses fgeorgiadpetergcedtucgr z peter triantafillou contact person x department computer science carnegie mellon university pittsburgh usa email address christoscscmuedu material based upon work supported national science foundation grants iri9625428 dms9873442 iis9817496 iis9910606 defense advanced research projects agency contract n6600197c8517 additional funding provided donations nec intel opinions findings conclusions recommendations expressed material authors necessarily reflect views national science foundation darpa funding parties 7mb 17 considering storage 12 database containing thousand videos costs less 400000 highend tape library chosen eg price ampex dst812 four drives 256 50gb tapes 4000000 highend disk array chosen eg price 8 maximum strategys gen5 arrays storing 17tb ii mediumsized companies reported willing spend 125000 annually mass storage systems one see robotic nearline tape libraries desirable reasons tape library market growing annual pace 34 17 however robotic tape library access times remain 3 orders magnitude slower diskbased storage due costly robotic exchange tape positioning operations reason many demanding applications involve abovementioned storage levels hierarchical storage servers higher fastest level disk storage acts cache lowest slowest robotic tape library fact several realworld products applications digital tv broadcasting digital video effects relying upon storage technology infrastructure 8 since tape library level slowest performance improvement transfering data level improves considerably overall storage hierarchy performance goal paper twofold first study central issue scheduling retrieval requests tertiarystorageresident video objects second performance fundamentals tertiary storage robotic tape library video databases 11 tape library technology overview tape libraries typically consist robot arms tape drives large number tape cartridges robotic mechanism loadsunloads tapes fromto shelves tofrom drives tape technology employed either linear helical scan recording 1 9 linear tapes tracks parallel tapes axis read batches either one direction eg serpentine drives helical scan tapes tracks angle tapes axis rotating drum read tracks tape moves one direction addition great variability storage capacity tape cartridge typical values ranging gbs 330gb total access time tape libraries considerably high searching within tape proceeds best pace 16gbs plus startup cost seconds many vendors report robotic delays less seconds least smallercapacity tapes bring total access cost tens seconds currently tape drive products offering transfer rates 20mbs compression 12 problem application requirements video databases high storage requirements example single mpeg2 90minute video typically requires least 23gb storage reading mpeg2 video tape take 100 seconds 20 minutes depending tape drives performance capabilities video accesses follow skewed distribution thus multicasting batching single reading video requests may prove beneficial however due vcrtype interactions requests may different parts video prohibiting multicasting thus workloads types considered finally requests served within certain time threshold ie nearvideoondemand applications users drop algorithms ensure low startup latencies lucky requests expense high dropoutrejection ratio realworld usefulness efficient scheduling algorithm must achieve high throughput respecting rejection ratio constraints systemlevel issues library three different types resources requests compete tapes tape drives robots service requests simultaneous resource allocation necessary request possess tape wants copy replication well possess tape drive maybe robot arm tape already loaded simultaneous resource allocation makes efficient scheduling formidable task problem hand therefore twofold first devise efficient scheduling algorithms appropriate complex environment examine performance second study resources form bottlenecks circumstances done alleviate bottlenecks second problem addressed examining impact length service times number tape drives number robots employed settings parameters create bottlenecks either robot drive resources approach experimental analytical first develop optimal scheduling algorithm simplified problem setting adapt algorithm environment experimental study compare performance algorithm others found literature study general performance characteristics video tape library section 2 overview related work section 3 description tape library model provided detailed description three scheduling algorithms presented section 4 section 5 contribute formal problem formulation optimal scheduling algorithm called relief section 6 explain could tape replication incorporated scheduling algorithms section 7 present results derived experiments finally overview work presented section 8 related work despite facts tape library storage recognized economical mass storage medium applications video servers ii suffers high access times iii currently employed many realworld video deliverymanipulation products iv enjoys high market growth rates knowledge reported study efficient scheduling video tape library acceses experimental investigation performance issues video tape library environments efficient scheduling algorithms related work mostly concentrated modeling performance characteristics tape drive tape library products 1 9 13 14 comparative studies use tertiary storage multimedia 1 2 7 storing elevating video blocks tertiary playback 5 18 caching digital library documents secondary storage 15 striping analytical modeling tape libraries fcfs scheduling 6 12 algorithms optimal data placement tertiary libraries 3 scheduling random accesses traditional data single serpentine modified serpentine tapes 10 11 16 authors contributed scheduling algorithm video tertiary libraries useful several drives compete one robotic arm queuing delays could otherwise cause hiccups 3 tape library simulation model one distinguish operations tape librarys components robot arm tape drive operations robot arm performs three fundamental tasks load unload move operations load operation consists grabbing tape cartridge shelf putting drive unload operation consists grabbing tape drive putting back shelf loading unloading require arm movement shelf drive performs four operations namely medium load medium eject tape searchrewind tape read playback tape libraries consist three key resources tape drives robot arms tapes contention three resources cause queuing delays queuing delay tape occurs request tape cannot served even though may available drives robots desired tape already use serving another request robot queuing delay occurs available robot arm request requires one finally queuing delays drives occur available drives used waiting requests notice case simultaneous resource occupation request may wait tape available empty tape drive possibly free robot arm desired tape already loaded model simulates closed queuing network tape library library consists tape drives r robot arms tapes robots considered similar meaning every operation robot perform also performed every robot time tape drives also considered similar model tape contains single video object done simplicity since allows us bypass dealing issues efficient placement video objects within tapes declustering issues etc research issues right every time object accessed time spent drive transferring data depends objects size drives transfer rate video object accessed tape rewind performed denote sum transfer rewind time term access time access measure seconds multicasting environments simplicity assume requests transfer time ie video size unicasting environments case since wish model random accesses within video case robot invocation required following operations take place drive unload old tape idle drive simultaneous move robot arm towards drive robot unload tape robot movement placement old tape shelf robot movement unload new tape shelf finally robot movement drive load new tape whole procedure described takes practically constant time found independent relative location tapes 1 termed mount time mount also measure seconds implicitly assumed drive becomes idle ie request requires access tape remains drive placed offline ie moved away drive request another tape host drive must used 1 model user behavior ie way user issues requests library associating object access probability p request tape playback made according access probabilities objects assume standard practice related work videos probability distribution follows zipf distribution found closely reflect user preferences exponent controls skew distribution greater exponent skewed distribution typical exponent values found literature range 073 2 1 4 note hierarchical storage video server primary secondary storage acting caches tertiary secondary storage cache absorbing requests popular videos definitely affect skew zipf distribution however experiments shown reasonablysized secondary storage caches storage capacity 5 tertiary backing store required bandwidth service requests popular videos thus requests received tape library continue follow quite skewed distribution significant percentage total requests submitted video server see appendix unicasting environment request best case wait access seconds order serviced requested tape must first brought online total service time cannot less access mount seconds naturally times include queuing delays tapes drives robots multicasting environments request may piggyback another since single possible robot access single drive access requests video served thus total cost amortized piggybacking requests queuing system model depicted figure 1 uses queue incoming requests wait service queue termed wait idle drive queue widq drive becomes idle scheduling algorithm pick request group queue serve since robot involvement may required 1 tape drives actually unload tape idle long period time however minor issue since scheduling primary concern systems heavy loads queue selected requests wait robot arm become available queue termed wait idle robot queue wirq wirq required number drives greater number robots robot 1 robot 2 robot r idle robot queue drive 1 drive 2 drive drive subsystem robot subystem rejections idle drive queue figure 1 queuing system library model mentioned requests library require simultaneous resource allocation request requires first tape resource second drive resource assigned may require robot resource desired tape already loaded onto assigned drive two main types events library arrival new request completion service request essence systems operation follows arrival new request ffl request enters widq completion request idle drive ffl drive tape declared available locking ffl scheduling algorithm applied requests widq selected request must available tape ffl idle drive selected tape locked ffl request queued robot necessary case upon completion robot service taking mount time playback starts requests waiting past certain timeout exit system system rejects also simplicity paper assumed requests wirq served fcfs basis table 1 shows system parameters typical values table 1 system problem parameters parameter explanation values number drives 5 r number robots 1 2 number tapes 300 access drive access time 2 60 230 secs mount mount time robot drive loadunload 25 secs ro replication overhead 0 20 storage space access probability th video zipf uniform skew parameter zipf 0271 0271 timeout requests rejected 5 20 1 mins mean number requests th video per time unit tp throughput requestshour achievable algorithm mpl multiprogramming level number users 20 200 requests scheduling algorithms requests video tape library next outline three basic scheduling algorithms fcfs scheduling scheduling algorithm picks request closest head queue ie already tape drive oldest one whose tape available ie used another request algorithm serves reference point comparison purposes bypass scheduling similar shortest job first younger request allowed bypass older requests need costly robot access bypass selects queue oldest request tape already loaded idle drive request exists bypass behaves fcfs bypass tries minimize costly robotic operations multicasting environment bypass scheduling allows requests queue waiting video selected request piggyback onto selected request bypass unfair algorithm suffering starvation thus become useful incorporate aging mechanism avoid starvation paper study bypass without aging noting performance upper bound performance useful bypassbased algorithm aging maximum queue length mql scheduling mql suitable environments multicasting allowed algorithm partitions waiting queue number queues one tape scheduling time selects serve queue greatest length motivation increase much possible amortization benefits gained multicasting algorithm studied similar context namely efficient batching policies video requests found perform well 4 mql also suffers starvation mpeg2 video bandwidth 4mbs 80 minutes 4800 seconds needs 48004 mbits24gb storage tape drive transfers data rate 12mbsec retrieve video 24gb12mbs200s seconds 5 formal approach 51 formal problem formulation goal find tape request serve drive becomes available answer pick request maximize relief ratio next give definitions justification first study structured problem consider queueing setting given one server eg io channel tape drive able broadcastmulticast data items eg video movies ii requests distinct video items iii ith video item service length l time units iv ith video item accessed probability p v requests item arrive mean rate assuming access probabilities p remain constant time want find often schedule multicast item want find cycle times c item minimize average waiting time ie startup latency requests notice cycle time c integer multiple unit time measures time units beginning one broadcasting item beginning next broadcasting theorem 1 single multicasting server items access probability p ith item optimal cycle time c ith item given c proof average waiting time w given percentage time units server engaged video l c assuming server never idle ie utilization 1 percentages sum 1 thus want minimize eq 1 subject constraint eq 2 using lagrange multipliers theory using eq 2 get qed 52 proposed scheduling algorithm relief initial scheduling problem crucial observation eq 3 implies assuptions mean arrival rate constant ii mean arrival rate item get since constant eq 4 becomes2 c intuitively c accounts average number requests serve every broadcasting ith item cumulative waiting time cumulative relief enjoyed broadcasting ith item divided l gives us amount relief enjoyed per unit time broadcasting item lets call relief ratio ith itemtape cumulative waiting time relief scheduling access probabilities p unknown single multicasting server choose object maximimum relief ratio justification follows eq 6 implies optimal choice cycles c 1 relief ratio item start broadcasting item constant equal items clearly means relief ratio item higher relief ratio every item second start broadcasting ith item item j higher relief ratio clearly relief ratio would increase waiting broadcasted thus would increase inequality relief ratios items j goes principle eq 6 way assured best achieve maximum possible relief next l service time units fact access probabilities constant time relief indeed optimal automatically leading optimallength cycles corollary 1 relief heuristic optimal access probabilities p constant time even unknown us proof sketch server automatically pick ith object results optimal cycle times theorem 1 qed proposed scheduling algorithm based previous proof relief ratio key choosing next request serve relief algorithm attempts improve performance minimizing average startup latency video requests achieved calculating every request queue total wait time b service time computing relief ratio request service time intuitively selected requests either long waiting time andor require small service times thus essence algorithm picks request results greatest wait time relief smallest resourceoccupation time multicasting requests video form request groups algorithm selects group highest group relief ratio group relief ratio computed summing waiting times members group dividing service time whole group addition novelty relief algorithm note aging mechanisms scheduling algorithms typically found adhocly based sound formal arguments 6 video tape replication single copy object might result maximum drive utilization satisfying startup delays see consider following scenario library ten tape drives bypass relief mql scheduling discipline used suppose video access probability 09 means around 90 requests pending hot object drives small number requests pending probably idle drives following observation arises naturally another replica hot object one idle drives could utilized performance system would improved leads us notion object replication distinct objects might number replicas furthermore logical choice maintain many replicas object access probability induces way two objects access probability ratio equal holds ratio number replicas equals 0 0 total number tapes used store replicas refer 0 term replication overhead using fraction example library 100 20 replication overhead 0 20 tapes used replication total 0 120 tapes system replication applied basic scheduling algorithms regardless multicasting algorithms already described need tuned far algorithms described single copy tape algorithm selected particular group request request must one available tape desired tape already use active drive algorithm select another request repeat process request selected available tape replicas algorithm selects group request serve long one replica desired tape available 7 performance results simplicity investigating systems resources drives robots affect performance primary performance metric system throughput rejections turned section focuses performance comparison scheduling algorithms use primary performance metrics rejection ratio system throughput rejection ratio constraints since meaningful metrics realworld applications number distinct tapes therefore objects set single robot arm considered system r 1 unless otherwise stated robot mount time mount set 25 seconds drive access time access set 200 seconds unless otherwise stated use notation ro replication overhead ro 02 means cartridges store replicas objects used zipf distribution stated model access probability distribution objects 71 impact drive access time number robots130150170190210 throughput r1 d5 unicast ro0 theta0271 average startup latency r1 d5 multicast ro0 theta0271 b figure 2 drive access time impact figures 2a 2b show throughput function mpl relief unicasting multicasting environments first thing notice throughput unicasting drops access time increases easily explained since request takes time serviced forcing waiting ones stay longer queue interestingly enough multicasting relief algorithm affected drive access time latter less 100 seconds happens multicasting throughput system much greater compared unicasting making robot resource even severe bottleneck situation ceases occur average case one drive waiting get loaded time ie time elapsed two consecutive media exchanges drive ie drive access time robot arms enough time load rest drives access gamma 1 mount r 8 according formula minimum access time robots bottleneck mount r equal 100 seconds graphs last observation suggests criterion extra robot arm required orand drives needed access values systems resources well utilized figure 3 weshowhow increasing one number robots affects abovementioned graphs throughput d5 taccess60s unicast ro0 theta0271 relief figure 3 impact number robots unicasting multicasting schemes considerable improvement throughput additionally note robot longer bottleneck example access 60s see considerable performance improvement adding second robot arm 72 impact number drives figures 4a 4b 4c show throughput increases proportionally number drives happens number requests system large enough none drives idle therefore duplication number drives doubles throughput reduces startup latency half however limiting number drives beyond performance system improve proportionally number drives even improve see figures 4a 4b graphs 10 due fact single robot arm become bottleneck results drive underutilization things hold bypass fcfs mql policies although shown100200300 throughput r1 taccess80s zipf multicastro0 theta0271 relief r1 taccess50s110s zipf unicast ro0 theta0271 relief r1 taccess50s110s uniform unicast ro0 theta0271 relief b c figure 4 effect number drives systems performance figures 4b 4c one witness skewed access frequencies better performance relief discipline happens relief well bypass skewed distributions selected request higher probability finding desired video online hand although shown fcfs mql algorithms almost improvement observed skewed distribution used fcfs policy benefits skewed distribution first request picked widq idle drive emergence video released probability last occurs increases slightly uniform distribution replaced zipf one 73 performance comparison scheduling algorithms unicasting use access 200secs sufficiently away point robot bottlenecks seen section 71 731 rejection ratio first performance metric concern rejection ratio defined fraction rejected requests requests submitted system reason runs associate request timeout request scheduled yet rejected figure 5 shows results two different timeout values two main observations 1 fcfs mql relief similar performance justified since three algorithms unicasting environment tend choose requests head widq reason show graph performance relief bypass 2 two fundamental observations regarding performance rejection ratios bypass relief bypass benefits number rejections high either low timeout values high mpl values happens bypass rejected requests reenter system get another chance lucky requesting loaded tape b relief nature fair algorithm tries evenly distribute waiting times among requests establish waiting time mpl increases waiting time approaches surpasses rejection timeout leads smaller rejection ratios relief smaller mpl values two observations explain bypass closer relief timeout value 5 minutes high mpl values timeout 20 minutes important thing note however small timeout values 20 mins high mpl values bigger timeout values eg timeout value 20 minutes mpl greater rejection ratios unacceptable results subsection significant utility help video storage system establish admission controller requests admitted system given rejection ratio constraint violated rejection r1 d5 taccess170s230s unicast ro0 theta0271 bypass tout20mins bypass tout5mins figure 5 effect timeout value relief bypass 732 throughput rejection ratio constraints given real video storage systems high rejection ratios requests would intolerable focus throughput various scheduling algorithms given admission controller video server admit maximum number requests serviced without exceeding certain threshold value rejection ratios table shows results obtained follows first determined graphs previous subsection algorithm maximummpl value rejection ratio constraint 01 satisfied subsequently turned graph showing throughput algorithms function mpl shown space reasons determined corresponding throughput algorithm maximum mpl value table 2 d5 access 200secs 0271 20mins rr 01 ro0 unicast fcfs 19 6414 bypass see relief achieves highest maximummpl value slightly better throughput compared mql considerably better throughput compared fcfs however slightly worse throughput bypass particular relief achieves 147 higher throughput mql 5017 higher throughput fcfs 151 lower throughput bypass 74 performance comparison scheduling algorithms multicasting 741 rejection ratio02061 rejection r1 d5 taccess200s tout20mins multicast ro0 theta0271 bypass fcfs rejection r1 d5 taccess200s tout20mins multicast ro0 theta0271 bypass fcfs mql b figure rejection ratios two different zipf access distributions figures 6 show rejection ratios algorithms timeout equal 20 minutes two different zipf distributions see figure 1 fcfs exploit multicasting capability hence highest average startup latency naturally leads greater rejection ratios 2 bypass hand allows multicasting fcfs specifically exploit like mql relief bypass mainly concerned picking request group requires robot exchange thats performance mql relief 3 relief algorithm better rejection ratio performance mql mpl values greater 40 better performance due fact design relief aims relieve system much waiting misery possible per service time unit 4 also see skewed access distributions rejection ratio values smaller algorithms except fcfs ii difference rejection ratios relief mql starts smaller mpl values 742 throughput rejection ratio constraints table 3 shows results obtained case table 2 table 3 d5 access 200secs 0271 20mins rr 01 ro0 multicast improvement max mpl others 48 22184 bypass 42 17404 2746 see relief achieves higher maximum mpl value throughput value 8 impact tape replication figures 7a 7b show throughput relief function mpl unicasting three different dvalues r2 gamma0271 chose r2 saw earlier throughput improved increase number drives stay one robot conclusions drawn study follow first three conclusions hold mql bypass algorithms also metrics rejection ratio throughput without timeouts reason space reasons show performance relief timeouts unicasting also report important findings 1 although shown slight improvement evidenced less skewed access distributions improvement due fact replication increases probability selected requests find available tape thus allow algorithms optimization greater extent 2 skewed distributions performance improvement significant see figures 7a 7b additional improvement due greater drive utilization example skewed distributions drives one replica per tape results drives underutilized 3 multicasting environments shown graphs replication help biggest contributor improvement far multicasting feature 4 interesting subtle behavior throughput system better replication unicasting lower aggregate drive utilization 10 5 latter turn due fact 10 requests chance serviced drives requests typically induce robot exchanges workload requests served 5 conclusion also supported significant lower rejection ratio observed d10 throughput r2 taccess170s230s unicast ro0 theta0271 relief throughput r2 taccess170s230s unicast ro02 theta0271 relief b figure 7 impact replication 9 concluding remarks studied performance behavior robotic video tape library variety workloads access distributions access times unicastingmulticasting variety scheduling algorithms mql bypass relief major contributions ffl problem definition along nuances skew tapeaccess probabilities unicast ingmulticasting simultaneous resource allocation replication performance metrics etc ffl design relief novel fair scheduling algorithm nearoptimality proof contrast scheduling algorithms use adhoc mechanisms achieve fairness ffl extensive experimentation showing relief outperforms competitors 203 compared fcfs 27 compared bypass 37 compared mql throughput rejection ratio note bypass mql unfair starvationbound ffl conditions robotarm tape resources become bottlenecks eq 8 ongoing work includes study tapereplication schemes study tape library scheduling algorithms applications r tertiary storage evaluation new applications challenges tertiary storage multimedia servers principles optimally placing data tertiary storage libraries dynamic batching policies ondemand video server multimedia repositories personal computers hierarchical storage systems analysis striping techniques robotic storage libraries study use tertiary storage multimedia systems role data storage broadcastings future modeling performance characteristics serpentine tape drive random io scheduling online tertiary storage systems scheduling noncontiguous tape retrievals analytical performance model robotic storage libraries performance measurements tertiary storage devices benchmarking tape system performance vertical data migration large nearline document archives based markov chain predictions costeffective nearline storage server multimedia systems untangle tape storage costs ondemand data elevation hierarchical multimedia storage servers tr ctr peter triantafillou r harpantidou paterakis high performance data broadcasting systems mobile networks applications v7 n4 p279290 august 2002
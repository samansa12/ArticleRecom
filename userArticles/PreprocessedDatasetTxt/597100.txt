handling updates crashes vod systems though several recent efforts develop disk based video servers approaches ignored topic updates disk server crashes paper present priority based model building video servers handle two classes events user events could include enter play pause rewind fastforward exit well assystem events insert delete serverdownserverup correspond uploading new movie blocks onto disks eliminating existing blocks disks andor experiencing disk server crash present algorithms handle events algorithms provably correct computable polynomial time furthermore guarantee certain reasonable conditions continuing clients experience jitter free presentations justify efficiency techniques prototype implementation experimental results b introduction last years tremendous drop digitization costs accompanied concomitant drop prices secondary tertiary storage facilities advances sophisticated compression technology three advances amongst others caused great increase quality quantity research design video servers 2 4 11 6 10 16 models video servers date assume following parameters 1 movies stored part entirety one disks 2 videoondemand vod system responsible handling events occur client events studied include ffl enter new client system requesting movie ffl exit existing client system ffl activities continuing clients eg play fast forward rewind pause handling event refers process vod server assigns jobs different disk servers optimize performance criterion variety algorithms handle events studied researchers authors address department computer science university maryland college park md 20742 events user events sense invoked caused activities user vod system however reality another class events must accounted call system events includes events serverdown specifying certain disk server crashed serverup specifying disk server previously crashed insert specifying system manager wishes include new movies blocks movies disk delete specifying system manager wishes delete movies servers disk array work date server crashes focused important topic recovery data crashed disk really looked satisfy clients vod system promised service based part expectation crashed disk would satisfy requests main focus paper develop vod server algorithms handle user events also handle system events problem updates video servers crucial several applications video data gathered regular intervals placed vod system example movieondemand vendor may regular intervals include new movies repertoire movies offered potential customers movies need placed disk array vendor may using leading insert operation similarly newsondemand systems new news videos audio reports may become available continuing basis need made available editors news programs creating current date news shows many similar systems today done taking system accomplishing update bringing system back obvious undesirable aspect way handling updates service must denied customers wish access server thus leading lost revenues vod vendor algorithms proposed paper treat updates collections events schedule occur concurrently userevents manner ensures 1 existing customers see deterioration reasonable restrictions quality service 2 update gets incorporated timely fashion particular algorithms flexibly adapt load disks incorporate much update possible resources available reduce update rate resources previously committed 3 system taken order accomplish update unlike issue updates disk crashes certainly studied extensively years 2 12 however consider problem vod server made certain commitments customers crash occurs vod server must try ensure client serviced disk crashed switched another disk service clients needs furthermore vod server must ensure fact disk crashed taken account processing new events vein disk server previously crashed comes back means new system resources available thus enabling vod server take appropriate actions eg admit waiting clients redistribute load servers achieve good load balance etc show framework handling updates handle crashes well certain limitations course particular propose algorithm called vsuc video server updates crashes algorithm handles events including user events well update events crashes several nice properties particular disk array server disk array server n disk array client 1 client 2 client m1 client high speed network router figure 1 system structure ffl vsuc guarantees certain conditions ensures continuous jitter free service clients admitted make conditions precise theorem 41 ffl vsuc also guarantees certain conditions client denied service arbitrarily long cf theorem 42 ffl vsuc reacts client events well system events polynomial time system architecture throughout paper use term video block block denote video segment assume size block arbitrary fixed words one vod application may choose block size frames another may consider size 60 frames video data stored disk means start video block located single page disk contains block data laid collection disks assume collection disks partitioned disjoint subsets dc 1 furthermore assume disks dc homogeneous ie identical characteristics single disk server ds regulates access disk drives dc entirely possible dc contains one disk could contain note requirement two disk collections dc need characteristics hence disks dc may vastly different characteristics dc j accomplishes heterogeneity design disk servers well known 2 4 11 6 10 16 simplest form disk server piece software given physical disk address retrieves object located address case disk servers ds mediate access collection dc disks means given diskid physical disk address server retrieves block located given disk address specified disk figure 1 shows structure system described informally architecture video server responsible following tasks 1 event user event system event occurs video server must determine handle event accompanied creating schedule accomplish event deciding instructions must sent disk servers involved successfully handle event example user event play instructions could include fetch client cl id block starting page p disk note disk server necessarily need know clients identity cl id 2 addition video server may need switch clients one disk server another example client cl id 1 may served disk server ds 1 new client cl id 20 requests movie block available disk server ds 1 disk server ds 1 already functioning peak capacity may possible switch client cl id 1 another disk server say ds 2 resources needed satisfy client cl id 1 3 third video server may split job smaller manageable jobs distribute smaller jobs different servers leads better system utilization 4 fourth whenever events disk server crashes occur vod server must reassign existing clients servers possible schedule system generated recovery events minimize damage caused crash 21 system parameters vod system participating entities may divided following components 1 servers disk servers retrieve specified blocks relevant disks 2 clients processes makingissuing requests servers 3 data includes movie blocks laid disks order successfully model vod system develop provably correct efficient algorithms purpose must model parameters well interactions components tables 23 4 show notations use denote relevant parameters servers clients movies respectively throughout paper assume set movies wish store disk movie bnumm blocks block denotes level granularity wish store reason mediadata example block may singleframe finest granularity consecutive sequence 100 frames application developer free select size block way wishes block size selected committed using selected block size application words free choose block size wish make choice must stick symbol meaning bufi total buffer space associated disk server state total cycle time read operation server state total disk bandwidth associated disk server state timeslice allocated client j state server set servers handling request client state set servers contain block b movie according placement mapping state server clienti set clients assigned nonzero timeallocation disk server state server statusi status flag server true server working false otherwise time required disk server switch one clients job another clients job state buffer space needed server match consumption rate client j state prioritye priority event e state figure 2 server parameters symbol meaning consumption rate client state set data blocks server providing client j state inusei set consists 3tuples j k b specifies server providing block b movie k client j state active clients set clients active state clientm set clients watching movie state rew wini size rewind window client state means client rewind movie many blocks size fast forward window client state means client fast forward movie many blocks play wini time limit client access system state pause wini time limit client pause state figure 3 client parameters symbol meaning number blocks movie figure 4 movie parameters 3 state transition model paper develop state transition model following properties ffl state feasible configuration system includes information disk servers serving client service providing client resources committed server client accomplish service provided ffl state system may change time triggered events events include client events enter exit fastforward pause rewind play well server events serverdown serverup server goes comes back manager events insert delete note manager events could either initiated human vod system manager tertiary storage device staging data onto disk though go possibility detail paper 31 state system state consists following components 1 set active clients active clients state 2 current cyctimei server system 3 consumption rates active clients consi state 4 time timealloci j within cyctimei allocated server client j state 5 locations b movie block ie set servers block b movie located state 6 set data blocks datai j provided server client j state 7 client mapping specifies client c set servers c specifying servers serving client c 8 set serverss consisting set servers state 9 set insert lists consisting set 3tuples form b movie b block server block inserted set used model set insertion updates yet handled 10 set delete lists consisting set 3tuples form b movie b block server block deleted set used model set deletion updates yet handled 3 system state must satisfy certain simple constraints list 1 server sum timeallocations assigned clients served server must less cycle time server captured 2 server processing request data data must available server captured expression 3 sum consumption rates clients served given disk server must exceed total disk bandwidth server captured expression 4 server active client captured expression constraints specify basic constraints tie together resources vod disk server system requirements clients 32 prioritized events informally speaking event something potentially causes vod system make transition current state next new state study performance disk servers multimedia applications varies substantially depending upon space events considered model framework space events allowed falls two categories ffl client events enterexitpauseplayfastforwardrewind ffl system events serverup serverdown insert delete event associated integer called priority event set attributes example event serverup attribute specifying server thus serverup2s specifies event server 2 occurred state likewise event insert three attributes server id movie id block number specifying server event assigned movie identifier movie block identifier example event insert2m1b1 specifies block b1 movie m1 inserted server 2 priority event chosen either importance event inherent attributes event example handling client event like play inherently implies delivering continuous data stream client data stream interrupted due reason client may experience degradation quality service degradation avoided choosing appropriate priority play event example system event consider delete event case enough disk space available download hot movies system able make space deleting data blocks soon possible expedite data deletion event assigned high priority specifying events handled describe concepts underlying approach 33 modeling usage constraints vod system system administrator may wish enforce usage constraints paper try force constraints upon system however make available system administrator ability articulate enforce certain types constraints feels desirable system ffl pause time constraint pause time constraint associates client c upper bound pause winc amount time customer pause movie watching example suppose pause win john smith s25 means far system concerned john smiths pause time cannot exceed time units state pause window expires resources allocated vod system taken back satisfy users requests general customer pauses servers satisfying customers request continues hold resources assigned system clearly holding resources indefinite period wise pause window specifies customer upper bound period time customer pause movie ffl fastforwardrewind window constraint addition pause window constraint discussed client c associated fastforward rewind window constraint specifies upper bound number data blocks client fastforward rewind respectively fastforward rewind windows associated client c state specified ff winc rew winc ffl play time constraint finally sometimes might desirable put restriction time client serviced server request constraint help prevent valuable resources taken arbitrary long time irresponsible usage also establishing maximum time client access system request every request eventually satisfied server total play time constraint client specified play wini example play win john smith s180 says john smith 180 time units finish viewing current movie client c1 read delete m1b1 c1 cannot rewind m5 b21b40 m4 b01b30 m3 b41b50 m2 b31b60 m5 b21b40 m4 b01b30 m3 b41b50 m2 b31b60 figure 5 deletion block 34 update boundaries suppose system state arbitrary point time j client served server state contains data tuple specifying data provided client server example consider situation described example section 31 example state shown server 1 presenting blocks b2 b3 movie m1 client c 1 suppose system administrator wishes delete block b1 movie m1 server 1 figure 5 shows situation system manager ability make request time precise time request actually scheduled ie precise time deletion block scheduled must take account existing clients watching movie wrt server question case question needs addressed happens client c 1 wishes rewind b1 deletion incorporated immediately upon receipt deletion request rewind request client denied situation may may desirable thus given point time client associated rewind boundary associated server specifying far back server support rewind request issued client rewind boundary may change time rewind boundary dual concept fastforward boundary defined definition 31 rewind boundary rewind boundary movie wrt server state defined follows rewind boundaryms set min performed empty movie clientms empty rewind example let us return movie m2 server 2 state 1 client c 5 reading block b4 movie m2 2 client c 6 reading block b3 movie m2 block read c5 block read c6 rewind boundary rewind window c5 rewind window c6 block updated min two boundaries figure rewind boundary computation 3 client reading movie m2 exactly pertinent example rewind window client c5 2 client c 6 1 rewind boundary associated server 2 movie m2 state given 2 let us try see case statement means figure 6 illustrates reasoning ffl two clients viz c 5 reading parts movie m2 disk server 2 try update copy movie m2 residing disk server 2 clients affected current state therefore clients c 5 c 6 client c 5 currently reading block b4 rewind window length 2 means go back 2 blocks movie executing rewind command effectively means cannot access blocks block b2 ffl likewise client c 6 currently reading block b3 rewind window length 1 means go back 1 block movie executing rewind command effectively means cannot access blocks block b2 ffl minimum two blocks b2 means neither client read access block b1 state ffl thus wish update block 1 lies rewind boundary safe analogous situation occurs wrt fast forward boundaries defined stated c3s ffwindow c2s ffwindow c4s ffwindow c1s ffwindow current reading block13 figure 7 fast forward boundary computation definition 32 fast forward boundary fast forward boundary movie state defined follows ff boundaryms set max performed empty movie clientms empty ff example consider single disk server figure 7 disk server contains several movies one viz movie m4 shown figure blocks 15720 movie available disk server suppose state four clients watching particular movie clients may watching movies blocks clients watching fast forward windows clients given client block watched ff win fast forward boundary given ff means blocks 1320 movie may updated point time primary use rewind boundaries fast forward boundaries ensure update request made system manager users viewing application flexibility rewind fast forward within limits fast forwardrewind boundaries notice always possible guarantee example figure 7 client c 1 wishes fast forward block 6 way satisfy request without switching another disk server disk server figure 7 block 6 definitions mind ready define handle events handling events section provide detailed algorithms handling events first provide abstract declarative specification constitutes appropriate way handling events provide algorithms successfully handle events 41 optimal event handling specification semantics suppose valid state system e event occurs section first specify means state 0 handle event e occurring state done without specifying find state 0 later provide algorithms handle events definition 41 event handling state 0 said handle event e state iff one following conditions true 1 new clients e new client c enters request movie 2 old clients e old client c exits system 3 continuing clients e continuing client c watches normal viewing mode block b movie b e continuing client c pauses c e continuing client c fast forwards block b block b e continuing client c rewinds block b block 4 server status event e disk server crashes b e disk server comes back rewind windowforward window rewind ff boundary figure 8 example deferred updates 5 update event status movie server delete lists 0 handling update events requires intuition let us suppose movie containing 100 blocks stored entirety one disk server 2 clients c 1 watching movie via server let us say watching block 45 c 2 watching block 50 consuming 1 block per time unit keep things simple let us say system manager wishes update entire movie replacing old blocks new ones may viewed simultaneous insert delete additionally clients c rewind windows fast forward windows 5 blocks figure 8 shows situation ffl stage rewind fast forward boundaries movie 40 55 respectively ffl means blocks may safely updated right away assuming enough bandwidth available ffl blocks b 40 b 55 updated later ie updating blocks must deferred ffl example one time unit block 40 updated 2 time units block 41 updated skeptical reader immediately wonder whether definition allows us postpone update events arbitrarily long time answer stated update events could get deferred ever avoid situation also assign different priorities different clients introduce notion priority associated event client initiated system initiated deferred priority higher priority important event particular e update event e deferred time unit e updated must increment es priority factor ffi e thus different events different associated prioritization steps may selected system manager based importance event determined himher means priority update events gradually rises till deferred longer discuss scheme detail also show idea applies priorities nondeferred events 42 priority scheme events whenever event occurs event assigned initial priority either system system administrator system maintains list default priority assignments event different priority assignment made system administrator latter overrides former integers used represent initial priority assignments though shall see noninitial priority assignments may realvalued precise integers used initial priority assignment really important important relative priority ordering initial priority assignments figure 9 shows initial priority assignments rationale assignments discussed 1 system events highest priority reason server crash server coming back events hard control possible instance defer delay crash occurs system must transition new state handles crash best possible 2 next existing clients already served system must highest priority reason vod system made commitment serve clients well must try honor commitments however existing client may spawn different events including exit pause play fast forward rewind events different priority highest priority assigned events exit processing exit event early desirable general done fast furthermore frees resources may used satisfy clients continuing clients well potential new clients b next highest priority class assigned pause events first events request new resources hence satisfied immediately second pause window events may lead future exit events fact c next highest priority class assigned play events reason cases play events relatively easy satisfy merely require next block movie fetched cases next block disks already serving client last two events category equal priority rewind fast forward events may require substantial switching clients ie client may switched current server another blocks skipped current server longer blocks several jumps ahead block currently scanned 3 new clients entered system waiting service lowest priority among user events reason video server started serve client service continued minimal disruption case new clients reasonable expect delay service starts however shouldnt cause new clients wait infinitely paper situation handled increasing priority incrementally event type event priority system server 9 system server 9 client old exit 7 client continuing pause 6 client continuing play 5 client continuing fast forward 4 client continuing rewind 4 client enter enter 3 manager delete 27 manager insert 1 figure 9 initial assigned priorities different events 4 system events delete event highest priority reason delete events accomplished simple operation remove pointers appropriate blocks contrast insert events require greater resources eg disk bandwidth needed write onto disk priority steps suppose update request received block b movie server suppose rwb fwb denote respectively rewind boundary fast forward boundary associated current state difficult see must rwb ffb update cannot carried immediately rwb b ffb consequence might need defer update however mentioned deferring update might cause event indefinitely delayed one possible way avoid assign higher priority update events client events handled first problem might cause continuous streams experience interruption handle update events eventually well minimize effect continuous streams define prioritystep priority step ffi u specified system administrator update request u ffi u nonnegative real number interpretation follows current state update u occurs priority p shown figure 9 p must either 1 2 states occur consecutively 0 defer update u ffl priority p update event u state p thus example suppose u deletion request system manager assigns step 02 u 6 state changes ie state 6 priority update 32 would exceed priority new event occurring state means new client enters system state 6 requests movie server question would asked consider higher priority update request u opposed serving customer making step size small system manager allow greater period time elapse making update higher priority new clients example system manager set ffi u example 0002 501 state changes would occur update us priority exceeded new client furthermore system manager specify priority step update different updates different associated priorities would expected real life systems ready give algorithm manipulates priorities shown figure 9 priority steps handle events occur given point time video server updates crashes vsuc algorithm main handleevents newevents oldevents f set events cant scheduled cycle set client events scheduled successfully timeout evtlist get first event evtlist switch f case case case play rewind fastforward handlecontevents evt case pause handlepauseevents evt case case enter handleenterevents evt case insert handleinsertevents evt case delete handledeleteevents evt increase priority event evtlist merge events evtlist waitlist return procedure handleserverdownevents evt data block b crashed server update placement mapping b visible event e crashed server insert e evtlist preserving sorted order procedure handleserverupevents evt f data block b recovered server update placement mapping b visible procedure handleexitevents evt f release resources data structures allocated evt procedure handlecontevents evt f set blocks necessary servicing evt depending event type way blocks read disks different example play event certain number continuous blocks read rewindff event intermediate blocks skipped match speed servers assigned evt contain blocks blocks f update data component evt insert evt donelist return set servers contain blocks blocks placement mapping error f make evt considered block insertions decrease evts priority insert evt evtlist preserving sorted order return set servers dservers satisfying resource constraints f evts priority decreased previously f finished svlist 6 finished f select one server randomly svlist event e served exists 0 6s satisfies e switchables 6 finished f select one event randomly switchables evt served using resources released e 0 f release resources e 0 update resource allocation allocate resources evt update resource allocation allocate resources e 0 update resource allocation put evt donelist finished f make evt scheduled prior clients next cycle increase evts priority ffi 0 evt insert evt waitlist else f make evt considered scheduling normal continuing clients decrease evts priority ffi evt insert evt evtlist preserving sorted order else f server rservers f specified criteria f allocate resources evt update resource allocation insert evt donelist procedure handlepauseevents evt f yield disk bandwidth update events next cycle keep status unchanged procedure handleenterevents evt f enter event handled way similar handling continuous events difference case enter events resources assigned previously therefore checking already assigned server handle event necessary enter events procedure handleinsertevents evt f evt server data block inserted specified evt size data inserted evt data size server evt handle using available resources f allocate resources evt update resource allocation evt dsize update placement mapping information evt else f dsize cant inserted entirety allocate resources evt update resource allocation evt msize reduce evts data size msize increase evts priority insert waitlist procedure handledeleteevents evt f number deleted calculate rewind fast forward boundary movie rewind boundary b evt ff boundary delete b evt update placement mapping information else f evt deferred next cycle increase evts priority ffi evt insert waitlist easy prove vsuc algorithm described number nice properties stated theorems informal description properties follows ffl certain reasonable conditions clients already admitted system experience jitter independently events occur result applies 1 placement mapping full ie either entire movie available server none 2 client watches movie entirely normal viewing mode 3 server outages occur ffl every event eventually gets handled long servers go eventually come back ffl vsuc algorithm runs polynomial time ie current state ev set events occur new state 0 together perhaps deferred events computed polynomial time theorem 41 continuity commitments suppose current state system c continuing client state watching movie normal mode furthermore suppose 1 movie contained entirety server sv 2 2 server goes time 3 updates u client c entered system deferred client c enters pr pr u priority update u client c enters system ffi u priority step associated update ffi c priority step associated c 4 updates u client c entered system enter system client c enters newpr newpr u priority update u enters system client c movie request event satisfied vsuc algorithm proof sketch vsuc algorithm event diminishes systems resources higher priority continuing client server event deferred update event however assumption statement theorem servers serving client c go hence highest priority events either deferred updates continuing clients suppose server sv serving client c request part full deferred events occur server continue servicing client c request next blocks however deferred events occur two possibilities 1 suppose deferred update u requested client c entered system pr u 5 ffi follows throughout normal playing movie client c priority higher update u thus server sv continues serve client c without allowing deferred events obtain priority client c 2 hand deferred update requested client c entered system client c guaranteed obtain priority update newpr hence client c continue served server sv 2 theorem important implications admission control new clients new updates ffl client admission guarantee continuity service new client c admitted system deferred updates u need handled client c enters system must know pr u 5 ffi ffl update admission guarantee continuity service existing clients new update u admitted system newpr theorem 42 update events get handled eventually suppose current state system ev update event requires set sv servers suppose times servers sv exists time 0 one servers sv go exists time 0 servers sv come back update event ev occurs exists time ev ev gets handled time ev proof sketch update event ev get handled execution vsuc algorithm event evs priority strictly increases till exceeds 7 point 0 time handled unless one servers needed service event ev restriction statement theorem exists time 0 servers sv simultaneously guaranteed event handled latest time 2 theorem 43 suppose evt set events occur time time taken vsuc algorithm terminate polynomial sum number events evt number deferred events proof follows immediately function call main algorithm runs time polynomial wrt sum 2 5 experiments 51 crash handling vs survival rate simulation experiments suggested vod architecture carried mentioned video server consists multiple disk servers possibly different relative performance character istics performance characteristics disk servers defined 1the lowest 4the highest three disk server configurations considered experiments homogeneous servers highest performance characteristics homogeneous servers lowest performance characteristics heterogeneous servers different performance characteristics 3 following experiments examined resilence video server disk server crashes different disk server configurations ie well video server performs crashes occur number disk server crashes crash time generated randomly assumed crash recovery time uniform recovery time disk server would available use compare resilience video server repeated experiment different frequency server crashes measuring average number continuing clients crashes figure shows effect handling server crashes number continuing clients regardless server configuration system could support streams crash handling without crash handling however depending upon performance characteristics servers involved number continuing clients could supported varied notable improvement shown case homogeneous server highest performance characteristics frequency disk crashes increases system experience much difficulty scheduling clients resources video data crashed servers available crash recovery crash handling handling effect server crashes average number continuing client probability server crash average number continuing client heterogenous homogenouslow homogenoushigh figure 10 effect disk server crashes2040608010012040 70 100 130 160 190 220 250 280 310 340 370 400 430 460 490 520 550 580 survival percentage period server crashes homogeneoushigh homogeneouslow hetergeneous figure 11 effect server crash rate survival rate 1 number video clips 800 minutes video 400 minutes video 200 minutes video 100 2 size video segment 1080 minutes 3 size block 02 seconds compressed video data 4 number requests 8002000 request pattern based actual data referenced 5 6 number disk servers 7 types disk servers buffer disk bandwidth group 3 32mb 16mb group 4 16mb 8mb 8 buffer size avg 50 mb per server 9 disk bandwidth avg 20 mb combined per server table 1 parameters used simulation measure many clients continue even server crashes define survival rate ratio clients continue served total number clients system crash occurs figure 11 shows homogeneous disk servers showed stable survival rate respect disk crashes however heterogeneous disk servers showed noticeable variation survival rate next experiment used different disk server configurations examined effect crashes disk servers different performance characteristics request pattern video data table 1 shows several parameters related experiment experiment used four different types disk servers servers highest performance characteristics belong group 1 servers lowest belong group 4 normal operation servers higher performance characteristics store video segments support concurrent streams lower performance characteristics therefore effects disk crashes vary depending performance characteristics server crashes figure 12a 12d show many clients crashed server continue served even disk crashes varying system load comparison showed number continuing clients crash handling without crash handling crash handling means streams crashed servers discontinued unconditionally figures difference top line bottom line number clients crashed disk average crash handling vod server algorithm satisfy half clients affected crash rescheduling streams available servers number clients server crash number clients crash handling number clients crash handling continuing clients beforeafter server crash group1 clients system number continuing clients number clients server crash number clients crash handling number clients crash handling continuing clients beforeafter server crash group2 clients system number continuing clients continuing clients group 1 b continuing clients group 2 number clients server crash number clients crash handling number clients crash handling continuing clients beforeafter server crash group3 clients system number continuing clients number clients server crash number clients crash handling number clients crash handling number continuing clients beforeafter server crash group4 clients system number continuing clients c continuing clients group 3 continuing clients group 4 figure 12 continuing clients server crash 52 performance vs segmentation experiment examined performance video server different segmentations segment refers continuous sequence video blocks assumed video objects divided several segments equal size segments placed disk servers way adjacent segments placed different disk servers otherwise multiple segments merged one large segment single server video segments placed servers manner proportional size disk storage available ie probability video segment placed disk capacity 5 gb 5 times probability segment placed 1 gb disk segment placement scheme two disk servers adjacent segments synchronized seamless display video stream soon segment consumed first server next segment delivered second server without delay second server cannot deliver next segment time clients may experience deterioration quality service show later situation relaxed increase buffer space stream number segments 1 number segments 2 number segments 4 number segments 8 800 1000 1200 1400 1600 1800 2000 2200200600100014001800normal continuing clients without glitch clients system number clients experienced glitch number segments 1 number segments 2 number segments 4 number segments 8 1000 1200 1400 1600 1800 2000 220010305070average interrupt time experienced clients clients system length cycles number continuing clients b average blocked time number segments 1 number segments 2 number segments 4 number segments 8 800 1000 1200 1400 1600 1800 2000 22002060100140180average initial response time clients system response time cycles number segments 1 number segments 2 number segments 4 number segments 8 800 1000 1200 1400 1600 1800 2000 2200300500700900number updates executed clients system number updates executed c average initial waiting time number updates executed figure 13 experiment results figure 13a shows many streams experience intermediate stream delay due server switches retrieval adjacent segments video objects stored entirety need server switches ongoing streams number segments movie increased number clients experiencing intermediate delays due server switch increases figure 13b examined average intermediate stream delay experienced clients shows video objects segmented average stream delay decreases number segments increases due fact smaller segments clients stay server shorter time larger segments shorter stays servers resource availability disk servers become flexible therefore server switching done easily frequently figure 13a 13b might conclude storing video objects entirety one disk server best scheme two criteria show scheme disadvantages well figure 13c shows server response time specifying long client waited till first frame video object displayed moderate large number clients system system response time increases sharply number segments decreases also number updates done simulation increases number segments increases figure 13d shows many update requests done simulation furthermore mentioned earlier intermediate stream delays due server switches compensated certain degree increase buffer space streams figure 13b average stream delay less cycles total number clients 1800 therefore increase buffer space streams number clients experiencing actual intermediate display delay reduced 6 conclusions though extensive work handling disk crashes work occurred area recovery data crashed disk likewise though extensive work developing systems support handling vcrlike functions video servers work ignored two possibilities 1 operation video server updates might occur problem handling updates adequately addressed literature 2 similarly operation video server one servers might crash andor otherwise become inaccessible means clients currently served servers must satisfied way date formal theoretical work extending vod servers handle possibility primary aim paper provide formal model vod systems capable handling events well provide vsuc algorithm neatly handle variations resource availability may arise consequence events particular vsuc algorithm many nice properties knowledge proposed first time ffl first vsuc algorithm guarantees certain reasonable conditions users vod server already made commitments experience disruption jitter service long watch movie normal mode ffl second vsuc algorithm guarantees certain reasonable restrictions request made continuing client denied service forever ie eventually handled ffl third vsuc algorithm reacts user events system events polynomial time acknowledgements work supported army research office grants daah049510174 daah 049610297 arparome labs contract f3060293c0241 arpa order nr a716 army research laboratory cooperative agreement daal019620002 federated laboratory atirp consortium nsf young investigator award iri9357756 grateful dr b prabhakaran careful reading manuscript making many useful comments critiques r staggered striping multimedia information sys tems fault tolerant design multimedia servers eventbased model continuous media data heterogeneous disk servers support fully interactive playout disk arraybased video server generalized interval caching policy mixed interactive long video workloads toward workload characterization video server digital library application distributed hierarchical storage manager videoon demand system multimedia repositories issues design storage server videoondemand case redundant arrays inexpensive disks introduction disk drive modeling disk striping distributed design performance tradeoffs clustered video servers designing ondemand multimedia service optimizing placement multimedia objects disk arrays scheduling algorithms modern disk drives tr
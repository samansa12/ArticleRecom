example deriving performance properties visual representation program execution abstractthrough geometry program visualization yield performance properties derive possible synchronization sequences durations blocking concurrent execution two process programs visualization mapping processes synchronization program execution cartesian graph axes line segments paths respectively relationships petri nets drawn b introduction systems visualize execution history collected program help explain happens program execution eg 4 10 13 15 visualization systems lend insight supported part national science foundation grant ncr9211342 performance measure program execution time mean waiting time resource particular value answer helps identify change program improve measure visualization use beyond providing images computer monitor one formally deduce properties program execution visualization first demonstrated roman cox 19 deduced correctness properties roman cox illustrate safety properties properties hold computation states invariants progress properties properties hold particular program state verified defining mapping program states visual representation observing whether sequence visual images corresponding execution sequence satisfies desired property discuss ability render invariant properties program state stable visual patterns render progress properties evolving visual patterns paper provides second example deducing following performance properties visualization class concurrent programs q1 sequence synchronization points program blocks q2 blocking duration synchronization point q3 duration concurrent execution synchronization points class consists program meets following assumptions program contains two processes a1 process executes dedicated processor a2 process blocks synchronization operations a3 synchronization operation process defined terms code segment c process b reaches synchronization operation block b executing c process represented branchless directed graph vertices represent code segments edges always represent precedence relations may represent synchronization operations a4 process optionally block moving one vertex another edge corresponds synchronization operation execution time code segment corresponding vertex independent constant exclusive time spent blocked a5 process initial vertex process starts execution optionally final vertex process terminates a6 process without final vertex never terminates argue next assumptions reasonable consider two process assumption a1 initial solutions classic parallel programming problems shared memory mutual exclusion algorithms initially solved two processes one important performance evaluation tool queueing networks started ability solve one kind queue mm1 isolation principle analysis presented extended two arbitrary number processes see conclusions x7 discussion regarding constant time assumption a5 adve vernon 5 conclude based seven parallel applications appears reasonable ignore variability execution times estimating synchronization delays exponential task time assumption could actually lead severe errors constanttime assumption relaxing assumption a2 multiprogramming modeled past work uses visualization underlying work incorporated model presented branchless assumption a4 restrictive might first appear loops whose number iterations known unrolled obtain branchless graph analysis includes nonterminating programs a6 certain long running programs repeatedly execute code simulations reactive programs programs react external stimuli ongoing basis operating systems solution method represents program execution timed progress graph tpg knowledge tpgs originally used operations research find minimum length schedules two jobs share set machines 20 pp 262263 however good necessarily minimal schedule found eye rather formal method later simplified form tpg called untimed progress graph utp delay timed transition diagram unity used analyze deadlocks 1 carson reynolds 7 define upg multidimensional cartesian graph progress set concurrent processes measured along independent time axis point graph represents set process times kung lipski papadimitriou soisalonsoininen yannakakis wood 11 17 22 24 used upgs detect deadlocks lockbased transaction systems recently carson reynolds used upgs prove liveness properties programs arbitrary number containing p v operations semaphores unconditionally executed use tpgs analyze program performance properties novel tpgs map progress process one cartesian graph axis line segments represent interprocess synchronization directed continuous path cross segment represents particular execution program path may found computational geometric algorithms compute line segment intersections ray shooting remainder paper organized follows first define tpgs illustrate use sample programs x2 representation execution program formalized x3 x4 presents algorithm solve problems listed earlier consider x5 special class programs displays periodic behavior present algorithm solve set possible periodic state sequences arise execution program x6 relates tpgs petri nets finally x7 contains conclusions timed progress graphs first illustrate approach solving quantities q1 q3 x1 three programs apparently tpgs reinvented computer science field attributed dijkstra 8 process producer process consumer x true true read x disk receive x consumer send x consumer write x disk od figure 1 nonterminating producerconsumer program one buffer nonterminating producerconsumer figure 1 contains producerconsumer program use one message buffer interprocess communication thus producer sends message fills single buffer thus must wait consumer executes receive performing next send figure 2 contains equivalent graph representation program satisfies assumptions a1 a6 deterministic execution time graph vertex excluding time spent blocked shown square braces edge conditions b1 b2 represent blocking may occur send receive respectively simplicity presentation assume process blocks end send receive operation condition straightforward relax recall a3 specifying synchronization operation requires identifying code segment c process may block therefore fig 2 conditions b1 b2 following b1 producer never blocks performs first send furthermore producer blocks performs nth send n 1 consumer yet executed 1st receive b2 consumer cannot execute nth n receive producer executed nth send recall tpg maps progress process one cartesian graph axis result fig 1 shown fig 3 sequence graph vertices process passes mapped sequence intervals denoted grey lines fig 3a along corresponding axis interval widths correspond execution time vertices synchronization processes represented read x disk send x consumer receive x consumer write x disk receive x consumer producer consumer figure 2 graph model corresponding fig 1 numbers square brackets refer time spent code segment labels edges denote conditions blocking occurs thick circles represent initial vertices final vertices fig 3b horizontal vertical line segments plane placed appropriate boundaries vertex intervals prohibit transition vertex line segments called constraint lines closed end point closest origin open end point line segment corresponds blocking condition graph consider b1 fig 2 fig 3a producer makes first transition read send vertex back time 4 second time 8 nth time 4n absence blocking similarly consumer completes first receive time 1 second time 3 third time 5 nth time 2n gamma 1 therefore b1 producer block time 4n n 1 consumer completed 1st receive corresponding points exceed coordinate axis representing consumer thus producer block point x meeting following two conditions corresponding vertical lines fig 3b similarly b2 consumer block tries complete nth receive time producer yet completed nth send time 4n thus consumer block point x meeting following two conditions corresponding horizontal lines fig 3b given initial point execution program represented point directed path 1st receive 2nd receive 1st write 3rd receive 2nd write 1st read send 2nd read send 3rd read send mapping states tpg producer consumer15 c mapping program execution tpg consumer b mapping synchronization tpg consumer15 figure 3 representation onebuffer producerconsumer program fig 2 tpg plane called timed execution trajectory tet initial point 00 processes start simultaneously tet point initial point represents deadlocked state otherwise tet path consists possibly infinite sequence rays slope 0 1 1 ray slope 0 respectively 1 process corresponding vertical respectively horizontal axis blocked slope 1 processes running concurrently constraint lines represent forbidden state transitions tet cannot cross constraint line finite portion tet one buffer producerconsumer problem thick directed path fig 3c general method constructing tet given tet construction rule given tpg tet constructed recursively follows let upper case letters optional superscripts ie g g 0 g denote graph points let point g denote ordered pair coordinates two points g g 0 line segment closed g 0 open g 00 satisfies g rule g lies constraint line g 0 g 00 either 1 2 exist point g distinct g 0 g 0 g 00 intersects another constraint line instance case 1 tet rooted g ray initial point g final point g case 2 tet rooted g ray initial point g final point g 00 followed tet rooted g 00 rule ii g lies constraint line slope one ray rooted g either 1 2 intersect constraint line case 1 tet rooted g slope one ray initial point g final point g 0 g 0 point ray lies constraint line followed set tets rooted g 0 case 2 tet rooted g infinite length slope one ray rooted g example 1 consider tet portion fig 3c point lies constraint line follows rule ii case 1 thus tet ray 0 0 1 1 followed tet rooted 11 next lies horizontal constraint line 0 1 4 1 rule case 2 second tet ray must 1 1 4 1 next rule ii case 1 applies third tet ray must g g 0 process continued forever yield infinite length tet 2 tet fig 3c yields three performance properties q1 q3 sought opening paragraphs paper sequence synchronization points q1 corresponds sequence horizontal vertical rays arising tet tet fig 3c contains horizontal rays thus program never blocks producer executes send blocking duration receive q2 length horizontal ray tet fig 3c 3 time units first receive first horizontal ray 1 1 4 1 2 time units subsequence receive finally duration concurrent execution synchronization points q3 length perpendicular projection diagonal ray tet either axis fig 3c 1 time unit program starts process first blocks first diagonal ray 0 1 1 1 2 time units subsequence receive 22 program 2 nonterminating mutual exclusion figure 4 contains different form synchronization last program two database transactions update record serially reusable resource mutually exclusive fashion using two semaphores one needed use two illustrate several concepts equivalent graph model shown fig 5 blocking occur edges vertex representing code segment p semaphore operation performed blocking condition process cannot complete p operation process code segment completion p operation v operation semaphore code segments label edges fig 5 correspond c a4 x1 corresponding tpg fig 6 shows heavy lines set tets could arise two initial points suppose process 1 runs 55 time units process 0 starts corresponds initial point 055 tet consists single slope one ray infinite length rule ii case 2 therefore processes forever execute without blocking suppose process 0 starts execution 2 time units process 1 two possible tets rooted initial point 20 tets contain first ray 2 0 3 1 representing concurrent execution processes one time unit final point ray 31 represents program state processes simultaneous attempt perform pb semaphore ab semaphore1 process 0 process 1 true true input input output output od figure 4 nonterminating database transactions using semaphores serially reusable resource operation two possible outcomes corresponding process first completes pb thus point 31 represents nondeterministic program state process 1 first completes pb process 0 blocks second tet ray vertical 3 1 3 3 tet final point 33 representing deadlock deadlock arises process 1 attempts blocks process 0 already holds semaphore alternate tet initial point 20 second ray 3 1 6 1 process 1 blocks 3 time units followed third ray slope one initial point 61 infinite length thus process starts 2 time units process 0 program either reaches deadlock process 0 blocks units processes run forever without blocking upgs used extensively analysis deadlocks 7 11 17 22 24 deadlocks considered paper 23 program 3 terminating program fig 7 unlike previous two programs contains terminating program producer process reads disk file whose first record specifies number successive records sends records consumer writes records another disk file simplify presentation input output process 0 input output process 1 figure 5 graph model corresponding fig 4 process 1 input output input output figure timed progress graph corresponding fig 5 constant size2 integer0size process producer process consumer numrecords read numrecords disk true i1 numrecords character x read x disk yak od figure 7 terminating producerconsumer code shared memory interprocess communication consumer nonterminating assume interprocess communication implemented mutually exclusive access shared memory using array size elements corresponding graph fig 8 obtained unrolling loops two processes corresponding tpg fig 9 numrecords6 unlike preceding tpgs bounded four sides two ie left bottom axes two additional bounds called right top bounding lines equations producer consumer respectively times 25 31 fig 7 combines synchronization preceding two examples tpg fig combines two forms constraint lines preceding tpg figures tets shown represent possible executions producer consumer start simultaneously note tets finite length final point point 2531 producer terminates sending six records consumer blocks forever pfull receiving six records read numrecords read x pempty 15 producer consumer read x pempty 15 bp1 nth nsize transition never blocks nth sizennumrecords transition blocks consumer yet executed nsize transitions vertex vempty bc1 nth transition blocks producer yet executed nth transition vertex vfull figure 8 graph model corresponding fig 7 thick circles denote initial final vertices learn tpg first synchronization point encountered consumer performs pfull point 11 next synchronization point occurs producer consumer simultaneously attempt respectively third second access shared buffer pool point 117 time race condition occurs producer obtains semaphore first thus tet contains ray 11 7 125 7 remainder execution consumer never blocks producer repeatedly synchronize briefly pempty operation hand consumer obtains semaphore first thus tet contains ray 11 7 11 8 processes encounter race condition followed producer consumer write write write write write write figure 9 timed progress graph corresponding fig 8 numrecords6 two possible outcomes tets contain part final ray 25 25 25 31 represents consumer removing final buffer producer terminated 24 problem statement preceding examples demonstrate quantities q1 q3 x1 computed solving problem p1 p2 added illustrate state reachability analysis tpgs p1 given tpg find set possible tets rooted initial point p2 given tpg determine exists process starting times correspond point leading exactly one tet process ever blocks eg tet rooted 055 fig 6 furthermore exists times output example 3 construction tet presenting algorithms solving p1 p2 formally define tpg rule construct possible tets let r z denote respectively nonnegative reals integers 31 formal definition tpg definition tpg graph representation program ordered pair h g c nonempty set constraint line segments positive r 2 plane g c initial point r 2 representing earliest instance processes started execution example consider tpg fig 3b let v denote vertical lines f8 zg horizontal lines zg tpg h v h 0 0i terminating programs also contains right top bounding lines eg fig 9 32 transition function f formalize rules ii x21 tpg h g c define two functions f respectively subscript f denotes ray orthogonal axes f denotes ray diagonal slope one defining f f requires notation continuous path fl point g fl write g 2 fl directed continuous path fl write fli respectively flf denote initial final point assume fli 6 flf two continuous paths fl fl 0 r 2 g relation lies line ray l line ray g 1 1 slope one infinite length lies constraint line instance l g smallest lf points greater g l intersects another constraint line instance formally min 1 lies constraint line instance g smallest 1 1 set points slope one ray rooted g intersects constraint line instance formally functions f maps point g possibly empty set successors fg r 2 point nondeterministic iff transition point unique eg 31 fig 6 example representing states processes simultaneously perform p operation semaphore points deterministic point dead iff transition point eg 33 fig 6 representing states processes blocked dead point may represent either program deadlock program termination definition point g nondeterministic iff jjf gjj 1 dead iff 33 constructing tet tet point directed continuous path consisting sequence horizontal diagonal rays may multiple tets rooted initial point following definition tet also provides rule construct tet formalizes recursion rules ii x2 timed execution trajectory tet tpg h g 0 rooted point g 0 2 r 2 either 1 point g 0 2 directed continuous path rooted g 0 case 1 holds iff case 2 holds iff path ray sequence g may case 2 n finite iff fg n example 2 fig 3c first line segment tet rooted initial point g 1g 00 lie constraint line instance slope one ray rooted point 00 first intersects constraint line instance point 11 next f1 1g thus second tet line segment 1 continuing manner yields 0 0 1 1 possible tet second example consider g fig 6 fg however 31 nondeterministic thus fg 1 1g continuing like yields two possible tets 2 0 3 1 3 1 3 3 2 0 3 1 3 1 6 1 6 1 1 1 2 section contains algorithms solve p1 p2 x24 terminating programs 41 computing function f essential solving p1 p2 method computing transition function f tpg h g c definition computation fg point g r 2 requires computing either f lies line f g otherwise computation f f discussed computation f computation f line l straightforward using relation 1 x32 1 requires computation set points intersection line li lf lines precompute fg 0 reduces computation evaluation f g evaluating minimization function 1 precomputing set equivalent well known computational geometric problem computing intersections collection horizontal vertical lines eg see 21 ch 27 thus computation f considered computation f g recall f g smallest 1 1 point slope one ray rooted g intersects constraint line instance well known problem ray shooting line segments 6 pp 234247 used find f g given point direction finite set line segments plane find first line segment intersected ray rooted point given direction typical ray shooting solution first stores line segments data structure subsequent queries consisting point direction answered sublinear time let shootraypoint p direction set line l denote ray shooting algorithm whose parameters point p direction either ray directed away toward axes respectively set l containing finite number line segments return value point intersection 1 1 ray intersect line segment formally f 42 problem p1 finding possible tets problem p1 given tpg h gi output representation tets rooted g definition tet along aforementioned methods compute f f solve p1 however one technical problem fg set contains either one deterministic two nondeterministic g points fg contains two points least two possible tets rooted g say least two point one tets rooted g contains point distinct g nondeterministic two tets rooted g therefore solution p1 requires calculating set tets proposed algorithm constructs directed graph set possible tets rooted g simply point g graph contains one vertex labeled g otherwise graph contains one vertex ray end point possible tets rooted g graph colored green representing unexplored vertices remaining vertices colored red findalltets terminating programs initialize graph contain one vertex representing g colored green following step repeated green vertices select green vertex g 0 graph color g 0 red vertex g 00 2 fg 0 add arc g 0 g 00 color g 00 green example 3 fig 9 graph consists vertex point 00 outgoing arc vertex point 11 arc 11 vertex 51 arc 51 117 two outgoing arcs 117 1257 118 graph paths leading vertex point 2531 vertex 2531 outgoing arc 2 43 problem p2 deciding existence nonblocking tets restate p2 using following definition tet nonblocking tet contains points representing state process blocked geometrically diagonal ray rooted point leads nonblocking tet never intersects constraint line final point lies top right bounding line problem p2 equivalent given constraint line set tpg determine exists initial point x axis leads exactly one tet tet nonblocking output tet algorithm findfreepoints let l set containing lines left 0 0 0 1 bottom 0 0 1 0 set g shootraylf gamma l exists line l g 2 f left bottomg g 0 shootraylf l lies top right bounding line return g g 0 otherwise report nonblocking tets exist r figure 10 tpg containing infinite number tets 5 case 2 nonterminating programs preceding algorithms cannot used nonterminating programs two reasons first tpg terminating programs rectangle four finite length sides tpg nonterminating programs extends infinity cartesian quadrant axes positive unbounded nature tpg means tet infinite length unless execution reaches deadlock second may infinite set tets rooted point plane fig 10 occurs program timings state represented point tet program eventually reach another race condition nonterminating programs whose synchronization mutually exclusive resource access eg x22 permit simple characterization exhibit periodic behavior grey lines fig 6 partition plane set equalsize rectangles location rectangle sides plane correspond initiation new infinite loop iterations process rectangle called quadrant formally defining quadrant requires notion process cycle time let r 2 f0 1g denote one two processes denote process ie vice versa cycle time process r denoted oe r time required process r pass vertex infinite loop graph representation ignoring time spent blocked thus fig 5 oe quadrant region fg g initial quadrant quadrant containing origin example 4 initial quadrant fig 6 opposite vertices 00 1111 quadrant opposite vertices significance quadrants constraint lines quadrants congruent definition point g 0 congruent denoted g j g 0 iff line segments congruent end points congruent fact placement constraint lines quadrants congruent two impli cations first sufficient analyze one quadrant plane derive set possible tets modification algorithms preceding section follows sec ond tet containing deterministic points consist transient portion followed infinite number repetitions congruent subtrajectories representing periodic behavior see theorem 1 3 repeated subtrajectory called limit cycle execution trajectory lcet example 5 fig 11 oe 3 tet subpath rooted point 3 2 fig 11 consists infinite number repetitions following lcet horizontal ray length 2 diagonal ray whose projected length either axis 3 transient tet portion subpath initial point 00 final point 32 instances lcet tet congruent example two instances 3 2 5 2 5 2 8 5 13 8 15 8 10 two congruent first second rays first subtrajectory congruent first second rays second subtrajectory respectively 2 figure timed progress graph nonterminating program uses one semaphore lcets motivate one problem addition p1 p2 x24 solved section p3 find set possible lcets tpg reachable initial point special case tpg definition tpg nonterminating program synchronizing mutually exclusive resource access ordered triple hphi g c specifying process cycle times constraint lines initial quadrant point representing initial program state phi ordered pair cycle times oe 0 oe 1 satisfying oe set constraint line generators line segments w x lie initial quadrant corresponding one edge graph model labeled nonempty condition initial final points generator w x w x respectively instances generator defined lines r 2 plane congruent generator formally instances generators def lambdag initial point satisfying lies either x axis within one cycle time origin tet construction rules ii definition transition function f given earlier x21 x32 respectively apply unaltered tpg hphi g c example 6 figure 11 illustrates finite portion tpg hfoe practical consideration henceforth assume execution time vertex graph representing program eg numbers square brackets figs 2 5 8 integer rather real number otherwise computational geometric algorithms presented work correctly finite precision arithmetic eg computation mod operation subject roundoff error assumption integer delays unreasonable practice software performance evaluation example measurements computer microsecond period clock measured times rational numbers form x therefore scaling measurements inverse clock period eg yields integer quantities required proposed algorithms 51 modified algorithms compute computing f recall x32 point g constraint line l f g smallest point g 0 g set containing final point l points intersection l constraint lines hphi g c contains constraint lines initial quadrant map g congruent point initial quadrant ie modg compute described x41 finally map g 0 2 f back quadrant containing g formally compute f oe r g computing f g method compute f g given x41 must modified nonterminating tpg infinite number constraint lines plane therefore figure 12 illustration using shootray within initial quadrant f g compute f using initial quadrant use observation diagonal ray fl tet partitioned collinear rays initial points lie quadrant boundary fact provides algorithm compute f ray initial quadrant compute right initial quadrant edgesg translate g 0 back fl k quadrant obtain fl k1 see 1 complete algorithm example 7 fig 11 f 5 fig 12 shows two shootray operations required compute f g ray 5 2 8 5 lies exactly two quadrants 52 p1 finding possible tets recall problem p1 given tpg hphi gi output representation tets rooted g stating solution two implications nonterminating programs must considered tet may infinite length may infinite number tets recall fig 10 former case infinite length tet tet must consist transient subtrajectory followed infinite number repetitions lcet therefore algorithm output representation transient trajectory first lcet later case infinite number tets choose integer value maxnpaths algorithm finds maxnpaths possible tets assumes infinite number tets terminates without exploration generalize algorithm findalltets x42 solve p1 nonterminating programs algorithm findalltets nonterminating programs 1 initialize graph contain one green vertex labeled g set npaths1 2 set g vertex color g 0 red increment npaths jjf g 0 jj gamma 1 3 point g 00 fg 0 create vertex labeled g 00 add directed edge g 0 g 00 g 00 congruent point p labeling vertex graph path g g 00 add arc g 00 p color vertex g 00 red otherwise color green 4 graph contains green vertex npaths maxnpaths go step 2 otherwise output graph path rooted g label paths containing cycle transient followed lcet label remaining paths transient example 8 graph constructed findalltets tpg fig 11 consists edge graph vertex labeled 00 vertex labeled 22 edge 22 52 52 85 85 back 52 fact graph contains one path one cycle means processes simultaneously start execution ie program starts state represented 00 must reach periodic state sequence process 0 blocks two time units processes run concurrently three time units 2 53 problem p2 deciding existence nonblocking tets recall problem p2 given phi tpg determine exists initial point x axis leads exactly one tet tet nonblocking output tet program termination makes one minor difference algorithm given earlier freepoints x 43 change lies top right bounding line equals 1 1 return g g 0 return g 1 1 54 problem p3 find possible lcets restate p3 categorizing lcets blocking nonblocking blocking lcet contains point representing state process blocked geometrically blocking lcet contains horizontal vertical ray nonblocking lcet consists single diagonal ray two tets homotopic continuously transformable avoiding constraint lines term due lipski papadimitriou 11 paths upgs example tets rooted points fg fig 6 consist one diagonal ray homotopic problem p3 given phi tpg output one element equivalence class blocking lcets one element set homotopic lcets algorithm findnonblockinglcets finds nonblocking lcets initialize l find freepoints x43 set l 2 shootraylf nonblocking lcets otherwise point g output g g oe nonblocking lcet consider next finding blocking lcets key insight set tets contains rays intersect given constraint line instance denoted l also contain common point lies l either dead point case point final point tets lf later case set must either lcet reach dead state lies another constraint line instance reach lcet therefore necessary consider tet rooted lf determine contains another point congruent lf lemma 1 makes precise lemma 1 set possibly unreachable blocking lcets found finding l 2 proof see theorems 3 4 2 2 let denote set lcets satisfying lemma 1 determine lcets reachable calculating line l lcet shootraylf gamma l l line set algorithm findfreepoints return value shootray lies bottom left edge initial quadrant lcet containing l reachable therefore propose solution p3 exhaustive testing l evaluating f lf described x51 6 relation tpgs petri nets figures 13a 13b petri net 16 representations figs 1 4 respectively producerconsumer program figure 13a petri net class called deterministic systems synchronizing processes dssp 18 shaded place denotes buffer shared two processes database transaction program fig 13b however class dssp violates rule place representing buffer input one process fig 13b places representing semaphores buffers inputs processes fig 13b simple asymmetric choice net ie arc weights one two places share output transition set output transitions one place either equal subset output transitions place 16 p 554 therefore class programs meeting assumptions a1 a6 dssp restricted two linear processes 23 generalized omit privatebuffer assumption ie definition 27ii 18 magott 12 gives algorithm compute minimum cycle time mct minimum time required consistent petri net return initial marking given deterministic firing times nets consisting set n cyclic processes mutually exclusively share single b output output process 1 read send receive write process 0 process 0 process 1 figure 13 petri net representations figs 1 4 resource shows finding mct nets complex resource sharing np hard also proved complexity results systems processes communication buffers finally holliday vernon 9 use petri nets frequency expressions ie probabilities resolve deterministically transition fires token enables two transitions simultaneously analyze program similar fig 4 tpg solution provides fourth analysis method one petri net class addition cov erability trees matrixequations decomposition techniques certain behavioral properties ie p1 enumerate possible transition firing sequences given initial marking certain structural properties ie p2 p3 conclusions analyzed two building blocks interprocess synchronization mutual exclusion asynchronous communication finite number buffers paper demonstrates properties set possible executions certain parallel programs exactly analyzed solving equivalent computational geometric problem analysis limited two processes extension processes requires ray shooting dimensional cartesian graph dimensional hyperplanes nonsimple arrangement bounded one dimension knowledge open computational geometric problem whose solution would allow solution problems p1 p2 arbitrary number processes closest problem solved dimensions ray shooting unbounded hyperplanes form simple arrangement eg see 14 one limitation dimensions progress graph represents contention multiple processes resource nondeterministic choice process gets resource represent different queueing disciplines broader implication work two open questions program visualizations mapped geometric problems geometry used analyze petri net classes acknowledgments allison l heath kafura mathur tripathi anonymous referees made suggestions improved manuscript c shaffer helped locate computational geometric algorithms r computational geometric performance analysis limit cycles timed transition systems geometric performance analysis semaphore programs geometric performance analysis periodic behavior visual analysis parallel distributed programs time influence random delays parallel execution times intersection decomposition algorithms planar arrangements geometry semaphore programs system deadlocks generalized timed petri net model performance analysis visualizing performance debugging fast algorithm testing safety detecting deadlocks locked transaction systems performance evaluation systems cyclic processes mutual exclusion using petri nets jed event display vertical ray shooting hyperplanes petri nets properties concurrency control locking deterministic buffer synchronization sequential systems declarative approach visualizing concurrent computations operations research methods problems algorithms c optimal algorithm testing safety detecting deadlocks locked transaction system deterministic systems sequential processes theory tools locking policies safety freedom deadlock tr
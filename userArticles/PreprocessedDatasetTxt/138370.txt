vectorized software bessel function evaluation suite computer programs evaluation bessel functions modified bessel functions orders zero one vector real arguments described distinguishing characteristics programs portable across wide range machines b vectorized case multiple function evaluations performed performance new programs compared software fnlib collection fullerton new software based b introduction bessel functions real argument integer order among commonly occurring special functions applied mathematics software libraries contain routines evaluation one successful collections routines evaluating special functions fnlib package developed wayne fullerton los paper appeared acm transactions mathematical software volume 4 pp 456469 contribution national institute standards technology nist subject copyright united states identification commercial products paper imply recommendation endorsement nist authors addresses computing applied mathematics laboratory national institute standards technology gaithersburg md 20899 electronic mail boisvertcamnistgov saun derscamnistgov respectively alamos national laboratories late 1970s 10 one important features fnlib portability parameterized port machine constants 9 fnlib codes regularly used machines ibm pcs cray ymps versions codes found way several wellknown libraries imsl sfunlibrary 11 slatec common math library 2 also available netlib 7 recently increased attention paid development algorithms software take advantage vector processors machines example special versions many standard fortran math functions available compiler vectorize loops following ability vectorize loops crucial many applications paper describe set fortrancallable subprograms extend functionality bessel functions done producing modified versions fnlib routines besi0 besi1 besj0 besj1 besk0 besk1 besy0 besy1 well double precision versions new routines maintain portability fnlib advantage vectorizable cases multiple function evaluations required section 2 review basic design fnlib routines section 3 discuss various issues involved vectorization algorithms followed short description user interface implementation section 4 finally section 5 describe testing new software evaluate performance various scalar vector processors 2 design fnlib fnlib substantial collection software including 200 fortran subprograms double precision versions available codes primary design criteria development package portability maintainability cases criteria speed accuracy relaxed slightly order maximize primary criteria 10 example fnlib routines rarely accurate last bit although almost always accurate within factor 10 times machine precision certainly sufficient vast majority applications fact routines remained popular 10 years trivially ported many machines exist initially developed attests success basic design fnlib based upon approximation truncated chebyshev series expansions 8 approximations many wellknown properties widely applicable nearly best minimax sense error easy estimate provide variable accuracy approximations stable evaluate conventional polynomials properties approximations basis many algorithms evaluation special functions basic formula construction routines fnlib paraphrase 10 follows recipe constructing fnlib routines 1 store chebyshev coefficients statements coefficients required chebyshev expansions accurate 16 digits stored single precision routines 31 digits double precision routines range ensures sufficient accuracy computers 2 initialize done first call routine calculate legal argument bounds illegal argument regions function undefined result would overflow underflow range reduction cannot performed accurately enough port machine constants used determine bounds applicable current machine b determine correct number expansion coefficients error committed truncating chebyshev series bounded sum absolute values discarded coefficients one use estimate error committed using fewer fewer terms way length series selected match precision machine 3 check input argument validity function argument compared bounds computed initialization fatal errors warnings provided warnings issued underflowed results example fatal errors issued cases result returned result overflows errors issued using port error handler 9 4 compute approximation basic computation evaluation truncated chebyshev series reasonable single series accurate whole argument range thus argument range broken several subintervals usually three four series appropriate subinterval determined computation proceeds follows preprocess argument argument mapped interval 11 b evaluate chebyshev series done using threeterm linear recurrence due clenshaw 3 c postprocess result series value finally corrected form interval necessary 3 vectorization multiple arguments section describe routines design may extended case evaluation multiple arguments three opportunities improving performance exist 1 reduction subprogram call overhead 2 vectorization pre postprocessing phases 3 vectorization chebyshev series evaluation emphasis paper 2 3 vectorization function evaluation routines multiple arguments seems quite simple first one simply applies scalar algorithm vector arguments un fortunately fails range possible input arguments divided several subintervals handled differently since cannot assume input arguments sorted way core algorithm proceeds follows argument range gather arguments range temporary vector compute approximation arguments vector mode scatter results back resultant vector clearly vector lengths depend upon distribution input arguments general less total number arguments 31 example illustrate transformation consider following statement fnlib routine gt xsml le 30 statement illustrates one particular argument range handled approximation case simply 275 plus chebyshev series sum returned utility csevl biocs array chebyshev series coefficients nti0 number coefficients corresponding vector code complex n gt statement modified slightly original code simplify presentation arguments array function evaluated result returned array f wgtle returns array indx n indices elements vector xsml 3 gathered routine wgthr ycmp 20 loop preprocesses argument array wcs evaluates chebyshev series csevl except vector n arguments stored array tcmp b0 b1 b2 work arrays length loop postprocesses result series evaluation wsctr puts result appropriate positions f preprocessing postprocessing phases trivially vectorizable remainder section investigate vectorization indicated subprograms 32 vectorization multiple chebyshev series evaluation next consider evaluation truncated chebyshev series vectorized first review series evaluated scalar code given argument x set chebyshev coefficients c due clenshaw evaluates recurrence scalar version 1 recurrence series 2 last term result f vector arguments x j clear done x ff fi fl f become vectors assignments loops run done however recurrence loop two unnecessary vector copies eliminated loop unrolled level three illustrated following vector version algorithm note three temporary vectors length required addition input vector x output vector f recurrence vector version 1 recurrence series unrolled 2 last term cleanup n divisible three endif loop repeatedly utilizes four vectors remain vector registers entire computation unrolling loops way yields 20 25 improvement overall performance software cray ymp 33 vectorization utility operations algorithm 2 forms inner loop computation given argument range performed vectors stored contiguously memory quite desirable since reduces possibility bank conflicts memory references however arguments corresponding given range need lie contiguously input vector thus argument range must gather together applicable arguments contiguous vector compute required function value scatter back appropriate locations output vector datahandling operations necessary things significant terms operation counts lead significant performance degradation properly vectorized unfortunately operations among likely thwart vectorizing compiler none vectorized cyber 205 compiler example wish implement code standard fortran permit easy customization cases code inefficient facilitate encapsulated operations subprograms replaced efficient versions available next describe utilities detail case implementation quite straightfor ward although vectorized compilers convex c120 cray ymp efficient implementation utilities necessarily systemdependent see 5 example discussion gather scatter isolated loops subprograms wgtmxanindx wlemxbnindx wgtlemxabnindx corresponding operations 1 2 3 respectively gatherscatter result index compression array indices j gather operation collects elements vector x j indices contiguous vector scatter inverse x placed simple gather scatter loops subprograms wgthrnxindxy wsctrnyindxx respectively outofrange tests apply algorithm must determine whether element input vector range ie greater less given scalar would like provide index first occurence diagnostic one attempts combine operations single loop one gets something general vectorizable eg ifxj gt go 25 instead first check error condition using simpler vectorizable loop eg ifxj gt table 1 usercallable vfnlib subprograms single double description single double vi0 dvi0 evaluates 0 vector arguments besi0 dbesi0 vi1 dvi1 evaluates 1 vector arguments besi1 dbesi1 vj0 dvj0 evaluates j 0 vector arguments besj0 dbesj0 vj1 dvj1 evaluates j 1 vector arguments besj1 dbesj1 vk0 dvk0 evaluates k 0 vector arguments besk0 dbesk0 vk1 dvk1 evaluates k 1 vector arguments besk1 dbesk1 vy0 dvy0 evaluates 0 vector arguments besy0 dbesy0 vy1 dvy1 evaluates 1 vector arguments besy1 dbesy1 key0 done otherwise compute first index loop like one numbered 20 way slow loop executed immediate error return follow operations represented subprograms wngtmxakey vectorized software using techniques described section produced portable vectorized routines evaluating following bessel functions real argument orders zero one codes employ basic algorithms fnlib retooled vector environment called collection codes vfnlib although produced new usercallable versions small portion original fnlib techniques used readily applied many fnlib routines vfnlib includes usercallable fortran subprograms listed table 1 identical calling sequence call name x f work iwork info x array containing arguments function evaluated results returned corresponding positions array f work iwork workspace arrays iwork length work length 7m info return code single precision double precision versions subprogram provided routines actually drivers partition work arrays call lowerlevel routines perform actual computations list subsidiary routines included vfnlib given table 2 coding standard fortran 77 elected provide error return code parameter rather issue error messages error handler done fnlib error conditions indicated nonzero return code info fatal errors indicated info 0 warnings argument leads fatal error results returned fatal error table 2 internal vfnlib subprograms single double description single double wi0 dwi0 performs computations dvi0 wi1 dwi1 performs computations dvi1 wj0 dwj0 performs computations dvj0 wj1 dwj1 performs computations dvj1 wk0 dwk0 performs computations dvk0 wk1 dwk1 performs computations dvk1 wy0 dwy0 performs computations dvy0 wy1 dwy1 performs computations dvy1 wcs dwcs evaluates chebyshev series vector arguments csevl dcsevl iwcs idwcs finds number terms needed compute chebyshev series given accuracy inits initds wngt dwngt outofrange test x j wnle dwnle outofrange test x j b wgthr dwgthr vector gather wsctr dwsctr vector scatter wferr processes fatal error message seteru i1mach i1mach returns integer machine constants 9 i1mach i1mach r1mach d1mach returns real machine constants 9 r1mach d1mach conditions 0 function undefined argument result overflows argument large accurate argument reduction possible last three cases index first offending argument returned iwork1 warning issued result underflows corresponding function value set zero case used separate procedure handle errors detected lowerlevel routines example nterm chebyshev series evaluated n 1 errors caused improper user input never occur normal use routines exception array work short code overwrites data reasonable thing cases issue fatal error message halt program done calling simple errorhandling routine wferr 5 evaluation section evaluate vfnlib respect three criteria accuracy efficiency portability accuracy assessed purely experimental means ie comparison existing software problem set efficiency evaluated series experiments cray ymp convex c120 sun sparcstation 1 finally portability verified successfully porting codes systems using appropriate compiler options flagging nonansi constructs 51 portability accuracy since vfnlib represents vectorization subset fnlib first goal assure vfnlib routines return results comparable corresponding fnlib routines test program distributed package compares function fnlib counterpart approximately 23000 arguments verifying two differ five times machine epsilon relative difference used function values greater one absolute difference less one code run three separate computer systems sun sparcstation 1 sun 4 25 mhz weitek 3172based fpu using sun fortran 131 options fast o3 convex c120 convex unix 42 release 90 using convex fc version v61 option o2 cray ymp2216 unicos 60 using cf77 case available options used check conformance ansi x391978 fortran additional testing done verify sets routines indeed producing correct function values ideally function routines return results relative error near machine precision rarely case practice accuracy vfnlib routines assessed evaluating function four five thousand arguments cray ymp fnlib vfnlib comparing results computed extended precision using mathematica 12 cases results returned fnlib vfnlib relative error less 10 times machine epsilon single precision 10 theta 10 gamma28 double precision two notable exceptions behavior occur functions j describe behavior near function zeros cancellation errors evaluation chebyshev series leads loss relative accuracy neighborhood zeros functions except j 1 cases absolute error remains less 10 times machine epsilon problems avoided function routines eg cosine accurately computing nearby zero recasting computation terms present case infinite number zeros apparent period making strategy impractical behavior large arguments large arguments functions computed axgx given chebyshev series g sine cosine since x size x sine cosine large argument must computed x large even one rounding error large magnitude table 3 asymptotic performance chebyshev series evaluation megaflops machine terms scalar vector sun sparc 1 7 18 29 cray ymp2 20 127 1821 cannot represented accurately enough assure result returned axgy small relative error occurs even g computed full machine precision 52 efficiency chief motivation using vfnlib prospect improved computation rates vector processors assess advantage using vfnlib compare use vfn routines vector codes repeated calls corresponding fnlib routines scalar codes compare codes three systems described section 51 sun sparcstation 1 convex c120 cray ymp2 first scalar workstation second vector minisupercomputer third 2processor vector supercomputer although use one processor tests include sun demonstrate portability software well show use vfnlib need degrade performance scalar processors tests performed single precision sun convex machines cray 64bit machine computation innermost loop vectorized codes evaluation chebyshev series using algorithm section 32 table 3 list computation rate megaflops evaluating single chebyshev series 2000 arguments using scalar vector codes subprograms csevl wcs used purpose theoretical peak rate convex cray 40 333 megaflops respectively corresponding linpack benchmark runs 65 90 megaflops 6 light figures observed rate vectorized chebyshev series evaluation convex cray 15 182 respectively seen quite reasonable unfortunately seen computation bessel functions evaluation chebyshev series overhead must paid gathering scattering vector elements well various error checks easy assess effect overhead cray ymp using hardware performance monitor table 4 lists measured asymptotic computation rate megaflops usercallable function obtain data evaluated function 19 different sets 2000 arguments different argument distribution comparing table 3 table 4 see computation rates full bessel function evaluation decline 7 22 percent raw chebyshev series evaluation another measure performance speedup ratio scalar vector times multiple function evaluation actual speedups depend upon distribution arguments compare scalar vector codes vectors length 2000 distributed 19 different table 4 asymptotic performance bessel functions cray ymp megaflops function 0 1 j scalar 90 87 106 104 78 80 91 90 vector 1487 1424 1645 1609 1628 1593 1720 1700 table 5 asymptotic speedups scalar time vector time machine 0 1 j sun sparc 1 min 10 10 11 11 10 10 12 12 ave 11 11 12 12 12 12 13 13 max 12 12 14 12 13 14 16 15 convex c120 min 44 52 55 46 76 73 79 79 ave 58 59 64 56 80 80 84 85 max 65 62 68 60 83 91 93 96 convex c120 min 62 75 66 58 82 91 86 80 veclib ave 79 79 73 66 98 96 92 86 max 88 82 76 70 109 104 103 97 cray ymp2 min 162 153 145 139 208 209 148 149 ave 178 168 160 153 215 216 196 198 ways among three different argument ranges test includes cases arguments single range well cases one per cent arguments given range table 5 lists minimum average maximum speedups observed single precision codes computer speedups convex range 44 96 speedups cray range 139 230 entry labeled convex c120 veclib explained shortly also interesting note vectorized codes run faster scalar codes sun cases speedups one might predict table 3 16 125 143 sun convex cray respectively average speedups cray ymp given table 5 somewhat better contrast speedups convex large predicted investigate generated execution profile subroutine evaluating 0 vector length 2000 x first two columns table 6 show percent time spent cray convex four different activities innermost loop computation chebyshev series evaluation half computation occurs cray however convex half time spent index compression although compiler vectorize index compression loops resulting code perform well one better straightforward fortran implementation operations table percent time spent vi0 various activities activity cray convex convex veclib chebyshev series evaluation 577 228 348 pre post processing 121 102 158 index compression 200 502 202 gatherscatter 52 97 179 table 7 short vector speedups scalar time vector time machine length 0 1 j 20 12 10 10 12 12 12 11 12 20 18 18 18 16 22 23 20 22 cray convex however convex veclib library 4 contains fortrancallable utilities optimize performance index compression gatherscatter operations since careful implementation isolate operations lowlevel utilities easily replace badly vectorized loops calls veclib done entries third column table 6 obtained reasonable distribution although gatherscatter operations still occupy significantly larger percentage time cray using modified version vfnlibs utilities convex leads improved scalarvector speedups labeled convex c120 veclib table 5 tests performed thus far assess performance codes long vectors also important assess penalty using vectorized codes vector lengths short table 7 lists sample speedups function three machines vectors length 2 20 arguments tests distributed two argument subranges internal vector lengths actually half listed table one would expect vector codes run slower case function values requested vector length 2 vector code runs twice long sun cray five times long convex table 8 lists vector length speedup 1 ie breakeven point vector codes faster breakeven point range 45 cray 711 convex 714 sun table 8 short vector breakeven point vector machine 0 1 j sun sparc 1 12 cray 6 conclusion described suite portable fortran subprograms vfnlib computing bessel functions real argument integer order codes modification routines fullertons wellknown fnlib package new routines allow users specify array arguments evaluate functions algorithms changed allow effective vectorization case speedups 13 22 use original fnlib observed vfnlib codes cray ymp modest speedups also observed sun sparcstation 1 scalar workstation vectorization techniques employed vfnlib extend many fnlib routines r handbook mathematical functions formulas slatec common mathematical library note summation chebyshev series convex computer corporation algorithm 692 model implementation test package sparse basic linear algebra subprograms performance various computers using standard linear equations software distribution mathematical software via electronic mail chebyshev polynomials numerical analysis algorithm 528 framework portable library portable special function routines imsl inc system mathematics computer tr distribution mathematical software via electronic mail mathematica system mathematics computer algorithm 692 model implementation test package sparse basic linear algebra subprograms algorithm 528 framework portable library z portable special function routines performance various computers using standard linear equations software
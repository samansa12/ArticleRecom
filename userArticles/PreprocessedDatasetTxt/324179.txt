linear hash functions consider set h linear affine transformations two vector spaces finite field f study good h class hash functions namely consider hashing set size n range cardinality n randomly chosen function h look expected size largest hash bucket h universal class hash functions finite field respect measure different fields behave differentlyif finite field f n elements bad set f2 size n expected maximal bucket size hn13 n perfect square even bad set largest bucket size always least n worst possible since respect universal class hash functions every set size n expected largest bucket size n however consider field two elements get much better bounds best previously known upper bound expected size largest bucket class o2 log n reduce upper bound olog n log logn note far guarantee random function average largest bucket would thgrlog n log log nin course proof develop tool may independent interest suppose subset vector space z2 consider random linear mapping smaller vector space r cardinality larger cegrrlogr probability 1 egr image cover elements range b introduction consider distributing n balls buckets randomly independently resulting distribution balls buckets object occupancy theory dep math sackler faculty exact sciences tel aviv university tel aviv israel institute advanced study princeton nj 08540 research supported part usaisraeli bsf grant sloan foundation grant 9662 nec research institute grant hermann minkowski minerva center geometry tel aviv university email nogamathtauacil fakultat fur informatik und automatisierung technische universitat ilmenau postfach 100565 98684 ilmenau germany work done author aliated university dortmund partially supported dfg grant di 41251 email martindietzfelbingertheoinftuilmenaude z brics centre danish national research foundation university aarhus ny munkegade aarhus denmark supported esprit long term research programme eu project number 20244 alcomit email bromillebricsdk part work done author university toronto x ibm haifa research lab matam haifa 31905 israel email erezphaifavnetibmcom work done author visiting university toronto renyi institute hungarian academy sciences pf 127 budapest h1364 hungary partially supported dimacs center grants otka t020914 t030059 fkfp 06071999 email tardoscseltehu part work done author visiting university toronto institute advanced study princeton theory algorithms complexity theory often necessary useful consider putting balls buckets without complete independence precisely following setting studied class h hash functions mapping universe u f1 xed set u hashed given adversary member h 2 h chosen uniformly random hashed using h distribution multiset fhxjx 2 sg studied class h class functions u f1 get classical occupancy problems carter wegman dened class h universal 1s remark stricter denition often used complexity theory literature universal families following properties well known variations used extensively various settings 1 size n hashed n 2 buckets probability 12 collision occurs 2 size 2n 2 hashed n buckets probability 12 every bucket receives element 3 size n hashed n buckets expected size largest bucket less p n 1the intuition behind universal hashing often lose relatively little compared using completely random map note property 1 true strong sense even complete randomness expect 2 buckets suce birthday paradox nothing lost using universal family instead bounds second third properties however rather coarse compared one would get complete randomness property 2 complete randomness n log n balls would suce cover buckets good probability coupon collectors theorem ie polynomial improvement n 2 property 3 complete randomness expect largest bucket size log n log log n ie exponential improvement p n last cases seem lose quite lot compared using completely random map better bounds would seem desirable however rather easy construct unnatural examples universal families sets hashed showing size n 2 necessary cover n buckets nonzero probability buckets size general unavoidable set size n hashed n buckets shows abstract property universality allow stronger statements x concrete universal family hash functions ask following question extent ner occupancy properties completely random maps preserved provide answers questions case linear maps two vector spaces nite eld natural well known class universal sense carter wegmen hash functions general avor results large elds bad sense bounds become worst possible universal families small elds good sense bounds become good almost good ones independently distributed balls precisely covering problem show following easy theorem theorem 1 let f eld size n let h class linear maps f 2 f subset f 2 size jf j 2 h hand prove following harder theorem theorem 2 let subset vector space z 2 choose random linear map smaller vector space r jsj c jrj log jrj probability least 1 image covers entire range r largest bucket problem let us rst introduce notation let u universe keys chosen x class h functions mapping u sg set u size n chosen adversary uniformly random pick hash function using h look size largest resulting hash bucket denote expectation size l n formally sujsjn usually think size close n note universal class yields class h consider set linear maps f f k k f nite eld class universal values parameters expected largest bucket large theorem 3 let f nite eld jf class h linear transformations 13 furthermore jf j perfect square h note close lower bound quadratic elds upper bound holds every universal class also mention bad set construct theorem 8 quadratic eld good linear hash function since always exists bucket size least p eld eld two elements situation completely dierent markowsky carter wegman mcw78 showed case l mv84 improved result although implicit paper showed l o2 log improve bound show theorem 4 class h linear transformations two vector spaces z 2 furthermore also show even range smaller jsj logarithmic factor still holds theorem 5 class h linear transformations two vector spaces z 2 log note even one uses class r functions one obtains slightly better result expected size largest bucket case l log l log log best possible bound class interestingly upper bound based upper bound covering property nontrivial lower bounds l class linear maps z 2 ie might good olog log log leave open question 11 motivation doubt method implementing dictionary hashing chaining recommended textbooks clr90 gby90 especially situations many update operations practically important scheme situations good bound cost single operations important e g realtime applications expected maximal bucket size formed keys ever present dictionary time interval plays crucial role results show least long size hash table determined right start using hash family linear functions z 2 perform well respect simple hash classes bounds worst case bucket size available even fail hold see example section 4 sophisticated hash families s89 dm90 dgmp92 guarantee small maximal bucket sizes consist functions higher evaluation time course worst case constant time certain operations absolutely necessary known twolevel hashing schemes used e g fks scheme fks84 static dictionaries dynamic perfect hashing dkmhrt94 dynamic case constant time lookups expected time n update operations realtime dictionaries dm90 perform operation constant time high probability noted however price paid guaranteed constant lookup time dynamic schemes average cost insertions signicantly higher simple schemes like chained hashing overall storage requirements higher well 12 related work another direction trying show specic class good bound expected size largest bucket build class specically designed good property one immediate result obtained looking class h ddegree polynomials nite elds log n log log n see eg abi86 easy see class maps elements domain independently range thus bound applies class functions also applies class combine following well known construction found eg fks84 sometimes called collapsing universe class c size 2 log nlog log ju containing functions mapping u g set size n randomly chosen map c onetoone probability 1 o1n k class consisting functions obtained rst applying member c member h class l n log log n size 2 olog log ju jlog 2 n log log n evaluation time olog n log log n reasonable model computation say ram unit cost operations members universe hashed ecient much larger families given siegel s89 dietzfelbinger meyer auf der heide dm90 provide families size ju j n functions evaluated o1 time ram l n log log n families s89 dm90 somewhat complex implement class linear maps requires basic bit operations discussed already cw79 therefore desirable study class main purpose present paper 13 notation subset domain function h use hs denote sg x element range use h 1 x denote fs 2 j xg b subsets vector space v x 2 v use notations ag use z 2 denote eld 2 elements logarithms paper base two 2 covering property 21 lower bounds covering large eld prove theorem 1 take set f size ag density around one quarter see note x picked randomly independently f xy x 1y distribution linear see take nonzero linear note 0 2 gs 6 0 ba 2 case 62 gs 22 upper bounds covering small eld existential case start showing subset vector space z 2 jaj suciently larger another space w exists linear transformation mapping entire range constant e base natural logarithm theorem 6 let nite set vectors vector space v arbitrary dimension z 2 let 0 integer jaj t2 log e exists linear maps onto z proof theorem need following simple lemma note although state lemma vector spaces holds nite group lemma 21 let v nite vector space v proof v u chosen uniformly independently random v events u 62 v probability independent 2 proof theorem 6 let dimension v starting choose vector choice v 1 exists lemma 21 procedure choose v 2 note one assume vectors v linearly independent since choosing vector v linearly depends vectors formerly chosen makes g disjoint contradiction jx choose onto linear 2 kernel 1 0 equals w w 2 claimed 2 bound theorem 6 asymptotically tight shown following proposition proposition 22 every large enough integer set least 3 log t2 vectors vector space v z 2 linear map map let chosen random picking element v independently probability set chebyshevs inequality know probability least 34 cardinality least pn 2 pn using p x log e x 2 2 log 2 e one show many claimed proposition let us compute probability exists linear map 2 maps onto z 2 tts possible maps probability 1 1 p 2 2 probability almost 34 small still maps onto z 23 choosing linear map random subsection strengthen theorem 6 prove bigger required constant factor almost choices linear transformation work may seem immediate rst glance since lemma 21 tells us random choice next vector good average particular might seem random choice v 1 v 2 proof theorem 6 unfortunately case example think linear subspace containing half v case ratio points covered 12 random vectors v chosen added vectors chosen probability 12 thus steps remains 12 probability 12 becomes 0 otherwise thus expected value 2 1 much bigger rst lemma technical nature lemma 23 let 1 k random variables let 0 0 1 constant suppose 0 k 0 i1 conditioned set values threshold 0 1 proof proof induction k base case trivial assume statement lemma k prove k 1 let log log1t may suppose c since otherwise bound lemma greater 1 choice 1 rest random variables form random process length k satisfying conditions lemma unless thus apply inductive hypothesis get dene f interval clearly upper bound prob k1 j 1 claim interval 0 x 0 fx f 0 0 x 0 prove simply observe f 0 xx rst increasing decreasing 0 1 see compute derivative 0 still increasing phase suppose 0 already decreasing phase dene x notice assumed 0 x 0 beginning proof f us dene x notice x x 00 easy check x 00 must still increasing phase f 0 xx thus x 00 x 1 simply thus must fxx 1x thus proved claim cases 0 x 0 claim trivial using claim nish proof writing remark bound lemma achievable 0 integer 0 j k optimal process theorem 7 every 0 constant c 0 following holds let nite set vectors vector space v arbitrary dimension z 2 let 0 integer jaj c t2 uniform random linear transformation b subset vector space z u 2 density jaj2 integer uniform random onto linear transformation proof start proving part b theorem order pick onto map use following process similar one proof theorem 6 pick vectors uniformly random vectors z u 2 choose random onto linear 2 constraints v ie vectors v kernel note v necessarily linearly independent necessarily span kernel still transformation indeed distributed uniformly random amongst onto linear maps z u using notations similar ones used proof theorem 6 let nonnegative monotone decreasing equation e guaranteed lemma 21 since independent j j thus conditions lemma 23 satised denition right hand side equal estimate theorem finally note proof theorem 2 since x 2 z sets disjoint sizes 2 u 1 2 u 2 u 2u contradiction thus claimed upper bound probability 6 z turn part theorem prove using part b part random linear transformation necessarily onto dierence claim proved poses less problem diculty priori bound 1 jajjv j fact ratio arbitrarily small solve choose transformation two steps rst step ensuring density covered set substantial applying part b second step first pick uniformly random linear transformation pick random onto linear map 2 set results uniformly chosen linear 2 true even xed onto 1 random 0 since values 0 independent uniformly distributed w thus values e also independent uniformly distributed z pair vectors v 6 w 2 collide due 0 probability probt 0 thus expected number collisions jaj jw j since jt 0 aj jaj2 implies least jaj2 collisions markovs inequality gives probjt 0 aj jaj2 2 jaj xed 0 part b theorem gives case jt 0 aj jaj2 1 jaj2jw using monotonicity bound get choosing c jaj c t2 implies 4 log2 implies bound equation 1 less 2 thus get probt 6 remark careful analysis gives c small polynomial 1 3 largest bucket 31 lower bound largest bucket large eld start showing linear hashing large nite eld bad respect expected largest bucket size measure natural example shows universality class enough assure small buckets nite eld f prove existence bad set f 2 size expected largest bucket respect random linear big prove results theorem 3 separately quadratic nonquadratic elds start intuitive description constructions linear hashing plane collapses straight lines random direction thus bad set plane must contain many points least one line many dierent directions hard come bad sets contain many points many dierent lines however obvious constructions subplane grid yield sets many popular lines tend parallel thus cover directions problem solved projective transformation transformed set many popular lines longer parallel nonquadratic case convenient explicitly use concept projective plane eld f recall projective plane p f dened equivalence relation x ane plane f 2 embedded p onetoone map x 7 x 1 line p given equation projective line corresponds plane f 3 containing origin projective lines extensions one new point lines ane plane f 2 except ideal line given fx 0g projective transformation mapping ideal line another projective line l map obtained quotient nonsingular linear mapping plane corresponding ideal line plane corresponding l projective geometry useful understanding behavior linear hash functions due following fact easily veried picking random nontrivial linear map f 2 f hash function partitioning subset f 2 hash buckets accordingly corresponds exactly picking random point p ideal line partitioning points according line p observation used explicitly proof theorem 9 theorem 8 let f nite eld jf j perfect square exists set f 2 size every linear large bucket ie exists value 2 f jh 1 yj jf j proof nite eld f 0 f quadratic extension let jf arbitrary element f n f 0 dene g note also image subplane f 2 0 projective transformation x 7 1 fix f consider function h dened hx must show c 2 f jh 1 c sj maps elements needed otherwise claim c 2 f c b ac f 0 see observe g 1 g 2 two distinct members f 0 ag 1 ag 2 lie distinct additive cosets f 0 f since otherwise dierence ag 1 would f 0 contradicting fact 62 f 0 thus ranges members f 0 ag intersects distinct additive cosets f 0 f hence af 0 intersects cosets particular g 2 f 0 ag 2 f implying assertion claim c dene follows yx 2 f 0 every x 2 f 0 1 ax b yx showing h maps elements theorem 9 let f nite eld exists set f 2 size half linear maps large bucket ie exists value 2 f proof first construct set 0 f 2 js 0 j jf n distinct lines plane f 2 containing least n 13 3 points 0 let us rst consider case n prime f consists integers modulo n ng consider square grid clearly js 0 j n well known n popular lines contains least n 13 3 points 0 usually proved grid euclidean plane see eg pa95 pp 178179 result implies grid f 2 let subeld f p elements let x 2 f primitive element every element f uniquely expressed polynomial x degree k coecients f 0 let k let polynomials f coecients f 0 finally take n 2 1 b 2 2 consider line l ay notice n lines ay n distinct lines containing points 0 n 13 claimed unless k 1 mod 3 notice k 2 mod much higher n 13 bad case k 1 mod 3 apply construction instead finally suppose prime k 1 mod 3 get set 0 case merge two constructions let f 0 p element subeld f f 0 consists integers modulo p set pg let k let x 2 f primitive element express element f uniquely polynomial x degree less k coecients f 0 set ag polynomials f coecients f 0 finally set g let b polynomials coecients f 0 dega k 1 degb k 2 consider line l fg compute value jl ab 0 j note point axy bx l ab 0 polynomial f number polynomials f exactly exactly p k1 1 jl a0b0 aaj thus knowing p popular lines f 2 0 contain least 0 p 13 3 points conclude exist n distinct lines containing least points namely lines l ab choices b l a0b0 popular line f 2 cases constructed set 0 f 2 size js 0 j n n distinct popular lines containing least n 13 3 points 0 let p projective plane containing f 2 n 2 n 1 points p every popular line covers n 1 ith popular line 1 n 1 intersections earlier lines thus covers least n 2 points previously uncovered therefore total least n2 1 points covered popular lines simple counting gives existence line l p among popular lines half points l covered popular lines let f projective transformation taking ideal line l l dene one linear hash function h f 2 f constant zero thus single bucket rest point x h 2 l 0 h collapses points f 2 single line going x h observed beginning section furthermore linear nonzero map picked random points x h equally likely thus statement theorem follows show least half points x h ideal line holds line x h intersects least n 13 3 1 points line x h intersects least n 13 3 1 points line fx h intersects fs least n 13 3 1 projective points sucient line fx h intersects 0 least n 13 3 points 1 comes possibility fx h line fx h popular sense used denition f true least half points x h ideal line done 2 32 upper bound largest bucket small eld let us recall prove main result convenience speak hashing n log n keys n values also assume n power 2 theorem 5 let h class linear transformations two vector spaces z 2 log n log log n theorem implies theorem 4 bound probability event many elements set mapped single element range denote bad event e 1 overall idea present another less natural event e 2 show probability e 2 small yet probability e 2 given big thus probability e 1 must small remark somewhat similar line reasoning used seminal paper vapnik chervonenkis vc71 proof x domain 2 range buckets size let us choose arbitrary log n consider space 2 construct linear intermediate range following way choose uniformly random linear transformation uniformly random onto linear transformation note mentioned proof part theorem 7 yields h uniformly chosen among linear transformations b let us x threshold dene two events e 1 existence bucket size least exists element 2 b going limit probability e 1 seemingly unrelated event exists element 2 b consider distribution space h 1 h 2 uniformly chosen shall show proposition 31 log log log proposition 32 c 12 2 n log2 n c 12 theorem 7a propositions 31 32 deduce probability e 1 must small corollary 33 constant c r 4 every power two n following holds subset size log n vector space z 2 hashed random linear transformation z log n 2 probmaximum bucket size rc log n log log n 2r log r logr log r log logr log r proof given r 4 let l blog nlog log nlog r log log r 1c let log log n letting log n log nlog log nlog r log log r n log n r log r 1 2 l n 2 log nlog log nlog r log log r1 log nr log r c 12 2 l n log2 l n c 12 2 log nr log r1 log log n log r log nr log r2 log log n log r log log n conditions proposition 31 32 satised combining conclusions get log log log event e 1 event biggest bucket bigger log log n since r log r statement corollary follows putting let us prove propositions proof proposition 31 note rst alternative way describe e 2 prove proposition 31 holds specic h 1 thus also holds randomly chosen h 1 x h 1 consider distribution h 2 chosen uniformly amongst full rank linear transformation b use part b theorem 7 set n h 1 density clearly 1 1d thus theorem gives log log nlog log1 log log log claimed 2 proof proposition 32 fix h e 1 holds x full rank h 2 show probability event e 2 least 12 even two xed thus conditional probability also least 12 since e 1 holds subset 0 cardinality least mapped h single element 2 z log n fix dene consider distribution h 1 satisfying restrict h 1 0 get distribution implied h 1 uniform choice ane linear map 0 0 show proposition 34 event e 2 hold enough 0 h 1 show h 1 0 covers points 0 probability least 12 thus get event e 2 happens probability 12 since h 2 onto ja hand 0 cardinality least theorem 7 probability set cardinality mapped random linear transformation cover range cardinality 2 n least 12 note theorem 7 part clearly applies random ane transformation 2 point proven corollary 33 limits probability large buckets linear hashing straightforward deduce theorem 5 corollary proof theorem 5 l n log n expectation distribution largest bucket size corollary 33 limits probability tail distribution thus yielding desired bound expectation constant c corollary 33 set log log n 4k z 4k kz2r log r logr log r log logr log r dr log log nin order paper selfcontained include proof simple statement random linear transformations used proposition 34 let b vector spaces z 2 let h arbitrary linear map let arbitrary onto linear map let point b denote choosing uniform linear map restricting domain 0 get uniformly chosen linear map 0 0 uniformly chosen ane map 0 0 otherwise proof consider 0 0 let us choose complement space 1 us call x unique vector 0 1 linear transformation determined two restrictions clearly uniform random choice h 1 corresponds uniform independent choices h 0 h 00 restriction means h 0 0 0 restriction h 1 thus restriction random choices h 0 h 00 still independent note restriction h 1 question exactly note restriction question h 0 time translated random value h 00 x 2 0 2 4 remarks open questions discussed case small eld size 2 large eld size n happens intermediate sized elds immediate rough generalizations bounds following hash adversely chosen subset f size randomly chosen linear map expected size largest bucket olog n log log n log jf j least bounds possible another question properties well known hash families examples families mind include arithmetic z p cw79 fks84 h ab b mod p mod n integer multiplication dhkp97 ahnr95 h boolean convolution mnt93 h projected subspace example natural nonlinear scheme assertion theorem 6 fails scheme maps integers 1 p large prime p integers 0 n 1 mapping x 2 z p ax two randomly chosen elements z p scheme primes p choices n subset cardinality log n log log log n z p mapped mapping onto 0 n 1 choice b see let p prime satisfying p 3 mod 4 consider set quadratic residues modulo p note every nonzero element 2 z p set mod p either set quadratic residues set quadratic nonresidues modulo p main result graham ringrose gr90 asserts innitely many primes p smallest quadratic nonresidue modulo p least ast p log log log p result holds primes p well follows remark end gr90 since primes p 1 quadratic nonresidue follows choice b 2 z p set computed z p avoids intervals length least ast p log log log p choosing log log log p appropriate small constant c dening log n log log log n mapped onto 0 n 1 choice b nal question whether exists class h size 2 olog log ju jlog n l n olog n log log n note linear maps z 2 even combined collapsing universe use olog log bits simple scheme using higher degree polynomials uses olog log log log n acknowledgment thank sanjeev arora helpful remarks r fast simple randomized parallel algorithm maximal independent set problem sorting linear time universal classes hash functions introduction algorithms reliable randomized algorithm closestpair problem polynomial hash functions reliable handbook algorithms data structures lower bounds least quadratic nonresidues analysis universal class hash functions randomized deterministic simulations prams parallel machines restricted granularity parallel memories computational complexity universal hashing combinatorial geometry universal classes fast high performance hash functions uniform convergence relative frequencies events probabilities tr storing sparse table italic0italic1 worst case access time randomized deterministic simulations prams parallel machines restricted granularity parallel memories fast simple randomized parallel algorithm maximal independent set problem introduction algorithms computational complexity universal hashing dynamic perfect hashing sorting linear time reliable randomized algorithm closestpair problem polynomial hash functions reliable extended abstract ctr dahlia malkhi moni naor david ratajczak viceroy scalable dynamic emulation butterfly proceedings twentyfirst annual symposium principles distributed computing july 2124 2002 monterey california beate bollig stephan waack philipp woelfel parity graphdriven readonce branching programs exponential lower bound integer multiplication theoretical computer science v362 n1 p8699 11 october 2006 beate bollig philipp woelfel readonce branching program lower bound 2n4 integer multiplication using universal hashing proceedings thirtythird annual acm symposium theory computing p419424 july 2001 hersonissos greece
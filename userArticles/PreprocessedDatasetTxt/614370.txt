lazy sweep ray casting algorithm rendering irregular grids abstractlazy sweep ray casting fast algorithm rendering general irregular grids based sweepplane paradigm able accelerate ray casting rendering irregular grids including disconnected nonconvex even holes unstructured irregular grids rendering cost decreases disconnectedness decreases algorithm carefully tailored exploit spatial coherence even image resolution differs substantially object space resolutionlazy sweep ray casting several desirable properties including generality depthsorting accuracy low memory consumption speed simplicity implementation portability eg hardware dependencieswe establish practicality method experimental results based implementation shown substantially faster two orders magnitude algorithms implemented softwarewe also provide theoretical results lower upper bounds complexity ray casting irregular grids b introduction visualization threedimensional data whether scalar vector direct volume rendering emerged leading often preferred method surface rendering method partially supported sandia national labs national science foundation nsf grant cda9626370 part work conducted c silva partially supported cnpqbrazil phd fellowship partially supported grants nsf ccr9504192 hughes aircraft boeing sun microsystems applied visualize volumetric data require extraction structure isosurfaces streamlines may bias resulting visualization rendering volumetric data directly treat space composed semitransparent material emit transmit absorb light thereby allowing one see see inside data 43 22 21 volume rendering also allows one render surfaces fact changing properties light emission absorption different lighting effects achieved 18 common input data type regular cartesian grid voxels given general scalar field 3 one use regular grid voxels represent field regularly sampling function grid points j k integers j k scale factor 2 thereby creating regular grid voxels however serious drawback approach arises scalar field disparate nonuniform resolution large regions space little field variation small regions space high field variation cases often arise computational fluid dynamics partial differential equation solvers use regular grid infeasible since voxel size must small enough model smallest features field instead irregular grids meshes cells necessarily uniform cubes proposed effective means representing disparate field data irregular grid data comes several different formats 37 41 one common format curvilinear grids structured grids computational space warped physical space preserving topological structure connectivity regular grid however introduction new methods generating higher quality adaptive meshes becoming increasingly common consider general unstructured noncurvilinear irregular grids implicit connectivity information furthermore applications disconnected grids arise rendering irregular grids identified especially important research area visualization 17 basic problem consists evaluating volume rendering equation 21 pixel image screen necessary line sight ray image pixel sorted order cells mesh along ray information used evaluate overall integral rendering equation paper present analyze lazy sweep ray casting algorithm new method rendering general meshes include unstructured possibly disconnected irregular grids primary contribution lazy sweep ray casting lsrc algorithm new method accurately calculating depthsorted ordering lsrc based ray casting employs sweepplane ap proach proposed giertsen 15 introduces several new ideas permit faster execution theory practice paper built upon paper silva mitchell kaufman 36 fundamentals method developed months since writing 36 made several improvements extensions report latest results compare results earlier work 36 definitions terminology polyhedron closed subset 3 whose boundary consists finite collection convex polygons 2faces facets whose union connected 2manifold edges 1faces vertices 0faces polyhedron simply edges vertices polygonal facets convex polyhedron called polytope polytope exactly four vertices four triangular called simplex tetrahedron finite set polyhedra forms mesh unstructured irregular grid intersection two polyhedra either empty single common edge single common vertex single common facet two polyhedra set said form cell complex polyhedra mesh referred cells 3faces boundary mesh also boundary convex hull called convex mesh otherwise called nonconvex mesh cells simplices say mesh simplicial given mesh let c denote number connected components say mesh connected otherwise mesh disconnected let n denote total number edges polyhedral cells mesh vertices edges facets cells theoretical discussions assuming input mesh given standard data structure cell complexes eg facetedge data structure 10 cell pointers neighboring cells basic traversals facets also possible following pointers raw data topological information already encoded obtained preprocessing step using basic hashing methods implementation lsrc algorithm relies simple economical structure input data particular store vertex v use set see 32 simply list cells mesh use v v vertex cell note requires storage since total size use sets bounded sum sizes cells image space consists screen nbyn pixels let ae ij denote ray eye camera center pixel indexed j let k ij denote number facets intersected ae ij finally let total complexity ray casts image refer k output complexity clearly omegagamma k lower bound complexity ray casting mesh note since n 2 rays intersects facets related work simple approach handling irregular grids resample thereby creating regular grid approximation rendered conventional methods 28 42 order achieve high accuracy may necessary sample high rate requires substantial computation time may well make resulting grid far large storage visualization purposes several rendering methods optimized case curvilinear grids partic ular fruhauf 12 developed method rays bent match grid deformation also exploiting simple structure curvilinear grids mao et al 20 shown grids efficiently resampled spheres ellipsoids presorted along three major directions used splatting direct approach rendering irregular grids compute depth sorting cells mesh along ray emanating screen pixel irregular grids especially disconnected grids nontrivial computation efficiently one always take naive approach n 2 rays compute intersections cell boundary facets time crossing points log n time however results overall time 2 n log n take advantage coherence data sorted order cells crossed one ray used way assist processing nearby rays garrity 14 proposed preprocessing step identifies boundary facets mesh processing ray passes interior cells mesh connectivity information used move cell cell constant time assuming cells convex constant complexity every time ray exits mesh boundary facet necessary perform firstcell operation identify point ray first reenters mesh garrity using simple spatial indexing scheme based laying regular grid voxels cubes top space recording facet voxels intersects casting ray regular grid one search intersections among facets stored voxel stabbed ray firstcell operation fact ray shooting query field computational geometry provides data structures one either answer queries time olog n cost preprocessing storage 2 4 8 27 answer queries worstcase time 34 using data structure essentially linear n 3 33 terms worstcase complexity reasons believe tradeoffs query time storage space essentially best possible unfortunately algorithms rather complicated high constants yet implemented shown practical certainly data structures superlinear storage costs practical volume rendering motivated mitchell mount suri 23 devise methods ray shooting query sensitive worstcase complexity answering query depends notion local combinatorial complexity associated reasonable estimate difficulty query easy queries take provably less time hard queries data structure based octrees 31 extra care needed keep space complexity low achieving provably good query time uselton 39 proposed use zbuffer speed firstcell ramamoorthy wilhelms 30 point approach effective 95 time also point 35 time spent checking exit cells 10 entry cells 19 describes parallelization garritys method one disadvantages ray casting approaches exploit coherence nearby rays may cross set cells another approach rendering irregular grids use projection feedforward methods 22 45 34 38 cells projected onto screen onebyone visibility incrementally accumulating contributions final image one advantage methods ability use graphics hardware compute volumetric lighting models order speed rendering another advantage approach works object space allowing coherence exploited directly projecting cells onto image plane may end large regions pixels correspond rays depth ordering discovered without explicitly casting rays however order projection possible depth ordering cells computed course always possible even set three triangles cyclic overlap computing verifying depth orders possible 43ffl time 1 7 9 ffl 0 arbitrarily small positive constant case depth ordering exists important problem find small number cuts break objects way depth ordering exist see 7 5 bsp trees used obtain decomposition result quadratic number pieces 13 26 however important classes meshes eg rectilinear meshes delaunay meshes 11 known depth ordering always ex ists respect viewpoint structure exploited max et al 22 williams 45 obtained lineartime algorithm visibility ordering convex connected acyclic meshes whose union convex cells convex assuming visibility ordering exists williams also suggests heuristics applied case visibility ordering case nonconvex meshes eg tetrahedralizing nonconvexities unfortunately may result quadratic number cells 40 techniques presented depth ordering strictly necessary cases calculated approximately fast rendering achieved using graphics hardware project partially sorted faces recent scanline technique handles multiple overlapping grids presented 44 process set polygonal facets cells first bucketing according scanline contains topmost vertex maintaining yactives list polygons present scanline sweep top bottom scanline scan x bucketing polygons according left extent maintaining via merging zsorted list polygons scan left right method parallelized used within multiresolution hierarchy based kd tree two important references rendering irregular grids yet discussed giertsen 15 yagel et al 47 elaborate next section closely related method summary projection methods potentially faster ray casting methods since exploit spatial coherence however projection methods give inaccurate renderings visibility ordering methods break cycles either heuristic nature potentially costly terms space time standard algorithmic paradigm computational geometry sweep paradigm 29 com monly sweepline swept across plane sweepplane swept across 3space data structure called sweep structure status maintained simulation continuous sweep certain discrete events eg sweepline hits one discrete set points sweep structure updated reflect change idea localize problem solved solving within lower dimensional space sweepline sweepplane processing problem according systematic sweeping space sweep algorithms sweep plane intersection sweep plane z axis viewing plane axis scanline x axis figure 1 sweepplane perpendicular yaxis used sweeping 3space able exploit spatial coherence data giertsens method giertsens pioneering work 15 first step optimizing ray casting making use coherency order speed rendering performs sweep mesh 3space using sweepplane parallel xz plane viewing coordinate system viewing plane xy plane viewing direction z direction see figure 1 algorithm consists following steps 1 transform vertices viewing coordinate system 2 sort transformed vertices ycoordinates put ordered vertices well ycoordinates scanlines viewing image event priority queue implemented case array 3 initialize active cell list acl empty acl represents sweep status maintains list cells currently intersected sweepplane 4 empty pop event queue event corresponds vertex v go b otherwise go c b update acl insertdelete appropriate cells incident v giertsen assumed cells disjoint v belongs single cell c render current scanline giertsen uses memory hash buffer based regular grid squares sweepplane allowing straightforward casting rays lie current scanline sweeping 3space giertsen reduces ray casting problem 3space 2dimensional cell sorting problem giertsens method several advantages previous ray casting schemes first need maintain connectivity information cells mesh fact assumes cells disjoint second computationally expensive ray shooting 3space replaced simple walk regular grid cells plane finally method able take advantage coherence one scanline next however drawbacks method including 1 original data coarsened finite resolution buffer memory hashing buffer rendering basically limiting resolution rendering possibly creating aliasing effect one could simply increase size buffer approach impractical large datasets cell size variation order 1100000 giertsen mentions cells get mapped location considered degenerate case later cells ignored however resolution might lead temporal aliasing calculating multiple images 2 another disadvantage comparing ray casting techniques need two copies dataset transformation sorting cells must done sweeping started note also feature cell projection methods one cannot keep retransforming single copy since floating point errors could accumulate yagel et als method 46 47 yagel et al proposed method uses sweepplane parallel viewing plane position sweepplane plane intersected grid resulting twodimensional slice whose cells scanconverted using graphics hardware order obtain image slice composited previously accumulated image resulted sweep far several optimizations possible example instead performing full sort along zdirection bucketing technique used also intersections mesh edges slices accelerated storing incremental step sizes deltax deltay corresponding interslice distance deltaz however speedup requires considerably memory furthermore storage polygons given slice requires significant amount memory eg 134 mb blunt fin 47 method handle general polyhedral grids without compute adjacency informa tion conceptually generate high quality images expense slice oversampling simplicity method makes attractive implementation use ideally user access highperformance graphics hardware abundance memory 3 lazy sweep ray casting algorithm design new method based two main goals 1 depth ordering cells correct along rays corresponding every pixel 2 algorithm efficient possible taking advantage structure coherence data first goal mind chose develop new ray casting algorithm order able handle cycles among cells case causing difficulties projection methods address second goal use sweep approach giertsen order exploit interscanline interray coherence algorithm following advantages giertsens 1 avoids explicit transformation sorting phase thereby avoiding storage extra copy vertices 2 makes requirements assumptions level connectivity convexity among cells mesh however take advantage structure mesh running faster cases involve meshes convex cells convex components 3 avoids use hash buffer plane thereby allowing accurate rendering even meshes whose cells greatly vary size 4 able handle parallel perspective projection within framework without explicit transformations 31 performing sweep sweep method like giertsens sweeps space sweepplane orthogonal viewing plane xy plane parallel scanlines ie parallel xz plane events occur sweepplane hits vertices mesh rather sorting vertices advance placing auxiliary data structure thereby least doubling storage requirements maintain event queue priority queue appropriate small subset mesh vertices simple lineartime preprocessing pass data readily identifies set vertices boundary mesh initialize event queue boundary vertices prioritized according magnitude inner product dot product vector representing yaxis viewing coordinate system ie according ycoordinates explicitly transform coordinates furthermore given instant event queue stores set boundary vertices yet swept plus vertices upper endpoints edges currently intersected sweepplane practice event queue relatively small usually accounting small percentage total data size sweep takes place new vertices nonboundary ones inserted deleted event queue time sweepplane hits vertex sweep algorithm proceeds maintain sweep status data structure records necessary information current slice active edge list see section 5 sweepplane encounters vertex event determined event queue sweep status event queue data structures must updated main loop sweep algorithm pop event queue obtaining next vertex v hit check whether sweepplane encounters v reaches ycoordinate next scanline hit v first perform appropriate insertionsdeletions event queue sweep status structure easily determined local tests checking signs dot products neighborhood v otherwise sweepplane encountered scanline point stop sweep drop twodimensional ray casting procedure also based sweep described algorithm terminates last scanline processed 32 processing scanline sweepplane encounters scanline current 3d sweep status data structure gives us slice mesh must solve twodimensional ray casting problem let denote polygonal planar subdivision current scanline ie subdivision obtained intersecting sweepplane mesh time linear size subdivision recovered geometry topology stepping sweep status structure utilizing local topology cells slice sweep status gives us set edges intersecting sweep plane edges define vertices edges obtained searching set triangular facets incident edge implementation however constructed explicitly given implicitly sweep status data structure list active edges locally reconstructed needed twodimensional sweep described details implementation nontrivial presented section 5 twodimensional ray casting problem also solved using sweep algorithm sweep plane sweepline parallel z axis case perspective projection sweep ray eminating viewers eye events correspond vertices planar subdivision occur intersection points active edge 3d sweep status current sweepplane event points processed xorder thus begin sorting alternative approach mentioned section 4 proceed 3d first identifying sorting locally extremal vertices maintaining event queue sweep since single slice relatively event points compared size opted implementation simply sort outright sweepline status ordered list segments crossed sweepline sweepline status initially empty pass sweepline update sweepline status event point making local insertions deletions necessary analogous bentleyottmann sweep used computing line segment intersections plane 29 also stop sweep xcoordinates correspond rays casting ie pixel coordinates along current scanline output rendering model sorted ordering depth ordering given current sweepline status analysis upper lower bounds proceed give theoretical analysis time required render irregular grids begin negative results establish lower bounds worstcase running time theorem 1 lower bounds let mesh c connected components n edges even cells log n lower bound worstcase complexity ray casting cells convex connected component union cells component convex log c lower bound k total number facets crossed n 2 rays cast mesh one per pixel image plane proof clear lower bound since k size output ray casting let us start case c convex components mesh made set convex cells assume one rays traced lies exactly along zaxis fact assume one pixel origin image plane ray cast one along zaxis k simply measures many cells intersects show lower bound log c simply note ray tracing algorithm outputs intersected cells order along ray used sort c numbers z construct oc time tiny disjoint tetrahedral cells one centered z consider case connected mesh whose cells convex assume local connectivity cells part input mesh data structure claim theorem even information still must effectively perform sort claim casting single ray along zaxis require effectively sort n numbers z take unsorted numbers z construct mesh follows take unit cube centered origin subtract cylinder centered zaxis cross sectional shape regular 2ngon radius less 12 remove half polyhedral solid lies xz plane polyhedron p genus 0 constructed time refer n skinny rectangular facets bound concavity walls point 0 0 z create thin wedge contains 0 0 z point 0 0 z j j 6 wedge attached wall touches wall refer figure 2 polyhedron p still genus 0 size polyhedron easily decomposed time convex polytopes zaxis intersects pierces n wedges order given sorted order z thus output ray tracing algorithm one ray along zaxis must give us sorted order n wedges hence n numbers log n bound follows ut remark may tempting think one given convex mesh eg connected tetrahedral cells information used sort vertices mesh eg x coordinate linear time thereby using topological information make sweep algorithms efficient however easy show even 2 dimensions given triangulation complete topological information still requires log n sort n vertices xcoordinates proof based reduction sorting left reader upper bounds previous theorem establishes lower bounds show worst case ray casting method complexity superlinear problem size essentially forced figure 2 lower bound construction sorting however pathological situations lower bound constructions unlikely arise practice examine upper bounds running time sweep algorithm proposed discuss complexity written terms parameters capture problem instance complexity first give worstcase upper bound sweeping 3space vertex events plus n presorted events stop sweep process 2dimensional slice corresponding scanline operation insertiondeletion priority queue requires time olog maximum size event queue worst case order n get worstcase total log n time perform sweep 3space scanline slice must perform sweep well subdivision worstcase size events sweep algorithm include vertices subdivision intersections slice plane edges mesh well n presorted events stop sweepline discrete pixel values x order output ordering size k ij ith pixel jth scanline along sweepline pass rendering module thus worst case sweep 2space requires time log n slice j overall cost n slices p product term nn bound ok log n due fact n slices might complexity roughly n however pessimistic bound practical situations instead let n denote total sum complexities n slices practice expect n much smaller nn potentially n considerably smaller n example mesh uniform may expect slice complexity n 23 case n 13 byn 13 byn 13 grid gives rise n write complexity terms n get worstcase running time ok note worst case may every one n 2 rays crosses upper bound ok n contrasted bound 2 n log n obtained naive method ray casting computes intersections n 2 rays facets sorts intersections along ray omegagamma n facets mesh thus output size k could end dominant term complexity algorithm note even best case since n 2 rays log n term upper bound comes sweep 3space worst case may forced effectively sort vertices via insertionsdeletions event queue discuss analyze complexity terms number n c critical vertices approach used 2dimensional triangulation algorithm hertel mehlhorn 16 consider sweep 3space sweepplane say vertex v critical small neighborhood v number connected components slice changes sweepplane passes v thus vertices locally min max critical also saddle points may critical let n c denote number critical vertices note lower bound construction shows worst case must resort sorting quite contrived particular n c omegagamma n one would expect practice n c small say order c number connected components mesh conduct sweep 3space carefully get away sort critical vertices resulting total time constructing n slices similarly hertel mehlhorn 16 able triangulate polygonal regions plane time compared previous bound log n based plane sweep main idea exploit topological coherence slices noting number connected components changes critical vertices ycoordinates sorted along n scanlines particular use depthfirst search construct connected component within slice given starting seed point component seed points obtained seed points previous slice simply walking along edges grid direction increasing ycoordinate one seed next slice total time walks changes occur critical vertices local points processed time linear degree critical vertices overall sweep 3space gives us slices processed already described note extremal vertices within slice discovered construction slice vertices need sorted put initial event queue sweep slice summary theorem 2 upper bound ray casting irregular grid n edges performed n size output total number facets crossed cast rays n total complexity slices n number critical vertices remark upper bound shows linear dependence n lower bound theorem showed omegagamma n log n lower bound contradiction since proof lower bound construction n critical vertices agreement upper bound figure 3 illustration sweep one slice another potential savings particularly image resolution low compared mesh resolution jump one slice next without using sweep discover one slice evolves next instead construct next slice scratch using depthfirst search mesh using seed points found intersecting new slice plane critical subgraph mesh edges connects critical vertices mesh course know priori better sweep slice slice construct slice scratch thus perform methods parallel two processors use result obtained first processor complete task alternatively achieve effect using single processor performing lock step algorithm steps alternation two methods results asymptotically complexity minimum complexities two methods scheme applies sweep 3space also sweeps slice illustration methods quite useful consider situation figure 3 drawn 2 dimensions depict cases 3space well sweep line 2 line 3 huge complexity must swept may costly compared rebuilding scratch slice along line 3 hand sweeping line 5 line 6 quite cheap essentially change geometry topology constructing slice along line 6 scratch would quite costly performing two methods parallel lock step take advantage best methods resulting algorithm exploits coherence data running time sensitive sense complexity visualization task note practice image resolution low one would probably prefer oversample filter rather use method jumping slice slice ray ray 5 implementation details implemented version main lsrc algorithm simplifications discuss details implementation concentrating relevant issues unique implementing lsrc try present enough details experienced graphics programmer reproduce results minimal guess work current implementation handles general disconnected grids however also assumes simplicity cells mesh tetrahedra simplices extension complex convex even nonconvex cells conceptually straightforward details somewhat tedious contribute basic understanding algorithm ways implemented algorithm differs methods discussed previously section upper bounds two reasons simplicity coding efficiency practice terms running time terms memory discussions point implemented algorithm differs 3d sweep inserting heap boundary vertices grid rather critical vertices 2d sweep maintaining sweepline status implementation entirety consists less 5000 lines c code yet attempted optimize code expect improved major modules program include 3d sweep sweeps input mesh plane orthogonal viewing plane maintaining active edge list aedge marking tetrahedra swept 2d sweep sweeps slice producing sorted intersections cells along ray scanline also graphics module handles computations coordinates respect viewing coordinate frame manages modules computes transfer function optical integration simple shading speak x zcoordinates calculated using simple dot products defining unit vectors viewing frame result full coordinate transformation seek avoid major data structures due large sizes irregular grids efficient data structures substantially influence performance memory requirements implementation basically two big data structures vertex list contains vertex position field values use set list tetrahedra containing couple utility data fields eg generalpurpose flag tetrahedron list contains tetrahedron pointers four vertices one flag data field used indicate sweepplane reached yet 3d sweep experiments two main data structures typically occupy 95 overall space used algorithm organization data memory efficient allowing necessary connectivity information recovered quickly within algorithm since tetrahedron contains 4 vertices total amount memory required use sets bounded 4 theta number tetrahedra clearly extends cell complexes composed cells bounded complexity collect vertices boundary meshes lists sweep preinsert priority queues important note points boundary need inserted 3d sweep sweepplane orthogonal yaxis moved top bottom direction decreasing sweep progresses need able detect next event corresponds closest vertex direction 3d sweep yaxis done maintaining priority queue contains vertices sorted along yaxis particular priority queue contains vertices yet encountered sweepplane bottom endpoints active edges intersected sweepplane priority queue implemented heap 3dheap vertices inserted discovered neighboring vertex encountered sweepplane deleted swept sweep status data structure explicitly keep list active tetrahedra necessary keep list aedge edges currently active aedge active edge list central data structure implementation aedge element contains data fields used several different phases algorithm yet attempted optimize storage space associated aedge list typically contain particularly large number elements since represents cross section dataset size cross section typically n 23 eg regular mbymbym mesh cross section complexity om 2 active edge entry aedge contains pointers endpoints record intersection current position sweepplane pointers top segment bottom segment defined detail 2d sweep data fields used bookkeeping addition insertions deletions aedge list must support endpoint queries given pair vertices v w determine entry aedge pair endpoints implemented simpleminded hashbased dictionary data structure experimented using data structures keeping aedge binary tree overhead keeping complex data structures seems outweigh advantages b c figure 4 processing cell c 3d sweep sweepplane hits topmost vertex c three incident edges added aedge b sweepplane hits intermediate vertex c one edge removed aedge two edges added c sweepplane hits another intermediate vertex c two edges removed aedge one edge added sweep plane hits bottommost vertex c three edges removed aedge 2d sweep also use segment data structure stores pairs active edges belong facet cell pair active edges determines line segment current slice segment object also two pointer fields allow construction doublelinked lists segment objects corresponding sweepline status data structure depthsorting segments along ray 3d sweep 3d sweep events determined sweepplane hits vertex arrives scanline since ycoordinates scanlines predetermined sorted concern ycoordinates vertices since trying lazy sweep interested avoiding creating single sorted list vertices proceed follows first single preprocessing pass vertex list identify vertices lie boundary grid typically set vertices tiny fraction total set given viewing frame insert boundary vertices 3dheap based ycoordinate key values current implementation take advantage fact restrict attention critical vertices discussed section 4 boundary vertices identified preprocessing step opposed critical vertices defined respect viewdependent yaxis still small superset critical vertices aspect algorithm allows us exploit nice structure may present input grids connected components component wellshaped relatively boundary vertices allow 3d sweep algorithm run faster nonlinear time component algorithm sensitive number vertices boundary grid next begin sweep using 3dheap identify vertex events sweep progresses process vertex events natural way making insertions deletions 3dheap aedge list accordingly based use set vertex determine local geometry thereby decide insertionsdeletions make see figure 4 vertex event processing proceeds follows 3dheap empty 1 remove 3dheap vertex v smallest key value ycoordinate 2 cell c contains v v topmost vertex c insert vertices c 3dheap add incident edges aedge list mark c vertices visited b v bottommost vertex c remove incident edges aedge list c otherwise make insertions deletions aedge list according edges incident v 3d sweep stops time sweepplane arrives scanline point 2d sweep occurs corresponding slice rather explicitly constructing slice eg building wingededge data structure 2dimensional subdivision use aedge list represent implicitly structure refer line segments edges subdivision segments rather edges order distinguish edges 3dimensional mesh elements aedge since segments determined pair edges bounding common face segment data type simply stores pairs endpoints segment determined intersection edges pair sweepplane 2d sweep maintain ordering segments intersected line parallel zaxis swept across slice data structure sweepline status typically sweepline algorithms utilize form balanced binary tree order effect efficient logarithmic insertion deletion lookup sweepline status structure indeed first implementation 2d sweep used binary tree store sorted order segment crossings see 36 however experimentation determined different simpler approach works faster practice even though cannot guarantee logarithmic worstcase performance thus describe current method maintaining sweepline status structure 2d sweep begins computing intersections active edges aedge sweepplane caching sorting x place event priority queue implemented heap 2dheap since single slice relatively small size go ahead case full sorting simplicity implementation sweepline status structure implemented doubly linked list segment objects represent sorted list segments intersecting current sweepline sweepline hits active edge ie hits point p slice active edge intersects slice process event making updates sweepline status structure 2dheap necessary overall sweep algorithm proceeds follows 2dheap empty 1 remove 2dheap active edge v smallest key value xcoordinate let v 0 vertex current slice 2 cell c use set v 0 c use set v 1 done considering c since v edge c otherwise proceed b b vertices c exactly two case tetrahedral cells determine forms active edge querying aedge list one v 0 instantiate segment corresponding edge v segment objects inserted explained doubly linked sorted list corresponds sweepline status structure step 2b discovers segments incident event point p intersection active edge v sweepplane updates sweepline status structure done manner exploits topological structure mesh see figure 5 particular point p encountered leftward segments incident p identify using top bottom pointers described delete doublylinked list time insert rightward segments incident p sorting angle using dot product computations p using insertion point position list leftward segments way need searching sorted list segments except case leftward segments incident p case naive lineartime search linked list could search insertions efficiently worstcase logarithmic time found overhead associated data structures pay practice vast majority cases linear search since event points one leftward segments indeed event points leftward segments critical sense described earlier hertel mehlhorn 16 specifically maintain active edge pointers two additional segment objects top segment bottom segment representing topmost bottommost respectively among leftward segments incident corresponding crossing point p pointers initialized null maintain pointers time new segment added discover left endpoint point check right endpoint potentially update topbottom segment pointer corresponding active edge active edge corresponding event point p nonnull top bottom pointer know add new segments right p without search whole sweepline status structure pointers null must linear search locate p linked list since case p leftward segments several advantages new approach compared former binarytree approach notice inserting edges share endpoint allows much simpler robust ordering function implementation use 2d determinant method requires 4 subtractions two multiplications one comparison general case plus two extras comparisons handle degeneracies determining correct ordering two segments share endpoint performing insertions sweepline status still careful handling degeneracies like 36 case analysis much simpler figure 5 illustration action 2d sweep solid thick edges represent elements segment data structure currently sweepline dashed elements touched sweepline yet sweepline encounters event point p discover edge p q therefore update bottom segment q b q p q top segment q q remains unchanged final rendering issues issue handling degeneracies event points happen coincide ycoordinates scanlines xcoordinates pixels within scanline thus 3d sweep must careful process event vertices ycoordinate starting processing 2d slice similarly sweeping slice perform rendering along ray event points may xcoordinate ray processed interpolation original scalar field provided original vertices rendering need able evaluate field given point form interpolation necessary nontrivial step general considerable research devoted topic refer reader 24 25 current implementation tetrahedral cells approach straightforward compute value scalar field point r ray crosses segment p q 2d slice first use linear interpolation along active edges aedge define p q compute values p q third interpolation along p q determine value r lighting model stabbing order cells along ray computed single scattering lighting model applied see 21 survey implemented simple lighting model proposed uselton 39 cell size taken consideration assumption cell important cell able generate good pictures method tend overemphasize portions volume particularly high cell density 6 experimental results datasets code currently handles datasets composed tetrahedral grids possibly disconnected nonconvex boundary input format similar geomview file format simply number vertices tetrahedra followed list vertices list tetrahedra specified using vertex locations file index format compact handle general disconnected grids fairly simple fast recover topological information maintaining explicit topological information input file would waste much space test runs used tetrahedralized versions 4 different datasets originally nasa plot3d format dataset broke hexahedral cell 5 tetrahedra information datasets summarized table 1 see volumerendered images figures 811 besides tested lsrc several artificial datasets debugging purposes particular generated simple datasets disconnected components name dimensions vertices cells blunt fin 40 theta 32 theta 32 40960 187395 liquid oxygen post 38 theta 76 theta 38 109744 513375 wing 56 theta 54 theta 70 211680 1005675 combustion chamber 57 theta 33 theta 25 47025 215040 table 1 list datasets used testing dimensions original nasa plot3d sizes vertices cells actual sizes used lsrc rendering memory requirements lsrc memory efficient see section 5 details data structures besides input dataset memory consumption priority queues aedge segment data structures small practice low storage requirement due incremental computations touch cross section dataset time see table 2 details overall memory consumption rendering dataset numbers independent screen size rendered although depend view given different cross sections datasets might lead different memory usage patterns data structure blunt fin liquid oxygen post delta wing combustion chamber dataset size 78mb 213mb 418mb 9mb aedge 390kb 675kb 214mb 375kb segment 8kb 8kb 20kb 4kb table 2 memory consumption rendering dataset size includes memory necessary keep vertices including use set tetrahedra aedge row gives space used storing list active edges cut current sweepplane segment row gives storage requirement sweepline status representing stabbing order cells along ray performance analysis primary system measurements silicon graphics power challenge equipped processors r10000 195mhz 3gb ram used one processors experiments disk io numbers reflect reading local disk present rendering figures tetrahedralized version datasets described table 1 expect rendering times considerably less work directly hexahedral cells without first tetrahe dralizing however current implementation assumes tetrahedral cells lsrc code compiled native sgi compiler irix 62 optimization level o3 times reported seconds represent measured wallclock times table 3 present times read preprocess datasets input files currently ascii requires amount parsing upon reading thus reading time dominated parsing time disk access time use binary files would likely improve efficiency using ascii files simplifies manual creation test samples operation blunt fin liquid oxygen post delta wing combustion chamber reading 386s 1048s 2069s 451s connectivity 347s 962s 1898s 402s boundary vertices 6760 13840 20736 7810 table 3 times spent reading preprocessing data reading accounts time spent reading parsing dataset disk connectivity represents time spent recovering adjacency boundary information boundary vertices row gives number vertices classified boundary dataset table 4 presents rendering times different datasets dataset rendered different resolution primarily would make sense present square images since projections cover square region also present pixel coverage number full pixels image rendering times 34 times faster ones presented earlier 36 36 blunt fin liquid oxygen post used reported took 70 seconds render blunt fin new results reported obtain time 22 seconds improvement factor 31 post dataset improvement 145 seconds 37 seconds factor 39 blunt fin liquid oxygen post delta wing combustion chamber image size 530 theta 230 300 theta 300 300 theta 300 300 theta 200 rendering time 22s 37s 64s 19s full pixels 83264 70503 48009 33947 table 4 rendering results four datasets also tested algorithm scales image size rendered liquid oxygen post 3 different resolutions 300 theta 300 70503 full pixels 600 theta 600 282086 pixels 900 theta 900 634709 pixels rendering times 37 seconds 82 seconds 136 seconds respectively indicates cost per pixel actually decreases image size increases matches intuition larger image less useless sorting per scanline 2dsweep basically get sorting information continuum along scanline use information along pixel actually rendered image size gets larger less sorting work 2dsweep per pixel rendered large images shading cost dominate point sorting becomes essentially free constant cost given dataset view far shown new method 3 times fast one presented 36 important understand speedup achieved order able analyze differences recalculate figures 5 6 36 using new method using dataset eg blunt fin order make direct performance comparisons possible figure 6 illustrates number active edges varies 3d sweep figures corresponds figure 5 36 figure 7 illustrates rendering time breaks task function scanline blunt fin dataset compare earlier results presented 36 rendering scanline involves computing intersection points sorting along direction scanline performing 1d sweep sort along ray incrementally basically involves processing events finally shading intergration time two components presented figure 7 correspond 85 overall time spent rendering event handling time approximately 50 time integration time 30 results figure 7 compared figure 6 36 improvements 2d sweep explained previous section resulted several changes first processing scanline 3 times fast second event handling time much lower previously accounted 80 rendering time lowering cost handling events clearly see relative increase cost shading phase event handling cost dominating processing time negligible appear clearly graph performance numbers indicate 1 time process given scanline directly correlated number active edges corre 0number active edges scanline number active edges figure size aedge list function scanline ycoordinate0050150250350 20 40 time scanline number total time event handling time integration time figure 7 illustration breakdown total rendering time per scanline total time represents actual time scanline required rendering order avoid clutter plot two major components rendering time shown event handling time time process active edge enters exists sweepline status integration time time necessary shading calculations sponding slice 2 cost per scanline varies depending complexity slice rendered 3 event handling time still dominates total time spent per scanline 36 event handling time clearly bottleneck rendering speed still accounts 50 overall rendering time future improvements may possible based reuse intersweep planes sorting information use form jumping complexity pixels lockstep idea proposed performance comparisons recent report irregular grid ray caster 19 october 1995 using intel paragon superscalar 50mhz intel i860xps reports rendering times two datasets artificially generated cube dataset 130000 tetrahedra flow dataset 45500 tetrahedra report times single cpu runs experiments use two processing nodes cube reports taking 2415 seconds 2234 seconds ray casting rest parallel overhead 480by480 image approximately 230000 pixels total cost 105 milliseconds per pixel cost per tetrahedron 185 1718 milliseconds flow dataset reports 1593 1585 milliseconds image size cost 69 68 milliseconds per pixel 3501 348 milliseconds per tetrahedron giertsen 15 reports running times 38 seconds 3681 cells 1032 milliseconds per cell dataset small uniform allow direct meaningful comparisons however implementation handles cell complex 100 times number cells used fraction cost per cell yagel et al 47 report rendering blunt fin using sgi reality engine 2 9 seconds using total 21mb ram using 50 slicing planes 100 planes report rendering time 1317 seconds rendering time dependent number slicing planes course affects accuracy picture generated 50slice rendering liquid oxygen post takes 20 seconds using 57mb ram takes almost 43 seconds uses 1117mb ram order facilitate comparisons table 5 summarizes performance results available data reported algorithm comparing numbers table 4 see lsrc much faster ray casting algorithms furthermore comparable performance yagel et als method 100slice rendering uses less half memory used technique looking increase rendering times datasets get larger see larger dataset advantageous use lsrc techniques 7 algorithm extensions section mention possible extensions work dataset cells ren time pixel cell image size memory algorithm blunt fin 187395 22s 180s 117s 530 theta 230 8mb lsrc post 513375 37s 411s 72s 300 theta 300 22mb lsrc post 513375 82s 227s 159s 600 theta 600 22mb lsrc post 513375 136s 167s 264s 900 theta 900 22mb lsrc wing 1005675 64s 711s 63s 300 theta 300 44mb lsrc chamber 215040 19s 316s 88s 300 theta 200 9mb lsrc blunt fin 187395 70s 373s 664s 527 theta 200 8mb 36 post 513375 145s 1611s 282s 300 theta 300 22mb 36 cube 130000 2415s 10500s 18500s 480 theta 480 na flow 45500 1593s 6900s 35010s 480 theta 480 na blunt fin 187395 911s na 48s na 21mb yagel blunt fin 187395 13s17s na 6991s na 21mb yagel post 513375 2045s na 40s na 57mb yagel wing 1005675 4297s na 42s na 112mb yagel na 3681 38s 144s 10320s 512 theta 512 27mb giertsen table 5 performance summary several algorithms indicated last column lsrc results lazy sweep ray casting algorithm proposed paper 36 results obtained previous work yagel results reported 47 results reported 19 giertsen results reported 15 table includes columns indicating datasets used sizes possible cost per pixel per cell memory usage algorithm yagel et al 50plane rendering times reported exception row marked represents rendering times using 100 planes 1 current implementation assumes tetrahedral cells conceptually simple extend arbitrary cells method applies general 2 straightforward generalize method case multiple grids simply perform sweep independently several grids merge sort results along ray rendering 3 investigating possible methods improve algorithm exploits coherence scanline slices reasonable expect us able reuse much slice information one scanline next particular order event points nearly two consecutive slices improvement could help address current bottleneck code interesting possible extension work investigating application outofcore cases dataset large fit main memory must careful control number paging operations disk spatial locality memory accesses indicates able employ prefetching techniques achieve fast rendering irregular grids much larger memory finally method natural candidate parallelization see silva 35 chapter 5 discussion parallelization issues conclusions paper proposed fast new algorithm termed lazy sweep ray casting lsrc algorithm rendering irregular grids based sweepplane approach method similar ray casting methods need transform grid instead uses projection methods adjacency information available determine ordering attempt optimize rendering interesting feature algorithm running time memory requirements sensitive complexity rendering task furthermore unlike method giertsen 15 conduct ray casting within slice sweepplane sweepline method whose accuracy depend uniformity feature sizes slice method able handle general types grids without explicit transformation sorting used methods thereby saving memory computation time performing accurate ray casting datasets established practicality method experimental results based implementation also discussed theoretical lower upper bounds complexity ray casting irregular grids reported timing results showing method compares favorably ray casting schemes many instances two orders magnitude faster published ray casting results another advantage method memory efficient making suitable use large datasets difficult give direct comparison method hardwarebased techniques eg 47 yield impressive speedups purely softwarebased algorithms hand softwarebased solutions broaden range machines code run eg much code developed small laptop 16mb ram acknowledgements indebted arie kaufman extensive discussions encouragement research well contributions paper precursor 36 paper prepared jointly kaufman also thank center visual computing kaufman director use computing resources experiments thank dirk bartz pat crossno george davidson juliana freire dino pavlakos ashish tiwari brian wylie useful criticism help work blunt fin liquid oxygen post delta wing datasets courtesy nasa combustion chamber dataset vtk 32 r computing range searching semialgebraic sets applications new partition scheme counting cutting cycles lines rods space introduction algorithms lecture notes computer science efficient computing verifying primitives manipulation threedimensional subdi visions acyclicity theorem cell complexes dimensions raycasting nonregularly structured volume data visible surface generation priori tree structures raytracing irregular volume data volume visualization sparse irregular meshes fast triangulation plane respect simple polygons research issues volume visualization display surfaces volume data parallel volume rendering unstructuredgrid data distributed memory machines splatting curvilinear grids optical models direct volume rendering area volume coherence efficient visualization 3d scalar functions querysensitive scattered data modeling visualizing modeling scattered multivariate data efficient binary space partitions hiddensurface removal solid modeling ray shooting triangles 3space parallel voxelization algorithms volume rendering unstructured grids computational geometry introduction analysis approaches raytracing curvilinear grids design analysis spatial data structures visualization toolkit polygonal approximation direct scalar volume rendering parallel volume rendering irregular grids fast rendering irregular grids volume probes interactive data exploration arbitrary grids sorting hardware assisted rendering volume visualization volume rendering computational fluid dynamics initial results rapid exploration curvilinear grids using direct volume rendering pursuing interactive visualization irregular grids direct volume rendering curvilinear volumes coherent projection approach direct volume render ing hierarchical parallelizable direct volume rendering irregular multiple grids visibility ordering meshed polyhedra volume rendering polyhedral grids incremental slicing hardware assisted volume rendering unstructured grids incremental slicing tr ctr yang tulika mitra tzicker chiueh onthefly rendering losslessly compressed irregular volume data proceedings conference visualization 00 p101108 october 2000 salt lake city utah united states lichan hong arie kaufman accelerated raycasting curvilinear volumes proceedings conference visualization 98 p247253 october 1823 1998 research triangle park north carolina united states stefan guthe stefan roettger andreas schieber wolfgang strasser thomas ertl highquality unstructured volume rendering pc platform proceedings acm siggrapheurographics conference graphics hardware september 0102 2002 saarbrucken germany bruno lvy guillaume caumon stphane conreaux xavier cavin circular incident edge lists data structure rendering complex unstructured grids proceedings conference visualization 01 october 2126 2001 san diego california ricardo farias joseph b mitchell cludio silva zsweep efficient exact projection algorithm unstructured volume rendering proceedings 2000 ieee symposium volume visualization p9199 october 0910 2000 salt lake city utah united states ricardo farias cludio silva outofcore rendering large unstructured grids ieee computer graphics applications v21 n4 p4250 july 2001 lichan hong arie e kaufman fast projectionbased raycasting algorithm rendering curvilinear volumes ieee transactions visualization computer graphics v5 n4 p322332 october 1999 rdiger westermann thomas ertl efficiently using graphics hardware volume rendering applications proceedings 25th annual conference computer graphics interactive techniques p169177 july 1998 stefan rttger martin kraus thomas ertl hardwareaccelerated volume isosurface rendering based cellprojection proceedings conference visualization 00 p109116 october 2000 salt lake city utah united states j schroeder berk geveci mathieu malaterre compatible triangulations spatial decompositions proceedings conference visualization 04 p211218 october 1015 2004 peter l williams nelson l max clifford stein high accuracy volume renderer unstructured data ieee transactions visualization computer graphics v4 n1 p3754 january 1998 silva joseph b mitchell peter l williams exact interactive time visibility ordering algorithm polyhedral cell complexes proceedings 1998 ieee symposium volume visualization p8794 october 1920 1998 research triangle park north carolina united states cevdet aykanat b barla cambazoglu ferit findik tahsin kurc adaptive decomposition remapping algorithms objectspaceparallel direct volume rendering unstructured grids journal parallel distributed computing v67 n1 p7799 january 2007 yijen chiang ricardo farias cludio silva bin wei unified infrastructure parallel outofcore isosurface extraction volume rendering unstructured grids proceedings ieee 2001 symposium parallel largedata visualization graphics october 2223 2001 san diego california
scalable parallel algorithm incomplete factor preconditioning describe parallel algorithm computing incomplete factor ilu preconditioners algorithm attains high degree parallelism graph partitioning twolevel ordering strategy subdomains nodes within subdomain ordered preserve concurrency show algorithmic analysis computational results algorithm scalable experimental results include timings three parallel platforms problems 20 million unknowns running 216 processors resulting preconditioned krylov solvers desirable property number iterations required convergence insensitive number processors b introduction incomplete factorization ilu preconditioning currently among robust techniques employed improve convergence krylov space solvers linear systems equations ilu stands incomplete lu fac torization l u lower upper triangular incomplete factors coecient matrix however scalable parallel algorithms computing ilu preconditioners available despite fact used twenty years 12 report design analysis implementation computational evaluation parallel algorithm computing ilu preconditioners parallel algorithm assumes three requirements satisfied adjacency graph coecient matrix underlying finite element finite dierence mesh must good edge separators ie must possible remove small set edges divide problem collection subproblems roughly equal computational work requirements size problem must suciently large relative number processors work required subgraph processor suitably large dominate work communications needed boundary nodes subdomain intersection graph defined later small chromatic number requirement ensure dependencies factoring boundary rows result undue losses concurrency outline paper follows section 2 describe steps parallel algorithm computing ilu preconditioner detail provide theoretical justification algorithm based incomplete fill path theorem proof discussion theorem deferred appendix also discuss received editors august 4 2000 accepted publication revised form december 17 2000 published electronically april 26 2001 work supported u national science foundation grants dms9807172 ecs9527169 u department energy subcontract b347882 lawrence livermore laboratory gaann fellowship department education nasa contract nas119480 authors residence icase httpwwwsiamorgjournalssisc22637619html old dominion university norfolk va 235290162 icase nasa langley research center hampton va 236812199 hysomcsoduedu pothencsoduedu role subdomain graph constraint plays design algorithm show preconditioners exist special classes matrices relate work earlier work problem section 3 contains analysis shows parallel algorithm scalable twodimensional 2d threedimensional 3dmodel problems suitably ordered partitioned section 4 contains computational results poisson convectiondiusion problems first subsection shows parallel ilu algorithm scalable three parallel platforms second subsection reports convergence studies tabulate number krylov solver iterations number entries preconditioner vary function preconditioner level three variations algorithm results show fill levels higher one eective reducing number iterations number iterations insensitive number subdomains subdomain graph constraint aect number iterations makes possible design simpler parallel algorithm background needed ilu preconditioning may found several books see eg 1 15 17 33 preliminary version paper presented supercomputing 99 published conference proceedings 18 algorithm revised additional details included proof theorem based added experimental results section 4 new included technical reports 19 20 2 algorithms section discuss parallel ilu pilu algorithm underlying theoretical foundations 21 pilu algorithm figure 21 describes steps pilu algorithm high level algorithm suited implementation messagepassing sharedaddress space programming models pilu algorithm consists four major steps first step create parallelism dividing problem subproblems means graph partitioning second step preserve parallelism interior subproblems locally scheduling computations subgraph third step preserve parallelism boundaries subproblems globally ordering subproblems coloring suitably defined graph final step compute preconditioner parallel describe four steps greater detail step 1 graph partitioning first step pilu partition adjacency graph ga coecient matrix p subgraphs removing small set edges connects subgraphs subgraph mapped distinct processor responsible computations associated subgraph example model fivepoint grid partitioned four subgraphs shown figure 22 clarity edges corresponding coecient matrix elements within subgraph subgraphs shown edges drawn correspond fill elements elements zero coecient matrix nonzero incomplete factors join dierent subgraphs state objective function graph partitioning problem need introduce terminology edge separator edge endpoints belong dierent subgraphs vertex subgraph interior vertex neighbors belong subgraph boundary vertex adjacent one vertices belonging another subgraph definition interior vertex subgraph adjacent vertex boundary interior another subgraph figure 22 first 25 vertices interior vertices subgraph 0 vertices numbered 26 36 input coecient matrix adjacency graph number processors p output incomplete factors coecient matrix 1 partition adjacency graph matrix p subgraphs sub domains map subgraph processor objectives partitioning subgraphs roughly equal work edges join dierent subgraphs 2 subgraph locally order interior nodes first order boundary nodes 3 form subdomain intersection graph corresponding par tition compute approximate minimum vertex coloring order subdomains according color classes 4 compute incomplete factors parallel factor interior rows subdomain b receive sparsity patterns numerical values nonzeros boundary rows lowernumbered subdomains adjacent subdomain c factor boundary rows subdomain send sparsity patterns numerical values highernumbered neighboring subdomains fig 21 high level description pilu algorithm boundary vertices goal partitioning keep amount work associated incomplete factorization subgraph roughly equal keeping communication costs needed factor boundary rows small possible diculty modeling communication costs associated boundary rows order describe diculty need relate cost precisely separators graph define higher degree vertex v number vertices numbered higher v given ordering assume upwardlooking roworiented factorization used boundary two subgraphs elements need communicated lower numbered subgraph higher numbered subgraph number elements proportional sum higher degrees filled graph gf boundary vertices lower numbered subgraph unfortunately know fill edges point since neither computed ordering ga computed symbolic factorization could approximate considering higher degrees boundary vertices graph ga instead filled graph gf even requires us order subgraphs partition union boundary vertices subgraphs forms wide vertex separator means shortest path interior vertex subgraph interior vertex another subgraph consists least three edges path length least three communication cost forward backward triangular solution steps proportional sum sizes wide vertex separators none publicly available graph partitioning software minimization wide separators objective function possible modify existing software optimize objective 42 43 44 45 46 93 94 95 96 9799101103 104 105 106 107 108 fig 22 example shows partitioning mapping vertex ordering used pilu algorithm graph top regular 12 12 grid fivepoint stencil partitioned four subdomains mapped four processors subdomains ordered coloring algorithm reduce dependency path lengths level one two fill edges join dierent subdomains shown edges omitted clarity figure bottom right shows subdomain intersection graph subdomain graph constraint enforced prohibits fill boundary nodes subdomains 1 2 indicated broken edges top graph graph bottom left shows subdomain intersection graph subdomain graph constraint enforced goal partitioning step keep amount work associated subgraph roughly equal load balance making communication costs due boundaries small possible previous two paragraphs show modeling communication costs accurately terms edge vertex separators initial graph ga dicult could adopt minimization wide separator sizes reasonable goal problem npcomplete exist ecient heuristic algorithms partitioning classes graphs occur practical situations among graph classes 2dfinite element meshes 3dmeshes good aspect ratios step 2 local reordering second step subgraph order interior vertices boundary vertices ordering ensures incomplete factorization interior vertex one subgraph cannot joined fill edge vertex another subgraph shown later fill edges two subgraphs join boundary vertices together thus interior vertices corresponding initial graph ga remain interior vertices graph factor gf consequences rows corresponding interior vertices subdomain initial problem ga factored concurrently communication required factoring rows corresponding boundary rows reader verify subgraph figure 22 interior nodes ordered boundary nodes observation concerning fill edges preceding paragraph results application following incomplete fill path theorem given adjacency graph ga coecient matrix theorem provides static characterization fill entries arise incomplete factorization l lower triangular incomplete factor u upper triangular incomplete factor e remainder matrix characterization static fill completely described structure graph ga information factor required need definition state theorem fill path path joining two vertices j whose interior vertices numbered lower end vertices j 1 recall also definition levels assigned nonzeros incomplete factorization discuss sparsity pattern incomplete factors consider filled matrix sparsity pattern f initialized nonzero entries f corresponding nonzeros level zero zero entries level infinity new entries arise factorization assigned level based levels causative entries according rule incomplete fill path theorem describes intimate relationship fill entries iluk factors path lengths graphs theorem 21 let filled matrix corresponding incomplete factorization let f ij nonzero entry f f ij level entry exists shortest fill path length joins j ga proof discussion theorem included appendix consider adjacency graph ga partition subgraphs subdomains path joining two interior nodes distinct subdomains must include least two boundary nodes one subgraphs since boundary node numbered higher least one paths end vertices since interior nodes subgraph path cannot fill path two interior nodes belonging separate subgraphs connected fill path corresponding fill entry permitted f interior nodes would transformed boundary nodes gf undesirable parallelism since would fewer interior nodes eliminated concurrently local ordering step preserves interior boundary nodes factorization ensures subdomains interior rows factored independently row updates subdomain therefore subdomains relatively large interiorboundary node ratios contain approximately equal amounts computational work expect pilu exhibit high degree parallelism 1 reader doubtless noted interior used dierent sense previously trust obvious context interior used refer nodes paths used refer nodes subgraphs step 3 global ordering global ordering phase intended preserve parallelism factoring rows corresponding boundary vertices order explain loss concurrency could occur phase algo rithm need concept subdomain intersection graph shall call subdomain graph brevity subdomain graph sg computed graph g partition subgraphs vertex set v contains vertex corresponding every subgraph partition edge set e contains edge edge g one endpoint j compute subdomain graph sa corresponding initial graph ga partition graph denoted sga shall write sa simplicity could also compute subdomain graph sf corresponding graph factor gf subdomain graph sa corresponding partition initial graph ga top graph figure 22 shown graph bottom right figure impose constraint fill subdomain graph constraint subdomain graph corresponding gf restricted identical subdomain graph corresponding ga prohibits fill filled graph gf two subdomains joined edge original graph ga fill edge joins subdomains permitted graph incomplete factor gf description pilu algorithm figure 21 assumes subdomain graph constraint satisfied constraint makes possible obtain scalability parallel ilu algorithm later discuss algorithm modified constraint relaxed subdomains nodes ga ordered contiguously consequently saying subdomain r ordered subdomain equivalent saying nodes subdomain r ordered nodes subdomain ordered permits sa considered directed graph edges oriented lower higher numbered vertices edges sf indicate data dependencies factoring boundary rows subdomains edge sf joins r subdomain r ordered subdomain updates boundary rows r applied boundary rows factorization latter rows completed follows ordering sf reduce directed path lengths reduces serial bottlenecks factoring boundary rows impose subdomain graph constraint observations apply subdomain graph sa well since sa identical sf reduce directed path lengths sa coloring vertices subdomain graph colors using heuristic algorithm graph coloring numbering subdomains color classes boundary rows subdomains corresponding first color factored concurrently without updates subdomains subdomains update boundary rows higher numbered subdomains adjacent updates subdomains correspond second color factor boundary rows process continues color classes subdomains factored boundary rows number steps takes factor boundary rows equal number colors takes color subdomain graph figure 22 let p denote processor computes subgraph p 0 computes boundary rows 0 sends processors p 1 p 2 similarly 3 computes boundary rows subgraph 3 sends p 1 p 2 latter processors first apply updates compute boundary rows much parallelism gained subdomain graph reordering gain intuition analysis simplified model problems although cannot answer question priori general problems possible partitions consider matrix arising second order pde discretized regularly structured 2d grid using standard fivepoint stencil assume grid naturally ordered partitioned square subgrids mapped square grid p processors worst case associated subdomain graph appearance regular 2d grid dependency path length 2 p 1 similarly regularly structured 3d grid discretized sevenpoint stencil naturally ordered mapped cube containing p processors dependency path length 3 3 1 however regular 2d grids fivepoint stencil regular 3d grids sevenpoint stencil bipartite graphs colored two colors subdomains first color class numbered first subdomains second color class numbered longest dependency path reduced one discussion shows coloring subdomain graph important step obtaining scalable parallel algorithm step 4 preconditioner computation subdomains nodes subdomain ordered preconditioner computed employ upwardlooking row oriented factorization algorithm interior subdomain computed concurrently processors boundary nodes computed increasing order color classes either levelbased iluk numerical threshold based ilut p algorithm may employed subdomain dierent incomplete factorization algorithms could employed dierent subdomains appropriate multiphysics problems dierent fill levels could employed interior nodes subdomain boundary nodes reduce communication synchronization costs 22 relaxing subdomain graph constraint consider subdomain graph constraint might relaxed given graph ga partition subgraphs color subdomain graph sa order subdomains compute graph gf incomplete factor subdomain graph sf need discover dependencies sf initially dependencies sa available done several rounds fill edges could create additional dependencies boundary rows subdomains turn might lead dependences number rounds needed length longest dependency path subdomain graph gf could p discussion applies iluk algorithm employed symbolic factorization preceding numerical factorization ilut employed symbolic factorization numerical factorization must interleaved would done sequential algorithm color vertices sf compute schedule factoring boundary rows subdomains achieving concurrency step subdomain graph sf small chromatic number independent number vertices ga note description pilu algorithm figure 21 needs modified reflect discussion subdomain graph constraint relaxed graph gf figure 22 indicates fill edges join 1 2 broken lines corresponding subdomain intersection graph sf shown lower left edge 1 2 necessitates three colors color sf subdomains 0 3 form one color class 1 constitutes second color class 2 makes third color class thus three steps needed computation boundary rows preconditioner subdomain graph constraint relaxed note processor responsible subdomain 2 begin computing boundary rows receives update either 0 3 cannot complete computation received update theorem 21 intuitively simple geometric interpretation given initial node ga construct topological sphere containing nodes distance less equal k edges fill entry f ij admissible within sphere note nodes j cause fill edges since needs fill path joining j applying theorem 21 gain intuitive understanding fill entries may discarded account subdomain graph constraint referring figure 22 see prohibited edges arise two nonadjacent subdomains ga nodes joined fill path length less k zero edge discarded constraint 23 existence pilu preconditioners existence preconditioners computed pilu algorithm proven classes problems meijerink van der vorst 28 proved mmatrix ilu factors exist predetermined sparsity pattern manteuel 27 extended result hmatrices positive diagonal elements results immediately show pilu preconditioners sparsity patterns based level values exist classes matrices true even dierent level values used various subdomains boundaries incomplete cholesky ic preconditioners symmetric problems could computed parallel algorithmic framework using preconditioners proposed jones plassmann 21 lin 23 subdomain boundaries sparsity patterns preconditioners determined numerical values matrix memory constraints lin proved preconditioners exist hmatrices parallel ic preconditioners also shown exist hmatrices subdomain graph constraint enforced preconditioner computed parallel corresponds preconditioner computed serial algorithm reordered matrix constraint enforced specified fill elements dropped schur complement shown resulting schur complement matrix componentwise larger former hence still mmatrix 24 relation earlier work briefly discuss earlier parallel ilu algorithms related pilu algorithm proposed earlier attempts parallel algorithms preconditioning including approaches incomplete surveyed 6 12 34 orderings suitable parallel incomplete factorizations studied inter alios 4 11 13 surveys also describe alternate approximate inverse approach preconditioning saad 33 section 1261 discusses distributed ilu0 algorithm features graph partitioning elimination interior nodes subdomain boundary nodes coloring subdomains process boundary nodes parallel level 0 preconditioners discussed fill subdomains within subdomain need considered implementations results reported although saad informed us recently technical report 24 includes implementation results work done independently shows fill levels higher zero accommodated within algorithmic framework also analyze algorithm scalability provide computational results performance pilu preconditioners results show fill levels higher zero indeed necessary obtain parallel codes scalability good performance karypis kumar 22 described parallel ilut implementation based graph partitioning algorithm include symbolic factorization discover sparsity patterns values boundary rows numerical computation interior rows subdomain factorization boundary rows done iteratively discussion given show subdomain graph constraint might relaxed partially filled graph boundary rows interior rows eliminated formed graph colored compute schedule computing boundary rows since fill edges boundary rows discovered rows factored approach could lead long dependency paths p number boundary rows meshes good aspect ratios cost factoring communicating boundary row proportional number rows phase algorithm could severely limiting scalability algorithm cf discussion section 3 recently magolu monga made van der vorst 25 26 reported variations parallel algorithm computing ilu preconditioners partition mesh linearly order subdomains permit fill interior boundaries subdomains boundary nodes classified respect number subdomains adjacent eliminated increasing order number since subdomains linearly ordered burn ends ordering employed eliminate subdomains approaches similar except additionally order subdomains means coloring reduce dependency path lengths obtain scalable algorithm provided analysis condition number preconditioned matrices class 2d second order elliptic boundary value problems permit high levels fill four greater show increased fill permitted across boundaries enables condition number preconditioned matrix insensitive number subdomains except latter gets great worked independently dierent approach based partitioning mesh rectangular strips computing preconditioner parallel steps wavefront mesh computed step processors proposed bastian horton 3 implemented shared memory multiprocessors recently vuik van nooyen wesseling 36 approach less parallelism one considered 3 performance analysis section present simplified theoretical analyses algorithmic behavior matrices arising pdes discretized 2d grids fivepoint stencils 3d grids sevenpoint stencils since arguments structural nature assume iluk factorization method used word nomenclature begin 2d case word grid refers grid mesh unknowns regular 2d 3d grids five sevenpoint stencils respectively identical adjacency graph ga coecient matrix problems use terms eliminating fig 31 counting lower triangular fill edges naturally ordered grid count number edges incident vertex 9 considering graphs top bottom find two level 0 edges one level 1 edge due fill path 9 3 4 one level 2 edge due fill path 9 3 4 5 two level 3 edges due fill paths 9 3 4 5 6 9 3 2 1 7 generalize two additional fill edges created every level greater three except near boundaries conclude asymptotically 2k lower triangular edges incident vertex level k factorization since mesh corresponds structurally symmetric problem 2k upper triangular edges incident vertex well node factoring row synonymously assume grid blockpartitioned subdomain consisting square subgrid dimension c c also assume subdomain grid dimensions p p p processors total thus grid subdomains boundary nodes subdomain interior nodes locally numbered natural order k c row factor f asymptotically 2k strict upper triangular 2k strict lower triangular nonzero entries justification statement arises consideration incomplete fill path theorem intuition illustrated figure 31 assuming classical iluk algorithm used symbolic factorization symbolic numeric factorization row j entails 4k 2 arithmetic operations lower triangular entry f ji matrix row j factorization requires arithmetic operation upper triangular entry row redblack ordering subdomain graph gives optimal bipartite division red subdomains numbered black subdomains algorithm simplifies following three stages 1 red processors eliminate nodes black processors eliminate interior nodes 2 red processors send boundaryrow structure values black processors 3 black processors eliminate boundary nodes stages nonoverlapping cost first stage bounded cost eliminating nodes subdomain cost 4k 2 c cost second stage cost sending structural numerical values uppertriangular portions boundary rows neighboring processors c incomplete fill path theorem used show asymptotically processor needs forward values c rows neighbor assume standard noncontentious communication model wherein represent message startup perwordtransfer times respectively measure times nondimensional units flops dividing time takes execute one flop time arithmetic operation thus normalized unity cost second step since cost factoring boundary row shown asymptotically identical factoring interior row cost eliminating 4c boundary nodes 4k 2 speedup expressed numerator represents cost sequential execution three terms denominator represent costs three stages arithmetic interior nodes communication costs arithmetic boundary nodes parallel algorithm three implications equation order first fixed problem size number processors parallel computational cost first third terms denominator proportional k 2 communication cost second term denominator proportional k explains increase eciency level observed second ratio np large enough first term denominator become preeminent eciency approach 100 third wish increase number processors p factor maintaining constant eciency need increase size problem n factor shows algorithm scalable observation true direct factorization coecient matrix dependencies created additional fill cause loss concurrency 3d case assume partitioning cubic subgrids dimension c c c subdomain grid dimension p 13 gives subdomains 6c 2 boundary nodes development similar shows asymptotically matrix rows factor f 2k 2 strict upper lower triangular entries cost factoring row 4k 4 speedup case expressed 4k 4 n 4k 4 n 4 results results section based following model problems problem 1 poissons equation two three dimensions g problem 2 convectiondiusion equation convection xy plane x e xy e xy g homogeneous boundary conditions used problems derivative terms discretized unit square cube using 3point central dierencing regularly spaced n x n n z grids n 2d values problem 2 set 1500 11000 problem becomes increasingly unsymmetric dicult solve accurately decreases righthand sides resulting systems artificially generated allones vector preconditioning amenable performance analysis since nonzero structures iluk preconditioners identical pde discretized 2d 3d grid given stencil structure depends grid stencil aected numerical values pivoting needed numerical stability identical structures imply identical symbolic factorization costs well identical flop counts numerical factorization solve phases parallel contexts communication patterns costs also identical preconditioner eectivenessthe number iterations stopping criteria reacheddiers numerics particular problem modeled parallelism available preconditioner structure ilut preconditioners hand function grid stencil numerics changing problem particularly non diagonally dominant cases alter preconditioner structure even grid stencil remain report performance evaluation iluk preconditioners although parallel algorithmic framework proposed could easily work ilut p compared performance iluk ilut earlier report 18 report problem 2 incurred fill ilu5 2d domain grid sizes 400 400 3d domains grid sizes 64 64 64 ilut preconditioner incurred fill ilu2 ilu3 addition demonstrating algorithm provide high degrees parallelism address several issues study influence subdomain graph constraint fill permitted preconditioner convergence preconditioned krylov space solvers also report convergence results function number nonzeros preconditioner 41 parallel performance report timing scalability results preconditioner factorization application three parallel platforms sgi origin2000 nasa ames research center ames coral pc beowulf cluster icase nasa langley research center sun hpc 10000 starfire server old dominion university odu 2206 david hysom alex pothen table time sec required incomplete symbolic numeric factorization 3d scaled problem 91 125 unknowns per processor sevenpoint stencil ilu2 factorization interior nodes ilu1 factorization boundary nodes dashes beowulf hpc 10000 indicate machines insucient cpus perform runs procs origin2000 beowulf hpc 10000 ames icase odu 8 244 311 243 problems solved using krylov subspace methods implemented petsc 2 software library problem 1 solved using conjugate gradient method problem 2 solved using bicgstab 35 petscs default convergence criterion used five orders magnitude 10 5 reduction residual preconditioned system used codes problem generation partitioning ordering symbolic factorization table 41 shows incomplete factorization timings 3d memoryscaled problem approximately 91 125 unknowns per processor number processors increases size problem coecient matrix problem factored 216 processors 197 million rows ilu2 employed interior nodes ilu1 employed boundary nodes reading columns shows performance highly scalable eg sgi origin2000 factorization 216 processors 197 million unknowns required 62 longer serial case scanning horizontally indicates performance similar across platforms eg execution time diered less factor two fastest origin2000 slowest beowulf platforms table 42 shows similar data trends triangular solves scaled problem scalability solves quite good factorization eg solve 216 processors took 25 times longer serial case expected due lower computation cost relative communication synchronization costs triangular solution observed timings identical repeated runs hpc 10000 sgi typically varied 50 repeated runs beowulf remarkably consistent table 43 shows speedup constantsized problem 17 million unknowns clear correlation performance subdomain interiorboundary node ratios ratio needs reasonably large good performance performances reported tables applicable pde discretized sevenpoint central dierence stencil since sparsity pattern symbolic factor depends grid stencil 42 convergence studies approach designing parallel ilu algorithms reorders coecient matrices whose incomplete factorization computed reordering could significant influence eectiveness ilu preconditioners accordingly section report number iterations preconditioned krylov space solver needed reduce residual factor 10 5 compare three dierent algorithms table time sec compute triangular solves 3d scaled problem 91 125 unknowns per processor sevenpoint stencil ilu2 factorization interior nodes ilu1 factorization boundary nodes dashes beowulf hpc 10000 indicate machines insucient cpus perform runs procs origin2000 beowulf hpc 10000 table speedup 3d constantsize problem grid 120120120 total approximately 17 million unknowns data ilu0 factorization performed sgi origin2000 ib ratio ratio interior boundary nodes subdomain procs unknowns ib time eciency processor ratio sec 8 216000 93 2000 100 43 408 62 constrained piluk parallel iluk algorithm subdomain graph constraint enforced unconstrained piluk subdomain graph constraint dropped fill edges level k boundary nodes dierent subdomains permitted even edges join two nonadjacent subdomains initial subdomain graph sa block jacobi iluk bjiluk fill edges joining two dierent subdomains excluded intuitively one expects especially diagonally dominant matrices larger amounts fill preconditioners reduce number iterations required convergence 421 fill count comparisons given problem number permitted fill edges function three components factorization level k subdomain discretization stencil numerical values coecients particular pde influence convergence aect fill counts therefore first set results consists fill count comparisons problems discretized using standard sevenpoint stencil table 44 shows fill count comparisons unconstrained piluk constrained piluk block jacobi iluk various partitionings factorization levels data shows fill discarded factorization level increases subdomain size number nodes subdomain decreases two eects hold constrained piluk block jacobi iluk much pronounced latter example less 5 fill discarded unconstrained factors subdomains contain least 512 nodes table fill comparisons 64 64 64 grid u denotes unconstrained c denotes constrained b denotes block jacobi iluk preconditioners columns headed nzfnza show ratio number nonzeros preconditioner number nonzeros original problem indicative storage requirements columns headed constraint eects present another view data percentage nonzeros constrained piluk block jacobi iluk factors shown relative unconstrained piluk columns show amount fill dropped due subdomain graph constraint nodes per subdom nzfnza constraint eects subdom count level u 4 973 973 973 10000 10000 3 632 632 570 9992 9013 3 660 564 271 8537 4104 subgraphs processor small 42 discarded block jacobi factors thus one might tentatively speculate given subdomain size level piluk provide eective preconditioning bjiluk observed similar behavior 2d problems also 2d 3d problems single subdomain factors returned three algorithms identical single subdomain case ordering used corresponds natural ordering model problems important observation make table 44 sizes number nonze ros preconditioners depend levels fill 3d problems considered cube 64 points side sevenpoint stencil level one preconditioner typically requires twice much storage coecient matrix level two ratio three level three six level four ten 2d problems square grid 256 points side table iteration comparisons 646464 grid u denotes unconstrained c denotes constrained b denotes block jacobi iluk preconditioners starred entries indicate since single subdomain factor structurally numerically identical unconstrained piluk dashed entries indicate solutions either diverged failed converge 200 iterations problem 2 level zero preconditioners reduce relative error solution factor 10 5 termination level one preconditioners either problem 1 problem 2 nodes per subdom subdom count level u c b u c b u c b 28 78 28 28 28 67 4 43 43 64 28 28 63 63 26 fivepoint stencil growth fill level slower ratios 14 level one 18 level two 26 level three 35 level four 43 level five 54 level six parallel computation fill levels higher employed sequential computing feasible since modern multiprocessors either clusters virtual shared memory memory sizes increase number pro cessors another point note added memory requirement level values prohibitive complete factorization hence practical tradeo increased storage preconditioners reducing number iterations solver 422 convergence preconditioned iterative solvers fill results previous subsection influenced actual numerical values nonzero coecients however convergence preconditioned krylov space solvers influenced numerical values accordingly table 45 shows iterations required convergence various partitionings fill levels three variant algorithms consider data tables interpreted various ways begin discussing two ways think primarily significant first scanning vertically one see changing number subdomains hence matrix ordering aects convergence basis comparison iteration count single subdomain partitioning ordering cases identical data close agreement reported benzi joubert mateescu 4 natural ordering report results problem 2 pleasing property constrained unconstrained pilu algorithms number iterations increases mildly increase number subdomains one 512 problems insensitivity number subdomains number nodes per subdomain small confirms pilu algorithms enjoy property parallel algorithmic scalability example poissons equation problem 1 preconditioned level two factorization single subdomain required 24 iterations preconditioning level constrained piluk 512 subdomains needed two iterations similar results observed convectiondiusion problems also property consequence fill subdomains included pilu algorithm similar results reported 26 36 first paper includes condition number analysis supporting observation increasing level fill generally beneficial eect reducing number iterations needed influence largest worseconditioned convection diusion problem 11000 problem level zero preconditioners converge reasonable subdomain sizes also even though level one preconditioners require fewer iteration numbers level two preconditioners cases petsc solvers terminate residual norms reduced 10 5 relative errors larger 10 5 former preconditioners relative errors also large convectiondiusion problem level set zero second scanning data table 45 horizontally permits evaluation subdomain graph constraints eects unless subdomains small factorization level high constrained unconstrained piluk show similar behavior consider example poissons equation problem 1 preconditioned level two factorization 512 subdomains solution unconstrained required 25 iterations constrained piluk required 26 also see piluk preconditioning eective bjiluk 3d trials recall single apparent exception problem 2 32 768 nodes per subdomain large relative errors termination extremes convergence behavior seen problem 2 level one preconditioners bjiluk suers large relative errors termination two algorithms number subdomains 64 fewer 2d domains piluk eective bjiluk poissons equation bjiluk sometimes eective convectiondiusion problems also examine iteration counts function preconditioner size graphically plot data appears figure 41 figures performance 512 nodes per subdomain 512 subdomains block jacobi iluk const unconst piluk1020304050 4096 nodes per subdomain 64 subdomains block jacobi iluk const unconst nodes per subdomain 8 subdomains block jacobi iluk const unconst fig 41 convergence comparison function preconditioner size convection diusion problem 64 64 64 grid data points levels 4 data points constrained unconstrained piluk indistinguishable third graph constrained unconstrained pilu algorithms often indistinguishable find piluk preconditioning eective bjiluk 3d problems given preconditioner size however conclusion always hold 2d problems especially lower fill levels number vertices subdomains increases higher fill levels become eective reducing number iterations needed convergence find fill levels high four six eective subdomains suciently large fill levels higher seem merited problems even dicult convectiondiusion problems level four preconditioner reduces number iterations ten 5 conclusions designed implemented pilu algorithm scalable parallel algorithm computing ilu preconditioners creates concurrency means graph partitioning theoretical basis algorithm incomplete fill path theorem statically characterizes fill elements incomplete factorization terms paths adjacency graph initial coecient matrix obtain scalable parallel algorithm employ subdomain graph constraint excludes fill subgraphs adjacent adjacency graph initial matrix show pilu algorithm scalable analysis 2d 3dmodel problems computational results parallel implementations three parallel computing platforms also study convergence behavior preconditioned krylov solvers preconditioners computed pilu algorithm results show fill levels higher one eective reducing number iterations number iterations insensitive number subdomains subdomain graph constraint aect number iterations needed convergence makes possible design scalable parallel algorithm appendix proof incomplete fill path theorem theorem a1 let filled matrix corresponding incomplete factorization let f ij nonzero entry f f ij level entry exists shortest fill path length joins j ga proof shortest fill path length prove edge exists induction length fill path define chord path edge joins two nonconsecutive vertices path fill path joining j chordless since chord would lead shorter fill path base case immediate since fill path length one graph ga edge j ga corresponds original nonzero assume result true lengths less k 1 let h denote highest numbered interior vertex fill path joining j claim h section path shortest fill path ga joining h section fill path choice h since intermediate vertices section numbered lower h fill path joining h shorter h section would able concatenate h section form shorter path hence h section shortest fill path joining h similarly h j section path shortest fill path joining h j sections fewer k hence inductive hypothesis applies denote number edges h h j section path 1 inductive hypothesis edge h fill edge level k 1 1 edge h j fill edge level k 2 1 sum rule updating fill levels vertex h eliminated fill edge j level prove converse suppose j fill edge level k show fill path ga length induction level k base case immediate since edge j constitutes trivial fill path length one assume result true fill levels less k let h vertex whose elimination creates fill edge j level k let edge h level k 1 let edge h j level k 2 sum rule computing levels k inductive hypothesis shortest fill path length h path length j concatenating paths find fill path joining j length need prove fill path previous paragraph shortest fill path j consider elimination another vertex g causes fill edge j choice vertex h level edge g k 1 g j k inductive hypothesis applies g g j sections hence sum lengths least k 1 completes proof result generalization following theorem characterizes fill complete factorizations direct methods due rose tarjan 30 theorem a2 let filled matrix corresponding complete factorization exists fill path joining graph ga associate level values fill edge relate length shortest fill paths incomplete fill path theorem enables new algorithms incomplete symbolic factorization ecient conventional algorithm simulates numerical factorization described algorithms earlier work 29 report preparation dazevedo forsyth tang 9 defined sum level fill edge j using length criterion employed hence aware result however theorem neither stated proved paper definitions level compute levels fill nonzeros rules summing levels causative pairs nonzeros used literature maximum rule defines level fill nonzero minimum causative pairs maximum value levels causative entries variant incomplete fill path theorem proved case simple elegant one sum rule discussion issues deferred future report acknowledgments thank dr edmond chow casc lawrence livermore national laboratory professor michele benzi emory university helpful discussions r cambridge university press httpwww parallelization robust multigrid methods ilu factorization frequency decomposition method numerical experiments parallel orderings ilu preconditioners approximate incomplete factorizations objectoriented framework block preconditioning experimental study ilu preconditioners indefinite matrices ordering methods preconditioned conjugate gradient methods applied unstructured grid problems graphtheory approach analyzing eects ordering ilu preconditioning ordering strategies related techniques overcome tradeo parallelism convergence incomplete factorizations numerical linear algebra high performance computers analysis parallel incomplete point factorizations iterative methods solving linear systems parallel incomplete cholesky preconditioners based nonoverlapping data distribution incomplete decomposition ilu algorithms parallel ilu ordering convergence relationships numerical experiments improved incomplete cholesky factorization parallel thresholdbased ilu factorization incomplete factorization technique positive definite linear systems iterative solution method linear equation systems coe fast algorithms incomplete factorization algorithmic aspects vertex elimination directed graphs ilut dualthreshold incomplete lu factorization iterative methods sparse linear systems parallelism ilupreconditioned gm res tr ctr robert falgout jim e jones ulrike meier yang conceptual interfaces hypre future generation computer systems v22 n1 p239251 january 2006 luca bergamaschi giorgio pini flavio sartoretto computational experience sequential parallel preconditioned jacobidavidson large sparse symmetric matrices journal computational physics v188 michele benzi preconditioning techniques large linear systems survey journal computational physics v182 n2 p418477 november 2002
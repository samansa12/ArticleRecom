selfstabilizing clock synchronization presence byzantine faults initiate study bounded clock synchronization severe fault model proposed lamport melliarsmith 1985 realistic aspects problem synchronizing clocks presence faults considered one aspect clock synchronization ongoing task thus assumption processors never fail optimistic cope reality suggest selfstabilizing protocols stabilize long enough period less third processors faulty another aspect clock value processor bounded single transient fault may cause clock reach upper bound therefore suggest bounded clock wraps around appropriatewe present two randomized selfstabilizing protocols synchronizing bounded clocks presence byzantine processor failures first protocol assumes processors common pulse second protocol new type distributed counter based chinese remainder theorem used part first protocol b introduction distributed system often necessary keep logical clocks processors synchronized system physical clocks may drift messages could varying delivery times moreover processors may faulty many cases type failures predictable advance handle situation worst type failures must considered namely byzantine faults lsp82 presence byzantine faults processor exhibit arbitrary malicious two faced behavior problem keeping clocks synchronized presence byzantine faults extensively studied eg hs84 lm85 ms85 dhs86 st87 wl88 rsb90 lamport melliarsmith lm85 first present problem show 3f processors sufficient tolerate f byzantine faults necessity 3f processors tolerate f faults later proved dhs86 weaker fault model called authenticated byzantine allows protocol tolerate number faulty processors hs84 failure model reintegration repaired processors possible less half processors faulty many protocols problem assume clocks initially synchronized thus focus keeping synchronized presence clock drift problem ensure clocks initially synchronized addressed eg st87 wl88 protocols mechanism assumed allows nonfaulty processors begin protocol within bounded time period mechanism essentially processes supported part tamu engineering excellence funds nsf presidential young investigator award ccr9158478 department mathematics computer science bengurion university beersheva 84105 israel email shlomicsbguacil z department computer science texas university college station assumed wake distinguished initial state uniquely perform initializing actions including communication work weaken assumptions made design clock synchronization protocols presence byzantine faults goal protocols cope severe realistic fault model traditional byzantine fault model lsp82 initially protocols tolerate byzantine faults designed flight devices need extremely robust device traditional assumptions could violated reasonable assume period execution less one third processors faulty happens short period third faulty perhaps experience weaker fault byzantine fault happens messages sent nonfaulty processors lost one instant time paper present selfstabilizing protocols overcome problems temporary violations assumptions viewed leaving system arbitrary initial state protocol resumes selfstabilizing protocols work correctly started initial system state thus even system loses consistency due unexpected temporary violation assumptions made eg onethird faulty unexpected message loss system synchronizes clocks subsequently assumptions hold eg less third experience byzantine faults originally dijkstra defined dij74 protocol selfstabilizing started arbitrary system state system converges consistent global state realizes task selfstabilizing protocols resilient transient faults faults cause state processor change arbitrarily new state processor resumes operation according program permanent fault fault causes processor permanently misbehave protocol tolerates hybrid faults resilient transient permanent faults eg dw93 gp93 consider napping omission faults respectively interested clock synchronization protocols tolerate hybrid faults work arbitrary initial configuration tolerate less third processors exhibiting permanent byzantine faults realistic assumption clock synchronization protocol 64bit clock unbounded possible applications however context selfstabilizing protocols transient faults could cause system reach upper bound clock thus another aspect problem considered fact clocks bounded paper present two randomized selfstabilizing clock synchronization protocols work presence byzantine faults protocols work bounded clocks first assumes existence common pulse second make assumption expected stabilization time protocols exponential n drawback number processors large however addition theoretical interest believe protocols could practical interest least number backup processors small one contributions paper interesting usage chinese remainder theorem implementing distributed counter counter used accelerate first protocol remainder paper organized follows next section formalize assumptions requirements protocol section 3 presents clock synchronization protocol assumption common pulse section 4 present protocol assume existence common pulses conclusions section 5 distributed system consists set processors communicate sending messages messages bounded delay processor bounded physical clock constantly incre mented wrapping around appropriate physical clocks different processors run approximately rates processor also bounded logical clock computed function current state physical clock value goal logical clocks nonfaulty processors become subsequently remain close continuing progress reasonable rate wrapping around appropriate consider two types timing behavior system synchronous semisynchronous models processors take steps either receive message physical clocks reach predetermined value addition synchronous model common pulse periodically occurs simultaneously processors causing take step proceed formally processor p modeled state machine associated processor physical clock takes integral values 0 pc gamma 1 pc state contains distinguished timer variable take values 0 pc gamma 1 nil indicates processor wants take step next time physical clock given value transition takes current state processor current value physical clock message received produces new state processor set messages sent message system holds messages sent yet received configuration system set processor states one per processor set physical clock values one per processor state message system execution alternating sequence configurations events c 0 delta semisynchronous execution events happen real times taking one configuration next two types events one type tick processors physical clock causing increase 1 mod nothing else changes require real time elapsed two successive ticks processor fixed ae type event step processor processor take one step real time step processor may may receive message real time elapsed sending receiving message must range gamma ffl ffl fixed ffl fixed set faulty processors size f n 3f processor taking step nonfaulty succeeding configuration must correctly reflect processors transition function acting message received state physical clock preceding configuration thus changes processors state message system removing message received adding messages sent processor taking step faulty change state arbitrarily add arbitrary messages message system synchronous execution addition constraints exists value 0 every processor p receives special pulse message dummy processor time delta ie processors take step pulse pulses occur regularly period require every processor p exist function clock given state p value p physical clock returns value range 0 lc gamma 1 fixed lc logical clock p given particular execution c 0 denote clock value function clock applied p state physical clock value c j j configuration execution whose real time occurrence largest exceeding require exist finite time following two conditions hold clock agreement exists 4 nonfaulty processors p clock validity exists delta 4 exists 0 real times clock 1 constant 4 chosen convenience constant larger 2 sufficient note constant 2 condition holds arbitrary configuration since every two clock values lc 2 apart clock agreement states difference two nonfaulty processors clocks fl clock validity states amount logical clock time elapses delta real time linear function delta 3 synchronous protocol first describe protocol synchronous system nonfaulty processors access periodic common pulse pulse triggers processors synchronize clocks time two successive pulses appears important parameter problem case two successive pulses farther apart time required run byzantine agreement protocol following scheme solves problem every pulse starts new version byzantine agreement agree common clock value however pulses order round trip message delay apart scheme cannot work assume pulses order round trip delay apart recall time two successive pulses nonfaulty processors send messages update logical clocks pulse occurs assume long enough pulse takes place message sent nonfaulty processor previous pulse present system whenever nonfaulty processor p triggered pulse p sends message clock value neighbors p waits receive clock values processors p waits period 1 ffl longer bound message delay accounts clock drift period p receives one message neighbor say q p uses latest value arrives q thus end period p set least n gamma f logical clock values one value nonfaulty processor including p p uses set logical clocks received order choose clock value formal description protocol appears figure 1 describe protocol informally protocol processor p works follows 1 value p clock appears less set received logical clocks p assigns 0 clock otherwise 2 case value p clock appears least n gamma f times distinguish case 21 p clock value equal 0 case 22 equal 0 case 21 p increments clock 1 modulo number clock values lc case 22 subdivided two cases 221 according state p previous pulse p incremented clock 1 result case 222 otherwise case 221 p increments clock 1 1 case 222 p tosses coin assigns result 0 1 clock protocol guarantees probability 1 system eventually reaches global state nonfaulty processors clock value 1 global state reached clocks synchronized every pulse every nonfaulty processor p receives messages least processors containing clock value identical clock value moreover pulse nonfaulty processors set clocks 0 always follows pulse every nonfaulty processor increments clock value 1 set 0 thus case 222 applied main idea protocol ensure enough nonfaulty processors clock value value incremented proved sequel pulse one clock value nonfaulty processors incremented 1 rest values changed zero ensures first pulse set clock values nonfaulty processors contains two elements moreover two elements indeed exist one 0 first glance seems sufficient coin toss needed value incremented eventually wrap around 0 time clocks nonfaulty processors 0 however describe infinite execution e use coin tosses clocks never become synchronized consider system four processors p 4 p 4 exhibits byzantine behavior let 0 0 1 clock values p 1 respectively first configuration e first pulse p 4 sends clock value 1 p 1 p 3 clock value 0 p 2 thus p 1 receives clock values vector 0 0 receives 0 0 processor finds processors clock value namely clock value 0 increments clock value one 1 time p 1 p 3 find two clock values value 1 two value 0 assign 0 clocks hence configuration clock values 0 respectively obtained p 4 continue sends clock values receives clock values vector 0 receives 0 receives 0 1 0 0 similarly p 3 processor finds processors clock value assigns 1 clock p 1 assign 0 reach configuration clock values 0 0 1 identical clock values first configuration therefore infinite execution nonfaulty processors never agree clock values possible overcome problem use coin tosses pulse nonfaulty processor clock value clock values value 0 processor tosses coin decides whether assign 1 clock leads possible scenario probability occurring coin toss results cause nonfaulty processors simultaneously assign 1 clocks pulse occurs broadcast clock collect clock values 1 elapsed physical clock case 1 last increment 06 else case 2 07 clock 6 0 case 21 last increment trueg else case 22 last increment else case 222 clock toss0 1 last increment true else last increment false figure 1 synchronous protocol p 31 correctness proof synchronous protocol throughout proof say processor p increments clock 1 certain pulse p assigns last increment true pulse otherwise say assigns 0 clock lemma 31 nonfaulty processors p p j increment clocks 1 pulse p immediately p clock proof assume towards contradiction clock p hence p p finds least n gamma f clock values equal x least n gamma 2f belong nonfaulty processors thus p j also receives n gamma 2f clock values equal x hence p j receives clock values equal since n 3f holds contradicts possibility p j receiving least n gamma f clock values equal lemma 31 implies straightforward manner correctness next two corollaries corollary 32 every pulse set clock values nonfaulty processors contains two elements case two values one 0 corollary 33 pulse p nonfaulty processor p increments clock value 1 result 0 immediately following p clock values nonfaulty processors 0 34 pulse p follows first pulse nonfaulty processor p increments clock 1 without tossing coin p nonfaulty processors clock values 0 proof variable last increment assigned every pulse thus since p follows first pulse indeed increments q pulse p thus lemma 31 nonfaulty processors clock values 0 q p next theorem uses schedulerluck game dim91 dim95 analyze randomized pro tocol schedulerluck game two competitors scheduler adversary luck goal scheduler prevent protocol reaching safe configuration goal luck help protocol reach safe configuration synchronous protocol configuration safe nonfaulty processors logical clocks equal last increment true system scheduler chooses message delays clock drifts execution within predefined limitations time processor activated scheduler tosses coin luck may intervene determine result coin toss proved dim91 dim95 starting possible configuration c luck strategy win schedulerluck game within interventions expected time system reaches safe configuration within expected time main observation used proof fact coin toss result differs desired result according luck strategy configuration reached new game begin theorem 35 expected lc delta 2 2ngammaf pulses system reaches configuration value every nonfaulty processors clock 1 proof proof use lemma 1 dim91 theorem 5 dim95 present strategy luck win schedulerluck game 2n gamma f interventions within lc 2 time strategy luck 1 wait first pulse elapse thereafter 2 luck waits till pulse p nonfaulty processor clock value 0 receives clock values 0 occurs within next lc pulses occur least one nonfaulty processor assign 0 clock successive pulses impossible case 21 pulse nonfaulty processors either tossing coin assigning 1 without tossing luck intervenes n gamma f times fixes coin toss results nonfaulty processors 1 otherwise 22 nonfaulty processor p neither toss coin assign 1 without tossing luck intervenes fixes coin toss results less f 0 note p p clock equal 0 thus 34 processor assigns 1 without tossing coin lemma 31 fact nonfaulty processor tosses coin p holds following p clock values nonfaulty processors 0 therefore next pulse case 21 reached luck could intervene fix n gamma f coin toss results ensure desired global state reached theorem 35 system reaches configuration value every nonfaulty processors clock 1 expected time lc delta 2 2ngammaf easy see successive pulse nonfaulty processors clock value thus clock agreement requirement holds clocks nonfaulty processors incremented 1 every pulse pulses constant time apart clock validity requirement also holds note clock value could multiplied known time difference two successive pulses order yield clock value reflects real time otherwise value clock validity requirement encodes 1 32 accelerating protocol protocol converges expected 2 64 pulses certainly time complexity protocol cannot used practice however lc n f small 2 expected number pulses required reasonably small instance expected number pulses 128 use observation accelerate protocol achieve synchronization clock values range expected number pulses less 381 synchronization occurs within expected number pulses less 58 define chinese remainder counter use chinese remainder theorem appears kn81 p 270 theorem 36 let 1 r positive integers relatively prime pairs ie r integers exactly one integer u satisfies conditions u u j u use theorem case let 2 3 5 p j series prime numbers jth prime 2 delta 3 run j parallel versions protocol ith version runs protocol lc message carries value j clocks one clock value version computation new clock value version uses values received particular version independent computation versions thus ith version converges within expected pulses therefore expected time versions synchronized less p 1 upper bound expectation since corresponds scenario version starts synchronize every apply chinese remainder theorem show every combination values mapped one one number range 0 2 wellknown technique could used order convert representation mapping eg garner methods cf p 274 kn81 chinese remainder theorem could used implementations distributed counters based number presentation method suggested st67 one possible use memory communication efficient distributed counter let dc distributed counter maintained set processors triggered common pulse increments counter mod p every trigger need store entire bits clock send messages indicate carry counter wraps around thus counter incremented communication processors needed value counter scanned communication required 4 semisynchronous protocol section drop assumption common pulses present selfstabilizing randomized protocol semisynchronous systems due space constraints formal description protocol full correctness proof excluded section 2 reasonable think n f small single processor efficiently compute task additional processors added ensure reliability let reliability fn ratio number faulty processors total number processors reach reliability 025 number processors needed thus general terms blowup hardware cost four improve reliability 27028 blowup would 7 asymptotically need infinite blowup reach reliability 13 thus devices would use relatively small number processors protocol stabilizes relatively short time protocol uses faulttolerant averaging function first introduced dl86 solving approximate agreement later used clock synchronization wl88 given multiset values processor applies function discarding f highest f lowest values taking midpoint remaining values shown function used context protocols dl86 wl88 approximately halves range values held nonfaulty processors situation bounded clocks notions highest lowest must appropriately modified real difficulty directly applying previous result analysis showing range cut half depends nonfaulty processors working approximately multisets round multisets differ arbitrarily values corresponding faulty processors values corresponding nonfaulty processors must close allowing error introduced clock drift uncertain message delays round structure achieved actions processors roughly synchronized time wl88 protocols due assumption initial synchronization distinguished initial states since protocol selfstabilizing cannot rely either assumptions thus using faulttolerant averaging function obvious manner processors starting arbitrary information collecting clock values arbitrary times would ensure function applied processors rounds instance p could apply function multiset subsequently q could apply function multiset 0 reflects p new value instead p old value achieve sort approximate rounds applying faulttolerant averaging function first use randomization bring clock values nonfaulty processors close achieved nonfaulty processors collect approximately multisets nonfaulty processors stage midpoint averaging function shown cf wl88 approximately halve nonfaulty clock values thus overcoming ongoing effects clock drift uncertainty message delay describe protocol processor p two synchronization procedures first called averaging procedure second jumping procedure averaging procedure executed value clock range greater 0 smaller ffi time elapsed since previous time clock value range jumping procedure executed j time elapsed since previous execution jumping procedure p currently range dedicated executing averaging function p measures j using physical clock roughly speaking jumping procedure causes clocks nonfaulty processors within small range averaging procedure keeps clocks nonfaulty processors small range approximately halving range time clock values wrap around synchronization procedures processor p start request clock values execution averaging procedure processor measures 2d order make sure requests clock values arrive destinations responses return proceeds decide new clock value thus execution averaging procedure takes period time define symmetric clock clock clock procedures p finds clock values within small range ffi clock p eliminates f values side symmetric clock value 3 jumping procedure p chooses one clock values random reduced clock values list averaging procedure p chooses midpoint reduced clock values list procedures less processors found within ffi clock p chooses randomly one clock values 3 instance collected values 231011 symmetric clock value 7 eliminated 41 correctness proof sketch semisynchronous protocol period time jumping period nonfaulty processor executes averaging procedure period choose 2n gamma f5t j next lemma proves choice yields existence period length 5t ae jumping period lemma 41 every time jumping period least 5t j long proof processor measures time use physical clock whose drift rate real time ae thus processor measures period time physical clock real time elapsed measurement least t1 ae t1 ae way chosen every period length processor executes averaging function processor measures 2d make sure requests clock values arrive destinations responses arrive decides new clock value thus time averaging function executed processor period ae hence total time averaging processors period 2n gamma f5t j ae ae therefore total non averaging time least 2n gamma ae pigeon hole principle least one jumping period length safe configuration system configuration nonfaulty processors clocks within ffi8 moreover case processor middle collecting clock values clock values transit sent nonfaulty processors within range use following assumptions correctness proof assumption 1 1 assumption 2 n lemma 42 jumping period length 5t j 1ae probability least 1n 6ngammaf system reaches safe configuration sketch proof prove lemma presenting sequence random choice results forces system reach configuration clocks nonfaulty processors less ffi 8 apart sequence random choice results probability least 1n 6ngammaf occur let c configuration beginning jumping period without loss generality assume number faulty processors f maximal possible 4 violate inequality n 3f let c first configuration choosing period every nonfaulty processor p luck counts number nonfaulty processors clocks within clock configuration c nonfaulty processor least clock values called anchor claim anchor processors 2t r apart assume towards contradiction two nonfaulty anchor processors p q clock values 2t r apart thus p surrounded processors q surrounded different nonfaulty 4 case fewer faulty processors one could assume nonfaulty processors behave like nonfaulty processors processors therefore total number nonfaulty processors least 2n gamma contradiction note possible anchor processor exists case luck chooses one nonfaulty processor anchor processor luck chooses single anchor processor anchor processors every nonfaulty processor executes jump procedure twice luck uses following strategy every time processor p j chooses clock value value clock possible choice ie either find reduced clock values list value chosen otherwise value clock j changed let c 1 first configuration reached c processor executes jump procedure least twice results according strategy luck let e 1 execution starts c ends c 1 since jumping period every nonfaulty processor chooses clock value least every period length occurs 2t c show c 1 nonfaulty processors within 2t r first show nonanchor processor p assigns value clock p clock either first execution jump procedure second one every processor collects clock values every execution jump procedure particular nonanchor processor p j receives value clock second execution jump procedure next show second execution jump procedure p j choose value clock choice p j restricted subset clock values p j read p j finds values within ffi range clock j since p j nonanchor processor holds c 1 less processors within ffi range clock j moreover nonfaulty processor assign clock value within range clock j since 1 every nonfaulty processor p k changes clock value use jump procedure assigns clock value ffl range clock 2 every nonfaulty processor p k change clock value use jump procedure rate drift clock p j 2ae thus difference clock j clock k shorten 2t j r c p j cannot consider p k clock ffi range clock j assigns clock j value clock proves c 1 nonanchor processors within ffl ae clock anchor processors assign clock value clock 2t r apart c thus 2t r fact nonfaulty processors within small range used define new anchor processor 0 0 nonfaulty processor left removing f nonfaulty processors highest clock values mod lc f nonfaulty processors smallest values mod lc c 1 every processor executes jump procedure least twice luck continues follows processor p process collecting clock values c 1 change clock first execution jump procedure execution jump function luck intervenes fix result clock 0 clock processor already set clock value 0 clock since c 1 prove possible result jump function obvious processor find processors within ffi clock since choice restricted also clear first set processors execute jump procedure use clock values c 1 base decision new clock value moreover since luck intervenes fixes results value clock 0 reduced list every processor uses new clock values includes either clock 0 clock processor assigned clock clock 0 hence first configuration c 2 follows first two executions jump function processors following c 1 nonfaulty processors within n aeae assumption 2 less ffi 8 following c 2 processor waiting answers process collecting clocks change clock value thus safe configuration reached length execution 2t j reached 2t j c 2 additional configuration reached thus safe configuration reached following ae c assumption 1 5t ae thus processor could choose six times range thus total number interventions lemma 43 configuration execution starts safe configuration clock values nonfaulty processors within ffi2 main observation made proof lemma starting safe configuration every processor either executes jumping averaging procedure finds clock values within ffi clock value thus new clock value chosen jumping averaging range clock values nonfaulty processors averaging procedure approximately halves range clock values nonfaulty processors whenever pass zero clock value theorem 44 expected ot n 6ngammaf stabilizes concluding remarks extensive research done find efficient clock synchronization protocols presence byzantine faults work considered severe realistic model faults ie one takes account transient faults well byzantine faults arbitrary corruption state possible often case transient faults longer reasonable approximate unbounded clocks bounded clocks matter large consequently clocks take bounded number values wrap around appropriate assumed paper presented two randomized selfstabilizing protocols synchronizing bounded clocks presence f byzantine processor failures n 3f believe observations definitions types faults considered type clocks namely bounded reflect reality open new directions research protocols designed fault tolerance model robust existing clock synchronization protocols therefore protocols might preferred system implementer protocols cope byzantine faults acknowledgment many thanks brian coan injong rhee swami natarajan helpful discussions r self stabilizing systems spite distributed control possibility impossibility achieving clock synchronization uniform dynamic self stabilizing leader election analyzing expected time schedulerluck games reaching approximate agreement presence faults waitfree clock synchronization unifying selfstabilization faulttolerance faulttolerant clock synchronization art computer programming synchronizing clocks presence faults byzantine generals problem inexact agreement accuracy precision graceful degradation faulttolerant clock synchronization distributed systems optimal clock synchronization residue arithmetic applications computer technology new faulttolerant algorithm clock synchronization tr synchronizing clocks presence faults reaching approximate agreement presence faults possibility impossibility achieving clock synchronization optimal clock synchronization new faulttolerant algorithm clock synchronization faulttolerant clock synchronization distributed systems waitfree clock synchronization unifying selfstabilization faulttolerance art computer programming volume 2 3rd ed inexact agreement byzantine generals problem selfstabilizing systems spite distributed control analyzing expected time schedulerluck games uniform dynamic selfstabilizing leader election extended absrtact faulttolerant clock synchronization ctr ariel daliot danny dolev selfstabilizing byzantine agreement proceedings twentyfifth annual acm symposium principles distributed computing july 2326 2006 denver colorado usa
instruction selection using binate covering code size optimization address problem instruction selection code generation embedded dsp microprocessors processors highly irregular datapaths conventional code generation methods typically result inefficient code instruction selection formulated directed acyclic graph dag covering conventional methods instruction selection use heuristics break dag forest trees cover independently breakup result suboptimal solutions original dag alternatively dag covering problem formulated binate covering problem solved exactly heuristically using branchandbound methods show optimal instruction selection dag case accumulatorbased architectures requires partial scheduling nodes dag augment binate covering formulation minimize spills reloads show irregular data transfer costs typical dsp datapaths modeled binate covering formulation b introduction increasingly common microarchitecture embedded systems integrate microprocessor microcontroller rom asic single ic microarchitecture currently found many diverse embedded systems eg fax modems laser printers cellular telephones programmable component embedded systems applicationspecific instruction processor asip generalpurpose microprocessor sparc microcontroller intel 8051 digital signal processor tms320c25 paper focuses dsp application domain embedded systems increasingly used many systems use processors tms320c2x dsp5600x adsp families fixedpoint dsp microprocessors irregular datapaths code size matters great deal embedded systems since program code resides onchip rom size directly translates silicon area cost designers often devote significant amount time reduce code size code fit available rom exceeding onchip rom size could require expensive redesign entire ic 7 result compiler automatically generates small dense code result significant productivity gain well believe generating best code embedded processors require traditional optimization techniques also new techniques take advantage special architectural features decrease code size paper presents one efforts developing techniques address problem instruction selection code generation embedded dsp microprocessors emphasize decreasing code size although techniques also increase execution speed instruction selection formulated directed acyclic graph dag covering conventional methods instruction selection use heuristics break dag forest trees covered optimally independently 1 3 independent covering trees may result suboptimal solution original dag trees heuristic formulation inherently preclude use complex instructions cases internal nodes shared alternatively dag covering problem formulated binate covering problem 11 solved exactly heuristically using branchandbound methods present basic binate covering formulation instruction selection section iii unlike heuristic formulation trees good heuristic procedure solving covering problem likely elude difficulties faced trees formulation section iii ignores data transfer costs nodes dag formulation used obtain preliminary instruction selection pattern dags cover two nodes given binary dag selected binary dag transformed general dag second step instruction selection taking account data transfer costs performed section iv generalize work aho et al 2 give binate covering formulation optimal code generation oneregister machine takes account spill reload costs next provide formulation section v takes account irregular data transfer costs general machine model ii motivating example fig 1 shows simplified model datapath texas struments popular tms320c25 architecture tms320c25 accumulatorbased machine addition usual alu separate multiplier takes input register memory places result p register note generalpurpose registers accumulator important feature architecture dsp architectures certain instructions assume operands specific locations registers memory deposit results specific registers example mpy instruction assumes multiplier multiplicand come memory register writes result p register another example addt instruction adds operand memory shifted amount specified register accumulator also unusual find complex instructions dsps typical examples include addwithshift eg tms320c25 add addt multiplyaccumulate eg dsp56000 mac utilizing instructions essential generating compact efficient code conventional heuristic breaking dag trees prohibits use complex instructions case internal nodes shared addition heuristic may introduce unnecessary stores intermediate values consider subject dag pattern dags shown fig 2 conventional treecovering first break dag node n 3 thereby prohibiting use pattern fig 3a shows result abus ar agu dbus mem alu acc x x fig 1 tms320c25 datapath simplified model cost b c fig 2 subject dag bd pattern dags ing treecover fig 3b shows optimal dag cover even pattern used treecovering may still result inefficient code instance using treecovering might first evaluate node n 3 store memory evaluate nodes n 1 n 2 however datapath fig 1 possible let intermediate result remain p register evaluate n 1 n 2 using instruction apac adds contents p register accumulator without destroying former sequel show solve problem selecting complex instructions problem data transfers using binatecovering formulation instruction selection first problem easily taken account basic dag covering formulation section iii second problem tackled section iv section v iii basic formulation formulation section assumes target machine data transfers registers registers memory zero cost subject dag corresponds basic block given program 3 subject dag covered using pattern dags correspond individual machine instructions pattern dag associated cost dag covering problem cover subject dag set pattern dags minimum cost b fig 3 two coverings subject dag fig 4 covering matrix three steps associated dag covering 1 matches pattern graphs subject graph generated 2 covering matrix created expresses conditions lead legal cover 3 cover minimum cost obtained using branchand bound algorithm alternatively heuristic methods used find covers low cost step 1 relatively straightforward pattern matching step boolean variable call corresponds successful match pattern graph subject graph g let nodes subject graph n node n j 2 g covered set matches possible matches 1 5 example subject dag marked fig 3 covering matrix column corresponds distinct match let columns rows correspond disjunctive clauses represent covering constraints basic dag covering formulation two different sets rows ie disjunctive clauses ffl rows first set represent different ways particular node n j 2 g covered using different matches subject graph fig 2a covering matrix shown fig 4 first row matrix node n 1 indicates node n 1 covered either match 2 match 4 indicated fig 3 therefore put 1s entry corresponding column 2 column 4 2s columns similarly next row indicates either 3 5 needs selected cover node n 2 note first set rows need clauses cover root nodes selection particular match necessitate selection matches cover nodes connected inputs see ffl matches allowed nodes internal match feed nodes match results second set rows match ensure nonleaf inputs match outputs matches nonleaf inputs mean internal nodes contrast primary inputs dag serve inputs nodes let nonleaf inputs match set matches k output node w k viewed disjunctive expression boolean variables corresponding match selecting match implies satisfy write expression translates clauses clauses corresponds distinct row covering matrix match generates additional rows nonleaf inputs covering matrix fig 4 second set rows correspond additional clauses match 2 implement nonleaf node n 3 output another match done using match 1 alone therefore generate clause corresponding third complemented clause put 0 entry corresponding column 2 put 1 entry corresponding column 1 2s columns fourth row generated match 3 selected would require selection 1 cost match costm simply cost associated pattern dag step 3 select set columns covering matrix cumulative cost columns minimum every row either 1 entry corresponding selected column 0 entry corresponding unselected column example end selecting 4 5 minimum total cost 1 corresponds covering fig 3b reader verify selecting 4 disjunctive clauses fig 4 aside note tree covering methods would able discover optimal solution fig 3b since subject dag would broken three trees covered independently would result covering fig 3a cost problem called binate covering problem variables present true complemented forms problem npcomplete received considerable attention exact solutions given 5 9 techniques improved recently 6 without compromising optimality heuristic methods given 8 9 first solve binate covering problem zero data transfer costs determine matches use pattern dags one operator eg pattern dag fig 2b original dag modified reflect use complex operators thus new dag nodes two inputs second step binate covering performed new dag accurately models spill data transfer costs step described next two sections iv focus oneregister machines accumulatorbased archi tectures architectures accumulator spills memory reloads memory account large fraction structions binate covering formulation must take cost account order find optimal instruction selection major complication modeling memory spills spilling values depends chosen instruction schedule 10 however since performing instruction selection yet know schedule therefore choose instructions determine partial schedule instructions binate covering partial schedule determined adding boolean variables corresponding adjacency constraints pairs nodes dag connected edge previous work 2 aho et al presented optimal code generation algorithms dags two different models oneregister machines noncommutative machines available operations 1 op 2 load 3 store denotes accumulator denotes memory commutative machines available operations 1 op 2 op 3 load 4 store find models inadequate following reasons first application given dag ternary higher arity operators depending complex patterns chosen first step binate covering second noncommutative model 2 take commutative operators account example evaluating expression b c value b must first loaded accumulator added c however b c expressions accumulator may already contain c immediately evaluation b addition commutative adding accumulator b perfectly acceptable commutative model hand assumes first operand operation memory general machines commutative noncommutative operators believe best way handle commutativity treat operation independently using separate pattern commutative forms operations wherever necessary rather assuming commutativity machine model present compact binatecovering formulation optimal code generation noncommutative oneregister machine taking account commutativity individual operators following sections operators binary ternary higher arity operators ease exposition concentrate binary operators however techniques generalize higherarity operators b definitions let h directed graph ucycle h set edges would form cycle edges considered undirected h contains ucycle said ucyclic otherwise uacyclic use terms dacyclic dcyclic dcycle case directions edges considered worm directed path dag nodes path appear consecutively schedule 2 wormpartition set disjoint worms edge said selected respect wormpartition belongs worm partition associated wormpartition directed graph g node g corresponds worm edge nodes g whenever edge node worm w 1 node worm w 2 think deriving g given wormpartition successively merging nodes connected selected edges imploding edge wormpartition said legal valid schedule derived g nodes worm appear consecutively schedule henceforth shall denote original expression dag g induced graph wormpartition sufficient condition wormpartition legal g dacyclic 2 condition however always necessary see theorem 4 adehi c g schedule b adeh fg ci f g adeh fg ci b g f ac hi schedule ac f bdeg hi denotes worms fig 5 worms schedules adag wormpartition derived schedule b another wormpartition schedule c illegal wormpartition fig 5 illustrates concepts worms wormpartitions relation scheduling graph shaded nodes g b two different wormpartitions dag along corresponding schedules shown schedules derived scheduling g expanding nodes g back nodes note schedule nodes worm placed consecutively c illegal wormpartition shown partition gives rise cycle g schedule exists places nodes worm consecutively c fundamental adjacency clauses selection edge indicates headnode tailnode placed adjacently schedule following fundamental adjacency clauses fundamental clauses must b fig 6 reconvergence dag worm b cycle g due worm node multiple fanouts one fanout edges may selected node multiple fanins one fanin edges may selected clearly fundamental clauses necessary wormpartition legal dag simply stated schedule node may one immediate predecessor one immediate successor let e boolean variable takes value 1 edge selected 0 otherwise fundamental clauses node n every pair fanout edges j n every pair fanin edges j n satisfy clause generated cost ek equal zero however choosing ek imply spilling reloading associated costs described section ive following theorem shows fundamental clauses sufficient uacyclic dags theorem 1 subject dag uacyclic fundamental clauses sufficient words wormpartition satisfies fundamental clauses legal proof uacyclic selecting edge merging head tailnodes edge results dag remains uacyclic repeating process cannot possibly create ucycle therefore merging nodes according selected edges wormpartition ucycle much less dcycle appear g implies wormpartition legal ucycles fundamental clauses become sufficient good example one reconvergent paths fig 6 note hand selecting edge part ucycle create dcycle g thus need focus writing additional clauses ucycles clauses ucycles since ucycles may lead dcycles g need add clauses prevent happening let c ucycle arbitrarily choose direction traversal c forward direction label edges forward backward accordingly theorem 2 forward edges backward edges u cycle selected imploding selected edges result dcycle conversely least one forward edge least one backward edge selected ucycle remains dacyclic implosion proof edges ucycle selected imploded ucycle backward edges remain since g nodes nodes worms fig 7 dcycle g always find ucycle produced edges imploded ucycle direction imploded ucycle also dcycle least one forward edge least one backward edge selected imploded ucycle least two edges pointing opposite directions hence imploded ucycle remains dacyclic therefore necessary cycle select edges orientation possible even selected edges satisfy condition every cycle including composite cycles still dcycle g possible dcycle g arises another cause ucycles following theorem shows impossible thereby establishing sufficiency condition theorem 3 g dcyclic exists ucycle forward edges backward edges selected therefore clauses derived theorem 2 satisfied every ucycle g dacyclic wk nodes dcycle g also denote corresponding worms definition g exist nodes edge similarly exist edges nodes worm path one direction denote p path v u ucycle furthermore regardless orientations paths p ucycle every edge direction opposite e selected recall edges p selected edges turns compactly write clauses require least one forward edge one backward edge selected follows fk boolean variables forward edges ucycle clause ensure edges selected similar clause written backward edges hence two clauses ucycle suffice new variables introduced formulation merely additional clauses one important exception needs made regarding selfloops g addressed 2 consider portion dag shown fig 8 choose path abcd forward edges ucycle dcycle results g accordance theorem 2 however dcycle self loop easily verified worm thus chosen actually b abcd fig 8 portion dag selected worm b induced selfloop g legal schedule abcd nodes worm namely ad appear consecutively admissible example shows selfloops make wormpartition illegal lemma theorem follow state formally lemma 1 let c selfloop g corresponding ucycle must consist two reconvergent paths furthermore u v endpoints reconvergent paths one paths must edge u v proof loopedge c corresponds single edge node u worm node v worm edge u v another path p u v worm respect u must predecessor v otherwise dag would dacyclic thus two reconvergent paths edge u v path p theorem 4 dcycles wormpartition g selfloops g legal conversely dcycle g contains one node g illegal proof selfloops arise solely kind reconvergent paths described lemma 1 long path part worm thus schedule nodes consecutively precedence relation required edge u v violated hand one node dcycle g scheduling nodes one worm consecutively unsuccessful node current worm depends node another worm turn depend current worm light theorem 4 clauses 2 required selfloops instead clause consisting single variable requiring edge u v selected prescribedclearly choosing edge would lead nontrivial dcycle g hand reconvergent path single edge eg operator takes operands node neither cycle reconvergenceclauses necessarythe fundamental clauses described section ivc ensure one edges selected e clauses reloads spills depending operation takes operands edges selected spills reloads may required computations describe precisely write clauses activate spills reloads fig 9a shows fragment dag consider edge cb whose corresponding boolean variable e 2 four cases consider edge 1 match 1 used e left operand accumulator b immediately c acc mem acc b c fig 9 spilling reloading according adjacency nodes spill c reload edge cb necessary 2 match 1 used e case spill c required node b immediately follows c destroys contents accumulator value needed b later also reload necessary immediately b scheduled 1 takes leftoperand accumulator 3 match 2 used e immediately follows c spill still required 2 takes left operand memory reload necessary 4 match 2 used e previous case spill required let spillc denote match transfers value c accumulator memory immediately c computed reloadcb denote match loads value c memory accumulator immediately b scheduled express conditions following clauses similar clauses prescribed edge e 1 well every node possible matches given dag complex patterns selected fundamental clauses ucycle clauses clauses reloads spills added clauses node matches clauses node matches simple oneregister machine since choices node inputs come shown fig 9 v target architecture assume target architecture modeled conveniently 1 1 model 4 1 1 model resource class assumed either one element infinite number elements resource classes one element perform separate pass storage allocation scheduling 12 shown section ii typical fixed point dsp irregular datapaths certain registers specialized uses consequently completion operation results may available use another operation takes operands registers example mpy operator requires one operands come treg register memory thus data transfer necessary move operands desired registers tree covering methodology models cost transfer modeled associating cost unit production production nonterminal left rightsides section show incorporate data transfers binate covering formulation addacc preg fig 10 data transfers b example consider fragment expression dag fig 10 operation covered match 3 requires left operand come memory right operand come treg register however match 1 produces result preg register match 4 transfers contents preg register memory required hence write require selection match 4 event 1 3 selected similar clauses also prescribed matches node 1 c constructing clauses based example section vb describe general procedure constructing clauses necessary data transfers add clauses clauses summarized end section iv every pair nodes n 1 n 2 given dag connected edge possible match n 1 possible match j n 2 write matching q ij indicates transfer result match location required j results writing operand memory j requires reading register preg q ij correspond match moves data memory preg similarly moves across different register classes writes register acc j reads register acc ij disjunction adjacency constraint output node input node j spillreload match cf section ive assume adjacency constraint satisfied schedule guarantee correct data transfer without spillreload satisfying adjacency constraint necessary correct data transfer multipleregister machines inbetween instructions exist write registers acc however relaxing assumption would require lifetime analysis registers large number clauses instruction selection partial scheduling using binate covering optimized complete schedule generated exploits lifetime analysis cases due datapath constraints possible move contents one location another location via single move example suppose direct path preg register memory way accomplish move preg memory accumulator case two moves required q ij represent conjunction two corresponding matches fig 11 matches altering fundamental clauses b e fig 12 ucycle dag b modified ucycle vi discussion presented twopass strategy first step selects complex operators second step selects matches minimize data transfer costs transformed dag steps performed simultaneously solving single binate covering problem answer yes number clauses binate covering become large reason selection complex operators affects fundamental adjacency clauses clauses ucycles fundamental clauses corresponding marked edges dag fig 11 e 1 however match selected fundamental clauses become incorporated writing following clauses done match corresponds complex pattern covers edge dag manner 1 covers e 3 example dag uacyclic fundamental clauses sufficient modification enough however ucycle clauses modified general case modification result large number clauses since choosing complex pattern change ucycles dag understand consider fig 12 match 2 selected fig 12a effect dag modified one shown fig 12b new ucycle beginning node means write clauses corresponding new ucycle match 2 selected note ucycles begin level 1 nodes dag ie nodes whose inputs leaves new ucycles introduced due complex operators even new ucycle generated still modify original ucycle clauses since edge e covered 2 fundamental clause case vii ongoing work presented formulation instruction selection problem binate covering formulation captures data transfer memory spill costs commonly associated dsp processors preliminary experiments indicate exact binate covering applied smalltomoderate sized basic blocks tms320c25 processor optimal solutions better produced tree covering heuristic many cases large basic blocks entire procedures however computationally efficient heuristic strategies required two avenues explored first large basic blocks broken simpler blocks covered using exact binate covering algorithm second heuristics restrict number matches therefore clauses covering matrix investigated viii acknowledgements thank richard rudell olivier coudert help binate covering formulation research supported part advanced research projects agency contract dabt63 94c0053 part nsf young investigator award matching funds mitsubishi corporation r optimal code generation expression trees code generation expressions common subexpressions optimal code generation embedded memory nonhomogeneous register architectures boolean relations incomplete specification logic networks new ideas solving covering problems art programming embedded systems minimization tant networks method minimizing number internal states incompletely specified machines code optimization techniques embedded dsp microprocessors logic synthesis vlsi design memory bank register allocation software synthesis asips tr compilers principles techniques tools code optimization techniques embedded dsp microprocessors new ideas solving covering problems optimal code generation embedded memory nonhomogeneous register architectures memory bank register allocation software synthesis asips optimal code generation expression trees code generation expressions common subexpressions art programming embedded systems ctr markus lorenz peter marwedel phase coupled code generation dsps using genetic algorithm proceedings conference design automation test europe p21270 february 1620 2004 rainer leupers code selection media processors simd instructions proceedings conference design automation test europe p48 march 2730 2000 paris france rainer leupers peter marwedel function inlining code size constraints embedded processors proceedings 1999 ieeeacm international conference computeraided design p253256 november 0711 1999 san jose california united states rainer laupers hdlbased modeling embedded processor behavior retargetable compilation proceedings 11th international symposium system synthesis p5154 december 0204 1998 hsinchu taiwan china mahesh mehendale g venkatesh sherlekar optimized code generation multiplicationfree linear transforms proceedings 33rd annual conference design automation p4146 june 0307 1996 las vegas nevada united states rainer leupers register allocation common subexpressions dsp data paths proceedings 2000 conference asia south pacific design automation p235240 january 2000 yokohama japan marnix arnold henk corporaal automatic detection recurring operation patterns proceedings seventh international workshop hardwaresoftware codesign p2226 march 1999 rome italy stan liao srinivas devadas solving covering problems using lprbased lower bounds proceedings 34th annual conference design automation p117120 june 0913 1997 anaheim california united states raul camposano behavioral synthesis proceedings 33rd annual conference design automation p3334 june 0307 1996 las vegas nevada united states steven bashford rainer leupers constraint driven code selection fixedpoint dsps proceedings 36th acmieee conference design automation p817822 june 2125 1999 new orleans louisiana united states marnix arnold henk corporaal designing domainspecific processors proceedings ninth international symposium hardwaresoftware codesign p6166 april 2001 copenhagen denmark graphbased code selection techniques embedded processors acm transactions design automation electronic systems todaes v5 n4 p794814 oct 2000 j van praet lanneer w geurts g goossens processor modeling code selection retargetable compilation acm transactions design automation electronic systems todaes v6 n3 p277307 july 2001 ashok sudarsanam sharad malik masahiro fujita retargetable compilation methodology embedded digital signal processors using machinedependent code optimizaton library readings hardwaresoftware codesign kluwer academic publishers norwell 2001 jason cong yiping fan guoling han zhiru zhang applicationspecific instruction generation configurable processor architectures proceedings 2004 acmsigda 12th international symposium field programmable gate arrays february 2224 2004 monterey california usa stefan schfer bernhard scholz optimal chain rule placement instruction selection based ssa graphs proceedingsof 10th international workshop software compilers embedded systems april 2020 2007 nice france lars rder clausen ulrik pagh schultz charles consel gilles muller java bytecode compression lowend embedded systems acm transactions programming languages systems toplas v22 n3 p471489 may 2000 ashok sudarsanam sharad malik simultaneous reference allocation code generation dual data memory bank asips acm transactions design automation electronic systems todaes v5 n2 p242264 april 2000 amir hormati nathan clark scott mahlke exploiting narrow accelerators datacentric subgraph mapping proceedings international symposium code generation optimization p341353 march 1114 2007 david j kolson alexandru nicolau nikil dutt ken kennedy optimal register assignment loops embedded code generation acm transactions design automation electronic systems todaes v1 n2 p251279 april 1996 nathan clark jason blome michael chu scott mahlke stuart biles krisztian flautner architecture framework transparent instruction set customization embedded processors acm sigarch computer architecture news v33 n2 p272283 may 2005 guido araujo sharad malik code generation fixedpoint dsps acm transactions design automation electronic systems todaes v3 n2 p136161 april 1998 nathan clark amir hormati scott mahlke sami yehia scalable subgraph mapping acyclic computation accelerators proceedings 2006 international conference compilers architecture synthesis embedded systems october 2225 2006 seoul korea milenko drini darko kirovski hoi vo code optimization code compression proceedings international symposium code generation optimization feedbackdirected runtime optimization march 2326 2003 san francisco california chunho lee johnson kin miodrag potkonjak william h mangionesmith media architecture general purpose vs multiple applicationspecific programmable processor proceedings 35th annual conference design automation p321326 june 1519 1998 san francisco california united states nathan clark hongtao zhong scott mahlke processor acceleration automated instruction set customization proceedings 36th annual ieeeacm international symposium microarchitecture p129 december 0305 nathan clark hongtao zhong scott mahlke automated custom instruction generation domainspecific processor acceleration ieee transactions computers v54 n10 p12581270 october 2005 chunho lee johnson kin miodrag potkonjak william h mangionesmith exploring hypermedia processor design space journal vlsi signal processing systems v27 n12 p171186 feb 2001 milenko drini darko kirovski hoi vo ppmexe program compression acm transactions programming languages systems toplas v29 n1 p3es january 2007
constructing compact models concurrent java programs finitestate verification technology eg model checking provides powerful means detect concurrency errors often subtle difficult reproduce nevertheless widespread use technology developers unlikely tools provide automated support extracting required finitestate models directly program source paper explore extraction compact concurrency models java code particular show static pointer analysis traditionally used computing alias information optimizers used greatly reduce size finitestate models concurrent java programs b introduction finitestate analysis tools eg model checkers automatically detect concurrency errors often subtle difficult reproduce tools applied software finitestate model program must constructed model must accurate enough verify requirements yet abstract enough make analysis tractable paper consider problem constructing models concurrent java programs consider java explosion internet applications java stands become dominant language writing concurrent software new generation programmers writing concurrent applications first time encountering subtle concurrency errors heretofore plagued mostly operating system telephony switch developers java uses monitorlike mechanism thread synchronization simple describe difficult use correctly colleague teaching concurrent copyright c fl1998 association computing machinery inc permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit direct commercial advantage copies bear notice full citation first page copyrights components work owned others acm must honored abstracting credit permitted copy otherwise republish post servers redistribute lists requires prior specific permission andor fee java programming found half students wrote programs nested monitor deadlocks ideally analysis tool could extract model program use model verify property program eg freedom deadlock practice extracting concurrency models difficult automate completely order obtain model small enough tractable analysis analyst must assist existing tools specifying aspects program model particular representation certain variables often necessary make model sufficiently accurate variables must often abstracted restricted make analysis tractable although model restricts range variable represent possible behaviors program thus cannot technically used verify program property conventional wisdom concurrency errors present small versions system6 9 thus models still useful finding errors testing previous work concurrency analysis software used ada 7 13 12 2 3 8 although aspects methods also applied java programs java language presents several new chal lengesopportunities 1 due objectoriented style typical java pro grams variables need represented fields heap allocated objects stack statically allocated variables common ada 2 java threads must created dynamically thus impossible general determine many threads program create although ada tasks may created dynamically many concurrent ada programs contain statically allocated tasks 3 java locking mechanism synchronize access shared data exploited reduce size model main contribution paper show static pointer analysis used reduce size finitestate models concurrent java programs method employs virtual coarsening 1 wellknown technique reducing size concurrency models collapsing invisible actions eg updates variables local protected lock adjacent visible actions static pointer analysis used construct approximation runtime structure heap statement information used identify heap objects actually local thread locks guard access variables paper organized follows first provide brief overview javas concurrency features section 2 section 3 defines formal model transition systems section 4 explains size models reduced virtual coarsening given certain information runtime heap structure available explain collect information using static pointer analysis section 5 section 6 shows use heap structure information apply reductions finally section 7 concludes concurrency java javas essential concurrency features illustrated familiar bounded buffer system shown figure 1 java threads instances class thread subclass thereof created using allocator ie new constructor thread takes parameter object implementing interface runnable essentially means object method run thread started calling start method thread executes run method object although threads may assigned priorities control scheduling paper assume modeled threads equal priority scheduled ar captures possible executions example program begins execution static method main main thread creates instance intbuffer creates instances producer consumer point intbuffer creates instances thread point producer consumer starts threads execute run methods producer consumer producer consumer threads putget integers shared buffer two types synchronization bounded buffer problem first access buffer mutually exclusive every java object implicit lock thread executes synchronized statement must acquire lock object named expression executing body statement releasing lock body exited lock unavailable thread block lock released acquiring lock current object method body common idiom may abbreviated simply placing keyword synchronized methods signature second type synchronization involves waiting callers put must wait space buffer callers get must wait buffer nonempty entry precondition operation checked false thread blocks object executing wait method releases lock method changes state object way precondition might true executes notifyall method wakes threads waiting object threads must reacquire objects lock returning wait 3 formal model model concurrent java program finitestate transition system state transition system abstraction state java program transition represents execution code transforming abstract state formally transition system pair heap structure thread thread consumer producer intbuffer int data buf buf public class intbuffer protected int data protected int count 0 protected int public intbufferint capacity new intcapacity allocate array datalength size array capacity public void putint x synchronized count datalength buffer full datafront count 1 buffer empty public int get synchronized count wait wait buffer empty int count datalength 1 notifyall buffer full return x public class producer implements runnable protected int next 0 next int produce protected intbuffer buf public void run true public class consumer implements runnable protected intbuffer buf public void run true int public class main public static void mainstring args new new threadnew producerbufstart new threadnew consumerbufstart figure 1 bounded buffer example transformations state variables loc1 loc2 location thread 12 lock state lock 0 free 1 taken x value program variable x initially 1 thread 1 1 lock 2 3 unlock 4 thread 2 5 lock state space fragment state loc1 loc2 lock x figure 2 example transition system dn set states state assignment values finite set state variables ranges finite domain transition relation defined set guarded transformations state variables called guard boolean predicate states called transformation map states states g true sometimes write trace transition system sequence transitions method constructing transition system representing java program similar method presented 5 constructing untimed transition system representing ada program state variables used record current control location thread values key program variables runtime information necessary implement concurrent semantics eg whether thread ready running blocked object transformation represents execution bytecode instruction thread depthfirst search state space used enumerate reachable states anal ysis state successor generated ready thread representing threads execution small example figure 2 gives flavor translation java heap must also represented bound number states model limiting number instances class including thread may exist simultaneously paper assume limits provided analyst class c instance limit kc program attempts allocate instance class c point kc instances still accessible java uses garbage collection transition system goes special trap statethe model represent behavior program beyond point discussed introduc tion restricted model still useful finding errors consider bounded buffer example figure 1 could generate restricted model program representing variables restricting ranges restricting variables representing contents buffer f0 1g variables representing size buffer f0 1 2g would obtain restricted interesting model program ie one would likely contain concurrency errors reductions transition system produced method sketched section 3 much larger required analyses often large construct instead construct reduced transition system use analysis reduce size transition system using virtual coarsening 1 wellknown technique reducing size concurrency models amalgamating transitions since using interleaving model concurrency reducing number transitions thread greatly reduces number possible states eliminating interleavings collapsed transition sequences reduced transition system constructed classifying transformation defining visible invisible composing maximal sequence invisible transformations given thread visible transformation following sequence transitions states generated composed transformations form example figure 2 might replace transformations t2 t3 single transformation t2 ffi t3 updates x releases lock could eliminate control location 3 domain loc1 assume requirement verified tested specified stutteringinvariant formula f linear temporal logic ltl 11 atomic propositions state variable 2 statement true state transition system useful reduced transition system 1 equivalent original transition system purpose verification specifically 2 2 constructible directly program without first constructing note reduced model constructed specific thus reduction must repeated property verified classify transformation invisible compose successor transformations show cannot change truth value f constructed applying temporal operators state predicates boolean combinations atomic propo sitions let pm state predicates f fobservation state denoted pf vector booleans giving value transformation fobservable change fobservation trace s0 defines sequence f observations reduce combining consecutive identical ie stuttered fobservations easy show set reduced fobservation sequences determines truth value f s0 therefore satisfy condition 1 construct reduced transition system set reduced fobservation sequences original transition system satisfy condition 2 must without constructing must classify transformations vis ibleinvisible based information obtained program code give two cases transformations representing java code made invisible cases need information structure heap runtime apply reduction show collect information section 5 41 local variable reduction state variables accessed particular thread running example program variables locally scoped particular thread language seman tics also state variable recording control location thread accessed thread transformations access exclusively state variables may made invisible provided fobservable understand consider transformation figure 3 assume fobservable accesses variables local thread whose code represents let 0 represent code thread executed immediately following code represented replace 0 ffi 0 multiple successors say replace 0 prove reduction change truth value f must show resulting transition system set reduced fobservation sequences original transition system state s1 enabled may one sequences transformations representing execution code threads ie thread combining 0 eliminates traces occurs 0 eliminate reduced fobservation sequences however since executing must produce reduced f observation sequence executing accesses variables t1 independent commutes state s1 enabled fobservable trace obtained executing must reduced fobservation sequence trace obtained executing use technique would like determine variables local particular java thread ie referenced thread program variable local thread 1 variable stack allocated ie declared method body formal parameter 2 variable statically allocated referenced one thread 3 variable heap allocated ie instance variable object object accessible one thread example variable next class reduction reduction figure 3 reduce combining 0 producer figure 1 accessible producer thread case 1 trivial detect case 2 difficult due dynamic nature thread creation though following conservative approximation reasonable static variable may considered local accessed code reachable 1 main code reachable single run method class passed thread allocator allocator outside loop recursive procedure example variable next static member class producer since variable accessed code reachable producers run method since one instance producer created analysis could determine next local producer thread case 3 difficult clearly object containing variable accessible stack statically allocated variables local specific thread cases 1 2 heap allocated variable also local thread determining requires information accessibility heap objects runtime 42 lock reduction propose another technique virtual coarsening based javas locking mechanism transformation updates variable x instance class c may made invisible provided fobservable exists object x thread accessing x holding lock x x may instance c containing x say lock x protects x intuition behind reduction even though threads may access x cannot current thread releases lock x thus changes x need visible lock released correctness reduction shown using diagram figure 3 reasoning similar local variable reduction assume nonlocal variables accesses protected locks thread whose code represents must hold locks variables s1 therefore although exist transformations representing code threads accesses variables transformations cannot sequence since thread would block reaching transformations assuming f reference state shared ob ject reduction allow us represent complex updates objects two transformations bounded statement reachable statement 0 exists path programs control flow graph 0 ie thread might execute executing 0 heap structure object programmer object salarylock hourslock public class programmer protected long hours 80 protected double salary 500000 protected object hourslock new object protected object new object public void updatehourslong newhours synchronized public void updatesalarydouble newsalary synchronized figure 4 example splitting locks buffer example execution put get updates several variables yet represent call transformation acquires lock transformation atomically updates state buffer releases lock order apply reductions need determine locks protect variables clearly instance variable class accessed within synchronized methods class variable protected lock object contained nevertheless common variables protected locks objects instance bounded buffer example array object referenced instance variable data protected lock enclosing intbuffer object common design pattern known containment 10 object x conceptually 2 nested object placing reference x accessing x within methods another common design pattern locks protect variables objects splitting locks 10 class might contain independent sets instance variables may updated concurrently case acquiring lock entire instance would excessively limit potential parallelism instead set instance variables lock usually instance root class object example given figure 4 two threads could concurrently update programmers hours salary general determining locks protect variables requires information structure heap runtime collecting information topic next section 5 reference analysis section describe static analysis algorithm constructs approximation runtime heap struc ture collect information needed reductions understanding runtime heap structure important problem compiler optimization since accurate knowledge aliasing improve many standard java allow physical nesting objects optimizations one common approach construct directed graph program statement represents finite conservative approximation heap structure control paths ending statement several different algorithms proposed differing method approximation algorithm extension simple algorithm given chase et al 4 uses basic approach extend chases algorithm three ways first handle chases algorithm sequential code second distinguish current summary heap nodes allows us collect information onetoone relationships objects third handle arrays 51 program reference analysis represent multithreaded program set control flow graphs cfgs whose nodes represent statements whose arcs represent possible control steps one cfg thread one cfg main method kc identical cfgs run method class c recall kc instance limit class c paper handle interprocedural anal ysis assume procedure method calls inlined limits analysis programs statically bounded recursion polymorphic calls inlined using switch statement branches based objects type tag since tag modeled analysis methods call might dispatch explored algorithm require concept loop block statement let loops innermost enclosing loop statement nested within null loop set fs 0 jloops loopsg called loop block analysis models reference variables values references pointers heap objects heap object contains fixed number fields references heap objects model fields reference type class instances number fields equals number instance variables reference type possibly zero arrays number fields equals zero array primitive type one array references latter case array elements represented single field named java references manipulated four ways new allocator returns unique new reference field selected field updated references checked equality last operation irrelevant analysis 52 storage structure graph storage structure graph ssg finite conservative approximation possible pointer paths heap particular statement two types nodes ssg variable nodes heap nodes one variable node statically allocated reference variable stack allocated reference variable scope one two heap nodes allocator eg new c program depending location statement relation within loop block different threadcfg ssg contains current node represents current instance class cthe instance allocated current iteration loop block statements ssg contains summary node represents x f f z f 1c 2c 2c class c class two fields c xyz stack variables method body 1 2 3 4 5 figure 5 ssg statement 4 summarized instances class call instances allocated completed iterations loop block heap node fixed number fields edges may directed edge ssg statement represents possible reference value edges directed variable nodes fields heap nodes towards heap nodes general one edge may leave variable node heap node field since different paths may result different values reference even one path may multiple edges leaving summary node array field since nodes represent multiple variables runtime example ssg shown figure 5 elide parts code relevant analysis prepend line numbers simple statements identification variable nodes shown circles heap nodes rectangles slot field heap nodes labeled name class prefixed statement number allocator summary nodes suffixed asterisk thus 2c represents summary node allocator class c statement 2 often omit disconnected nodes eg summary node allocator loop note linked list represented self loop node 2c like chase et al 4 distinguish objects class allocated different allocators heuristic based observation objects allocated given allocator tend treated similarly example employee meeting objects might contain nested date object allocated respective constructors ie two date allocators distinguishing two kinds date objects analysis could determine date inside employee cannot affected date inside meeting updated conservative ssg statement contains following information structure heap runtime 1 exists edge node variable x heap node allocator execution path ending ie executed thread cfg x may point object allocated otherwise x cannot point object allocated 2 exists edge field f current heap node allocator b heap node allocator execution path ending f field current instance allocated b may point object allocated otherwise f field current instance allocated b cannot point object allocated 3 exists edge field f summary heap node allocator b heap node allocator execution path ending f field summarized instance allocated b may point object allocated otherwise summarized instance allocated b whose f field points object allocated 4 three cases heap node allocator current node reference must current instance allocated otherwise reference summarized instance allocated note useful information lack edge one graph precise another strict subset edges 53 algorithm use modified dataflow algorithm compute statement conservative ssg edges possi ble initially statement ssg edges worklist initialized contain start statement main step statement removed head worklist processed possibly updating ssgs statement statements cfgs edges added statements ssg successors statement cfg dependent statements cfgs added tail worklist one statement dependent another may reference variable runtime select static variable instance variable algorithm terminates worklist empty process statement employ three operations ssgs join step summarize first compute pre ssg statement joining ssgs immediate predecessors cfg ssgs joined taking union edge sets anypaths analysis pre ssg updated step operation discussed manner reflecting semantics statement produce postssg finally statement last statement loop block postssg summarized produce new version statements ssg otherwise postssg new version summarize ssg redirecting edges tofrom current nodes allocators within loop block corresponding summary nodes see ssgs statement 6 figure 6 step operation uses abstract interpretation update ssg abstract representation runtime heap according statements semantics assignments reference variables need considered statements cannot add edges ssg ie postssg equals pressg pointer expression lvalue rvalue defined follows lvalue variable variables node lvalue field selector expression xf set f fields nodes rvalue x rvalue expression set heap nodes pointed expressions lvalue case allocator current node allocator semantics assignment whether left hand side stack variable local static variable e1 either stack variable local static vari able perform strong update removing edges node lvaluee1 adding edge node lvaluee1 node rvaluee2 otherwise perform weak update simply adding edge nodefield lvaluee1 node rvaluee2 edges added statements ssg step summarize operation also added ssgs statements cfgs assume threads may scheduled arbitrarily thus statement another thread may witness reference value execution thread allocator new threadx treated assignment x special field runnable thread object reflects inlining constructor thread let x set classes object referenced x might belong ie subclasses type x allocator processed add worklist start statement every cfg run method class x ie start statement cfg implicitly dependent every thread allocator might start 3 thread cfg run method class c accesses instance variable current object eg expression next producers run method figure 1 rvalue set heap nodes class c pointed runnable fields heap nodes class thread ie associate given threadcfg specific thread allocator 54 computing onetoone relationships summarized information gathered analysis sufficient lock reduction ssg edge summary node allocator summary node allocator b indicates objects allocated may point objects allocated b need know object allocated points different object allocated b would holding lock object protect variable access nested b object conservatively estimate information ssgs summarized updated follows edge summary node summary node b marked onetoone points different b runtime b loop block edge field summary node summary node b first added ssg summarize operation marked onetoone field summary node subsequently updated step operation way another edge summary node b would added edge longer marked onetoone method based observation nested objects almost always allocated loop block enclosing object often enclosing objects con structor given constructor loop body allocates object allocates one nested objects links objects together onetoone relationships objects recorded ssg arcs current nodes allocators nodes summarized end loop block information preserved annotations arcs summary nodes fact motivation distinguishing 3 technically thread started start method called since using thread scheduling informa tion assuming thread starts allocated produces ssgs current summarized instancesnodes 55 example consider java source figure 6 first ssg figure 6 postssg statement 6 first time processed ie summary information exists second ssg result summarizing ssg note since nodes 3b 5a summarized together arc field a2 3b 5a labeled onetoone 11 since 2a current node onetoone relationship field a1 3b 2a would loop added around code 2a summarized last ssg final ssg statement 9 end method statement 7 thread allocated may access allocated statement 2 statement 8 a1 field b may point allocated statement 5 note stack variable b scope statement 9 thus removed ssg arc 2a 0a added statement 0 placed worklist statement 7 processed although shown final ssgs statements 18 ssgs would contain arc even though reference value represents cannot appear statement 7 thread scheduling information considered 56 complexity given program statements v variables allocators algorithm must construct ssgs containing ov nodes ov 2 edges running time process statement worst proportional total number edges ssgs number times statement processed fixpoint reached thus worst case running time os 2 v 4 number statements inlining procedure calls could produce exponential blowup number statements despite complexity anticipate cost reference analysis prohibitive first based application algorithm several small examples believe average complexity much lower ssgs generally sparse many edges typical ssg would violate javas type system could generated analysis also edges added statements ssg processed thus statement typically processed times second v refer number modeled statements variablesin typical analysis fraction program mod eled reference analysis model variables primitive ie nonreference types need model statements manipulating variables exclusively also program requirement might involve small subset programs classes rest program need represented 6 applying reductions section explain use information collected reference analysis apply local variable lock reductions class implements runnable a3 void run 0 new class a1 a2 new class main static void main 2 new 3 new ba inlined constructor 4 5 new 7 new threadastart else 8 x 5a x x 5a a3 0a a3 0a a3 0a 2a 5a 9 final 2a 5a summary first iteration 2a 3b a3 a3 a3 a3 a3 3b 3b summary 7thread 3b a3 a3 figure reference analysis example 61 local variable reduction applying local variable reduction straightforward set heap nodes ssg local given thread accessible stack static variables local thread heap variables accessed expressions form refid ref reference expression id name instance variable variable accessed expression local thread nodes rvalue ref local thread pressg statement note heap variables may local statements nonlocal others common idiom object allocated initialized made available threads eg intbuffer object example figure 1 reference analysis determine instance variables object local object made available threads 62 lock reduction applying lock reduction complex need determine whether variable protected lock general relationship variable lock protects may elaborate determine static analysis propose heuristic believe widely applicable particular works locking design patterns given 10 heuristic assumes relationship object containing variable object containing lock matches following general pattern either lock object accessible variable object vice versa accessible third object lock variable object pattern expressed terms three roles root lock variable lock object contains lock variable object contains variable root object two objects accessible role must played exactly one object one object may play multiple roles expression datai bounded buffer example intbuffer object root lock object int array referenced data variable object expression count intbuffer object plays three roles expression salary splitting locks example figure 4 programmer object plays root variable roles object referenced salarylock plays role lock consider static variables fields special environment object called env play roles variable root role lock generalizes pattern include case lock object variable object accessible static variables case variable static also fully qualify expressions prepending expressions accessing variables current instance prepending env static variable accesses staticheap variable want determine whether exists lock protects variable ie thread accessing variable must holding lock static variables represented variable nodes heap variables fields heap nodes locks heap nodes ssg essentially use expressions accessing variable lock identify lock object interpret expressions abstractly using ssgs formally staticheap variable v want compute protectv set locks protecting v v let accessv set program expressions may access v sets constructed reference analysis expression ev accessv compute protectv ev set locks thread holding ev protecting v since lock must protect variable everywhere lock summary node variable must field summary node interpretation variable object protected unique lock object given expression ev accessing v compute lock expression ev argument enclosing synchronized statement e define triple er root expression common prefix e ev lock selector part e sv variable selector part ev er final selector removed ie ersv reference object containing v v exam ple consider expression hours method updatehours figure 4 fully qualified expression 4 accessing variable thishours lock expression thishourslock pair yields triple hourslock note indicates lock root objects indicates variable root objects given ev er sv identify candidate lock ssg follows ssg node n selector ns set nodes reached n following field object nsg set ssg nodes applying selector nodes may reach object containing variable v first pressg ev compute set possible root objects ev access v r contains exactly one node node candidate root r compute set possible locks pressg e l contains exactly one node node candidate lock include protectv ev deduce ssgs instance v runtime unique instance held thread note follow immediately since r ssg nodes paths r r v might represent multiple objects runtime nevertheless still conclude variable represented v runtime unique lock represented following true 1 variable represented v runtime unique root object represented r holds r current node arcs path selected sv onetoone arcs summary nodes 2 root object represented r runtime unique lock object represented 4 analysis method inlined variable replaced new temporary holding implicit param eter addition simple propagation analysis used allow recognition pattern even multiple selectors decomposed series assignments eg xfg expressed holds provided current node arcs path selected onetoone arcs summary nodes variable v protected protectv nonempty transformation may made invisible fobservable variables might access protected local note inaccuracy reference analysis leads larger model incorrect model cannot determine variable local protected lock transformation accessing variable visible transition system states still represent behaviors possibly restricted program 63 example consider bounded buffer example figure 1 ssgs statements producer consumer run methods isomorphic heap structure shown top figure would also nodes stack variables ssgs deduce variable next producer object local producer thread thus formula f depend next transformation incrementing next may invisible also bounded buffer example variable data array object instance variables intbuffer class protected lock intbuffer object thus formula depend variables sequence transformations representing methods put get may combined two transformations one acquire lock update variables release lock although complete program shown splitting locks example figure 4 allocator programmer would produce ssg subgraph isomorphic heap structure shown top figure arcs summary programmer node object nodes would onetoone analysis could determine instance variable hours protected object accessible via field hourslock 7 conclusion proposed method using static pointer analysis reduce size finitestate models concurrent java programs method exploits two common design patterns java code data accessible one thread encapsulated data protected lock process extracting models source code must degree depended source language although presentation restricted java many aspects method widely applicable could used reduce finitestate models programs heap data andor monitorlike synchronization primitive eg adas protected types method currently implemented part tool intended provide automated support extracting finitestate models java source code although empirical data methods performance time effectiveness virtual coarsening reducing concurrency models well known manual application method several small examples suggests many transitions made invisible typical formula arrival java concurrent programming entered mainstream finitestate verification technology offers powerful means find concurrency errors often subtle difficult reproduce unfortunately extracting finitestate model program required existing verifiers tedious errorprone result widespread use technology unlikely extraction compact mathematical models real software artifacts largely automated methods like one described essential support extraction acknowledgements thanks due george avrunin helpful comments draft paper r formalization properties parallel programs automated analysis concurrent systems constrained expression toolset compositional verification model checking counter examples analysis pointers structures timing analysis ada tasking pro grams protocol verification hardware design aid using state space reduction methods deadlock analysis ada tasking data flow analysis verifying properties concurrent programs elements style analyzing software design feature counterexample detector concurrent programming java design principles patterns checking finite state concurrent programs satisfy linear specifica tions static infinite wait anomaly detection polynomial time tr integrated concurrency analysis software development enviornment analysis pointers structures automated analysis concurrent systems constrained expression toolset using state space reduction methods deadlock analysis ada tasking data flow analysis verifying properties concurrent programs compositional verification model checking counterexamples elements style timing analysis ada tasking programs checking finite state concurrent programs satisfy linear specification concurrent programming java protocol verification hardware design aid ctr james c corbett matthew b dwyer john hatcliff shawn laubach corina psreanu robby hongjun zheng bandera extracting finitestate models java source code proceedings 22nd international conference software engineering p439448 june 0411 2000 limerick ireland gleb naumovich george avrunin lori clarke data flow analysis checking properties concurrent java programs proceedings 21st international conference software engineering p399410 may 1622 1999 los angeles california united states klaus havelund mike lowry john penix formal analysis spacecraft controller using spin ieee transactions software engineering v27 n8 p749765 august 2001 gleb naumovich george avrunin lori clarke efficient algorithm computing mhp jonathan aldrich emin gn sirer craig chambers susan j eggers comprehensive synchronization elimination java science computer programming v47 n23 p91120 may jongdeok choi manish gupta mauricio serrano vugranam c sreedhar sam midkiff escape analysis java acm sigplan notices v34 n10 p119 oct 1999 pramod v koppol richard h carver kuochung tai incremental integration testing concurrent programs ieee transactions software engineering v28 n6 p607623 june 2002 james c corbett using shape analysis reduce finitestate models concurrent java programs acm transactions software engineering methodology tosem v9 n1 p5193 jan 2000 john whaley martin rinard compositional pointer escape analysis java programs acm sigplan notices v34 n10 p187206 oct 1999 jongdeok choi manish gupta mauricio j serrano vugranam c sreedhar samuel p midkiff stack allocation synchronization optimizations java using escape analysis acm transactions programming languages systems toplas v25 n6 p876910 november premkumar devanbu stuart stubblebine software engineering security roadmap proceedings conference future software engineering p227239 june 0411 2000 limerick ireland john penix willem visser seungjoon park corina pasareanu eric engstrom aaron larson nicholas weininger verifying time partitioning deos scheduling kernel formal methods system design v26 n2 p103135 march 2005
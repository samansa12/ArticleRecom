certifying compilation runtime code generation certifying compiler takes source language program produces object code well certificate used verify object code satisfies desirable properties type safety memory safety certifying compilation helps increase compiler robustness program safety compiler robustness improved since compiler errors caught checking object code certificate immediately compilation program safety improved object code certificate alone sufficient establish safety even object code certificate produced unknown machine unknown compiler sent untrusted network safe execution guaranteed long code certificate pass verifierexisting work certifying compilation addressed statically generated code paper extend code generated run time goal combine certifying compilation runtime code generation produce programs fast verifiably safe achieve goal present two new languages explicit runtime code generation constructs cyclone type safe dialect c talt type safe assembly language designed implemented system translates safe c program cyclone compiled talt finally assembled executable object code paper focuses overall approach front end systemsemi details talt appear subsequent paper b introduction 11 runtime specialization specialization program transformation optimizes program respect invariants technique shown give dramatic speedups wide range appli cations including aircraft crew planning programs image shaders operating systems 4 11 17 runtime specialization exploits invariants become available execution program generating optimized code fly opportunities runtime specialization occur dynamically changing values remain invariant period time example networking software specialized particular tcp connection multicast tree runtime code generation tricky hard correctly write reason code generates code obvious optimize debug program yet generated early examples runtime code generation include selfmodifying code ad hoc code generators written hand specific function mind approaches proved complicated error prone 14 recent work applied advanced programming language techniques problem new source languages designed facilitate runtime code generation providing programmer highlevel constructs compiler implement lowlevel details 15 21 22 program transformations based static analyses capable automatically translating normal program runtime code generating program 6 10 12 type systems check runtime code generating programs compile time ensuring certain bugs occur run time provided compiler correct 22 25 techniques make easier programmers use runtime code generation address concerns compiler writer end user compiler writer still needs implement correct compilernot easy even language without runtime code generation end user would like assurance executables crash machine even programs generate code jump itbehavior usually provokes suspicion securityconcious users address concerns another programming language technique certifying compilation 12 certifying compilation certifying compiler takes source language program produces object code certificate may help show object code satisfies certain desirable properties 16 18 separate component called verifier examines object code certificate determines whether object code actually satisfies properties wide range properties verified including memory safety unallocated portions memory accessed control safety code entered valid entry points various security properties eg highly classified data appear low security channels often properties corollaries type safety appropriate type system object code paper describe certifying compiler cyclone highlevel language supports runtime code generation cyclone compiled talt assembly language supports runtime code generation cyclone talt type safe certificates system type annotations talt output verifier talt type checker compiler writers motivated implement cyclone certifying compiler believe approach enhances compiler correctness example forced develop type system operational semantics talt provides formal framework reasoning object code generates object code run time eventually hope prove compiler transforms type correct source programs type correct object pro grams important step towards proving correctness compiler meantime use verifier type check output compiler get immediate feedback compiler introduces type errors others noted 23 24 helps identify correct compiler bugs quickly also wanted certifying compiler address safety concerns end users system type safety depends certificate object code method produced thus end user rely programmer cyclone compiler ensure safety makes system usable basis securitycritical applications like active networks mobile code systems 13 cyclone compiler cyclone compiler built two existing systems specializer 19 popcorn certifying compiler 16 three phases shown fig 1 first phase transforms type safe c program cyclone program uses runtime code generation starts applying static analyses tempo system c program context information specifies function arguments invariant tempo front end produces actionannotated program added additional pass translate actionannotated program cyclone runtime specializer second phase verifies cyclone program type safe compiles talt modified popcorn compiler morrisett et al popcorn compiles type safe dialect c tal typed assembly language extended front end popcorn handle cyclone programs modified back end outputs talt talt tal extended instructions manipulating templates code fragments parameterized holes corresponding types compilation phase transforms highlevel cyclone constructs lowlevel assembly instructions also transforms cyclone types talt types third phase first verifies type safety talt program type system talt ensures templates combined correctly holes filled correctly paper describes overall approach front end detail details talt appear subsequent paper finally talt program assembled linked executable three phase design offers flexible user interface since allows programs written c cyclone talt simplest case user simply write c program reuse existing program allow system handle rest user desires explicit control code generation process may write modify cyclone program finegrain control de sired user finetune talt program produced cyclone write one hand note since verification performed talt level program cyclone verify compile cyclone verify assemble link executable translate actionannotated program cyclone figure 1 overview cyclone compiler safety properties guaranteed three cases 14 example present example illustrates runtime code generation phases cyclone compiler fig 2 shows modular exponentiation function mexp written standard c arguments base value exponent modulus modular exponentiation often used cryptography key used encrypt decrypt several messages function called repeatedly exponent modulus thus mexp benefit specialization specialize function respect given exponent modulus user indicates two arguments invariant function called repeatedly values invariant arguments fig 2 invariant arguments shown italics static analysis propagates information throughout program producing actionannotated program actions describe language construct treated specializa tion constructs depend invariants evaluated specialization constructs displayed italics second part figure understand runtime specialization works c code invariant arguments italics int mexpint base int exp int mod f int u u1 actionannotated code italicized constructs evaluated int mexpint base int exp int mod f int u specialized source code int mexp spint base f int figure 2 specialization source level helpful first consider specialization could achieved entirely within source language example specialized function mexp sp fig 2 obtained actionannotated mexp exponent 10 modulus 1234 italicized constructs mexp like loop evaluated note loop test depends known arguments nonitalicized constructs mexp show source code mexp sp constructs evaluated mexp sp called depend unknown argument think mexp sp constructed cutting pasting together fragments source code mexp fragments templates central idea used designing cyclone cyclone type safe dialect c extended four constructs manipulate templates codegen cut splice fill using constructs possible write cyclone function generates specialized version mexp run time int int mexp genint exp int mod f int u return codegen int mexp spint base f int cut splice splice figure 3 runtime specializer written cyclone fact system automatically generate cyclone runtime specializer actionannotated pro gram fig 3 shows cyclone specializer produced actionannotated modular exponentiation function fig 2 function mexp gen takes two invariant arguments original mexp function returns function mexp sp version mexp specialized arguments figure italicized code evaluated mexp gen called nonitalicized code template code manipulated mexp gen produce specialized function template code evaluated specialized function called example codegen expression begins code generation process allocating region memory new function mexp sp copying first template region template includes declarations function argument base local variables also initial assignments recall template code evaluated code generation process merely manipulated cut statement marks end template introduces code italicized evaluated code generation namely loop test body including conditional statement splice state ments shiftassignment statement evalu ated loop finishes template following cut statement containing returns added code generation region evaluating splice statement causes template appended code generation region example time first splice statement executed assignment appended similarly time second splice statement executed assignment ap pended effect loop thus add number assignment statements code mexp sp exactly many ones determined arguments mexp gen fill expression used within template marks hole template fille encountered template e evaluated code generation time value used fill hole template example fill used insert known modulus value assignment statements code generation complete newly generated function mexp sp returned result codegen takes one remaining argument mexp compute result cyclone programs evaluated symbolically produce specialized source programs like one fig 2 basis formal operational semantics give appendix implementation however compile cyclone source code object code compile source templates object templates cyclone object code manipulates object templates directly object code talt extension tal instructions manipulating object templates talt instructions x86 machine instructions new template instructions cgstart cgdump cgfill cghole start template end example cyclone program fig 3 compiled talt program shown fig 4 omitted instructions save space added source code fragments comments aid readability beginning mexp gen contains x86 instructions adding local variable u stack assigning value argument exp next cgstart used dynamically allocate code generation region first template dumped copied region cgdump instruction next body loop unrolled cyclone splice statement compiled cgdump instruc tion followed instructions computing hole values cgfill instruction filling hole end mexp gen function final cgdump instruction outputs code last template next comes code four templates first template allocates stack space local variables assigns values second third templates come statements contained within cyclone splice instructions ie multiplications mods assignments final template contains code returns cghole instruction introduces placeholder inside template filled specialization described summary designed system performing type safe runtime code generation following parts ffl c actionannotated program translation actionannotated program cyclone translation ffl cyclone language design ffl cyclone verifier ffl cyclone talt compiler ffl talt language design ffl talt verifier mexpgen mov esp0eax 1st template ifend24 mov eaxesp0 mov esp0eax whileend22 cgend eax retn 1st template mov esp0eax templatestart splcbeg25splcend26 templateend splcend26 templateend splcend32 templatestart cutbeg36cutend37 add esp8 retn templateend cutend37 figure 4 talt code ffl talt assembly translation ffl assemblerlinker parts able reuse existing software specifically used tempo actionannotated program generation microsoft masm assembling microsoft visual c linking parts extend existing work case cyclone language type system verifier compiler talt language components needed written scratch including translation actionannotated program cyclone pro gram definition new talt instructions terms x86 instructions weve organized rest paper follows section 2 present cyclone language type sys tem section 3 give brief description talt due limited space defer full description later pa per give implementation details initial impressions performance section 4 discuss related work section 5 future work section 6 final remarks section 7 21 design decisions cyclones codegen cut splice fill constructs designed express templatebased style runtime code generation cleanly concisely made design decisions based cyclones relationship c programming language implementation concerns first runtime specializer function returns function result need higher order types cyclone c higher order types written using pointer types cyclone pointers fore introduce new notation higher order types cyclone example int floatint fint x cyclone function f takes int argument x returns function taking float int returning int f declared defined use int int floatint f note type first argument appears left remaining arguments consistent order arguments would appear c using pointer types second design decision concerns extent support nested codegens consider following example int float int fint x returncodegen int int gfloat returncodegen int hint z body h f function generates function g using codegen called run time turn g generate function h time called nested codegens thus used generate code generates code first version tempo support code generates code though recently extended sys tems c 20 21 also prohibit decided permit cyclone adds little complication type system implementation nested codegens generated automatically cyclone version tempo use programmer always explicitly final design decision concerns extent cyclone support lexically scoped bindings last example function h nested inside two func tions f g language true lexical scoping arguments local variables outer functions would visible within inner function f x g could used body h decided would support full lexical scoping cyclone scoping rule body function function arguments local variables toplevel variables visible keeping cs character lowlevel machine systemsoriented language operators language close provided machine cost executing program hidden highlevel abstractions felt closures lambda lifting standard techniques supporting lexical scoping would stray far lexical scoping desired programmer introduce explicit closures lexical scoping achieved using cyclone features example needed body h accessed using filly 22 syntax typing rules formalize core calculus cyclone full cyclone addition structures unions arrays void break continue loops use x range variables c range con stants b range base types implicit signature assigning types constants speak type c figure 5 gives grammars programs modifiers types declarations sequences declarations function definitions f statements expressions e write ffl type function defined modifier function definition xd declares x type ffl e sometimes consider sequence declarations finite function variables types assumes x distinct achieve alpha conversion neces sary imposing standard syntactic restrictions cyclone programs names function formal parameters must distinct global variables distinct names define type environments e support cyclones scoping rules local global local local informally type environment sequence hidden visible frames followed outermost frame gives vis outermostt figure cyclone environment functions programs modifiers types declarations x decl sequences function defns f xd statements e return e splice expressions e x figure 5 grammar core cyclone type top level function types local vari ables types global variables nonoutermost frames contain type function generated run time types parameters local variables function e type environment write e vis visible declarations e e vis defined figure 6 informally definition says declarations first nonhidden frame global declarations vis ible declarations visible note vis sequence declarations may write e vis x type x e figure 6 also defines two important operations environments rtypee return type function first nonhidden frame e environment obtained adding declaration local declarations first nonhidden frame typing rules cyclone given figure 7 interesting rules codegen cut splice fill codegen expression starts process run time code generation type codegent xd environment e type body function environment makes function x parameters visible body enclosing func tion parameters local variables hidden expression fille appear within tem plate typing rule ensures looking envi ronment must form framet xd 0 expression fille typed e typed environment function generated codegen well parameters local variables hidden computing value fill hole necessary parameters local variables become available function called available hole filled rules cut splice similar like fill cut invoked within template changes frame hidden reason fill splice dual cut changes frame hidden cut back visible frame thus splice introduces template cut interrupts template p wellformed program wellformed statement type constant c figure 7 typing rules cyclone operational semantics cyclone safety theorem given appendix output cyclone compiler program talt extension typed assembly language tal morrisett et al 16 designing talt primary concern retain lowlevel assembly language character tal tal instructions x86 machine structions possibly annotated type information exceptions macros malloc would difficult type expanded form macro expands short sequence x86 instructions since instruction simple trusted components systemthe typing rules verifier macrosare also simple gives us high degree confidence correctness safety system tal already instructions powerful enough generate code run time malloc move sufficient problem approach types malloc region code type clearly end code generation process type tal code jumped start code generation safe jump must different type moreover type region change move instructions tal type system powerful enough show sequence malloc move instructions results tal program safely jumped solution talt extension tal types macros manipulating templates since paper focuses cyclone front end system sketch ideas talt full details appear subsequent paper tal procedure label address sequence tal instructions procedure called jumping label address type procedure precondition says entry x86 registers contain values particular types example procedure return precondition saying return address accessible stack pointer jumped talt template also label sequence instructions unlike tal procedure however template meant jumped example might need concatenated another template form tal procedure thus type template includes postcondition well precondition typing rules template instructions talt ensure template dumped code generation region precondition matches postcondition previous template dumped also template may holes need filled types holes also given type template type code generation region similar template includes types holes remain filled region precondition first template dumped postcondition last template dumped holes filled template postcondition dumped region type consisting precondition ie type tal procedure point code generation finished result jumped int fint x returncodegen int gint return int hint xint returncodegen int kint figure 8 example showing two codegen expressions executing called h starts generating k stops middle call f generates g give brief description new talt macros intended informal description showing macro go beyond already talthe macros low level remain close machine code macros manipulate implicit stack code generation regions region stack used function generated codegen stack needed possible two codegen expressions executing example see figure 8 ffl cgstart initiates runtime code generation allocating new code generation region new region pushed onto stack code generation regions becomes current region cgstart macro complicated malloc copies template label l current code generation region execution register r points copy template used fill holes copy cgdump complicated macro core simple stringcopy loop must also check current code generation region enough room copy template enough room cgdump allocates new region twice size old region copies contents old region plus new template new region replaces old region new region stack complex talt instruction consisting roughly twenty x86 instructions ffl cghole r l template l hole move instruction containing hole used template label l template declares hole l hole ffl cgfill r1 l template l hole r2 fills hole tem plate simple move instruction register r1 point copy template label l template hole label l hole register r2 contains value put hole ffl cgfillrel fills hole template pointer second template like cgfill expands simple move instruction needed jumps templates int f returncodegen int gint cut return 4 figure 9 example shows need cgabort called function f starts generating function g aborts middle returns 4 ffl cgabort aborts code generation pops top region region stack needed runtime code generation function stops middle example figure 9 cgend r finalizes code generation process current region popped region stack put register r tal jump location r implementation status describe key aspects implementation previously mentioned components written scratch others realized modifying existing software 41 actionannotated program cyclone translate tempo actionannotated programs runtime specializers written cyclone using tempo front end lets us automatically generate cyclone program c program actionannotated program distinguishes two kinds code normal code executed specializa tion indicated italics fig 2 template code emitted specialization nonitalicized code annotated c program translated cyclone program uses codegen cut splice fill since italicized constructs executed code generation occur outside codegen within cut statement fill expression nonitalicized constructs placed within codegen expression splice statement algorithm operates two modes normal mode translates constructs executed code generation time template mode translates constructs part template algorithm performs recursive descent actionannotated abstract syntax keeping track mode starts normal mode produces cyclone code beginning runtime specializer arguments invariants local variables initial statements annotated italics first nonitalic construct encoun tered codegen expression issued putting translation template mode rest program translated follows italic statement expression must translated normal mode therefore translation tem plate mode insert cut processing statement fill processing expression switch normal mode similarly nonitalic statement translated template mode insert splice switch modes necessary isnt possible encounter nonitalic expression within italic expression another step needs taken translation since specialization speculative ie branches conditional statement optimistically specialized conditional test cannot evaluated means specialization store needs saved prior specializing one branch restored specializing branch therefore must introduce cyclone statements save restore store translating conditional statement solution used tempo 6 42 cyclone talt compile cyclone talt extended existing com piler popcorn compiler morrisett et al popcorn written caml compiles type safe dialect c tal typed assembly language 16 currently popcorn simple stack based compiler though extended register allocation sophisticated optimizations popcorn compiler works performing traversal abstract syntax tree emitting tal code goes uses environment data structure following form argsonstack int environment maintains execution state function compiled field local env contains variable identifier corresponding stack offset arguments pushed onto stack prior entry function body field args stack records number arguments popped stack upon exiting function compile cyclone needed extend environment datatype first cyclone switches generating normal code template code second cyclone nested functions therefore use environments structure environments used cyclones typing rules outermost env id list frame env cycloneenv hidden env cycloneenv environments sequences type frames func tions frame either outermost normal hidden type environment visible bindings defined e vis section 2 outermost frame contains local environment toplevel function well global identifiers frame used compiling template code new frame environment created time codegen encountered frame becomes hidden switch back normal mode cut fill encountered popcorn programs compiled traversing abstract syntax tree translating popcorn construct appropriate tal instructions resulting sequence tal instructions compiled program compiling cyclone program however complicated performed two phases first phase alternates generating normal template talt instructions second phase rearranges instructions put proper place order instructions rearranged second phase first phase interleaves special markers talt instructions mtemplatebeg id id mfill id exp markers used indicate instructions normal belong within template used fill holes templatebeg takes two arguments beginning ending label template issued beginning template codegen splice encountered cut ends similarly templateend issued end template end codegen splice beginning cut note corresponding templatebeg templateend markers templates may begin end therefore markers nested hole encountered fill marker issued first argument fill label hole inside template second argument cyclone source code expression fill hole following example shows cut statement compiled match stmt cut match cycloneenv outermost raise error cgfillholes hiddenenvcycloneenv emitmarkmtemplatebegidnew idnew b hidden raise error function compile stmt takes cyclone statement environment emits talt instructions sideeffect first thing notice cut occur compiler template mode case environment begins frame cut statement ends template therefore cg fill holes called emits templateend marker emits talt code dump template fill holes filling holes must done using normal environment therefore first frame becomes hidden next compile stmt called recursively compile statement within cut since statement also compiled normal mode also keeps first frame hidden finally templatebeg marker emitted compilation constructs following cut occur within new template second phase code generation uses markers rearrange code talt instructions issued templatebeg templateend marker extracted made template remaining normal instructions concatenated make one function hole filling instructions inserted instruction dumps template contains hole example fig 4 shows talt program second phase completed normal code includes instructions dump templates fill holes followed templates 43 talt executable tal translated assembly code expanding tal macro sequence x86 instructions similarly new talt macros expand sequence x86 tal instructions description talt macro given section 3 resulting x86 assembly language program assembled microsoft masm linked microsoft visual c linker 44 initial impressions implemented system started testing programs assess strengths weaknesses since currently lot interest specializing interpreters decided explore type application program stateoftheart program specializer tempo typically achieves speedup 2 20 depending interpreter program interpreted see system compares took bytecode interpreter available tempo distribution ran system preliminary results show cyclone achieves speedup 3 encouraging since roughly speedup tempo achieves similar programs precise comparison two systems still needs done however hand initial implementation cost generating code higher tempo one possible reason safety allocate code generation regions run time perform bounds checks dump templates approach taken tempo choosing maximum buffer size compile time allocating buffer size faster safe 5 related work propagating types stages compiler front end back end shown aid robust compiler construction checking type safety stage quickly identifies compiler bugs 23 24 additionally necula lee shown proving properties assembly language level useful safe execution untrusted mobile code 18 far approach taken statically generated code system intended achieve goals dynamically generated code many ideas cyclone derived tempo runtime specializer 7 12 13 designed cyclone talt templatebased approach mind use tempo front end automatic template identi fication another runtime specializer dyc shares features static analyses templatelike back end 5 9 10 however important differences cyclone systems tried make compiler robust tempo dyc making cyclone type safe using types verify safety compiled code like tempo dyc cyclone automatically construct specializers ad dition cyclone also gives programmer explicit control runtime code generation via codegen cut splice fill constructs even possible us handtweak specializers produced tempo front end complete type safety like dyc perform optimizations intertemplate code motion since writing compiler tempos strategy using unmodified existing compiler limits optimizations perform mlbox metaml c systems add explicit code generation constructs existing languages ml box metaml type safe dialects ml 15 25 22 c unsafe dialect c 20 21 three systems features combining code fragments go beyond provide cyclone example c possible generate functions n arguments n value computed run time possible cyclone mlbox metaml hand c cannot generate function generates function done cyclone using nested codegens also mlbox metaml advantage gain sophisticated features manipulating code fragments simplicity example cyclone type system need new type code fragments fundamental difference however overall system present provide type safety source level also object level makes system robust makes usable proof carrying code system 6 future work paper presented framework performing safe robust runtime code generation compiler based simple stackbased certifying compiler written morrisett et al extending compiler register allocation standard optimizations expect merge cyclone improvements interested studying templatespecific optimiza tions example templates appear explicitly talt plan study intertemplate optimizations code motion templates performing inter template optimizations difficult system like tempo based existing compiler aware templates also interested analyses could statically bound size dynamic code generation region would let us allocate exactly right amount space begin generating code function would let us eliminate bounds checks template dumps would like extend front end tempo takes cyclone c input would mean extending analyses tempo handle cyclone nlevel language like mlbox additionally may implement analysis gluck jrgensen 8 produce nlevel cyclone c cyclone 7 conclusion designed programming language compiler combines dynamic code generation certified com pilation system cyclone following features robust dynamic code generation existing dynamic code generation systems prove safety source level approach extends object code means bugs compiler produce unsafe runtime specializers caught compile time specializer run extremely helpful complexity analyses transformations involved dynamic code generation flexibility safety cyclone produces dynamic code generators exploit runtime invariants produce optimized programs user interface flexible since final executable generated c program cyclone program talt assembly code type safety statically verified three cases safe execution untrusted dynamic mobile code generators approach used extend proofcarrying code system include dynamic code generation since verification occurs prior run time runtime cost incurred safety guarantees sophisticated optimization techniques employed certifying compiler resulting system could produce mobile code safe potentially extremely fast acknowledgements able implement cyclone quickly worked existing tempo tal implementations wed like thank charles consel tempo group greg morrisett tal group making possible paper improved feedback julia lawall anonymous referees r partial evaluation aircraft crew plan ning general approach runtime specialization application c fast bindingtime analysis multilevel specialization dyc expressive annotationdirected dynamic compiler c specializing shaders static analyses effective specialization realistic applications accurate bindingtime analysis imperative languages flow case runtime code generation lightweight runtime code gener ation system f typed assembly language fast optimized sun rpc using automatic program specialization design implementation certifying compiler tcc system fast design implementation code optimizations typedirected compiler standard ml tr ctr george c necula peter lee design implementation certifying compiler acm sigplan notices v39 n4 april 2004 christopher colby peter lee george c necula fred blau mark plesko kenneth cline certifying compiler java acm sigplan notices v35 n5 p95107 may 2000 ingo strmer integration code generation approach modelbased development process means tool certification journal integrated design process science v8 n2 p111 april 2004 hongxu cai zhong shao alexander vaynberg certified selfmodifying code acm sigplan notices v42 n6 june 2007 scott thibault charles consel julia l lawall renaud marlet gilles muller static dynamic program compilation interpreter specialization higherorder symbolic computation v13 n3 p161178 sept 2000 cristiano calcagno walid taha liwen huang xavier leroy implementing multistage languages using asts gensym reflection proceedings second international conference generative programming component engineering p5776 september 2225 2003 erfurt germany simon helsen bisimilarity region calculus higherorder symbolic computation v17 n4 p347394 december 2004
interpolation automatization frege systems interpolation method one main tools proving lower bounds propositional proof systems loosely speaking one prove particular proof system feasible interpolation property generic reduction usually applied prove lower bounds proof system sometimes assuming usually modest complexitytheoretic assumption paper show method cannot used obtain lower bounds frege systems even tc0frege systems specifically show unless factoring blum integers feasible neither frege tc0frege feasible interpolation property order carry argument show carry proofs many elementary axiomstheorems arithmetic polynomialsized tc0fregeas corollary obtain tc0frege well proof system polynomially simulates automatizable assumption factoring blum integers hard also show hardness assumption kprovability problem frege systems hard b introduction one important questions propositional proof complexity show family propositional tautologies requiring superpolynomial size proofs frege extended frege proof system problem still open thus important question understand techniques applied prove lower bounds systems well weaker systems recent years interpolation method one promising approaches proving lower bounds propositional proof systems bounded arithmetic show method likely work frege systems weaker systems basic idea behind interpolation method follows department lsi universidad politecnica de cataluna barcelona spain bonetlsiupces research partly supported eu hcm network console esprit ltr project 20244 alcomit cicyt tic980410c0201 tic980410c0201 department computer science university arizona tonicsarizonaedu research supported nsf grant ccr9457782 usisrael bsf grant 9500238 grant int9600919me103 nsf smt czech republic z department applied math weizmann institute ranrazwisdomweizmannacil research supported usisrael bsf grant 9500238 begin unsatisfiable statement form f x z denotes vector shared variables x vectors private variables formulas 0 1 respectively since f unsatisfiable follows truth assignment ff z either 0 x ff unsatisfiable 1 ff unsatisfiable interpolation function associated f boolean function takes assignment ff input outputs 0 unsatisfiable 1 1 unsatisfiable note 0 1 unsatisfiable case either answer suffice hard compute interpolation function given unsatisfiable statement f shown among things interpolation functions always computable polynomial time unless nevertheless possible procedure exists special cases particular interesting fruitful question whether one find whether exists polynomial size circuit interpolation function case f short refutation proof system say proof system admits feasible interpolation whenever polynomial size refutation formula f interpolation function associated f polynomial size circuit krajicek k2 first make connection proof systems feasible interpolation circuit complexity also monotone version interpolation idea namely conjunctive normal monotone variables z occur positively 1 negatively 0 case associated interpolant function monotone thus interested finding polynomial size monotone circuit interpolant function say proof system admits monotone feasible interpolation whenever polynomial size refutation monotone f monotone interpolation function associated f monotone polynomial size circuit beautiful connections exist circuit complexity proof systems feasible interpolation monotone nonmonotone cases monotone case superpolynomial lower bounds proven sufficiently strong proof system admits feasible interpolation presented sequence papers ipu bpr k1 first used bpr prove lower bounds propositional proof systems idea also implicit razb2 short statement f used clique interpolation formula 0 g xa 1 g 0 states g graph containing clique size k clique described x variables 1 states g graph colored coloring described variables pigeonhole principle formula unsatisfiable however associated monotone interpolation function would take input graph g distinguish graphs containing cliques size k colored circuit exponential size thus exponential lower bounds follow propositional proof system admits feasible monotone interpolation similar ideas also work case admits feasible interpolation necessarily monotone feasible interpolation first result razb2 gives explicit superpolynomial lower bounds sufficiently strong proof systems admitting feasible interpolation cryptographic assumption particular shown nonmonotone interpolation function associated certain statement expressing p 6 np computable polynomial size circuits exist pseudorandom number generators therefore lower bounds follow sufficiently strong propositional proof system admits feasible interpolation conditional cryptographic assumption exist pseudorandom number generators also possible prove nonexplicit superpolynomial lower bounds sufficiently strong proof system assumption np computable polynomial sized circuits many researchers used ideas prove lower bounds propositional proof systems particular last five years lower bounds shown following systems using interpolation method resolution bpr cutting planes ipu bpr pud ch generalizations cutting planes bpr k1 k3 relativized bounded arithmetic razb2 hilberts nullstellensatz ps polynomial calculus ps lovasz schriver proof system pud3 11 automatizability kprovability explained previous paragraphs existence feasible interpolation particular proof system gives rise lower bounds feasible interpolation moreover important paradigm proof complexity general several reasons section wish explain lack feasible interpolation particular proof system implies automatizable say proof system automatizable exists deterministic procedure takes input formula f returns refutation f one exists time polynomial size shortest refutation f automatizability crucial concept automated theorem proving proof complexity mostly interested length shortest proof whereas theorem proving also essential able find proof seemingly powerful systems propositional calculus extended resolution even zfc scarce theorem proving seems difficult search efficiently short proof systems words seems tradeoff proof simplicity automatizability simpler proof system easier find proof section formalize tradeoff certain sense particular show feasible interpolation automatizable first observed russell impagliazzo idea show automatizable using deterministic procedure feasible interpolation theorem 1 proof system feasible interpolation automatiz able proof suppose automatizable suppose deterministic procedure find proofs moreover guaranteed run time n c n size shortest proof input formula let 0 x z 1 z interpolant statement let ff assignment z want output interpolant function 0 x ff 1 ff first run 0 x z 1 z obtain refutation size next simulate 0 x ff steps return 0 produces refutation 0 x ff chosen maximum time produce refutation formula refutation size thus c case works case 1 ff satisfiable satisfying assignment fl plug fl refutation 0 x ff 1 ff obtain refutation 0 x ff size therefore feasible interpolation ut thus feasible interpolation simple measure formalizes complexitysearch trade existence feasible interpolation implies superpolynomial lower bounds sometimes modulo complexity assumptions whereas nonexistence feasible interpolation implies proof system cannot automatized concept closely related automatizability kprovablity ksymbol provability problem particular frege system follows problem determine given propositional formula f number k whether ksymbol proof f k line provability problem determine whether k line proof f k line provability undecidable problem firstorder logic b1 first complexity result kprovability problem propositional logic provided buss b2 proved rather surprising fact ksymbol propositional provability problem np complete particular frege system recently abmp show ksymbol k line provability problems cannot approximated within linear factors variety propositional proof systems including resolution frege systems unless methods paper show ksymbol k line provability problems cannot solved polynomial time tc 0 frege system frege system extended frege system assuming hardness factoring blum integers precisely using idea show polynomial time algorithm solving kprovability problem feasible interpolation suppose unsatisfiable statement first run first verifies size proof f fixed value c let ff assignment z run determine ossymbol osline refutation 0 x ff return 0 accepts fact proof extended easily show ksymbol k line provability problems cannot approximated within polynomial factors proof systems tc 0 frege frege extende frege hardness assumption 12 interpolation one way functions one prove certain propositional proof system admit feasible interpolation one idea due krajicek pudlak kp use one way permutations following way let h one way permutation let 0 x z 1 z following formulas formula th bit x 0 formula th bit 1 since h one one 0 x z 1 z unsatisfiable assume 0 1 formulated proof system exists polynomial size refutation 0 x z 1 z admits feasible interpolation follows given assignment ff z exists polynomial size circuit decides whether 0 x ff unsatisfiable 1 ff unsatisfiable obviously circuit breaks th bit input h since constructed bits input h broken hence assuming input h secure proof system exists polynomial size refutation 0 1 follows admit feasible interpolation major step towards understanding feasible interpolation made krajicek pudlak kp considered formulas 0 1 based rsa cryptographic scheme showed unless rsa secure extended frege systems feasible interpolation open however whether negative results hold frege systems weaker systems bounded depth threshold logic bounded depth frege 13 results paper prove frege systems well constantdepth threshold logic referred admit feasible interpolation unless factoring blum integers computable polynomial size circuits recall blum integers integers p primes p 1 mod result significantly extends kp weaker proof systems addition cryptographic assumption weaker prove result use variation ideas kp conversation moni naor observed cryptographic primitive needed one way permutation kp general structure bit commitment formulas 0 1 based diffiehellman secret key exchange scheme dh simplicity state formulas least significant bit argument works bit informally propositional statement dh common variables two integers xy p g p represents number necessarily prime length n g element group z private variables 0 integers b private variables 1 integers c informally 0 say g mod ab mod p even similarly 1 say g cd mod p odd statement 0 1 unsatisfiable since informally 0 1 true ab mod show informal proof made formal polynomial size proof hand interpolant function computes one bit secret key exchanged diffiehellman procedure thus tc 0 frege admits feasible interpolation bits secret key exchanged diffiehellman procedure broken using polynomial size circuits hence diffiehellman cryptographic scheme secure note proved primes breaking diffiehellman cryptographic scheme harder factoring p bbr see also sh mc require quite bit work formalize statement argument short proof notice want size propositional formula expressing diffie hellman statement polynomially bounded number binary variables additionally want size proof statement also polynomially bounded key idea order define statement prove efficiently introduce additional common variables propositional diffiehellman statement bulk argument involves showing aid auxillary variables one formalize proof showing basic arithmetic facts including chinese remainder theorem stated proven efficiently within 14 section description paper organized follows section 2 define system section 3 define used proof section 4 define precisely interpolation formulas based diffiehellman cryptographic scheme section 5 show prove main theorem provided technical lemmas proved fully section 7 section 6 discussion open problems finally section 7 prove technical lemmas required main theorem unusual organization paper due many technical lemmas required show result essential correctness argument every reader might want go sections 16 give exposition result relying complete proofs technical part systems clarity work specific boundeddepth threshold logic system call reasonable definition system also suffice system sequentcalculus logical system formulas built using connectives number 1s x least k phi x true number 1s x mod 2 system essentially one introduced mp turn extension system ptk introduced buss clote bc section 10 intuitively family formulas f formula proof size polynomial size formula every line proof built using connectives th k phi 1 phi 0 connectives assumed unbounded fanin th k interpreted true number true least k phi j interpreted true number true equal j mod 2 formula denotes logical multiset consisting similarly phi j th k thus commutativity connectives implicit proof system operates sequents sets formulas form intended meaning conjunction implies disjunction b j proof sequent logic system sequence sequents 1 q sequent either initial sequent follows previous sequents one rules inference final sequent q size proof depth initial sequents form 1 formula 2 rules inference follows note logical rules defined n 1 k 1 first simple structural rules weakening formulas always added left right contraction two copies formula replaced one permutation formulas sequent reordered remaining rules cut rule logical rules allow us introduce connective left side right side cut rule allows derivation gamma logical rules follows 1 derive 2 negationright 3 andleft 1 4 andright 5 orleft 6 7 modleft 1 phi 1gammai derive 8 modright derive 9 thresholdleft th k derive derive proof boundeddepth proof system polynomial size formally following definitions ng family sequents fr family tc 0 proofs f exist constants c following conditions hold 1 r n valid proof gamma system 2 depth r n 3 n size r n note defined specific proof system clarity result still holds reasonable definition proof shown system polynomially simulates fregestyle system difference polynomial size proof system polynomial size tc 0 proof similar difference nc 1 tc 0 3 section describe needed formulate refute diffiehellman formula simplicity description let us assume fixed number n upper bound length numbers used refutation diffiehellman formula number n used define formulas seeing statement refutation diffiehellman formula clear enough take n small polynomial length number p used diffiehellman formula 31 addition subtraction use usual carrysave ac 0 formulas add two nbit numbers let two numbers x denote following ac 0 formula bit z equal mod 2 sum c x c carry bit intuitively c 1 bit position less generates carry propagated later bit positions bit formally c computed orr th bit position generates carry p k 1 k th bit position propagates generate carry subtraction let us show compute z think x n bit numbers complement modulo 2 n bits x complement n bits x denote note equal 2 n similarly equal 2 n know x gamma 0 thus know thus thus compute z n1 32 iterated addition describe inputs numbers n bits long outputs sum x 1 assume n main idea reduce addition numbers addition two numbers let x x x i1 binary representation let l dlog 2 ne let 2l assume simplicity r integer divide x r blocks block 2l bits let ik number k th block x 2l ik 2l bits let l ik loworder half ik let h ik high order half denote r r r r r hence show compute numbers hl let us show compute l computation h similar denote r since l ik length l l k length l 2l hence bits l bits l k combined computation l k note since l k polysize sum logarithmic length numbers computed using polysize threshold gates 33 modular arithmetic next describe compute quotient remainder number z modulo p z length n remainder inputs remainder quotient formulas follows 1 number z 2 numbers 3 numbers k r 1 n intended values variables k r 2 1 n intended values variables p delta p suppose z assume input variables k r take right values formula z p output r formula div p z output k formulas computed follows suppose k r p variables satisfy p l l delta therefore computed div p z computed sum n notice k r p 2 formulas required compute correct values quotient remainder give junk 34 product iterated product write x delta denote formula sum ij 2 ij gamma2 x computing product two nbit numbers x 2 ij gamma2 x j mean 2 ij gamma2 x j true 0 otherwise lastly describe computing iterated product numbers formula basically original formula bch articulated tc 0 formula iterative product prodz gives product z 1 z z length n assume mn bounded n basic idea compute product modulo small primes using iterated addition use constructive chinese remainder theorem construct actual product product modulo small primes let q product first primes first integer gives number q length larger n 2 since q 1 q larger 2 n 2 well known bounds distribution prime numbers length q j olog n q j let g j fixed generator z also q j let u j q fixed number property u j mod q number exists chinese remainder theorem prodz computed follows 1 first compute r calculated using modular arithmetic described earlier 2 1 compute ij g ij done table lookup b calculate c c compute r j g c j another table lookup 3 finally compute hardwire values thus computation obtained table lookup compute followed iterated sum followed mod q calculation 35 equality inequality often write vectors variables formulas apply conventions writing 6 4 diffiehellman formula ready formally define propositional statement dh dh conjunction 0 1 common variables formulas p g representing nbit integers every 2n also add common variables g 2 mod p b xy every 2n also add common variables x 2 mod p mod p c also add variables p variables needed define arithmetic modulo p see section 33 following common variable mod mod conjunction following 1 means g mod 2 every j n mod p means g 2 j modp note easy prove 3 similar formulas g b mod mod p 4 prod ij even means g ab mod p even 5 every n formulas expressing formulas added guarantee modulo p arithmetic computed correctly similarly formula 1 conjunction formulas replaced c b replaced fourth item stating g cd mod p odd note definition iterated product prod requires primes q 1 q well product q numbers u fixed length n going hardwire numbers q well correct values r k needed modulo q j arithmetic one numbers refutation dh want describe refutation dh mentioned proof proceeds follows 1 using 0 show g ab mod 2 using 1 show x b mod 3 show g cb mod 4 using 0 show g bc mod 5 using 1 show c mod 6 show g dc mod conclude steps 0 1 imply g ab mod reach contradiction since 0 states g ab mod p even 1 states g cd mod p odd formulate g ab mod p prod ij x b mod p thus step 1 formulated prod ij steps 1245 virtually identical steps 3 6 follow easily formulas defining g ab make symmetry obvious thus key step show step 1 show prove g ab mod mentioned formulated follows prod ij build proof g ab mod p equals x b mod p proving many lemmas concerning basic formulas final lemma need following lemma 4 every z 11 z mm 0 p tc 0 frege proofs proof lemma given section 7 using lemma 4 first equality point 2 section 4 second equality obtain prod ij proves step 1 main goal section 7 hence show statement short proof trivial quite complicated particular formulas iterated product modular arithmetic order prove statement need carry lot basic arithmetic go technical part try give intuition proof main lemma built organized proof sequence lemmas show many basic facts arithmetic formulated proved tc 0 frege using formulas proofs lemmas require careful analysis exact formula used operation proof lemmas straightforward using well known proof lemmas require new tricks short main lemmas used proof final statement lemma following 1 lemma 38 every x p tc 0 frege proofs 2 lemma 41 every z frege proofs 3 lemma 47 every z 1 z 2 tc 0 frege proofs first prove basic lemmas addition subtraction multiplication iterative sum lessthan modular arithmetic among lemmas lemma 38 proof lemma 41 cumbersome basically straightforward given basic facts modular arithmetic recall iterated product first compute product modulo small primes combine products get right answer using iterated sum therefore many basic facts modulo arithmetic need proven advance well basic facts iterated sum done need obtain fact modulo p lemma 48 point easier go regular product basic facts modular arithmetic easier prove therefore important show tc 0 frege prove lemma 47 application z 1 z 2 iterated products show fact use chinese remainder theorem first prove equality modulo small primes relatively easy since sizes primes sufficiently small olog n basically check possible combinations done apply chinese remainder theorem obtain equality modulo product primes since product big enough obtain desired result proof chinese remainder theorem different standard textbook one main fact need show every j r q j tc 0 frege proofs r usual proofs use basic facts division primes would hard implement instead prove induction method allows us work numbers smaller q since numbers sufficiently small verify possibilities 6 discussion open problems shown tc 0 frege feasible interpolation assuming factoring blum integers efficiently computable implies assumptions frege well system polynomiallysimulate frege automatizable interesting note proof even definition diffiehellman formula nonuniform essentially due nonuniform nature iterated product formulas use would interesting know extent result holds uniform tc 0 proof setting recent paper bdgmp extends results prove boundeddepth frege doesnt feasible interpolation assuming factoring blum integers sufficiently hard actually assumptions stronger consequence boundeddepth frege automatizable somewhat weaker hardness assumptions important question still open whether resolution restricted forms automatizable positive answer question would important applied consequences 7 formal proof main lemma goal section prove lemma 4 mentioned earlier build proof lemma showing basic facts concerning arithmetic multiplication iterated multiplication modulus computations efficiently carried proof system begin formal presentation would like note giving precise description sequence lemmas sufficient order carry full formal proof lemma 4 however since many lemmas many obvious proofs describe metalevel required order formalize argument tc 0 frege rather give excessively formal frege proof lemma follows x z numbers one denote vector n variables formulas representing number n n x respectively z denotes th variable x representing th bit number x need talk three numbers write z 1 z represent sequence nbit mn n z ij j th variable z representing j th bit th number recall whenever say tc 0 frege proofs actually mean say polynomial size tc 0 frege proofs trivial properties like stated 71 basic properties addition subtraction multiplication lemma 5 every x tc 0 frege proofs x proof lemma 5 immediate fact addition formula defined symmetric way ut lemma 6 every x z tc 0 frege proofs x proof lemma 6 definition addition formula th bit x equal phi 1 phi 1 carry bit going th position add x c similarly defined carry bit going th position add using basic properties phi 1 definitions simple proof phi 1 c x thus left show show prove stronger equality verified strongest equality possible 4 quantities 6 assignments satisfy equality actually possible prove induction carry bits going first position zero identity holds trivially prove equality assume holds prove equality considering many cases particular case assume fixed value following seven quantities subject condition c easy check number cases 48 since 2 choices x choices choices z 6 choices total c case proceed way first show compute using seven values simply verify 48 cases inductive hypothesis holds equality true first show requires proof along following lines x lefthand side statement true since position carry also righthand side statement also true similarly x sides statement false since position carry last case x viceversa case position propagates carry th carry bit 1 exists j th position generates carry positions carries exactly definition c thus last case sides statement true c using fact also z arguments show c also computed simple formulas seven pieces information ut lemma 7 every x tc 0 frege proofs proof lemma 7 computed taking first n bits definition addition formula follows easily bits 1 hence hence first n bits number first n bits x ut lemma 8 every x proof lemma 8 computed taking first n bits x definition addition formula since x proved n th bit hence therefore lemma 7 particular first n bits x lemma 9 every x z tc 0 frege proofs x proof lemma 9 follows immediately lemma 7 lemma 6 follows every z tc 0 frege proofs proof lemma 10 need show every j shown rather tedious straightforward proof following definition formula sum iterated addition namely show first similarly secondly show h using definition second step difficult carry bits zero ut lemma 11 every z 1 z every fixed permutation ff tc 0 frege proofs iterated sum symmetric proof lemma 11 immediate fact formula sum defined symmetric way ut lemma 12 every z tc 0 frege proofs proof lemma 12 definition iterated addition formula sum straightforward prove similarly also straightforward show using definition formula every j carry bits zero ut lemma 13 every z 1 z tc 0 frege proofs proof lemma 13 recall sum z computed adding two numbers hl recall l computed first computing numbers l loworder half k th block z first equality follows lemma 13 similarly computed h 0 l 0 l 0 computed first computing numbers l k l 0 k sum computed using polysize threshold gates eg using unary representation l ik therefore straightforward prove k l eg trying possibilities l 0 proving formula separately possibility consider formula since addition carry flow one block next one since bits l l block bits l k l 0 respectively conclude similar way prove able conclude ut lemma 14 every z 1 z tc 0 frege proofs proof lemma 14 proved easily lemma 13 lemma 6 follows lemma 15 every z 1 z every 1 k tc 0 frege proofs proof lemma 15 lemma 13 lemma 14 lemma 11 proof follows repeating argument gamma k times lemma 12 used base case ut lemma 16 every x tc 0 frege proofs x proof lemma 16 immediate fact product formula defined symmetric way ut lemma 17 every x x power 2 tc 0 frege proofs x proof lemma 17 straightforward prove 2 delta sequence bits consists adding end 0s lemma easily follows ut lemma every z 1 z every x x power 2 proofs proof lemma proof lemma like proof lemma 21 using lemma 17 instead 20 ut lemma 19 every x powers 2 tc 0 frege proofs x proof lemma 19 proof lemma 17 ut following three lemmas generalizations previous three lemmas lemma 20 every x z tc 0 frege proofs x proof lemma 20 definition product formula x similarly x iterative application lemma 15 using also lemma 11 similarly using also lemma 13 lemma 14 way using lemmas thus prove prove proving every trivial otherwise x using lemma 19 lemma 18 lemma way using also lemma 17 ut lemma 21 every z 1 z every x tc 0 frege proofs proof lemma 21 show every lemma follows combination equalities case proven follows first equality follows applying lemma 13 second equality lemma 12 general step first equality follows lemmas 13 second equality follows lemma 20 third equality follows lemma 13 ut lemma 22 every x z tc 0 frege proofs x proof lemma 22 show x delta delta z equal sum ijk 2 ijkgamma3 x true lemma follows definition product hence lemma 10 two applications lemma 21 using freely lemma 16 x since easily verified 2 equal iterative application lemma 15 using also lemma 11 equal 72 basic properties lessthan lemma 23 every x also proof lemma 23 either bit significant bit x differ bits equal significant bit differ x lemma 24 every x proof lemma 24 lemma 23 suppose contradiction get x x easily proved false lemma 25 every x z proof lemma 25 proof first statement obvious otherwise suppose significant bit x 6 x similarly suppose j significant bit j 6 z j easy show significant bit x 6 z x thus x z similarly j j significant bit x j 6 z j x reasoning also implies second statement lemma ut lemma 26 every x z tc 0 frege proofs xz x also z proof lemma 26 z 0 clear x show inductively decreasing k assuming z 0 let z 0 significant bit z base case induction show x z applying lemma 12 suffices show x two cases x equal x n x case x significant bit position greater 0 x one clearly exists x higher bits equal thus x inductive step assume x want show x using argument base case one prove x inductive hypothesis b x applying lemma 25 b obtain desired ut lemma 27 every x z proof lemma 27 lemma 26 lemma lemma 28 every x z proof lemma 28 first equality follows lemma 8 second lemma 26 fact lemma 29 every x tc 0 frege proofs proof lemma 29 x definition also since 0 bit 1 suppose l x ut 73 basic properties modular arithmetic recall formulas z p div p z take inputs variables p z also variables k formulas give right output n following theorems hypothesis values variables k r p correct short state hypothesis first lemma omit afterwards simplicity simplicity also use notations k lemmas used either number used dh formula fixed hardwired value eg q j one primes used iterated product formula q product primes hardwired q k also hardwired hence values correct straightforward check ie prove nonvariable correct inputs dh formula requirements 2 part requirements dh formula lemma z p nbit numbers tc 0 frege proofs proof lemma ut lemma 31 every z p tc 0 frege proofs also following uniqueness property proof lemma 31 previous lemma express z sum r let l definition modulo formulas first equality follows definitions formulas z p div p z remaining equalities follow following lemmas 20 6 8 21 13 15 14 30 let us prove uniqueness part suppose done div p z claim bellow contradiction similar argument holds div proof claim since v lemma 8 lemma lemma 9 get therefore lemmas 29 26 lemma 25 get p x ut lemma 33 every z k p tc 0 frege proofs proof lemma 33 let lemma 31 therefore uniqueness part lemma 31 applied x z lemma 34 every x z p frege proofs also proof lemma 34 lemma 31 lemma 33 similar argument shows x lemma 35 every z 1 z p tc 0 frege proofs proof lemma 35 lemma follows easily lemma 13 lemma 34 ut lemma 36 every x p tc 0 frege proofs proof lemma 36 first equality follows lemma 34 next equality follows assumption third equality follows lemma 34 ut lemma 37 every x z p frege proofs proof lemma 37 assuming x follows lemma 36 x left side equation equal first equality follows lemma 34 second equality follows lemmas 5 6 7 third equality follows lemma 33 similarly shown thus lemma follows ut lemma 38 every x p tc 0 frege proofs proof lemma 38 last equality follows lemma 33 ut lemma fixed numbers bc every z frege proofs lemma used situations recall numbers q hardwired also corresponding k r variables hence think b c hardwired proof lemma 39 using lemmas 313322 get ut 74 basic properties iterative product lemma 40 every z 1 z every fixed permutation ff tc 0 frege proofs iterated product symmetric proof lemma 40 lemma immediate symmetric definition prod ut lemma 41 every z 1 z every 1 k tc 0 frege proofs proof lemma 41 recall hardcoded numbers u j u j mod q primes q j dividing q verify following statements statements variablefree hence easily proven formula evaluation recall k iterated product numbers z k z calculated follows r km j computed like r j defined section 34 using r ij way r 1kgamma1km j calculated following steps 1 also calculate r 2 calculate ij g ij also j g j 3 calculate c 0 4 calculate r 1kgamma1km j g c 0 tablelookup therefore show hence need prove lemma 41 show following claim 42 every j tc 0 frege proofs r 1kgamma1km first step prove following claim 43 43 proven follows r km second equality follows lemma 39 third equality follows lemma 35 lemma 11 prove fourth equality need use fact u j delta r km also facts easily proved checking possibilities r km proving statement possibility easy statements variablefree hence easily proven formula evaluation order prove fourth equality formally show sum i6j u delta r km equals zero induction number terms sum ut turn proof claim 42 quantity r 1m j obtained table lookup find value equal g c j gamma1 similarly quantity r 1kgamma1km j obtained table lookup find value equal hence enough prove c using previous lemmas thus suffices show recall j value obtained tablelookup g j claim 43 r j turn value obtained tablelookup equal g easy verify tablelookup onetoone every x using property 75 chinese remainder theorem properties iterative prod uct heart proof proof following lemma gives hard direction chinese remainder theorem proof direction simpler lemma 44 let r two integers every j r q j frege proofs fixed primes used prod formula ie first primes q product proof lemma 44 without loss generality assume 0 r prove r otherwise define r use lemma 39 show every j r 0 since 0 r 0 conclude every k let q k denote note numbers q k hardwired one easily prove following statements statements variablefree hence easily proven formula evaluation every proof lemma induction number q j lemma trivial assume therefore induction hypothesis hence denote r lemma 31 since know r q r q lemma 37 since r lower q follows dr lower q hence claim therefore conclude every proof since 1 olog n possibilities 1 2 therefore one check possibilities 1 2 proving statement possibility easy statements variablefree hence easily proven formula evaluation alternatively one define function domain f0 q g prove fx onto range f0 q g applying propositional pigeonhole principle efficiently provable tc 0 frege follows f one one ut able prove following lemmas lemma 46 every z tc 0 frege proofs proof lemma 46 recall prodz calculated follows r j computed r claim 43 every prodz q thus every prodz q proof lemma follows lemma 44 ut lemma 47 every z 1 z 2 tc 0 frege proofs proof lemma us prove every proof lemma follows lemma 44 two applications lemma 38 enough prove every recall prodz 1 z 2 calculated follows r 12 j computed like r j defined section 34 claim 43 every recall z 1 r 2i therefore prove every r 12 definitions r also r 12 therefore one check possibilities 1i 2i ut using previous lemmas able prove following lemma 48 every z every p tc 0 frege proofs given 2 proof lemma 48 lemmas used equality turn lemmas 4147 384741 41 ut ready prove lemma 4 every z 11 z mm 0 p tc 0 frege proofs given 2 proof lemma 4 iterative application previous lemma ut acknowledgments grateful omer reingold moni naor collaboration early stages work particular suggesting use diffiehellman cryptographic scheme also would like thank uri feige conversations insight extending result boundeddepth frege part work done dagstuhl complexity boolean functions workshop 1997 r monotone circuit complexity boolean functions minimal propositional proof length nphard linearly approximate generalized diffiehellman modulo composite weaker factoring log depth circuits division related problems nonautomatizability boundeddepth frege proofs lower bounds cutting planes proofs small coefficients undecidability kprovability godels theorems lengths proofs ii lower bounds recognizing k symbol provability cutting planes connectivity threshold logic exponential lower bound size monotone real circuits constant depth reducibility new directions cryptography upper lower bounds treelike cutting planes proofs interpolation theorems lower bounds proof systems independence results bounded arithmetic discretely ordered modules firstorder extension cutting planes proof system threshold circuits small majority depth key distribution system equivalent factoring lower bound complexity craigs interpolants sentential logic lower bounds resolution cutting planes proofs monotone computations algebraic models computation interpolation algebraic proof systems lower bounds monotone complexity boolean func tions unprovability lower bounds circuit size certain fragments bounded arithmetic composite diffiehellman publickey generating systems hard break tr ctr alexander razborov propositional proof complexity journal acm jacm v50 n1 p8082 january pavel pudlk reducibility symmetry disjoint np pairs theoretical computer science v295 n13 p323339 24 february olaf beyersdorff classes representable disjoint nppairs theoretical computer science v377 n13 p93109 may 2007 albert atserias conjunctive query evaluation searchtree revisited theoretical computer science v371 n3 p155168 march 2007 samuel r buss polynomialsize frege resolution proofs stconnectivity hex tautologies theoretical computer science v357 n1 p3552 25 july 2006 paolo liberatore complexity results dpll resolution acm transactions computational logic tocl v7 n1 p84107 january 2006 maria luisa bonet nicola galesi optimality sizewidth tradeoffs resolution computational complexity v10 n4 p261276 may 2002 albert atserias mara luisa bonet automatizability resolution related propositional proof systems information computation v189 n2 p182201 march 15 2004 juan luis esteban nicola galesi jochen messner complexity resolution bounded conjunctions theoretical computer science v321 n23 p347370 august 2004
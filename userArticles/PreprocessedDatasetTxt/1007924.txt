online hierarchical cooperative caching address hierarchical generalization wellknown disk paging problem hierarchical cooperative caching problem set n machines residing ultrametric space cooperate one another satisfy sequence read requests collection readonly files seminal result area competitive analysis states lru widelyused deterministic online paging algorithm based least recently used eviction policy constantcompetitive given constantfactor blowup capacity offline algorithm constantcompetitive deterministic algorithm constantfactor blowup machine capacities exist hierarchical cooperative caching problem main contribution present paper answer question negative specifically establish log log n lower bound competitive ratio online hierarchical cooperative caching algorithm capacity blowup olog n1 denotes arbitrarily small positive constant b introduction traditional paging problem extensively studied defined follows given cache sequence requests files uniform sizes system satisfy requests one one file f requested cache cost incurred otherwise uniform retrieval cost incurred place f cache need files determined online caching algorithm know future request sequence evicted make room f objective minimize total retrieval cost wisely choosing files evict cost online algorithm compared optimal oine algorithm opt full knowledge request sequence following sleator tarjan 10 call online algorithm ccompetitive cost c times opt request sequence wellknown optimal oine strategy evict file requested furthest future paging problem also known caching files nonuniform size retrieval cost seminal paper sleator tarjan 10 shown lru least recentlyused several deterministic paging algorithms k competitive k cache space used lru h used opt also shown k kh1 best possible among deterministic algorithms call k h capacity blowup lru files nonuniform size retrieval cost young 13 proposed landlord algorithm shown landlord k kh1 competitive stated 13 focus landlord simple local caching strategies rather distributed strategies caches cooperate cache pages across network cooperative caching 6 set caches cooperate serving requests making caching deci sions benefits cooperative caching supported several studies example harvest cache 5 introduce notion hierarchical arrangements caches harvest uses internet cache protocol 12 support discovery retrieval documents caches harvest project later became public domain squid cache system 11 adaptive web caching 14 builds mesh overlapping multicast trees popular files pulled towards users origin server localarea network environments xfs system 1 utilizes cooperative caches obtain serverless file system cooperative caching scheme roughly divided three components placement determines place copies files search directs request appropriate copy requested file consistency maintains desired level consistency among various copies file paper study placement problem assume separate mechanism enables cache locate nearest copy file free cost assume files readonly ie copies file always consistent focus class networks called hierarchical networks precise definition given section 2 call cooperative caching problem networks hierarchical cooperative caching hcc problem notion hierarchical network constantfactor related notion hierarchically wellseparated tree metrics introduced bartal 3 refining earlier results bartal 3 fakcharoenphol et al 7 shown metric space approximated wellseparated tree metrics logarithmic distortion hence many results tree metrics imply corresponding results arbitrary metric spaces additional logarithmic factor access frequency file cache known advance korupolu et al 9 provided exact approximation algorithms minimize average retrieval cost practice access frequencies often unknown expensive track since lru landlord provide constant competitiveness single cache natural ask whether exists deterministic constantcompetitive algorithm constant capacity blowup hierarchical cooperative caching problem paper answer question negative show log n lower bound competitive ratio deterministic online algorithm capacity blowup olog n 1 n number caches hierarchy arbitrarily small positive constant particular construct hierarchy suciently large depth show adversary generate arbitrarily long request sequence online algorithm incurs costt1 log n times adversary terestingly oine algorithms associated lower bound argument replicate files hand online algorithm given sufficiently large capacity blowup constant competitiveness easily achieved appendix shows result given od capacity blowup depth hierarchy ie n lrulike online algorithm constantcompetitive note terms lower bound result yields capacity blow od 1 competitive ratio hence results imply small range values capacity blowup separates regions constant competitiveness achievable unachievable drawing analogy traditional caching lru landlord provide constant competitiveness may think constantcompetitive algorithm exists hcc perhaps hierarchical variant lru landlord fact began investigation searching algorithm since hcc problem generalizes paging problem cannot hope achieve constant competiveness without least constant capacity blowup regard remark results 9 incomparable require capacity blowup several paging problems eg distributed paging file mi gration file allocation considered lit erature related hcc problem see eg survey paper bartal 4 definitions problems particular hcc problem formulated readonly version distributed paging problem ultrametrics hcc problem without replication special case constrained file migration problem accessing migrating file cost existing work problems focuses upper bound results lower bound results apply algorithms without capacity blowup example distributed paging problem awerbuch et al 2 shown given polylogn capacity blowup exists deterministic polylogn competitive algorithms general networks normalized diameter net work constrained file migration problem bartal 3 given deterministic upper bound total size caches randomized lower bound 55 network topology olog log 2 n randomized upper bound arbitrary network topologies using recent result fakcharoenphol et al 7 last upper bound improved olog log n rest paper organized follows section 2 gives preliminaries problem sections 3 4 present main result paper lower bound constant capacity blowup section 5 provides concluding remarks appendix presents upper bound su ciently large capacity blowup 2 preliminaries section formally define hcc problem given fixed sixtuple f set files c set caches dist function cc n size function f n cap function c n penalty function f n n denotes nonnegative integers assume dist ultrametric defined c assume every file f f penaltyf diamc diamu denotes maxuvu distu v every set caches u 21 ultrametrics hierarchical networks distance function c c n defined metric nonnegative symmetric satisfies triangle inequality du special case metric satisfy inequality subsumes triangle inequality equivalent perhaps intuitive characterization ultrametric assumption caches c form hierarchical tree simply tree defined follows every leaf node tree corresponds distinct cache every node tree associated nonnegative value called diameter node every two caches u v distu v equals diameter least common ancestor u v since hierarchical network natural correspondence tree rest paper use tree terminology develop algorithms analysis follows definitions ancestor descendant parent children follow standard tree terminology use denote tree caches use root denote root depth root 0 depth maximum depth nodes capacity node total capacity caches within subtree rooted node impose arbitrary order children every internal node 22 hcc problem goal hcc algorithm minimize total cost incurred movement files serve sequence requests respecting capacity constraints cache facilitate formal definition problem introduce additional definitions copy pair u f u cache f file set copies called placement u f belongs placement p say copy f placed u p placement p bfeasible total size files placed cache b times capacity cache 1feasible placement simply referred feasible placement given placement p upon request file f cache u algorithm incurs access cost serve request p places least one copy f caches cost defined sizef distu v v closest cache copy f placed otherwise cost defined penaltyf serving request algorithm may modify placement via arbitrarily long sequence following two operations 1 may add copy p incur access cost defined 2 may remove copy p incur cost given capacity blowup b goal hcc algorithm maintain bfeasible placement total cost minimized 3 lower bound section show given constant capacity blowup b competitive ratio online hcc algorith is85 depth hierarchy prove lower bound algorithm showing existence suitable hierarchy set files request sequence feasible oine hcc algorithm incurs factor lower cost request sequence online bfeasible hcc algorithm result easily extends analyzing lower bound competitive ratio varies function nonconstant capacity blowup depth hierarchy particular capacity blowup 1 fixed 0 competitive ratio online hcc algorithm still ill present adversarial argument lower bound let denote bfeasible online hcc algorithm adv adversarial oine feasible hcc algorithm chooses fixed value capacity blowup b adv subsequently chooses instance hcc problem ie sixtuple introduced section 2 follows hi erarchy tree consists n unitsized caches form leaves regular kary tree depth given choice k set files consist unitsized files diameter every leaf node ie cache 0 diameter node depth 4bk 1 1 diameter every internal node least times diameter child 1 file f penaltyf least diamroot given instance hcc problem described section 2 give program takes input generates request sequence oine hcc algorithm incurs less cost high level ons lack future knowledge empowers adv play game analogous shell game 1 game maintains compact placement files tailored request sequence adv generates forced guess offs placement incurs relocation costs guesses incorrectly finally zeroes offs placement switches placement around incurring small fraction relocation cost already expended repeats game example consider simple twolevel hierarchy associated equalsized departments within university set files say universitywide interest remaining files departmentspecific interest capacity constraints set way department either cache files interest universitys sets simultaneously stores files idle department ie one access activity hand guess identity idle de partment guesses incorrectly adv creates requests force move files dierent department best strategy evenly distribute files across departments yet exposed nonidle unfortunately even strategy ends incurring significantly higher cost course simplistic case circumvent predicament simply twofold blowup capacity using algorithm described appendix rest paper present formalization shellgamelike adversarial strategy extension strategy hierarchies nonconstant depth 31 adversary algorithm adv fix disjoint sets files s0 s1 sd sd call depth file f f define function gi j adv shown figure 1 key notations used algorithm rest paper explained table 31 adv nonnegative integer n specifies number requests generated code figure 1 shows adv generates bad request sequence section 4 show augment code obtain oine algorithm serves request sequence incurs much lower cost every node adv maintains two integer fields x summarize state adv global variable records current node adv generates next request initially set root program proceeds rounds end round algorithm generates request based ons adjustment placement adv adjusts using loop loop former moves ancestor latter moves descendant played especially three walnut shells notation meaning parent parent anc ancestors desc descendants depth depth diam diameter files cap total capacity blowup caches ch children hierarchies placed set distinct files placed caches load number files f placed depth f less depth missing set files f depth f depth f placed act gdepth r activation value react gdepth k reactivation value deact gdepth 2k deactivation value table 1 key notations initially 1 count n main loop load deact loop 4 every child set x 0 5 parent 6 od end loop 7 missing loop 8 child satisfies x 0 load react else exactly one child x equal 0 12 every child set x 0 child set x act 17 od end loop generate request element missing arbitrary cache 19 serves request arbitrarily updates placement count count od end main loop figure 1 adv algorithm 32 correctness adv show section adv welldefined ie root line 5 leaf line 8 line 14 finds child round terminates generation request sake brevity reasoning call predicate global invariant holds everywhere adv ie holds initially holds two adjacent lines pseudocode figure 1 lemma 31 let i1 denote every internal node child x field equal 0 i2 denote internal node i3 denote load deact i1 i2 global invariant i3 holds everywhere loop proof predicate i1 i2 holds initially root i3 holds loop due guard loop next show every line code loop preserves i1 i2 ie i1 i2 holds line holds line every line code loop preserves i1 i2 i3 every line code loop preserves i1 none assigns nonzero value x field line aects i2 line 5 observe root line 5 due guard loop observation root load root deact 0 hence line 5 preserves i2 loop line aects i1 15 i3 inner statement establish least two children x field equal 0 line 14 hence line 15 preserves i1 lines aect i2 lines 9 14 first observe line 8 depth 4bk 1 i2 states depth 4bk i3 implies depth 4 since load integer implies load bk implies missing 4bk contradiction guard loop hence depth 4bk1 line 8 therefore line 9 preserves i2 show line 14 also preserves i2 let ch x 0 let r denote denote depth observe load load load load deact react derivation second equality due guard loop definition load first inequality due guard outer statement hence averaging argument exists child load act hence line 14 finds child shown depth line 8 hence line 14 preserves i2 lines aect i3 9 14 lines preserve i3 definition act deact react deact claim lemma follows lemma 32 loop terminates proof every iteration loop moves parent root load root deact definition hence loop terminates lemma 33 loop terminates proof every iteration loop moves one children i2 lemma 31 always internal node hence loop terminates lemma 34 adv terminates generating sequence n requests proof follows lemmas 32 33 4 cost accounting section show exists oine hcc algorithm serves sequence requests generated adv incurs cost log less incurred bfeasible online hcc algorithm 41 properties adv first prove properties adv follow directly structure sake brevity property global invariant sometimes state property omit stating property holds everywhere lemma 41 react proof claim holds initially line assigns nonzero value x 15 preserves claim definition act react lemma 42 equals 0 react x proof claim holds initially rooty rootx lines modify x 4 12 15 lines modify 3 4 12 15 inspection code lines trivially preserve claim lemma 43 let p denote predicate every node anc positive x value every node neither anc child node anc zero x value p holds initially loop invariant loop loop main loop proof initially p holds let denote anc let b denote set nodes neither children nodes every iteration loop moves parent avoid confusion use denote old node ie child denote new node ie parent iteration loop removes adds ch b sets x value ch 0 therefore preserves p every iteration loop moves one chil dren avoid confusion use denote old node ie parent denote new node ie child suppose loop takes first branch outer statement adds positive x value removes ch b hence preserves p suppose loop takes second branch outer state ment line 12 executed p preserved line 12 preserves b changes x value nodes neither b lines 14 15 preserves p add positive x value line 15 removes ch b hence preserves p main loop preserves p loop loop preserve p lemma 44 x proof claim holds initially lines modify x field 3 4 12 15 lines 4 12 15 x fields become value follows lemma 43 guard loop line 3 root x 0 follows lemmas 41 42 line 3 preserves x introduce notion active sequence subsequent proofs sequence a0 a1 ar called iactive lemma 45 every internal node nonzero x fields children form iactive sequence proof claim holds initially root lines modify x field 4 12 15 lines 4 12 preserve claim x fields children become preserves claim parent x becomes act definition equals gi 1 k j j equals number children parent positive x field lemma 46 let p denote predicate ancestors react p holds initially p loop invariant loop loop main loop proof predicate p holds initially root loop preserves every iteration first establishes react moves parent loop preserves set field nonzero value main loop preserves p loop loop preserve p 42 colorings order facilitate presentation oine algorithm section 43 introduce notion colorings section notion consistent placements next coloring recall tree caches assignment one colors white black every node following rules observed 1 root white 2 every internal white node exactly one black child k1 white children 3 children black node black coloring called consistent adv every x 0 white coloring c pair sibling nodes define swapcc swap coloring coloring obtained c exchanging color node subtree rooted corresponding node subtree rooted note subtrees rooted identical structure 43 consistent placements placement colorable exists coloring c 1 white internal node set files files stored fill caches associated unique black child 2 white leaf set files files stored fill cache note preceding definition colorable place ment coloring c exists unique placement called consistent colorable associated coloring consistent placement p pair siblings define swappp swap placement placement obtained p exchanging contents cache corresponding cache note colorable placement p associated coloring c pair sibling nodes placement swappp colorable associated coloring swapcc 44 offline algorithm every internal node maintain additional variable last defined follows first partition execution adversary algorithm epochs respect first epoch begins start execution subsequent epoch begins either line 4 line 12 executed variable last updated start epoch set child line 15 executed furthest future one children line 15 never executed future last set arbitrary child note variables last introduced solely purpose analysis impact execution adv point execution adv values last fields determine unique coloring denoted coff follows root white black child internal white node last define oine algorithm maintains placement poff follows initialize poff arbitrary consistent placement associated coloring coff update poff swapppoff whenever line 4 line 12 executed denote values last execution line algorithm uses placement poff serve request generated line 18 placement poff updated serves request poff updated lines 4 12 lemma 47 throughout execution adv poff colorable associated coloring coff proof immediate way poff updated whenever last field updated lemma 48 execution line 4 line 12 preserves consistency coff proof assume coff consistent line 4 white coff line 4 lemma 43 x positive line 4 definition coff line 4 last black let last line 4 let last line 4 line 4 x values descendants equal 0 lemma 43 x values proper descendants equal 0 line 4 since line 4 x values descendants equal 0 line 4 hence swapp operation preserves consistency coff argument applies line 12 lemma 49 execution line 15 preserves consistency coff proof assume coff consistent line 15 line 14 implies root line 15 let denote parent lemma 43 x 0 hence white line 15 therefore lemma 47 last black child let denote start current epoch ie recent time last assigned time x values children equal 0 definition child set 0 since time lemma 31 every internal node least one child x equal 0 therefore time execution line 15 k 1 children x value set nonzero value note line 15 line sets x nonzero value thus definition last lastx remains 0 execution line thus last since white last black coff conclude white coff coff remains consistent even additional constraint required white note x set positive value line 15 lemma 410 placement poff always consistent proof observe coff always consistent due lemmas 48 49 observation lines 4 12 15 lines aect consistency coff lines modify last field x field node follows lemma 47 poff always consistent 45 potential function argument let denote arbitrary online bfeasible algorithm section use potential function argument show let ton denote total cost incurred similarly let toff denote total cost incurred except exclude toff cost initializing poff initialization cost taken account proof theorem 1 define potential ancroot parent diam x parent diam x convenience exposition account cost moving empty placement first placement separately lemma 411 cost incurred swappp parent diam proof cost incurred cost exchanging files placed parent diam note capacity lemma 412 predicate 0 loop invariant loop proof every iteration loop moves parent avoid confusion use refer old node ie child use refer new node ie parent consider change single iteration loop incurs cost loop definition line 3 preserves lemma 44 line 4 increase let execution line 4 incurs cost diam move current consistent marking placement next thus total change iteration derivation first inequality due guard loop line 3 second inequality due assumption diameters nodes separated lemma 413 predicate 0 loop invariant loop proof every iteration loop moves one children avoid confusion use refer old node ie parent refer new node ie child incurs cost loop consider following three cases suppose outer statement takes first branch case incur cost thus change inequality due lemma 46 guard outer statement suppose outer statement takes second branch line 12 executed case incur cost thus change first inequality due lemma 44 second inequality due lines 14 15 suppose outer statement takes second branch line 12 executed lemma 411 case incurs cost thus change due line 12 ch ch derivation first inequality follows lemma 46 first equality follows lemma 45 analysis previous case ie outer statement takes second branch line 12 executed lines 14 15 increase thus every iteration loop preserves 0 lemma 414 lines preserve 0 proof guard loop ensures exists file missing line 18 thus incurs cost least parent diam diam line 19 incurs cost diam stores files missing child let u cache request generated let set nodes path u excluding since adds file missing u change parent diam derivation last inequality follows 8 line 19 allowed make arbitrarily many updates placement suppose update causes load nodes increase definition load set nodes increased load value form path say leaf incurs cost least parent diam let set nodes path b since diameters nodes path separated change parent diam parent diam parent diam parent diam parent diam claim lemma follows theorem 1 competitive proof initially 0 loop invariant main loop therefore lemmas 41 44 ton holds initially loop invariant main loop let c cost incurred moving empty placement first placement note ton serves every request cost least 1 diameter internal node least 1 hence given arbitrarily long sequence requests ton grows unbounded therefore make arbitrarily close increasing length n request sequence generated program log bound competitive ratio capacity claimed beginning section 3 follows 4bk choose arbitrarily large 5 discussion cooperative caching fact found application areas distributed systems example nuca nonuniform cache architecture switched network allows data migrate dierent cache regions according access frequency 8 although nuca supports single processor time writing multiprocessor nuca developed data replication possibility 6 r serverless network file systems distributed paging general networks approximating arbitrary metrics tree metrics distributed paging harvest information discovery access system cooperative caching using remote client memory improve file system performance tight bound approximating arbitrary metrics tree metrics adaptive placement algorithms hierarchical cooperative caching amortized e squid internet object cache tr amortized efficiency list update paging rules harvest information discovery access system serverless network file systems distributed paging general networks placement algorithms hierarchical cooperative caching adaptive nonuniform cache structure wiredelay dominated onchip caches distributed paging tight bound approximating arbitrary metrics tree metrics probabilistic approximation metric spaces algorithmic applications
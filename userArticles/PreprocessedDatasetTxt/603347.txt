design prototype performance tool interface openmp paper proposes performance tools interface openmp similar spirit mpi profiling interface intent define clear portable api makes openmp execution events visible runtime performance tools present design using sourcelevel instrumentation approach based openmp directive rewriting rules instrument directive combination applied generate calls interface consistent directive semantics pass context information eg source code locations portable efficient way proposed openmp performance api allows user functions arbitrary code regions marked performance measurement controlled using new openmp directives prototype proposed openmp performance interface developed compatible performance libraries expert automatic event trace analyzer lsqb17 18rsqb tau performance analysis framework lsqb13rsqb directive instrumentation transformations define implemented sourcetosource translation tool called opari application examples presented expert tau show openmp performance interface opari instrumentation tool operation used together mpi profiling interface examples also demonstrate proposed approach provides portable robust solution performance analysis openmp mixedmode openmpmpi applications b introduction advent proposed language system expressing parallel operation whether true parallel language eg zpl 6 parallel extensions sequential language eg upc 4 parallel compiler directives eg questions soon arise regarding performance instrumentation measurement conducted performance data analyzed mapped languagelevel highlevel parallel abstractions several issues make interesting problem first language system implements model parallelism whose explicit parallel operation generally hidden programmer parallel performance events may accessible directly requiring instead support underlying runtime software observe full support unavailable performance must inferred model properties second language system typically transforms program parallel executable form making necessary track code transformations closely performance data correctly mapped userlevel source complex transformations difficult performance mapping last highlevel language expression parallelism often goes handinhand interest crossplatform portability language system users naturally desire programming performance tools portable well performance tool developer issues complicate decisions regarding choice tool technology implementation approach paper consider problem designing performance tool interface openmp three goals performance tool interface openmp considered expose openmp parallel execution performance system concerned execution events state data observable performance measurement interface make interface portable across different platforms different performance tools portability regard requires definition interface semantics information accessed allow flexibility interface applied since openmp compilers may implement openmp directives differently including variations runtime library operation performance interface constrain used study focuses mainly instrumentation interface events monitored operational state queried clearly type performance measurement determine scope analyses possible ideally flexibility interface support multiple measurement capabilities master slave x00000001111111000000011111110000111parallel region operation master starts serial execution parallel region begins slaves started team begins parallel execution team threads hit barrier slaves end master exits barrier master resumes serial execution figure 1 openmp parallel region operation showing states events general performance model openmp openmp parallel programming language system used express shared memory parallelism based model nested forkjoin parallelism notion parallel regions computational work shared spread across multiple threads execution thread team see figure 1 language constructs provide thread synchronization explicitly implicitly enforce consistency operation openmp implemented using commentstyle compiler directives fortran pragmas c c performance model openmp defined based execution events states advocate multiple performance views based hierarchy execution states level refined focus level 1 serial parallel states nesting level 2 work sharing states per team thread level 3 synchronization states peracross team threads level 4 runtime system thread states way performance observation targeted levels interest using events specific level events defined identify points state transitions beginend enterexit allowing openmp programs thought multithreaded execution graphs states nodes events edges performance instrumentation interface would allow monitoring events access state information figure 1 shows diagram openmp parallel region operation identified serial parallel p states parallel startup startup shutdown shutdown states different events different levels master slave threads based diagram given workable performance instrumentation interface develop measurement tools capturing serial parallel performance structured block call pomp parallel forkd call pomp parallel begind structured block call pomp barrier enterd call pomp barrier exitd call pomp parallel endd call pomp parallel joind loop call pomp enterd loop call pomp barrier enterd call pomp barrier exitd call pomp exitd structured block call pomp workshare enterd structured block call pomp barrier enterd call pomp barrier exitd call pomp workshare exitd call pomp barrier enterd call pomp barrier exitd structured block structured block call pomp sections enterd call pomp section begind structured block call pomp section endd call pomp section begind structured block call pomp section endd call pomp barrier enterd call pomp barrier exitd call pomp sections exitd structured block call pomp critical enterd call pomp critical begind structured block call pomp critical endd call pomp critical exitd structured block call pomp single enterd call pomp single begind structured block call pomp single endd call pomp barrier enterd call pomp barrier exitd call pomp single exitd atomic expression call pomp atomic enterd atomic expression call pomp atomic exitd structured block call pomp master begind structured block call pomp master endd table 1 proposed openmp directive transformations 3 proposed openmp performance tool interface performance interface developed meet goals openmp although different interfaces possible see 5 10 basic idea behind proposal define standard api performance measurement library used instrument users openmp application program monitoring openmp events instrumentation could done sourcetosource translation tool prior actual compilation within openmp compilation system performance tool developers need implement functions interface enable tool measure analyze openmp programs different measurement modes eg profiling 2 tracing 5 7 10 easily accommodated way hence proposed performance interface specify measurements performed form library interface call openmp performance api pomp api corresponding performance library pomp library taking use pmpi definition mpi profiling interface following present various aspects proposal standardized performance tool interface using directive rewriting im plementation fortran90 openmp 20 syntax used examples tables transformations equally apply cc 31 openmp directive instrumentation pomp api defined respect semantics openmp operation thus specify instrumentation openmp directives terms directive transformations first allows description independent base programming language second specification tied directly programming model application programmer understands transformation rules insert calls pomp name typed manner appropriate openmp directive name replaced name directive type either fork join enter exit begin end context descriptor described section 35 fork join mark location execution model switches sequential parallel vice versa enter exit flag entering exiting openmp constructs finally begin end mark start end structured blocks used bodies openmp directives table 1 shows proposed transformations performance library routines improve readability optional clauses directives allowed openmp standards shown seen type placement pomp calls intended expose openmp events underlying performance measurement system cases necessary transform directive way operation explicitly captured instance order measure synchronization time implicit barrier end sections workshare single directives use following method shown table original corresponding end directive include nowait clause nowait added implicit barrier made explicit nowait clause original end directive step necessary distinguish barriers userspecified explicit barriers pomp barrier functions passed context descriptor enclosing construct instead descriptor explicit barrier unfortunately method cannot used measuring barrier waiting time end parallel directives come nowait clause therefore add explicit barrier corresponding performance interface calls sourcetosource translation tools implementing proposed transforma tions means actually two barriers get called second implicit barrier execute succeed immediately threads openmp team already synchronized first barrier course openmp compiler insert performance interface calls directly around implicit barrier thereby avoiding overhead transformation rules combined parallel worksharing constructs parallel parallel sections parallel workshare defined accordingly see table 2 basically combination transformations corresponding single openmp constructs difference clauses specified combined construct distributed single openmp constructs way complies openmp standard eg schedule ordered lastprivate clauses specified inner directive 32 openmp runtime library routine instrumentation monitor openmp runtime library routine calls transformation process replaces calls calls performance tool interface library example openmp api call omp set lock transformed call omp parallel clauses loop call pomp parallel forkd omp parallel otherclauses call pomp parallel begind call pomp enterd omp scheduleclauses orderedclauses lastprivateclauses loop call pomp barrier enterd call pomp barrier exitd call pomp exitd call pomp parallel endd call pomp parallel joind clauses structured block call pomp parallel forkd omp parallel otherclauses call pomp parallel begind call pomp sections enterd omp sections lastprivateclauses call pomp section begind structured block call pomp section endd call pomp barrier enterd call pomp barrier exitd call pomp sections exitd call pomp parallel endd call pomp parallel joind clauses structured block call pomp parallel forkd omp parallel clauses call pomp parallel begind call pomp workshare enterd structured block call pomp barrier enterd call pomp barrier exitd call pomp workshare exitd call pomp parallel endd call pomp parallel joind table 2 proposed openmp combined parallel worksharing directive transformations pomp set lock implementation performance interface function original corresponding openmp runtime library routine must called performance data obtained currently think sufficient use procedure omp lock omp nest lock routines relevant observation openmp performance behavior 33 performance monitoring library control addition performance library interface propose add new directive give programmer control performance collection done omp inst init finalize normal openmp compilation directive ignored otherwise translated calls pomp init pomp finalize pomp pomp calls performance instrumentation requested compatibility existing openmp compilers essential new directives sentinel pomp could used yet another approach extend set openmp directives would programmer add performance tool interface calls directly requires either stub routines conditional compilation removal instrumentation used performance monitoring desired proposed new directive approach portable effective easier maintain parallel master single pompparallelforkd pompparallelbegind pompparallelendd pompparalleljoind pompmasterbegind pompmasterendd pompsingleenterd pompsinglebegind pompsingleendd pompsingleexitd workshare section sections pompdoenterd pompdoexitd pompforenterd pompforexitd pompworkshareenterd pompworkshareexitd pompsectionsenterd pompsectionbegind pompsectionendd pompsectionsexitd barrier critical atomic pompbarrierenterd pompbarrierexitd pompcriticalenterd pompcriticalbegind pompcriticalendd pompcriticalexitd pompatomicenterd pompatomicexitd runtime library control user code pompsetlock pompunsetlock pompsetnestlock pompunsetnestlock pompinit pompfinalize pompon pompoff pompbegin pompend table 3 pomp openmp performance api 34 user code instrumentation large application programs usually sufficient collect openmp related events openmp compiler also insert appropriate pomp begin pomp end calls beginning end user function case context descriptor describes user function addition users may desire mark arbitrary nonfunction code regions done directive mechanism similar described last subsection arbitrary user code directives translated pomp begin pomp end calls techniques used avoid defining new directives disadvantages described last section furthermore transformation tool compiler cannot generate context descriptor user defined region case another less efficient mechanism would used full proposed openmp performance api shown table 3 35 context descriptors important aspect performance instrumentation performance tool interface routines get access context information order relate collected performance information back source code openmp constructs propose following instrumented openmp construct user function userspecified region instrumentor generates context descriptor global static memory segment compilation unit containing construct region monitoring function calls related construct region passed address descriptor called tables 1 2 proposed definition context descriptor c syntax shown struct ompregdescr char name char subname int numsections char filename int beginline1 beginlinen int endline1 endlinen word data4 struct ompregdescr next fields context descriptor following meaning name contains name openmp construct string region user functions regions sub name stores name named critical regions name user functions regions case sections openmp directives num sections provides number sections otherwise set 0 next five fields file name begin line1 begin linen line1 end linen describe source code location openmp construct user region source file name first last line number opening corresponding end openmp directive field data used performance tool interface functions store performance data related construct region eg counters timers finally next component allows chaining context descriptors together runtime end program list descriptors traversed collected performance data stored away analyzed approach many advantages methods eg using unique identifiers 1 full context information including source code location available performance tool interface functions 2 runtime overhead implementing approach minimal one address passed argument addition providing space storing performance data form data field performance tool interface functions need dynamically allocate memory purpose costly 3 context data kept together instrumented executable avoids problems locating right separate context description files runtime 4 finally allows separate compilation important todays large complex application codes 36 conditional compilation also propose support user source code lines compiled conditionally pomp instrumentation requested openmp compiler pomp transformation tool supports macro preprocessor eg cpp c c sometimes fortran must define symbol pomp used conditional compilation following openmp standard conventions symbol defined decimal value yyyymm yyyy mm year month designations version pomp api implementation supports allows users define use application user sitespecific extensions pomp writing arbitrary user code endif p sentinel used conditional compilation fortran compilation transformation systems addition cp p sentinels accepted instrumenting fortran fixed source form pomp instrumentation sentinels replaced three spaces rest line treated normal fortran line sentinels also comply specifications defined sections 2131 2132 openmp fortran application program interface version 20 november 2000 37 conditional selective transformations finally allow user temporarily disable pomp instrumentation process specific files parts files propose provide following new directives pomp necessary disable reenable pomp instrumentation similar common existing compiler directives disabling optimizations pomp instrumentation disabled omp noinstrument effect end file next omp instrument whichever comes first 38 cc openmp pragma instrumentation transformations fortran openmp directives described tables 1 2 apply equally cc openmp pragmas main difference extent cc openmp pragmas determined structured block following explicit end pragma fortran following consequences pragma instrumentation instrumentation closing part pragma follows structured block adding nowait clause allow make implicit barriers explicit done opening part pragma structured block cc openmp pragma pragma omp transformed wrapping pomp begind pomp endd calls turn enclosed block ie using changes simple differences language eg call keyword using pragma omp instead omp new monitoring control user code instrumentation would appear pragma omp inst init finalize pragma omp inst begin arbitrary user code pragma omp inst end pragma omp noinstrument pragma omp instrument 39 implementation issues clear interface performance measurements must efficient must minimize influence dynamic behavior user code investigation designed pomp library interface efficiency mind beginning choose define larger set performance monitoring api functions according pattern pomp type namedescr instead using interface like pomp eventpomp type pomp name filename linenumber value would much simpler implement would make necessary use costly statements inside pomp event routine resulting runtime overhead argument passing overhead minimized still supporting full context information using context descriptors already discussed section 35 optimization required inlining pomp interface calls use macros would possible cc possible without changes proposal outlined function call macro call syntax fortran openmp instrumentation requires generation call openmp directive transformation suppressed however structure single pomp call simple ie function call one constant argument current compiler technology able inline calls without manual use macros granularity openmp constructs much finer example mpi functions especially true atomic critical master single openmp constructs well openmp api functions locking implementers pomp interface must take special care implementing corresponding pomp functions addition propose instrumentation constructs selectively disabled specifying following command line option openmp compiler pomp transformation tool pompdisableconstructconstruct construct name one openmp construct listed sync disable finally instrumentation constructs critical specific parts code omp noinstrument directive see section 37 used disable selectively 310 open issues think proposal outlined far reasonably complete additional issues need discussion try briefly summarize issues aware need instrumentation openmp ordered flush need instrumentation single iterations parallel parallel loops would potentially allow influence openmp loop iteration scheduling policies measured iterations sufficient granularity need way allow users pass additional information pomp interface besides using pomp conditional compilation see section 36 might consider extending omp inst begin end directive see section 34 optionally allow pass address user variable arbitrary user code pomp begin pomp end routines would additional void typed second parameter would null user specify variable way user could pass additional information pomp api functions would ignored general implementations could utilized user supplied special versions also possible allow passing user information pomp api functions requires directives pragmas need additional openmp runtime level instrumentation enough observe openmp behavior source code level 4 prototype implementation integrate performance tools proposed openmp performance interface two issues must addressed first openmp program must instrumented appropriate performance calls second performance library must developed implement openmp performance api particular performance tool following describes two performance tools expert tau integrated proposed openmp performance interface case openmp applications hybrid openmpmpi applications sup ported latter demonstrates ability combine openmp performance interface performance interface mechanisms seamless manner 41 automatic instrumentation proof concept means experimentation implemented opari openmp pragma region instrumentor sourcetosource translator performs openmp directive api call transformations described paper including new proposed directives pomp inst alternative sentinel current prototype implements full fortran77 fortran90 openmp 20 full cc openmp 10 support instrumentation user functions based pdt 12 way tool consists 2000 lines c code sourcetosource translator based fuzzy parser full compiler opari small limitations fortran omp end omp end parallel directives required optional described openmp standard atomic expression controlled omp atomic directive line structured blocks describing extent openmp pragma need either compound statements simple statements addition loops supported omp omp parallel pragmas complex statements like ifthenelse dowhile need enclosed block find limitations overly restrictive tests experiments rarely apply wellwritten code original source code easily fixed course possible remove limitations enhancing oparis parsing capabilities finally performance measurement environment support automatic recording user functions entries exits therefore cannot automatically instrument programs main function opari runtime measurement library initialized omp inst init directive pragma prior openmp pragma 42 integration expert expert tool environment 17 18 aimed automatically uncovering performance problems event traces mpi openmp hybrid applications running complex large smp clusters work expert carried within kojak project 11 part esprit working group apart 1 expert analyzes performance behavior along three dimensions performance problem category dynamic call tree position code location analyzed dimensions organized hierarchy performance problems organized general mpi related problem specific ones messages sent wrong order dynamic call tree natural hierarchy showing calling stack relationships finally location dimension represents hierarchical hardware software architecture smp clusters consisting levels machine node process thread range performance problems known expert hardcoded tool provided collection performance property specifications makes expert extensible flexible performance property specification consists compound event ie event pattern describing nature performance problem instructions calculate socalled severity property determining influence performance analyzed application parent performance property instructions initialize property display collected performance data property related results performance property specifications abstractions beyond simple performance metrics allowing expert explain performance problems terms underlying programming models specifications written event trace analysis language earl 16 extension python scripting language earl provides efficient access event trace level abstractions parallel programming models eg region stack message queue collective operation making easy write performance property specifications experts analysis process relies event traces performance data source event traces preserve temporal spatial relationship among individual events necessary prove certain interesting performance properties event traces recorded newly designed epilog format contrast traditional trace data formats suitable represent executions mpi openmp hybrid parallel applications distributed across one possibly large clusters smp nodes supports storage necessary source code call site information hardware performance counter values marking collectively executed operations mpi openmp implementation epilog thread safe necessary feature always present traditional tools traces generated c c fortran applications linking epilog tracing library intercept user function calls returns use internal profiling interface pgi compiler suite 15 installed linux smp cluster testbed capturing openmp events implemented pomp library functions terms epilog tracing calls use opari instrument user application example omp enter omp exit interface implementation instrumentation pragma omp parallel directive cc would look like following epilog void pompforenterompregdescr r struct elgregion e void pompforexitompregdescr r important notice region descriptor utilized collect performance data per openmp con struct hybrid applications using openmp mpi mpispecific events also generated appropriate wrapper function library utilizing mpi standard profiling interface 43 integration tau tau performance system 13 provides robust technology performance instrumentation measurement analysis complex parallel systems targets general computation model consisting sharedmemory nodes contexts reside providing virtual address space shared multiple threads execution model general enough apply many highperformance scalable parallel systems programming paradigms tau enables performance information captured nodecontextthread levels information mapped particular parallel software system execution platform consideration tau supports flexible instrumentation model allows access measurement api several stages program compilation execution instrumentation identifies code segments provides mapping lowlevel execution events highlevel computation entities works multithreaded message passing parallel execution models interfaces tau measurement model capture data function method basic block statement execution profiling tracing form two measurement choices tau provides performance experiments composed different measurement modules including ones access hardware performance monitors tau data analysis presentation utilities offer textbased graphical tools visualize performance data well bridges thirdparty software vampir 14 sophisticated trace analysis visualization expert tau implements openmp performance api library captures openmp events uses taus performance measurement facility record performance data example pomp implementation functions section 42 would look like following tau tauglobaltimertforfor enterexit openmpopenmp void pompforenterompregdescr r endif endif void pompforexitompregdescr r endif endif tau supports constructbased well regionbased performance measurement constructbased measurement uses globally accessible timers aggregate constructspecific performance cost regions case regionbased measurement like expert region descriptor used select specific performance data context following instrumentation approach taus functionality accessible user including ability select profiling tracing enable hardware performance monitoring add mpi instrumentation performance measurement hybrid applications 5 example applications demonstrate viability robustness proposed interface instrumentation tools developed opari tool pomp libraries expert tau applied example mixedmode openmp applications types application present analysis challenge performance tools need capture present performance data different parallel modes interaction figure 2 expert performance analysis openmpmpi weather forecasting application instrumented opari 51 weather forecasting remo weather forecast application dkrz deutsches klima rechenzentrum germany excellent testcase performance api code instrumented using opari openmp events mpi profiling library mpi events measurement system uses epilog tracing facility pomp library calling epilog trace routines described expert system processes events traces displays performance analysis results expert presentation results also based three dimensions performance problem call graph location dimension displayed using weighted trees weighted tree tree browser labels node weight expert uses performance propertys severity weight weight displayed simultaneously using numerical value well color coded icon color allows identify nodes interest easily even large tree expanding collapsing three trees possible analyze performance behavior parallel application different levels granularity see interactive analysis figure 2 3 three tree views shown first view lists different performance properties numbers nodes show percentage cpu allocation time spent property lost result property node collapsed inclusive value shown expanded exclusive value colors represent numeric value graphically figure 2 shows 50 cpu allocation time lost result sequential execution used idle slave threads although idle threads execute code idle time mapped middle call tree view ie idle slave threads considered executing code corresponding master threads allows user find code regions spent long time sequential execution numbers middle view refer selection left view 735 500 spent remoed4orgprogec4 figure 3 barrier performance analysis remo right view shows distribution idle times across different threads values refer selection left neighbor sum values correspond 739 middle view course slave threads idle times master thread shows always 00 figure 3 refers property openmp barrier call tree shows nearly barrier time spent implicit barrier omp ibarrier belonging parallel omp distribution overhead across different threads shown right view 52 ocean circulation demonstrate use openmp performance tool interface tau applied twodimensional stommel ocean current application san diego supercomputing center application code models winddriven circulation homogeneous rectangular ocean influence surface winds linearized bottom friction flat bottom coriolis force 5point stencil used solve partial differential equation grid points table 4 shows source code computeintensive block instrumentation opari linking tauspecific pomp library userconfigured tau measurement package performance data openmp mpi events captured displayed figure presents profiling data stommel application shown regionbased performance view individual parallel loops distinguished block shown table 4 highlighted nct 000 profile display representing node 0 context 0 thread 0 seen take significant percentage time execute execution time block across threads shown location original code block pragma omp schedulestatic reduction diff privatej firstprivate a1a2a3a4a5 forjj1jj2j code block opari instrumenation line 252 stommelc pragma omp schedulestatic reduction diff privatej firstprivate a1a2a3a4a5 nowait forjj1jj2j pragma omp barrier table 4 directive instrumentation stommel code profile display clearly work imbalance two threads within process distribution consistent across nodes ie processes notice mpi performance data integrated openmp data display also possible tau used obtain constructbased performance data linking stommel application traceconfigured performance library openmp mpi events displayed using vampir 14 visualization tool figure 5 displays event timeline showing overlaps openmp mpi events 6 related work given interest openmp last years several research efforts addressed performance measurement analysis openmp execution none efforts considered common performance tool interface manner proposed paper ovaltine tool 2 helps determine relevant overheads parallel openmp program compared serial implementation uses polaris fortran 77 parser build basic abstract syntax tree instruments counters timers determine overheads various openmp constructs code segments nature ovaltine performance measurements suggests openmp performance api could applied directly generate openmp events interest allowing greater range performance tools use overhead analysis omptrace 5 dynamic instrumentation package used trace openmp execution sgi ibm platforms provides automatic capture openmp runtime system rts events intercepting calls rts library user functions also instrumented generate trace events main advantage omptrace need recompile openmp program performance analysis essence omptrace uses rts interface performance tool interface relying interception dynamic link time instrumentation unfortunately approach relies openmp compiler transformations turn openmp constructs function calls dynamic shared library operation bypass restrictions openmp performance interface propose could figure 4 tau performance profile openmpmpi 2d stommel model ocean circulation instrumented opari provide suitable target performance tracing part omptrace compatible pomp library would need developed generate equivalent omptrace events hardware counter data manner paraver 7 tool analysis visualization omptrace data could used without modification vgv tool combines openmp compiler tools guide guideview kai vampirvampirtrace tracing tools pallas openmp performance analysis visualization openmp instrumentation provided guide compiler profiling tracing guide runtime system handles recording thread events compilerbased monitoring openmp performance quite detailed tightly integrated execution environment however lack external api prevents performance tools observing openmp execution events performance interface proposed could applied vgv context manner pomp calls could implemented library vgv mapping openmp actions vampir state transition calls appropriate points another approach might guide compiler generate pomp instrumentation allowing pompcompatible performance interface libraries used lastly jomp 3 system sourcetosource compiler transforms openmplike directives java multithread java statements implement equivalent openmp parallel operations similarities work supports performance instrumentation part directive transformation 8 instrumentation generates events analysis paraver 7 similar manner jomp compiler could modified generate pomp calls case since jomp manages threads implement parallelism may necessary implement runtime support pomp libraries access thread information figure 5 tau performance trace stommel application 7 conclusion future work paper proposes portable performance interface openmp aid integration performance tools openmp programming environments defined library api interface exposes openmp execution events interest eg sequential parallel synchronization events performance observation passes openmp context descriptors inform performance interface library regionspecific information openmp uses compiler directives pragmas express shared memory parallelism definition performance tool api must consistent operational semantics directives show accomplished describe api used rewriting openmp directives functionally equivalent sourceinstrumented forms opari tool perform openmp directive rewriting automatically inserting pomp performance calls appropriate benefits proposed performance interface several first gives performance api target source tosource instrumentation tools eg opari allowing instrumented openmp codes portable across compilers machine platforms second performance library interface provides target tool developers port performance measurement systems enables multiple performance tools used openmp performance analysis show accomplished expert tau redefining pomp calls third api also offers target openmp compilers generate pomp calls access internal compiler specific performance libraries external performance packages finally openmp community could adopt openmp performance interface one proposed would significantly improve integration compatibility compilers performance tools perhaps importantly portability performance analysis techniques future hope work openmp arb promote definition performance tool api offering proposal consideration enhance opari sourcetosource instrumentation approach support user function instrumentation using pdt 12 opportunities also possible integration api openmp compilers use performance technologies instrumentation measurement hope work kai pallas investigate use proposed performance tool interface kappro guide compiler vampirtrace basis pomp performance library implementation r esprit working group apart automatic performance analysis resources tools overheads profiler openmp codes towards openmp java introduction upc language specification dynamic tracing mechanism performance analysis openmp applications case high level parallel programming zpl european center parallelism barcelona cepba performance analysis tools parallel java applications sharedmemory systems integrated performance visualizer mpiopenmp programs kojak kit objective judgment knowledgebased detection bottlenecks tool framework static dynamic analysis objectoriented software templates performance technology complex parallel distributed systems vampir visualization analysis mpi resources programmable extensible toolkit analyzing event traces message passing programs automatic performance analysis mpi applications based event traces automatic performance analysis smp cluster applications tr performance technology complex parallel distributed systems tool framework static dynamic analysis objectoriented software templates case highlevel parallel programming zpl performance analysis tools parallel java applications sharedmemory systems automatic performance analysis mpi applications based event traces integrated performance visualizer mpiopenmp programs dynamic tracing mechanism performance analysis openmp applications programmable extensible toolkit analyzing event traces message passing programs ctr felix wolf bernd mohr automatic performance analysis hybrid mpiopenmp applications journal systems architecture euromicro journal v49 n1011 p421439 november sameer shende allen malony tau parallel performance system international journal high performance computing applications v20 n2 p287311 may 2006
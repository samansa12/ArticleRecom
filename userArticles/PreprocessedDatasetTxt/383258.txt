integrated test interacting controllers datapaths systems consisting interacting datapaths controllers utilizing builtin self test bist datapaths controllers traditionally tested separately isolating component environment system test work facilitates testing datapathcontroller pairs integrated fashion key approach addition logic system interacts existing controller push effects controller faults data flow observed datapath registers rather directly controller outputs result reduce bist overhead needed datapath controller tested independently allow complete test interface datapath controller including faults manifest isolation fault coverage overhead results given four example circuits b introduction systems consisting interacting datapaths controllers typically designed synthesizing testing datapath controller independently even though two operate inseparable pair separation cause difficulties even datapath controller designed 100 current addresses nourani dept electrical engineering university texas dallas po box 830688 ec 33 richardson dept electrical engineering university akron akron oh 443253904 c papachristou dept eecs case western reserve university 10900 euclid avenue cleveland oh 441067071 permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit direct commercial advantage copies show notice first page initial screen display along full citation copyrights components work owned others acm must honored abstracting credit permitted copy otherwise republish post servers redistribute lists use component work works requires prior specific permission andor fee c 2000 association computing machinery inc testable taken separately two taken combination testability may severely degraded dey et al 1995 addition separating tests datapath controller may result neglecting controlstatus signals used communicate two moreover faults seen modules interact faults due phenomena like crosstalk reflection bakoglu 1990 faults create signal slew among cores receiving signal sparmann et al 1995 faults cause excessive power consumption circuit nourani et al 1997 synthesis tools address issue test datapath controller interacting pair integrated way main goal work test controllerdatapath pair realistically quickly without neglecting signals used communicating two key successful integrated system test controllerdatapath pair provide method propagate observe effect certain controller faults datapath observed datapath registers rather controller outputs way avoid test hardware overhead associated observing controller outputs directly approach test interconnects datapath controller effectively would separate tests datapath controller moreover approach detect certain type redundant controller faults although may affect overall system functionality controllerdatapath pair deleterious effects system increased power consumption time approach substantially increase overall system cost basis technique addition small finite state machine fsm interacts main controller fsm purpose making controller faults observable datapath registers state machine designed work independent implementation details designfortestability technique design tools used synthesize controller datapath 11 related work many wellknown problems controller optimization work presented devadas newton 1989 ashar devadas 1991 lagnese thomas 1989 apply finite state machine fsm decomposition techniques improve controller area performance importance state assignment discussed demicheli et al 1984 devadas et al 1988 among others recently effect controller design power consumption explored landman rabaey 1995 work benini demicheli 1994 uses special state assignments reduce power benini et al 1994 adds combinational logic original controller avoid inactive state transitions selftestable designs based bist builtinselftest research involving controllers focuses test plan test scheduling abadir breuer 1985 kime saluja 1982 jone et al 1989 hellebrand wunderlich 1994 uses additional test registers implement system function supporting selftestable pipelinelike controller mmc control scheme breuer lien 1988 able test chip module via boundary scan bus local dedicated test controller discussed joersz kime 1987 reduce overall test overhead heuristics examples eschermann wunderlich 1990 uses special state assignment feedback polynomial mukherejee et al 1991 uses onehot encoding breuer et al 1988 employs microprogrammed hardwired implementations controller method proposed kuo et al 1995 adds additional edges fsm make corresponding architecture testable authors hsu patel 1995 note fsms easily controllable require long synchronizing sequence propose method improve fsm testability none approaches use unified model test controllerdatapath pair instead datapath controller tested separately different test sessions approaches basic test scheme similar bhatia jha 1994 proposed controller output signals multiplexed datapath primary outputs thus making directly observable observing controller datapath faults separately general implies test time due separate test session overhead due direct observation dey et al 1995 observed even controller datapath 100 testable separately combination usually much lower coverage degradation opinion occurs due correlation dependency control signals improve testability authors propose redesign controller breaking correlation control signals 12 organization paper paper organized follows section 2 presents system model testing datapathcontroller pair issues central testing controllers presented section 3 issues include classification types faults controller impact controller faults nonfunctional aspects system manufacturing power section 4 details solution integrated datapathcontroller testing experimental results shown section 5 concluding remarks section 6 2 model system model introduced carletta papachristou 1995 datapath represented behaviorally data flow graph dfg nodes represent operations addition multiplication edges represent transfer data structurally datapath consists arithmetic logic units alus mul tiplexers registers busses responsible data computations assume datapath composed functional blocks like shown figure 1 behaviorally controller viewed state diagram specifies time steps various operations data flow graph done work controllers implemented structurally finite state machines using random logic traditional approach testing controllerdatapath pair shown figure 2 pair completely split two parts tested independently controller datapath tested different times multiplexers may used share test resources example one tpgr one multiplexer used instead two tpgrs shown figure traditional designs designfortestability decisions made one component without thinking component used context pair approach controller datapath ms alu multiplexerbus rl register r fig 1 one functional block defining datapath style control status done misr tpgr data data status misr tpgr b start control control fig 2 separate testing controller b datapath control start done data data control status tpgr misr fig 3 completely integrated testing datapath controller advantage tests components designers intended fore fault coverage individual components high design allows however approach undesirable test interface controller datapath requires large amount insertion disadvantages addressed completely integrated approach shown figure 3 integrated approach controllerdatapath pair treated inseparable unit two parts tested simultaneously one motivation treating controllerdatapath pair integrated system shown figure 4 figure shows controller datapath single control line extending one independent test controller line would tapped output controller could observed control line misr control datapath fig 4 illustration disadvantage separate testing9296100 fault coverage time clocks separate integrated datapath8090100 fault coverage time clocks separate integrated b controller fig 5 fault coverage curves datapath controller differential equation solver tested separately tested together pair directly misr even though arrangement allows good observation controller still segment control line shown figure dotted line observed control line extends far datapath may control multiple registers multiplexers even part segment tested test datapth difficult ensure coverage complete line particular testing line series segments may miss problems due phenomena like crosstalk reflection signal skew show operation overall system note controller datapath laid separate blocks control lines may significantly longer length wires may therefore susceptible faults integrated test observe controller datapath ensure test entire control line figure 5 uses differential equation solver example compare separate integrated testing controllerdatapath pair separate fault coverage curves shown datapath controller seen curves fault coverage degraded datapath controller tested together controllability observability control status lines reduced integrated test lines longer directly accessible goal research achieve high quality integrated test overcoming difficulties work concentrates exclusively test controller integrated environment focus enhancing observability control lines datapath addition extra logic system work complements previous work reported carletta papachristou 1997 develops scheme datapath tested integrated way work datapath exercised according normal behavior even test guidelines based highlevel testability metrics given modify 6controllerfunctionally irredundant faults cfi controllerfunctionally redundant faults cfr redundant faults systemfunctionally irredundant faults systemfunctionally controller faults design number faults cfr cfi sfi sfr poly 0 164 136 28 fig 6 classification controller faults percentage faults belonging category example controllers ing datapath ensure quality test sufficient two pieces work used together ensure full integrated system test 3 controller fault analysis classify stuckat faults internal controller several groups shown figure 6 carletta et al 1999 first division based whether fault affects functionality controller functionality mean inputoutput behavior synthesized controller operates normal mode faults never affect output synthesized controller normal mode controller functionally redundant cfr cfr faults detected even direct observation controller outputs normal mode operation detection faults may require example application transitions designer left unspecified perhaps states controller unused states input combinations never occur work fummi et al 1995 shows controller resynthesis used remove faults concern note stuckat fault inside controller may affect controller outputs sequential way causing controller outputs change one control steps controller state diagram kind fault call controllerfunctionally irredundant cfi affects output controller least one time step controller running normal mode faults kind caught independent test controller operate controller normal mode observe controller outputs directly divide controllerfunctionally irredundant faults two sub groups based whether fault affects functionality datapathcontroller pair system systemfunctionally irredundant sfi faults faults change inputoutput behavior system whole faults controller clearly affect function performed datapath example fault whose effect changes care specification multiplexer select line cause operation done incorrect data thereby affecting change results computation systemfunctionally redundant sfr faults faults affect inputoutput behavior system even though affect inputoutput behavior controller one example system 7functionally redundant fault fault affects bits controller output time steps bits dont care specifications example fault may affect multiplexer select line time steps multiplexer idle time steps register driven multiplexer loaded select line multiplexer dont care multiplexer take part registertoregister transfer depending controller synthesized select line either 0 1 although actual value select line make difference terms signals propagating locally area multiplexer signals never written register never used computation therefore affect function performed datapath fault controller causes select line value change way observe change datapath function datapath affected difference fault classification model fummi et al 1995 subtle important fummi et al 1995 faults distinguished terms controller functionality specified designer whereas consider functionality synthesized controller designers specification outputs may unspecified whereas synthesized version specific values chosen outputs byproduct synthesis fummi et al 1995 fault affects care specification controller output viewed irredundant however systemfunctionally redundant faults affect even care specifications outputs controller sense faults due redundant logic within system even controller datapath redundancy considered separately combined system may redundancy example suppose fault controller causes register loaded time step loaded extra load overwrites important part computation de tectable however extra load may write register currently holding computation value holding computation value used case extra load affect functionality datapath possible determine whether fault causes change register load line time step systemfunctionally redundant analyzing lifespans variables bound register variable alive time step extra load serves redo previous computation fault systemfunctionally redundant table 6 shows faults three example controllers presented completely results section break categories controllers 15 faults controller systemfunctionally redundant synthesizing controller sfr faults exist trivial carletta et al 1999 show key removing sfr faults careful consideration meaning dont care specifications context controllerdatapath pair requires analysis lifespans variables bound registers datapath controllers specified ways likely contain sfr faults particular controllers systems utilizing gated clocks designate registers loaded necessary save results computation likely contain significant number sfr faults inputs power w clock data lines load line latch register stopped random fixed random fixed 007 007 running random random 130 151 stuckat0 26 25 running fixed random 68 96 fault power presence w increase multiple effects 2413 754 b table power consumption watts four bit storage components b four bit implementation differential equation solver presence sfr faults 31 power nonfunctional effects sfr faults synthesis method used controller impacts many kind controllerfunctionally redundant systemfunctionally redundant faults exist controller carletta et al 1999 presence faults affect functionality system however faults may cause undesirable nonfunctional effects whether detection faults important depends concerns designer groups responsible manufacturing reliability quality assurance one nonfunctional effect systemfunctionally redundant faults increased power consumption excessive power consumption may undesirable right also cause degradation system performance chip heats sfr fault causes harmless unnecessary loading garbage values register result unnecessary power consumption register combinational logic driven register essence fault undermines gated clock scheme used low power design show extent effects power measured dynamic power consumption 4bit storage elements implementation used components 08micron vcc4dp3 datapath library vlsi technology 1993 compass design automation tools compass design automation 1993 ran compass toolset power enable switch report average power consumption large number random patterns table shows experiment measure power consumption fixed means fixed signal randomly selected value kept unchanged entire simulation process random means signal driven random patterns note even data input storage element fixed considerable amount power consumption component due clock signal systemfunctionally redundant stuckat1 faults load line cause dramatic 9increase power consumption random data inputs power consumption latch rises 56 176 watts fixed inputs power consumption rises 26 97 watts 200300 increase power one latch worst case j average simulation nonembedded storage element verify phenomenon occurs storage elements embedded circuit repeated power simulation complete design implements differential equation solver careful inject faults systemfunctionally redundant throughout experiment functionality datapath remains faultfree case table ib summarizes result fault 1 2 correspond two different systemfunctionally redundant single stuckat1 faults two specific register load lines presence fault 1 causes 2 increase overall power consumption presence fault 2 causes 9 increase column labelled multiple effects reflects worst case scenario particular example registers load often possible without disrupting datapath functionality scenario multiple registers load multiple times increase power consumption dramatic 75 another example undesirable nonfunctional fault effect presence fault may indication manufacturing problem taking example aitken 1995 one manufacturing problem seen real integrated circuits cracks insulation layers time metal migrates cracks forming shorts systemfunctionally redundant fault caused manufacturing problem may indicate serious problems come shorts form therefore worth detecting 4 design solution section describes solution controller testing problem adds small finite state machine fsm system fsm piggybacks onto original controller interacting controller way effects controllerfunctionally irredundant cfi faults systemfunctionally irredundant redundant sfi sfr within controller pushed data flow observed outputs datapath registers goals scheme follows ffl scheme work existing adhoc systematically synthesized controller datapath pair without architectural change ffl overhead scheme less overhead required separate test scheme ffl scheme complement test schemes controller datapath indicated designer making possible detect sfr interface faults ffl faults observable directly controller outputs whether systemfunctionally redundant irredundant made observable datapath registers scheme key method push effects controller faults controller datapath interface datapath registers conditions done successfully explored section 41 section 42 shows implementation details scheme explains finite state machine added x z c e x z c ed e b c fig 7 propagation fault effect control line data flow multiplexer select lines b register load lines c closer view register load line case system ensures necessary conditions present observe faults datapath registers section 43 show observation costs reduced observing single bit pertinent datapath register rather whole register 41 propagation controller faults section discuss propagate effect controllerfunctionally irredundant cfi faults within controller datapath cfi fault cause least one output controller change least one time step control schedule barring detailed gate level analysis controller want sure catch cfi faults within controller must sure detect change control line one time step key approach ensure changes control lines cause changes data flowing datapath follows consider multiplexer select line fault effects register load line stuckat1 effects register load line stuckat0 effects separately figure 7a shows fault effect select line multiplexer point fault causes wrong path multiplexer selected time step control schedule time step example multiplexer may pass incorrect value instead correct value x noticeable point b long x 6 turn alu performs operation correct xz effect fault propagates datapath point c preserve fault effect propagate point register must loaded time step otherwise result erroneous operation z never written therefore lost figure 7b illustrates fault effect register load line point e suppose first fault causes load line stuckat0 time step case register loaded thus keeps old value rather obtaining new value ct noticeable output register location ct gamma 1 6 ct ie missed load would written new value register assuming system designed redundant computations done case least test patterns register load line stuckat1 time step register loaded noticeable register output location new value inadvertently loaded different old value referring figure 7b see number ways happen first multiplexer select line could changed value since last time register loaded operand alu comes different source noticeable long new source supplies different data value old source ie x 6 alternatively value x may changed since x coming another register datapath possible new value written x case inadvertent load cause xt z overwrite correct value faults discussed register primary output register multiplexer selects register loads subsequent time steps must serve propagate erroneous value register output observable point example case register load line stuckat1 time step inadvertent load caused fault noticed value register used least inadvertent load takes place note figure 7 solely example method restricted specific architectural style multilevel multiplexers fanouts outputs arithmetic logic units multiplexers registers invalidate argument elaborate shortly explain controller faults observed 42 implementation purpose fsm add system allow us detect changes controller output value looking outputs datapath registers rather directly controller outputs justify method looking single functional block datapath shown figure 1 single time step would like able detect change multiplexer select lines register load line time step following requirements ffl justification depend content register loaded time step ffl scheme work regardless values ms rl method works freezing original controller expand time step two time steps first two steps known value different supposed normal operation loaded register accomplished complementing multiplexer select lines loading register second two steps control signals normal operation produced original controller unfrozen make transition next normal mode state illustrated figure 8 figure shows testing controller time step normally would produce control signals ms expanded two time steps one produces one produces ms note side effect ms rl ms rl ms rl ms 1 ms rl ms rl ms 1 ms rl ms 1 b operation testing controller normal mode operation select register load fig 8 state diagrams illustrating added fsm interacts original controller ms ms ms ctlclock rlrl r r r controller testmode mask mask ms rl ctlclock ms rl fig 9 one possible logic implementation fsm added scheme slowing execution control schedule factor two logic implementation fsm needed effect changes quite inexpensive figure 9 shows one possible implementation elaborate role added fsm allowing detection cfi faults within controller best described figure 10 details different cases note table shows typical active components see figure 1 time step however simplicity subscript shown figure r r denote content register r multiplexer select lines ms ms respectively also ms f denotes multiplexer select least one bit faulty due controller fault ms f denotes complement r f denote content register r two situations ms ms ms ms ms ms rl ms ms f f sa0 rl faultfree circuit register r observed content register r ms rl detected sa1 ms detected faulty circuit 1 ms rl sa0 rl faultfree circuit register r observed content register r ms ms ms ms ms ms ms ms ms f f sa1 ms detected faulty circuit 1 ms rl detected case r supposed load b case r supposed load fig 10 effect interaction controller piggyback typical register r time step figure shows controller faults cause changes controller outputs ms rl lines given time step observed checking content register r figure split two cases case 1 faultfree system register loads new value time step part figure shows contents register r faultfree case presence three different kinds fault effects stuckat0 rl stuckat1 rl stuckat0 1 ms arrows show difference contents register indicates fault detected figure easily seen fault causes rl stuckat0 ms stuckat0 1 time step detected note fault causes rl stuckat1 time steps like one rl supposed 1 fault controllerfunctionally redundant targeted technique alu ms1 ms2 ms3 active path fig 11 active path multilevel multiplexers fanouts case 2 faultfree system register load new value time step results case shown part b figure arrows show fault causes rl stuckat1 ms stuck at0 1 time step detected note fault causes rl stuckat0 time steps rl supposed 0 fault controllerfunctionally redundant targeted technique mentioned earlier method pushing controller faults data flow restricted specific architectural style fact figure 10 ms refers select lines multiplexers forward data time step example figure 11 show active path data flow step fms1ms2ms3g ms indicates select lines three multiplexers including two multilevel multiplexers complemented desired effect forward incorrect data alu similarly rl refers registers loading data alu whether directly indirectly muxes figure 11 example fanouts multiplexeralu outputs registers driven alu could even beneficial testing since effect fault traveling controller datapath time step potential influence components erroneous values loaded checking feature stems fact multiplexer select lines complemented storage elements loaded additional control states 43 observation controller faults important point effect fault moves control line data flow moves single bit line multibit bus fault effect may seen one lines bus figure 7c shows transfer fault effect register load line nbit wide data flow individual bits data flow shown moving register load line fault effect location e location data bits fault effect change bus location depends specific values data noticeable bit data x 6 specifically noticeable bit data bus location bit x equal bit practical standpoint test datapath using reasonably large number random patterns possible observe control line faults without observing bits datapath bus single bit suffice bit choose likely least patterns cause change bit explore argument quantitatively suppose patterns written register random uniform distribution uncorrelated time let c denote bit tth pattern written register observe bit register output detect error affects register load line whenever c words fault escape detection c tgamma1 patterns written register assuming c random signal happen probability 1 must take value 0 1 n patterns probability takes particular value given pattern 1 therefore assumptions probability fault escapes detection drops exponentially test session length quite small even short test sessions note bits register output observed probability fault escaping detection would even smaller n bit register probability would 1 2 nn acknowledge practical circuits alus particular influence randomness signals assumption c remains random often valid bits signal example alu multiplies input 4 first two bits output remain zero time probability far ideal value 1empirically observed majority arithmetic logic alus randomness reduction invalidate argument almost bit used observation seen example system fault coverage curves figure 12 show effects observing single bit either significant bit least significant bit register versus observing datapath register bits curves corresponding single bit observation rise bit slowly full observation curve reach final fault coverage one easily perform behavioral simulation register transfer level datapath find bits successfully used observation previous work harmanani et al 1994 presented randomness analysis dataflow graph based entropy 1 simulation tool analyzes behavior computes randomness bit overall signals generated alus 5 experimental results section demonstrate approach using several example circuits circuits synthesized high level descriptions using syntest synthesis system harmanani et al 1992 output syntest register transfer level datapath state diagram controller logic level synthesis done using asic synthesizer compass design automation suite 1 entropy binary signal x defined jxj denotes bit width x p xi denotes probability x state fault coverage time clock phases full observation msb observation lsb observation fig 12 fault coverage curves proposed test scheme controller differential equation solver datapath register bits observed versus observing least significant bit register tools compass design automation 1993 using finite state machine implementation controller based 08micron cmos library vlsi technology 1993 test pattern generation registers tpgrs necessary builtin selftest bist synthesized using compasss test compiler fault coverage curves found resulting logic level circuits using atts gentest fault simulator att 1993 gentest uses single stuckat fault model probability aliasing within misrs neglected faults within tpgrs test circuitry although datapath controller tested together separated fault coverage curves controller clarify results work four example circuits eight bit wide datapaths first evaluates third degree polynomial second example implements differential equation solver standard high level synthesis benchmark gajski et al 1992 third example another high level benchmark known facet example gajski et al 1992 finally fourth example well known fifth order elliptical filter kung et al 1985 basis comparison show fault coverage transistor count results three different test schemes together test corresponds completely integrated test datapath con troller additional hardware added internal system case drive inputs system tpgr observe system outputs make changes datapathcontroller interface piggyback test corresponds new test scheme facilitating integrated controllerdatapath test add piggyback finite state machine interface datapath controller drive inputs system tpgr observe one bit datapath registers separate test corresponds independent test controller separate system case drive inputs controller tpgr observe controller outputs directly transistor counts given entire system given test scheme include datapath controller circuitry necessary test fault coverage time clocks separate test piggyback test together test polynomial evaluator85950 50 100 150 200 250 fault coverage time clocks separate test piggyback test together test b differential equation solver85950 100 200 300 fault coverage time clocks separate test piggyback test together test c facet benchmark85950 50 100 150 200 fault coverage time clocks separate test piggyback test together test wave benchmark fig 13 fault coverage curves controllers four example circuits piggyback test scheme includes transistor count added finite state machine fault coverage results four examples shown parts b c figure 13 respectively fault coverage controller fault coverage graphs vertical axes show fault coverage percentage controller faults detected horizontal axes show time function clock cycles tests controller run normal mode case polynomial schedule five control steps separate together schemes example 100 clocks controller run schedule times piggyback scheme action added finite state machine serves slow speed twice slow 100 clocks controller run schedule 10 times see one penalty approach takes approximately twice long fault coverage curves saturate using piggyback scheme effect seen four example circuits however serious limitation controller test still quite short especially compared test datapath may easily order magnitude longer carletta papachristou 1997 expected together test scheme results low fault coverage controller four examples due fact difficult observe controller outputs datapath scheme systemfunctionally redundant faults go undetected hand sep 8d bitwidth input data dout bitwidth output data r number registers number multiplexer select lines number status lines parameters system size together piggyback separate test scheme test scheme test scheme width tpgr associated muxes width misr dout associated muxes gates xor r b test circuitry required terms parameters table ii test circuitry required three test schemes arate test scheme good job testing controller scheme observes controller outputs directly test scheme capable catching controllerfunctionally irredundant faults including systemfunctionally redundant ones see curves piggyback scheme final fault coverages nearly high separate case indicates piggyback successful pushing systemfunctionally redundant faults datapath table ii summarizes test circuitry needed three test schemes terms key system parameters includes tpgr misr muxes associated example muxes needed control whether data inputs datapath coming tpgr test mode system inputs normal mode single misr used test datapath controller muxes needed determine component driving misr given time table iii shows relative sizes systems implementing three test schemes four example circuits overhead given relative overhead together test scheme since together scheme represents minimal amount test circuitry used bist scheme together test scheme lowest area test circuitry since attempt made observe extra controller datapath lines drawback however low fault coverage extreme separate test scheme highest fault coverage highest observability also highest area overhead ranging 108 239 examples shown middle piggyback test scheme fault coverage almost good separate test scheme area overhead much lower 38 76 overhead advantage piggyback scheme separate scheme arises two sources first reduced area requirements tpgr compared separate scheme due fact separate scheme tpgr must least wide enough generate test bits inputs datapath data control contrast piggyback scheme control lines driven controller tpgr must wide input data one extra bit start input controller together piggyback relative separate relative design test scheme test scheme overhead test scheme overhead poly 8186 8684 61 9839 202 facet 12966 13460 38 14371 108 table iii relative sizes systems three test schemes number transistors overhead figures relative size system together test scheme design together piggyback separate tpgr misr tpgr misr tpgr misr poly 729 819 0 0 43 0 facet 729 440 0 50 76 100 table iv comparing tpgr misr overhead three test schemes number transistors together test scheme relative together method two test schemes similar savings number associated multiplexers often results significant area savings second source reduced area requirements misr due indirect observation control lines datapath registers separate scheme requires misr wide enough watch outputs datapath outputs controller whichever wider consider system controller outputs outnumber datapath outputs misr must least big r 1 r number registers number multiplexer select lines piggyback scheme contrast require misr wide enough watch r bits thus see larger comparison r save area misr similar savings associated multiplexers necessary sharing misr testing datapath controller thus circuits number controller outputs outnumber number datapath outputs reasonably large compared r see significant reduction amount observation circuitry needed circuits may significant reduction amount observation circuitry may even grow slightly however stated benefits like detecting faults would cause excessive power consumption still exist seen results test scheme requires slightly observation circuitry two circuits differential equation solver number datapath outputs outnumber number controller outputs savings misr width possible facet example eleven register load lines two multiplexer select lines small relative r offset addition logic needed finite state machine required piggyback approach general many designs number multiplexer select lines outnumber register load lines especially distributed multiplexors buses tristate buffers onehot encoding multiplexor control used two circuits use piggyback scheme result reduction amount observation circuitry 6 conclusion paper proposes scheme facilitating testing datapath controller pairs advocates testing pair integrated way rather testing datapath controller completely independently separating system environment test scheme adds small finite state machine system serves enhance observability controller outputs controller faults observed outputs registers datapath experimental results show use scheme results onethird test overhead required scheme datapath controller tested sepa rately fault coverage good nearly good addition integrated scheme control lines used communicate controller datapath thoroughly tested r constructing optimal test schedules vlsi circuits builtin test hardware finding defects fault models optimum heuristic algorithms approach finite state machine decomposition state assignment low power dissipation ieee custom integrated circuits conf automatic synthesis gated clocks power reduction sequential circuits behavioral synthesis hierarchical testability con trollerdatapath circuits conditional branches computer design concurrent control multiple bit structures test maintenance controller module containing testable chips synthesis controllers full testability integrated datapathcontroller pairs testability analysis insertion rtl circuits based pseudorandom bist behavioral testability insertion data pathcontroller circuits compass design automation mustang state assignment finite state machines targeting multilevel logic implementations decomposition factorization sequential finite state machines controllerbased designfor testability technique controllerdatapath circuits optimized synthesis selftestable finite state machines synthesis testability large complexity controllers method testability insertion rtl behavioral structural syntest environment systemlevel design test efficient pprocedure synthesis fast selftestable controller structure distance reduction approach design testability distributed hardware approach builtin self test scheme overlaying concurrent testing vlsi circuits test scheduling testable vlsi circuits vlsi modern signal processing optimized testable architecture finite state machine architectural partitioning system level design synthesis optimal 1hot coded onchip controllers bist hardware scheme integrated controllerdatapath fault testing fast identification robust dependent path delay faults tr architectural partitioning system level design scheme overlaying concurrent testing vlsi circuits highlevel synthesis efficient procedure synthesis fast selftestable controller structures fast identification robust dependent path delay faults activitysensitive architectural power analysis control path controllerbased designfortestability technique controllerdata path circuits behavioral testability insertion datapathcontroller circuits scheme integrated controllerdatapath fault testing synthesis controllers full testability integrated datapathcontroller pairs vlsi modern signal processing behavioral synthesis hierarchical testability controllerdata path circuits conditional branches synthesis testability large complexity controllers testability analysis insertion rtl circuits based pseudorandom bist finding defects fault models distance reduction approach design testability optimized testable architecture finite state machines
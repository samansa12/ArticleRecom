localizing failures distributed synchronization abstractthe faulttolerance distributed algorithms investigated asynchronous message passing systems undetectable process failures two specific synchronization problems considered dining philosophers problem binary committee coordination problem abstraction bounded doorway introduced general mechanism achieving individual progress good failure locality using building block optimal faulttolerant algorithms constructed two problems b introduction ability tolerate failures important design requirement computer systems general distributed systems particular detection failures becomes difficult systems investigate effects failures distributed synchronization problems require cooperation set independent processes specific problems study assume underlying undirected graph defines neighborhood processes interprocess communication messagepassing possible neighboring processes goal design solutions effect failure process confined immediate neighborhood words interested solutions processes shielded effects nonlocal failures assume failstop model failures undetectable failed processes indistinguishable processes slow choose problems dining philosophers committee coordination representatives class distributed synchronization problems dining philosophers problem generalization mutual exclusion problem used solve many synchronization problems committee coordination problem occurs languages csp 4 ada 1 based synchronous message communication use failure locality 6 measure degree fault tolerance failure locality algorithm denotes size neighborhood gets affected failure thus algorithm failure locality process failures within distance underlying graph executes failures occurred words process continues meet specified safety progress properties main contribution paper presentation tight lower bounds failure locality solutions dining philosophers committee coordination problem achieved presentation lower bounds design solutions achieve part optimal algorithms also introduce idea bounded doorway doorway interesting property coupled algorithm ensuring absence global starvation doorway ensures absence local starvation without adding failure locality algorithm contrast kind doorways 6 13 add failure locality underlying algorithm rest paper organized follows section 2 present relevant back ground section 3 introduce idea bounded doorways section 4 solve dining philosophers problem optimal failure locality section 5 solve committee coordination problem optimal failure locality brief discussion appears section 6 appendix contains proofs theorems used main body paper relevant background locality distributed computation studied many authors 2 14 19 20 linial 14 considered problem computing functions require global communication compute function process starts local data computation information exchanged neighboring processes finally processes terminates returns value function said computed locally 2 computed time less diameter network functions include finding maximal independent set 2 11 14 15 computing nodes edge colorings network 2 10 paper investigate locality distributed synchronization problems require processes terminate return results particular concentrate dining philosophers problem 8 16 committee coordination problem 5 dining philosophers problem consists set processes set resources modeled conflict graph process mapped node conflict graph resource mapped edge many solutions dining philosophers problem appear literature 3 5 6 16 20 styer peterson 20 perhaps first consider issue locality problem measure locality algorithm length longest waiting chain processes may formed system formalize idea waiting chains notion failure locality dining philosophers problem failure locality algorithm defined smallest number process failures within distance conflict graph free starvation algorithms obtained styer peterson achieve failure locality 3 recently considered problem achieving good failure locality conjunction problem achieving good response time good message complexity 6 presented solutions achieved failure locality 4 maintaining quadratic degree conflict graph response time quadratic message complexity paper also contains algorithm achieves failure locality 3 however question best achievable failure locality remained open committee coordination problem consists set interactions committees set processes problem initially arose rendezvousbased communication languages like csp ada 1 4 subset processes needs exchange information synchronous manner conflict graph constructed problem mapping interaction node placing edge interactions share common process concentrate binary version problem every interaction two members binary general versions problem solved many researchers 4 5 6 12 18 19 sistla 19 calls solution problem real time complexity independent size communication network also investigates formation waiting chains uses derive lower bound response time define failure locality solutions committee coordination problem smallest number continuously ready interaction failures within distance conflict graph eventually committed recently presented solutions committee coordination problem failure locality 2 6 question optimal failure locality remained open 3 bounded doorways solutions problems requiring absence local starvation often composed two parts 6 13 20 first part satisfies requirements problem except ensures absence global starvation ie deadlocks second part solution usually called doorway translates absence global starvation underlying solution absence local starvation ie progress respect process composite solution words doorway takes program f ensuring absence global starvation produces composite program consisting f local starvation occur various kinds doorways defined used literature basic kind called firstcomefirstserved doorway defined used lamport 13 context mutual exclusion problem doorway consists finite sequence nonwaiting statements enforces firstcomefirstserved behavior though useful shared variable systems doorway cannot used message based systems doorway would consist waiting statements order enforce firstcomefirstserved behavior variant doorway used styer peterson solve dining philosophers problem message based model similar 20 scheme neighboring processes executes p operation common semaphore implemented passing messages entering doorway v operation exiting doorway two kinds doorways called single doorway double doorway introduced 6 order avoid unbounded overtaking doorways require processes outside doorway wait processes inside doorway increases failure locality composite solution least one paper introduce new kind doorway increase failure locality underlying computation doorway referred bounded doorway implemented dynamically assigning set distinct ids processes ids distinct used resolving conflicts occur execution algorithm assume underlying solution resolves conflicts favor process smaller id doorway algorithm process made progress selects neighbor higher id perform id exchange exchange results neighbor smaller id ie higher priority id exchange involves sending exchg message selected neighbor waiting acknowledgement returned broadcast new id processes process receiving exchg message agrees exchange ids lead smaller id process currently participating another exchange process maintains queue neighbors chooses candidate process id exchange scanning queue process higher id exchange needed neighbors lower id order ensure fairness process chosen placed end queue exchange ids thus process makes progress infinitely often neighbors starving eventually higher id consequently lower priority neighbors allow neighbors make progress avoid starvation 4 dining philosophers problem 41 problem description problem consists number processes may one three states thinking hungry eating predicate thinking denotes process thinking predicates hungry eating defined similarly initially every process thinking thinking process becomes hungry needs access resources adjoining edges process stays hungry allowed eat dining philosophers algorithm process accesses resources eating period assumed finite eating process transits thinking state dining philosophers algorithm satisfy two requirements mutual exclusion requires neighboring processes eat time starvation requires every hungry process eventually gets chance eat process may fail time computation failure process modeled auxiliary predicate failed predicate initially false set true failure process true remains true forever assume failstop mode failures failure process undetectable particular implies predicate failed cannot used code algorithm predicate however used proofs correctness stated earlier measure faulttolerance algorithm failure locality formally failure locality algorithm defined smallest number process failures within distance conflict graph free starvation require failures effect safety properties mutual exclusion algorithm example consider conflict graph 7 processes shown figure 1 failure locality algorithm 1 failures effect progress processes outside immediate neighborhood failed process words failure process 1 starve processes 23 4 failure process 4 starve processes 1235 6 algorithm failure locality 2 failure process 1 cannot starve process 7 viceversa figure 1 example conflict graph 42 impossibility result easy see failure locality 0 ie failure process starve processes unachievable process may fail eating means immediate neighbors unaware failure may starve following theorem states failure locality 1 also unachievable theorem 1 exist solution dining philosophers problem failure locality 1 proof suppose exists solution failure locality one consider problem instance 3 processes neighbors j k neighbors consider following execution history none processes fail initially processes thinking process becomes hungry first since thinking processes may remain thinking forever exists future state starts eating j k still thinking assume eating j k become hungry possible process undetectably eating therefore order ensure failure locality one process k allowed eat thus exists future state k eating j hungry suppose finishes eating becomes hungry argument exists future state k remains eating j remains hungry starts eating let process stop eating become hungry leads us back state existed earlier history process eating processes j k hungry note process j remains hungry intermediate states scenario may repeat continuously giving us desired contradiction process j remains hungry forever though none neighbors failed 2 initially main procedure ack processes n order wait ack pending wait allforks allforks alllowforks release releasehigh forever figure 2 algorithm process 43 optimal algorithm construct optimal algorithm failure locality 2 algorithm consists two parts bounded doorway discussed section 3 scheme ensure mutual exclusion absence global starvation mutual exclusion ensured associating forks edges maintaining invariant eating process neighboring forks order ensure absence global starvation conflicting requests fork resolved favor process smaller id since may lead formation long waiting chains turn results poor failure locality processes break long chains selectively releasing forks however process smallest id release forks ensures absence global starvation id exchange mechanism due bounded doorway ensures continuously hungry process eventually smaller id competing neighbors able eat composite algorithm thus also ensures freedom local starvation algorithm shown figures 2 3 process set n defines neighbors given process j 2 n refer process j high neighbor process refer process low neighbor process j similarly fork processes referred high fork process low fork process j process uses number local variables refers id process variable id ij refers id process j known process boolean fork ij true iff fork processes j process initially fork process smaller id presence process inside bounded doorway indicated variable ack variable false iff process executing code bounded doorway ie exchanging id neighbor queue q used order select next process receiving message hrequesti j id ij pending receiving message hrequesti j id ij pending releasehighforks fi receiving message hfork flagi j requested ij f lag pending alllowforks requesthighforks lag receiving message hexchg idi j ack send hexchgyes id j k 2 n send hnewid idi k od alllowforks hungry requesthighforks fi else send hexchgnoi j fi receiving message hexchgyes idi j k 2 n send hnewid idi k od ack true receiving message hexchgnoi j ack true receiving message hnewididi j procedure requestforks j 2 n send hrequest j requested ij true fi od procedure requesthighforks j 2 n send hrequest j requested ij true fi od procedure releaseforks j 2 pending od releaseforks procedure releasehighforks j 2 pending od releasehighforks procedure releaseid ack send hexchg id j fi procedure sendforkj pending pending send hfork truei j requested ij true else send hfork falsei j fi figure 3 algorithm process continued exchanging ids initially ack true q set arbitrary ordering processes n requested ij true iff process sent outstanding fork request process j set pending contains fork requests yet serviced process becomes hungry attempts collect missing forks sending request messages procedure requestforks neighbors process receiving request fork decides whether going release fork requester j depending state relative order ids id ij fork released process thinking collected low forks condition captured predicate releasehigh fork released along captured high forks order avoid formation long waiting chains process thinking collected forks condition captured predicate release note procedure sendfork process releasing fork hungry informs requesting process setting flag fork true fork released requesting process id requester saved set pending future consideration reception fork completes collection low forks process request missing high forks made calling procedure requesthighforks otherwise fork received high fork true flag fork returned sender process gathers forks transits eating state enters critical section upon exiting critical section sets state thinking releases forks pending executes bounded doorway code ie procedure releaseid order exchange ids procedure process first invokes function next choose next process higher id queue q process exists id returned moved end queue otherwise special value null returned implementation function straightforward shown function next returns nonnull value j ack set false exchg message sent process j upon receiving message process j participates id exchange iff outside doorway indicated ack true id exchange lower id case process j sends exchgyes message also informs neighbors new id otherwise process j responds exchgno message process upon receiving positive acknowledgement process j process completes id exchange process informs neighbors new id negative acknowledgement received exchange carried either case ack set true next iteration state transitions begins 44 proof correctness use temporal operators 2 3 17 following proof briefly 2p means formula p holds states history beginning current state 3p means formula p holds future state history beginning current state following two lemmas proved appendix lemma 1 nonfailed process starves eventually every neighbor j ordering id id j becomes fixed formally 22failed lemma 2 nonfailed process starves eventually low neighbor j either fails remains noneating forever id ji 22failed failed j eating j construct waiting graph w starving nonfailed process follows process w ffl process j w apply lemma 2 add neighbor k w failed k holds ffl repeat processes added w informally graph w includes process starving nonfailed processes reachable chain decreasing ids processes w following lemma proved appendix lemma 3 process j w low neighbor k j eventually fork j k either remains j forever remains k forever formally ii based lemma prove following theorem failure locality algorithm theorem 2 process starves failed process distance 2 proof sake contradiction assume process starves processes within distance 2 fail lemma 3 neighbor j process eventually either holds forever two cases consider either eventually process holding low forks forever eventually process missing low fork forever former case process sends requests necessary high neighbors collect high forks since processes fail eventually release forks thus process eventually collect forks start eating contradicts assumption process starves second case let j low neighbor holds fork process forever since process j holding high fork must collected low forks consequently process j start collecting missing high forks since processes within distance 2 fail processes within distance 1 j fail implies process j able collect high forks start eating eventually process j finishes eating release fork process contradicts assumption fork shared processes j stays process j forever 2 5 committee coordination problem 51 problem description problem consists set processes set interactions process predetermined set interactions may participate interaction predetermined set processes cooperate execute processes may participate interaction physically close communicate directly process may one three states idle ready commit predicate idle denotes process idle predicates ready commit defined similarly initially processes idle time time process becomes ready take part interactions associated remains ready one interactions committed similar process interaction may also one three states idle ready commit interaction ready executed processes associated ready interaction commit state processes participating committed perform interaction idle otherwise execution interaction interaction processes associated interaction state commit commitment interaction eventually terminates point interaction processes become idle say two interactions conflict share common process based conflict relation interactions define conflict graph follows represent interaction node place edge two nodes corresponding interactions conflict mentioned earlier state transitions process occur order idle ready commit back idle state transitions interaction similar except fact interaction may transit state idle directly state ready two neighboring interactions may ready time committing one changes state idle time interaction committed assumed finite solution committee coordination problem satisfy two safety requirements synchronization mutual exclusion one progress requirement weak interaction fairness synchronization requires commitment interaction started ready mutual exclusion requires two interactions sharing common process commit simultaneously weak interaction fairness requires interaction continuously ready eventually committed dining philosophers problem process may fail time computation modeled auxiliary predicate failed say interaction fails process belonging fails failure locality algorithm defined smallest number interaction long interactions within distance conflict graph fail requirement weak interaction fairness satisfied failures impact requirements synchronization mutual exclusion safety properties 52 impossibility result following theorem shows effect failure process cannot limited interactions participates theorem 3 exist solution committee coordination problem achieves failure locality 0 proof proof reduction wellknown result impossibility distributed consensus one faulty process 9 assume exists algorithm achieves failure locality 0 words algorithm supposedly ensures long processes interaction ready fail interaction one neighbors commit eventually use algorithm solve distributed consensus problem three processes consensus problem every process initial value nonfailed processes agree common value one initial values case three processes consider form three interactions fi jg j fj kg k fk ig devise mechanism commitment interaction eg implies consensus reached initial value corresponding process case every process first broadcasts initial value processes becomes ready participate interaction member requirements synchronization mutual exclusion weak interaction fairness underlying committee coordination algorithm commits exactly one interactions j k processes participating committed interaction broadcast identity third process finally processes agree initial value process corresponding committed interaction since processes broadcast initial values becoming ready value corresponding committed interaction available processes since one process fails least one interaction ready committed assumed failure locality underlying committee coordination algorithm least one interaction commits therefore least one process able broadcast identity committed interaction result nonfailed processes agree common value one initial values 2 initially main procedure ack processes n order wait ack pending wakeupneighbors wait commit hperform state releaseid forever figure 4 algorithm process 53 optimal algorithm construct optimal algorithm failure locality 1 binary version problem dining philosophers problem use bounded doorway processes exchange ids another piece code ensures two safety properties global progress every interaction process smaller id designated manager responsible committing interaction process may possibly manage several interactions based upon relative ordering ids processes process set n defines set processes participate common interaction process process becomes ready attempts commit interactions manages invoking procedure requestcommitment executing procedure process sends request messages process j fi jg interaction managed process process j receives request replies yes message ready sent yes message another manager otherwise saves set pending j local variable set true iff process j sent yes message manager upon receiving yes message process j process commits interaction fi jg provided still ready responded yes message manager otherwise manager responds release message process j receiving release message process j informs neighboring managers retransmit request messages sending wakeup message process pending j receiving wakeup message process j processes try commit corresponding interactions complete algorithm shown figures 4 5 local variables id ack dining philosophers algorithm implementation bounded doorway ie procedure releaseid also previous solution receiving message hrequesti j ready send hyesi j else pending receiving message hyesi j send hcommiti j state else send hreleasei j fi requested ij receiving message hreleasei j wakeupneighbors requestcommitment receiving message hwakeupi j requested ij ready send hrequesti j requested ij true fi receiving message hexchg idi j ack id send hexchgyes id j k 2 n send hnewid idi ki od else send hexchgnoi j fi receiving message hcommiti j state commit receiving message hexchgyes idi j k 2 n send hnewid idi ki od ack receiving message hexchgno idi j ack receiving message hnewididi j procedure requestcommitment j 2 n bound send hrequesti j requested ij true fi od requestcommitment procedure wakeupneighbors j 2 pending send hwakeupi j od pending wakeupneighbors procedure releaseid ack send hexchg id j fi figure 5 algorithm process continued 54 proof correctness following two lemmas proved manner similar lemma 1 lemma 2 lemma 4 nonfailed process remains ready forever eventually every neighbor j ordering id id j becomes fixed formally 22failed lemma 5 nonfailed process remains ready forever eventually low neighbor either fails remains noncommitted forever formally 22failed failed j construct waiting graph w nonfailed process ready forever follows process w ffl process j w apply lemma 5 add neighbor k w holds ffl repeat processes added w informally graph w includes process nonfailed processes ready forever reachable chain decreasing ids processes w following lemma proved appendix lemma 6 process j w eventually bound j becomes stable formally based lemma prove following theorem failure locality algorithm theorem 4 interaction remains ready forever either interaction conflicting fails proof sake contradiction assume interaction remains ready forever interactions conflicting fail let j two processes lemma 4 assume without loss generality belong w lemma 6 eventually bound bound j become fixed bound j becomes fixed true since neighboring interactions fail process j eventually send yes message nonfailed process process eventually respond commit release message former case process j becomes nonready latter case bound j reset false possible assumption therefore must case bound j fixed false eventually similarly shown bound fixed false eventually algorithm process j sends request message process time bound j reset false consider request message sent process j becomes fixed false process responds message either yes wakeup message former case process j becomes nonready latter case process j retransmits request message former possible process j remains continuously ready therefore process j sends request message process infinitely often since bound eventually fixed false process eventually respond yes message thus committing interaction contradicts assumption remains ready forever 2 6 concluding remarks paper proved failure locality one cannot achieved dining philosophers problem impossibility result essentially based absence global information totally asynchronous distributed system subsequently presented algorithm optimal failure locality two algorithm based idea bounded doorway processes exchanged ids neighbors upon making progress considered committee coordination problem showed failure locality 0 unachievable problem proof based reduction problem distributed consensus finally presented optimal algorithm binary version problem based idea bounded doorway general case committee coordination problem solved reduction dining philosophers problem 5 use optimal algorithm presented resulting solution committee coordination problem failure locality two open question whether failure locality one achieved problem r reference manual ada programming language network decomposition locality distributed computation dining philosophers algorithm polynomial response time effective implementation generalized inputoutput construct csp parallel program design foundation efficient fault tolerant algorithms resource allocation distributed systems adaptive algorithms mutual exclusion problem hierarchical ordering sequential processes impossibility distributed consensus one faulty process parallel ffi fast parallel algorithm maximal independent set problem algorithm nparty synchronization using tokens mutual exclusion problem part ii distributive algorithms global solutions local data simple parallel algorithm maximal independent set problem fast allocation nearby resources distributed system cook temporal proof system pet language new efficient implementation multiprocess synchronization distributed algorithms ensuring fair interprocess communications improved algorithms distributed resource allocation tr ctr hagit attiya eyal dagan improved implementations binary universal operations journal acm jacm v48 n5 p10131037 september 2001 yehuda afek michael merritt gadi taubenfeld dan touitou disentangling multiobject operations extended abstract proceedings sixteenth annual acm symposium principles distributed computing p111120 august 2124 1997 santa barbara california united states
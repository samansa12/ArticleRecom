loop checks logic programs functions two complete loop checking mechanisms presented literature logic programs functions oscheck evacheck oscheck computationally efficient quite unreliable often misidentifies infinite loops whereas evacheck reliable majority cases quite expensive paper develop series new complete loop checking mechanisms called vafchecks key technique introduce notion expanded variants captures key structural characteristic finite loops show approach superior oscheck evacheck efficient oscheck reliable evacheck copyright 2001 elsevier science bv b introduction recursive nature logic programs leads possibilities running innite loops topdown query evaluation innite loop refer innite sldderivation illustrative example evaluation goal pa logic program leads innite loop another representative logic program currently leave department computing science university alberta edmonton alberta canada t6g 2h1 email ydshencsualbertaca fax 780 4921071 evaluating query pga generates innite loop loop checking long recognized problem logic programming 1 although many loop checking mechanisms proposed last decade eg 1 2 6 7 9 12 14 17 19 20 22 23 majority eg 1 2 6 7 9 12 19 20 22 23 suitable functionfree logic programs determine innite loops checking variant goalssubgoals sldderivations variant goalssubgoals goalssubgoals variable renaming hence innite loop like l 2 detected variant goalssubgoals occur derivation important fact functionfree logic programs innite loops completely avoided appealing tabling techniques 4 5 18 21 23 24 however innite loops functions remain unresolved even tabling systems 13 best knowledge among existing loop checking mechanisms two deal innite loops like l 2 one called oscheck oversize loop check 14 evacheck extended variant atoms loop check 17 oscheck rst introduced sahlin 14 15 formalized bol 3 determines innite loops based two parameters depth bound size function size informally os check says sldderivation may go innite loop generates oversized subgoal subgoal said oversized ancestor subgoals sldderivation predicate symbol whose size smaller equal example choose innite loop proved oscheck complete sense cuts innite loops however merely takes number repeated predicate symbols size subgoals decision parameters without referring informative internal structure subgoals underlying decision fairly unreliable ie many nonloop derivations may pruned unless depth bound set suciently large evacheck proposed shen 17 determines innite loops based depth bound generalized variants informally evacheck says sldderivation may go innite loop generates subgoal 0 generalized variant ancestor subgoals subgoal 0 said generalized variant subgoal variable renaming except arguments whose size increases via set recursive clauses recursive clauses form like c 21 p 2 one distinct property repeatedly applying may lead recursive increase size subgoals 1 two dierent topics termination logic programs one termination analysis see 8 detailed survey loop checking see 1 23 paper study loop checking recursive increase term size key feature innite loops functions innite loops innitely large subgoals generated repeatedly applying set recursive clauses due fact evacheck complete much reliable oscheck sense less likely misidentify innite loops 17 oscheck obvious advantage simplicity unreliable contrast evacheck reliable majority cases computationally expensive main cost evacheck comes computation recursive clauses one hand given logic program need determine clauses recursive clauses hand subgoals 0 sldderivation order determine 0 generalized variant need check 0 derived applying set recursive clauses observation shows processes timeconsuming paper continue explore complete loop checking mechanisms proved quite useful stopping criteria partial deduction logic programming 11 see 3 relation stopping criteria partial deduction loop checking one hand unlike oscheck fully employ structural characteristics innite loops design reliable loop checking mechanisms hand instead relying expensive recursive clauses extract structural information innite loops directly individual subgoals introduce new concept expanded variants captures key structural characteristic certain subgoals innite loop informally subgoal 0 expanded variant subgoal variant except terms ie variables constants functions grows 0 function containing term notion expanded variants provides useful tool series complete loop checking mechanisms dened paper develop four vafchecks variant atoms loop checks logic programs functions v af 1 4 depth bound loops based expanded variants v af 2 enhances v af 1 taking account one innitely repeated clause v af 3 enhances v af 2 constraint set innitely repeated clauses v af 4 enhances v af 3 constraint recursive clauses reliability increases v af 1 v af 4 computational overhead increases balancing two key factors choose v af 2 best practical applications v af 2 complexity oscheck far reliable oscheck 2 v af 2 reliable vast majority logic programs moreover less reliable evacheck v af 2 much ecient evacheck like oscheck compute recursive clauses plan paper follows section 2 review basic concepts concerning loop checking section 3 introduce expanded variants examine properties section 4 dene four vafchecks prove completeness section 5 make comparison vafchecks oscheck evacheck preliminaries section review basic concepts concerning loop checking assume familiarity basic concepts logic programming presented 10 throughout logic program always mean positive logic program variables begin capital letter predicate symbols function symbols constants lower case letter let atomfunction size denoted jaj count function symbols variables constants use rela refer predicatefunction symbol use ai refer ith argument aij refer jth argument ith argument aik refer kth argument ith argument example let denition 21 variant sldderivation resp goal subgoal atom function mean derivation resp goal subgoal atom function 0 variable renaming denition 22 1 3 let p logic program g 0 top goal computation rule 1 let l set sldderivations p fg 0 g dene proper subderivation dg l subderivation free 2 simple loop check computable set l nite sldderivations l closed variants subderivation free observe loop check l formally denes certain type innite loops generated ie sldderivation g 0 said step innite loop g k g 0 l therefore whenever innite loop detected cut immediately g k leads following denition denition 23 let sldtree p fg 0 g l loop check let sldderivation top goal g 0 g 0 lg applying l obtain new sldtree consists nodes goals cut pruned pruning node sldtree mean removing descendants order justify loop check bol et al introduced following criteria denition 24 1 let computation rule loop check l weakly sound following condition holds every logic program p top goal g 0 sldtree p fg 0 g contains successful branch contains successful branch loop check l complete every innite sldderivation pruned l put another way loop check l complete logic program p top goal g 0 ideal loop check would weakly sound complete unfortunately since logic programs full power recursive theory loop check weakly sound complete even functionfree logic programs 1 mentioned introduction paper explore complete loop checking mechanisms order compare dierent complete loop checks introduce following concept denition 25 complete loop check l 1 said reliable 2 complete loop check logic program p top goal g 0 successful sldderivations tl1 less tl2 vice versa proved evacheck reliable oscheck 17 introduction mentioned notion ancestor subgoals denition 26 17 subgoal sldtree ancestor list ala dened recursively follows 1 root fg 2 let node sldtree 1 selected resolve clause 0 1 child node let ancestor list ala ancestor list alb b n ala1 fa 1 g ancestor list ala j j ala j obviously subgoals b ancestor list b ie 2 alb proof requires proof b denition 27 let g g k two nodes sldderivation b selected subgoals g g k respectively say ancestor subgoal b denoted anc b following result shows ancestor relation anc transitive theorem 21 1 anc 2 2 anc 3 1 anc 3 proof denition ancestor lists subgoal 2 ala 0 ala ala 0 ala 3 thus 1 2 ala 2 ala3 implies 1 2 ala 3 1 anc 3 2 17 phrased sound loss generality sequel assume leftmost computation rule selected subgoal node leftmost subgoal convenience node goal g unless otherwise specied use refer leftmost subgoal g 3 expanded variants design complete reliable loop check rst need determine principal characteristics innite loop possesses consider innite loop l 2 see introduction notice 0 subgoal pfffga 1th node g i1 variant subgoal pffga ith node g except function ga g grows function fga g i1 however replace ga constant l 2 pfffa g i1 variant pffa g except constant g grows function fa g i1 furthermore replace ga variable x l 2 pfffx g i1 variant pffx g except variable x g grows function fx g i1 another example consider program let top goal g z get innite loop l 3 depicted fig1 observe 0 subgoal g 2i1 variant g 2i except variable g 2i grows fa g 2i1 fig1 innite loop l 3 observations reveal key structural characteristic subgoals innite loop functions formalized follows denition 31 let 0 two atomsfunctions 0 said expanded variant denoted 0 wev 0 variant except may terms certain positions aik grows 0 function 0 terms like aik called growing terms wrt 0 following result immediate theorem 31 variant b wev b example 31 following lines 0 expanded variant variant except growing terms gt however following lines 0 expanded variant c c b uniable fx case px x variant py x example px fx expanded variant px x might doubtful would happen innite loop example example 32 let p logic program g top goal following innite loop clearly 0 subgoal i1 g i1 subgoal g second x growing fx i1 variant except i1 expanded variant following properties 3 example suggested anonymous referee theorem 32 let 0 wev 1 jaj ja 0 j 2 k jaikj ja 0 ikj 3 variants jaj 6 ja 0 j exists jaij ja 0 ij proof 1 2 immediate denition 31 2 growing term denition 31 0 variant proves 3 finally 4 immediate 2 2 properties useful computation expanded variants ja 0 j jaj conclude 0 expanded variant otherwise determine variants otherwise proceed arguments recursively nd growing terms check variants except growing terms relation variant dened denition 21 yields equivalent relation exive ie variant symmetric ie variant b implies b variant transitive ie variant b b variant c variant c however relation wev equivalent relation theorem 33 1 wev 2 wev b imply b wev 3 wev b b wev c imply wev c imply b wev c proof 1 straightforward theorem 31 2 counterexample pfx wev px px 6w ev pfx 3 immediate letting immediate letting although wev transitive sizes set expanded variants transitively decreas ing following result immediate theorem 32 corollary 34 wev b b wev c jaj jcj concept expanded variants provides basis designing loop checking mechanisms logic programs functions claim supported following theorem theorem 35 let innite sldderivation innitely large subgoals innitely many goals g j 1 proof since innite justication given bol 3 page 40 innite subderivation 0 form j 1 0 since logic program nite number clauses must set clauses program invoked innite number times 0 set dierent clauses used innite number times must innite subderivation 00 form j 1 00 logic program nite number predicatefunctionconstant symbols contains innitely large subgoals must innite sequence 00 j 1 j anc j1 j variant j1 except terms j1 whose size increases note innite increase term size 00 must result clauses cause terms grow functions form fi cycle applied means j variant j1 except terms grow j1 fi ie j1 wev j vafchecks based expanded variants dene series loop checking mechanisms logic programs functions section present four representative vafchecks prove completeness denition 41 let p logic program g 0 top goal 1 depth bound dene goals satisfy following conditions 1 j j anc j1 j1 wev j 2 j ja j ja theorem 41 1 v af 1 simple loop check 2 v af 1 complete wrt leftmost computation rule proof 1 straightforward denition 22 2 let innite sldderivation since p nite number clauses must set clauses p invoked innite 4 note 1 order clauses fc j 1 necessarily say fc may contain duplicated clauses say fc c1g number times derivation let set distinct clauses applied innite number times proof theorem 35 innite subderivation form j 1 fc distinguish two cases subgoal whose size innitely large logic program nite number predicate symbols function symbols constants must innitely many atoms variants let fb 1 rst variants theorem 31 1 j b j1 wev b j jb j1 conditions v af 1 satised leads derivation pruned node leftmost subgoal b d1 ii subgoal innitely large size theorem 35 must innitely many atoms expanded variants growing terms let fb 1 rst 1 j b j1 wev b j jb j1 j jb j j conditions v af 1 satised derivation pruned 2 complete 1 taking 1 leads following immediate corollary theorem 41 corollary 42 innite sldderivation innite subderivation form j satisfy two conditions v af 1 1 observe v af 1 identies innite loops based expanded variants selected subgoals reliable loop checks built taking account clauses selected generate expanded variants denition 42 let p logic program g 0 top goal 1 depth bound dene goals satisfy following conditions 1 j j anc j1 j1 wev j 2 j ja j ja 3 j clause selected resolve j g theorem 43 1 v af 2 simple loop check 2 v af 2 complete wrt leftmost computation rule proof 1 straightforward 2 corollary 42 innite sldderivation innite subderivation form 0 satisfy rst two conditions v af 2 since logic program nite number clauses must clause c k resolves innitely many 0 subderivation let rst 0 resolve c k third condition satised conclude proof 2 taking 1 leads following immediate corollary theorem 43 corollary 44 innite sldderivation innite subderivation form j satisfy two conditions v af 1 1 special case v af 1 sldderivation pruned v af 2 must pruned v af 1 converse true example consider sldderivation cut v af 1 2 v af 2 2 condition 3 satised leads following theorem 45 v af 2 reliable v af 1 considers repetition one clause innite sldderivation constrained loop checks developed considering repetition set clauses denition 43 let p logic program g 0 top goal 1 depth bound dene goals satisfy following conditions 1 j j anc j1 j1 wev j 2 j ja j ja 3 j clause selected resolve j 4 j set clauses used derive j1 j g theorem 46 1 v af 3 simple loop check 2 v af 3 complete wrt leftmost computation rule proof 1 straightforward 2 corollary 44 innite sldderivation innite subderivation form 0 satisfy rst two conditions v af 3 obviously third condition satised well since logic program nite number clauses must innite sequence 0 l 1 l j 0 subderivation set clauses used derive 0 l j1 0 l j let rst fourth condition v af 3 satised 2 taking 1 leads following immediate corollary theorem 46 corollary 47 innite sldderivation innite subderivation form j satisfy three conditions v af 2 1 j 1 g obviously sldderivation pruned v af 3 must pruned v af 2 converse true consider sldderivation cut v af 2 2 v af 3 2 condition 4 satised leads following theorem 48 v af 3 reliable v af 2 introducing another constrained loop check recall concept recursive clauses introduced 16 denition 44 16 set clauses fr called recursive clauses form similar forms 0 q x 1 r 1 uniable q x r mgu containing rm uniable q 0 x 0 r 0 mgu containing fx x 0 put another way fr set recursive clauses starting head r 0 replacing x 0 x applying successively leads inference chain form last atom q 0 f x uniable head r 0 mgu containing example 41 sets clauses fc 11 g p 1 fc 21 g p 2 fc p 3 fc 41 g p 4 recursive clauses recursive clauses cause subgoals increase size recursively ie cycle fr applied size q 0 increases constant fr repeatedly applied innite number times subgoal q 0 generated innitely large size note recursive clauses repeatedly applied since logic program nite number clauses exist recursive clauses program innite sldderivations innitely large subgoals subgoal increase size recursively means innite sldderivation innitely large subgoals generated repeatedly applying certain set recursive clauses leads following denition 45 let p logic program g 0 top goal 1 depth bound dene goals satisfy following conditions 1 j j anc j1 j1 wev j 2 j ja j ja 3 j clause selected resolve j 4 j set clauses used derive j1 j 5 j ja contains recursive clauses lead size increase g theorem 49 1 v af 4 simple loop check 2 v af 4 complete wrt leftmost computation rule proof 1 straightforward 2 corollary 47 innite sldderivation innite subderivation e form 0 satisfy rst four conditions v af 4 1 assume j e contains 0 innitely large size innitely increase term size e must generated repeated applications recursive clauses means must innite sequence 0 l 1 l j 0 e clauses used derive 0 l j1 0 l j contain recursive clauses lead size increase 0 l j l j1 let rst j satisfy conditions 1 obtain following corollary theorem 49 corollary 410 innite sldderivation innite subderivation form j 1 g size increase results application set recursive clauses fc k c n j g enhancement v af 3 sldderivation pruned v af 4 must pruned v af 3 converse true consider program consists clauses pfa sldderivation pa c1 pfa c2 2 cut v af 3 1 v af 4 1 recursive clauses program following result theorem 411 v af 4 reliable v af 3 example 42 let us choose depth bound 1 applying one four vaf checks four illustrating innite loops introduced earlier cut node l 1 l 2 l 4 pruned g 1 second node root pruned g 4 example 43 consider following listreversing program borrowed 3 top goal g z note c 53 recursive clause let us choose 1 successively applying clauses c 52 c 53 c 53 get following sldderivation easy check expanded variant continue expand g 3 rst apply c 51 g 3 generating successful node 2 apply c 52 g 3 generating node 3 anc 5 5 wev 3 ja 5 satised stop expanding g 5 apply c 53 g 3 generating node obviously 3 anc 6 6 wev 3 ja 6 j ja 3 j size increase 6 via recursive clause c 53 v af 1 4 1 satised stop expanding g 6 since v af 1 4 1 cut innite branches retaining shortest successful sldderivation weakly sound g observe condition vafchecks captures one characteristic innite loop obviously except 1 5 conditions 2 4 make sense 1 expanded variants capture key structural characteristic subgoals innite loops vafchecks weakly sound majority representative logic programs see examples however considering undecidable nature loop checking problem choosing 1 would safer 5 following example although quite articial illustrates point example 44 consider following logic program pfa c 62 following successful sldderivation top goal g 5 mentioned bol 3 question depth bound optimal remains open however experiments show v af22 weakly sound vast majority logic programs obviously pa anc pfa pfa wev pa c 61 recursive clause choose derivation pruned g 1 four vafchecks v af 1 4 1 weakly sound program apparently v af 1 4 2 weakly sound observe v af 1 v af 4 reliability increases computational overhead increases well therefore need consider tradeo choosing among vaf checks practical applications 1 suggest choosing vafchecks following basic reasons preference experience shows v af 2 2 weakly sound vast majority logic programs ii check condition 3 v af 2 takes little time whereas check recursive clauses condition 5 v af 4 rather costly 5 comparison oscheck evacheck oscheck evacheck v af 1 4 complete loop checks make comparison based two key factors reliability computational overhead 51 comparison oscheck begin recalling formal denition oscheck denition 51 3 14 let p logic program g 0 top goal 1 depth bound let size sizefunction atoms dene goals 1 j three versions oscheck depending sizefunction size dened 14 3 rst version atoms b condition 2 always hold thus ignored second version atom third version atoms b arity n jaij jbij obviously third version reliable rst two versions focus third version comparison oscheck complete 3 weak identies innite loops mainly based sizefunction regardless internal structure atoms therefore order increase reliability choose depth bound large possible example 14 however internal structure atoms functions may vary drastically dierent application programs using large depth bound together sizefunction loop checking criterion could general ineectiveinecient example applying osc10 size programs would generate lot redundant nodes following example illustrates fact example 51 consider following logic program top goal 100 c 7100 successful sldderivation follows z easy see oscd size weakly sound program unless choose 100 contrast approach common structural features repeated subgoals nite loops characterized expanded variants based expanded variants vafchecks weakly sound small depth bounds eg 2 majority logic programs instance v af 1 4 1 weakly sound p 7 example shows dramatical dierence discussion summarized following results theorem 51 let size sizefunction third version oscheck atoms b wev b implies sizeb sizea proof immediate theorem 32 2 theorem 52 1 4 v af reliable oscd size proof theorem 51 corollary 34 oscd size satised whenever condition 1 v af holds sldderivations pruned v af pruned oscd size well reverse true counterexample 100 sldderivation example 51 pruned oscd size v af 2 discuss computational overhead first note oscheck vaf checks ancestor checking j anc j1 required moreover ancestor subgoal j k oscd size compute although computation expanded variants little expensive sizefunction processes two strings ie atoms since string processing far faster ancestor checking needs scan goalstack assume two kinds string computations take constant time wrt scanning goalstack assumption complexity oscd size v af 1 2 note check conditions 2 3 vafchecks takes little time since check condition 4 vafchecks requires scanning goalstack v af 3 expensive oscd size furthermore condition 5 vafchecks ie computation recursive clauses quite expensive one hand given logic program need determine clauses recursive clauses hand two subgoals j j1 ja sldderivation need nd size increase j j1 results recursive clauses means v af 4 could much expensive oscd size discussion suggests v af 2 best choice balanced reliability overhead among oscd size v af 1 4 52 comparison evacheck begin reproducing denition evacheck denition 52 17 let p logic program g 0 top goal 1 depth bound dene goals 1 j 2 k generalized variant j g subgoal 0 said generalized variant subgoal variant except may arguments whose size increases via set recursive clauses following characterization generalized variants immediate denition denition 31 theorem 53 subgoals 0 sldderivation 0 generalized variant 0 wev ja 0 j jaj size increase via set recursive clauses ev ad relies heavily recursive clauses complexity similar v af 4 since computation recursive clauses expensive choose ev ad practical applications unless reliable v af however following example shows ev ad reliable four vafchecks example 52 consider following logic program top goal pfa c 83 successful sldderivation follows easily seen fc 81 c 82 g fc 82 g two sets recursive clauses let us choose 2 2 generalized variant 0 1 ev a2 cut derivation however sldderivation never cut v af 2 condition 2 vafchecks satised ie ja 6 conclusions developed four vafchecks logic programs functions based notion expanded variants observe key structural feature innite loops repetition selected subgoals clauses recursive increase term size repetition leads variants logic program nite number clauses predicatefunctionconstant recursive increase introduces growing terms notion expanded variants exactly catches structural characteristic certain subgoals innite loops due vafchecks much reliable oscheck less reliable evacheck even small depth bounds see examples 51 52 hand since structural information extracted directly individual subgoals without appealing recursive clauses vafchecks except v af 4 much ecient evacheck balancing reliability computational overhead choose v af 2 best one practical applications although v af 2 2 reliable vast majority logic programs due undecidability loop checking problem like complete loop checks v af 2 general cannot weakly sound xed way deal problem heuristically tuning depth bound practical applications methods carrying heuristic tuning present interesting open problem study acknowledgements thank anonymous referees constructive comments greatly improved presentation rst author supported part chinese national natural science foundation transcentury training programme foundation talents chinese ministry education r analysis loop checking mechanisms logic programs towards ecient loop checks loop checking partial deduction tabulated resolution wellfounded semantics tabled evaluation delaying general logic programs eliminating unwanted loops prolog note loops prolog termination logic programs neverending story redundancy elimination loop checks logic pro grams foundations logic programming partial evaluation logic programming eliminating loops prolog xsb programmers manual version 18 mixtus approach automatic partial evaluation full prolog mixtus automatic partial evaluator full prolog verifying local strati extended variant atoms loop check positive logic programs linear tabulated resolution well founded semantics abstract approach loop detection problems old resolution tabulation power logic memoing logic programs tr controlling recursive inference old resolution tabulation efficient loop detection prolog using tortoiseandhare technique foundations logic programming 2nd extended ed recursive query processing power logic analysis loop checking mechanisms logic programs partial evaluation logic programming mixtus approach automatic partial evaluation full prolog towards efficient loop checks memoing logic programs mixtus sound complete partial deduction unfolding based wellfounded measures redundancy elimination loop checks logic programs tabled evaluation delaying general logic programs extended variant atoms loop check positive logic programs abstract approach loop detection problems linear tabulated resolutions wellfounded semantics ctr yidong shen jiahuai liyan yuan samuel p shen qiang yang dynamic approach characterizing termination general logic programs acm transactions computational logic tocl v4 n4 p417430 october etienne payet fred mesnard nontermination inference logic programs acm transactions programming languages systems toplas v28 n2 p256289 march 2006 alexander serebrenik danny de schreye inference termination conditions numerical loops prolog theory practice logic programming v4 n56 p719751 september 2004
metaprogramming names necessity metaprogramming languages provide infrastructure generate execute object programs runtime typed setting contain modal type constructor classifies object code code types generally come two flavors closed open closed code expressions invoked runtime computations rigid typically produce less efficient residual object programs open code provides better inlining partial evaluation object programs constructed expressions type cannot general evaluatedrecent work area focused combining two notions sound system present novel way achieve based adding notion names work nominal logic freshml calculus proof terms necessity fragment modal logic s4 resulting language provides finegrained control free variables object programs compared existing languages metaprogramming addition approach lends well addition intensional code analysis ie ability meta programs inspect destruct object programs runtime typesafe manner also undertake b introduction metaprogramming broadly defined discipline algorithmic manipulation programs written certain object language program written another meta language operations object programs meta program may describe diverse may include among others gen eration inspection specialization course execution object programs runtime illustrate concept present following scenario refer sheard 2001 comprehensive treatment example rather using one general procedure solve many dierent instances problem program generate specialized hence ecient subroutines particular case language capable executing thus generated procedures program choose dynamically depending runtime value certain variable expression one suitable invoke idea behind work runtime code generation lee leone 1996 wickline et al 1998b wickline et al 1998a functional programming concept staged computation ershov 1977 gluck jrgensen 1995 davies pfenning 2001 nanevski f pfenning languages object programs composed executed also structure inspected add advantages particular e ciency may benefit various optimizations performed knowing structure code example griewank 1989 reports way reuse common subexpressions numerical function order compute value certain point value ndimensional gradient way complexity evaluations performed together grow n applications well seem call capability execute certain function also inspect structure see rozas 1993 examples computer graphics numerical analysis ramsey pfeer 2002 example machine learning probabilistic modeling paper concerned typed functional languages metapro even precisely limit considerations homogeneous metaprogramming especially simple case object meta language recent developments direction centered around two particular modal lambda calculi calculus proofterm language modal logic s4 whose necessity constructor annotates valid propositions davies pfenning 2001 pfenning davies 2001 type used runtime code generation classify generators code type wickline et al 1998b wickline et al 1998a calculus proofterm language discrete lineartime temporal logic type classifies terms associated subsequent time moment intended application partial evaluation typing annotation program seen bindingtime specification davies 1996 calculi provide distinction levels stages terms explains use meta programming lowest level meta language used manipulate terms next level terms type meta language subsequent level containing another stratum boxed circled types etc purposes metaprogramming type also associated closed code classifies closed object terms type hand type type postponed code classifies object terms type associated subsequent time moment operational semantics allows reduction objectlevel binders postponed code frequently conflated notion open code dichotomy closed open code inspired recent type systems metaprogramming abstract concept open code necessarily general closed code specific programming environment already observed davies 1996 working open code flexible results better optimized residual object programs however also want run generated object programs closed thus need type system integrates modal types closed open code several proposed type systems providing expressiveness notable metaml moggi et al 1999 taha 1999 calcagno et al 2000 calcagno et al 2001 metaml defines notion open code names necessity 3 postponed code introduces closed code refinement open code happens contain free variables approach calculus call opposite rather refining notion postponed code relax notion closed code start system provide additional expressiveness allowing code contain specified object variables free rudiments idea already considered nielsen 2001 given code expression depends set free variables reflected type object variables represented separate semantic category names also called symbols atoms admits equality treatment names inspired work nominal logic freshml gabbay pitts 2002 pitts gabbay 2000 pitts 2001 gabbay 2000 design choice leads logically motivated easily extendable type system example describe nanevski 2002 extension intensional code analysis allows object expressions compared structural equality destructed via patternmatching much way one would work abstract syntax tree paper organized follows section 2 brief exposition prior work type system properties described section 3 section 4 describes parametric polymorphism sets names illustrate type system example programs discussing related work section 5 modal calculus section reviews previous work modal calculus use metaprogramming separate mechanism types realms metalevel programs objectlevel programs calculus proofterm calculus necessitation fragment modal logic s4 pfenning davies 2001 davies pfenning 2001 chronologically came considered functional programming context specialization purposes runtime code generation wickline et al 1998b wickline et al 1998a example consider exponentiation function presented mllike notation function exp1 int int int written curried form applied part input known example actual parameter n available exp1n returns function computing nth power argument practical implementation scenario however outcome partial instantiation closure waiting receive actual parameter x proceeds evaluation thus one argue following reformulation exp1 preferable 4 nanevski f pfenning else let val xint x ux indeed n provided x expression exp2n performs computation steps based value n produce residual function specialized computing nth power argument particular obtained residual function perform operations take decisions runtime based value n fact even depend n computation steps dependent n taken specialization useful intuition understanding programming idiom ex ample view exp2 program generator supplied n generates specialized function computing nth powers immediately suggests distinction calculus two stages levels meta object stage object stage expression encodes terms viewed data results process code generation exp2 function terms would xint1 xint x ux meta stage describes specific operations performed expressions object stage aboveillustrated programming style referred staged computation idea behind type system make explicit distinction meta object stages allows programmer specify intended staging term annotating objectlevel subterms program type system check whether written code conforms staging specifications making staging errors type errors syntax presented use b stand predetermined set base types c constants types types b 1 2 erms e c x u xa e e 1 e 2 alue variable contexts xa expression variable contexts ua alues v c xa e box e several distinctive features calculus arising desire dierentiate stages important new type constructor usually referred modal necessity logic side necessitation modifier propositions pfenning davies 2001 metaprogramming application used classify objectlevel terms introduction elimination forms term constructors box let box respectively figure 1 shows e object term type box e would meta term type box term constructor wraps object term e accessed manipulated meta part program elimination form let box names necessity 5 opposite takes object term enclosed e 1 binds variable u used e 2 type system distinguishes two kinds variables consequently two variable contexts variables bound meta terms variables bound object terms implicitly assume exchange holds order variables contexts immaterial figure 2 presents smallstep operational semantics decided callbyvalue strategy addition prohibits reductions object level thus expression boxed evaluation suspended boxed expressions considered values choice means canonical necessary applications paper use type system make explicit staging exp2 else let box box xint x ux application exp3 argument 2 produces objectlevel function squaring val xint x yint zint elimination form let box bound variable u belongs context objectlevel variables used e 2 object positions ie box meta positions way calculus capable composing object programs also explicitly force evaluation example use generated function sqbox following way val val example demonstrates object expressions reflected coerced objectlevel metalevel opposite coercion referred reification however possible suggests given specific model reflection naturally exists reification possible interpretation exhibiting behavior considers object terms actual syntactic expressions abstract syntax trees source programs calculus meta terms compiled executables typed scenario object terms represent syntax higherorder syntax pfenning elliott 1988 well operation reflection corresponds 6 nanevski f pfenning fig 1 typing rules xa let box let box fig 2 operational semantics natural process compiling source code executable opposite operation reconstructing source code compiled equivalent usually feasible interpretation support reification required modal calculus names 31 motivation syntax overview adhere interpretation object terms higherorder syntax staging exp3 rather unsatisfactory problem residual object programs produced exp3 eg sqbox contain unnecessary variablefor variable redexes hence optimal one would want may serious criticism perspective runtime code generation indeed variableforvariable redexes easily eliminated compiler object terms viewed higherorder syntax argued previous section natural model calculus limitation severe exhibits restrictive allow arbitrary composition higherorder syntax trees reason deficiency requirement boxed object terms must always closed sense type type closed syntactic expressions type observed typing rules figure 1 introduction rule erases meta variables typechecking argument term allows object level variables runtime always substituted closed object expressions produce closed object expression end names necessity 7 unfortunately type closed syntactic expressions disposal cant ever type body objectlevel abstraction isolation binder subterms closed term necessarily closed thus would impossible ever inspect destruct recurse objectlevel expressions binding structure solution extend notion object level include closed syntactic expressions also expressions free variables need long recognized metaprogramming community section 5 discusses several dierent metaprogramming systems solutions problem technique predominantly used solutions goes back davies calculus davies 1996 type constructor calculus corresponds discrete temporal logic modality propositions true subsequent time mo ment metaprogramming setup modal type stands open object expression type free variables object expression modeled metavariables subsequent time moment bound somewhere outside expression calculus adopts dierent approach seems purposes higherorder syntax one cannot equate bound metavariables free variables object expressions imagine recursing two syntax trees binding structure compare syntactic equality modulo conversion whenever abstraction encountered expressions need introduce new entity stand bound variable abstraction recursively proceed comparing bodies abstractions introducing new entity standing bound variable must change type surrounding term words free variables object expressions cannot introduced computation type introduction form like abstraction case languages based thus start calculus introduce separate semantic category names motivated pitts gabbay 2000 gabbay pitts 2002 also odersky 1994 object meta stages separated modality object terms use names encode abstract syntax trees variables names appearing object term apparent type addition type system must instrumented keep track occurrences names names prevented slipping scope introduction form informally term depends certain name name appears metalevel part term set names term depends called support term situation analogous polynomial algebra one given base structure set indeterminates generators freely adjoins structure polynomials setup indeterminates names build polynomials base structure expressions example assuming moment x names type int usual operations addition multiplication exponentiation integers 8 nanevski f pfenning primitive term would type int support set x names x appear e 1 meta level indeed notice order evaluate e 1 integer first need provide definitions x hand box term e 1 obtain type xy int support empty set names x appear object level ie box thus support term case e 1 becomes part type term boxed way types maintain information support subterms stages example assuming language pairs term would type int int support x also interested compiling evaluating syntactic entities empty support ie closed thus need mechanism eliminate name given expressions support eventually turning nonexecutable expressions executable ones purpose use explicit substitutions explicit substitution provides definitions names appear metalevel certain expression note emphasis metalevel explicit substitutions substitute boxes names appearing object level term contribute terms support way explicit substitutions provide extensions ie definitions names still allowing names boxes used intensional information identity utilize related development described nanevski 2002 next present syntax calculus discuss constructors names x n types b 1 2 1 2 ca substitutions x e erms e c x x u xa e e 1 e 2 x e choose e alue variable contexts xa expression variable contexts uac name contexts x calculus makes distinction meta object levels interpreted level compiled code level source code abstract syntax expressions respectively two levels separated modal type constructor except whole family modal type names necessity 9 constructors one finite set names c sense values type ca abstract syntax trees calculus freely generated set names c refer finite set c support set syntax trees names drawn countably infinite universe names n distinction levels forces split variable contexts context metalevel variables also call value variables context objectlevel variables also call syntactic expression variables expression variables context must keep track typing given variable also support set set terms includes syntax calculus section 2 ever two important distinctions first explicitly refer names level terms second required references expression variables certain term makes always prefixed explicit substitution example u expression variable bound let box u appear e 2 prefixed explicit substitution dierent occurrences u dierent substitutions associated explicit substitution supposed provide definitions names expression bound u reference variable u prefixed empty substitution instead u simply write u explicit substitutions used calculus simultaneous substitutions assume syntactic presentation substitution never defines denotation name twice example 1 assuming x names type int code segment creates polynomial x evaluates point 2 val terms xa e choose e introduction elimination form type constructor b term x e binds name x type subsequently used e term choose picks fresh name type substitutes name bound argument abstraction type b proceeds evaluate body abstraction prevent bound name x e escaping scope definition thus creating observable eect type system must enforce discipline use x e occurrence x certain position e allowed type system establish occurrence x encountered evaluation possibilities arise two ways x eventually substituted away explicit substitution nanevski f pfenning x appears computationally irrelevant ie deadcode part term needless say deciding questions practical language impossible type system provides conservative approximation using fairly simple analysis based propagation names encountered typechecking finally enlarging appropriate context new variable name subject usual variable conventions new variables names assumed distinct renamed order clash already existing ones terms dier syntactic representation bound variables names considered equal binding forms language xa e let box x e usual captureavoiding substitution e 1 xe 2 expression e 1 variable x expression e 2 defined rename bound variables names descending scope given term e denote fve fne set free variables e set names appearing e metalevel addition overload function fn given type support set c fnac set names appearing c example 2 illustrate new constructors present version staged exponentiation function write calculus examples resort concrete syntax ml fashion assume presence base type integers recursive functions letdefinitions choose x int let fun exp else let box let box box xint x x v end val function exp takes integer n generates fresh name x integer type calls helper function exp build expression z type int support x finally turns expression v function explicitly substituting name x v newly introduced bound variable x names necessity 11 notice generated residual code sq contain unnecessary redexes contrast version program section 2 32 explicit substitutions section formally introduce concept explicit substitution names define related operations already outlined substitutions serve provide definitions names thus eectively removing substituting names support term appear term empty support compiled evaluated domain range explicit substitution function set names set terms given substitution domain dom set names substitution fix words range substitution image dom purposes work consider substitutions finite domains substitution finite domain finitary syntactical representation set ordered pairs x e relating name x dom substituting expression e opposite also holds finite functional set ordered pairs names expressions determines unique substitution frequently equate substitution set represents result ambiguities customary denote fv set free variables terms range set names appearing either dom range denoted fn substitution uniquely extended function arbitrary terms following way given substitution term e operation e applying meta level e defined recursively structure e given substitution nanevski f pfenning application captureavoiding xa let box choose choose e important aspect definition substitution application recursively descend box property utmost importance soundness calculus preserves distinction meta object levels also justified explicit substitutions intended remove names support term names appearing box contribute support operation substitution application depends upon operation substitution composition define next definition 3 composition substitutions given two substitutions 1 2 finite domains composition 1 2 substitution defined composition two substitutions finite domains welldefined resulting mapping names terms finite indeed every name x finite syntactic representation composition easily computed set occasionally beneficial represent set disjoint union two smaller sets 1 defined important notice though definitions substitution application substitution composition mutually recursive operations ter minating substitution application defined inductively structure argument size terms operates always decreasing composing substitutions finite domain also terminates 1 2 requires applying 1 defining terms 2 names necessity 13 33 type system type system calculus consists two mutually recursive judgments hypothetical work three contexts context names context expression variables context value variables syntactic structure three contexts given section 31 first judgment typing judgment expressions given expression e checks whether e type generated support set c second judgment types explicit substitutions given substitution two support sets c substitution type c maps expressions support c expressions support intuition proved section 34 contexts deserve words types calculus depend names types names depend names well must impose conditions wellformedness contexts henceforth variable contexts wellformed relative declares names appear types name context wellformed every type uses names declared left often abuse notation define set obtained removing name x context obviously wellformed context types may depend x always transform wellformed context using thus always take care also implicitly assume contexts judgments wellformed holds types support sets use rules typing rules presented figure 3 pervasive characteristic type system support weakening namely term set expressions type freely generated support set c certainly among expressions freely generated support set c make property admissible judgments type system proved lemma section 34 explicit substitutions substitution empty syntactic representation identity substitution identity substitution applied term containing names c resulting term obviously contains names c support resulting term extended support weakening superset discussed bake property side condition c identity substitution rule implicitly require sets wellformed contain names already declared name context rule nonempty substitutions recursively checks component terms well typed given contexts support worth noticing however substitution given type c domain support set c completely unrelated set dom words sub 14 nanevski f pfenning explicit substitutions hypothesis calculus modality names fig 3 typing rules calculus stitution provide definitions names fewer names typing judgment actually expresses example substitution domain dom x given among others typings well x z z indeed map term another term support term support x term support term support x z term support z hypothesis rules three kinds variable contexts three hypothesis rules first rule names name x used provided declared accounted supplied support set implicit assumption support set c wellformed c dom rule value variables straightforward typing xa inferred xa declared actual support term support set c long wellformed implicitly assumed expression variables occur term always prefixed explicit substitution rule expression variables check expression variable declared context corresponding substitution appropriate type names necessity 15 calculus fragment rule abstraction quite standard implicit assumption argument type wellformed name context introduced variable context application rule checks function application argument support set modal fragment calculus meaning rule introduction ensure boxed expression e represents abstract syntax tree checks e given type context without value variables support e match supplied index constructor hand support whole expression box e empty expression obviously contain names meta level thus support arbitrarily weakened wellformed support set elimination rule also straightforward extension corresponding rule dierence bound expression variable u context stored support annotation names fragment introduction form names x e corresponding type b introduces irrelevant name x computation determined e assumed type wellformed relative context term constructor choose elimination form b picks fresh name substitutes bound name abstraction words operational semantics redex choose x e formalized section proceeds evaluation e runtime context fresh name picked x justified x bound convention renamed fresh name irrelevancy x example means x never encountered evaluation e computationally significant position thus 1 necessary specify runtime behavior 2 never escape scope introducing observable way sidecondition introduction serves exactly enforce irrelevancy eectively limits x appear deadcode subterms e subterms eventually removed explicit substitution example consider following term xint yint box let box end contains substituted occurrence x deadcode occurrence therefore welltyped type int int int one may wonder use entities like names supposed appear computationally insignificant positions computation fact however names insignificant import lies identity example related development intensional analysis syntax nanevski 2002 compare names equality something cannot done nanevski f pfenning ordinary variables ordinary variables placeholders val ues cannot compare variables equality values variables stand sense say abstraction parametric abstraction deliberately designed names appear irrelevant force certain discipline upon usage particular leaving local scope name x determined introducing close resulting expression depends significantly x closure achieved turning expression abstraction means explicit substitutions otherwise introduction new name observable eect paraphrase leaving scope x turn polynomials depending x functions illustration technique program already presented example 2 previous version work nanevski 2002 use constructors choose rather combined single constructor new also case pitts gabbay 2000 decomposition given equation new x choose x e decided reformulation order make types language follow closely intended meaning terms thus provide stronger logical foundation calculus 34 structural properties section explores basic theoretical properties type system lemmas developed used justify operational semantics ascribe calculus section 35 ultimately lead proof type preservation theorem 12 progress theorem 13 lemma 4 structural properties contexts 1 weakening let 2 contraction variables xa b xa c uad vad uad proof straightforward induction structure typing derivations names necessity 17 contraction names hold indeed identifying two dierent names term may make term syntactically illformed typical examples explicit substitutions oneone correspondence syntactic representations identifying two names may make syntactic representation assign two dierent images name would break correspondence substitutions next series lemmas establishes admissibility support weakening discussed section 33 lemma 5 support weakening support weakening covariant righthand side contravariant lefthand side judgments formally let c c dom dom wellformed support sets following holds 1 2 3 uad 4 proof first two statements proved straightforward simultaneous induction given derivations third fourth part proved induction structure respective derivations lemma 6 support extension let dom wellformed support set following holds 1 uac 1 2 proof induction structure derivations lemma 7 substitution merge dom proof induction structure following lemma shows intuition behind typing judgment explicit substitutions explained section 33 indeed valid lemma 8 explicit substitution principle following holds 1 2 proof nanevski f pfenning simultaneous induction structure derivations present proof second statement given substitutions split representation two disjoint sets set show two typings imply result substitution merge lemma lemma 7 establish observe typing clear 1 dom definition dom fixed thus either x appear syntactic representation syntactic representation contains sequence mappings second case x substituting term xn thus first case x c inductively appealing typing rules substitutions empty substitution reached either way c 1 dom c furthermore c 1 dom c dom result follows support weakening lemma 54 establish b observe x dom x c first induction hypothesis x typing b obtained inductively applying typing rules substitutions x c 1 dom following lemma establishes hypothetical nature two typing judgment respect ordinary value variables lemma 9 value substitution principle c following holds 1 xa e 2 proof simultaneous induction two derivations situation simple expression variables simple substitution expression expression variable result syntactically wellformed term reason discussed occurrences expression variables always prefixed explicit substitution form kind closure explicit substitutions calculus occur part closures cannot freely applied arbitrary terms 1 hence substitution expression e expression variable u produce syntactically valid term need follow 1 albeit extension seem particularly hard omit simplicity names necessity 19 applications e explicit name substitutions paired u operation also gives us control extensional also intensional form boxed expressions definition generalizes captureavoiding substitution expression variables order handle problem substitution expression variables captureavoiding substitution e expression variable u defined recursively follows choose e note first clause u definition resulting expression obtained carrying explicit substitution lemma 11 expression substitution principle let e 1 expression without free value variables e following holds 1 uac e 2 proof simultaneous induction two derivations present one case proof first statement case 1 derivation 2 second induction hypothesis e 3 explicit substitution lemma 81 e 1 4 exactly equal 35 operational semantics define smallstep callbyvalue operational semantics calculus judgment e e nanevski f pfenning e1 e2 e2 e 2 v1 e2 xa e v vxe let box let box e e choose e choose e choose xa e xa e fig 4 structured operational semantics calculus relates expression e onestep reduct e relation defined expressions free variables expression contain free names must empty support words consider evaluation terms whose names appear exclusively object level computationally irrelevant positions removed explicit substitution free names allowed operational semantics account keeping track runtime name contexts rules judgment given figure 4 values language generated grammar alues v c xa e box e x e rules standard important observation redex type constructor extends runtime context fresh name proceeding extension needed soundness purposes freshly introduced name may appear computationally insignificant positions reduct must keep name typing runtime context evaluation relation sound respect typing never gets stuck following theorems establish theorem 12 type preservation extends e proof straightforward induction structure e using substitution principles theorem 13 progress 1 e value 2 exist term e context e e proof names necessity 21 straightforward induction structure e progress theorem indicate reduct e context unique given e fact fresh names may introduced course computation two dierent evaluations one term may choose fresh names dierently determinacy theorem shows choice fresh names accounts dierences two reductions term customary denote n nstep reduction relation theorem 14 determinacy e exists permutation names fixing dom proof induction length reductions using property e n e permutation names e n e interesting case choose x e case must fresh obviously involution two names required properties frequently necessary write programs polymorphic support syntactic objectlevel arguments intended manipulate abstract syntax trees whose support known compile time typical example would function recurses syntax tree binding structure encounters abstraction place fresh name instead bound variable recursively continue scanning body abstraction syntactic expression depending newly introduced name 2 uses extend calculus notion explicit support polymorphism style girard reynolds girard 1986 reynolds 1983 addition support polymorphism simple calculus starts syntactic changes summarize support variables p q sets c pn types p erms e p e e c name context p alues v p e 2 calculus described cannot support scenario full generality yet lacks type polymorphism typepolymorphic recursion support polymorphism necessary step direction 22 nanevski f pfenning introduce new syntactic category support variables intended stand unknown support sets addition support sets allowed contain support variables express situation portion support set unknown consequently function fn must updated return set names support variables appearing argument language types extended type p expressing universal support quantification introduction form p e abstracts unknown support set p expression e abstraction also value extended operational semantics corresponding elimination form application e c whose meaning instantiate unknown support set abstracted e provided support set c types depend names well support variables name contexts must declare assume convention wellformedness name context typing judgment instrumented new rules typing support polymorphic abstraction application introduction rule requires bound variable p escape scope constructors bind particular must p c convention also assumes implicitly p added rule elimination substitutes argument support set type assumes wellformed relative context dom operational semantics new constructs also surprising e e extended language satisfies following substitution principle lemma 15 support substitution principle operation substituting p following holds 1 2 proof simultaneous induction two derivations present one case proof second statement case 1 derivation 2 first induction hypothesis 3 second induction hypothesis 4 c 1 x c 1 x support weakening lemma 54 names necessity 23 5 result follows 2 4 typing rule nonempty substitution structural properties presented section 34 readily extend new language support polymorphism true type preservation theorem 12 progress theorem 13 whose additional cases involving support abstraction application handled using lemma 15 example 3 supportpolymorphic calculus slightly generalize program example 2 pulling helper function exp parametrizing exponentiating expression following program use p function definition concrete syntax abstraction support variable p else let box choose x int let box box xint x x w end val example 4 example realistic program present regular expression matcher davies pfenning 2001 davies 1996 example assumes declaration datatype regular expressions datatype empty plus regexp regexp times regexp regexp star regexp const char nanevski f pfenning val acc1 regexp char list bool char list bool acc1 plus e1 acc1 times e1 acc1 e1 acc1 e2 k acc1 star e k else acc1 star e k acc1 const c k case nil false xl val accept1 regexp char list bool fig 5 unstaged regular expression matcher also assume primitive predicate null char list bool testing input string empty figure 5 presents ordinary ml implementation matcher versions found davies pfenning 2001 davies 1996 would like use calculus stage program figure 5 specialized respect given regular expression purpose useful view helper function acc called acc1 figure 5 code generator takes regular expression e emits code parsing according e end appends k generated code main idea behind program figure 6 simplicity use name input string parsed code acc generates also want allow continuation code k contain names standing yet unbound variables hence supportpolymorphic typing acc regexp p sp bool sp bool support polymorphism pays generating code alternation pluse 1 e 2 iteration stare indeed observe alternation case generated code duplicate continuation k rather k emitted separate function joining point computation branches corresponding e 1 e 2 similarly case iteration set loop output code would attempt zero matchings e support polymorphism acc enables us produce code chunks without knowing exact identity abovementioned joining looping points parts output code generated stitch together means explicit substitutions names necessity 25 val accept regexp char list bool choose list sp bool let fun acc empty p acc plus e1 e2 p choose list bool let box acc e1 join boxjoin acc e2 join boxjoin boxlet fun join orelse end acc times e1 e2 p acc e1 acc e2 acc star e p choose list choose list bool let box acc e loop else loop boxlet fun loop orelse loop end acc const c p let box boxcase xxs nil false box schar list sscode fig 6 regular expression matcher staged calculus point may illustrative trace execution program concrete input figure 7 presents function calls intermediate results occur staged matcher applied regular expression starempty note resulting specialized program contain variable forvariable redexes perform unnecessary boolean tests possible improve matching algorithm avoid emitting extraneous code improvement involves examination preprocessing input regular expression thorough description beyond scope paper refer harper 1999 insightful analysis 5 related work work presented paper lies intersection several related ar eas staged computation partial evaluation runtime code generation meta programming modal logic higherorder abstract syntax early reference staged computation ershov 1977 introduces 26 nanevski f pfenning else loop null orelse loop end box let fun loop null orelse loop end fig 7 example execution trace regular expression matcher function calls marked corresponding return results marked aligned staged computation name generating extensions generating extensions purposes partial evaluation also foreseen futamura 1971 concept later explored eventually expanded multilevel generating extensions jones et al 1985 gluck jrgensen 1995 gluck jrgensen 1997 work done untyped setting typed calculus provided direct motivation foundation system calculus evolved type theoretic explanation staged computation davies pfenning 2001 wickline et al 1998a runtime codegeneration lee leone 1996 wickline et al 1998b described section 2 another important typed calculus metaprogramming formulated davies 1996 proofterm calculus discrete temporal logic provides notion open object expression free variables object expression represented meta variables subsequent temporal level original motivation develop type system bindingtime analysis setup partial evaluation quickly adopted metaprogramming development metaml moggi et al 1999 taha 1999 taha 2000 metaml adopts open code type constructor generalizes language several features important one addition type refinement closed code values classified closed code types open code expressions happen depend free meta variables might interest point certain relationship concept names phenomenon occurs extension metaml references calcagno et al 2000 calcagno et al 2001 reference metaml names necessity 27 must assigned open code expression indeed case eventual free variable expression may escape scope binder introduced technical reasons however actually cannot prohibited authors resort hygienic handling scope extrusion annotating term list free variables allowed contain deadcode positions deadcode annotations type constructor metaml deadcode variables belong syntactic category ordinary variables nevertheless much compare names abstraction another interesting calculus metaprogramming nielsens described nielsen 2001 based idea calculus instead defining notion closed code refinement open code metaml relaxes notion closed code use names stand free variables object expression uses variables introduced box thus becomes binding construct variables bound box treatment bound variables typeconstructor updated reflect types names variables corresponding box binds property makes unclear extended concept corresponding support polymorphism nielsen taha present another system combining closed open code nielsen taha 2003 based explicitly name object stages computation notion environment classifiers stages explicitly named stage revisited multiple times variables declared previous visits reused feature provides functionality open code environment classifiers related support variables several respects bound universal quantifiers abstract sets indeed support polymorphism explicitly abstracts sets names environment classifiers used name parts variable context thus implicitly abstract sets variables coming direction higherorder abstract syntax probably first work pointing importance nonparametric binder like abstraction miller 1990 connection higherorder abstract syntax modal logic recognized despeyroux pfenning schurmann system presented despeyroux et al 1997 later simplified twolevel system schurmanns dissertation schurmann 2000 also hofmann discusses various presheaf models higherorder abstract syntax fiore et al 1999 explores untyped abstract syntax categorical setup extension arbitrary types fiore 2002 however work explicitly motivated developments series papers nominal logic freshml gabbay pitts 2002 pitts gabbay 2000 pitts 2001 gabbay 2000 names nominal logic introduced urelements fraenkelmostowsky set theory freshml language manipulation object syntax binding structure based model primitive notion swapping two names used define operations name abstraction producing equivalence class respect abstracted name name concretion providing specific representative equivalence class earlier version paper nanevski 2002 contained 28 nanevski f pfenning two operations almost orthogonal add name abstraction used encode abstract syntax trees depend name whose identity known unlike calculus freshml keep track support term rather complement freshml introduces names computation construct new x e roughly interpreted calculus new x choose x e except deadcode position name x appear e scope abstraction hides x one main dierences freshml names freshml runtime values possible freshml evaluate term nonempty support hand names arbitrary types freshml names must single type atm though generalized arbitrary family types disjoint types values language calculus allows general typing names thanks modal distinction meta object levels example without modality names arbitrary types function defined integers always perform runtime checks test argument valid integer case function applied argument name case evaluation suspended whole expression becomes syntactic entity added bonus support explicit name substitution primitive substitution must userdefined freshml logic side direct motivation paper comes pfenning davies 2001 presents natural deduction formulation propositional s4 general interaction modalities syntax names interest logicians quite time example logics encode syntax topic godels incompleteness theorems references direction montague 1963 smorynski 1985 viewpoints attardi contexts mccarthy 1993 similar notion support used express relativized truth finally names resemble nonrigid designators fitting mendelsohn 1999 names kripke 1980 virtual individuals scott 1970 also touch issues existence identity explored scott 1979 classical work seems indicate metaprogramming higherorder syntax concrete instance much broader abstract phenomenon hope draw cited work future developments 6 conclusions future work paper presents calculus typed functional language meta programming employing novel way define modal type syntactic object programs free variables system combines calculus pfenning davies 2001 notion names inspired developments freshml nominal logic pitts gabbay 2000 gabbay pitts 2002 pitts 2001 gabbay 2000 motivation combining names comes longrecognized names necessity 29 need metaprogramming handle object programs free variables davies 1996 taha 1999 moggi et al 1999 setup calculus provides way encode closed syntactic code expressions names serve stand eventual free variables taken together provide way encode open syntactic program expressions also compose evaluate inspect destruct names operationally thought locations tracked type system names cannot escape scope introduction form set names appearing meta level term called support term support term reflected typing term term evaluated support empty also considered constructs support polymorphism calculus reformulation calculus presented nanevski 2002 adopted changes involve simplification operational semantics constructs handling names furthermore decomposed name introduction form new two constructors choose introduction elimination form new type constructor b design choice gives stronger logical foundation calculus level types follows much closely behavior terms language hope investigate logical properties immediate future work direction would include embedding discretetime temporal logic monotone discrete temporal logic logic types also considering proofirrelevancy modality pfenning 2001 awodey bauer 2001 classify terms unknown support another important direction exploration concerns implementation calculus presented paper developed particular semantical interpretation mind object level expressions abstract syntax trees representing templates source programs need interpretation quite possible boxed expressions calculus support polymorphism stored runtime intermediate even compiled form might benefit eciency programs remains important future work explore implementation issues acknowledgment would like thank dana scott bob harper peter lee andrew pitts helpful comments earlier versions paper robert gluck pointing missing references r formalization viewpoints propositions closed types simple approach safe imperative multistage programming closed types safe imperative metaml temporal logic approach bindingtime analysis modal analysis staged computation journal acm primitive recursion higherorder abstract syntax partial computation principle semantic analysis normalization evaluation typed lambda calculus abstract syntax variable binding partial evaluation computation process approach compilercompiler new approach abstract syntax variable binding system f variable types automatic program generator multilevel specialization automatic di semantical analysis higherorder abstract syntax experiment partial evaluation generation compiler generator naming necessity optimizing ml runtime code generation pages 137148 conference programming language design implementation extension ml handle bound variables data structures pages 323335 proceedingsproceedings first esprit bra workshop logical frameworks syntactical treatment modalities combining closed open code functional theory local names judgmental reconstruction modal logic mathematical structures computer science nominal logic first order theory names binding pages 219242 kobayashi metalanguage programming bound names modulo renaming translucent procedures advice modal logic existence intuitionistic logic accomplishments research challenges metaprogramming pages 244 sound reduction semantics untyped cbn multistage compu tation tr functional theory local names modal analysis staged computation runtime code generation modalml modal types staging specifications runtime code generation firstorder modal logic sound reduction semantics untyped cbn mutlistage computation theory metaml nontrival extended abstract stochastic lambda calculus monads probability distributions accomplishments research challenges metaprogramming nominal logic primitive recursion higherorder abstract syntax metalanguage programming bound names modulo renaming idealized metaml temporallogic approach bindingtime analysis translucent procedures abstraction without opacity multistage programming ctr marcos viera alberto pardo multistage language intensional analysis proceedings 5th international conference generative programming component engineering october 2226 2006 portland oregon usa chiyan chen hongwei xi implementing typeful program transformations acm sigplan notices v38 n10 p2028 october kevin donnelly hongwei xi combining higherorder abstract syntax firstorder abstract syntax ats proceedings 3rd acm sigplan workshop mechanized reasoning languages variable binding p5863 september 3030 2005 tallinn estonia iksoon kim kwangkeun yi cristiano calcagno polymorphic modal type system lisplike multistaged languages acm sigplan notices v41 n1 p257268 january 2006 geoffrey washburn stephanie weirich boxes go bananas encoding higherorder abstract syntax parametric polymorphism acm sigplan notices v38 n9 p249262 september chiyan chen rui shi hongwei xi implementing typeful program transformations fundamenta informaticae v69 n12 p103121 january 2006 yosihiro yuse atsushi igarashi modal type system multilevel generating extensions persistent code proceedings 8th acm sigplan symposium principles practice declarative programming july 1012 2006 venice italy mark r shinwell andrew pitts murdoch j gabbay freshml programming binders made simple acm sigplan notices v38 n9 p263274 september chiyan chen hongwei xi metaprogramming typeful code representation acm sigplan notices v38 n9 p275286 september derek dreyer type system wellfounded recursion acm sigplan notices v39 n1 p293305 january 2004 chiyan chen hongwei xi metaprogramming typeful code representation journal functional programming v15 n6 p797835 november 2005 aleksandar nanevski frank pfenning staged computation names necessity journal functional programming v15 n6 p893939 november 2005 walid taha michael florentin nielsen environment classifiers acm sigplan notices v38 n1 p2637 january
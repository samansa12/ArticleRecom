adaptive programming adaptive program one changes behavior base current state environment notion adaptivity formalized logic reasoning adaptive programs presented logic includes several composition operators used define adaptive program terms given constituent programs programs resulting compositions retain adaptive properties constituent programs authors begin discussing adaptive sequential programs extend discussion adaptive distributed programs relationship adaptivity selfstabilization discussed case study constructing adaptive distributed program token circulated ring processes presented b introduction adaptive program one changes behavior according environment often motivation changing program behavior satisfy performance criteria performance one behavior superior behaviors environment case adaptivity technique performance optimization dynamic environment another reason changing program behavior logical correctness one behavior correct certain environment case adaptivity matter program functioning properly changing environment paper investigation particular class adaptive programs following examples motivate investigation ffl consider system distributed processes communicate via shared bus instance processes use either one two protocols control access bus ethernetlike protocol 11 tokenring protocol 9 ethernetlike protocol performs well periods low contention small number processes need use bus performs poorly periods high con tention hand tokenring protocol works well periods high contention less efficient ethernetlike protocol periods low contention system dynamically switch ethernetlike protocol tokenring protocol based activity bus ideally switch one protocol another occur instantaneously processes however system distributed may short period processes switched protocols processes ffl resource allocation program required minimize amortized cost resource allocation two strategies employed resource allocation pessimistic strategy optimistic one comparing amortized cost two strategies happens pessimistic strategy lower cost worstcase resource requests significant proportion resource requests otherwise optimistic strategy lower cost program monitors resource requests time time switches one strategy another appropriate ffl distributed system traffic control traffic routes changed optimize traffic flow given traffic patterns depend time day time measured local clocks may drift apart system executes adaptive program optimally controls traffic spite discrepancies local clocks instance transition morning afternoon may instantaneous eventually clocks agree afternoon system route traffic optimize afternoon patterns three examples illustrate main characteristics class adaptive programs interested 1 changes environment necessarily occur instantly may occur gradually short period time traffic control example clocks may indicate change environment others may continues seconds due drift clocks clocks indicate change environment 2 periods change environment relatively short usually followed long periods stability traffic control example 24hour day divided say three periods morning afternoon night environment remains unchanged period changes end period thus change environment followed long period stability environment remains unchanged hours 3 periods change environment adaptive program behaves arbi trarily words nothing asserted programs behavior periods hand periods stability environment remains unchanged adaptive program secures behavior consistent current environment traffic control example controller program behaves arbitrarily short period eg seconds environment switches morning afternoon environment settles afternoon period controller secures behavior optimizes afternoon traffic patterns paper environment program defined set input variables read written program assume program computation environmental change asynchronous time program execution values input variables change arbitrarily consequence difficult say cases correct adaptivity instance response environmental change adaptive program may compensate computing choice new time choice effected environment may changed input variables long scenario repeated adaptive program cannot behave appropriately current values input variables notion adaptive program somewhat similar notion selfstabilizing program 2 3 6 10 selfstabilizing program property computation leads maintains legitimate state arbitrarily chosen initial state arbitrary state initial state selfstabilizing program special attributes consequently selfstabilizing programs interesting prevail transient faults program state following transient fault effect new initial state way view environmental change transient phenomenon adaptive program converge appropriate behavior paper formalize definition program adaptivity present logical properties definition also present operators combining adaptive programs retaining adaptive properties begin discussing adaptive sequential programs sections 2 3 extend discussion adaptive distributed programs sections 4 5 section 6 investigate relationship adaptivity self stabilization section 7 outline case study constructing adaptive distributed program token circulated ring processes section 8 contains discussion applicability proposed methods concluding remarks section 9 2 adaptivity sequential programs section concepts programs program computations defined characteristic property adaptive programs called secures also defined although definitions restricted sequential programs extended distributed programs section 4 let sequential program defined set variables set actions every variable v prescribed domain either input variable internal variable action guarded assignment form p c p predicate variables v c assignment statement assigns values internal variables statespace cartesian product domains variables v state element statespace thus denotes value variable v state predicate boolean function statespace value state predicate p true state say p holds r state predicate p input predicate program denoted input p simply input p understood iff p predicate whose definition makes reference internal variable transition ordered pair states r action p c p holds obtained r replacing values internal variables indicated assignment statement c r transition p holds say enabled r note definition transition introduces nondeterminism one transition may originate state r one action enabled r computation sequence states every consecutive pair transition empty singlestate sequences therefore computations prefix suffix computation computation restrict scope prefix suffix follows prefix computation finite sequence suffix computation suffix respect finite prefix suffix nonempty computation nonempty computation computation maximal iff proper prefix computation maximal computation either infinite exists transition originating last state computation sequential program adaptive iff properties interest stated terms following secures relation secures q adaptivity iff p input predicate maximal computation p holds state computation exists suffix computation q holds state suffix convenience write p secures q program understood operationally interpret p secures q follows p input predicate false possible environment set values input variables program p satisfied p satisfied program converge accord situation q holds continues hold indefinitely q satisfied environment change subsequent program transitions effect constitute new computation definition adaptivity applies new computation example 1 consider following program three input variables b c one internal variable z two actions input variable b c internal variable z actions program prove b two proof obligations definition secures first b 0 input predicate b input variable second consider maximal computation b 0 holds state first action enabled state computation thus first transition computation establishes b subsequent transitions leave state unchanged completes proof b similarly shown b 1 secures secures properties program proved appealing definition secures deduced following inference rules correctness rules established definition secures proofs given appendix input p secures true secures q secures q input r r r secures q secures q q p secures r weakening secures q r secures junction properties secures derived various combinations rules instance input p secures p stability derived truth sharpening rules similarly false secures r falsehood derived stability weakening rules 3 composition sequential programs adaptive programs composed combining smaller adaptive programs composed programs retain secures properties constituent programs section describes two types composition level hierarchical level composition combines two programs equal roles resulting composite program hierarchical composition combines two programs one programs subordinate compositions applied repeatedly combine finite number programs single program 31 level composition level composition principle tool constructing adaptive program prerequisite level composition two programs compatibility secures properties compatibility syntactic restriction variables programs given two sequential programs compatible holds iff variable name type programs note type variable determines whether variable input internal variable also determines domain values variable note also compatibility two programs difficult achieve renaming variables one program name common programs compatibility assured let two compatible sequential programs let e input boolean variable occur let e denote program w b w union feg variables variables b union two sets actions first set contains action program action second set contains action action e p based definition following rule proved secures q p secures r compatible secures q e secures r e level composition example 2 required design traffic control program morning program directs traffic either right across evening directs traffic either left across consequently propose program internal variable traffic take values left right across inspired level composition rule start two adaptive programs morning program evening program two programs contains assignments internal variable traffic combining two programs using input variable named morning construct required traffic control program morning morning program defined follows input variable waiting boolean internal variable traffic left right across actions waiting traffic across waiting traffic right shown waiting secures waiting secures result reduced junction sharpening rules true secures waiting waiting evening program defined input variable waiting boolean internal variable traffic left right across actions waiting traffic across waiting traffic left symmetry adaptivity property true secures waiting waiting required traffic control program morning input variable waiting morning boolean internal variable traffic left right across actions morning waiting traffic across morning morning morning following adaptivity property program morning obtained level composition rule simplification result true secures waiting waiting morning waiting morning operational view simple example consider effect change programs environment environmental change enough environment static long enough execution one action morning assure program correctly adapts current environment assigning traffic appropriate value environment changes execution action assignment traffic may inappropriate however secures specify behavior environment changes computation soon environment stabilizes long enough complete execution action program correctly adapts 32 hierarchical composition notation hierarchical composition programs informally means execution program suspended program terminates variables declared input variables may internal variables play role environment prerequisite hierarchical composition two programs controllability one sequential programs relation controls holds iff variable name domain programs internal variable variable restriction input variables input variable may internal input variable following two definitions introduce notation state hierarchical composition rule let idlet sequential program denote conjunction negated guards actions ie thus idlet holds state action enabled let two sequential programs controls let denote program w b w union variables variables variables thus variable internal program also input program internal program w b union actions two sets actions first set consists actions program second set contains action p c program action based definition following rule proved secures q secures r controls p secures r hierarchical composition operational interpretation rule follows suppose execution program starts state satisfying p q state actions enabled executed secure q actions form disabled execution actions continues q established ensuring idlet state actions become enabled executed secure r note notion hierarchical composition less similar notion superposition chandy misra 4 example 3 let program defined follows input variable clock internal variable morning boolean actions clock morning true morning false straightforward show program suitable hierarchical composition composite program morning example 2 proof consists four steps first shown secures morning second shown third condition follows level composition rule morning secures waiting waiting traffic right morning fourth internal variable traffic morning appear therefore controls morning thus hierarchical composition rule applied combine two programs morning one program morning result waiting waiting 4 adaptivity distributed programs distributed program defined sequential program meets additional constraints imposed partitioning variable set action set thereby definitions adaptivity compatibility composition sections 2 3 straightforward extensions distributed programs distributed program pair ff sequential program ff partition variables v actions subject following constraint ff partitions v collection sets partitions actions sets every assignment statement c assigns values variables v note sets fv fa g may empty definition distributed program ff may interpreted collection sequential programs called processes process defined corresponding sets variables actions defined partition ff w set variables appearing v observe given sequential program may many choices ff satisfy definition distributed program partition possible case ff single process also notice whereas ff partitions v disjoint sets processes may share variables provided two processes assign variable thus ff locates variable exactly one process process may read write variables located processes input variables exempt considerations since process writes input variable location input variable arbitrary example ff could place input variables v k let k empty practice location input variables significant consideration distributed systems develop special rule section 5 deal concern computations distributed program ff exactly computations sequential program model concurrency interleaving computation ff interleaving computations processes definition secures distributed program follows secures q ff iff ff distributed program p secures q concurrency definition rules reasoning secures properties sequential programs extend straightforward way reasoning secures properties distributed programs 5 composition distributed programs two distributed programs combined combining corresponding processes end extend notions level hierarchical composition distributed programs 51 distributed level composition start extending notion compatible distributed programs compatible every variable x named x assigned assigned k definition compatible intended preserve structure ff fi composite program consisting ff fi partition variables composite program rank ff fi example definition assures two processes composite program write common variable note requirement made simplicity instance define ff 0 padding partition variables given ff empty sets satisfy rankff 0 let e vector input boolean variables two predicates alle noe follows given two compatible distributed programs ff fi let e vector boolean input variables occurs neither distributed level composition compatible distributed programs written ffet fi denotes distributed program whose processes fs secures q ff p secures r fi secures q ff e fi secures r ff e fi distributed level composition proof rule similar proof level composition rule given appendix 52 distributed hierarchical composition let ff fi two distributed programs fi controls ff iff rankfi controls suppose ff controls fi distributed hierarchical composition ff fi written fi ff denotes distributed program whose processes order distributed hierarchical composition desired adaptivity properties define following property distributed programs computation let ff distributed program ff fairunder p holds iff every computation ff p holds states every suffix computation contains transition every range 0 secures q fi q secures r ff p secures r fi ff distributed hierarchical composition proof rule similar proof hierarchical rule appendix note may possible partition computation fi ff transitions corresponding fi precede transitions corresponding ff instance possible action j executes later action k executes k 6 j possible composite fi ff guard corresponding j action depends idlet j depend idlet k however within process actions priority actions long action k k enabled eventually executed thanks ff fairunder p assures continued execution ff depends action k k actions priority k actions thus ff cannot prevent eventual progress fi composite program 6 adaptivity selfstabilization section discuss relationship adaptivity selfstabilization many cases adaptivity appears generalization selfstabilization start defining notion selfstabilization terms model computation sequential program predicate q selfstabilizes q iff maximal computation partitioned prefix suffix state prefix satisfies q state suffix satisfies q definition selfstabilization predicate q stable closed respect computation state satisfying q reached subsequent states also satisfy q literature selfstabilization 3 2 6 predicate q typically predicate internal variables program however definition also permits q refer input variables q refers input variables meaning legitimate state depends environment selfstabilizing program also adapts environment thus view selfstabilization particular type adaptivity relationship selfstabilization adaptivity stated rule selfstabilizes q true secures q easily proven definitions secures selfstabilization converse rule hold general true secures q program imply program selfstabilizes q programs true secures q holds predicate q stable exist transitions form r r satisfies q satisfy q section 7 contains example usually true secures q holds exists predicate r r q program selfstabilizes r cases kind converse relationship adaptivity selfstabilization however following example demonstrates instances true secures q imply underlying selfstabilization example theoretical interest exploits nondeterminism model computation let z program internal variable x domain 012 actions straightforward show true secures x 6 2 z every maximal computation whose initial state suffix every state also every maximal computation whose initial state x 1 suffix either every state x 0 every state refute possibility r satisfying z selfstabilizes r r expansion r four possibilities r false four cases exhibit maximal computation cannot partitioned satisfy z selfstabilizes r first z selfstabilize false maximal computations z nonempty second z selfstabilize maximal computation consisting states third z self stabilize maximal computation consisting states fourth z selfstabilize x 6 2 due following maximal computation nonempty sequence followed state followed infinite sequence states end refutation 7 case study adaptive token section apply two distributed composition rules level hierarchical construct adaptive distributed program token circulated ring processes construction proceeds three steps first two distributed programs presented program token circulated ring processes two programs differ policies token circulation second two programs combined using distributed level composition rule form adaptive program whose behavior switched behaviors two constituent programs third adaptive program combined controller program using distributed hierarchical composition rule controller program selects based current environment two constituent programs executed two constituent programs different policies circulating token one program circulates token continuously busy token program circulates token process current holder requests token lazy token busy token behavior reasonable environment token requested frequently different processes lazy token behavior reasonable environment token infrequently needed adaptive program switches two behaviors according observed frequency token requests 71 busy token busy token program henceforth called busy continuously circulates one token among set n processes busy j fs process defined follows internal variable x actions x program remainder case study adopt convention subscripts modulo n n number processes system say process holds token x mod predicate homebusy true iff state busy satisfies exactly one process satisfying informally homebusy describes state exactly one process either token token immediately next transition shown true secures homebusy busy proof consists showing busy selfstabilizes l l predicate satisfying predicate l complicated formulation proof selfstabilization little common methods paper include proof paper reader find proof 8 case busy selfstabilizes homebusy exist transitions state exactly one token state two tokens 72 lazy token lazy token program henceforth called lazy circulates one token among set n processes one processes needs token lazy j ft process defined follows internal variable x internal variable input variable z actions process integer variable x two boolean variables z variable z input variable indicating need token process say process holds token x mod following predicate used guard one action predicate holds token i1 token token i1 adaptivity property program true secures homelazy lazy homelazy predicate holds state exactly one process satisfying 73 adaptive token busy lazy token programs compatible hence composed using distributed level composition rule resulting composite program busy elazy satisfies alle secures homebusy noe secures homelazy program busy e lazy applicable environment alle noe holds presumably alle hold environment processes frequently require use token busy program behavior appropriate illustrate hierarchical composition present fully distributed program obtain consensus alle input variables may arbitrary values let b array boolean input variables represent frequency token requirement variable b true iff process busy e lazy frequently requires token define program concur j fz j process z defined follows internal variable internal variable e input variable b actions ii ii igamma1k function f outputs boolean value input nelement boolean array majority vote plausible definition f last line program denotes actions copy k boolean variables igamma1k ik shown computations concur finite concur satisfies junction rule follows true secures holds thus process holds image b vector consequently straightforward show secures alle fb secures noe inspection concur controls busy e lazy verified 8 shown concur busy e lazy fairunder true holds therefore distributed hierarchical composition applicable result secures homebusy concur busy e lazy secures homelazy concur busy e lazy 8 applicability section addresses concerns related application definitions composition rules given paper discuss limitations methodology level composition tool constructing particular class adaptive programs domain applicability limited definition secures limits ability describe certain aspects program behavior view adaptivity different programs different environments traditional meaning adaptive program typically behavior adaptive program seen one program parametrized environmental inputs instance p secures q q specifies constraints input variables one behavior behavior adapts environment kind adaptive behavior call incremental adaptivity instances adaptive behavior better modeled different programs different behaviors call threshold adaptivity distinction incremental threshold adaptivity largely methodological adaptive programs difficult say view better suited methodology constructing incremental adaptive programs outside scope paper methodological contribution limited adaptive programs threshold adaptivity appropriate significant application threshold adaptivity appears 1 presents adaptive routing protocol problem adaptive routing network wellknown 12 optimal route message destination minimum cost path messages source destination network changes costs change optimal routes recomputed two distributed protocols selfstabilizing given 1 calculating minimum cost paths network since protocols selfstabilizing incrementally adaptive responding changes network costs one protocols lazy program reaches fixed point performs computations long network costs change protocol busy program repetitively computes minimum cost paths even network costs static turns lazy protocol preferable network changes infrequently whereas busy protocol better rapidly changing network two protocols combined distributed level composition obtain threshold adaptive protocol message routed time switch one protocol computation minimum cost paths may incomplete message could misrouted delayed lost expect message retransmission timeout used tolerate transient errors limitations secures related issues program behavior periods environmental change immediately following change environment show p secures q enough prove program converges q maintains q convergence q program may exhibit undesirable behavior example adaptive program part distributed data base service transaction might lost convergence appropriate behavior conceivably situation could addressed proving desired properties hold convergence eg proving program behavior convergence satisfies safety properties however proving properties convergence difficult context work definition secures permit specification initial values programs internal variables instead proving desired properties hold convergence recommend applications methods paper limited situations unpredictable behavior tolerated data base service transaction lost client service could resubmit transaction question frequently asked adaptive distributed systems user system know system behaving properly distributed system possible answer question instant user distributed system local view asynchronous environmental change possible information accumulated messages locations could inaccurate time information assembled form global view question posed selfstabilizing systems eg user know system stabilized instead attempting answer question directly researchers typically answer question long take stabi lize adaptive program terms model corresponding question maximum number transitions required correctly adapt current environment question answered adaptive programs techniques used calculate costs selfstabilization eg see 5 7 although done examples paper feasible analyze worstcase scenarios bound number transitions required convergence calculating upper bound number transitions needed convergence estimate given real time taken program transition possible specify long period environmental stability must guarantee correct adaptation programs current environment exception theoretical example given section 6 nondeterminism maximal computation defies upper bound number transitions needed convergence although claimed possible correctly adapt asynchronously changing environment instant change practice changes environmental conditions acceptable often enough approximate adap tivity order formalize notion approximate adaptivity stronger assumptions environment needed synchrony environment program could given domain input variables may specialized framework paper address approximate adaptivity however tool variable abstraction hierarchical composition could useful approximate adaptivity consider instance scenario environment changes frequently never adequately long period stability assure proper adaptation judicious use hierarchical composition may possible buffer change environment thereby allowing subordinate adaptive program function behavior rather spending effort switching one behavior another 9 conclusions studied problem adaptivity distributed system one object study reason program behavior respect environment using assumptions environment program computation assume computation environmental change asynchronous environmental change unpredictable model computation simple depend fair computation control structures thereby results may appeal implementations driven interrupts shown even restricted assumptions logic reasoning adaptive behavior possible restricting assumptions hope results broad applicability example results apply situations fair computation predictable environment second object study methodological develop techniques constructing adaptive programs claim techniques proposed paper constitute possible solution adaptive programming even case threshold adaptivity alternative method might resemble following scenario periodically environment sampled sample indicates change behavior effected broadcast quiesce operation initiated processes acknowledge active behavior quiesced broadcast start operation initiated new behavior method relies distributed synchronization start stop behavior even signal start behavior cannot instantaneous distributed system consequently programs individual processes deal problems distributed control note behavior explicitly started signal internal variables initialized time start signal detected contrast definition secures assures programs eventually behave properly without initialization internal variables desire separate concerns adaptivity concerns distributed control led us definition secures depend variable initialization questions related study merit investigation program computation environmental change synchronous specific types adaptivity con sidered example change environment sinusoidal pattern certain frequency program adapt change frequency another question related composition operators proposed roughly speaking hierarchical composition rule corresponds sequential composition sequential programming language level composition rule corresponds alternative construct else sequential programming language also composition rule corresponding iterative construct sequential programming language appendix 101 proofs inference rules proofs section based definition adaptivity p secures q form p q definition secures two proof obligations first obligation establish p input predicate trivial task verification omit second obligation show every maximal computation appropriate suffix q holds state part proof present case streamline presentation observe two cases maximal computation either empty nonempty case empty definition secures reduces universal quantification empty range secures holds trivially therefore maximal computations assumed nonempty proofs consider maximal computation p holds state observe true tautology true holds states sharpening antecedent maximal computation p holds state exists suffix q holds state therefore p q holds state suffix strengthening consider maximal computation r holds state also holds state antecedent p secures q implies q holds state suffix junction conjunction consider maximal computation p r holds state observe p r p p r r antecedents applicable suffix q holds state suffix holds state therefore suffix q holds state junction disjunction consider maximal computation p r holds state let r transition three cases holds holds iii p r holds r predicates p r input predicates case iiii state case r input variable values change due transitions moreover one case iiii holds states case p holds state antecedent asserts suffix q holds state hence q holds state suffix treatment case ii follows symmetry case iii follows conjunction shown fact 102 proofs composition rules proofs composition rules define state projections projection maps state composite program state one constituent programs instance let ffi composition two programs let h projection state state h excludes variables appear ffi extend projections operate sequences states elementwise application observe ae sequence states ffi p predicate variables p holds state ae iff p holds state hae level composition two parts rules conclusion symmetric demonstrate one part let f projection state et state observe maximal computation e e true states f maximal computation complete proof let maximal computation et p e holds state antecedent p secures q maximal computation f therefore suffix q holds state therefore suffix q holds state hierarchical composition let arbitrary maximal computation proof obligation show p holds state suffix r holds state show two steps first partitioned prefix suffix q holds state suffix second suffix maximal computation turn suffix r holds state remainder proof assume p holds state let f projection state state let g projection state state first step show existence suffix wherein q holds let maximal prefix action enabled state gffi consider three cases case changed missing composite action derived action enabled idlet holds therefore computation gffi maximal computation antecedent secures q suffix gffi q holds state suffix hence q holds state suffix enabled g therefore transition due action derived program f maximal computation observe first state g constitutes maximal computation antecedent secures q follows q holds first state g consequently q holds first state also first state f definition q secures r predicate q satisfies input q q holds state f hence state case 2 ffi nonempty since p holds state action enabled first state g antecedent p secures q follows q holds first state g hence q holds first state since q input predicate program transition derived action falsify q therefore idlet q hold state second step show existence suffix wherein r holds let ae suffix q holds state ae assumed p holds state ae antecedent action enabled gae observe ae maximal computation holds states therefore fae maximal computation antecedent q secures r fae suffix r holds state suffix hence ae suffix r holds state r composite routing protocols token systems selfstabilize uniform selfstabilizing rings parallel program design foundation costs selfstabilization selfstabilizing systems spite distributed control convergenceresponse tradeoffs concurrent sys tems department computer sciences ieee 8025 token ring access method selfstabilizing extensions messagepassing systems ethernet distributed packet switching local computer networks computer networks tr costs selfstabilization parallel program design foundation uniform selfstabilizing rings token systems selfstabilize selfstabilizing extensions messagepassing systems ethernet selfstabilizing systems spite distributed control ctr mohamed g gouda multiphase stabilization ieee transactions software engineering v28 n2 p200208 february 2002 g gouda multiphase stabilization ieee transactions software engineering v28 n2 p201208 february 2002 frdric duclos jacky estublier philippe morat describing using non functional aspects component based applications proceedings 1st international conference aspectoriented software development april 2226 2002 enschede netherlands j beauquier b brard l fribourg f magniette proving convergence selfstabilizing systems using firstorder rewriting regular languages distributed computing v14 n2 p8395 april 2001 w b prasetya swierstra formal design selfstabilizing programs journal high speed networks v14 n1 p5983 january 2005 marco schneider selfstabilization acm computing surveys csur v25 n1 p4567 march 1993
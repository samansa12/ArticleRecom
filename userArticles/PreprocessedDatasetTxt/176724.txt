complexity decision versus search basic question np whether search reduces polynomial time decision paper indicates answer negative complexity assumption deterministic nondeterministic doubleexponential time unequal language np search reduce decision constructed ideas extend natural way interactive proofs program checking similar assumptions authors present languages np harder prove membership interactively decide membership languages np checkable b summary summarize relationships amongst various complexity classes wehave discussed first notation de ne triple exponential time class similarlywe let bpeee denote class languages recognized bounded error probabilistic ntm running time 222 constant c 0 following inclusions known easily derived known techniques 3 compip check frip mip coh assumption nee bpee establish following4 np contained following compnp compip check frip 5 np coh contained following compnp compip check frip results line 4 see theorems 29 44 53 36 line 5 see theorem discussion end section 5 finally assumption neee bpeee bfestablish following 6 np coh2 decision versus searchinnp section present simple construction language np searchdoesnot reduce decision assuming ee nee later sections extend argumenttointeractive proofs program checking let us begin de nitions 21 de nitions goal section make precise mean search reduces decision np language l since issues discussed length section 11we brief stating formal de nitions limiting discussion essentials convenient proceed steps begin de ning nprelations saying means search reduce decision use say means search reduce decision np language de nition 21 let beapolynomial time computable binary relation let x 2f0 1g let x f w call members set witnesses xwe say nprelation exists constant c 2 n x 2f0 1g case x f0 1gjxjc language de ned f x 2f0 1g x gand denotedl note nprelation l 2 np notation w oracle machine wl x denotes output w oracle l f0 1g input x 2f0 1g wenowsay means search reduce decision nprelation equivalent formulation de nition follows appears bd de nition 22 suppose nprelation w isapolynomial time oracle machine let l l say w witness nder x 2 l case wl x 2 x say search reduces decision exists witness nder note witness nder restricted particular method example required length queries decreasing time rather polynomial time computation allowed strengthens negative results wenow wish say means search reduce decision np language opposed nprelation begin following terminology de nition 23 suppose nprelation l f0 1g language say de nes clearly exists nprelation de nes l however particular language l 2 np may many di erent nprelations de ne lifl npcomplete search reduces decision nprelations however l npcomplete search might reduce decision others de ning means search reduce decision l wehavechosen liberal ask nprelation de ning l search reduces decision de nition 24 suppose l f0 1g say search reduces decision l exists nprelation de nes l search reduces decision wehave indicated section 1 de nition motivated byinteractive proofs question whether proving membership harder deciding proving membership l easy sense l competitive npproof system long search reduces decision nprelation de ning lsowe led de nition 24 note context languages suchasf0 1g easy associated search problem hard certainly dont wish think search harder decision languages appropriately search reduce decision languages according de nition finallywe note existence language search reduce decision course imply existence nprelation search reduce decision negative results de nition stronger simply conclude existence nprelations search harder decision whenever understood say witness witness nder rather witness witness nder 22 uniformly logsparse languages proof use languages combine logarithmic sparseness property possible e ciently identify logarithmic sized superset strings belowany given length let us proceed formal de nitions de nition 25 census function l n n l f0 1g language l de nedby say l logsparse l n logn l n number strings l whichhave length n language logsparse contains log n strings length n logsparse languages used hsi called next de nition formalizes idea able e ciently identify superset language speci es notion uniform logsparseness whichwe interested de nition 26 say c f0 1g candidate selector l c polynomial time decidable l c say language l uniformly logsparse logsparse candidate selector see section 23 interest uniformly logsparse languages form class problem reducing search decision particularly hard let us end section stating lemma whichwe use later lemma generalizes work hartmanis sewelson immerman hsi showed logsparse language np pife nee ylogsparseness weaker uniform logsparseness candidate selector required easy see uniformly logsparse language np p nonetheless exists assumption completeness provide sketch entirely standard proof lemma 27 ee nee uniformly logsparse language np pproof use standard downward separation argument assume ee nee suppose ne l uniformly logsparse l 2 np p hsi claimed converse well allender al points proof awed theorem cannot proved using techniques relativize de ne algorithm input x 2f0 1gn behaves follows n range g outputs 0 else computes k g1 n outputs 1 last n k bits x zero c f x x 1g candidate selector l c n 21g1 n logn l uniformly logsparse fact l 2 np p follows directly fact l0 2 nee ee 23 language search reduce decision following main lemma section shows reduction searchto decision uniformly logsparse language possible trivial case language already p lemma 28 suppose l uniformly logsparse language search reduces decision proof assumption exists nprelation polynomial time oracle machine w de nes l w witness nder construct polynomial time machine decides lwe begin describing idea informally idea use w subroutine nd witness di culty course w makes oracle queries l access oracle l machine certainly cannot correctly answer queries see nonetheless exploit w suppose moment w guaranteed make one oracle query entire computation input x try possible answers branches pair parallel computations rst answers query 0 second answers 1 cases runs w w halts clearly x 2 l least one runs outputs witness strategy polynomial time idea extends w making log n queries realityhowever w could make polynomially many queries strategy e cient point weinvoke uniform logsparseness l whichwehave used far implies really log n e ective queries w make since w write queries polynomial length use logsparse candidate selector l identify set log n strings include strings l w could possibly query need branch overall strategy mind let us specify operation precisely since nprelation exists constant c 2 n x 2f0 1g case x f0 1gjxjcwe assume constant 0 input x 2f0 1g machine w halt djxjd steps output string length jxjc regardless oracle queries w answered also assume wlog queries made w distinct let c logsparse candidate selector lnow input x 2f0 1gn machine behaves follows runs w input x time w makes oracle query q machine provides response follows 11 q 2 c responds 012 else continues trying parallel possible answers 0 1 branches two parallel computations rst lets response q 0 second lets response q 1 continues run w computation manner generates number parallel computations dnd steps computations halted yielded nc bit output output w examines set outputs previous step accepts least one outputs w satis es x w 1 rejects otherwise completes description machine fact works clear completeness let us spell first see accepts x x 2 l su ces check least one parallel computations oracle queries correctly according l answered step 11 obviously correct de nition candidate selector step 12 everything tried one runs certainly end right query answers next thing check runs polynomial time su ces show total number parallel computations 1 su ces show number branches path log n wenow argue latter first note query q length dnd running time w branching occurs q 2 c wehave assumed ws queries distinct number times branching occurs size dnd g c dnd logn completes proof put pieces together obtain result theorem 29 ee nee exists language np search reduceto decision proof lemma 27 exists uniformly logsparse language l 2 np p lemma 28 search cannot reduce decision l note fact search reduce decision l implies l npcomplete existence non npcomplete language npp however established assuming 3 deciders properties extending ideas previous section interactive proofs checking pause develop technical materiel materiel useful proving results later sections particular weintroduce notion decider enable us give uni ed concise treatment rest results paper begin de nition de nition 31 let beaprobabilistic polynomial time oracle machine say decider language l x 2f0 1g following true accepts probability 2 3 probability da x accepts 1 3 oracles awe note l decider functionrestricted ip cf bk deciders wayofcharacterizing languages frip also viewed checkers yes instances weaker multiprover interactive proofs results frs imply l decider multiprover interactive proof us motivation de nition 31 generalize notion witness nder light proof lemma 28 property witness nder important proof correct x 2 l long oracle queries answered correctly ie according l correct x 2 l nomatter oracle queries answered like witness nder correctness decider inputs guaranteed except high probability long oracle queries correctly answered hand x 2 l correctness guaranteed high probabilityno matter oracle queries answeredaswe see properties su ce us appropriately extend lemma 28 lemma 43 error probabilityof13 de nition always su cient convenientto also de ne following de nition 32 let beaprobabilistic polynomial time oracle machine say strong decider l x 2f0 1g following true accepts probability 1 2jxj probability da x accepts 2jxj oracles astandard errorreduction course says strong deciders exist whenever deciders exist completeness let us state proposition provide sketch proof proposition 33 l decider strong decider proof let decider lwe de ne machine d0 follows input x machine d0 runs input x total n times time independent coin tosses oracle queries made d0 answered d0 byway oracle makes oracle query q d0 makes oracle query q provides answer receives d0 outputs majorityvote outputs trials see d0 strong decider l let x1axma denote sequence random variables representing outcomes oracle successive trials independent 1msatisfy pr xl 1 2 3 case oracles case x 2 l application standard cherno bounds yields desired conclusions wesaw section 2 reducing search decision uniformly logsparse languages hard show languages also deciders unless bpp lemma 34 suppose l uniformly logsparse decider l 2 bpp proof proposition 33 l strong decider dwe showhowtoused construct bpp machine decide l idea much proof lemma 28 decider playing role witness nder played proof input x machine run input x answer oracle queries according rules used proof lemma 28 accepts decider accepts least one parallel computations main di erence respect lemma 28 lies fact way tell whether particular output decider correct lemma 28 one always check whether output witness nder really witness instead correctness procedure follows fact error probabilityofd small 2n details follow let constant always halts dnd steps inputs length n let c logsparse candidate selector lwe assume wlog oracle queries made distinct input x 2f0 1gn machine behaves follows runs input x time makes oracle query q machine provides response follows 11 q 2 c responds 012 else continues trying parallel possible answers 0 1 branches two parallel computations rst lets response q 0 second lets response q 1 continues run w computation manner generates number parallel computations dnd steps computations halted yielded output 1 0 output examines set outputs previous step accepts least one outputs 1 since answers one parallel computations correspond l machine accepts dnd g let adenote set subsets q parallel computation corresponds running oracle 2a follows probability accepts a2a pr da accepts assumption strong decider lsowe bound jaj 2n claim probability accepts completing proof justify claim note jaj 2jqj jqj c dnd log n recall bpee denote class languages accepted time 2c2n constant c 0by probabilistic machine bounded error argument analogous used proof lemma 27 show following lemma 35 nee bpee exists uniformly logsparse language np bppcombining lemma 34 obtain following theorem whichwe use next two sections theorem 36 nee bpee exists language np deciderwe remarked earlier l decider l 2 frip lemma 36 says nee bpee impliesnp frip later sections use theorem 36 show nee bpee implies np checkby showing languages compip checkhave deciders cf lemmas 43 52 competitiveinteractive proofs begin recalling notion interactive proof de ne competitiveinteractive proofs present results 41 interactive proofs interactive proofs extensions np ones let us begin recalling latter np proof system language l 2 np de ned polynomial time veri er v imagine veri er talking prover parties receive common input x provers goal convince veri er accept end allowed send veri er single message length veri ers decision whether accept made function common input message since veri er deterministic decision polynomial time binary predicate evaluated common input provers message case exist deterministic prover p convince veri er accept completeness condition case x 2 l prover able toconvince veri er accept soundness condition usually specify np proof system pair pv p prover satisfying completeness condition clearly l 2 np possesses np proof system interactive proofs whichwere introduced goldwasser micali racko gmr natural extension np proof systems parties allowed probabilistic moreover allowed interact exchange messages polynomial number rounds end exchange v decides whether accept say pv isaninteractive proof language l 1 common input string litis possible p induce v accept high probability 2 common input string l prover prevent v rejecting high probability let us proceed formally party interactive proof may viewed probabilistic function common input conversation far outcome function input x common input c transcript conversation far whichwe denote x c next message computed sent party assume transcript conversation pointmay uniquely parsed constituent messages wemay discuss complexity parties usual way viewing computed probabilistic turing machines example veri er party computable probabilistic polynomial time tm complexity measured function length common input whichwe usually denote n total numberofmoves move consists party computing sending message well length messages assumed bounded polynomial n end interaction veri er accepts rejects applying deterministic binary predicate common input transcript conversation suppose prover interacts veri er b common input x probability b accepts interaction common input x probability b accepts given common input x transcript 1 1 g1 g1 g chosen according following experiment 1 g g n total number moves empty string assuming simplicity speaks rst last probabilities random choices parties conversation de nition 41 interactive proofs gmr let pv beapair probabilistic functions say pv interactive proof system language l v probabilistic polynomial time 1 every x 2 l probability v accepts interaction p common input x 2 every x 2 l every function pb probability v accepts interaction pbon common input x 1 3 rst condition completeness condition second soundness condition note strength soundness condition quanti cation functions pb call cheating dishonest provers even noncomputable ones note np proof system special kind interactive proof system speci callyan np proof system interactive proof system pv p v deterministic interaction restricted single message prover veri er probabilities completeness soundness conditions 1 0 rather 2 3 1 3 respectively addition interaction randomness however seems add signi cantly language recognition power system established lund fortnow karlo nisan lfkn ip class languages possessing interactive proofs membership contains polynomial time hierarchy shamir sh extended show ip equals pspace wesay function probabilistic mean x c party actually associates distribution strings xc random element distribution 42 competitiveinteractive proofs basic complexity theoretic question determine e cient prover p interactive proof pv language l certainly would need least ability decide language de ne competitiveinteractive proof system one prover allowed speci callyhemust run probabilistic polynomial time given access l oracle see competitiveinteractive proofs represent natural generalization problem decision vs search de nition 42 let p beaprobabilistic polynomial time oracle machine v aprobabilistic polynomial time machine say pv competitive interactive proof system language 1 every x 2 l probability v accepts interaction pl common input x 2 every x 2 l every interactive tm pb probability v accepts interaction 6 pbon common input x 1 3 rst condition completeness condition second soundness condition call p competitive prover note soundness condition remains de nition interactive proofs particular restrict computational power cheating prover pbin case x 2 lour goal understand di culty providing correct proof unrestricted soundness would appear inherent property proofs competitive np proof systems de ned natural way competitive np proof system competitiveinteractive proof system parties deterministic interaction restricted single message prover veri er probabilities completeness soundness conditions 1 0 rather 2 3 1 3 respectively equivalently np proof system prover restricted polynomial time plus oracle lwenow note search reduces decision l l competitive np proof system prover competitive np proof system corresponds witness nder sense competitiveinteractive proofs natural extension problem decision versus search 43 np language possessing competitiveinteractive proof section 2 presented language l 2 np search unlikely reduce decision words l unlikely competitive np proof system truth however proving membership np languages remains hard even interaction randomness allowed show probably np language even havea competitiveinteractive proof system given results section 3 need following lemma shows language possessing competitiveinteractive proof also decider equivalently compip frip lemma 43 suppose l competitive interactive proof system decider proof let pv competitiveinteractive proof lwe note probabilistic polynomial time run p v given oracle machine input x sample space conversations pa v input x accept conversation obtained accepting details follow let r n denote polynomial bound number coin tosses used p v input length n picks uniformly random r n bit string rp r n bit string rv runs p v common input x using rp coins p rv coins v assuming example p sends rst message would run p coins rp get ps rst message would run v coins rv get response oracle queries made p process answered byway oracle makes oracle query q makes oracle query q provides answer receives p eventually obtains output v 1 v accepts 0 otherwise outputs value given particular oracle case da x isa01 random variable clearly probability 1 equals probability v accepts interaction pa common input x assumption pv competitiveinteractive proof l follows case x 2 l pr da x 1 1 3 oracles case x 2 lcombining lemma 43 theorem 36 yields theorem theorem 44 nee bpee exists language np competitiveinteractive proof note wehave done simply show interactive proofs may powerful competitive ones language l theorem 44 np subclass ip possesses particularly simple interactive proofs show interactive proofs powerful competitive ones would su ce present language ip necessarily np competitiveinteractive proof done weaker assumptions extension argumentwe used example let show eespace bpee exists language ip whichdoesnotpossess competitiveinteractive proof general construct language l lies particular complexity class c possess competitiveinteractive proof su ces assume doubleexponential counterpart c contained bpee put phrase doubleexponential counterpart quotes course always make sense many classes counterpart many natural classes used paradigm make sense 44 zeroknowledge aspects competitive aspects zeroknowledge proofs may also worth investigating initiate suchaninvestigation let us try discuss brie one easily infer known work open questions np languages competitive zeroknowledge interactive proofs general course probably since theorem 44 probably even competitiveinteractive proofs let alone zk ones appropriate question whether np languages possess competitiveinteractive proofs also possess competitive zeroknowledge interactive proofs answer depends kind zeroknowledge one considers kind cryptographic assumptions one willing make let us rst consider computational zk result goldreich micali wigderson gmw implies npcomplete languages competitivezkinteractive proofs given existence oneway functions generally implies search reduces decision l l competitivezkinteractive proof given existence oneway functions know whether assumption exist oneway functions su ces show language possesses competitiveinteractive proof also possesses competitivezkinteractive proof wedoknow latter conclusion may established stronger assumptions suchasthe existence ideal secure circuit evaluation existence oblivious transfer follows result kilian ki refer reader paper details exactly assumptions statistical zk languages known possess competitiveinteractive proofs also known possess statistical zk competitiveinteractive proofs languages graph isomorphism gmw graph nonisomorphism gmw quadratic nonresiduosity gmr course know whether quadraticresiduosity competitive statistical zk interactive proof given know whether competitiveinteractive proof 5 program checking blum kannan bk introduced notion program checkers informallyachecker function f probabilistic polynomial time oracle machine receives oracle program purports compute f checker also receives input x program entirely correct p f checker supposed accept high probability however program disagrees f particular input x provided checker checker reject high probability de nition follows note program mean deterministic machine halts inputs also recall characteristic function language l function l f0 1g f0 1g de ned l x 1ifx 2 l 0 otherwise de nition 51 bk let c beaprobabilistic polynomial time oracle tm c checker f f0 1g f0 1g programs p x 2f0 1g case accepts probability 2 3 probability cp x accepts 1 3we say c checker language l checker characteristic function l l checkable checker de nition close spirit competitive interactive proofs two important di erences first unlikeinteractive proofs checking symmetric notion checker language l must able determine p correct x x 2 l also x 2 l second programs history independent objects cheating provers arenot thus l l competitiveinteractive proofs l checker wedo know whether every checkable language competitiveinteractive proof checkers also related multiprover interactive proofs bgkw particular results frs imply class languages possess checkers contained mip comip mip class languages possessing multiprover interactive proofs membership note mip nexp result bfl blum kannan bk showed check frip cofrip follows checkable languages deciders completeness however let us see directly lemma 52 suppose l checker decider proof let c beachecker l let probabilistic polynomial time oracle machine input xworks follows begins querying oracle string x oracle returns 0 rejects else runs c input x using oracle denoted answer cs oracle queries accepts c accepts claim decider lto see need check x 2f0 1g two conditions de nition 31 hold rst condition clear see second true suppose x 2 l suppose rst x 0 cased rejects probability1now suppose x 1 probability accepts 1 3 c isachecker combining lemma 52 theorem 36 yields theorem theorem 53 nee bpee exists language np checkablesimilarly eespace bpee exists language pspace checkablewe recall language l coherent membership x l decided probabilistic polynomial time bounded error machine called examiner access l oracle allowed query oracle points di erent xifl coherent wesay incoherent previous negative results checking established rst exhibiting incoherent sets exploiting yaos observation incoherent set uncheckable cf ya bf note stronger results obtained directly moreover techniques indicate even within np class coherent sets could much larger class checkable ones let us sketchwhy disjoint union languages b denoted bisf0x construct widely used complexity theory eg bd hh easy see cf bf l l coherent language l also easy see transformation l l l preserves manycomplexitycharacteristics l example membership np compnp compip check frip particular combining observation theorem 53 yields claimed separation theorem 54 nee bpee exists language np coherent checkable 6 towards competitive proofs quadratic residuosity section return unresolved question whether language quadratic residuosity competitiveinteractive proof system present special case problem competitive proofs possible 61 de nitions looking promise problems rather problems language membership di erence former begin promise input already belongs set wehave decide whether falls given subset set problems considered manyworks eg esy formalization use di erent equivalent ones used works follows problem speci ed pair disjoint sets b intuitively input promised b wehave decide whether b corresponding promise problems promise oracles guaranteed correct promise true de nition 61 promise problem isapair disjoint sets b apromise oracle promise problem given query q returns 1 q 2 0 q 2 b note promise problems intuitively easier language recognition problems promise oracles correspondingly weaker normal oracles particular promise oracle oracle b response queries outside b indeterminate competitiveinteractive proof promise problem b interactive proof given x 2 b property competitive prover gets promise oracle b formal de nition follows de nition 62 let p beaprobabilistic polynomial time oracle machine v aprobabilistic polynomial time machine say pv competitive interactive proof promise problem 1 every x 2 every promise oracle b probability v accepts interaction po common input x 2 3 2 every x 2 b every interactive tm pb probability v accepts interaction pbon common input x 1 3 62 results recall x 2 z quadratic residue square modn x y2 mod n quadratic nonresidue nonsquare modn otherwise also recall section 12 qr f x n x square mod n g qnr f x n x nonsquare mod n special case interested n product constantnumber distinct odd primes precise rst de ne product distinct odd primes g product distinct odd primes present competitiveinteractive proof x n 2 qrs given already qrs qnrs note qrs qnrs complements formallywe talking competitiveinteractive proof promise problem qrs qnrs sense de nition 62 theorem 63 let integer 1 promise problem qrs qnrs possesses competitive interactive proof related work kompella adleman ka presentcheckers special case quadratic residuosity modulus product constantnumber primes ie present checkers promise problem qrs qnrs construction however extend competitiveinteractive proofs correctness checker uses fact program contrast cheating prover history independent prove theorem 63we begin recalling basic number theoretic facts refer reader nz numbertheoretic background justi cation facts x 2 zn let qn x 0ifx quadratic residue mod n 1 otherwise suppose ps p1ps distinct odd primes de ne binary relation zn equivalence relation equivalence class x relation namely f 2 called residue class product xy mod n two elements square mod n x residue class nonsquare mod n otherwise total number residue classes 2s size denote r2s convention last r2s class quadratic residues mod n recall exists competitiveinteractive proof quadratic nonresiduositywe exploit fact reducing proof x n 2 qrs polynomial number proofs nonresiduosity suchaway prover need use probabilistic polynomial time promise oracle qrs qnrs rst step following de nition de nition 64 let n beaproduct distinct odd primes let 2s calavector representative zn following conditions hold 1 yi nonsquaremod n 1t 1 nonsquaremod n pair indices leads us way reduce residuosity test collection nonresiduosity tests long possession representativevector proposition 65 let n beaproduct distinct odd primes let x 2 z suppose y1yt1 representative zn 2s x n 2 qrs xyi mod n nonsquaremod n 1t 1 proof xyi mod n nonsquare mod n 1t 1 residue class di ers residue class yi 1t 1 since representative happens x square mod n use however wehave able get representativevectors su ces showhow prover construct representativevector convince veri er indeed representative using probabilistic polynomial time promise oracle qrs qnrs proposition 66 thereisaprobabilistic polynomial time oracle machine r input x n 2 qrs qnrs access promise oracle qrs qnrs outputs either representative vector z special symbol probability latter event 1 4 proof r picks random y1ym 2 zn t1 2s constant de ned later 1mthe machine r uses promise oracle test whether conditions de nition 64 hold yi vector yi passes test rst suchvector output vectors fail test r outputs probability particular vector passes test 1 tt1 positive constant su ces choose constant crude calculation shows 2e su ces r runs probabilistic polynomial time clear proceed describe protocols begin recalling following gmr basic competitive protocol prove nonresiduosity protocol qnr input x n 1k picks random c1ck 2f0 1g r1rk 2 zn sets zi xciri2 mod n sends z1zk p p1 p sets di 0 zi quadratic residue mod n 1 otherwise 1k sends d1dk v accepts ci di 1k proposition 67 protocol qnr following properties probability v accepts interaction p 1 2 x n 2 qnr pb probability v accepts interaction pb 6 k 3 p competitive runs probabilistic polynomial time given oracle qnr proof rst two items follow basic properties modular residues refer reader gmr proofs last item clear wenow proceed competitiveinteractive proof qrswe use protocol qnr subprotocol input notation let 2s runs algorithm proposition 66 sends output v receives p rejects instead receives vector y1yt1 2 z t1 parties proceed next step subprotocol p uses protocol qnr security parameter k set 2 provetov 1 yi nonsquare mod n 1t 1 nonsquare mod n pair indices 3 xyi mod n nonsquare mod n 1t 1 total 1 2 2invocations qnr protocol accepts subproofs accepting correctness protocol follows results established details follow suppose qrs proposition 66 implies parties get representativevector proceed subprotocol probability 3 4 de nition 64 proposition 65 imply inputs nonresiduosity subproofs indeed nonsquares mod n thus proposition 67 implies subproofs succeed probability1 sov accepts suppose qnrsifpbsends rst step v rejects suppose sends vector y1yt1 2 zn t1ify representative de nition 64 either yi square mod n pair jsuch yiyj mod n square mod n either case corresponding nonresiduosity subproof fails probability 3 4 v rejects suppose representative proposition 65 implies xyi mod n square mod n corresponding nonresiduosity subproof fails probability 3 4 v rejects competitiveness p follows propositions 66 67 reason extend arbitrary n course number residue classes could general exponential length n polynomial time could even write representative list hand working proofs shows result extend case n n polynomial time computable function n whichis bounded abovebylglglgn lglgjnjfor simplicitywehave stuck case constant clearly weakness result promise n already product exactly odd primes may hard prove competitively one wants competitiveinteractive proof qr 7 open questions quadraticresiduositywe think interesting open question whether language quadratic residuosity competitiveinteractive proof conditional results subject would also interesting example could one show quadratic residuosity competitiveinteractive proof factoring reducible probabilistic polynomial time deciding quadratic residuosity note rmative answer last question would imply qr competitiveinteractive proof npproof via simple factorization witness reducing assumptions another open question whether one reduce assumptions required results particular one show language search reduce decision given p np even e ne could cryptographic assumptions existence oneway functions used establish existence languages ip dont competitiveinteractive proofs settings relationship decision search context optimization problems approximation algorithms search reduce decision setting example consider traveling salesman problem tsp let g denote weightof optimal tour weighted graph g suppose 1 constant suppose oracle satisfying g g g graphs g polynomial time procedure oracle access input g outputs tour g ofweight g perfect completenessaninteractive proof pv l said perfect completeness probability acceptance completeness condition 1 know language l possessing interactive proof also possesses one perfect completeness fgmsz language possessing competitiveinteractive proof also possesses competitiveinteractive proof perfect completeness one motivations question fact competitive proof special case quadratic residuosity section 6 possess perfect completeness zeroknowledgewe discussed open questions section 44 acknowledgments many people pointed us error hsi thank eric allender juris hartmanis jack lutz osamuwatanabe regard thank muli safra lance fortnow jack lutz helpful discussions silvio micali suggesting term competitiveinteractive proofs thank oded goldreich many helpful comments paper thank satish thate drawing attention results la mentioned section 2 finally thank pair anonymous referees manyvaluable comments paper r lecture notes complexity problems number theory limitations upward separation technique languages easier proofs improved bounds coherence checkability complexity decision versus search making zeroknowledge provers e cient theory average case complexity multiprover interactive proof systems removeintractability assumptions designing programs check work comments functional selfreducibility np hierarchy complexity promise problems applications publickey cryptography power multiprover interactive protocols completeness soundness interactive proof systems knowledge complexityofinter active proofs complexity classes without machines sparse sets npp exptime versus nexptime private communication decision versus search problems superpolynomial time complexityofparallel search achieving zeroknowledge robustly fast checkers cryptography personal communication structure polynomial time reducibility algebraic methods interactive proof systems anintroduction theory numbers natural selfreducible sets ip pspace private communication via beigel feigenbaum relative complexity checking evaluating tr ctr salil vadhan transformation interactive proofs preserve provers complexity proceedings thirtysecond annual acm symposium theory computing p200207 may 2123 2000 portland oregon united states minhhuyen nguyen salil vadhan zero knowledge efficient provers proceedings thirtyeighth annual acm symposium theory computing may 2123 2006 seattle wa usa liming cai david juedes existence subexponential parameterized algorithms journal computer system sciences v67 n4 p789807 december
kdd framework support database audit understanding data semantics reallife databases considered following audit perspective must help experts analyse properties actually hold data support comparison desired properties typical problem knowledge discovery databases kdd specified within framework mannila toivonen data mining consists querying theories eg theories approximate inclusion dependencies formalization enables us identify important subtask support database audit well generic algorithm next consider dream relational database reverse engineering method dream heuristics revisited within new setting b introduction interested understanding data semantics reallife databases process considered following audit perspective following sense must help experts analyse properties actually hold data support comparison desired properties research paper takes examples relational database audit assuming inclusion functional dependencies almost hold data capture socalled data seman tics called hereafter basic problem however framework applied kinds databases andor properties work done author sabbatical year department computer science university helsinki finland partly supported affrst association francofinlandaise pour la recherche scientifique et technique auditing databases important topic integrity constraints less explicited design time database may always hold given instance indeed recent data base management systems enable enforce important integrity constraints foreign keys cases assumed application programs enforce desired integrity constraints obviously always done reallife databases understanding data semantics databases crucial interest support maintenance evolution fact property holds instance used experts fix integrity violation data also lead explicit definition integrity constraint use builtin checking mechanisms improving knowledge encoded data semantics also useful semantic query optimization see eg 2 last least audit important preliminary step database reverse engineering process 5 design federated databases indeed solving basic problem provides raw knowledge needed start restructuring phase denormalized relational schema 13 auditing querying multiple theories auditing databases typical problem knowledge discovery databases kdd discovering knowledge databases seen process containing several steps understanding domain preparing data set discovering patterns eg dependencies postprocessing discovered patterns eg selecting dependencies become integrity constraints putting results use 8 semiautomatic iterative process often described using adhoc formalisms andor notations however general kdd framework proposed mannila toivonen 11 data mining consists querying socalled theory database wrt class patterns selection predicate defines interestingness audit supported queries relevant theories approach emphasizes humancentered process expert users precisely specify theories interested formulate queries learn properties really hold data contribution first specify auditing tasks within general kdd frame work basic problem formalized mining theories approximate inclusion functional dependencies see section 2 enables us identify important subtask support database audit ie querying intensionally defined collection dependencies generic algorithm guessandcorrect scheme introduced 11 good starting point evaluation queries sec tion 3 finally section 4 revisit heuristics constitute core dream reverse engineering method 1617 project equijoins performed application programs used support discovery relevant dependencies 2 formal framework database audit notations reader supposed familiar relational database con cepts suppose r relational database instance schema r relation belongs r defined relation name r set attributes relation r associated table r set tuples database extension r represents set tables r r projection table r x ty projection tuple following let z two subsets x functional dependency denoted r r z two relations associated tables r r j respectively let resp z subset attributes x dependency denoted r r j z true r written r 21 computing theories first introduce kdd framework mannila toivonen 11 given database instance r assume definition language l expressing properties data selection predicate q predicate q used evaluating whether sentence 2 l defines potentially interesting property r therefore mining task compute theory r respect l q ie set thl trueg possible consider generic algorithms compute theories following popular learning search paradigm reasonnable collection data mining tasks association rules sequential patterns data dependencies etc already carried using approach see 12 survey example 21 consider discovery dependencies hold database assume l 1 language inclusion dependencies consider q 1 satisfaction predicate let r instances r language functional dependencies predicate q 2 satisfaction predicate instance assume two following instances looking generic data mining technique key issue organize search space l sentences get safe pruning strategies safe means want miss interesting sentence wrt selection predicate simple idea define specialization relation l use levelwise algorithm compute thl specialization relation partial order general specific monotone specialization relation wrt q r words sentence satisfies q also general sentences fl satisfy q simple powerful generate andtest algorithm derived start general sentences try generate evaluate specific sentences evaluate sentences interesting given available information example 22 monotone specialization relation wrt inclusion dependencies defined follows instance given general sentences potential unary inclusion dependencies itera tion one consider longer attribute sequences assuming restriction functional dependencies fixed righthand side denoted b monotone specialization relation wrt functional dependencies reverse set inclu 5sion x r b 2 r instance general sentences whole set r lefthand side iteration one consider shorter lefthand sides selection predicate q 1 resp means rha bi f holds rhai shei holds safe pruning criteria obvious rhai shei hold rha bi f hold either discarded candidate generation step idea applies functional dependencies ab hold doe hold either might pruned alternating candidate generation candidate evaluation levelwise algorithm moves gradually specific interesting sentences already implemented inclusion functional dependency computation see 11 complexity analysis pointers related work provides best known algorithm discovery inclusion dependencies functional dependencies better algorithms available eg 9 however clear functional dependency discovery hard problem due inherent exponential complexity fact functional dependencies long lefthand sides less likely hold functional dependencies shorter ones problem scheme computation interesting sentences theory quite slow interesting statements far general sentences typical case functional de pendencies furthermore framework designed support basic audit task might consider important specificities kind application first one consider exact dependencies want study dependencies even case tuples violate constraints next expert user quite often interested tightly specified subsets dependencies hold instance heshe want dependencies involve given collection attributes finally quite often dependencies computed scratch ie either expert user already good knowledge constraints hold andor computation constraints already done previous state database motivates definition theories approximate dependencies querying approach intensionally defined theories use variation levelwise algorithm socalled guessandcorrect scheme 22 solving basic problem computing approximate dependencies inconsistencies database allowed defining q 0 ffi true iff error measure dependency lower equal userdefined threshold let us define error measure g inclusion dependency r instance r using g enables consider dependencies almost hold since gives proportion tuples must removed r get true dependency among several ways defining approximate functional dependencies instance r r one also consider minimum number rows need removed r dependency hold socalled g 3 error measure 9 example 23 assuming instances example 21 approximate inclusion functional dependencies given inclusion dependencies error functional dependencies error selection predicate q 1 resp q 2 modified denote approximate inclusion resp functional dependencies whose error lower equal usersupplied threshold desired selection predicates remain monotone wrt respective specialization relations one naive approach solve basic problem might compute theories approximate dependencies error thresholds store sql3 table query tables using available query languages typical approach many kdd applications interestingness patterns considered postprocessing phase pattern discovery mainly guided simple criteria like statistical significance error thresholds gives rise several problems size theories huge expert user interested dependencies might untractable compute whole theories also gives rise tedious postprocessing phases eg posteriori elimination redundancies motivates flexible querying framework support analysis tightly specified theories querying tightly specified theories happens priori small subsets languages dependencies l 1 l 2 interesting restrictions practical interest concern non trivial inclusion functional dependencies unary inclusion dependencies also various selection criteria attributes attribute data types application domain semantics guide definition restrictions example 24 continuing example 21 inclusion dependency like shei rhbi considered irrelevant corresponding domains e b respectively collection transaction identifiers f12g denote male female also application domain like relational schema restructuring clear functional dependencies interesting see section 4 fact expert users define restrictions possible define either contextsensitive restrictions definition l 1 l 2 means new selection predicates different views influence computation process efficiency less generateandtest scheme generation candidate dependencies make active use given restrictions notice refining language redefinition basic technique dependency discovery inductive logic programming systems socalled declarative linguistic bias definition see eg 7 typical audit process requires computation many related theories several theories dependency class needed depending dynamically evolving users interest also different theories different kind dependencies might useful obvious example audit referential integrity constraints one must consider inclusion dependencies whose righthand side sets attributes key ie special case functional dependency cope querying approach conceptual framework inductive databases recently emerged suggests elegant approach support audit generally data mining multiple theories 23 towards inductive databases inductive database database contains inductive generalizations data addition usual data 3 idea user query data properties data well behavior data wrt properties theories defined intensionally indeed realistic consider querying properties carried means queries materializations every properties eg data dependencies idea properties computed query evaluation time user asking specific ones however formulation query think every property formally schema inductive database r database schema qr collection patterns v set result values e evaluation function defines patterns occur data function e maps pair r element v r database r pattern qr instance r inductive database schema r consists database r schema r subset qr basic problem need two inductive databases associate database inclusion dependencies functional dependencies built schema choose evaluation functions respectively return g g 3 error measures previously defined stage manipulating inductive database r user think value er available pattern present set ie every dependency actually heshe send queries intensionally defined collections dependencies select dependencies fulfilling constraints example 25 continuing example 21 user might interested select ing inclusion dependencies instances r involve attribute ra lefthand side g error value lower 03 one expects sentence like rhc di f belongs answer definition concrete query language inductive databases scope paper however let us take ideas sqllike operator mine rule 15 propose two queries example 26 first part query specifies kind dependency one want mine second one begins keyword defines data mining performed intuition power sql used selection data part query introduced example 25 written follows mine inclusion dependencies ind select 13 lhsind 13 rhsind rs schema output table ind three attributes lhsind rhsind error correspond respectively lefthand side righthand side error measure inclusion dependencies given instances example 21 expect tuple hc denotes approximate inclusion dependency rhc di f belongs ind one search functional dependencies whose lefthand sides righthand side previously discovered inclusion dependency query might look like mine functional dependencies fd select 13 lhsfd 11 rhsfd schema output table fd also three attributes lhsfd rhsfd error obvious meaning given instances example 21 expect tuple denotes ef g belongs fd evaluating kind query provides information potential foreign keys gg actual objectrelational query languages used basis inductive database query languages however non classical optimization schemes needed since selections properties lead complex data mining phases deed implementing query languages difficult selections properties performed previously materialized collections optimizing kind query remains open problem properties like functional dependen cies however many inspiring ideas emerge current research association rule mining 3 3 guessandcorrect generic algorithm 11 provides generic algorithm start process finding thl initial guess l appears interesting basis query evalua tion consider set l closed downwards ie 2 fl definition true thl q border bds consists sentences generalizations socalled positive border bd none specializations called negative border bd gamma bd consists specific sentences bd gamma consists general sentences roughly speaking positive border collection sentences theory negative border set sentences example 31 assume collection maximal nontrivial inclusion dependencies ie positive border theory frha b di shg f ei rhci shei shei g negative border contains many nondependencies like rhai shei rhbi shei computing borders simple task general tractable sets data dependencies reallife business databases algorithm 31 guessandcorrect algorithm 11 given database r language l specialization relation selection predicate q initial guess closed generalizations algorithm outputs thl 1 e correct downward 2 c bd 3 c 6 4 5 n f 2 c j qr falseg 7 od 8 c 9 c 6 evaluation find sentences c satisfy q using 12 c bd gamma 13 od 14 output algorithm first evaluates sentences positive border bd removes interesting steps repeated positive border contains sentences satisfying q thus thl algorithm expands upwards evaluates sentences negative border evaluated yet adds satisfy q steps repeated sentences evaluate finally output q notice complexity point view selection predicate evaluated every sentence belongs border theory initial guess first part algorithm skipped second part starts candidate set c containing general sentences l get simple levelwise algorithm sketched section 21 discovery approximate functional inclusion dependencies database solved algorithm 31 given specialization relations introduced results complexity scheme found 11 discussed however clear better guess better algorithm efficient obtain good original guesses one fairly widely applicable method sampling take small sample r compute thl q use another obvious situation guess available new audit performed database dependencies preserved definitions schema level application programs also used produce guess 4 revisiting dream heuristics section revisits heuristics dependency discovery relational database reverse engineering given operational database aim database reverse engineering dbre process improve understanding data semantics support redefinition validated conceptual model dbre process naturally split two major steps 17 ffl eliciting data semantics existing system various sources information relevant tackling task eg physical schema dictionary data application programs especially expert users among things application programs might encode integrity constraints encoded schema level ffl expressing extracted semantics high level data model task consists schema translation activity gives rise several difficulties since concepts original model eg relational schema overlap target model eg entityrelationship model many works done conceptual schema less automatically derived hierarchical database network database relational database 1416 relational databases realistic assume functional dependencies foreign keys available beginning dbre process furthermore less make assumptions knowledge priori normalization attribute naming discipline etc cope reallife databases several works 181619 proposed independently fetch needed information data manipulation statements embedded application programs dream project 16 began study use equijoins support 3nf schema reverse engineering work extended cope denormalized schema 17 spirit 14 dream approach consider relational schemas translated conceptual schemas looking method used design key problems resumed follows identifying relevant objects application domain recovering structure objects eliciting links relationships objects process inherently iterative interactive part dependency discovery done automatically cope denormalized schemas 17 propose restructuring phase leads 3nf schemas according experts charge validation relation maps exactly one object application domain pur pose one find functional dependencies meaningful application domain conceptualized relations assuming primary keys known difficulty find nonkey attributes correspond identifiers objects application domain attributes constitute left hand side relevant functional dependencies involved approximate inclusion dependencies foreign keys matter fact one must support discovery hidden objects 10 even encoded 3nf schemas main contribution dream proposal explore attributes equijoins performed help discovery interesting inclusion functional dependencies restructuring purposes main result following heuristics ffl equijoins sets attributes embedded application programs used discover relevant inclusion dependencies ffl non key attributes inclusion dependencies good candidates lefthand side relevant functional dependencies heuristics obviously reduce number dependencies considered relevancy refers interestingness discovered dependencies restructuring process complete scenario considered 17 though following example carries intuition example 41 given empfcodenameteladdg deptfdepdirectoraddg dependencies 1 deptdirector empcode 2 empadd deptadd 3 code name tel add 4 tel add dependencies 1 3 seem relevant restructuring phase 2 4 integrity constraints dream heuristics rely assumption deptdirector empcode probably performed application programs pointing potentially interesting dependency 1 code candidate lefthand side potentially interesting functional dependencies deptadd empadd probably occur clear analyzing set equijoins application programs enables focus interesting inclusion dependencies furthermore helps fix integrity problems find eg rc se performed neither rhci shei shei rhci hold collection equijoins considered theory thl language equijoins sets attributes r q predicate says given equijoin performed r computing theories requires non trivial compilation techniques indeed even consider sql queries equijoins performed many ways nested unnested queries clause intersect operator etc collection valuable source information support maintenance application code well data semantics elicitation dream heuristics encoded queries inductive databases inclusion functional dependencies using selection criteria derived equijoin occurrences dream method claim completness discovered dependencies however appears combining different sources information compute guesses speed discovery complete collections 5 conclusions presented framework audit databases based kdd per spective emphasizes highlevel querying tools needed support expert analysis operational databases provides nice application domain ongoing research generic data mining tools inductive database management systems though brings solution concrete problems practical interest eg mining approximate dependencies must study typical audit tasks instance supporting elicitation referencial integrity constraints useful migrating old dbms recent one needs mine inclusion functional dependencies also support efficient search erroneous data finally seems interesting study relationship approximate inclusion dependency discovery measures similarity sets attributes eg 6 r conceptual database design entityrelationship ap proach discovering rules relational databases semantic query optimisation querying inductive databases case study mine rule operator reverse engineering relational databases extraction eer model relational database framework design evaluation reverse engineering methods relational databases machine learning 26 2 advances knowledge discovery data mining method translating relational schemas conceptual structures levelwise search borders theories knowledge discovery methods problems data mining extended entityrelationship object structures relational schemas new sqllike operator mining association rules usign queries improve database reverse engineering towards reverse engineering denormalized relational databases approach reverse engineering relational databases reconstruction er schema database applications cognitive approach tr
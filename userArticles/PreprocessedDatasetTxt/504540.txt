using acceptors transducers wish use given nondeterministic twoway multitape acceptor transducer supplying contents input tapes asking generate missing contents tapes provide algorithm assuring beforehand transduction always results finite set answers also develop algorithm evaluating answers whenever previous algorithm indicated finiteness furthermore algorithms used speeding simulation acceptors even used transducers copyright 2001 elsevier science bv b introduction paper study following problem assume given nondeterministic twoway multitape acceptor subset x tapes would like use longer acceptor receives input tapes instead kind transducer 15 chapter 27 receives input tapes x generates output set missing inputs onto tapes face following two problems problem 1 guaranteed given choice input strings tapes x set corresponding outputs always remain finite problem 2 cases problem 1 solved positively actual set outputs corresponding given choice input strings supported academy finland grant number 42977 appear theoretical computer science special issue third international workshop implementing automata wia98 preprint submitted elsevier preprint 18th january 2000 motivation studying two problems came string databases 3711 manipulate strings instead indivisible atomic entities databases interest example bioinformatics allow direct representation manipulation stored nucleotide dna sequences one base query language databases fixed set sequence comparison predicates example proximal system 5 would flexible allow userdefined string processing predicates well assume sqllike notation 1 chapter 71 query language one possible query string database might stated follows rev userdefined expression compares strings w 1 w 2 denoted variables x 1 x 2 say w 2 reversal w 1 query requests every string w 2 reversal string w 1 currently stored database table r note particular strings w 2 need general stored anywhere database query evaluation machinery must generate instead needed developed elsewhere 101117 logical framework query language framework accommodates expressions like rev multidimensional extension modal extended temporal logic suggested wolper 29 multitape acceptors studied exactly computational counterparts logical expressions given query database considered safe execution way evaluate answer finitely 1 pages 7577 one safe plan evaluating aforementioned query would follows string relation accepted rev multitape acceptor corresponding expression acceptor shown figure 1 strings w 1 table r output every string v end two problems stem safe evaluation plans problem 1 could infer rev set v always going finite every string w 1 could possibly appear r problem 2 turn finiteness every possible v ensured simulate rev eciently w 1 generate v corresponding studied elsewhere 917 chapter 44 solutions problem 1 used guide selection appropriate safe execution plans end section 12 presents problem automata also database theoretic terms one possible solution would restrict beforehand language string handling expressions rev one ensures finiteness definition say fixing x 1 input variable mapped output variable x 2 kind transduction 37 however logicbased data models 1 use transducers seems less natural acceptors concept information flow input output alien logical level interest query evaluation level must eventually also evaluate string database queries must infer acceptors used transducers perform inferred transductions thus face aforementioned problems rest paper organized follows section 11 presents acceptors wish use transducers section 12 formalizes problem 1 section 2 first reviews already known decidability presents algorithms give sucient conditions answering problem 1 armative section 3 presents explicit evaluation method acceptors algorithms accept answering problem 2 turn finally section 4 concludes presentation 11 automaton model let alphabet finite set characters fixed advance let denote set finite sequences characters let denote empty sequence kind let w denote concatenating n copies w usual shall study relations sequences strings drawn follows hand database theory often studies sequence database models taken conceptually infinite instead example 719222425 emphasis data given lists data items provided user conversely emphasis data given strings alphabet fixed beforehand database designer words approach fixes appropriate alphabet part database schema list approach considers part data instead however approach employed even managing list data 2 furthermore assume left right tape endmarkers define n th character given string w length z intuitively automaton model twoway multitape nondeterministic finite state automaton endmarkers similar devices studied example harrison ibarra 14 rajlich 20 formally ktape finite state automaton kfsa 11 section 317 chapter 31 tuple 1 finite alphabet explained number tapes 3 qa finite set states qa distinguished start state qa set final states set transitions form p c1 c k q p q qa 1 0 1 moreover require ensures heads indeed stay within tape area limited endmarkers configuration input form corresponds intuitively situation state p head scanning square number n tape containing string w hence say possible next configuration c p w1 n1 w k n k d1 k 1 interpreted read forward 1 means rewind tape read preceding square 0 stand still call tape unidirectional transition specifies direction 1 otherwise tape called bidirectional instead computation input w sequence config urations starts initial configuration c c j1 possible next configuration preceding configuration c j computation c accepting finite last configuration c f possible next configurations state c f belongs fa language la accepted consists inputs w exists accepting computation c note language kfold relation strings general case nondeterministic without loss generality assume transitions leave final states fa example introduce new iii figure 1 2fsa recognizing strings reversals state f qa set every state p previously fa every character combination c 1 c k transition leaving p add transition p c 1 c k 0 0 f way whenever computation would halt state p performs instead one extra transition unique new final state f halts instead often view transition graph ga nodes qa edges particular computation considered trace path p within ga starting node furthermore expedient restrict attention nonredundant state either path p state fa figure 1 presents 2fsa rev form b language accepted consists pairs string v reversal string u looping state ii finds right end bidirectional tape 1 without moving unidirectional tape 2 looping state iii compares contents two tapes opposite directions another often useful simplification following way detect mutually incompatible transition pairs kfsa locally consistent every consecutive pair c k r transitions satisfies condition ensures configurations pair indeed taken whether configurations ever occur computation quite another matter example tapes figure 1 locally consistent particular tape unidirectional locally consistent given path c 11 c k1 11 k1 c 12 c k2 12 k2 c 13 c k3 13 k3 ga construct input string tape allows p followed choose c ij otherwise example figure 1 w 2 eq 2 spells sequence transitions taken looping state iii harrison ibarra provide related construction deleting unidirectional input tapes multitape pushdown automata 14 theorem 22 rajlich 20 definition 11 allows reading head scan two adjacent squares time similar purposes nondeterminism allows us enforce definition 1 tape cost expanding size factor kfsa b state space q remembers character tape head add transition p c1 c k d1 k q transitions d1 k complete construction 12 limitation problem section introduces limitation problem 11 definition 3117 definition 33 concerning automata defined section 11 determine exists limitation n following property u 1 la case say satisfies finiteness dependency 21 dependencies special case functional dependencies database theory 1 section 82 intuitively finite representation conceptually infinite database table assures select rows table supplying values columns 1 k always receive finite answer way used safely declaratively string processing tool within string database model thus goal treat userdefined string processing operation another relation far database query language concerned transparency fact advocated forthcoming objectrelational database proposal 4 pages 4955 discuss elsewhere 12 overall string processing mechanism relates proposal could incorporated database management systems terms automata theory require input u 1 possible outputs v 1 v l l must remain finite set meant using acceptors transducers supply strings tapes 1 k acceptor ask produce us contents missing tapes k would accepted given known tape contents limitation problem determine beforehand whether computation always return finite result weber 2728 studied related question whether set possible outputs inputs given transducer remains finite maximal output length 2 solving limitation problem hardness limitation problem shown depend crucially amount bidirectional tapes problem shown elsewhere undecidable fsas two bidirectional tapes 11 theorem 5117 chapter 41 given turing machine 15 chapter 7 one write corresponding 3fsa two bidirectional tapes accepts exactly tuples u v w v w together encode sequence computation steps taken input u v w must read twice requiring bidirectionality asking whether satisfies 1 2 3 amounts asking whether total readtwice construction reminiscent representing valid computations given turing machine intersection two contextfree languages 15 chapter 86 shows also undecidable determine whether given finiteness dependency satisfied intersection relations denoted two given fsas even fsas bidirectional tapes 17 corollary 61 hand limitation problem becomes decidable restrict attention fsas one bidirectional tape 11 theorem 5217 chapter 42 intuitively unidirectional tapes first made locally con sistent eq 2 allows us construct contents concentrate sole bidirectional tape tape turn studied using extension wellknown crossing sequence construction 15 chapter 26 converting twoway finite automata classical oneway iii iii iii figure 2 crossing behavior 2fsa figure 1 finite automata method clearly impractical however therefore paper presents section 21 practical partial solution furthermore applies even cases involving multiple bidirectional tapes section 22 develops solution yield yet explicit limitation information example 3 2fsa rev figure 1 satisfies 1 2 2 1 limitation function reversal string longer string moreover decidable tape 1 bidirectional rev see limitation inference proceeds consider figure 2 exhibits crossing behavior rev tape 1 contains string ab example determining 2 1 involves checking every character written onto bidirectional output tape 1 paid reading something unidirectional input tape 2 well although payment may occur much later computation occurs tape 1 reread reverse turn seen automaton b produced crossing sequence construction noting loops b around repeating crossing sequence indicated figure 2 consume tape 2 well 2fsa rev also considered satisfy trivial finiteness dependency definition hand rev satisfy 1 2 21 algorithm determining limitation technique solving limitation problem given definition 2 based following two observations let l finiteness dependency question observation 1 accepts input w 1 w kl computation never visits corresponding right endmarker also accepts suxed inputs c hence cannot satisfy case observation 2 hand every accepting computation visits right endmarker output tapes way violate looping generating output onto output tape without consuming inputs time returning read squares input tapes however undecidability results mentioned beginning section indicate reasoning actual computations infeasible thus reason instead structure transition graph ga therefore instead observation 1 algorithm figure 3 merely tests path p start state final state never requires appear output tape whereas would suced show p ever traversed accepting computation b denotes boolean type values 0 false 1 true similarly algorithm figure 4 enforces stringent condition observation 2 every cycle l ga output tape advanced direction 1 must also move input tape direction 1 back opposite direction 1 tape acts clock eventually terminates potentially dangerous repetitive traversals l violates l failing condition must exist ga converse need hold repetitions l need necessarily occur accepting computation figure 6 presents loop seems first glance generate arbitrary many copies character onto output tape 2 seems move back forth input tape 1 however closer scrutiny reveals behavior fact impossible square tape 1 must first contain character order get state q later character b order get back state p making tapes locally consistent definition 1 catch impossible transition sequences including cases arise due demands contents unidirectional tapes hand figure 6 presents bidirectional tape 1 already locally consistent still im possible one bidirectional tape altogether crossing sequence construction alluded example 3 seen method detecting impossibilities eliminating consid eration unfortunately method kind general case stringent condition given enforced repeatedly deleting transitions justifiably argued take part loops kind mentioned observation 2 technique related analyzing inputoutput behavior logic programs 1626 analyze call graph given program component component however technique remains simpler automata restricted general logic programs function halting g transition graph ga kfsa xsubset 1 kb 2 1 k x 3 h g without transitions specify tape 4 b b h contains path state fa 5 end return b figure 3 algorithm testing observation 1 function looping gsubgraph ga kfsa xsubset 1 kb 2 h 1 hm maximal strongly connected components g 3 delete g transitions dierent components 4 1 5 tape j x winds direction 1 h 1 delete h transitions wind tape j b 7 loopingh x 8 else 9 tape 1 k x winds direction 1 h 12 end 13 return b figure 4 algorithm testing observation 2 function limited kfsa xsubset 1 kb 1 return haltingg x loopingg x figure 5 algorithm determining limitation b figure 6 loop cannot traversed repeatedly precisely edge deletions made algorithm figure 4 justified follows consider first call made main algorithm figure 5 every loop mentioned observation 2 must clearly contained component h entire transition graph kfsa transition two dierent strongly connected components cannot surely belong loop kind deletions step 3 therefore warranted b transition winds clock tape j selected current component h cannot belong loop kind either cannot traversed indefinitely often traversals namely wind input tape j eventually onto either endmarker tape j wound opposite direction transition h deletions step 6 therefore warranted well reasoning applied subsequent recursive calls reduced components h well assume inductively loops broken earlier calls could ones mentioned observation 2 formalizing reasoning shows algorithm figure 5 indeed correct follows theorem 4 let p let algorithm figure 5 return 1 1 satisfies 1 function proof let us assume c arbitrary computation input begin proving following two claims c correspond observations 1 2 c accepting every tape p r computation c takes transition requires tape j let otherwise h tape violates claim 5 c traces path ga state fa step 4 algorithm figure 3 sets violates assumption algorithm figure returns 1 thus proving claim 5 moves direction 1 times computation c assume contrary h violates claim 6 post fence two adjacent configurations c g c g1 c whenever tape direction 1 contrary assumption least l 1 fences posted consider hand two configurations c x c c color share state head positions tapes 1 l colors available recalling assumption tapes 1 p unidirectional therefore c must contain two configurations c x c color separated intervening fence consider sequence transitions transform c x c path l within ga l forms closed cycle tape heads 1 squares traversing l c x c shared common color let us see steps 3 6 algorithm figure 4 first delete transition belongs l cannot step 3 l belongs initially maximal strongly connected component cannot step 6 either l ever moves tape j x direction 1 must also move tape j opposite direction 1 well order return head onto square l hence l persists untouched end recursion step 9 presence transition l crosses fence c x c yields subsequently violates assumption algorithm figure 5 returns 1 thus proving claim 6 claims 5 6 combined proof theorem follows assume z la accepting computation c input z suces show w h l 1 every 1 h r tape head must cross every border two adjacent tape squares left right otherwise c would meet claim 5 claim 6 states turn c performs l crossings kind means tape p contains l squares first last reserved endmarkers leaving l 1 squares characters input string w h example 7 consider 2fsa rev figure 1 algorithm figure 5 detect satisfies 1 2 follows algorithm figure 3 returns 1 every path final state iv must contain iii 00 iv evaluating algorithm figure 4 proceeds turn follows first transitions one state another deleted step 3 leaving loops ii iii figure 7 division 2fsa figure 1 components around states ii iii depicted figure 7 components dotted transitions thus deleted step dashed loops turn deleted step 6 processing corresponding components therefore function eventually returns 1 well however theorem 4 provides rather imprecise limitation function compared one given example 3 hand algorithm figure 5 fails detect 2 1 detected example 3 looping state ii advances tape 1 without moving tape 2 seems therefore dangerous algorithm figure 4 intuitively rev first guesses nondeterministically string later verifies guess input example 3 crossing sequences examined see later checking state iii indeed reduces acceptable outputs finitely many one essentially limitation function theorem 4 suces whenever output tapes r limited unidirectional even 1 cannot verified algorithm figure 5 9 theorem 21 natural algorithm figure 5 ignored eects moving output tape pq1 pqr direction 1 theorem 8 let p1 pq bidirectional tapes pqr fsa let satisfy corresponding limitation function g theorem 4 proof consider proof theorem 4 assume claim 6 output tapes pq1 pqr made locally consistent definition new assumption introduces factor 2 r w modification original fencingcoloring construction shows accepting computation c input z advances output tape pqh path transitions taken c partitioned three subpaths klm l begins c x ends c share color contains transition crosses fence c x c however must also accept pumped inputs n w kj denotes string characters squares output tape head lands j excluded eect application eq 1 output tapes pq1 p r presence within l shows w hl hence fails observation 2 thereby proving modified claim 6 5 continues hold reasoned observation 1 theorem follows turning assessing algorithm figure 5 detect finiteness dependencies see successful least tapes unidirectional theorem 9 let nonredundant lfsa tapes unidirectional locally consistent let algorithm figure 5 return 0 1 k satisfy proof nonredundancy unidirectionality local consistency tapes imply eq 2 every path p ga always find accepting computation c input traversing p letting p subgraph ga caused algorithm figure 5 return 0 yields c whose existence violates along lines theorem 8 22 two variants limitation algorithm section explores two possible directions algorithm given section 21 could developed alter nonrecursive step 9 algorithm figure 4 tests strongly connected component h transition graph ga moreover h known shrinkable algorithm first direction enlarges set fsas finiteness dependencies verified hold relaxing test follows suppose h contained output tape j 1 k x wound reverse tape j x winds direction 1 h direction 1 delete h transitions wind tape j b else tape j 1 k x winds direction 1 h direction 1 delete h transitions wind tape j else tape 1 k x winds direction 1 h figure 8 enlarging additions algorithm figure 4 direction 1 forward direction 1 tape j used clock shrinking h similarly steps 57 head tape j cannot travel backwards forever must stop least left endmarker reached algorithmically direction leads replacing steps 510 algorithm figure 4 steps given figure 8 direction algorithm given section 21 developed constrain set fsas finiteness dependencies verified hold restricting test performed step 9 algorithm figure 4 require component h tested must transitions left call correspondingly modified limitation algorithm section 21 fastidious thus requires transitions deleted order verify example 10 calculations example 7 show 2fsa rev figure actually satisfy finiteness dependency 1 2 even fas tidiously one advantage fastidious verification ecient simulation explained section 31 rest section explains another ad vantage namely enables straightforward construction better explicit limitation functions generic one provided theorem 4 construction similar spirit van gelders analysis logic programs systems equations 26 except recurrences used instead let therefore satisfying finiteness dependency suitable limitation function would evidently auxiliary function f p limit character position output tape kj right endmarker encountered assumed state p qa input tapes unspecified input string length n designated output tape k j character h unspecified output string auxiliary functions turn obtained labeling transition graph ga suitable expressions follows expression state p qa maximum expressions transitions leave p leaves p graphically speaking one consider node p graph ga become labeled operator max applied arrows exit p expression transition expression state enters adjusted eects tapes question f otherwise branch eq 5 denotes case transition cannot apply virtue input tape head position n violating corresponding restriction value 1 warranted earliest possible position possibly appear graphically speaking shows construct expressions arrows maximized node p graph ga eq 4 fastidiousness guarantees labeling indeed yield function otherwise expression f p refers indirectly back change arguments n 1 n k however implies cycle c ga p back none input tapes 1 k moves exactly one direction turn means c could deleted fastidious limitation algorithm accordingly fastidious version algorithm figure 8 used instead labeling must include h 1 h l instead h also output tapes k1 kl may used deleting transitions k question thus output tape head positions might ones cannot repeat arguments expression hand dropping fastidiousness restriction altogether invalidate approach either makes dicult provide explicit counterpart eq 4 namely possible expression f p indeed refer back without changing arguments n 1 expressions f j eq 5 transitions still remain component containing state p even successful execution algorithm figure 4 however expressions also guaranteed increase h otherwise execution algorithm figure 4 would unsuccessful thus function f p still exist even though giving explicit expression dicult similar labeling technique suces even crossing sequence construction mentioned example 3 instead fastidious algorithm section 21 provided labeling performed relative resulting crossing sequence automaton instead original 17 chapter 52 example 11 labeling generate eq 3 example 10 proceeds follows applying eq 5 transitions leaving state iii leads f iii 00 iv f iii aa iii iii bb iii f iii appear eq 4 state iii namely f iii f iii 00 iv iii aa iii f iii bb iii f iii figure 9 bidirectional loop eventually ends last simplification solves recurrence found f iii 1 continuing similarly state ii leads eventually tight limitation function mentioned example 3 dierent possibility improving limitation algorithm given section 21 would take account directions also total amount tape movement instance current algorithms break loop like figure 9 input tape 1 question moves directions even though overall net eect movements 1 move one square forward therefore loop cannot execute indefi nitely calculating net eects recently studied 18 resulting algorithms dier significantly approach presented 3 evaluation limited answers inferring given k indeed satisfy given finiteness dependency want generate finite set outputs solve problem 2 problem known dicult general case let b 2fsa unidirectional input tape 1 bidirectional output tape 2 ask given input u produce output v problem equivalent whether b considered checking stack automaton accepts u 20 theorem 51 known either pspace npcomplete depending whether b part instance 6 problem al5 however additional information provides certain optimization possibilities straightforward way obtain evaluation algorithm convert output tapes readonly writeonce perform writing operations concurrently simulation nondeterministic control figure shows resulting algorithm simulations possible computations performed depthfirst order using stack algorithm maintains 1 j l extensible character array w j 0 l j holds contents tape squares output head k j al procedure simulate k 2 3 4 initialize stack contain 0 l 1 l l 5 nonempty l top element let 7 q fa 8 outputv 1 v l 10 else 13 pop top element 15 else d1 k e 1 e l l 19 21 else 23 end 24 end figure 10 algorithm using acceptors transducers ready examined computation c currently simulated figure 11 shows indices one simulation 2fsa rev figure 1 input tape 1 contains string ab whose reversal generated onto output tape 2 figure 10 enumerated 1 0 new starting pseudo transition 0 0 also assume section 11 final state fa outgoing transitions note alone guarantee algorithm figure 10 halts guarantees finitely many dierent outputs ever generated consider namely situation figure 12 2fsa rev figure 1 output tape 2 b iii state figure 11 simulating 2fsa figure 1 transducer input tape 2 b output tape 1 ii state figure 12 generating indefinitely long output 2fsa figure 1 used transducer opposite direction figure 11 input read tape 2 written onto tape 1 explained example 7 rev guessing nondeterministically possible output later verification input long guesses rev allowed make question answered adding extra conditions 1 j l branch 15 algorithm figure 10 w limitation function corresponding addition warranted currently simulated computation c j violates eq 6 wu 1 u k characters output onto tape k j case c must eventually rejecting hence discarded without ado l j bounded w stack always contain finitely many dierent configurations c transducer simulated input u transducer configurations c defined straightforward way extending acceptor configurations defined section 11 writeonce output tapes although stack represents configurations c implicitly reconstructed branch 10 algorithm figure 10 however configurations c still repeat transducer simulated also loop already known parts tapes without generating new output fortunately looping detected eliminated simply testing branch 15 algorithm figure 10 new configuration c new pushed stack yet occur stack standard way avoid repetition depthfirst search 23 chapter 36 also experimented comparing c new configurations c encountered far entire search conducted algorithm figure 10 current input u proved extremely inecient practice solved problem 2 developing halting variant evaluation algorithm figure 10 however solution suers two drawbacks drawback 1 value limitation function needed eq 6 estimate hopefully tightly depth ultimately rejecting output generating computations pruned could termed compiletime drawback limitation function must formed acceptor proposed possible transducer value required invocation simulation algorithm figure 10 drawback 2 whole stack must scanned repeating configurations c pushing new configuration c new algorithm figure 10 could turn termed runtime drawback adds loop checking overhead execution simulation algorithm figure 10 fortunately drawbacks alleviated considering inferred hold discussed remainder section 31 limitation algorithm succeeds consider first case inferred hold algorithm figure return 1 claim 6 proof theorem 4 shows every computation c selflimiting sense l j grow indefinitely thus eq 6 needed thereby alleviating drawback 1 alleviates also drawback 2 two occurrences c x c configuration c color definition proof claim shows c x c arise traversing closed loop l deleted algorithm figure 4 therefore modify algorithm mark transitions considers deleted algorithm figure 10 stop scanning stack soon recent marked transition seen holds even marking performed enlarged algorithm figure 8 reasoning shows another benefit fastidious variant algorithm figure 4 every transition gets marked therefore scanning stack longer required algorithm figure 10 suces unmodified case runtime loop checking overhead eliminated example 12 applying modified marking algorithm figure 4 2fsa rev figure 1 even fastidiously example 10 algorithm figure 10 rev generate reversal given string linear time respect length words choosing evaluation strategy leads optimal way perform string reversals note finally marking technique also speed simulation mfsas b still used acceptors transducers compute marking given modified algorithm figure 4 b 1 yields 1 use resulting stack scanning optimization strategy simulation b given input u 1 um marks identify transitions necessary look scanning stack repeating configurations simulation 32 outputs unidirectional another strategy related one developed section 31 works output tapes unidirectional finiteness dependency still holds fact longer inferred algorithm developed section 21 case proof theorem 8 shows halting still correct variant simulation algorithm figure 10 obtained adding branch 15 extra condition configurations c x c color sense proof may repeat within computation c path l transitions c x c advances unidirectional output tapes r c must rejecting would violate via observation 2 otherwise taking l c unnecessary c x c configuration reasoning provides loop checking discipline guarantees halting simulation algorithm case furthermore simulation also amenable stack scanning optimization technique developed section 31 variant algorithm figure 4 merely attempts mark every transition possibly instead trying test fail identifies cycles l cause color repeat marks used limiting stack scanning simulation conclusions studied problem using given nondeterministic twoway multitape acceptor transducer supplying inputs onto tapes asking generate rest developed family algorithms ensuring transduction always yield finite answers another family algorithms actually computing answers guaranteed exist addition two families algorithms provided way execute optimize simulation nondeterministic twoway multitape acceptors restricting amount work must performed runtime loop checking algorithms implemented prototype string database management system developed department computer science university helsinki 81213 r foundations databases datalog transducers foundation objectrelational databases third manifesto proximal database system e computers intractability guide theory npcompleteness regular sequence operations use database queries aql alignment based query language querying string databases translation evaluation alignment calculus reasoning strings databases reasoning strings databases declarative programming system manipulating strings implementing declarative string query language string restructuring introduction automata theory framework testing safety e finding paths right cost absolutely parallel grammars twoway finitestate transducers safety recursive horn clauses infinite relations extended abstract supporting lists data model timely approach artificial intelligence modern approach seq model sequence databases aqua approach querying lists trees objectoriented databases deriving constraints among argument sizes logic programs valuedness finite transducers lengths values finite transducer temporal logic expressive tr database language sets lists tables safety recursive horn clauses infinite relations valuedness finite transducers lengths values finite transducer reasoning strings databases artificial intelligence framework testing safety effective computability foundation objectrelational databases regular sequence operations use database queries sequences datalog transducers reasoning strings databases foundations databases introduction automata theory languages computation computers intractability aqua approach querying lists trees objectoriented databases implementing declarative string query language string restructuring supporting lists data model timely approach ctr matti nyknen esko ukkonen exact path length problem journal algorithms v42 n1 p4153 january 2002 gsta grahne raul hakli matti nyknen hellis tamm esko ukkonen design implementation string database query language information systems v28 n4 p311337 june
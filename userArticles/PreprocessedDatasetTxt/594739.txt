efficient window block retrieval quadtreebased spatial databases algorithm presented answer window queries quadtreebased spatial database environment retrieving quadtree blocks underlying spatial database cover quadtree blocks comprise window works decomposing window operation suboperations smaller window partitions partitions quadtree blocks corresponding window although block b underlying spatial database may cover several smaller window partitions bmath retrieved rather multiple times achieved using auxiliary main memory data structure called active border requires matholeftnrightmath additional storage window query size mathntimes nmath result algorithm generates optimal number disk io requests answer window query ie one request per covering quadtree block proof correctness analysis algorithms execution time space requirements given experimental results b introduction spatial data consists spatial objects made points lines regions rectangles sur faces volumes even data higher dimension includes time examples spatial data range locations cities rivers roads areas spanned counties states crop coverages mountain ranges etc increasingly finding way adaptations conventional databases use applications geographic information systems gis resource management space urban planning etc 9 22 many different representations spatial data see 20 21 overview interested representations based spatial occupancy spatial occupancy methods decompose space data drawn eg twodimensional space containing lines regions called buckets also commonly known bucketing methods traditionally bucketing methods grid file 19 bang file 13 lsd trees 17 buddy trees 25 etc usually applied points although applied types well four principal approaches decomposing space data drawn one approach buckets data based concept minimum bounding enclosing rectangle case minimum bounding rectangles objects grouped hopefully proximity hierarchies stored another structure btree 7 rtree 16 well variants r tree 6 example approach drawback hierarchies objects result disjoint decomposition underlying space problem object associated one bounding rectangle even though may also overlap portion bounding rectangle another object worst case means wish determine object associated particular point twodimensional space objects drawn eg containing rectangle rectangle database intersecting line line segment database may search entire database approaches based decomposition space disjoint cells mapped buckets common property objects decomposed disjoint subobjects subobjects associated different cell differ degree regularity imposed underlying decomposition rules way cells aggregated price paid disjointness order determine area covered particular object retrieve cells occupies moreover wish report objects overlap particular area may report object many times subobjects appear area first method based disjointness partitions objects arbitrary disjoint subobjects groups subobjects another structure btree partition subsequent groupings bounding rectangles disjoint level structure r tree 26 cell tree 15 examples approach drawback well rtree variants decomposition datadependent means difficult perform tasks require composition different operations data sets eg settheoretic operations overlay contrast remaining two methods also yielding disjoint decomposition greater degree dataindependence based regular decomposition space decomposed either blocks uniform size eg uniform grid 12 adapt decomposition distribution data eg quadtreebased approach makes use regular decomposition 24 former case blocks size latter case widths blocks maximal subject restricted powers two restriction positions example figure 1 shows quadtree block decomposition two square regions space contains rectangular subregion termed window delimited heavy lines blocks obtained applying regular decomposition square regions thereby repeatedly breaking four congruent blocks block either completely within window completely outside window window w window w underlying spatial database underlying spatial database figure 1 decomposition 12 theta 12 window b 13 theta 13 window maximal quadtree blocks uniform grid ideal uniformly distributed data quadtreebased approaches suited arbitrarily distributed data case uniformly distributed data quadtreebased approaches degenerate uniform grid albeit higher overhead uniform grid quadtreebased approaches lend settheoretic operations positions decomposition lines restricted thus much less variation operands operations thus ideal tasks require composition different operations data sets gen eral since spatial data usually uniformly distributed quadtreebased regular decomposition approach flexible window query spatial analog range query retrieves objects overlap space covered range x possibly z threedimensions coordinate values form window paper focus performing variant window query using regular decomposition quadtree window underlying database represented quadtree particular quadtree blocks bw make window used guide retrieval process variant query one retrieves quadtree blocks bu underlying database cover blocks make window ie bw query differs classical window operation described retrieves objects underlying database cover window instead blocks underlying database rationale using quadtree blocks window match quadtree decomposition underlying spatial database makes straightforward answer window query since direct correspondence window block overlapping quadtree blocks underlying spatial database answer window query union answers generated querying underlying spatial database maximal quadtree blocks comprising window serving individual queries variant viewed preliminary step retrieval objects retrieves blocks underlying database ie bu correspond window next step would process blocks bu extract relevant objects underlying database quadtree objects decomposed blocks contain disjoint step extracts relevant objects blocks may fact encounter objects eg region line object decomposed several blocks contains part region line object case step would eliminate duplicates simple matter see 2 4 rationale variant may wish use blocks ie bu input subsequent operation whose underlying representation also quadtree thereby facilitating composition several operations another way characterize variant somewhat like clipping operation using quadtree blocks make query window ie bw clip blocks make underlying database ie bu paper show retrieve quadtree blocks underlying database cover quadtree blocks comprise window particular describe method retrieves block b bu even though b may cover several blocks bw rest paper organized follows section 2 gives overview approach section 3 describes algorithm section 4 contains informal proof correctness algorithms block retrieval process analysis worstcase execution time space complexity given section 5 section 6 presents empirical results disk io behavior algorithm concluding remarks drawn section 7 2 overview approach window decomposition algorithm given 3 decomposes twodimensional window size n theta n feature space eg image size theta maximal quadtree blocks log log time set bw determined simply retrieve elements underlying spatial database overlap elements drawback algorithm many elements may retrieved example figure 2 algorithm would retrieve block p underlying spatial database four times maximal window blocks 1 4 8 10 assume underlying spatial database diskresident often speak operation retrieving block underlying spatial database disk io request means redundant disk io requests result 2 one solution keep track blocks already retrieved easy without additional storage see 2 discussion similar issue uniquely reporting answers spatial database r underlying spatial database window w figure 2 examples one window block retrieves block underlying spatial database problem using algorithm 3 process generating maximal blocks comprise window depends query window take consideration decomposition space induced underlying spatial database overcome problem generating retrieving covering block underlying spatial database achieved controlling window decomposition procedure use information blocks underlying spatial database already retrieved use approach based active borders 23 expense extra storage algorithm present performs task worstcase cpu executiontime complexity one 3 ie log log difference io cost new algorithm makes requests access underlying spatial database instead maxn 3 number quadtree blocks underlying spatial database overlap problem overcome via appropriate use buffering techniques however paper show avoid problem retrieving block underlying spatial database without relying buffering techniques window n number maximal quadtree blocks window general significance algorithm one 3 although window contains n 2 pixel elements worstcase cpu executiontime complexity algorithms almost linearly proportional quadratic window diameter independent factors important note retrieve blocks underlying spatial database use information partial relationship blocks eg containment overlap subset etc retrieve block underlying database identifier could could keep track blocks retrieved via hash table example avoid retrieving instead given spatial description window block say b spatial description b used retrieve blocks underlying spatial database spatially related b eg blocks contain contained b blocks underlying spatial database retrieved satisfy spatial relationship respect different window blocks order avoid retrieving block different window block processed maintain spatial analog hashtable mechanism achieved usage spatial data structure namely active border tailored match needs type spatial retrieval active border also viewed simulating spatial equivalent sortmerge list pages used database query processing accessing data secondary indexes 10 3 algorithm answering window query first computing maximal quadtree blocks comprising retrieving corresponding covering blocks underlying spatial database proceeds follows assume query window w spatial database query function f performs appropriate variant window query test eg containment test record type answer set accumulates answer window query answerset procedure algorithm1swf begin reference spatialdatabase value window w value function f block b block set c spatialobject set answerset result decompose w maximal quadtree blocks foreach block b w begin cblocks cover b foreach block q c apply f spatial objects associated q varying function f data type answer set many window operations implemented using algorithm1 example answer report query ie reporting identity features exist inside window function f simply identifies spatial objects inside block underlying spatial database data type answer set set spatial object identifiers qualifying objects answer exist query ie determining feature f exists w function f tests whether f f identifier exists inside block underlying spatial database data type answer set type boolean u logical operation answer select query ie reporting locations instances feature f window function f simply tests whether f f identifier exists inside block underlying spatial database data type answer set quadtree stores location blocks one principal issue implementing algorithm discussed section 2 corresponds situation block q underlying spatial database covers one maximal quadtree block window case q retrieved several times happens algorithm reported 3 could overcome avoiding invocation retrieval step maximal quadtree window blocks issue skip maximal quadtree window blocks order understand issue briefly focus relation maximal quadtree blocks window decomposition quadtree blocks underlying spatial database assume b maximal window block generated window decomposition algorithm due quadtree decomposition window underlying spatial database b either contained contain one quadtree blocks underlying spatial database particular three possible cases illustrated figure 2 case 1 demonstrated figure window block 2 contains one quadtree block underlying spatial database blocks retrieved eg disk processed algorithm eg spatial objects associated blocks reported intersecting window second case illustrated window block 9 figure 2 block 9 contains exactly one block underlying spatial database retrieved eg disk well third case demonstrated window blocks 1 4 8 10 figure 2 require retrieving eg disk quadtree block ie block p underlying spatial database case 3 arises frequently typical window query shown experiments conducted section 6 thereby resulting large number redundant disk io requests algorithm improvement algorithm1 based following observation restated lemma 1 well proved section 4 observation 1 assume block say b maximal block lies inside window w overlaps block underlying spatial database say q q greater size b q must intersect least one boundaries window w refer figure 3 illustration words cannot database blocks bigger intersecting window blocks middle query window big database blocks intersect boundary query window window retrieval algorithm based observation illustrate later section new algorithm consists procedures window retrieve gen southern maximal max block described detailed code given ap pendix algorithm works arbitrary rectangular window ie need square avoid generating nonmaximal quadtree blocks window least generate bounded number using technique 3 outline note 2 nonmaximal blocks inside n theta n window also maximal quadtree block window processed ie neighbor another node regardless size make use active border data structure 23 separator window regions already processed rest window note active border case differ conventional one looks like staircase nature block traversal process particular traverse blocks window rowbyrow manner rather quadrant order ie nw ne sw se figures 48 represent first five steps execution algorithm query window w heavy lines figure 4 represent active border window w initial stage algorithm generating new block window decomposer consult active border order avoid generating disk io request window region already processed block underlying spatial database already retrieved active border maintained follows first window block say b generated window decomposer disk io request issued access region underlying spatial database corresponding b assume b overlaps space block u underlying spatial database therefore u retrieved result disk io request corresponding b spatial objects inside u processed thus need retrieve u result active border needs updated block b u depending one provides coverage window region figures 48 illustrate updating process active border u larger overlap unprocessed portion window b eg window block 1 block p underlying spatial database figure 4 well window block 3 block q underlying spatial database active border expanded using us region figure 5 u contained b eg window block 2 block r underlying spatial database figure 4 blocks underlying spatial database retrieved well active border expanded bs region figure 6 sizes b u eg window block 12 block underlying spatial database figure 4 active border expanded either one figure 8 notice using algorithm1 window blocks 4 8 10 7 would still processed hence would generate four redundant disk io requests retrieve blocks p q generation maximal quadtree blocks inside given window controlled procedure window retrieve whose basic structure given figure 9 window retrieve scans window rowbyrow block domain rather pixel domain visits blocks within visited previous scans 3 visited window block say b underlying spatial database queried corresponding quadtree block say q retrieved database procedures gen southern maximal max block generate bs qs maximal southern neighboring blocks fact 3 observe could chosen scan window columnbycolumn fashion instead rowbyrow result unchanged long data structures keeping track active border reoriented appropriately portion q lies inside window used according three cases presented earlier section relate location size b q respect query window window retrieve also makes sure remaining columns row r lie within b q skipped example consider figure 2 five scans needed cover 12 theta 12 window maximal blocks first scan visits blocks 1 2 3 second scan visits blocks 12 5 6 9 remaining scans visit blocks 14 11 13 15 notice blocks 5 6 visited columns ie 25 window completely processed also observe block 1 generated block p underlying spatial database overlaps block 1 retrieved result window blocks 4 8 10 skipped way algorithm avoid reaccessing p skipping window blocks overlap p consequence southern neighbors p block 1 generated algorithm procedure gen southern maximal generates southern neighbors maximal blocks maximal block b generated window retrieve contained another maximal block number possible cases illustrated figure greater equal b otherwise total width blocks n 1 nm equal b impossible total length exceed b unless one neighbor see figure 10b procedure max block takes input window say w values x coordinates pixel say colrow returns maximal block w colrow upperleftmost corner resulting block width 2 maximum value 0 log theta size image space row mod point row lies inside w figure 11a gives active borders general form active border contain holes see lemma 1 section 4 thus figure 11b corresponds impossible situation block underlying spatial database say q retrieved algorithm checks size corresponding window block say b qs size larger b algorithm knows q intersect one windows boundaries see lemma 1 section 4 make use property figure 3 shows four possible cases block retrieved underlying spatial database intersects one window boundaries four cases must treated separately algorithm need maintain data structures explicitly store northern portion active border since window retrieve handle portion directly first rowbyrow scan window window retrieve block underlying spatial database say q retrieved happens intersect northern boundary window figure 3a window retrieve skips window blocks current row scan overlap q portion southern boundary q lies inside window used generate southern neighboring blocks processed next scan block q underlying spatial database intersects southern boundary window figure 3d also suffices window retrieve skip window blocks adjacent window block initiated qs retrieval although seems intuitive straightforward see processing block q window retrieve localized one part algorithm particular although true directly obvious blocks overlap q processed window retrieve time skipped thus result localized processing need maintain explicit data structures case either q intersects western eastern boundaries figures 3b 3c overlap window creates pocketlike region needs stored two separate lists westlist eastlist respectively time window block generated checked active border order make sure block covered previously retrieved block underlying spatial database show perform check constant time facilitate presentation represent westlist eastlist two onedimensional arrays length equal height window westlistr rngamma1 height window n r c corresponds x coordinate values upperleft corner figure 12b shows border represented two arrays result extracting 8 theta 12 window underlying spatial database figure 12a let r q c q location upperleft corner q q intersects west boundary window westlistr q set first component pair denotes x coordinate value qs east boundary second component ie q denotes size q pair represents pocketlike region resulting intersection q w similarly q intersects east boundary window eastlistr q set time window block generated checked active border order make sure block covered previously retrieved block underlying spatial database notice updating active border requires one array access either updating westlist eastlist depending whether q intersects west east boundaries window respectively checking window block active border takes two array accesses one access westlist eastlist therefore maintaining active border whether updating checking takes o1 time observe window retrieve always generates maximal neighboring blocks bounded number nonmaximal blocks example situation arises processing blocks aj first row window figure 13 blocks b generate one nonmaximal neighboring block even though nonmaximal blocks generated procedure window retrieve skips next scan since subsumed ie contained previously processed maximal block scan example scanning block k figure 13 blocks l n skipped since contained easy detect block know x coordinate values upperleft corner size proving algorithm correct involves showing every block underlying spatial database overlaps query window retrieved processed algorithm order prove structure algorithm following way algorithm consists two mechanisms one generating maximal quadtree blocks inside window also termed window decomposition algorithm retrieving blocks underlying spatial database maintaining active border active border keeps track blocks boundary window already retrieved guarantees block underlying spatial database retrieved strategy proving algorithm correct separate two mechanisms show one correct prove interact properly algorithm two cases first case arises quadtree blocks underlying spatial database overlap window smaller equal size smallest quadtree block window second case arises size criterion satisfied first case window decomposition algorithm generate maximal quadtree blocks inside window none skipped ie one causes block underlying spatial database retrieved words pockets thus arrays westlist eastlist never updated accessed means algorithm reduces window decomposition algorithm given 3 window decomposition algorithm proved correct 3 thus address however state proving window decomposition algorithm correct involves showing execution algorithm generates list maximal blocks lie entirely inside window cover point inside window words point inside window covered one maximal block generated execution algorithm following two theorems proved 3 theorem 1 point inside window covered one one maximal block generated algorithm theorem 2 window decomposition algorithm generates maximal blocks inside window maximal blocks hence correct address second case blocks underlying spatial database larger smallest block window ie blocks underlying spatial database whose sizes larger overlapping window blocks need show interaction maintenance active border window decomposition algorithm 1 guarantees every block underlying spatial database overlaps query window retrieved processed algorithm 2 interfere negatively window decomposition algorithm complexity point view prove section 5 every block underlying spatial database overlaps window retrieved first use concept maximal zone 3 facilitate presentation proofs assume window c r x coordinate values upperleft corner height w h ie direction width ww ie x direction first let us look x direction processing along width ww subdivide window p vertical strips coordinate values upperleft corner p defined c example decomposition vertical strips shown figure 14a vertical strips termed maximal columns subdivide window horizontal strips way particular q horizontal strips c r x coordinate values upperleft corner r r q defined r example decomposition horizontal strips shown figure 14b horizontal strips termed maximal rows define term maximal zones follows maximal zone say z ij region vertical strips ie maximal columns c c i1 xcoordinate values upperleft corner horizontal strips ie maximal rows r j r j1 ycoordinate values upperleft corner figure 14c gives example decomposing window maximal zones state propositions dealing properties maximal zones proofs straightforward omit interest brevity illustrated figure 14d proposition 1 maximal block inside window entirely contained one one maximal zone proposition 2 maximal blocks inside maximal zone size proposition 3 maximal zone contains either one maximal block one row maximal blocks one column maximal blocks proposition 4 southern neighbors block lie one maximal zone proposition 5 exists maximal column say c k inside window words sequence distances width maximal columns forms monotonically increasing sequence followed monotonically decreasing sequence equivalent property exists maximal rows useful invariant holds execution window decomposition algorithm also relates maximal columns stated invariant 1 maximal window block southern neighbor window blocks generated window decomposition algorithm always lie inside maximal column words blocks inside maximal column processed independently blocks maximal columns inside window put differently although algorithm scans window rowbyrow block domain generates maximal neighboring blocks south block encountered interaction blocks different maximal columns make use invariant prove lemmas lemma 1 assume block say b maximal block lies inside window w overlaps block underlying spatial database say q q greater size b q must intersect least one boundaries window w figure 3 proof contradiction since b overlaps q b smaller q b contained q definition quadtree decomposition space assume contrary database block q lies entirely inside w q greater size window block b overlaps b maximal block since use window block b 1 contains b coincides q new maximal block leads contradiction 2 result deal three categories blocks underlying spatial database intersect window boundary blocks intersect north boundary blocks intersect east west boundary blocks intersect south boundary notice algorithm treats blocks intersect west east south boundaries window intersect west east boundary hand treats blocks intersect north west east boundaries window intersect north boundary blocks intersecting east west boundary window receive type processing hence considered one group prove correctness interaction category separately lemma 1 means active border contain holes see figure 11b since query window scanned rowbyrow largesized blocks underlying spatial database intersect window boundary therefore storing outer boundary active border enough lemma 2a block underlying spatial database say q intersects west east window boundary east west boundary q lies inside window must coincide boundary one maximal columns window proof prove lemma case q intersects west boundary window case similar assume lemma hold ie q intersects window boundary eastern boundary q lies inside window coincide maximal column window therefore one two possible cases must occur illustrated figure 15 cases cannot happen since definition quadtree decomposition blocks cannot overlap manner 2 analogous lemma stated blocks intersecting north south boundary window lemma 2b block underlying spatial database say q intersects north window boundary south north boundary q lies inside window must coincide boundary one maximal rows window lemma 3 block underlying spatial database say q intersects west east window boundary part south boundary q say lies inside window must coincide north boundary maximal block inside window proof assume q intersects west boundary window lemma 2a qs east boundary coincides boundary maximal column window say c however maximal columns west c may intersect q well example figure 12 maximal column c 1 intersects block p underlying spatial database q intersects maximal columns c two cases possible illustrated figures 16a 16b figure 16a cannot occur quadtree decomposition figure 16b satisfies lemma q intersects one maximal columns c must coincide maximal row inside window figure 16c case cannot exist quadtree decomposition figure 16d since maximal row coincides north boundary maximal blocks across whole window applies q well 2 lemma 4 block underlying spatial database say q intersects west east window boundary window decomposition strategy skip window blocks covered q maintaining normal processing otherwise words updating active border q adversely affect mechanism used window decomposition proof assume q intersects west border window lemma 2a east boundary q coincides maximal column window therefore window decomposition mechanism function properly east q since invariant 1 block generation process works independently inside maximal column portion south boundary q say lies inside window used algorithm generate new window blocks south q however lemma 3 parts coincide north boundary maximal block inside window therefore applying maximal block computation algorithm would still generate maximal blocks window south q skipping ones inside q hence avoid retrieving q overlapping window blocks south boundary lies outside window lemma holds since processing south q needed addition invariant 1 window decomposition process east q affected q since east boundary q coincides maximal columnwe study case block underlying spatial database intersects south boundary window make use following lemma proof given 3 lemma 4 lemma 5 maximal blocks arranged row inside maximal zone processed iteration main loop procedure window retrieve lemma block underlying spatial database say q intersects south boundary window q lies entirely inside one maximal column window proof proposition 5 q overlaps one maximal column window either size q power two contradiction q must intersect east west boundary window contradiction therefore q lies inside one maximal column 2 combining lemmas 5 6 get following result lemma 7 block underlying spatial database say q intersects south boundary window window decomposition strategy skip window blocks covered q maintaining normal processing otherwise proof lemma 6 q lies inside one maximal column window lemma 5 one maximal window block say b results retrieving q rest window blocks maximal zone lie row b exist iteration main loop procedure window retrieve therefore automatically skipped algorithm q retrieved hence additional data structure needed record qs retrieval since south boundary q already outside window processing needed south q effect results skipping window blocks overlap q lie south b south boundary window also invariant 1 q lies inside one maximal column hence affect portions window decomposition mechanismlemma 8 block underlying spatial database say q intersects north boundary window window decomposition strategy skip window blocks covered q maintaining normal processing otherwise proof since q intersects north boundary window q retrieved algorithm scans first row window addition q retrieved leftmost maximal window block say b overlaps q since scanning left right therefore window blocks right b overlap q automatically skipped algorithm since immediately follow b toplist list blocks processed processing algorithm resumes first window block right q current row scan lemma 2b part qs south border say lies inside window coincide maximal row window since maximal row coincides north boundary maximal blocks across whole window applies well therefore using generate maximal blocks south q resume regular processing decomposition algorithm results generating legitimate maximal blocks window skipping window blocks overlap q therefore q retrieved algorithm without affecting normal processing algorithm 2 combining theorems 1 2 lemmas 4 7 8 get following theorem theorem 3 every block underlying spatial database overlaps query window retrieved procedure window retrieve hence algorithm correct proof theorem 1 maximal blocks window cover every point inside window without overlap therefore blocks underlying spatial database smaller window blocks theorem 2 window decomposition algorithm generate maximal blocks inside window hence blocks underlying spatial database overlapping window blocks retrieved blocks underlying database say larger corresponding maximal window blocks lemma 1 block say q intersect window boundaries lemmas 4 7 8 algorithm skip one maximal blocks window overlap q one maximal blocks retrieve q rest overlapping window blocks skipped lemmas 4 7 8 also show normal window decomposition mechanism resumed processing block underlying spatial database overlaps 5 complexity analysis based observation 1 restated lemma 1 relates size query window blocks size underlying database blocks intersect able restrict size active border worstcase space complexity instead 2 n theta n query window analyzing time complexity algorithm bit complex two processes going hence two ways measuring first terms blocks underlying spatial database retrieved io cost second terms maximal blocks window ie window decomposition mechanism maintenance active border cpu cost cpu cost process generating maximal quadtree blocks window computed follows first find number maximal quadtree blocks say n inside window compute cost generating one maximal quadtree blocks say gen overall cpu cost cpu product two terms ie important note usually maximal blocks inside window generated however worst case none blocks underlying spatial database intersect border window maximal blocks inside window generated known number maximal quadtree blocks inside square window size n theta n worst case 8 11 27 remains compute cost generating maximal quadtree block comprising window ie gen consists work say tm generate maximal quadtree block say b work wasted say tw generating southern neighboring blocks b nonmaximal therefore total cpu execution time window decomposition algorithm given point xy theta space log different blocks size 2 0 log xy upperleft corner use binary search set blocks determine maximal quadtree block inside window 3 thus tm olog log compute tw need show maximal quadtree block inside window generated limited number nonmaximal blocks generated say work required generate blocks maximal respect particular window wasted blocks ignored ie bypassed subsequent processing example work generating southern neighbors blocks b c f g h j ie l n p q r respectively figure 13 wasted formulated proved following two lemmas lemma 9 maximal quadtree block inside window w generated proof theorem 2 proved every maximal quadtree block inside window w generated algorithm show generated observe window block processed algorithm generates southern neighbors facts nonmaximal window blocks bypassed algorithm maximal blocks overlap mean maximal window block say b generated southern neighbor one maximal window block say c note worst case arises window retrieve generates maximal blocks ie none lemma 10 window block visited algorithm waste olog log work generating intermediate nonmaximal window blocks proof assume window block b generates wasted work show work takes olog log time b generate neighboring southern maximal blocks either smaller larger size neighboring block greater equal size b algorithm takes olog log whether wasted lemma holds one southern neighboring block generated number order size b need show generated southern blocks maximal cannot bypassed ie wasted work shall prove contradiction assume b generates one southern neighboring block bypassed ie visited subsequent processing clear due nature quadtree decomposition space either visited bypassed assumption means exists block c whose width greater total width bs southern neighbors let b x b c x c locations upperleftmost pixels blocks b c respectively also let b c widths blocks b c respectively easy see fact b c maximal blocks southern neighbors visited maximal blocks means c fact c b means lowerrightmost pixel c c x window therefore lowerrightmost pixel bs southern neighbor equal size say also window means bs neighboring southern maximal block however contradicts existence one block thus assumption southern neighboring blocks b bypassed invalid therefore work wasted generating bs southern neighbors case lemma holds 2 combining results tm tw theorem 3 means proven following theorem theorem 4 given n theta n window theta image worstcase cpu execution time algorithm log log order compute disk io execution time algorithm say io need prove following theorem theorem 5 every block underlying spatial database overlaps query window retrieved window retrieve proof lemma 9 maximal block generated let q block underlying spatial database suppose q overlaps window q lies inside window equal smaller size overlapping window block say b q retrieved algorithm b generated hence theorem holds notice maximal blocks overlap q overlaps window q contains one window block q retrieved first window block say b encounters q however point onwards window blocks overlap q skipped block q retrieved lemma 1 q intersect one window boundaries q intersects east west boundaries window lemma 4 active border ie westlist eastlist prevents block q retrieved remaining window blocks overlap q otherwise q intersects north south boundaries window lemmas 7 8 algorithm skips remaining window blocks overlap q therefore q retrieved hence theorem also holds q larger size overlapping window blocks 2 note onto relation set blocks underlying spatial database retrieved algorithm set maximal window blocks generated algorithm relation onto rather onetoone onto window block say b may overlap one block underlying spatial database ie overlapped blocks smaller b case several blocks underlying spatial database retrieved however retrieved actual disk io cost algorithm depends quadtree implemented assume underlying database consists total k quadtree blocks blocks retrieved window query assume spans space size theta pointerbased quadtree implementation may overall io cost high log must traverse log pointers access relevant block quadtree using pointerless quadtree representation linear quadtree eg 14 leaf block represented unique number stored tree overall io cost om log k cost retrieve block olog k 6 empirical results section study performance two algorithms algorithm1 based window decomposition algorithm 3 window retrieve proposed paper window decomposition part two algorithms worstcase execution time complexity ie log log shown section 5 result focus comparing io cost two algorithms figure 17 shows results experiments comparing number disk io requests ie blocks retrieved answer window query using algorithm1labeled old alg number disk io requests generated window retrieve labeled new alg data consists maps road network us provided bureau census sample map corresponding falls church containing 640 line segments given figure 18 maps represented using pmrquadtree 18 21 variant quadtree storing vector data xaxis corresponds ratio window area area underlying spatial database spanned 512 theta 512 image experiments run ratios 01 001 0001 00001 example ratio 00001 corresponds 5 theta 5 window ratio 01 corresponds 50 theta 50 window ratio set 500 randomly positioned rectangles generated window query processed rectangle using algorithms yaxis corresponds average disk io requests set rectangles plotted logarithmic scale surprisingly use window retrieve lead great reduction disk io requests small window sizes 25 since window corresponding area underlying database number blocks relatively small however larger size windows reduction much pronounced fact use window retrieve leads improvement one order magnitude eg factor 10 7 concluding remarks algorithm presented retrieving blocks quadtreebase spatial database environment overlap given window based decomposing window maximal quadtree blocks performing simpler subqueries underlying spatial database block underlying spatial database retrieved algorithm proven analytically experimentally lead improvement disk io performance algorithm requires extra space order width window store active border remains consider algorithm adapted handle spatial databases nondisjoint objects ie overlapping performance enhanced selecting suitable buffering strategy underlying btree 1 5 particular adjust scan order window algorithm window quadtree blocks visited morton order accompany mostrecentlyused buffer replacement policy would guarantee btree pages leaf nonleaf pages would requested algorithm hence redundant disk io requests would result clarification issue see 1 5 r algorithm cost model window queries spatial databases uniquely reporting spatial objects yet another operation comparing spatial data structures decomposing window maximal quadtree blocks hashing proximity process duplicates spatial databases multidimensional window retrieval large spatial databases ubiquitous btree space efficiency quadtrees advances spatial databases fourth international symposium fundamentals database systems analytical results quadtree decomposition arbitrary rectangles adaptive grids geometric operations bang file new kind grid file effective way represent quadtrees efficient structures geometric data management rtrees dynamic index structure spatial searching lsd tree spatial access multidimensional point nonpoint data consistent hierarchical representation vector data grid file adaptable applications spatial data structures computer graphics design analysis spatial data structures spatial data models query processing computing geometric properties images represented linear quadtrees storing collection polygons using quadtrees buddytree efficient robust access method spatial data base systems formula computing number quadtree node fragments created shift tr ctr ashraf aboulnaga walid g aref window query processing linear quadtrees distributed parallel databases v10 n2 p111126 september 2001
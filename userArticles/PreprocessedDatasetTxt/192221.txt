astoot approach testing objectoriented programs article describes new approach unit testing objectoriented programs set tools based approach two case studies approach test case consists tuple sequences messages along tags indicating whether sequences put objects class test equivalent states andor return objects equivalent states tests executed sending sequences objects class test invoking usersupplied equivalencechecking mechanism approach allows substantial automation many aspects testing including test case generation test driver generation test execution test checking experimental prototypes tools test generation test execution described test generation tool requires availability algebraic specification abstract data type tested test execution tool used formal specification available using test execution tools case studies involving execution tens thousands test cases various sequence lengths parameters combinations operations performed relationships among likelihood detecting error sequence length range parameters relative frequency various operations investigated priority queue sortedlist implementations subtle errors case long sequences tended likely detect error provided range parameters sufficiently large likelihood detecting error tended increase threshold value parameter range increased b introduction objectoriented programming based concepts data abstraction inheritance dynamic binding becoming increasingly popular software development methodology much research done developing objectoriented analysis design techniques developing objectoriented programming languages exploring methodology research supported part nsf grants ccr8810287 ccr9003006 new york state science technology foundation performed first author polytechnic university authors address department computer science polytechnic university 6 metrotech center brooklyn ny 11201 email phyllismorphpolyedu changes software development process yet relatively little research addressed question objectoriented programs tested developed new approach unit testing objectoriented programs based ideas natural units test classes testing classes one focus question whether sequence messages puts object class test correct state approach roughly speaking test case consists pair sequences messages along tag indicating whether sequences result objects abstract state test case executed sending sequence messages object class test invoking usersupplied equivalence checking routine check whether objects abstract state comparing result check tag testing scheme several nice properties ffl expected results tests included test cases concise format one boolean independent class tested facilitates automatic checking test results ffl test drivers different classes similar one another hence automatically generated class interfaces ffl algebraic specification class test available term rewriting used generate test cases automatically algebraic specification available person develop test cases reasoning informal specification approach embodied prototype testing system astoot set tools objectoriented testing includes interactive specificationbased test case generation tool tool automatically generates test drivers class c astoot automatically generate test driver turn automatically executes test cases checks results addition algebraic specification c available astoot partially automate test generation thus system allows substantial automation entire testing process current version astoot targeted testing programs written eiffel 1 throughout paper assume classes tested written eiffel ever underlying ideas tools adapted relatively easily objectoriented languages section 2 paper review relevant background material software testing objectoriented programming algebraic specification abstract data types section 3 describes ideas underlying astoot correctness class implements abstract data type test case format test result checking tools described section 4 section 5 describes two case studies performed order gain insight generate good test cases compare approach related work section 6 note directions future work section 7 1 eiffel trademark nonprofit international consortium eiffel nice background 21 background software testing testing one timeconsuming parts software development process increased automation testing process could lead significant saving time thus allowing thorough testing three aspects testing process could potentially least partially automated test data generation test execution test checking approach testing objectoriented programs involves three areas perhaps obvious opportunity partially automating testing generation test cases order automate test generation necessary analyze formal object source code formal specification research automated test generation involved programbased whitebox techniques ie techniques based analysis source code program tested however whitebox testing suffers certain limitations inability generate test cases intended exercise aspects specification inadvertently omitted program blackbox specificationbased techniques based analysis programs specification overcome limitations cannot automated unless kind formal specification available manual blackbox test generation techniques based informal specifications widely used practice testing scheme described paper blackbox approach automatable formal algebraic specification available applied manually otherwise another area potential automation construction test drivers many testing methods applied individual subprograms program unit tested whole program inputs outputs usually sets files unit tested procedure function inputs outputs may include values parameters global variables well values read written files order test procedure necessary build driver program initializes global variables actual parameters appropriate values calls procedure outputs final values relevant globals parameters quite cumbersome initialize inputs check values outputs particularly unwieldy often case objectoriented programming parameters complicated types model described testing objectoriented programs circumvents problem another problem arises testing software oracle problem running program p test case necessary check whether result agrees specification p often nontrivial problem example great deal output difficult calculate correct value 30 testing method uses novel approach allows correctness test cases checked automatically test execution system 22 overview objectoriented programming objectoriented languages support abstract data types inheritance dynamic binding abstract data type entity encapsulates data operations manipulating data objectoriented programming programmer writes class definitions implementations abstract data types object instance class created dynamically instantiation operation often called new create language supports inheritance classes organized directed acyclic graph definitions shared reflecting common behavior objects related classes class consists interface lists operations performed objects class body implements operations state object stored instance variables sometimes called attributes static variables local object classs operations sometimes called methods objectoriented programs computation performed sending messages objects message invokes one objects methods perhaps arguments invoked method may modify state object andor send messages objects method completes execution returns control cases returns result sender message inheritance mechanism objectoriented languages facilitates development new classes share aspects behavior old ones descendent subclass c class c inherits instance variables methods c c may extend behavior c adding additional instance variables methods andor specialize c redefining cs methods provide alternative implementations dynamic binding mechanism used associate methods objects strongly typed objectoriented languages legal assign object class c variable class c viceversa message sent object invoke method associated class c example consider class polygon subclasses triangle square redefines polygons perimeter method assigning object class square variable class polygon sending perimeter message invoke squares perimeter method allows construction polymorphic data types examples objectoriented languages include smalltalk c eiffel 13 29 27 ada modula2 strictly speaking objectoriented languages provide support data abstraction thus ideas discussed relevant see 27 overview objectoriented approach 23 algebraic specification abstract data types talk test class c must concept means c correct thus must means formal informal specifying entity c intended implement stating conditions implementation conforms specification case c intended implement abstract data type algebraic specifications provide formal means algebraic specification syntactic part semantic part syntactic part consists function names signatures types take input produce output algebraic specification type functions return values types called observers provide ways us query contents functions return values type called constructors transformers 2 2 transformers called extensions 16 distinction constructors transformers clarified semantic part specification consists list axioms describing relation functions specification techniques allow list preconditions describing domains functions others allow functions return error values indicating function applied element outside domain rewriting 24 used define formal semantics algebraic specifications 28 12 two sequences 1 2 operations adt equivalent use axioms rewrite rules transform 1 2 3 specification modeled heterogeneous word algebra elements equivalence classes sequences operations specification useful must consistent sufficiently complete 16 consistent specification must contain contradictory axioms ie contradiction derivable operation sequences specification let w set containing operation sequences consisting constructors transformers sufficiently complete every sequence w w result applying observer w defined discussion construct useful algebraic specifications found 14 15 1 algebraic specification languages use functional notation convenience designed specification language lobas whose syntax similar oo programming language syntax 6 syntactic part lobas specification includes export section lists operations available users adt lobas designer specification classify operations three categories constructors transformers observers classification process helps designer producing sufficiently complete specification facilitates test generation scheme described section 42 additional advantage notation pointed section 31 algebraic specifications priority queue lobas functional notation shown figure 1a figure 1b sequences operations separated dots read left right example createadd5add3 represents result creating priority queue adding items 5 3 order according specification createadd5add3delete equivalent createadd3 apply axiom 6 twice give createadd5add3delete createadd3 difference constructors transformers becomes clear point simplification complete constructors left operation sequence role transformers transform sequence constructors another sequence constructors note appearance operation sequences lobas bears strong resemblance trace specifications data abstractions specifying legality equivalence values traces operation sequences 3 20 21 two advantages trace specifications 3 definition follows assumption goguen 11 guttag 18 makes opposite assumption ie two sequences may assumed equivalent unless provably inequivalent specification lobas class priority queue export create largest add delete empty eqn constructor create add x integer transformer delete observer empty boolean largest eqn b priority queue boolean var axiom 2 3 createlargest 4 aaddxlargest gamma alargest x else alargest 5 alargest else adeleteaddx 7 aempty bempty true else aempty bempty aempty bempty false else alargest blargest adeleteeqnbdelete else false b specification functional notation type priority queue add priority queue theta integer delete priority queue gamma priority queue largest priority queue gamma eqn priority queue theta priority queue declare semantics 1 2 3 4 else largesta 5 else adddeleteax 7 emptya emptyb true else emptya emptyb emptya emptyb false else largest else false figure 1 specifications priority queue lobas ability specify functions observers side effects ability handle operation sequences intermingled procedures functions however axioms lobas algebraic languages facilitate automatic test case generation discussed section 42 3 selfchecking test cases section describe main concepts underlie astoot include notion correctness classes model test cases execution test checking mechanism one early papers specification data abstractions 25 liskov zilles pointed possible specify data abstraction specifying intended inputoutput behavior operations individually usually cumbersome may lead overspecification underlying representation data instead others 11 14 17 proposed algebraic specifications abstract data types adts define intended behavior adt giving axioms describing interaction operations similarly possible test class testing methods individually treating function mapping input space output space selecting elements input space examining outputs see correct however shifts focus testing away essence data abstraction interaction operations furthermore testing method individually necessitates construction complicated drivers output checking mechanisms example test case add operation priority queue would consist priority queue item output would another priority queue thus driver would initialize input priority queue checking output would entail examining output priority queue see correct result contrast approach testing classes focuses interaction operations section restrict attention classes intended implement adts require 1 operations side effects parameters 2 functions observers side effects 3 functions observers appear last operation sequence 4 sequence passed parameter operation must contain functions observers main reason placing restrictions 1 2 cannot specify kinds side effects using either lobas purely algebraic languages reason behind restriction 3 sequences mix functions procedures syntactically valid lobas algebraic specification languages26 restriction 4 makes easier generate test cases using astoot note restriction 4 hinder ability express test cases involving parameters operation since function f side effects target object object message sent target object sequence sf observationally equivalent target object techniques relaxing restrictions restrictions 2 3 4 discussed 6 31 correctness adt implementation consider class c intended implement abstract data type function corresponds method c inputting value type function corresponds sending message object class c eiffel constructors transformers typically coded procedures rather explicitly returning object class c procedure returns value modifying state object ap plied observer coded function explicitly returns object another class refer object function procedure message sent target object object returned returned object procedures target object returned object though typically value target object changed procedure call notice addition explicitly returning object function also implicitly returns target object function side effect free value target object unchanged function call syntax lobas unlike functional syntax algebraic specification lan guages allows us differentiate target returned values example sequence createadd5add3largest final value target priority queue whose elements 5 3 returned value 5 say objects 1 2 class c observationally equivalent ffl c builtin class 1 2 identical values ffl c userdefined class sequence operations c ending function returning object class c 0 1 observationally equivalent 2 objects class c 0 thus 1 observationally equivalent 2 impossible distinguish 1 2 using operations c related classes two observationally equivalent objects abstract state even though details representations may different example consider circular array implementation firstinfirstout fifo queue two arrays containing elements order would observationally equivalent queues even though elements could occupy different portions underlying arrays define notion correctness underlies approach class c correct implementation adt signaturepreserving mapping operations c ffl pair 1 sequences operations 1 equivalent 2 corresponding sequences messages give rise observationally equivalent returned objects words onetoone correspondence abstract states abstract states c preserves transitions abstract states note based definition returned object definition correctness demands operation sequences consisting entirely constructors transformers give rise observationally equivalent target objects operation sequences ending observers return observationally equivalent objects notions correctness corresponding specification methodologies also investigated 3 11 18 8 definition based observational equivalence similar corresponding trace specifications 3 based limited algebraic specification methodology pragmatic intuitively appealing one lends convenient testing strategy 32 test case format definition correctness gives rise natural way framework testing infinite amount time way check whether two objects observationally equivalent could exhaustively test class c follows ffl consider set u consisting 3tuples 1 sequences messages tag equivalent 1 equivalent 2 according specification notequivalent otherwise ffl element u send message sequences 1 2 objects 1 2 c respectively check whether returned object 1 observationally equivalent returned object 2 ffl observational equivalence checks agree tags implementation correct otherwise incorrect unfortunately neither infinite amount time testing foolproof way checking observational equivalence nonetheless scheme suggests approach testing demand c class returned function c include method called eqn approximates observational equivalence checker select elements u test cases addition shifting emphasis testing functionality individual methods notion state approach testing facilitates automation many aspects testing process note elements u viewed selfchecking test cases test case includes information form tag describing expected result execution furthermore format expected result single boolean concise independent particular class tested pair sequences executed facilitates automated execution checking test cases course generating test cases necessary consider specification adt order derive tags either done semiautomatically manipulating formal specification described section 4 manually reasoning formal informal specification example consider priority queue integers whose functions described informally follows create creates empty priority queue add adds integer priority queue delete removes largest element priority queue largest returns value largest element priority queue without modifying contents priority queue empty determines whether priority queue empty reasoning informal specification person generate test cases 1 createadd5add3deletecreateadd3equivalent 2 createadd5add3deletelargestcreateadd3largestequivalent 3 createadd5add3deletecreateadd5notequivalent 4 createadd5add3createadd3add5equivalent test case 1 says createing empty priority queue adding 5 3 applying delete creating empty priority queue adding 3 test case 2 says objects returned applying largest two priority queues equivalent test case 3 says create empty priority queue add 5 3 delete create empty priority queue add 5 test case 4 says priority queue obtained adding 5 adding 3 observationally equivalent one obtained adding 3 adding 5 unlike previous three test cases test case captures aspect informal specification expressed formal specification thus cannot derived formal specification using term rewriting 4 indicates even formal specification partially describes intended semantics adt available manual generation additional test cases may useful refer test cases consisting pair sequences along tag restricted format test cases general test case formats useful testing classes involving side effects dynamic binding introduced 6 33 eqn method discuss eqn operation ideally eqn operation class c check whether two objects 1 2 class c observationally equivalent check whether sequence messages ending observer yields result sent 1 sent 2 since clearly impossible send every message sequence objects practice eqn approximate check observational equivalence 4 axiom aaddxaddy aaddyaddxwere added specification aspect informal specification would captured however resulting specification would longer satisfy finite termination condition often quite easy produce recursive version eqn specification c intended implement example axiom 7 figure 1 specifies eqn function based priority queue specification note actually approximation true observational equivalence neglects possible effects building priority queues removing elements thus might say two objects equivalent 5 also since eqn calls largest delete error one operations may propagate eqn causing mask error hand error propagation also help error detection demonstrated section 51 another approach developing eqn function write implementation level approach eqn based detailed knowledge data represented manipulated class body example knowing fifo queue represented linked list one traverse two lists comparing elements general sufficient attention paid details representation eqn implement observational equivalence exactly hand possible misconceptions lead implementation errors cs methods may lead errors eqn furthermore representations data structures writing implementationlevel eqn operation may extremely difficult errorprone even methods relatively simple also sometimes possible use coarse approximation observational equivalence eqn function example might consider two fifo queues equivalent number elements front element version eqn may consider two inequivalent objects equivalent naturally using coarser approximation observational equivalence lead less accuracy test results bernot et al 4 discuss closely related problem suggest oracle hypothesis explicitly stated context approach testing hypothesis would describe conditions implementation eqn equivalent actual check observational equivalence 4 tools astoot set tools based approach described section 3 current prototype handles test cases restricted format three components driver generator compiler simplifier driver generator takes input interface specifications class test cut related classes outputs test driver test driver executed reads test cases checks syntax executes checks results compiler simplifier together form interactive tool semiautomatically generating test cases algebraic specification note algebraic specification available drivers produced driver generator 5 example consider implementation completely empties priority queue whenever total number adds performed reaches particular number n 2 recursive eqn would consider o1 createadd1add2delete equivalent o2createadd1 fact performing additional adds followed deletes object would leave o1 empty leave o2 nonempty used execute test cases derived person reasoning informal specification structure astoot illustrated figure 2 screen dump astoot session shown figure 4 41 driver generator approach testing leads relatively simple test drivers operate reading test cases form 1 one time checking sequences syntactically valid sending sequences 1 2 objects 1 2 cut comparing returned objects 1 2 eqn checking whether value returned eqn agrees tag hand drivers complicated enough writing manually tedious errorprone task particular checking syntactic validity operation sequences involves complicated parsing type checking example driver priority queue class 400 lines code counting inherited classes deals checking syntax operation sequences luckily drivers testing different classes similar one another structure allowed us write tool driver generator automatically generates test drivers drivergenerator viewed specialpurpose parser generator based syntax described class interfaces generates test drivers parse test cases well executing checking driver generator dg operates three phases first phase collect information interfaces cut ancestors classes parameter types return types cuts operations dg first checks whether classes exported eqn operation 6 like eiffel implementation language facility selective export let eqn exported test driver integrity implementation preserved second phase dg builds test driver class implementation language current version driver generator targeted eiffel 21 underlying ideas applied oo languages third phase dg compiles executes test driver test cases supplied user 42 test generation tools astoots test generation component two parts compiler simplifier based internal representation called adt tree compiler reads specification written lobas syntactic semantic checking specification 7 translates axiom pair adt trees adt tree tree nodes represent operations along arguments path root leaf adt tree represents possible state adt branching adt tree arises axioms else expressions right 6 astoot access functions hidden implementation cut export functions test driver generated astoot eiffel achieved selective export test driver c achieved making test driver friend class cut 7 simplifier driver generator operate assumption create instantiation operation compiler makes sure constructor named create specification also simplifier insist first operation sequence create operation simplifier oe driver generator compiled axioms compiler test driver source compiler driver original sequences implementation cut algebraic specification cut cases figure 2 components astoot figure 3 screen dump astoot session upper left window shows execution test generator batch mode priority queue specification file pqseq contains initial sequence supplied user test generator generates five test cases based initial sequence writes along corresponding constraints free variables file pqsim constraint test case obtained conjoining condition test case negations conditions previous test cases upper right window shows four test cases user developed instantiating free variables values satisfy constraints first generated test cases unsatisfiable constraint eliminated user driver generator invoked incorrect implementation priority queue described section 51 invokes eiffel compile class test generates test driver class compiles executes given test cases first two test cases detect bug second two lower left window shows small portion test driver automatically generated driver generator void addxm alargest alargest figure 4 axiom 6 priority queue adt tree form hand side edge adt tree boolean expression called edge condition attached path condition path root leaf conjunction edge conditions path indicates conditions operation sequence path equivalent original sequence path conditions given tree mutually exclusive figure 4 illustrates adt tree pair axiom 6 figure 1 clarity edge conditions shown rectangles figure implementation parameters operations operands boolean expressions represented adt trees simplifier inputs operation sequence supplied user translates adt tree applies transformations obtain equivalent operation sequences process simplification follows 1 search axioms find axiom lefthand side matches partial path adt tree ignoring edge conditions 2 axiom found bind variables axiom proper arguments partial path adt tree simplify arguments replace partial branch righthand side axiom 3 repeat steps 1 2 matching axiom worst case adt tree arising sequence operations may paths maximum number branches axiom deal complexity current prototype operate either batch mode builds entire equivalent adt tree interactive mode allows user selectively guide construction particular path tree order simplifier work properly set axioms specification must convergent ie axioms must properties finite unique termination 28 property finite termination ensures process simplification go infinite loop property unique termination makes sure two terminating sequences starting operation sequence results matter choice made axiom rewrite axiom apply first qk void create create addy create void qk void create delete addy figure 5 simplification sequence createaddxaddydelete example involving batchmode simplification sequence createaddxaddy delete priority queue shown figure 5 simplifier generate test cases form createaddxaddydelete createaddx equivalent path condition x createaddxaddydelete createaddy equivalent path condition x note simplifier also suggests test cases notequivalent tags instance exchange path conditions test cases get following test cases createaddxaddydelete createaddx notequivalent constraint x createaddxaddydelete createaddy notequivalent constraint x adt tree n paths simplifier generate n test cases equivalent tags principle simplifier could also generate nn gamma 1 test cases notequivalent tags n om length original sequence maximum number branches axiom many cases adt tree current version simplifier leaves selection test cases user note test cases generated simplifier contain symbolic values make acceptable test driver user resolve path conditions constraints instantiate symbolic values corresponding actual values principle could sometimes done automatically constraint solving system current prototype constraint solving left user two important questions remain one select original sequences input simplifier one select paths resulting adt trees order increase likelihood exposing errors 5 case studies gain insight kind original sequences person using test generation tools select kind paths adt tree generated interactive mode performed two case studies involving generating many tests buggy priority queue implementation buggy sortedlist implementation choose priority queue adt knew sufficiently complicated exhibit many interesting phenomena purposely introduced bug believe one could easily occur practice sortedlist based 23 tree implemented graduate algorithms class bug slight variation one actually occurred program development wished gain insight following questions length original sequence affect likelihood test case detect error selection parameters operations original sequence affect likelihood test case detect error ratio adds deletes original sequence affect likelihood test case detect error addressed questions randomly generating executing several thousand test cases various original sequence lengths various ranges parameters could lie various frequencies occurrence different operations original sequence generated corresponding simplified sequence executed test case original sequence simplified sequence equivalent note would extremely difficult execute check many test cases astoots selfchecking test case concept 51 testing buggy implementation priority queue case study cut priority queue implemented using heap bug delete operation 8 specifically downheap sift operation performed delete offbyone error causes sometimes fail swap bottom row erroneous delete code shown appendix 8 recall heap complete binary tree node greater equal children heap implementation priority queue delete operation performed removing root replacing rightmost leaf sifting element proper position ka original b correct c incorrect figure illustration buggy priority queue figure 6 heap resulting sequence createadd5add4add3 add2add1 b heap resulting applying correct delete c resulting heap incorrect delete applied note 1 failed swap 2 bottom row discussed section 33 since eqn calls delete bug delete propagated eqn even though original sequence test case createadd5add4add3 produces incorrect heap figure 6c eqn reports original sequence simplified sequence equivalent due bug delete thus case error masked propagation bug delete eqn hand consider test case createadd4add3add2add1 deletecreateadd3add2add1equivalent original sequence produces heap 3 root 1 roots left child 2 roots right child simplified sequence produces heap 3 root 2 roots left child 1 roots right child two heaps correct observationally equivalent however checking executing eqn check observational equivalence call erroneous delete routine first call delete original heap 2 root 1 left child incorrect heap resulting simplified sequence 1 root 2 left child one call largest compares roots eqn reports two sequences equivalent bug detected thus case propagation error eqn helps error detection order carry case studies needed generate tens thousands test cases principle could done using astoot test case generator randomly generating original sequences symbolic values parameters sending original sequence simplifier generate test cases would give o2 test cases original sequence operations test case would symbolic values constrained path condition corresponding path realistic would randomly choose test cases would randomly instantiate symbolic values test case actual values satisfy constraint test case either manually aid constraint solver note number test cases needed experiments several orders magnitude larger number test cases one would typically use practice test implementation size order generate huge number test cases efficiently broad range testing three variables p r test set r used c program randomly generate test cases actual values three variables rather using astoot test generator c program consists three modules first module generates original sequences one time according three parameter r number operations excluding create original sequence parameter add integer range r ratio adds deletes appearing original sequences operations original sequence read second module one time applied priority queue implemented list third module inspects contents list generates simplified sequence outputs appropriate test case note simplified sequences generated test case generator astoot instantiated real values satisfy constraints test set generated 1000 test cases average number adds simplified sequences approximately 8 results priority queue case study percentages test cases expose bug test set shown figure 7 inspection graphs shows large values p parameter range long original sequences better short ones however parameter range small longer original sequences may worse shorter ones fact results test sets r 100103 r 100106 r 100109 worst respectively despite fact long original sequences p parameter range p increases test cases tend get better however case appears threshold error detection probability levels likelihood exposing error depends somewhat r buggy implementation failure occurred necessary swap rightmost element bottom row heap apparently long sequences potentially likely cause object enter state either application original simplified sequences propogation error eqn operation however simply using long sequence without regard parameters chosen could lead objects never got interesting states range parameter values small many duplicates heap item deleted less likely sifted item strictly smaller elements compared thus less likely supposed swap bottom row number operations range parameters p c e s103050ffl phi phi phi range parameters p c e s103050ffl omega omega omega omega pi range parameters p c e s103050ffl omega omega omega omega omega pi range parameters p c e s103050ffl omega omega omega omega pi figure 7 results testing priority queue using randomly generated test suites sorted list without duplicated elements class sorted list export create add delete nb elements find eqn constructor create create empty list addx integer x list add x list proper order transformer deletei integer nb elements delete ith element observer nb elements integer number elements list findi integer integer return value ith element eqn sorted list boolean equivalent list figure 8 specification sorted list 52 testing buggy implementation sorted list second case study used abstract data type sorted list integer six operations create add delete find nb elements eqn interfaces preconditions informal specification sortedlist shown figure 8 eqn operation compared lengths lists compared elementbyelement note use formal specification sorted list test cases generated using c program similar one case study priority queue sorted list implemented using 23 tree special case btree implementation approximately 1000 lines eiffel 21 code buggy version produced deleting one particular line correct version implementation absence statement affects state 23 tree following situation occurs 1 node figure 9a three children first child ff three children second child fi third child fl two children 2 one fls children deleted c incorrect44 b correct original figure 9 illustration buggy 23 tree example deleting 6 fl 23 tree figure 9a correct procedure 1 copy 5 fi fl 2 delete 5 fi 3 copy 3 ff fi 4 delete 3 ff line missing buggy version step 4 procedure illustrated figure 9 deleting 6 get 23 tree c priority queue case study test sets randomly generated various original sequence lengths various parameter ranges various ratios adds deletes original sequences contained create add delete operations simplified sequences contained create add operations results sorted list case study results shown figure 10 exhibit similar phenomena discussed priority queue example since number elements sortedlist equal range parameter values long sequences operations large range parameter values produce 23 trees large number leaves error program failure occurs deletion performed 23 tree particular kind state apparently 23 trees large number leaves likely enter state number operations range parameters p phi phi phi range parameters p theta theta theta theta theta theta theta theta phi phi phi pi range parameters p phi phi phi range parameters p figure 10 results testing 23 tree using randomly generated test suites 53 discussion case studies case studies intended provide insight effects factors length original sequence relative frequencies different operations original sequence range parameters operations case studies results showed long original sequences better short ones provided range parameters large enough take advantage length addition different ratios adds deletes original sequence gave different results certainly want overgeneralize two small examples however seems safe say potential relative values parameters would important apparent specification cases specification involved comparison items using less operator thus reasonable expect different orderings parameters added would lead different states might likely others expose error hand testing stack queue adt would expect particular parameters would matter testing set adt would expect number duplications important would necessarily expect relative order parameters important unless course set implemented using adt based comparison 23 tree another phenomenon noticed different ratios adds deletes led different probabilities error detection ratio one unlikely objects grow large course testing examples small objects apparently usually complicated enough excite failure offer following tentative guidelines generate test cases ffl use least long original sequences variety relative frequencies different constructors transformers ffl specification conditional axioms comparison operators choose variety test cases original sequence various parameters chosen large range equivalently choose variety different paths adt tree arising original sequence guidelines might seem obvious previous research suggested limiting complexity sequences 9 5 10 ignoring semantics specification 23 22 6 related work compare approach related work testing data abstractions previous systems generally fall one two categories test execution tools test generation tools contrast approach gives rise test generation test execution tools 9 gaudels group suggests using relatively simple sequences including regularity hypothesis asserting simple sequences length less n give correct outputs complex sequences results interpreted saying regularity hypotheses hold adts examined small n similar observations lead gaudel et al introduce additional uniformity hypotheses 61 test execution tools one first systems address question testing data abstractions daists data abstraction implementation specification test uses axioms algebraic specification provide oracle testing implementations adt test case tuple arguments lefthand side axiom daists executes test case giving input lefthand side righthand side axiom checks output invoking usersupplied equality function similar eqn test execution tool considered generalization daists example recall axiom 6 priority queue specification shown figure 1 says alargest else adeleteaddx executing daists test case axiom equivalent test case createadd1add2add3deletecreateadd1add2 equivalent second sequence obtained using axiom 6 rewrite first sequence however daists analog test cases form 1 2 notequivalent significant ramifications even exhaustive testing daists may fail detect error results two states erroneously combined single state extreme example consider erroneous implementation none operations change state object two sides axiom return state input thus error detected second distinction daists approach daists requires availability formal specification test execution tools ie drivers produced driver generator used informal specification available second case study hoffman et al 21 19 developed several test execution tools abstract data types based tracespecifications 3 recent system protest consists two subsystems 1 protest1 tests c implementation using test cases containing expected output 2 protest2 compares behavior c implementation usersupplied oracle written prolog test case protest1 5tuple trace expexc actval expval type trace sequence operations puts adt state expexc exception raised trace actval observer expval expected value applying observer state type data type actval expval protest2 values expexc expval generated prolog oracle written user protest program written prolog executes test cases calling operations implementation test interface supplied user operation interface defines prolog predicate calls corresponding c function implementation user also needs write functions called construct objects userdefined classes passed parameters operations implemen tation like astoot daists protest uses functions supplied user check equivalence objects corresponding adts unlike astoot daists use specification test generate expected outputs protest2 uses prolog oracle produce expected outputs oracle another program needs tested another distinction approach using eqn function check outputs effect combine many protest test cases single test case hand protests handling exceptions certainly important idea would like try incorporate future versions astoot antoy hamlet 2 proposed system compares class implementation abstract representation based term rewriting derived directly specification user supplies explicit representation function mapping concrete representation abstract representation code instrumented check diagrams corresponding method commute ie applying representation function abstract analog method gives rise abstract state equivalent one obtained applying method applying representation function system would cases give accurate checks correctness would approach using approximation observational equivalence eqn function compare concrete representations however imposes programmer highly nontrivial task writing correct representation function 62 test case generation two previous approaches generating test cases algebraic specifications reported gaudels research group 4 5 10 developed general theory testing based testing contexts triples consisting set hypotheses program set test data oracle approach nice property established hypotheses hold test set exposes errors program guaranteed correct course establishing hypotheses nontrivial task involving analysis program text approach provides test data oracles furthermore oracles appear simple uniform format interesting direction future research would extending approach include hypotheses perhaps deriving conditions one sequence pair used represent class sequence pairs conditions one instantiation parameters used represent class instantiations gaudels group also built tool testing data abstractions based theory testing contexts tool inputs specification written dialect prolog based definition complexity sequences uses prolog interpreter generate sequences operations given complexities sometimes subject additional constraints approach might provide useful means generate interesting original sequences simplifier jalote et al 23 22 suggest effective test cases generated syntactic part algebraic specification without reference semantics experience tools indicates fact important consider semantic part well since different instantiations arguments sequence corresponding different paths adt tree lead profoundly different abstract states specification thus necessary select many different paths adt tree arising given original sequence equivalently choose values parameters exhibit different relationships one another phenomenon demonstrated case study priority queue failure occurred necessary swap bottom row heap 7 conclusion described new approach testing classes places emphasis fact classes implementations data abstractions set tools based approach two case studies approach test case consists tuple sequences messages along tags indicating whether sequences put objects classundertest equivalent states andor return objects equivalent states test case restricted format consists single pair sequences tag indicating whether two objects resulting application sequences observationally equivalent tests executed sending sequences objects classundertest invoking usersupplied equivalence checking mechanism approach allows substantial automation many aspects testing including test case generation test driver generation test execution test checking astoot set tools based approach astoot consists tool automatically generates test drivers class interface specifications tool semiautomatically generates test cases algebraic specification class test drivers generated astoots driver generator automatically execute check test cases supplied either test generator manual generation consequently astoot allows substantial automation entire testing process performed two case studies one using buggy implementation priority queue using buggy 23 tree implementation sorted list case studies provided insight effects factors length original sequence relative frequencies different operations original sequence range parameters operations approach tools described paper assume specification implementation satify several restrictions limit kind sideeffects operations may several extensions basic model intended make testing scheme applicable realworld objectoriented programs rather pure abstract data type implementations described elsewhere 6 7 include general format test cases allows testing classes whose methods side effects dynamic format allows testing virtual classes observations impact inheritance testing directions future research include following ffl interface test generator constraintsolving system order decrease need manual intervention test generation ffl perform additional case studies including exploration complicated adts implentations larger variety errors particular errors case studies tended exposed number duplicate elements sequence insertions low easy envision errors opposite would true much experience needed order develop better intuition kind test sequences generated arbitrary classes unknown errors ultimately intuition incorported heuristics guide selection initial sequences paths adt trees thus enhancing test generator ffl explore whether various strategies involving picking special values parameters inserting elements ascending descending order help hinder ffl develop specification languages better able express aspects objectoriented programming sideeffects inheritance dynamic binding building tools based ffl explore impact inheritance testing focused far unittesting also many interesting questions pertaining systemtest objectoriented software hope address questions future ultimately use results expand improve astoot acknowledgments authors would like thank dan hoffman anonymous referees several useful suggestions r systematic design algebraic specifications automatically checking implementation formal specification using assertions traces write abstract specifications software modules software testing based formal specifications theory tool test data generation using prolog constraints approach testing objectoriented programs case studies testing objectoriented programs theory modules generation test data algebraic specifications initial algebra approach specification introducing obj3 abstract data types development data structures notes type abstraction version 2 algebraic specification abstract data types extensions algebraic specifications abstract data types software valida tion module test case generation trace specifications methodology models automated module testing prolog testing completeness specifications automated testcase generation data abstraction simple word problems universal algebras specification techniques data abstractions formal method abstract specification software abstract data type specification affirm system testing nontestable programs tr smalltalk80 language implementation formal method abstract specification software theory modules trace specifications testing completeness specifications systematic design algebraic specifications c programming language 2nd ed case studies testing objectoriented programs automated module testing prolog software testing based formal specifications approach testing objectoriented programs objectoriented software construction 2nd ed data abstraction implementation specification testing abstract data types development data structures abstract data types software validation extensions algebraic specifications ctr merlin hughes david stotts testing oo programs presence sideeffects acm sigsoft software engineering notes v21 n3 p5361 may 1996 david kung jerry gao pei hsia yasufumi toyoshima chris chen youngsi kim youngkee song developing objectoriented software testing maintenance environment communications acm v38 n10 p7587 oct 1995 mauro pezz michal young testing object oriented software proceedings 26th international conference software engineering p739740 may 2328 2004 amit paradkar interclass testing oo software presence polymorphism proceedings 1996 conference centre advanced studies collaborative research p30 november 1214 1996 toronto ontario canada labiche p thvenodfosse h waeselynck mh durand testing levels objectoriented software proceedings 22nd international conference software engineering p136145 june 0411 2000 limerick ireland roy patrick tan stephen h edwards experiences evaluating effectiveness jmljunit testing acm sigsoft software engineering notes v29 n5 september 2004 donald j yantzi james h andrews industrial evaluation log file analysis methodology proceedings 5th international workshop dynamic analysis p4 may 2026 2007 ugo buy alessandro orso mauro pezze automated testing classes acm sigsoft software engineering notes v25 n5 p3948 sept 2000 pei hsia xiaolin li david c kung augmenting data flow criteria class testing proceedings 1997 conference centre advanced studies collaborative research p9 november 1013 1997 toronto ontario canada daniel hoffman jayakrishnan nair paul strooper testing generic ada packages ape acm sigada ada letters vxviii n6 p255262 novdec 1998 ashok sreenivas panel discussion testing research relevant industrial users acm sigsoft software engineering notes v27 n4 july 2002 daniel hoffman durga prabhakar paul strooper testing iptables proceedings conference centre advanced studies collaborative research p8091 october 0609 2003 toronto ontario canada richard denney comparison modelbased algebraic styles specification basis test specification acm sigsoft software engineering notes v21 n5 p6064 sept 1996 james h andrews yingjun zhang broadspectrum studies log file analysis proceedings 22nd international conference software engineering p105114 june 0411 2000 limerick ireland johannes henkel amer diwan tool writing debugging algebraic specifications proceedings 26th international conference software engineering p449458 may 2328 2004 juei chang debra j richardson structural specificationbased testing automated support experimental evaluation acm sigsoft software engineering notes v24 n6 p285302 nov 1999 taewoong jeon hyon woo seung sungyoung lee embedding builtin tests hot spots objectoriented framework acm sigplan notices v37 n8 august 2002 gilles bernot laurent bouaziz pascale le gall theory probabilistic functional testing proceedings 19th international conference software engineering p216226 may 1723 1997 boston massachusetts united states david chays saikat dan phyllis g frankl filippos vokolos elaine j weber framework testing database applications acm sigsoft software engineering notes v25 n5 p147157 sept 2000 willem visser corina psreanu radek pelnek test input generation java containers using state matching proceedings 2006 international symposium software testing analysis july 1720 2006 portland maine usa james h andrews yingjun zhang general test checking log file analysis ieee transactions software engineering v29 n7 p634648 july qing xie atif memon designing comparing automated test oracles guibased software applications acm transactions software engineering methodology tosem v16 n1 p4es february 2007 pei hsia xiaolin li david c kung class testing codebased criteria proceedings 1996 conference centre advanced studies collaborative research p14 november 1214 1996 toronto ontario canada lijun hong zhu testing software modelling tools using data mutation proceedings 2006 international workshop automation software test may 2323 2006 shanghai china huo yan chen h tse f chan chen black white integrated approach classlevel testing objectoriented programs acm transactions software engineering methodology tosem v7 n3 p250295 july 1998 james h andrews susmita haldar yong lei felix chun hang li tool support randomized unit testing proceedings 1st international workshop random testing july 2020 2006 portland maine huo yan chen h tse chen taccle methodology objectoriented software testing class cluster levels acm transactions software engineering methodology tosem v10 n1 p56109 jan 2001 mary jean harrold testing roadmap proceedings conference future software engineering p6172 june 0411 2000 limerick ireland nikolai tillmann wolfram schulte parameterized unit tests acm sigsoft software engineering notes v30 n5 september 2005 willem visser corina psreanu sarfraz khurshid test input generation java pathfinder acm sigsoft software engineering notes v29 n4 july 2004 issa traore demissie b aredo enhancing structured review modelbased verification ieee transactions software engineering v30 n11 p736753 november 2004 axel van lamsweerde formal specification roadmap proceedings conference future software engineering p147159 june 0411 2000 limerick ireland n robinson suzanne pawlowski vecheslav volkov requirements interaction management acm computing surveys csur v35 n2 p132190 june
equalitybased flow analysis versus recursive types equalitybased controlflow analysis studied henglein bondorf jrgensen defouw grove chambers others faster subsetbased0cfa also approximate heintze asserted 1995 program safety checked equalitybased controlflow analysis typed recursive types article falsify heintzes assertion present type system equivalent equalitybased controlflow analysis new type system contains recursive types unusual notion subtyping unfold regular tree bottomttop function type particular nontrivial subtyping function types b introduction controlflow analysis done determine approximate sets functions may called call sites program paper address instance question question flow analysis relate type systems focus 1 equalitybased controlflow analysis studied henglein 9 bondorf jrgensen 3 defouw grove chambers 5 others 2 recursive types example present restricted form java 6 form recursive interfaces equality subtyping based names rather structure equalitybased controlflow analysis simplification subsetbased controlflow analysis 16 11 8 use abbreviations subsetbased controlflow analysis equalitybased controlflow analysis 0cfa also known simply 0cfa illustrate difference 0cfa 0cfa considering analyze call site e 1 e 2 functional program suppose xe function program want flow analysis express xe becomes result evaluating e 1 flow relations established actual argument e 2 formal argument x 2 body e call site e 1 e 2 subsetbased analysis flow relations subset inclusions models values flow actual argument formal argument body function back call site equalitybased analysis flow relations equations thus flow information actual formal argument forced flow information body call site also forced intuitively equations establish bidirectional flow information 0cfa approximate 0cfa implemented many times various purposes general functional objectoriented languages 0cfa executed cubic time programs finite types 0cfa executed quadratic time 8 specific floworiented questions identify functions called one call site answered linear time 8 comparison 0 cfa always executed almostlinear time 9 one 0cfa 0 cfa better choice practice language like ml 10 functions finite polymorphic types data may recursive types experiments heintze mcallester 8 indicate good choice use 0cfa implemented variant quadratictime algorithm 0cfa treated data much simplified way problem pointer analysis algorithms close cousins 0cfa 0cfa 17 problem condition finite types hold general shapiro horwitz 15 presented experimental comparison two algorithms confirms theoretical conclusion 0cfa faster approximate 0cfa objectoriented language like java condition finite types seldomly satisfied example binary methods 4 defouw grove chambers 5 experimentally compared family flowanalysis algorithms whose time complexities cubic time 0cfa variants well comparison ashley 2 also presented flow analysis time complexity less cubic time remains open relates 0cfa bondorf jrgensen 3 implemented 0cfa 0cfa scheme part partial evaluator similix scheme condition finite types hold general concluded two analyses comparable precision application 0cfa much faster summary 0cfa experiments proved preferable alternative 0cfa many applications flow analyses 0cfa formulated using constraints see example 11 14 approach proceeds two steps 1 derive flow constraints program text 2 compute least solution constraints least solution desired flow information precision analysis stems choice constraints example one choice leads 0cfa another choice leads 0cfa kind flow constraints used example paper 11 always admits least solution turn flow analysis predicate accepts rejects programs extending safety constraints example call site e 1 e 2 functional program safety constraint might express flow information e 1 denote safety constraints always solution derived program text like flow constraints means flowbased safety analysis program two steps 1 derive flow safety constraints program text 2 decide constraints satisfiable safety analysis performs task akin type inference sense safe like typable palsberg okeefe 12 showed program safety checked 0cfa typed amadio cardellis type system subtyping recursive types 1 proof connection makes explicit close relationship flow subtyping heintze asserted 1995 7 program safety checked 0cfa typed recursive types assertion reasonable says intuitively replace subset inclusions equalities need subtyping disappears heintzes assertion also consistent observation 0cfa type inference recursive types executed almostlinear time perhaps surprisingly heintzes assertion false example consider term variable f applied number 0 function xx thus term type type system recursive types subtyping still based safety analysis accepts program assigning f g empty flow set see section 2 details another example consider term reminds bit previous example f applied a0 bxx term e 2 type type system recursive types subtyping conservative flow analysis cannot assign empty flow set f flow set least contain y0 still 0cfa based safety analysis accepts program assigning flow set contains a0 bxx given heintzes assertion false left two questions 1 type system corresponds 0cfa 2 controlflow analysis corresponds recursive types palsberg okeefes result 12 implies e 1 e 2 typed recursive types amadiocardelli subtyping result also seem indicate adding recursive types amadiocardelli subtyping match 0cfa would overkill thus answer first question makes sense ask much subtyping necessary sufficient match 0cfa answer second question must ask restrictions 0cfa must impose match recursive types paper answer first question give partial answer second question show program safety checked 0cfa typed recursive types unusual restriction amadiocardelli subtyping unfold regular tree function type particular nontrivial subtyping function types see nontrivial subtyping function types required match 0cfa consider program xee 0 let hxi flow variable binding occurrence x let xee 0 xe flow variables occurrences xee 0 xe e e 0 respectively map flow variables flow sets satisfies 0cfa constraints particular satisfies also use hxi variables type system simple types nontrivial subtyping function types get among others following constraints type correctness unification gives typing must satisfy constraints thus get form relationships types flow sets allow nontrivial subtyping function types constraints type correctness become 12 particular opens possibility nontrivial relationship hence constraints closely related flow constraints used 0cfa 12 also show program safety checked certain restriction 0cfa typed recursive types restriction 0cfa flow sets must nonempty consistent consistency means two functions xe ye 0 occur flow set flow sets x equal also flow sets e e 0 equal sloganform results read tiny drop subtyping recursive types key understanding second result empty flow sets flow sets two inconsistent functions counterparts type system recursive types restricted version 0cfa fully match recursive types program may type flow set exists next section present heintzes definition 0cfa section 3 present new type system section 4 5 prove results example language calculus defined grammar succ denotes successor function integers equalitybased controlflow analysis given term p assume p ffconverted bound variables distinct different free variables let varp set bound variables p let x p set variables consisting one variable hxi x 2 varp let p set variables disjoint x p consisting one variable occurrence subterm e p notation ambiguous may one occurrence e p however always clear context occurrence meant set absp set occurrences subterms xe p set clp flowbased safety analysis term p phrased terms constraint system variables range clp ffl every occurrence p subterm form 0 constraint ffl every occurrence p subterm form succ e two constraints ffl every occurrence p subterm form xe constraint ffl every occurrence p subterm form e 1 e 2 constraint ffl every occurrence p variable x constraint ffl every occurrence p subterm form xe every occurrence p subterm form e 1 e 2 constraints last two constraints create connection call site e 1 e 2 potential callee xe notice two constraints equalities subset inclusions key reason subtyping needed match safety analysis constraint system mixes flow constraints safety constraints safety constraints ffl succ e succ ffl e 1 rest flow constraints notice int functions cannot occur flow set constraint effect fintg denote cp system constraint generated p fashion let cmapp set total functions constraints cp say p 0cfa safe cp example consider labeled two occurrences f f 1 f 2 notational convenience constraint system ce 1 pointwise least solution next consider labeled occurrences f f 1 f 2 notational convenience constraint system ce 2 pointwise least solution etc 3 type system use v range type variables drawn countably infinite set tv types defined grammar restriction type allowed contain anything form identify types infinite unfoldings rule infinite unfolding eliminates uses types follows types class regular trees alphabet subtype relation types straightforward show partial order notice lower bound upper bound function types int suggestive notation might type environment partial function finite domain maps variables types use range type environments use notation ax denote environment maps x maps 6 x ay type judgment form e means type environment expression e type formally holds derivable using rules notice subsumption rule instead subtyping used restricted way rules 2 3 say e rstypable e derivable rs stands restricted subtyping type system subject reduction property e derivable e betareduces e 0 e derivable proved straightforward induction structure derivation e follow type derivations two terms section 1 first type derivation uses abbreviation notice four uses subtyping notice also possible type f second derivation uses abbreviation notice possible common type a0 bxx reason subsumption rule form want disallow use subsumption immediately use rule variables add subsumption rule terms become typable example consider subsumption rule give yy type give x0 last occurrence f type straightforward complete type derivation e 3 notice fragment type derivation last occurrence f form without subsumption rule type derivation possible indeed type derivation using rules 15 possible see let 1 type yy let 2 type f yy type x moreover ff u type ff hence ff consider fx0 type x0 form cases cannot argument function type ffff ff conclude e 3 rstypable 4 equivalence result theorem 41 term p 0cfa safe p rstypable prove theorem two steps lemma 43 shows p 0cfa safe p rstypable prove lemma use technique 13 lemma 44 shows p rstypable p 0cfa safe prove lemma use technique direct one used show similar result 0cfa 12 flows types first consider mapping flows types given program p map 2 cmapp absp say consistent x 1 given program p 2 cmapp define equation system gammap ffl 2 range let v type variable contains equation contains equation two cases either consistent gammap contains equation otherwise gammap contains equation every equation system gammap unique solution see notice every type variable exactly one equation variable lefthand side thus intuitively obtain solution using equation unfolding rule possibly infinitely often lemma 42 2 cmapp unique solution proof support first w 1 suppose w 1 inconsistent w 1 w 2 also suppose finally w 1 consistent two cases w 2 inconsistent v w 1 lemma 43 satisfies cp unique solution gammap e subterm p derive e v e proof proceed induction structure e base case consider first derive x v hxi desired derivation consider e j 0 derive induction step consider first induction hypothesis derive e also derive succ e consider next e j xe 0 fxe 0 g xe 0 lemma 42 get induction hypothesis derive thus also derive xe finally consider e e 1 absp every xe 0 2 e 1 e 2 induction hypothesis derive two cases e 1 derive e 1 use e 1 absp conclude e 1 consistent thus v e 1 derive e 1 example consider term recall function 1 section 2 satisfies ce 1 constraint system plug construction proof lemma 43 get type derivation shown section 3 leave reader carry construction lead type derivation shown section 3 types flows next consider mapping types flows delta type derivation define f delta map types elements clp set occurrences xe p delta contains judgment form occurrence xe p delta contains judgment form occurrence e p delta contains judgment form 0 lemma 44 delta type derivation proof consider turn constraints cp occurrence 0 constraint delta contains judgment form 0 fintg occurrence succ e constraints delta contains judgments forms fintg occurrence x constraint delta contains judgment form ax occurrence xe constraint fxeg xe delta contains judgments forms two cases fxeg occurrence e 1 e 2 constraint also constraints every occurrence xe absp delta contains judgments forms 0 two cases constraints vacuously satisfied definition f concluding remarks remove section 3 types notion subtyping get traditional system recursive types given program p map 2 cmapp say consistent 2 range consistent add section 2 conditions contain contain inconsistent maps get notion flowbased safety analysis refer restricted 0cfa safety easy modify proof lemma 43 show following result theorem 51 term p restricted0cfa safe p typable recursive types intuitively theorem says want flow analysis weaker recursive types start 0cfa outlaw insist internal consistency flow sets converse theorem 51 false example attempt modify proof lemma 44 run trouble case e 1 e 2 guarantee type e 1 situation arises program recursive types subtyping one type derivation e 4 using abbreviation straightforward show x 6 fintg x 6 fxsuccx0g e 4 therefore counterexample converse theorem 51 leave open problem find flow analysis equivalent recursive types unusual aspect heintzes definition 0cfa int functions cannot occur flow set allow might define change constraints section 2 constraints 0 succ e become systematic way obtaining modified flow analysis begin constraints 0cfa 12 ffl change constraints remain type system matches modified flow analysis obtained changing type system section 3 smallest reflexive transitive relation types type rules 0 succ e become notice modified type system least type greatest type r subtyping recursive types practical flexible flow analysis higherorder languages efficient analyses realistic offline partial evaluation binary methods fast interprocedural class analysis java language specification dynamic typing definition standard ml closure analysis constraint form type system equivalent flow analysis polyvariant flow information intersection union types fast accurate flowinsensitive pointsto analysis tr definition standard ml controlflow analysis higherorder languages taming lambda dynamic typing subtyping recursive types objectoriented type systems closure analysis constraint form type system equivalent flow analysis binary methods pointsto analysis almost linear time practical flexible flow analysis higherorder languages lineartime subtransitive control flow analysis fast accurate flowinsensitive pointsto analysis polyvariant flow information intersection union types fast interprocedural class analysis java language specification controlflow analysis type systems ctr jens palsberg mitchell wand cps transformation flow information journal functional programming v13 n5 p905923 september naoki kobayashi typebased useless variable elimination acm sigplan notices v34 n11 p8493 nov 1999 naoki kobayashi typebased uselessvariable elimination higherorder symbolic computation v14 n23 p221260 september 2001 neal glew jens palsberg typesafe method inlining science computer programming v52 n13 p281306 august 2004 jens palsberg christina pavlopoulou polyvariant flow information intersection union types journal functional programming v11 n3 p263317 may 2001 michael hind pointer analysis havent solved problem yet proceedings 2001 acm sigplansigsoft workshop program analysis software tools engineering p5461 june 2001 snowbird utah united states
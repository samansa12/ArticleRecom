demanddriven adaptive type analysis compilers dynamically statically typed languages ensure safe execution verifying operations performed appropriate values operation simple car scheme hd sml include run time check unless compiler prove argument always nonempty list using type analysis present demanddriven type analysis adapt precision analysis various parts program compiled approach advantage analysis effort spent justified possibility removing run time check added precision needed accurately analyze complex parts program like kcfa approach based abstract interpretation analyze important programs accurately kcfa value k built prototype type analysis tested various programs higher order functions remove run time type checks nontrivial programs use map combinator b introduction optimizing compilers typically consist two components program analyzer program transformer goal ana permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copies bear notice full citation first page copy otherwise republish post servers redistribute lists requires prior specific permission andor fee icfp02 october 46 2002 pittsburgh pennsylvania usa let f lambda b cons 1 car 2 b lambda c c let j lambda 3 car 4 f f cons 5 5 cons 6 6 figure 1 scheme program analysis lyzer determine various attributes program transformer decide optimizations possible worth avoid missing optimization opportunities analyzer typically computes large set attributes predetermined level detail wastes time transformer uses small subset attributes attributes detailed required moreover transformer may require level detail attributes higher determined analyzer consider compiler scheme optimizes calls car removing run time type check argument known pair compiler could use 0cfa analysis 8 9 compute every variable program conservative set allocation points program create value pair function number etc bound instance variable program fragment shown figure 1 0cfa analysis computes pairs created cons 1 cons 5 bound instances variable consequently transformer safely remove run time type check call car 2 note 0cfa analysis wasted time computing properties variable b needed transformer call car b fs body would take complex 1 cfa analysis discover pair created cons 6 cons 8 bound instance variable b 0cfa exclude empty list bound b empty list bound c returned function 1cfa analysis achieves higher precision using abstract execution model partitions instances particular variable basis call sites create instances consequently distinguishes instances variable c created call 7 cons created call 9 allowing narrow type returned 7 cons pairs two calls replaced calls j 2cfa analysis would needed fully remove type checks calls car using abstract execution model keeps track call chains length 2 2cfa analysis distinguishes instances variable c created call chain 7 j cons call chain 9 j 3 compiler implementer user faced difficult task finding program x l x var l lab l l x e 1 l e cons l e 1 car l e 1 cdr l e 1 pair l e 1 figure 2 syntax source language acceptable tradeoff extent optimization value k compile time analysis approach presented paper demanddriven type analysis adapts analysis source program work performed analyzer driven need determine run time type checks safely removed demanddriven analyzer avoids performing useless analysis work performs deeper analysis specific parts program may result removal run time type check achieved changing abstract execution model dynamically increase precision appears beneficial like kcfa analysis based abstract interpretation explained section 4 models use lexical contours instead call chains important programs analyzed approach accurately analyzed kcfa value k see section 6 particular programs higher order functions including uses map combinator analyzed precisely demanddriven analysis place priori limits precision analysis advantage analysis effort varied according complexity source program different parts program hand analysis may terminate programs difficult impossible prove particular type check removed take pragmatic point view user decide maximal optimization effort limit time resource compiler expend type checks could removed within time simply kept generated code think better giving user choice optimization level k use kcfa direct link compilation time although motivation efficient compilation scheme analysis also applicable languages sml haskell removal run time patternmatching checks indeed previous example translated directly statically typed languages run time type checks calls hd brief description source language explain ana lyzer abstract execution models processing demands experimental results obtained prototype analyzer presented source language analysis purely functional language similar scheme three data types false value pairs one argument functions expression uniquely labeled allow easy identification source program syntax given figure 2 booleans pairs env var val evaluation function lv lv lv lv apply function figure 3 semantics source language builtin letrec special form combinator must written explicitly defining recursive functions note also cons car cdr pair treated special forms semantics language given figure 3 notable departure scheme semantics pair returns argument pair operations may require run time type check car cdr argument must pair function call function position must function 3 analysis framework able modify abstract evaluation model analysis program use analysis framework framework parameterized analysis general enough used type anal ysis well variety program analyses specifications abstract evaluation model fed framework analysis instance obtained used analyze program analysis instance composed set evaluation constraints produced framework parameters program constraints represent abstract interpretation pro gram analysis program amounts solving set constraints solution analysis results program framework parameters also produced safety constraints indicate program points run time type checks may needed confronting analysis results safety constraints redundant type checks identified safety constraints satisfied type checks removed optimizer detailed description analysis 1 operator disjoint union ie sets combine must disjoint abstract booleans al c abstract closures al p abstract pairs cont contours al c abstract closure creation abstract pair creation al c v al cont cont contour selection subject v al c ont figure 4 instantiation parameters analysis framework value e l k lk v al l lab k cont contents x k return value c body k flag indicating evaluation e l k creation circumstances c creation circumstances p circumstances leading k figure 5 matrices containing results analysis framework implementation given 4 give overview framework 31 framework parameters figure 4 presents framework parameters specify abstract evaluation model interface simple flexible four abstract domains main contour three abstract evaluation functions provided framework al p abstract domains booleans closures pairs must nonempty mutually disjoint al union three domains cont abstract domain contours contours abstract versions evaluation contexts expressions program get concretely evalu ated part evaluation contexts abstractly modeled contours may lexical environment continuation combination main contour k 0 indicates abstract contour main expression program evaluated abstract evaluation functions cc pc call specify closure creation pair creation contour selected function call occurs cclk returns abstract closure created lexpression e l evaluated contour k pclv 1 v 2 returns abstract pair created consexpression labeled l evaluated contour k arguments v 1 v 2 finally calll cvk indicates contour body closure c evaluated c called callexpression e l contour k argument v group modeling parameters satisfies constraints given figure 4 valid abstract evaluation model framework mpatf l l l k p l lab k mkpat pp mpat spat l l l k p l lab k skpat skpat figure 6 syntax patterns 32 analysis results analysis results returned seven abstract matrices shown figure 5 matrices b g indicate respectively value expressions value variables return value closures value b xk defined follows assume closure c created lexpression l l x e l c called call function prescribes contour k evaluation cs body parameter x bound abstract value b xk lk indicates whether expression e l evaluated contour k e l evaluated contour k lk 0 apparently lk defined boolean instead set however use sets makes implementation analysis framework simpler see 4 matrices c p k logs keeping circumstances prevailing different closures pairs contours respectively created example abstract interpretation program pair p created expression e l values v 1 v 2 contour k creation p logged p p time circumstances logged log variables much fewer theoretically words p p usually contains fewer values pc similarly closure created evaluation e l k l inserted c c contour selected contour body f evaluated f gets invoked v e l k l f v inserted k k patternbased models demanddriven type analysis use patterns pattern matchers implement abstract evaluation models patterns constitute abstract values v al abstract contours cont abstract values shallow versions concrete values abstract contours shallow versions lexical environments lexical contours one features distinguishing analysis type controlflow analyses typically use call chains call chain string labels k nearest enclosing dynamic calls although use call chains guarantees polynomialtime analyses also fooled easily believe lexical contours provide much robust way abstract concrete evaluation contexts figure 6 gives syntax patterns two kinds pat terns modeling patterns mpat mkpat split patterns spat skpat modeling patterns split patterns value variant mpat spat contour variant mkpat skpat split patterns contain single split point designated used demands drive analysis split demands precisely modeling patterns contain split point form representation abstract values contours f f r l r valid label l 2 r valid label l x innermost variable domr figure 7 formal definition relation abstracted 41 meaning patterns modeling patterns represent abstract values turn seen sets concrete values pattern abstracts value pattern f abstracts boolean value f pattern l abstracts clo sure pattern l l k abstracts closure coming lexpression labeled l definition environment abstracted k mkpat pattern p 1 abstracts pair whose components abstracted p 1 p 2 respectively difference abstract values concrete values abstract value made imprecise parts cut using l modeling contour patterns appear modeling patterns clo sures simplify use term contour mean modeling contour pattern contours abstract lexical environments contour list abstract value variable visible certain label innermost variable outermost example contour l indicates innermost variable say closure say x pair could abstract following concrete environment 5 formal definition concrete values abstracted abstract values given figure 7 relation val mpat relates concrete abstract values v p means v abstracted p mention without proof concrete value obtained execution program abstracted modeling pattern perfectly accurate latter abstracts one concrete value former split patterns split contour patterns used express split demands increase precision abstract evaluation model structure similar modeling patterns include one one split point indicates exactly abstract value improvement precision model requested utility made clearer section 5 operations split patterns explained next 2 r valid label l domain exactly set variables visible e l denotes domain function f 4 denotes undefined value consequently r x environment r without binding x 5 empty concrete environment contains bindings l l l l p 1 p n l l p l l p figure 8 algorithm computing intersection two patterns 42 pattern intersection although relation provides formal definition concrete value abstracted abstract value extension abstract value abstracted another necessarily expressed algorithm moreover demanddriven analysis manipulate concrete values patterns kinds present method test whether abstract value abstracted another generally want able test whether modeling split pattern intersects another similarly kinds contour patterns intersection patterns defined figure 8 partially defined two patterns may incompatible sense intersection empty intersection cannot represented using patterns intersection two split patterns may create something two split points equations figure seen cases try order first last possibly case applies pattern p intersects another pattern p intersection function defined applied p p moreover p intersects p resulting intersection characterized 6 43 spreading split patterns another relation needed perform demanddriven analysis spreading test useful determining given split pattern increase precision model used split demand spreading occur set abstract values modeling patterns split pattern split pattern thought denoting subdivision set abstracted concrete value partitioned number sets corresponding different possibilities seen split point sets called bucket example pattern abstracts values val subdivides val three buckets valb valc valp spreading occurs set abstract values v split 6 provided consider l abstract concrete values concrete closures respectively f sf 0 l l 1 p 2 p figure 9 algorithm relation spread pattern p two values refinements values v abstracted p fall different buckets say v spread split pattern p denote v p figure 9 gives formal definition operator cases tried order mathematically relation following meaning set abstract values spread split pattern p denoted p modeling patterns obtained replacing p f l respectively 44 model implementation abstract value viewed concrete value gone projection similarly contour viewed lexical environment gone projection one arranges image projection finite one obtains desired abstract domains al p cont projection used relation much help since generally concrete value v may one abstract value v v v projection based would illdefined projection use based exhaustive nonredundant patternmatcher patternmatcher implementing projection values finite set modeling patterns concrete value v exist one one modeling pattern v set v v patternmatcher describes finite partition val example simplest projection values 7 f l finite exhaustive nonredundant 7 exactly true simplest patternmatcher would trivial one would implement legal model framework since abstract model must least distinguish booleans closures pairs projection contours use one patternmatcher per l expression given lexpression e l lexical environment body evaluated projected patternmatcher l empty lexical environment always projected onto list length 0 empty list contour abstracts empty environment simplest contour patternmatcher l expression l l x e l single list many entries visible variables environment e l evaluated patternmatcher v projects values family patternmatchers project lexical environments assuming v projects closures coming different l expressions different abstract closures easy create abstract model ie define parameters analysis framework follows al b f al c l l k v al p v 1 cont k 0 cclk projection l l k v projection v 1 calll l l w 1 w n v projection v w 1 w n l 45 maintaining model consistency one remaining problem requires special attention consis tency demanddriven analysis patternmatchers used project concrete values abstract values one abstract values precise enough projection operation may become illdefined general abstract values abstract set concrete values suppose 1 imprecise abstract value 2 modeling pattern contains 1 subpattern want project order obtain resulting abstract value sensible definition projection consists choosing modeling pattern w patternmatcher concrete values abstracted abstracted w unfortunately w may exist may take union many modeling patterns properly abstract concrete values abstracted example help clarifying notion following patternmatcher intended projection values inconsistent f f f l l l note patternmatcher finite exhaustive nonredundant nevertheless inconsistent explaining let us see models values first distinguishes values toplevel type second distinguishes pairs type value cdrfield finally pairs containing sub pair cdrfield distinguished type value carfield subpair note carfield sub pairs precisely described carfield pairs inconsistency problems occur try make pair another pair cdrfield let us try make pm pm pm c pm l pm onode v al onode l 1 l n l lexpr pm l leaf mpat leaf mkpat figure 10 implementation patternmatchers project p mpat pm project p 1 p n mkpat pm queue mpatmpatmkpat pmonode v al 1 pq pmonode pmonode v al c 2 pq pmonode pmcnode lab 1 pq pmcnode l l l figure 11 patternmatching algorithm pair values f f obtain modeling pattern project using clear cannot nonambiguously choose one modeling patterns abstraction values abstracted v order avoid inconsistencies time entity refined one patternmatchers must ensure abstract values contours refined entity depends sufficiently precise cascaded refinements propagated dependencies entity cascade terminates since propagation depth extra details required decreases 46 patternmatcher implementation implementation patternmatchers quite simple patternmatcher basically decision tree breadthfirst inspection modeling pattern modeling contour pattern project internal node decision tree either onode object cnode closure leaf contains abstract value contour result projection onode either threeway switch depends type object inspect oneway catchall ignores object continues single child cnode either multiway switch depends label closure inspect oneway catchall ignores closure continues single child figure presents data structures used implement patternmatchers demand show b avarb bound split p splitteep spat show badcall l avarb bvarc gvar avar lk l labk mkpat gvar g ck c mpatk mkpat dvar lk l labk mkpat figure 12 syntax demands patternmatching algorithm presented figure 11 breadthfirst traversal done using queue contents queue always remain synchronized position decision tree cnode reached closure next queue leaf reached queue empty initial queue abstract value projection contains abstract value initial queue contour projection contains abstract values contained contour first abstract value contour first extracted queue keep notation terse use view operation enqueue dequeue values enqueuing queue left dequeuing queue right empty queue denoted patternmatchers used initial abstract model fol lowing note describe terms set theory terms actual data structures value patternmatcher contains one abstract boolean one abstract pair one abstract closure lexpression lexpression corresponding contour patternmatcher trivial one note consistent patternmatchers almost blind de tail inspection performed switch label projecting closure however projection closures always involves closures explicit labels since occurs use abstract model function cc give detailed description process refining patternmatcher would lengthy conceptually difficult 5 demand processing figure 12 presents syntax demands syntax demands builds syntax patterns show de mands split demands bad call demands 51 meaning demands show demand asks demonstration certain property example might ask demonstration particular abstract variable must contain pairs meaning certain ex pression certain evaluation context must evaluate pairs might ask demonstration particular abstract variable must empty meaning certain expression certain evaluation context must get evaluated note bound al rues represents values acting true conditionals al p bad call demand asks demonstration particular function call cannot happen specifies contour bad call currently happens function called value passed argument course except label parameters demand abstract split demand asks proper modifications done model way splittee longer spread pattern take demand example split lk asks abstract values contained lk distinguished type pattern variable lk currently contains abstract values different types values said spread pattern model ought modified way contour k subdivided number subcontours lk contains abstract values single case success one might observe lk 1 contains pairs lk 2 closures lk 3 nothing lk 4 f etc value expression e l contour k would split according type split demand splittee aspect abstract model v al c v al p abstract variable one b g matrices splittee bvar denote ordinary entry b matrix indicate name source variable also gives label contour variable referenced bound values intersect pattern concerned split example demand split lk ff ff l thing matters two abstract pairs must separated happens boolean important intersect pattern normally show demand emitted analysis determined specified property false type error plausibly happen real program similarly bad call demand unfortunately split demands natural interpretation purely artificial creation necessary demanddriven analysis perform task moreover concrete evaluation program expression particular evaluation context evaluates exactly one value splitting concrete evaluation meaningless 52 demanddriven analysis algorithm main algorithm demanddriven analysis relatively sim ple sketched figure 13 basically analysismodel update cycle analysis phase analyses program using framework parameterized current abstract model modelupdate phase computes possible modelupdating demand based current analysis results applies model note successive updates abstract model make increasingly refined analysis results helps produce improve monotonically consequently run time type check proved redundant point remains rest cycle steps performed modelupdate phase initial demands gathered demand processing demands modify model call monitoring occur new demands generated modelupdating demands best one selected applied model model modifying demands split demands splittee al c v al p member bvar create initial model analyze program model time left set demand pool initial demands make set modifying demands empty repeat monitor call sites l k marked time left new demands pool pick new demand pool modifying demand insert modifying demands set else process add returned demands pool time left call sites monitor modifying demands set empty exit else pick best modifying demand modify model reanalyze program new model figure 13 main demanddriven analysis algorithm initial demands obtain responding needs optimizer demand processing nonclosures may called nonpairs may go strictly pairwise operation bound demands asking demonstration violations really occur generated precisely call l e e l k cont l k v al c initial demand show l k v al c generated pairaccess expression car l e l cdr l e l k cont l k al p initial demand show l k v al p generated criterion used select good modelupdating demand implementation described section 6 analysismodelupdate cycle continues time left model updates proposed model update phase indeed user compiler including demanddriven analysis determines bound computational effort invested analysis program time necessarily wall clock time may measure implementation unit time allows algorithm process demand two reasons may cause algorithm stop lack modelupdating demands one initial de mands means run time type checks program shown redundant remain initial demands current analysis results mixed way demand processing lead generation modelupdating demand 53 demand processing 531 show demands us present processing demands begin processing show avarbound demands let us consider demand show lk b 3 cases first case values lk lie inside bound b demand trivially successful nothing done order obtain desired demonstration lk b second case values lk lie outside bound b must shown expression e l get evaluated abstract contour k sufficient necessary condition e l evaluated contour k value returns outside bound causing original demand fail e l get evaluated contour k conclude value lk lies inside bound lk 0 show last case values lk lie inside b sensible thing first split contour k subcontours way becomes clear whether values lie inside b lie outside b since bounds simple splitting type objects sufficient would better say split demand successful original demand processed otherwise split lk 532 show empty demands continue processing show demands let us consider demand show many cases processing first variable lk already empty demand trivially successful 0 otherwise fact e l get evaluated contour k depends lot parent expression one parent expression means e l main expression program consequently possibility prove e l get evaluated contour k 8 e l main expression case e l parent expression let e l expression let us consider case e l lexpression implies e l body e note evaluation e l contour k direct connection evaluation e l contour k fact e l gets evaluated contour k closure c resulting evaluation e l contour gets called somewhere expression e l contour k certain argument v way resulting contour calll cvk body c must evaluated k processing demand consists emitting bad call demand abstract call note log matrices k c used recover circumstances contours closures created 8 fact little complicated suppose abstract variables contain minimal solution evaluation constraints generated analysis framework conditions l label program main expres sion lk nonempty k main abstract contour contour k lk e l let us consider case e l conditional conditional three subexpressions first consider case e l thenbranch e l clearly sufficient show e l evaluated contour k however requirement abusive sufficient necessary condition thenbranch evaluated evaluated test return return resp true values e l show l k case e l elsebranch conditional analogous elsebranch cannot get evaluated test always returns true values e l show l k v al rues case e l test conditional treated default case default case concerns situations explicitly treated default case prove e l get evaluated contour k requires demonstration e l get evaluated contour k either obvious since evaluation call cons car cdr pair expression necessarily involves evaluation subexpressions similarly test subexpression conditional otherwise show l next describe bad call demands processed let us consider demand badcall l f v k expression e l necessarily call let e two cases either specified call occur call occur demand trivially successful 9 case specified call noted bad call log another note kept order later take care bad calls e l contour k call operation monitoring e contour k one bad call may concern expression contour monitoring crucial operation access bad call informations accurate possible preferable postpone monitoring much possible otherwise bad call log flag l k candidate monitoring 9 actually current implementation case cannot occur demand generated precisely specified call found k matrix however previous implementations differed way demands generated bad call demands could emitted later proved trivially successful 534 split demands direct model split let us present processing split demands processing differs considerably depending splittee start describing processing following demands split v al c p split v al p p easy process explicitly prescribe modification abstract model modification always accomplished successfully update v p avariables involving part demand processing processing split avarspat demands demand asks splitting value expression certain contour spreading values specified pattern let us consider demand split lk p first possibility actually spreading demand trivially successful however spreading expression e spected nature computations different expressions vary greatly let us examine kind expression one one first consider false constant note expression evaluate f value cannot spread p matter split pattern p completeness mention processing demand nevertheless second e l may variable reference processing demand straightforward translates split demand onto bvar third e l may call clearly case difficult deal way call expression abstractly evaluated potentially many closures present caller position many values present argument position follows cartesian product possible invocations must done turn invocation produces set potentially contains many return values order succeed split set return values spread pattern must split subexpressions call must split way invocation producing nonspread return values occur contour another invocation producing incompatible non spread return values second task done help function sc split couples prescribes split patterns separate incompatible couples example follows formal description processing split demand call split g ck p c l k v al c split l k split l k following example illustrates processing demand suppose want process demand split lk two closures may result evaluation e l say l two values may passed arguments say l g c 2 k 22 v al p closure c 1 called v 2 closure c 2 called v 1 return values spread follows return values circumstances must split g c 1 k 12 g c 2 k 21 must split pattern necessary two splits succeed order make original demand succeed sufficient however cannot allow c 1 called v 1 c 2 called v 2 contour k union return values spread incompatible sc function comes play use returns either l 0 either case split according prescribed pattern successful would make two incompatible calls occur different contours suppose first case happens result processing original demand split split l k l fourth e may lexpression processing demand simple reduces split abstract model closures fifth let us consider case e l conditional two cases possible first case least one branches spread pattern second branch causes spreading pattern incompatible test subexpression evaluates true false values first case conservative approach consists splitting branches cause spreading split l n k p l n second case sufficient split type test subexpression determining type test subexpression allows one determine two branches taken consequently knowing value conditional equal one two branches split l k sixth expression e l may pair construction fact value e l spread pattern implies first pattern form p second value one two subexpressions e l spread corresponding subpattern p p either case demand processed splitting appropriate subexpression appropriate subpattern cons l e l e l split l k p cons l e l e l split l k p seventh e l may carexpression order split value e l p subexpression split p however possibility abstract model pairs precise enough abstract pairs level details required p model pairs split first split subexpression proceed planned al p precise enough p split l k p al p p eighth e l cdrexpression processing similar carexpression al p precise enough p split l k p ninth e l must pairexpression processing demand simply consists split subexpression see important recall case currently considered lk p type subexpression must found order find type ex pression split required subexpression since pairs pairexpression come subexpression p cannot l l l k l lab k mkpat e l evaluate booleans pairs split l k p bvariables next kind split demands bvar splittee recall bvar indicates name program variable label contour reference variable occurs let us consider particular demand split b xkl p recall also contour k modeling contour pattern consists list modeling patterns one per variable lexical environment visible expression e l modeling pattern represents kind bound value corresponding guaranteed lie first modeling pattern corresponds innermost variable last corresponds outermost note analysis framework compute value variable references using bounds far framework concerned whole contour name particular evaluation context framework reference variable x computed either inspecting abstract variable b xk x innermost variable translating reference x label l lexpression immediately surrounding e l contour lexpression e l got evaluated creating closure later got invoked leading evaluation body contour k details variable references analysis framework see 4 nonetheless way implement abstract model reference variable x label l contour k always produces values lie inside bound corresponding x k consequently split program variable involves certain number splits abstract models call cc moreover consistency abstract values also prescribes multiple splits abstract model example contour k results call closure l l k value v label l contour k cannot precise program variable bounds shares contour k turn closure l l k results evaluation e l contour k l l k cannot precise k program variable bounds shares contour follows split program variable seen refining bound local contour requires refining chain contours closure environments point reached contour refine share variable closure leading creation come back processing split b xkl p first thing must verified whether reference x e l contour k produces values spread pattern p denote variable reference refxk l spreading occurs 10 demand trivially successful otherwise modifications model must done otherwise update v l l m1 update l m1 p m1 p update v l l n update l n p n p m1 p l l x l l m1 m1 l l n n x l lexpression binding x gvariables last kind demands split demand gvar splittee processing demand straightforward since case cannot occur current implementation return value closure result evaluation body let us consider particular demand split g ck p case return value spread pattern demand trivially successful otherwise split l k p 535 call site monitoring processing rules given demands however add description monitoring call sites monitoring call sites pretty similar processing demand split lk p e l call difference comes fact monitoring effort made order prove bad calls occur let us consider monitoring call expression l e l e l contour k let l bc denote bad call log potentially many closures may result evaluation e l potentially many values may result evaluation e l among possible closureargument pairs certain number may marked bad bad call log others pair marked bad monitoring e l k trivially successful l k v al ca l k l bc l 0 contrary pairs marked bad calls demand emitted asking show call get evaluated show general case marked pairs nonmarked pairs occurring call site tempting emit demand asking proof call get evaluated would simple would good idea nonmarked pairs may abstract actual computations concrete evaluation program consequently would hope ever making successful 11 done separate using splits pairs marked pairs overloaded sc function used otherwise split l k 536 split couples function conclude section short description sc function sc used two different tasks splitting closureargument pairs 11 analysis done using framework conservative see 4 computations made abstract interpretation abstract least computations made concrete interpretation impossible prove abstract invocation occur concrete counterpart occurring concrete interpretation according bucket return values fall relatively split pattern splitting closureargument pairs depending criterion considered bad calls fact two tasks similar cases set pairs partitioned equivalence classes given either split pattern bucket badness call order separate two pairs belonging different classes sufficient provide split separates v 1 w 1 split separates v 2 w 2 sc prescribe set splits perform first component pairs another set splits perform second component two pairs different classes would separated clearly possible since prescribing splits intended separate first component simple task similarly second components way pair would separated others would overly aggressive however usually much smaller sets splits sufficient separate pairs implementation sc proceeds way first computes equivalence classes next pair converted genuine abstract pair modeling pattern breadthfirst traversal pairs simultaneously splitting strategies elaborated compared end strategy requiring smallest number splits obtained little aggressive possible important proposed splits applied one two subexpressions call expression subexpressions may expressions hard split calls 6 experimental results 61 current implementation current implementation demanddriven analysis merely prototype written scheme experiment analysis approach effort put making fast space efficient instance abstract values implemented lists symbols closely resemble syntax gave modeling patterns reanalysis phase uses data without converting numbers bitvectors projection using patternmatchers done use cc pc call functions aside way demands processed many variants main algorithm tried variant present section 5 first method provided interesting results previous variants trying clever model changes concurrently demand processing lead many compli cations demands could contain values contours expressed terms older model reanalysis periodically done necessarily following model update caused demands see benefits split model done complex system success failure propaga tion sequencing processing periodic processing resuming necessary etc strength current variant model update reanalysis done whole demand propagation restarted scratch greatly benefitting new analysis results current variant tried different approaches way best modelupdating demand selected applied model first applied modelupdating demands proposed demand processing phase lead exaggerate l 2 op l 3 l 4 l 5 cons 6 7 cdr 15 l l 17 let let 22 24 25 f 26 letrec l 28 data let data let 36 data 42 43 loop 44 cons 45 cons 46 cons car 50 data 51 cons 52 l 53 w f 54 cdr data 56 cons 59 f figure 14 source maphard benchmark refining model leading massive space use decided make selection one demands according certain criterion first criterion measure much abstract model increases size particular demand selected helped controlling increase size model choosing wisely obtaining informative analysis results new results expressed finer values knowledge program data flow always creased moreover necessarily help controlling increase size analysis results second criterion use measures much abstract model plus analysis results increase size criterion really makes difference although demand selection step involves reanalyzing program candidate demands 62 benchmarks experimented small benchmark programs benchmarks involve numeric computations using naturals two important remarks must made first minilanguage include letrecexpressions means recursive functions must created using combinator note wrote benchmarks extended language let letrec expressions used translator reduce base lan guage included two kinds letrec translations one defined globally recursive functions created using one private combinator generated letrecexpression first kind translation really makes programs intricate recursive functions closures created second kind translation loosely corresponds making analysis able handle letrecexpressions special form made tests using translation modes second remark concerns numbers minilanguage include inte gers another translation step replaces integers simple numeric operators lists booleans functions respectively thus integers represented unary peano numbers operations numbers proceed accordingly adds another level difficulty top letrecexpression translation example translation see appendix benchmarks following cdrsafe contains definition function checks argument verify pair access analyzed perfectly well 1cfa 0cfa loop infinite loop 21 computes value 2 1 mapeasy uses map function short list pairs using two different operators maphard repetitively uses map function two different lists using two different operators lists passed growing longer longer use map mentioned 7 impossible analyze perfectly well kcfa source code benchmark shown figure 14 fib gcd tak ack classical numerical computa tions nqueens counts number solutions 4 queens ski interpreter expressions written well known k combinators interpreter runs ski program infinite loop combinators calls encoded using pairs booleans 63 results figure 15 presents results running analysis bench marks benchmark analyzed reduced translation method global private time limit 10000 work units allowed analysis bench mark machine running benchmarks pc 12 ghz athlon cpu 1 gbyte ram running rh linux kernel 242 gambitc 40 used compile demanddriven analysis column labeled indicates whether combinator global private next column indicates size translated benchmark terms number basic expressions columns labeled total pre post indicate number run time type checks still required program moments respectively analysis done analysis initial model done demanddriven analysis finally computation effort invested analysis measured terms work units cpu time measure column total purely syntactic one basically counts number call car cdrexpressions program measure pre useful comparison 0cfa analysis indeed initial abstract model used approach quite similar implicitly used 0cfa entry like 223 column indicates 2 run time type checks still required invested 23 work units demanddriven analysis gives idea convergence rate analysis look figure 15 aspect results striking small improvements full demanddriven analysis obtains results obtained 0cfa two reasons explain fact first many run time type checks completely trivial remove instance every letexpression trans lated introduces expression form lx turn translation letrecexpression introduces 2 3 let expressions depending translation method easy optimize expression even purely syntactic detection would suffice second type checks equally difficult remove checks removed 0cfa removed easy additional checks removed demanddriven phase difficult ones fact difficulty type checks seems grow rapidly come close 100 mark statement supported numbers presented 2 lineartime analysis sub0cfa obtains analysis results almost useful optimizer 0cfa despite patent negligence manipulation abstract values note translating private per letrec helps 0cfa demanddriven analysis fact except nqueens benchmark demanddriven analysis able remove type checks private combinators used success analysis varies considerably benchmarks size total pre post units times loop g mapeasy g maphard g 96 33 9 638 5254 3305 1520 0 1399 7626 nqueens g 372 121 51 51 10000 1589939 ack g 162 7473 6543 51474 43584 figure 15 experimental results unrolling units 176 280 532 1276 3724 figure 16 effect size program analysis work moreover closely related size program influenced style code order evaluate performance analysis similar programs conducted experiments family programs modified ack benchmark unrolling recursion certain number times translation private used figure 16 shows results range unrolling levels unrolling level total number type checks resulting program 43 optimization done 3 checks still required program analyzed initial model checks eliminated demanddriven analysis finishes observe somewhat quadratic increase analysis times certainly better exponential behavior expected type analysis using lexical environment contours conclusions type analysis presented paper produces high quality results use adaptable abstract model analysis abstract model updated response specifics program considering needs opti mizer adaptivity obtained processing demands express directly indirectly needs optimizer model updates demanddriven optimizer processing rules demands make approach robust differences coding style approach includes flexible analysis framework generates analyses provided modeling parameters proposed modeling data based patterns described method automatically compute useful modifications abstract model gave set demands processing rules compute useful model updates finally demonstrated power approach experiments showing analyzes precisely relatively short time program known impossible analyze kcfa complete presentation contribution found 3 indepth presentation concepts algorithms along proofs behind important theoretical results also found except ideas abstract interpretation flexible analyses remainder presented work best knowl edge original abstract interpretation frequently used field static analysis see 2 7 8 9 kcfa family analyses see 8 9 extent considered flexible configurable analysis presented 2 ashley dybvig produce extended family analyses compiler implementation time analysis framework see 4 allows subtlety modified analysis think many ways continue research subject extended experiments approach comparison many analyses speed memory consumption analysis incremental reanalysis analysis results r 1 obtained using model 1 model 2 refinement model 1 compute new results r 2 efficiently better selection modelupdating demands moreover language extensions considered handle larger part scheme extending demanddriven approach analyses also theoretical questions know analyzing analysis framework adequate modeling parameters always least powerful kcfa many analyses however requires parameters given oracle know whether current demanddriven approach always least powerful kcfa family think yet proof l 2 l 3 n 4 figure 17 ack benchmark expansion p ackp cons 22 f 23 cons 24 f 25 cons 26 f 27 cons 28 f 29 f l 35 ackf l 36 l 37 n 38 cons 67 f 68 f 69 l 94 f l 95 x l 96 97 x 109 110 f 111 cons 112 f 113 f 114 l 118 f l 119 x2 l 120 y2 121 y2 122 123 124 f 125 cdr 126 x2 127 l 134 f l 135 x3 l 136 y3 137 x3 138 cons 139 f 140 141 142 f 143 cdr 144 x3 145 l 148 f 149 l 150 g 151 g 152 g 153 figure 18 ack benchmark expansion researchers worked demanddriven analysis substantially different way see work duesterwald et al 5 agrawal 1 heintze tardieu 6 approaches abstract execution model changes suit pro gram goal adapt wellknown analysis algorithms variants one perform amounts lazy evaluation analysis results acknowledgments authors thank anonymous referees careful review numerous constructive comments work supported part grant natural sciences engineering research council canada 9 r simultaneous demanddriven dataflow call graph analysis practical flexible flow analysis higherorder languages unified treatment flow analysis higherorder languages control flow analysis scheme semantics scheme controlflow analysis tr control flow analysis scheme semantics scheme controlflow analysis demanddriven computation interprocedural data flow unified treatment flow analysis higherorder languages practical flexible flow analysis higherorder languages demanddriven pointer analysis simultaneous demanddriven dataflow call graph analysis
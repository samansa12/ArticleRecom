timeoptimal domainspecific querying enhanced meshes abstractquery processing crucial component various application domains including information retrieval database design management pattern recognition robotics vlsi many applications involve data stored matrix satisfying number properties one property occurs time specifies rows columns matrix independently sorted customary refer matrix sorted instance batched searching ranking problem bsr short involves sorted matrix items totally ordered universe along collection q queries q arbitrary mix following query types search query qj one interested item closest qj rank query qj one interested number items strictly smaller qj bsr problem asks solving queries q work consider bsr problem following context matrix pretiled one item per processor onto enhanced mesh size sqrt ntimes sqrt n queries stored one per processor first sqrt n columns platform main contribution twofold first show algorithm solves bsr problem must take least omega rm maxlognsqrt time worst case second show time lower bound tight meshes size sqrt ntimes sqrt n enhanced multiple broadcasting exhibiting algorithm solving bsr problem theta rm maxlognsqrt time platform b introduction due simple intuitive topology mesh established one massively parallel architectures suitable solving problems image processing robot vi sion computer graphics path planning vlsi design among many others time mesh notoriously inefficient comes handling nonspatially organized data address problem meshconnected computers enhanced various types bus systems 1 22 25 28 recently powerful elegant architecture referred mesh multiple broadcasting obtained endowing row column mesh dedicated high speed bus 22 35 mesh multiple broadcasting proven feasible implementation vlsi adopted among others dap family computers 35 theoretical interest well commercially available mesh multiple broadcasting attracted great deal well deserved attention applications ranging image processing 23 35 computer graphics robotics 6 34 computational geometry pattern recognition 5 6 9 10 12 22 27 33 sorting searching 8 11 22 fundamental problems 3 7 13 14 found efficient solutions work supported nasa grant nas119858 nsf grants ccr 9407180 ccr9522093 onr grant n000149510779 preliminary version work appeared proc international conference applicationspecific array processors stras bourg france july 1995 correspondence prof olariu email architecture variants 27 query processing crucial transaction various application domains including information retrieval database design management vlsi many applications involve data stored matrix satisfying number properties one property occurs time applications specifies rows columns matrix independently sorted 16 21 30 customary refer matrix sorted matrix said fully sorted entries sorted rowmajor resp columnmajor order figure 1a displays sorted matrix figure 1b features fully sorted version matrix figure 1a 3 9 14 26 b fig 1 illustrating sorted fully sorted matrices sorted matrices provide natural generalization number reallife situations consider vectors j cartesian sum x denoted n theta matrix entries clear x sorted stored succinctly n space 16 19 since entries ij computed needed constant time tasks searching ranking selection sorted matrices received considerable attention 16 17 19 20 21 30 main goal paper look problem batched searching ranking bsr short sorted matrices throughout work generic instance bsr problem involves sorted matrix size n theta stored one item per processor mesh multiple broadcasting size n collection q queries stored first columns platform queries two types query q j first type one interested item closest q j query q j second type one interested number items strictly smaller q j two query types referred search queries rank queries respectively set q queries arbitrary mix two query types goal determine solution every query q important note search queries occur frequently image processing pattern recognition computational learning artificial intelligence one interested finding item database best matches sense query hand 2 18 36 hand rank queries central relational database design histogramming pattern analysis given collection items database along query one interested computing number items database lesser value query addition rank queries finds applications image process ing robotics pattern recognition 2 6 18 note variant rank queries also received attention literature specifically range query involves determining number items given database fall certain range easy see range queries answered stating rank queries 18 point reader may wonder queries lie leftmost l columns mesh shall discuss section ii assume mesh multiple broadcasting communicates outside world via io ports placed along leftmost column platform consistent view 29 enhanced meshes serve fast coprocessors presentday computers scenario host computer passes queries mesh batches n presence input queries leftmost l columns used main contribution twofold first show algorithm solves bsr problem must take least omegagammaast flog n time worst case lower bound holds crewpram mesh multiple broadcasting second show bsr problem solved timeoptimally mesh multiple broadcasting size n theta n exhibiting algorithm whose running time matches lower bound put contribution perspective note recently bhagavathi et al 9 showed task solving search rank queries fully sorted matrix performed theta p time mesh multiple broadcasting size p n theta p n actually context fully sorted matrices difference two query types vanishes solved essentially way context sorted matrices search queries rank queries much different requiring different resolution strategy surprising therefore algorithm bsr problem much complicated sophisticated algorithm 9 order obtain timeoptimal algorithm bsr problem develop novel interesting cloning strategy queries scenario following partition platform number submeshes clone given queries done obtain local solution query submeshes fi nally since number clones query large larger available bandwidth allows handle devise strategy whereby retrieve information gathered clones interesting feature strategy always exists relatively small subset clones retrieved allows resolution queries consequence algorithm devised paper completely different 9 showing whole potential meshes multiple broadcasting paper organized follows section ii introduces model computation section iii presents lower bound arguments section iv discusses timeoptimal algorithm bsr problem finally section v offers concluding remarks poses open problems ii computational model mesh multiple broadcasting size theta n referred mesh confusion possible consists mn identical simd processors positioned rectangular array overlaid highspeed bus system every row mesh processors connected horizontal bus similarly every column processors connected vertical bus illustrated figure 2 assume processors first column serve io ports illustrated way platform communicates outside world fig 2 mesh multiple broadcasting size 4 theta 4 processor p j located row column j 1 northwest corner mesh processor p j local links neighbors 1 provided exist processors assumed know coordinates within mesh constant number registers size olog mn unit time processors perform arithmetic boolean operation communicate one neighbors using local link broadcast value bus read value specified bus operations involves handling olog mn bits information due physical constraints one processor allowed broadcast given bus one time contrast processors bus simultaneously read value broadcast accord researchers 3 13 22 23 25 28 35 assume constant broadcast delay although inexact recent experiments dap ppa yuppie multiprocessor array systems seem indicate reasonable working hypothesis 25 28 35 iii lower bound purpose section establish nontrivial lower bound bsr problem meshes multiple broadcasting purpose consider platform size n theta storing sorted matrix size discussed 1 n queries stored first columns 1 mesh clearly processor stores one item one query lower bound arguments rely part following fundamental result cook et al 15 proposition 31 15 time lower bound computing logical n bits crewpram omegagammas2 n matter many processors memory cells available also rely following result lin et al 26 proposition 32 computation takes otn computational steps nprocessor mesh multiple broadcasting performed otn computational steps nprocessor crewpram important note proposition 32 guarantees tm n execution time algorithm solving given problem nprocessor mesh multiple broadcasting exists crewpram algorithm solve problem tp using n processors extra memory words fast algorithm mesh multiple broadcasting implies fast algorithm crewpram observation exploited 26 transfer known computational lower bounds crewpram mesh multiple broadcasting fig 3 illustrating lower bound solving single query shall prove even solving single query search rank type takes n time result proved crewpram ported mesh multiple broadcasting proposition 32 begin reducing problem problem solving search query q purpose let arbitrary input construct sorted matrix illustrated figure 3 placing n 1 setting ae assume simplicity n integer construction guarantees matrix sorted regardless values b assign query q value 09 easy confirm answer problem 0 solution query see note sequence b 1 contains 1 1 returned solution query failing 0 returned virtue proposition 31 algorithm correctly answers search query sorted matrix must nomegagamma615 n time crewpram regardless number processors memory cells available continue reducing problem problem solving rank query q purpose let arbitrary input construct sorted matrix illustrated figure 3 let query q value 09 clear answer problem 0 number elements smaller q exactly n p nto see observe construction every element matrix upper left triangle strictly smaller query elements may strictly smaller query lie diagonal seen figure 3 reader difficulty verifying total number elements strictly smaller q elements diagonal 0 proposition 31 guarantees algorithm correctly answers rank query sorted matrix must takeomegagamma324 n time crewpram virtue proposition 32 following result lemma 33 algorithm correctly solves one search rank query sorted matrix n elements must take least omegagammaast n time mesh multiple broadcasting size demonstrate every algorithm solves bsr problem fully sorted matrix must take omegagamma time worst case course imply lower bound sorted matrices purpose assume fully sorted matrix stored rowmajor order mesh multiple broadcasting size n theta n refer elements row major order 1 note context fully sorted matrices search rank queries solved essentially way specifically let q arbitrary query let subscript q i1 clearly q rank type solution denotes number items strictly smaller q hand q search type item closest q either i1 observation allows us handle purpose lower bound type queries rank queries turn implies use following result proved bhavagathi et al 9 proposition 34 algorithm correctly solves queries fully sorted matrix n elements must take time mesh multiple broadcasting size n theta n lemmas 33 34 combined provide main result section state next theorem 35 algorithm correctly solves instance bsr problem involving sorted matrix items stored one per processor collection stored one per processor first columns mesh multiple broadcasting size n theta must take least omegagammaast flog n mg time iv timeoptimal bsr algorithm generic instance bsr problem involves sorted matrix size n theta n collection queries query q j following types 1 search type determine item closest 2 rank type determine rank q j ie number items strictly smaller q j avoid handling double subscripts items enumerated rowmajor order 1 sorted matrix stored one item per processor mesh r multiple broadcasting size n theta n set q stored first columns r one query per processor illustrated figure 4 shall view mesh r consisting submeshes size theta r ij involving processors p r c 1 illustrated figure 5 occasionally shall find convenient view mesh r consisting submeshes size theta n consisting submeshes r i1 submesh referred slice r depicted figure 5 fig 4 illustrating input bsr problem outline algorithm bsr problem proceeds following three stages stage 1 set q queries replicated submesh r ij creating local instances bsr problem stage 2 determine submesh r ij paral lel solution local instance bsr problem stage 3 solutions local instances bsr problem obtained stage 2 combined r r 11 slice slice fig 5 illustrating partition submeshes r ij solution original bsr problem remainder section devoted detailed description stages stage 1 purpose stage replicate set q queries submesh r ij one query per processor plan move queries column r columns every r ij specifically queries moved columns r ij give details data movement illustration reader referred figures 6ad begin every processor p n broadcasts query holds horizontally diagonal processor shown figure 6ab turn processor p r r broadcasts query received vertically every processor shown figure 6bc fig 6 illustrating data movement stage 1 noted result data movement queries originally stored column k r replicated diagonal processors submeshes every slice slices processed parallel specifically queries stored diagonal processors r i1 replicated using row buses slice th column r ij slice next queries stored diagonal processors r i2 replicated using row buses slice th column r ij illustration refer figure 6d easy see task replicating queries originally stored one column r takes time therefore long n queries initially stored leftmost columns r replicated time case queries replicated way similar one de scribed complexity data movement goal stage 1 achieved queries replicated submeshes r ij thus proved following result lemma 41 set q queries initially stored first columns r replicated one query per processor submesh r ij time stage 2 important note end stage 1 replicated set q queries submesh r ij fact partitioned original instance bsr problem several instances local r ij local instance involves subset stored processors r ij entire set q queries main goal stage solve local instance bsr submesh r ij avoid broadcasting conflicts stage 2 bus system ignored every submesh r ij act unenhanced mesh begin sorting items queries r ij rowmajor order using optimal sorting algorithm meshes 31 note sorting process ties broken favor queries words query item equal sorted version query precedes item let c 2m resulting sorted sequence stored two items per processor submesh r ij following two results justify approach solving local instances bsr problem lemma 42 let q k query rank type assume c words q k occurs position sorted sequence c ij number items r ij strictly smaller q k equals number items preceding q k c ij proof follows directly sortedness c ij along assumed tiebreaking discipline lemma 42 motivates following strategy solving rank type queries r ij assign every c weight defined follows ae item query 1 next compute prefix sums sequence using weights assigned 1 2m result virtue lemma 42 value e corresponding c exactly number items r ij strictly smaller q k therefore rank queries solved time sorting prefix sums computation p 31 32 task handling search queries requires different approach motivate strategy consider sorted sequence c refer figure 7 item query l 1 l 3 l 4 fig 7 illustrating sorted sequence c ij queries occur c ij form contiguous subsequences every sequence p let l p r p stand respectively leftmost rightmost query p illustrated figure 7 course sequence p consists one query l 2m motivation terminology becomes clear observe lemma 43 search queries sequence p solution either c ffgamma1 c fi1 proof let q k arbitrary search query sequence p sortedness c ij along tiebreaking discipline guarantees item r ij closer q k one items c ffgamma1 c fi1 turn lemma 43 suggests following approach solving search queries r ij first assign every c weight w defined follows ae c c item query 2 next compute prefix maxima sequence using weights assigned 2 2m result easy confirm every search query c corresponding value e exactly identity item c ffgamma1 previous terminology gamma1 item exists next assign every c weight w ae c c item query 3 compute prefix minima sequence using weights assigned 3 let 2m result easy confirm every search query c corresponding value e exactly identity item c fi1 previous terminology 1 item exists therefore end two computations every search query q k becomes aware c ffgamma1 c fi1 virtue lemma 43 sufficient purpose determining solution every search query q k r ij summarize finding state following result lemma 44 task solving local instance bsr problem submesh r ij performed parallel time stage 3 end stage 2 processor generic submesh r ij stores along query q k local solution case q k search query oei j denotes item closest q k case q k rank query oei j denotes number items strictly smaller q k goal stage 3 combine local solutions solution q k original instance bsr problem fig 8 illustrating proof lemma 45 preparation first task stage arrange every submesh r ij ordered pairs rowmajor order sorted subscript k recall using optimal sorting algorithm meshes 31 task performed time note sorting tuple q occupies relative position submeshes r ij processing relies heavily technical property sorted matrices discuss next referring figure 8 submesh r ij said critical respect query q k q k larger entry v northwest corner r ij greater entry b v southeast corner r ij words following result key deriving timeoptimal algorithm bsr problem lemma 45 submesh r ij critical respect query q k one submeshes r igamma1j r ij1 may critical respect q k proof referring figure 8 let u v aw stand items stored northwest corner respectively similarly let b b w stand items stored southeast corner r igamma1j r ij r ij1 respectively assume r ij critical respect query q k r igamma1j critical respect q k since matrix sorted 5 6 combined guarantee 4 r ij1 cannot critical respect q k similarly r ij1 critical respect q k since matrix sorted 7 8 combined guarantee confirming virtue 4 r igamma1j cannot critical respect q k completes proof lemma 45 r fig 9 illustrating concept active copy query q k consider generic slice reference shall call copy query q k submesh r ij active one conditions a1a4 satisfied refer reader figure 9 illustration r ij critical respect query q k a2 slice contains critical submesh respect query q k larger items r ij smaller equal items r ij1 larger items slice case copy q k r active smaller equal items slice case copy q k r i1 active leftmost submesh slice containing active copy query q k referred leading respect point reader may wonder information computed clear determining submeshes r ij critical respect given query information needed values northwest southeast corners submesh time values circulated within submesh every processor becomes aware next every processor r ij needs informed values items northwest southeast corners neighboring submeshes slice information obtained time obvious way information available critical submeshes active copies queries found constant time fig 10 illustrating assignment buses strategy combining solutions queries every r ij global solution involves considerable amount data movement restrict running time theta plan use buses support data movement lemma 45 motivates us assign buses active copies queries according following rules illustrated figure 10 r1 copy q k belongs leading submesh slice assigned horizontal bus row r2 remaining active copies q k assigned vertical bus column following result shows rules r1 r2 lead conflictfree broadcasting lemma 46 every active copy q k broadcasts simultaneously assigned bus broadcast conflict arise proof first claim broadcast conflicts occur horizontal buses see note horizontal bus assigned copy q k either exists one active copy q k slice case copy q k leading submesh active rules a2a4 copy q k attempts use bus else copy comes critical submesh rule r2 active copies slice use vertical buses conflict arise next show conflicts arise vertical buses supposing contrary let largest subscript broadcast conflict occurs copy q k slice broadcasts vertically assigned bus without loss generality assume q k belongs r ij1 conclusion lemma 45 along maximality imply copy q k submesh r igamma1j1 also using vertical bus implies neither r igamma1j1 r ij1 leading submeshes respect q k slice igamma1 respectively however r igamma1j r ij r ij1 must critical respect q k contradicting lemma 45 important note total number active copies query q k 2 follows immediately lemma 46 since assignment buses active copies q k leads two copies using bus since copies q k assigned horizontal buses copies q k assigned vertical buses conclusion follows next one may wonder active copies query q k carry enough information yield correct overall solution q k answer natural question provided following results lemma 47 let q k search query let item closest q k exists active copy q k submesh r ij either oei j proof assumption must solution oep q q k submesh r pq fact since items matrix necessarily distinct possible solution q k number submeshes assume without loss generality case submeshes slice specifically let r ij leftmost submesh oei j k copy q k r ij active nothing prove shall therefore assume copy q k r ij inactive propose show least one copies q k r ij gamma1 r ij1 active since copy q k r ij inactive 4 guarantees r ij cannot critical respect q k therefore v b v denoting respectively item northwest southeast corner r ij notice oei j along 9 implies must either v b v symmetry allows us assume without loss generality v turn implies notice 10 along fact copy q k r ij inactive guarantees virtue a4 j 6 1 thus r ij must exist let u b u respectively items northwest southeast corner r ij gamma1 r ij leftmost submesh since matrix sorted must moreover cannot q k b u otherwise a2 combined would guarantee copy q k r ij must active therefore must case however equations 4 11 12 combined imply copy q k r ij gamma1 must active desired completes proof lemma 47 lemma 47 suggests obvious way updating solutions active copies search query q k spell details follows ffl active copy q k belongs critical submesh r ij r ij gamma1 critical copy q k r ij updates solution oei j combining ffl active copy q k belongs critical submesh r ij r ij1 critical copy q k r ij updates solution oei j combining ffl copy q k active rule a2 updates solution oei j combining lemma 48 let q k rank query active copies q k generic slice carry enough information compute number items strictly smaller q k proof first copies q k slice active sum local solutions oei j exactly number items strictly smaller q k assume therefore copies q k slice active consider active copy q k leading submesh respect q k ffl copy active rule a4 solution must 0 correct number items strictly smaller q k ffl copy active rule a3 solution updated read mn correct number items strictly smaller q k ffl copy active rule a1 a2 solution updated read oei correct number items strictly smaller q k submeshes r i1 important note solutions active copies q k changed updates thus required updates collection active copies q k slice carry enough information correctly compute number items smaller q k conclusion follows r r 11 fig 11 illustrating target data movement stage 3 next task stage 3 move active copies queries diagonal submeshes r ii 1 illustrated figure 11 task performed two broadcast rounds follows first round proceed row row submesh r ij specifically active copies queries first row r ij assigned vertical buses broadcast local solution bus corresponding processor diagonal submesh r jj following queries second row broadcast vertically lemma 46 broadcast conflicts arise since every r ij rows first round takes p time second broadcast round involves broadcasting along horizontal buses time columns every r ij handled one one since columns submesh second round takes time note ever illustrated figure 12 possible two active copies query q k sent location diagonal submesh r jj one copy via horizontal bus one via vertical bus lemma 46 number copies restricted two fur thermore one arrive one broadcast round vertical buses second arrive horizontal buses processor receiving proceed combine respective solutions summarize state following result fig 12 illustrating combining solutions lemma 49 solutions active copies queries q broadcast diagonal submeshes r ii one per processor time complete algorithm various copies queries q moved diagonal submeshes collected combined idea move active copies query diagonal submeshes r ii one several adjacent rows original mesh specifically case p copies first moved first row mesh copies second group moved second row mesh hand case copies q 1 moved first rows mesh per row data movement cases similar discussed next preparation data movement need introduce terminology consider generic copy query q k associate q k quantities rq k cq k referred rvalue cvalue q k rq k identity row mesh copy navigate cq k relative position query among copies moved row rq k note processor storing q k compute rq k cq k o1 time recall beginning stage 3 every submesh r ij queries sorted rowmajor order thus solutions stored diagonal submeshes r ii relative order using vertical buses copies queries first row every submesh r ii moved row mesh corresponding rvalue specifically generic copy query q k stored processor p broadcast vertically processor p rq k j crucial note queries also sorted rowmajor order rvalues broadcasting conflicts arise proceeding sequentially p rows r ii processed described thus p time copies broadcast row mesh corresponding rvalue important observe processor receive one copy query data movement processing takes place row mesh depends whether 13 14 holds first assume 13 true shall detail processing takes place first row mesh action performed parallel rows copies q 1 broadcast processor p 1 1 order cvalues upon receiving next copy q 1 p 1 1 combines corresponding solutions obvious way since copies q 1 solution query q 1 obtained time copies remaining queries q moved row 1 processed similarly therefore overall time needed solve queries case 13 holds bounded case 14 holds recall copies given query spread rows mesh discuss processing query q 1 others han dled parallel perfectly similar way copies q 1 moved rows copies row proceeding sequentially order c values copies q 1 first rows broadcast leftmost processor rows processors responsible combining solutions described lemmas 47 48 end information needed solve queries stored processors first column mesh specifically processors solutions corresponding query q 1 next group processors contain partial solutions corresponding query refer figure 13 illustration finally consider diagonal submeshes size theta illustrated figure 14 final step stage 3 dedicate diagonal submesh solving query q one broadcast partial results stored processors first column mesh moved along horizontal buses first column depicted figure 13 combining partial solutions query q 1 fig 13 partial solutions contained processors first column fig 14 illustrating submeshes amounts semigroup computation local using result olariu et al 33 computation performed olog final solution query computed routine matter move back first column mesh consequently case 14 holds overall running time algorithm bounded log since 16 running time algorithm case 14 holds satisfies log summarize state following result theorem 410 arbitrary instance bsr problem involving sorted matrix size n theta n set queries solved omaxflog n mg time mesh multiple broadcasting size thermore timeoptimal architecture v concluding remarks open problems matrix said sorted rows columns independently sorted instance batched searching ranking problem bsr short involves sorted matrix items totally ordered universe along collection q queries q arbitrary mix following query types search query q j one interested item closest q j rank query q j one interested number items strictly smaller q j bsr problem asks solving queries q work considered bsr problem matrix pretiled one item per processor onto mesh multiple broadcasting size n theta n queries stored one per processor first columns platform main contribution twofold ffl first proved algorithm correctly solves bsr problem must take least omegagammaeas flog n time worst case ffl second showed time lower bound tight mesh multiple broadcasting size n theta n developed novel interesting cloning strategy queries partitioned platform number interesting feature cloning strategy supported sortedness matrix always small set clones retrieved allow obtained overall solution query visibly cloning strategy perfectly general interesting direction research see datasets strategy works yet another direction see practical applications benefit strategy acknowledgement authors wish express appreciation three anonymous referees exceptionally thorough reviewing job r optimal bounds finding maximum array processors k global buses computer vision square meshes always optimal design massively parallel processor square meshes optimal convex hull computa tion unifying look semigroup computations meshes multiple broad casting fast selection algorithm meshes multiple broadcasting square meshes optimal convex hull compu tation designing efficient parallel algorithms mesh connected computers multiple broadcasting efficient median finding application twovariable linear programming meshconnected computers multiple broadcasting upper lower time bounds parallel random access machines without simultaneous writes complexity searching x parallel algorithms searching x pattern classification scene analysis parallel search sorted multisets generalized selection ranking sorted matrices communications acm array processor multiple broadcasting image computations meshes multiple broadcast sorting x ieee transactions computers parallel processing letters efficient vlsi architecture digital geometry ieee transactions parallel distributed systems channel routing vlsi bitonic sort meshconnected parallel computer data broadcasting simd computers optimal convex hull algorithms enhanced meshes amt dap 500 image database systems survey tr ctr susumu matsumae nobuki tokura efficient selfsimulation algorithm reconfigurable meshes proceedings twelfth annual acm symposium parallel algorithms architectures p216223 july 0913 2000 bar harbor maine united states dharmavani bhagavathi himabindu gurla stephan olariu larry wilson james l schwing jingyuan zhang time vlsioptimal sorting enhanced meshes ieee transactions parallel distributed systems v9 n10 p929937 october 1998 r lin olariu j l schwing bf wang mesh hybrid buses efficient parallel architecture digital geometry ieee transactions parallel distributed systems v10 n3 p266280 march 1999
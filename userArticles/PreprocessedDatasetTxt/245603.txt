application petri net reduction ada tasking deadlock analysis abstractas part continuing research using petri nets support automated analysis ada tasking behavior investigated application petri net reduction deadlock analysis although reachability analysis important method detect deadlocks general inefficient even intractable net reduction aid analysis reducing size net preserving relevant properties introduce number reduction rules show applied ada nets automatically generated petri net models ada tasking define reduction process method useful description detected deadlock state obtained reduced nets information reduction tool experimental results applying reduction process discussed b introduction one major difficulty faces developers concurrent distributed software analysis concurrency based faults like deadlocks techniques analysis generally limited applicability due high complexity interesting analysis problems example reif smolka 1 prove undecidable npcompleteness results reachability problems various models communicating processes rauchle toueg 2 provide pspacehardness result deadlock detection bounded communication channel model communicating finite state machines regards concurrency analysis models based ada tasking taylor 3 proved npcompleteness results related classical static deadlock detection problem work supported part office naval research onr grant number n0001490j1446 national science foundation nsf grant numbers ccr8913580 ccr9321743 earlier version paper published proceedings 10th international conference distributed computing systems despite difficulty concurrency analysis problem number techniques proposed especially static analysis ada tasking 416 previously defined petri net framework type analysis 6 developed toolkit supports approach 10 architecture toolkit called total shown fig 11 fets frontend translator subsystem translates ada source ada tasking language atl design descriptions 10 petri net format ie set appropriately labeled place nodes transition nodes arcs refer resulting petri net original ada net nets suitable analysis programs composed static set tasks bids backend information display subsystem defined receive users queries present tasking analysis results based analysis ada net 11 bids uses different support tools carry desired analysis example deadlock detection using method described 9 would invoke tool calculate net invariants approach subject paper bids first invokes net reduction tool uses reachability graph generator tool unlike pure static analysis methods ignore variables approach model boolean variables increase accuracy analysis general implications using static analysis discussed elsewhere 410 petri netbased tools aimed ada analysis proposed including one developed software productivity consortium spc primary concern work performance modeling 12 taylors concurrency history method 4 one earliest ada tasking analysis methods discussed 6 definition concurrency graph similar classical reachability graph petri net goal taylors paper propose systematic method generating programs concurrency history general analysis concerned methods improving analysis effectiveness specific type analysis like deadlock concern yet taylors work also simplifies model focusing synchronization concurrency issues long clarke 5 introduced task interaction graph tig representation creating concurrency graphs smaller created taylors method provide experimentally based comparison tigbased results reductionbased results section 8 goal tig work similar although feel method advantage based model theoretically mature continues widely actively studied supported many available tools also approach distinguished methodology first deriving semantically rich model independent specific analysis issue manipulating model algorithms designed specific analysis issue concern recently dwyer et al presented compact petri net representation concurrent programs based tig model 17 standard deadlock preserving petri net reduction techniques cannot applied nets forms deadlock preserving reductions applicable nets suggested analysis methods shown particular promise handling reasonably large examples include use binary decision diagrams bdds represent symbolically state space 1819 use special petri net concepts stubborn sets petri net transitions 20 partial orders petri net transitions 21 net symmetry 22 bddmethods successfully applied hardware system analysis yet clear directly suitable method concurrent software analysis methods mentioned well defined petri nets exploit particular type concurrency defined adas tasking model work 23 explores use methods ada nets paper consider analysis classical case global deadlock detection ie tasks blocked context petri net approach straightforward way detect deadlocks would generate ada nets reachability graph search reachability graph states successor states easy implement toolkit system 10 computationally expensive since complexity generating reachability graph safe net exponential number nodes 24 previously studied use petri net structural invariants aid deadlock detection ada tasking 9 keeping research technique ie seeking exploit adapt existing general petri net theory paper consider reduce computation deadlock analysis use another petri net technique net reduction model reduction method experimental results indicate technique quite powerful significantly extend range problem sizes handled found reduction method compares favorably automated tasking analysis methods especially also rooted explicit reachability analysis addition found model reduction method facilitates use state reduction methods combination model reduction followed state reduction allows problems 100 tasks analyzed experimental results problems fare well comparison results reported constrained expressions tool 816 pal tool based using process algebra compositional analysis 15 automated methods know shown able analyze ada program 100 tasks early work reduction graph models expressing concurrency reported gostelow et al 25 reductions based narrow set substitutions arbitrary graph models comprehensive set petri net specific reduction rules later presented berthelot 26 work adapts berthelots rules specific modeling domain ada tasking casts rules technique tool specific software analysis problem deadlock analysis 2 background petri nets ada nets net reduction paper assume reader basic understanding petri nets 2427 general knowledge ada tasking 28 section provides background three areas terminology notations petri net theory presented terminology properties ada nets introduced idea petri net reduction explained definition 21 general petri net 5tuple pnp f w 0 p finite set place nodes finite set transition nodes f set arcs flows defined f pt tp w weight function defined w initial marking state defined 0 pin n stands set positive integers set nonnegative integers petri net restricted w f 1 ie arc weights always equal one called ordinary petri net definition 22 petri net pn x xyf xy yxf xy pt x place transition x input transition place set x x output transition place set x definition 23 petri net pn marking state mapping pin marking state graphically represented assignment tokens shown small black dots places notation mp denotes number tokens place p marking definition 24 given marking petri net pn transition tt p mp wpt said enabled note ordinary net transition enabled p mp 0 definition 25 petri net pn transition enabled marking fire resulting new marking 1 p wtq note ordinary net firing transition results new marking 1 p definition 26 petri net pn marking said reachable marking exists sequence markings ji results firing enabled transition marking ji1 i12 k sequence transition firings leads marking marking called transition firing sequence definition 27 petri net pn set reachable markings denoted rpnm 0 marking reachable 0 definition 28 petri net pn said safe number tokens every place exceed one reachable marking ie mrpnm 0 pp mp1 definition 29 petri net pn deadlock exists reachable marking transition enabled petri net derived ada tasking program translation scheme 610 called original ada net original ada net models number communicating finite state machines communication based adas notion rendezvous state machine represents local control flow task intertask communications represented extra nodes connecting different state machines control flow constructs ifelse case loop modeled structures state machines control flow construct impact choice tasking construct like entry call accept statement translation algorithm produces original ada nets uses set petri net templates corresponding ada statements details translation given 6 simply describe key features ada nets germane upcoming discussion reduction original ada net place automatically labeled translation program welldefined role modeling programs behavior place label prefixed keyword indicating type place label also contains statement number example template entry call statement shown fig 21a accept statement accept body shown fig 21b accept statements without accept bodies modeled compact way seen example fig 22 generally rendezvous represented net structure shown fig 21c model directly synchronize entry place accept place following reason model created automatically translation source code chose entry call construct models making entry call separate accept construct models accepting call made convenient translation algorithm also provides model distinguish task made call yet accepted task ready make call explain bit upcoming example definition 210 ada net call place label prefixed string begin wait accept entryex select beginplace waitplace acceptplace entryexplace selectplace respectively method construction original ada nets following characteristics 610 original ada nets ordinary safe petri nets original ada nets linear number nodes respect statements corresponding ada program places contain token initial marking represent beginning tasks control flow beginplaces defined decision statements ifelse case statements local control flow represented branching net structure ie place multiple output arcs every branching net structure least one branch choice contains net structure communication statement translation algorithm ignores decision statement involve intertask communication give reader feel labeling convention used ada nets sense net reduction use example program called gas station program 29 statement numbers part program used reference example 21 gas station program 1 task body customer 10 task body pump 20 task body operator 3 loop 12 loop 22 loop select 5 pumpstart 14 accept start 24 accept prepay 6 pumpfinish 15 accept finish 25 pumpactivate 8 end loop 17 end finish 27 9 end customer 28 accept charge original ada net structure corresponding 3task program shown standard petri net graphical form fig 22 purpose later reference token distribution shown figure 22 indicates deadlock marking rather initial marking ada net give following interpretations place labels appearing ada net shown fig 22 note place label ackentryoperator4 abbreviated aeo4 figure ackentryoperator4 entry call line 4 made yet accepted operator task entry call line 4 executed calling task waiting acknowledgment operator task call may may accepted yet rendezvous progress entry executing entry call line 6 accept statement line 15 original ada nets intended serve base model general tasking analysis discussed 10 deadlock analysis observed original ada nets contain atomic steps transitions strictly necessary model tasking semantics example endloop transitions aid translation process part effect reduction discussed paper remove extra steps hand also net structures example places unnecessary deadlock analysis may supportive forms analysis example waitplace marked indicates task made entry call waiting response distributed environment may correspond states request message transmitted states remote task performing service states acknowledgment message sent calling task determine maximum number entry calls waiting simultaneously search state contains maximum number marked wait places petri net researchers developed various reduction techniques general petri net analysis 26 petri net reduction aims transform given petri net pn another petri net pn pn easier analyze algorithmically typically means pn smaller reachability graph pn illustrate show fig 23 net produced applying net reduction rules net fig 22 important observe reduced net explicitly model task interactions defined source program ada net fig 22 instance source program specifies 6 entry calls 6 accept statements yet reduced net contains 4 transitions definition reduction rules introduce true reduced net preserve deadlock characteristics original ada net definition 211 net derived original ada net number reduction steps using reduction rules presented paper called reduced ada net reduced ada net called fully reduced ada net reduction rule applied ada net either original ada net reduced ada net fully reduced ada net fully reduced ada net unique depends interplay reduction operations applied 3 general reduction rules practical use ada nets selected 26 transition fusion reduction rules applicable general petri nets interest fact rules preserve deadlock properties net ie deadlock state preserved new deadlock state introduced furthermore rules preserve safeness net rigorous proofs found 26 use rules proposed 26 high computational complexity ie computationally expensive check applicability rules section also introduce simple rule 27 allows removal place transition cases exist parallel redundant nodes next section derive reduction rules special case rules useful ada nets note whenever reduction rule calls removal node place transition implied incident arcs node also removed rule 1 postfusion transitions 26 nonempty subset g set transitions petri net postfusable another subset h iff exists place p following four conditions satisfied fg fp input f p pf p output f b hh ph p h p output input h c tthg p pt p disconnected transitions except belonging h g operation rule 1 fuse hh fg producing transition h h p deleting p transitions thg conditions b imply hg fig 31 shows postfusion transitions h 1 h 2 f 1 f 2 reduced net consider firing every new transition firing sequence h f fire number firings transition reduced net original net rule 2 prefusion transitions 26 subset g set transitions petri net may prefused transition ht iff exists place pp following conditions satisfied h p p h p sole output h p input h b fg p f pf transitions g p input none p output c gh p pt p disconnected transitions q h q 1 h share input places transitions operation rule 2 fuse h fg substituting f f hp deleting h p fig 32 shows transition h fusing f 1 f 2 properties preserved prefusion rule 1 postfusion proof 26 applying rule 2 place p reduce number transitions net one number places one third reduction rule special case rule 1 explicitly specify easier apply commonly occurring fig 33 illustrates operation rule 3 rule 3 serialfusion transitions singleinputoutput place p token unique output place 1 unique input place p 2 pp 1 1 2 fused rule 4 parallel redundant nodes 27 two nodes two transitions two places without tokens x identical inputs identical outputs possibly empty pair parallel nodes either one nodes removed xy xy either x removed obvious rule 4 preserves deadlock safeness properties net 4 special case reductions ada nets intuitively place petri net considered redundant removal alter possible transition firing sequences net throughout paper removal redundant place p means p ps incident arcs removed benefit identifying places removal generally facilitate reductions involve transition fusions clearly safeness deadlock properties preserved removal redundant places unfortunately general efficient algorithm identifying place redundant berthelot gave formal structurebased characterization redundant place general petri nets 26 based existence place subset called iset meets certain conditions interest applying concept ada nets seek efficient rules special case instances berthelots characterization begin introducing general characterization specific case redundant place safe ordinary petri net first want establish fact ada nets always safe ordinary nets recall original ada nets safe ordinary nets construction noted earlier reduction rules introduced section 3 preserve safeness established berthelot 26 rule 1 always keeps ordinary net ordinary net safe start difficult see rules 2 3 4 keep ordinary net ordinary finally new rules introduce section remove nodes cannot change ordinary net one ordinary prove every node removed new rules redundant sense removal alter possible transition firing sequence safeness property nets preserved therefore concluded ada nets always safe ordinary nets important since want appeal general characterization redundant place safe ordinary net prove special case instances redundant places ada nets theorem 41 case 1 place redundancy safe ordinary net safe ordinary petri net pn place p redundant following conditions satisfied 1 exists b bp mrpnm 0 mb1 mp1 ie whenever b marked p also marked proof since output transition p p cannot impact firing transition except one necessary conditions enabled b marked condition 3 establishes whenever b marked p also marked removal p impact firing reachable marking meaning place p redundant theorem help define narrower class redundant places comparison general characterization given berthelot computationally expensive use theorem identify redundant place due behavioral condition implied condition 3 appeal theorem define special case instances redundant places ada nets remember original ada net place automatically labeled translation program welldefined role terms modeling programs behavior semantics net must correspond semantics ada program net sound model assume case paper exploit sense semantics identify cases condition 3 theorem must true thus cases simple efficient reduction rules since goal use rules define reduction process explain select ordering dependencies rules rule 5 redundancy waitplaces original ada net structure corresponding entry call statement waitplace redundant removed holds nets obtained applying rule one times original ada net proof fig 21a shows original ada net structure modeling entry call ackentry place represents call made yet accepted ackaccept place represents acknowledgment called entry indicate rendezvous terminating waitack place represents caller waiting termination acknowledgment appealing theorem 41 see conditions 1 2 theorem 41 true places p b represented places waitack ackaccept respectively ada semantics rendezvous terminating must previously initiated caller original ada net structure fig 21a easily seen rendezvous initiated caller waitack place become marked remains marked ackaccept place becomes marked therefore condition 3 theorem 41 also true waitplace redundant since removal waitplace associated entry call statement alter ada net structure entry call statement apply reduction one times ie waitplaces importance rule 5 case rules 6 7 provides opportunity reductions apply illustrate let us consider example 41 corresponding ada net shown fig 41a example 41 9 end t2 applying rule 5 remove immediately waitackt23 waitackt212 applying rule 3 results net fig 41b reduction process deadlock detection always apply rule 5 first meaning remove waitplaces first step reduction process rule 6 redundancy entryexplaces original ada net structure corresponding accept statement corresponding entryexplace redundant removed accept statement one caller holds nets obtained applying rule one times original ada net proof fig 21b shows original net structure modeling accept statement endaccept place represents accepting task reached end accept body ready terminate rendezvous initiated call entryexji place represents particular rendezvous progress rendezvous associated particular entry call statement particular accept statement j appealing theorem 41 see conditions 1 2 theorem 41 true places p b represented places entryexji endaccept respectively ada semantics task reaches end accept statement must corresponding rendezvous progress case accept statement one possible caller one corresponding entryex place shown case fig 21b contrast multiple caller case shown example fig 41a thus whenever endaccept place marked place marked condition 3 theorem 41 true entryexplace redundant since removal entryex places alter net structures associated accept statements recall structures fig 2 removal places affect application rule 6 structures apply reduction one times clear removal waitplace affect validity applying rule 6 corresponding entryex place reduction process always apply rule 6 possible applications rule 5 could well chosen define reduction process start applications rule 6 followed rule 5 important difference introduce second theorem generalization theorem 41 appealing theorem prove two special case rules application ada nets theorem 42 case 2 place redundancy safe ordinary net safe ordinary petri net pn place p redundant following conditions satisfied 1 r 2 every transition ok p k1 2 r place q ok p q ok ok k1 2 r mp1 ie q ok place marked state p also marked state fig 42 contains example net structure corresponds structure defined theorem 42 case r2 time one ignore labels nodes defined theorem 42 proof condition 2 safeness property net imply reachable state one q ok places marked one places could marked one associated enabled transitions could fire resulting marking q ok place still marked place p marked would contradict condition 2 infer reachable marking p impact firing one transition call necessary condition enabled corresponding q ok marked since condition 2 establishes whenever q ok marked p also marked removal p impact firing reachable marking meaning place p redundant present two rules appeal theorem 42 identify specific cases redundant places occur ada nets next two rules applied time reduction process since rules depend ada net issues help identify candidate places labeling check applicability rule improves efficiency reduction process example rule 7 directs attention acceptplaces particular ada net indicates task calls two consecutive entries another task net structure enforces called tasks control flow simplified removal one acceptplaces called task rule 7 redundancy acceptplaces ada net let p acceptplace pt i1 i2 ik p o1 o2 ok 0 p0 exists another acceptplace q q p p q correspond two accept statements task place p removed following conditions also satisfied 1 transition ik p k 1 2 r exists corresponding transition ok p ik p q ik ok p q ok pair places q ik q ok correspond statements task k kt pair transitions ik ok defined condition 1 ik always fires first ik cannot fire twice without firing ok ok cannot fire twice without firing ik fig 42 illustrates net structure corresponding rule 7 case r2 proof without loss generality refer fig 42 illustrates net structure corresponding rule 7 case r2 seen easily condition 1 rule 7 establishes structural conditions theorem 42 behavioral condition specified condition 2 theorem 42 shown true follows ik enabled marking mp0 otherwise p may contain multiple tokens net would safe previously established ada nets safe nets thus transition ok enabled marking whenever transition ik fire p becomes marked case ok fires transition ik fire otherwise net safe condition 2 ensures transition ok fire thus token place p removed transition ok fires note transition ok cannot enabled unless place q ok marked therefore mrpnm 0 mq ok 1 k1 2 r mp1 conditions theorem 42 hold example 42 fig 22 gas station example used illustrate simple case redundant acceptplace defined rule 7 using notation rule 7 let accept15 correspond place p let accept14 correspond place q checking figure seen q p r1 example task defined rule task contains two accept statements question pump task seen source code given section 2 considering condition 1 transition t14 corresponds i1 transition t15 corresponds o1 task customer corresponds task 1 checking condition 2 see corresponds q i1 ackentrypump6 t15 corresponds q o1 ada net model task customer easy confirm every iteration transition t14 fires t15 fires implying execution statement 5 must precede execution statement 6 condition 2 true thus rule 7 accept15 redundant place implement rule 7 need automatically check conditions rule condition 1 difficult check since correspondence places ada net statements ada program well defined based type place labeling used discussed earlier assuming condition 1 true main difficulty checking condition 2 without loss generality consider checking condition 2 one calling task ie r1 let us denote statement corresponds place q ik s1 statement corresponds place q ok s2 condition 1 s1 s2 belong task call task k mentioned section 2 ada net contains subnets communicating finite state machines representing local control flow task subnet consists places correspond statements particular task input output transitions places arcs associated place transition nodes condition 2 checked confirming following two properties subnet corresponding task k directed paths starting beginplace task k place q ok go place corresponding statement s1 b loop subnet corresponding task k contains place q ok loop must also contain place corresponding statement s1 confirm properties temporarily remove every place corresponds statement s1 perform two searches 1 search path starting begin place task k place q ok 2 search loop starting q ok leading back q ok searches fail condition 2 satisfied otherwise condition 2 satisfied rule 8 redundancy acceptbody places safe ordinary petri net pn place p redundant following conditions satisfied 1 pp r 2 transition ik p k1 2 r exists unique place q ok p q ok ik q ok 1 every transition ok p k1 2 r ok p q ok 0 pm 0 q ok 0 k1 2 r ada nets structure representing acceptbody modeled single place p multiple callers good candidate instance redundancy conditions hold place p removed proof rule 8 special case theorem 42 q ok ik clearly structural conditions theorem 42 true establish condition 2 theorem 42 follows since q ok ik ik p q ok gets marked p ii since p o1 o2 token p removed transition ok k1 2 r fires iii marking mq ok mp1 transition ik k1 2 r fire otherwise p one token safeness property hold thus one q ok place marked reachable marking iv ii iii token p removed ok fires remove token p q ok simultaneously therefore mrpnm 0 mq ok 1 k1 2 r mp1 conditions theorem 42 hold let us return fig 41b rule 8 allows us remove place endaccept8 serial fusions lead reduced ada net fig 43 final rule simple rule applies marked places removes places transitions restricted conditions rule 9 redundancy beginplaces safe ordinary net exists place bp 0 b1 b t1 b b removed dt 0 set 1 ada nets beginplaces initially marked input transitions used candidates place b proof marking every output place removing equivalent firing since tb b marked initially fire initially since b fire transition firing sequence case removal nodes b reassignment tokens defined change safeness deadlock properties net note possible rule 9 reduce net isolated marked place would represent deadlock state different reduction rules applied net rule 9 applied last since rules rules 1 8 assume places unmarked rule 9 induce marking marking could lost reductions allowed rule 9 applied 5 reduction process method deadlock identification apply reduction rules discussed previous sections define reduction process deadlock detection identification ada nets process starts original ada net applies rules particular order preserve soundness reduction process respect rules 5 8 follow rule ordering consistent mentioned section 4 ordering defined follows repeatedly apply rule 5 apply sequence rules 6 7 8 rules 3 2 1 4 repetitively applied order none four rules applied finally rule 9 applied deadlock identification requires able interpret program state corresponding detected deadlock marking reduced ada net difficulty arises reduction process removes places whose labels helpful defining semantics program state corresponding reachable marking fortunately provide method easily constructing original ada nets deadlock marking reduced nets deadlock marking method based application petri net state equation 27 0 initial marking net incidence matrix 27 net v firing count vector firing count vector mvector number transitions net element number times corresponding transition fired 27 given 0 v equation 51 returns marking net reach transitions represented v fire concern obtain v terms original ada net reduction application transition fusion rule rule 1 2 3 remove transitions generate new transitions transitions fused labels concatenated newly generated transition fusion transitions labeled concatenation kind label concatenation immediately gives us firing count fused transition ignores firing order every transitions label original ada net appear labels reduced ada net rule 9 applied labels easy generate firing count vector x search deadlock reachability graph however rule 9 applied transition labels lost saw section 4 removal transition rule 9 means transition fired thus generate another mvector removed fused transition containing removed rule 9 substituting vectors x forv equation 51 obtain full description deadlock marking original ada net incidence matrix original ada net 0 nets initial marking example next section illustrates method record state sequence transition sequence leading deadlock state either reachability graph construction states net sequence defined respect reduced ada net provide interpretation state sequence terms programs execution sequence apply basic method defined interpreting deadlock state would applying interpretation intermediate states since necessary transition information initial state well defined method still sound 6 example deadlock detection identification explain reduce net fig 22 initial marking beginplaces marked one token fig 23 use new net detect identify deadlocks first rule 5 remove waitplaces rule 6 remove entryexplaces entryex244 entryex2816 entryex156 rule 7 remove accept place accept15 first apply rule 3 rules 1 2 many groups transitions place accept14 removed rule 4 becomes parallel place place ackentrypump5 reduced ada net shown fig 61 finally apply rule 9 fully reduced ada net shown fig 23 marking corresponding deadlock state reachability graph reduced ada net fig 23 shown fig 62 composed 4 states chain deadlock state corresponds marking token place ackentrycustomer29 comparison note reachability graph original ada net 78 states token allocation fig 22 shows deadlock marking original net represented following string waitackpump6 entryex156 waitackoperator16 entryex2816 ackentrycustomer29 deadlock marking easy interpret corresponding program state circular deadlock task customer rendezvous task pump entry finish statement 6 task pump rendezvous task operator entry charge statement 16 task operator issued entry call customerchange statement 29 number marked waitplaces gives number tasks waiting state using method outlined section 5 also identify deadlock fully reduced ada net path initial state deadlock state reachability graph fig 62 identifies fired transitions t14t6t7t15t16t28t29 thus following firing count vector respect 31 transitions positions vector correspond following ordering transitions t1t21 t23t26 t28t33 reasons unimportant paper original ada net transitions labeled t22 t27 application rule 9 removes fused transitions containing t1t2t3 t11t12 t20t21 compare fig 61 fig 23 yields another vector defined reduction process every place p applying equation 52 defined section 5 obtain marking vector represents state string 61 7 net reduction tool experimental evaluation implemented prototype reduction tool compatible current research toolkit used construction evaluation ada nets 10 mentioned section 1 toolkit automates construction ada nets supports various forms netbased analysis including reductionbased analysis ada nets represented textual productionrule form compatible format petri nets input pnut system 31 set petri net tools allows description nets well reachability graph generation analysis simulation textual representation net transition specified production rule lefthandside gives transition label enclosed colons followed names input places righthandside gives names output places net reduction tool nrt implemented c runs sunos unix major input nrt ada net produced fets tool output nrt reduced version input ada net textual format nrt executed following command nrt r n 1 2 3 4 5 6 r option calls output report every reduction rule attempted applied n option calls output list intermediate nets produced reduction process final option specifies id numbers used earlier sections paper reduction rules attempted order consideration rule 9 automatically attempted last example 132 means first rule 1 considered ie repetitively applied reductions possible rule rule 3 considered rule 2 considered finally rule 9 considered typical use nrt provide id option case rules applied order defined reduction process discussed earlier section 5 evaluate net reduction method performed number experiments variety ada tasking programs experiments provide quantitative measures effect using net reduction method associated tools deadlock analysis experiments particular dining philosophers example measures compared existing data different tasking analysis approach toolset comparison intended show benefit using reduced concurrency model performing deadlock analysis since reduced ada nets intended support deadlock analysis meaningful interpret comparative data broader sense discuss two types experiments using nrt tool first experiments evaluate idea net reduction using different versions two benchmark tasking programs gas station program 1 dining philosophers program experiments net reduction followed full reachability graph generation mentioned gives opportunity see comparison effectiveness reduction method deadlock analysis comparison another reachabilityoriented automated ada tasking analysis technique second experiments evaluated effectiveness using net reduction method conjunction existing state space reduction methods ie methods reduce state space state space 1 source versions used developed provided us g avrunin experimental work constrained expressions analysis method generation contrast reduction method performs reductions net model prior state space generation types experiments observed significant benefit net reduction method net reduction example ada nets resulted 95 reduction state space size comparing original net state space fully reduced net state space analysis reduced ada nets accurately reported existence nonexistence deadlock examples considered recall reduction gain due removal atomic steps transitions strictly necessary model tasking semantics discuss amounts state space reduction achieved terms original vs reduced nets significant measures related resultant state space sizes comparison reduced nets tasking models rely reachability analysis analysis time experiments run using reductionbased analysis tools sun sparcstation 2 64mb memory fully reduced nets give number unique states number arcs reachability graph indicates number states generated time reduce net plus generate state space seconds measured usersystem time unix experiments time reduction step small fraction time generate state space always less one second lack space prevents us listing source code examples studied available authors 71 net reduction full reachability graph generation 711 gas station example gas station program simulates automated gas station system consisting operator pumps customers consider onepump twopump versions system programversions deadlock cases used unrolled versions different customers call different entries operator task operator task uses boolean variables keep track customers prepayed gas control automatically modeled ada nets current programtonet translator yet handle general use counter variables reachability graph generator tool intelligent enough consider transition sequences correspond boolean variable evaluations atomic actions thus states corresponding interleavings evaluation steps stored cannot correspond deadlock state issue discussed detail 23 deadlock cases created operator improperly handle flag variable indicates pump busy result customer finishes pumping paying operator still thinks pump busy allow customer get access pump experiments reported 23 introduced deadlocks slightly different way table 1 shows sample data based varying number customers number pumps potential deadlock customers pumps tasks deadlock fully reduced ada net reachability graph states arcs time table 1 experiments gas station program 712 dining philosophers example wellknown dining philosophers problem experimented different versions become standard examples number different concurrency analysis research projects examples especially relevant paper since allow quantitative comparison approach another statespace oriented analysis technique modified optimized version task interaction concurrent graphs ticg method 3233 assume reader familiar dining philosopher problem program simulating n philosophers consists 2n ada tasks one philosopher one fork four versions program discussed 3233 version 1 classic dining philosopher problem without deadlock avoidance table 2 shows comparisons state space sizes fully reduced ada net model published data modified ticg models 33 note fully reduced ada net problem number states 2 p p number philosopher tasks modified ticg model number states 3 p 1 remember ticg model general model terms preserving tasking properties beyond deadlock potential version 2 philosopher picks lowernumbered fork first similar situation reported 32 state space version 2 approximately equal size version 1 version 3 dining room butlertask added restricts number room occupants less n checking value counting variable thus deadlock happen however deadlock superfluously reported version pure static analysis counting variable modeled although static analysis case reveals false deadlock numerical results respect state sizes still compared reduced ada net model modified ticg model since models ignore counting variable table 3 shows comparison state space sizes version 3 provide check reduction method manually added nodes automatically generated original net models simulate control enforced butlers counting variable example counter could take values 0 10 would add 11 places ada net modeling unique value counter expected experiments nets showed superfluous deadlocks suppressed modified models state space sizes reduced nets obtained modified net model shown rightmost column table 3 reachable states phils tasks fully reduced ada net states arcs time modified ticg 33 states arcs time difference states approx 14 28 16384 172032 8 available 18 36 262144 3538944 175 available 20 40 1048576 15728640 894 available table 2 dining philosophers problem version 1 reachable states phils tasks fully reduced ada net ignoring variables states arcs time modified ticg 33 ignoring variables states arcs time difference fully reduced ada net simulating counting states arcs time 4 9 256 960 1 832 2964 3 69 175 524 1 10 21 1048576 9830400 656 available 989527 7274662 711 table 3 dining philosophers problem butler version 3 young et al 32 provided another program version version 4 dining room butlertask simulates counting variable unrolling selectivewait statement idea simulate variable values levels nesting selectivewait statements thereby avoiding spurious deadlocks state space analysis surprise analysis tool reported deadlock states version 4 number philosophers two investigation realized program error could indeed deadlock since method unrolling butlers selective wait provided 32 may allow n philosophers occupy room simultaneously 33 program corrected butlertask given analysis tools properly detected deadlocks corrected version 4 program table 4 summarizes results using ticg data reported 33 corrected unrolled butler task expected number fully reduced net states using unrolled butler number net states given table 3 net model simulates butlers counting variable comparisons show significant advantage state space sizes reduced nets comparison ticg model indicates philosophy using specific model specific problem useful strategy analysis inherently complex problems see benefit using problemspecific reduced model comparison unreduced ada net models independently developed concurrency analysis model number reachable states phils tasks fully reduced ada net unrolled butler states arcs time modified ticg 33 states arcs time difference 4 9 175 564 1 511 1543 3 66 7 15 14197 88809 7 104679 625873 1099 86 8 17 58975 427368 33 available 1995327 165 available 10 21 989527 9108690 910 available table 4 dining philosophers problem unrolled butler version 4 713 waveform generator example see reduction process works real world example obtained example ada program developed solve real problem designed purpose testing particular concurrency analysis method example perform hand modifications ada source order get proper net model program primarily due presence ada specific constructs like packages translator designed handle waveform generator program 1200 line ada simulation electric equipment generates various waveforms one programs used 23 experimentally studying various state space reduction methods including net reduction indicated 23 two versions program created two versions numbers states arcs reachability graphs corresponding original ada nets 10996 states 32332 arcs 4827 states 14250 arcs fully reduced ada net corresponding numbers states arcs reduces 78 states 326 arcs 31 states 242 arcs state space generation time cases 2 seconds noted numbers states arcs quoted original ada net slightly smaller full state space numbers given 23 due fact consider particular type original net reduction related selectivewait structures part net generation process part net reduction process used deadlock detection done 23 course either way reduction process provides significant benefit reducing size state space 72 net reduction state space reduction second series experiments looked effectiveness using net reduction method support recently proposed reduced state space generation methods particular considered three reduced state space generation methods stubborn sets petri net transitions 20 partial orders petri net transitions 21 net symmetry 22 basis experiments generate original ada nets set ada programs apply reduced state space generation methods ada nets applied net reductions original ada nets applied reduced state space generation methods time reduced nets examples considered included first experiments versions gas station program versions dining philosophers program well versions readerswriters program example traditional dining philosophers problem n philosophers combination net reduction stubborn sets generates states combination net reduction symmetry generates n states observed cases ie programs reduced state space generation method significant benefit using net reduction method prior applying reduced state space generation effect reduction step increases utility state generation methods applied deadlock analysis ada tasking full details experiments using reduction reduced state space generation methods found 2334 noted reduction method used 34 bit less powerful method described paper particular rule 6 defined paper general rule used experiments reported 34 example state space numbers reported dining philosophers problem better ie smaller paper comparison numbers reported 34 use net reduction reduced state space generation appears powerful combination deadlock analysis ada tasking make following observations based comparison experiments experiments reported two fully automated analysis tools also avoid full state space generation constrained expressions toolset 816 pal tools 15 approaches shown capable handling dining philosophers problem 100 philosopher tasks dining philosophers problem without butler task combination net reduction followed reduced state space generation also capable handling problems 100 philosophers fact stated one combination provides state space size grows linearly number philosophers 23 knowledge work reports favorable outcome analysis problem work valmari tienari 35 using semantic model called chaosfree failuresdivergences cffd model approach compositional way similar pal system 15 using combination compositional analysis induction valmari tienari able analyze dining philosophers system generation constant number states although work important techniques effectiveness examples yet clear results cited require manual step recognizing use induction also unclear whether type inductive step leading constant state space size dining philosophers example easily automated general usage contrast analysis work using net reduction state space reduction fully automated comparing analysis time constrained expression pal tools compared methods find analysis effective effective two tools depending state space reduction method use following net reduction time single method established definite superiority terms automated deadlock analysis continued development comparative studies clearly necessary 8 conclusion commonly accepted major impediment static analysis concurrent programs complexity associated producing various forms state space representations presented method dealing matter optimizing model based two key ingredients focusing deadlock specific analysis issue adapting existing modelreduction technique petri net reduction result part ongoing research using petri nets support automated analysis ada tasking motivated belief much gained basing ada tasking analysis research model theoretically mature also continues widely actively studied already supported many available tools combining petri net theory knowledge ada tasking semantics derived domain specific thus efficient reduction rules petri net models ada tasking generally errorprone construct model optimize manually program analysis critical model produced reflect programs true behavior behavior programmer modeler desires thinks true program question furthermore model optimization benefit understanding analysis issues germane program compiler techniques support automation building correct models combination model building model optimization adds another dimension difficulty considering issues analyzed may vary widely apply twophase methodology fully automate modeling optimization first deriving semantically rich model independent specific analysis issue manipulating model algorithms designed specific analysis issue concern observed reduced ada net models promising aid deadlock analysis concurrent ada programs especially used combination reduced state space generation methods acknowledgments thank mr goto help development net reduction tool u buy helpful suggestions many aspects paper also thank young providing us copy reference 33 finally thank referees valuable comments greatly improved paper terms technical content presentation r complexity reachability distributed communicating processes exposure deadlock communicating processes hard detect complexity analyzing synchronization structure concurrent programs generalpurpose algorithm analyzing concurrent programs task interaction graphs concurrency analysis petri net framework automated static analysis ada tasking behavior describing analyzing distributed software system designs automated analysis concurrent systems constrained expression toolset detection ada static deadlocks using petri net invariants design implementation petri netbased toolkit ada tasking analysis tql tasking query language concurrent program analysis tools analyzing dynamic properties system software designs starvation critical race analysis ada compositional reachability analysis using process algebra controlling state explosion reachability analysis identical tasks counter variables integer programmingbased approach verification compact petri net representation concurrent programs generating bdds symbolic model checking ccs symbolic model checking 10 20 states beyond stubborn attack state space explosion using partial orders efficient verification deadlock freedom safety properties reachability analysis petri nets using symmetries application experimental evaluation state space reduction methods deadlock analysis ada petri net theory modeling systems proper termination flowof control programs involving concurrent processes checking properties nets using transformations petri nets properties analysis applications united states department defense debugging ada tasking programs theory application net reduction ada deadlock analysis interactive statespace analysis concurrent systems integrated concurrency analysis software development environment concurrency analysis tool suite rationale design preliminary experience using state space reduction methods deadlock analysis ada tasking improved failures equivalence finitestate systems reduction algorithm tr ctr changjun jiang huaiqing wang shaoyi liao behavior relativity petri nets journal computer science technology v17 n6 p770780 november 2002 ravi k gedela sol shatz haiping xu formal modeling synchronization methods concurrent objects ada 95 acm sigada ada letters vxix n3 p211220 sept 1999 george avrunin ugo buy james c corbett laura k dillon jack c wileden experiments improved constrained expression toolset proceedings symposium testing analysis verification p178187 october 0810 1991 victoria british columbia canada nick savoiu sandeep shukla rajesh gupta mtp petri netbased framework analysis transformation systemc designs proceedings 2005 workshop software compilers embedded systems p99108 september 29october 01 2005 dallas texas laure petrucci lars michael kristensen jonathan billington zahid h qureshi towards formal specification analysis avionics mission systems proceedings conference application theory petri nets formal methods software engineering defence systems p95104 june 01 2002 adelaide australia juan jeffrey j p tsai tadao murata yi zhou reduction methods realtime systems using delay time petri nets ieee transactions software engineering v27 n5 p422448 may 2001 haiping xu sol shatz framework modelbased design agentoriented software ieee transactions software engineering v29 n1 p1530 january juan jeffrey j p tsai tadao murata compositional verification concurrent systems using petrinetbased condensation rules acm transactions programming languages systems toplas v20 n5 p917979 sept 1998 jeffrey j p tsai alan liu eric juan avinash sahay knowledgebased software architectures acquisition specification verification ieee transactions knowledge data engineering v11 n1 p187201 january 1999
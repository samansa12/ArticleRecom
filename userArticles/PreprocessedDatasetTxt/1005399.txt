logicbased subsumption architecture describe logicbased ai architecture based brooks subsumption architecture architecture axiomatize different layers control firstorder logic fol use independent theorem provers derive layers outputs given inputs implement subsumption lower layers higher layers using nonmonotonic reasoning principles particular use circumscription make default assumptions lower layers nonmonotonically retract assumptions higher layers draw new conclusions also give formal semantics approach finally describe layers designed task robot control system implemented uses architecture control nomad 200 mobile robotour system combines virtues using representandreason paradigm behavioraldecomposition paradigm allows multiple goals serviced simultaneously reactively also allows highlevel tasks tolerant different changes elaborations knowledge runtime finally allows us give commonsense knowledge robots report several experiments empirically show feasibility using fully expressive fol theorem provers robot control architecture benefits claimed b introduction brooks 1986 rodney brooks provided decomposition problem robot control layers corresponding levels behavior rather according sequential functional form within setting introduced idea subsumption complex layers could depend lower reactive layers could also influence behavior resulting architecture one could service simultaneously multiple potentially conflicting goals reactive fashion giving precedence high priority goals realization hardware architecture lacks declarativeness making difficult implement higherlevel reasoning making semantics unclear furthermore increasing hardware complexity new layers introduces scaling problems fi nally relying hardware specifications architecture specifically oriented towards robot control applicable software agents softwarebased intelligent agents problem extending similar architectures complex tasks goals agents necessarily physical already raised discussed general lines minsky 1985 stein 1997 knowledge practical ai architecture developed along lines paper describe architecture modeled spirit brooks subsumption architecture relies logical framework wider applicability extendability manner described logicbased subsumption architecture includes set logical theories corresponding layer sense brooks archi tecture layer supplied separate theorem prover allowing system layers operate concur rently use approximation nonmonotonic reasoning model connections theories allowing layers make nonmonotonic assump tions layers performance independent performance layers thus supporting reactiv ity demonstrate architecture modeling brooks first two layers showing empirically layer greatest demand reactivity sufficiently fast 02 03 seconds per controlloop cycle empirical result shows generalpurpose theorem provers used intelligent agents without sacrificing reactivity remainder paper organized follows giving brief introduction brooks system logical ai describe general architecture embodies collection theories uses decoupling interactions exhibit complex behaviors describe representation first two layers brooks system describe subsumption general operation system implemented using theorem proving negationasfailure techniques give formal semantics approach using circum scription discuss implementation issues conclude comparisons related work sketch future directions work first step towards creating general logicbased ai architecture efficient scalable supports reactivity architecture longterm goal background 21 brooks subsumption architecture brooks showed decomposing system parallel tasks behaviors increasing levels competence opposed standard functional decomposition advantageous whereas typical functional decomposition might resemble sequence sensors task recognition motor control brooks would decompose domain follows avoid objects monitor changes identify objects plan actions reason object behavior increasing levels competence potential benefits approach include increased robustness concurrency support incremental construc tion ease testing underlying assumption complex behavior product simple mechanism interacting complex environment focus simplicity led design individual layer composed simple state machine modules operating asynchronously without central control general different layers completely dependent example decomposition wandering exploring depend robots ability avoid objects often system may able service multiple goals parallel despite depen dence however occasionally goals one layer conflict another layer instances would expect higher priority goals override lower priority ones address issue subsumption architecture provides mechanisms higher layers may interfere operation lower layers first possible higher layers observe state lower layers second possible higher layers inhibit outputs andor suppress override inputs modules lower layer consequently competent layers adjust behavior reactive layers time possible high priority tasks lower layer halting object deadahead continue high precedence simply allowing higher layers tamper particular tasks brooks 1986 brooks describes detail first three layers one particular robot control system implemented using subsumption architecture con cept first two shown figure 1 briefly describe three layers avoid basic layer system endows robot obstacle avoidance capabilities obstacle appears directly ahead robots path halts colliding general whenever obstacles vicinity uses direction distance respect robot compute new heading moves away obstacles much possible detail layer accepts sonar readings robots surroundings sonar module outputs map vicinity based read ings collide module checks obstacle directly ahead forces robot stop regardless modules feelforce module uses map calculate combined repulsive force surrounding objects exert robot runaway module checks force significant enough pay attention case determines new heading speed robot move away force turn module commands robot make required turn passes speed forward module halt state commands robot move forward specified speed away robot gets smaller speed computed runaway module wander wander layer consists two modules together avoid layer cause robot move around aimlessly otherwise oc cupied every often wander module chooses new random direction robot move avoid module combines output avoid layers feelforce module computing overall heading suppresses input avoid layers turn module hence wander mode active overrides default heading computed avoid layer explore layer begins add primitive goaldirected behavior robots repertoire robot periodically checks see idle chooses location distance head towards explore exploration mode inhibits wander layer remains less track towards destination however like wander layer takes advantage avoid layers capabilities prevent collisions dont model layer paper first two layers sufficient demonstrate proposal refer reader brooks 1986 details 22 logic circumscription since early days ai logic held promise serve main knowledge representation language future intelligent machine mccarthy 1958 last decade theorem provers became wide spread formal verification tools lately robot systems wielding logic emerged eg shanahan 1996gi acomo lesperance levesque 1997 logical paradigm mccarthys circumscription mccarthy 1980 one first major nonmonotonic reasoning tools since debut nonmonotonic reasoning line work expanded several textbooks exist give fair view nonmonotonic reasoning uses eg brewka 1991 antoniou 1997 brewka dix konolige 1997 dm gabbay 1994 sandewall 1994 shanahan 1997 motivations nonmonotonic reasoning vary formalizing common sense reasoning elaboration tolerance representing uncertainty belief revision expand motivations reader may look shanahan 1997mccarthy 1998pearl 1990 antoniou 1997 details directions mccarthys circumscription formula mccarthy feelforce runaway turn forward avoid wander collide sonar heading turn fwd object wanderheading encoders sensorreadings robot heading force robot robot speed figure 1 layers 0 1 brooks subsumption architecture robot control system says theory parameter relations function sequences minimal element ap z still consistent allowed vary z order allow p become smaller take example following simple theory circumscription block varying noth ing circt block equivalent minimizing block concluded blocks world mentioned original theory 3 logicbased subsumption architecture section dedicated describing proposed ar chitecture first give intuitive account approximation semantics system describe architecture detail give ideas goals embodied finally describe build system approximates brooks proposed way 31 intuition logicbased subsumption architecture lsa composed sequence logical theories supplied theorem prover theories communicates underneath sequence subsumed modifying controlling behavior lowerlevel ories aside collection theories sensors affect theories manipulators affected theories precisely results found theorem provers description follows assume architecture used control cylindrical robot sonar sensors perimeter wheels control motion sensors manipulators assumed stage want system based premises work loop follows first physical sonars collect data assert form logical axioms sonar readingsonar dist axioms added 1 appropriate theory sequence theories comprising system time assert input coming layer higherlevel theory kinds input replaced cycle new inputs ask theorem prover layer find required outputs layer outputs specify actions nipulators reaching conclusions transmit relevant ones outputs specify actions manipulators robot manipulators robot executes requested actions loop starts figure 2 illustrates process theory 1 theory 0 sensors effectors figure 2 abstract diagram lsa 1 iteration sonar readings replace previous inputs new ones logicbased subsumption architecture follow general pattern making sure loop fast enough time get conclusions world different world based conclusions eg making sure robot fall cliff planning way avoid cliff edge notice fact several loops different times different layers theorem provers reactive loop one counts speed overall loop describe behavior achieved next section 32 architecture behavioral decomposition first important idea borrow brooks architecture decomposing domain along behavioral lines rather along standard sequential functional lines change paradigm makes possible view robot control problem set loosely coupled processes hence parallelizable claim get similar performance benefits applying paradigm logical version subsumption architecture build lsa represent layer axiomatization layers behavior layers input output state including dependencies support task layer architecture layerinputs layeroutputs predicatesfunctions intended go either fromto sensorsactuators fromto lower layers ignoring interlayer interactions moment output layer determined running separate theorem prover layer treatment representation buy us benefits first axiomatization layer generally much smaller whole system cycle less computationally expensive running one theorem prover whole compound axiomatization second decoupling different layers behavior way becomes possible achieve reactive behavior brooks system lower layers controlling basic behaviors need wait higher layers completed computations respond situations rather since lower layers trusted autonomous higher layer ac tive lower layer still behave validly layers simpler axiomatizations general cycle time compute outputs shorter higher complex layers leading overall high performance important example want robot continue avoiding obstacles tries plan next line action note although module important construct brooks architecture representation modules serve mostly syntactic sugar provide conceptual clarity regard operation layer given theory denotes hasten point however relative independence module axiomatizations could also exploited eg separate theorem proving session determine intermediate module outputs making possible pipeline operation layer subsumption principles course layers fully independent fundamental feature brooks subsumption architecture ability higher layers observe interfere operation lower layers particular suppression inhibition capabilities provide means otherwise independent layers may interact allowing highlevel goals overrideadjust default lowlevel reactive behavior adopt view together taskbased decomposition idea coupling approach represents important natural paradigm intelligent agent general robot control particular see stein 1997 however implementing idea logical setting raises following issue general one layer overrides another two disagree particular module input therefore two corresponding theories inconsistent need formalize higherlayer theorys precedence lowerlayers way conflict facts either theory hold overall state system b event conflict overall state sides higher layer c independent facts eg inputs either layer remain unchanged number techniques developed logic com munity nonmonotonic techniques belief vision applicable chosen use circum scription although agree approaches may equally interesting appropriate circumscriptionbased subsumption described earlier layer logical theory distinguish three parts logical theory 1 body level 2 sensory latch input latch 3 output see figure 3 body layer constant theory layer latches used accept input replace every cycle rather accumulate output simply output sentences proved layer including latches following assume arbitrary level theory layer language l distinguish input language l ae l constitutes language allowed latches layer language theory influenced serves assertions coming sensors higherlevel layers output language ae l used limit queries theory asked language includes outputs asserted lowerlevel layers used actuator controls implement idea subsumption let layer assumptions inputs may later adjusted higherlevel layers assumptions take form abnormality body l1 input sensors output latches body sensors output latches l2 input figure 3 detailed look two layers predicate ab whose negation precondition sentences language l body layer assumptions also take form closed worldassumption cwa minimizing predicate l minimizations vary l make sure assumptions propagate exam ple higherlevel layer assert lowerlevel layer existence object previously excluded using cwa cycle particular layer first assert layers latches sentences higher layers may inferred respective output language higher layers apply sumptions circumscribing ab predicates input predicates enforce cwa theory varying predicates functions l theorem prover obtain appropriate outputs layer taking account serted interference higher layers formally let layer theory layer ab additional abnormality constant symbol c set predicates l wish assert cwa subsumption achieved using parallel circumscription policy implementation point view many times formula substituted simple external logic mechanical interference determining value minimized predicates discuss issue section 4 semantics ignore mechanism runs behind scenes moment eg ignore time difference theorem provers different layers consider entire system layers one logical theory formalize logical theory follows let layer ab c mentioned combined system described equivalent circlayer 0 circlayer 1 33 model brooks system part describe logical theory corresponding roughly layers 0 1 brooks subsumption ar chitecture divide theory conceptually correspond layers modules mentioned figure 1 simplicity omit parts description refer reader appendix layer 1 differs slightly brooks instead implementing random wandering layer supports simple movements towards goal location goal location specified layer 2 imagine first constructs plan exploration step plan asserts theory layer 1 via subsumption latch next goal location layer 1 makes simple calculation determine eight quadrants surrounding goal position located see figure 4 layer 1 asserts theory layer 0 way another subsumption latch existence virtual pushing object opposing quadrant avoidance capabilities layer 0 effectively push robot away object robot heads direction goal although may deviate direct path depending physical objects vicinity3 figure 4 quadrants pushing object cycle layer 0 theorem prover layer 0 asked find required actions modules turn forward described attempts prove fwdheading speed turnheading angle heading speed heading angle instantiated proof results translated appropriate robot commands inputs layer sonar data output layer 1 input language includes symbols sonar reading sonar direction object direction distance halt robot output includes fwd turn sonar sonar module takes input physical sonars asserted form axiom schema sonar readingsonar dist translates map objects type symbols defined appendix 2 8dist sonar readingsonar sonar directionsonar dist sonar number 1 reason implication sonars objects minimize object circumscription reason dont include axioms stating one object point collide take predicate object check see detected objects lying directly front us object ahead halt robot object ahead 2 feelforce feelforce dirty work computing combined repulsive force different detected objects 3 force direction force x force force runaway ab avoid heading ab avoid heading speed force strength assume robots 0 radians reference point straight ahead front sonar numbered 0 sonars numbered consecutively counterclockwise 0 nsonars gamma 1 3 feelforce may implemented library function rather logical theory gain much logical representation implemented efficiently procedure logical representation uses library functions anyway turn need turnheading angle turnheading angle forward halt robot need turnheading angle need fwdheading speed fwd heading speed need turnheading angle fwd0 circumscribing theory finally add parallel circumscription formula inputs layer current location data robot output layer 2 input language includes symbols got move cmd curr location output includes note unlike layer 0 coordinates layer terms fixed coordinate system independent robots location 4 simple move pushing objectquadrantx 0 push 8quad pushing objectquad circumscribing theory add parallel circumscription formula implementation issues implemented theory using pttp theorem prover stickel 1988b stickel 1988a stickel 1992 sun ultra60 creator3d 640mb ram running solaris 26 quintus prolog underlying interpreter pttp theory yet implemented physical robot yet simulations done abovedescribed machine helped us identify points difficulty using theorem prover task controlling intelligent agent 4 robot able maintain position cartesian space origin position last zeroed eg powered 41 choice theorem prover first difficulty encountered fact finding suitable theorem prover theory includes several mathematical computations several trigonometric functions see appendix much better suited systematic algorithm theorem prover since also wanted algebraic sophistication theory needed semantic attachments examined many theorem provers none seemed support semantic attachments easily convenient control theorem proving process via strategies otherwise provers examined closely otter 5 resolution theorem prover acl2 6 industrialstrength version boyer moore theorem prover atp 7 model elimination theorem prover major difficulties encountered difficulties encountered inability append semantic attachments eas ily complexity making theorem prover run given platform inability control inference process easily lack documentation addition also examined proof checkers pvs 8 proof checker hol 9 getfol 10 found unsuitable due need least human intervention pttp prolog technology theorem prover modelelimination theorem prover given theory made clauses necessarily disjunctive without quantifiers pttp produces set prologlike horn clauses makes sure sound unification produced avoids negationasfailure proofs produced prolog inference algorithm also makes sure inference algorithm complete using id iterative deepening proof space together ensure pttp sound complete theorem prover one features liked pttp despite lack suitable documentation although fair number examples theorem prover easy customize reliance underlying language implemented prolog lisp allows easy use semantic attachments collection examples together pttp software illustrative despite difficulties incurred use semantic attachments builtin predicates algebraic gave us relatively troubles either installation use 6 httpwwwcsutexaseduusersmooreacl2acl2 dochtml manualhtml 9 httpwwwcomlaboxacukarchiveformal methodsholhtml 42 running pttp theory embodied feelforce module c function get force needs input returns force vector strength direction work calling prolog bagof operator collect objects existence proofs found simply computes sum forces subjected objects cwa closed world assumption achieved limiting sizes proofs longer specified constant experimented little got constant 20 16 objects proof around 36 objects got second proof happened 48 experiment finally get forcel abs others treated builtin functionspredicates given underlying prolog evaluation turn may call c function get force prolog pred icate way one manages get semantic attachments without need able prove many properties algebraic formulas rest theory stays provision constants nsonars min dist incorporated aid predicates nsonarsx min disty ran theory different simulated sensory inputs results sample run shown figures 5 7 6 appendix results achieved 02 03 seconds depending whether turn needed leaning towards 02 seconds forward move needed leaning mostly towards 03 seconds worth mentioning computation get force applied caching computed force since pttp apply caching results major improvement efficiency several seconds proof 0203 using simple scheme due fact every proof reproved get force many times 43 nonmonotonicity considerations mentioned way treated nonmonotonicity experiment using naf negationas failure default proved wrong certain amount time treated false particular three points nonmonotonicity required 1 cwa objects world 2 halt robot assumed false unless otherwise proved 3 ab avoid allows complete overriding force constraints input layer 0 layer 1 assumed false since use facility overriding implementation level 1 cwa objects looked proofs longer 20 halt robot proposition 5 related work work showed theorem provers used implement robot control also showed extended version brooks subsumption architecture implemented using theorem provers logical theories extended version proposed general architecture building intelligent agents notice include specific action theory l0 showed theory influences l0 compare work shanahan shana han 1996 shanahan 1998 baral tran baral tran 1998 reiter et al reiter 1998 lesprance et al 1996 reiter 1996 shanahan 1998 describes mapbuilding process using abduction abduction specialized specific scenario spatial occupancy noise one may wish include implements theory algorithm abides logical theory account abduction contrast work implemented algorithm rather using generalpurpose theorem prover showed use theorem provers control long theory remains small relatively simple described way joining theorem provers theories structure allows larger theories interact complicated behaviors established although control theory much simpler shanahan 1998 fact include version original theory presented shanahan upper layer also since robot sophisticated mobile robot inclusion theory take account different sensors sonars instead switches work baral tran baral tran 1998 focuses relationship members family action languages gelfond lifschitz 1993 giunchiglia kartha lifschitz 1997 kartha reactive control modules define control modules form stimulusresponse sr agents see nilsson 1998 state defined set fluent values either sensory memory sequence rules defines action agent take given conditions state provide way check sr module correct respect action theory ar finally provide algorithm create sr agent action theory work although dealing reactivity seem able deal worldcomplexity model sensors many possible input values accounted several input fluents one decides use algorithm described baral tran produce simple sr module complexity algorithm worstcase exponential number fluents allow end life time also lack hierarchyoftheories model use work finally work reiter levesque colleagues levesque et al 1997 giacomo lesper ance levesque 1997 reiter 1998 lesprance et al 1996 reiter 1996 giacomo reiter soutchanski 1998 focuses language golog vari ants specification highlevel robot actions paradigm planner computesplans golog program offline lets robot execute golog program online language includes among others testing truth condition performing primitive action performing sequence actions nondeterministic choice two actions nondeterministic iteration use hierarchical model reasoning merging planning execution work splits planning execution planning done line also use logic semantics golog programs given using situation calculus mccarthy hayes 1969 6 discussion future work last 5 years logical approach ai got reinvigorated positive results different frontiers planning eg work bibel selman kautz kautz mcallester selman 1996 sensing ai architectures eg shanahan 1996 lesperance et al 1994 giacomo lesperance levesque 1997 paper presented logicbased architecture formalizes brooks subsumption architec ture using circumscription implement subsumption combined reactivity advantages brooks architecture declarative advantages logic produce first cut architecture perform sensing planning acting concurrently moment system partially implemented level 0 simulating computer besides implementing system mobile robot future work plan includes expanding layers described paper contain planning layers map creating layers eg creating map world pos sibly following work shanahan layers contain beliefs world eg may want doubt conclusion certain location believe moment ago distant location reasonable change done world put us new location etc project also serves experiment elaboration tolerance layering approach acknowledgments wish thank mark stickel allowing us use pttp sources prolog lisp providing helpful answers inquiries regarding use research supported arpa onr grant n000149410775 national physical science consortium npsc fellowship r reasoning relating theories actions reactive control nonmonotonic reasoning overview nonmonotonic reasoning logical foundations common sense robust layered control system mobile robot representing actions change logic programs reasoning concurrent execution execution monitoring highlevel robot pro grams indeterminacy ramifica tions actions indirect effects preliminary report encoding plans propositional logic logical approach highlevel robot programming progress report kuipers foundations logical approach agent programming golog logic programming language dynamic domains philosophical problems standpoint artificial intel ligence programs common sense mechanisation thought processes formalization common sense elaboration tol erance society mind artificial intelligence reasoning uncertainty natural actions knowledge action logical foundations describing implementing dynamical systems features fluents robotics common sense informatic situation solving frame problem logical account common sense informatic situation mobile robot postmodular systems architectural principles cognitive robotics th international conference automated deduc tion prolog technology theorem prover implementation extended prolog compiler prolog technology theorem prover new exposition implementation prolog logical theory appendix draw entire logical theory version brooks subsumption architecture example brooks objects obj sonar number sum forces search cost 1 proof search cost 2 proof search cost 3 proof proof goal 1222 inferences 002 seconds proof goal 36 needturn314 6 12664 inferences 024 seconds tr applications circumscription formalizing commonsense knowledge automated deduction theory resolution society mind prolog technology theorem prover implementation extended prolog computer relationship circumscription negation failure principles metareasoning frame problem situation calculus prolog technology theorem prover introduction hol situated view representation control building brains bodies representing action behaviorbased robotics computeraided reasoning reinventing shakey interpolation theorems nonmonotonic reasoning systems logicbased subsumption architecture spatial agents implemented logical expressible language efficient approximation triangulation minimum treewidth decisiontheoretic highlevel agent programming situation calculus ccgolog highlevel robot control logic prolog technology theorem prover layered resourceadapting agents robocup simulation dynamic subsumption architecture programming intelligent agents
deriving efficient cache coherence protocols refinement address problem developing efficient cache coherence protocols use distributed systems implementing distributed shared memory dsm using message passing serious drawback traditional approaches problem users required state desired coherence protocol level asynchronous message interactions involving request acknowledge negative acknowledge messages handle unexpected messages introducing intermediate states proofs correctness protocols described terms low level asynchronous messages involved often proofs hold specific configurations buffer allocations propose method users state desired protocol directly terms desired highlevel effect namely synchronization coordination using synchronous rendezvous construct descriptions much easier understand computationally efficient verify asynchronous protocols due small state spaces rendezvous protocol also synthesized efficient asynchronous protocols paper present protocol refinement procedure prove soundness provide examples efficiency synthesis procedure applies large classes dsm protocols b introduction growing complexity concurrent systems automated procedures developing protocols growing importance paper interested protocol refinement procedures define accept highlevel specifications protocols apply provably correct transformations yield detailed implementations protocols run efficiently modest buffer resource requirements procedures enable correctness proofs protocols carried respect highlevel specifications considerably reduce proof effort refinement rules shown sound detailed protocol implementations need verified paper address problem producing correct efficient cache coherence protocols used distributed shared memory dsm systems dsm systems widely researched next logical step parallel processing 2 4 11 13 confirmation growing importance dsm central problem dsm systems design implementation distributed coherence protocols shared cache lines using message passing 8 presentday approach problem consists specifying detailed interactions possible nodes terms lowlevel requests acknowledges negative acknowl edges dealing unexpected messages difficulty designing protocols compounded fact verifying lowlevel descriptions invites state explosion done using modelchecking 5 6 tedious done using theoremproving 17 even simple configurations often lowlevel descriptions modelchecked specific resource allocations eg buffer sizes supported part arpa order b990 spawar contract n003995c avalanche darpa contract dabt6396c0094 uv often known would happen allocations changed protocol refinement help alleviate situation considerably contribution paper protocol refinement procedure applied derive large class dsm cache protocols problems designing dsm cache coherence protocols attributable apparent lack atomicity implementation behaviors although designers protocols may begin simple atomic transaction view desired interactions description seldom written instead gets written highest level specification detailed protocol implementation arrived ad hoc reasoning situations arise paper choose csp 9 specification language allow designers capture initial atomictransaction view rendezvous protocol rendezvous protocol subjected syntaxdirected translation rules modify rendezvous communication primitives csp asynchronous communication primitives yielding efficient detailed implementation asynchronous protocol empirically show rendezvous protocols several orders magnitude efficient modelcheck corresponding detailed implementations addition also show context state art dsm machine project called avalanche 2 procedure automatically produce protocol implementations comparable quality handdesigned asynchronous protocols quality measured terms 1 number request acknowledge negative acknowledge nack messages needed carrying rendezvous specified given specification 2 buffering requirements guarantee precisely defined practically acceptable progress criterion rest paper organized follows section review related past work section 2 presents structure typical dsm protocols distributed systems section 3 presents syntaxdirected translation rules along important optimization called requestreply section 4 presents informal argument refinement rules present always produce correct result also points formal proof correctness done using pvs 16 section 5 presents example protocol developed using refinement rules efficiency modelchecking rendezvous protocol compared efficiency modelchecking asynchronous protocol finally section 6 presents discussion buffering requirements concludes paper related work chandra et al 3 use model based continuations help reduce complexity specifying coherency protocols specification model checked compiled efficient object code approach protocol still specified lowlevel though rendezvous communication modeled useful transient states introduced compiler cannot adequately handle unexpected messages contrast approach user writes rendezvous protocol using rendezvous primitive verifies protocol level great efficiency compiles efficient asynchronous protocol object code work closely resembles buckley silberschatz 1 buckley silberschatz consider problem implementing rendezvous using message processes use generalized inputoutput guard implemented software solution expensive dsm protocol implementations contrast focus star configuration processes suitable syntactic restrictions highlevel specification language efficient asynchronous protocol automatically generated gribomont 7 explored protocols rendezvous communication simply replaced asynchronous communication without affecting processes way contrast show change processes rendezvous communication replaced asynchronous communica tion lamport schneider 12 explored theoretical foundations comparing atomic transactions eg rendezvous communication split transactions eg asynchronous communication based left right movers 14 considered specific refinement rules cache coherency distributed systems directory based cache coherent multiprocessor systems coherency line shared memory managed cpu node called home node simply home 1 nodes may access shared line called remote nodes home node responsible managing access shared line nodes without violating coherency policy system simple protocol used avalanche called migratory shown figures 2 remote nodes home node engage following activity whenever remote node r wishes access information shared line first checks data available required access permissions local cache r uses data cache sends request permissions home node line home node may contact remote nodes revoke permissions order grant required permissions r finally home node grants permissions along required data r seen description remote node interacts home node home node interacts remote nodes suggests restrict communication topology interest star configuration home node hub without loosing descriptive power decision helps synthesize efficient asynchronous protocols shall see later 21 complexity protocol design already pointed problems design dsm protocols traced lack atomicity example consider following situation shared line read number remote nodes remote node say r1 wishes modify data hence sends request home node write per mission home node contacts remote nodes currently accessing data revoke read permissions grants write permission r1 unfortunately incorrect abstract entire sequence 1 home different cache lines different derive protocols focusing one cache line usually done actions consisting contacting remote nodes revoke permissions granting permissions r1 atomic action home node process revoking permissions different remote node say r2 may wish obtain read permissions case request must either nacked buffered later processing handle unexpected messages designers introduce intermediate states also called transient states leading complexity protocols hand show rest paper designer allowed state desired interactions using atomic view possible refine description using refinement procedure introduces transient states appropriately handle unexpected messages 22 communication model assume network connects nodes systems provides reliable pointtopoint inorder delivery messages assumption justified many machines eg dash 13 avalanche 2 also assume network infinite buffering sense network always accept new messages delivered without assumption asynchronous protocol generated may deadlock assumption satisfied solution proposed hennessy patterson 8 used postprocessing step refined protocol divide messages two categories request acknowledge request message may cause recipient generate messages order complete transactions acknowledge message authors argue network always accepts acknowledge messages opposed messages case network infinite buffer deadlocks broken shall see section 3 asynchronous protocol two acknowledge messages ack nack guaranteeing network always accepts two acknowledge messages beyond scope paper use rendezvous communication primitives csp 9 specify home node remote nodes simplify dsm protocol design particular use direct addressing scheme csp every input statement process q form pmsgv pmsg p identity process sent message msg enumerated constant message type v variable local variable q would set contents message every output statement q form pmsge pmsg e expression involving constants andor local variables q p q rendezvous p executing qme q executing pmv say p active process q passive process rendezvous rendezvous protocol written using notation verified using either theorem prover model checker desired properties refined using rules presented section 3 obtain efficient asynchronous protocol implemented directly example microcode 23 process structure divide states processes rendezvous protocol two classes internal communication process internal state cannot home hm b remote c remote fig 1 examples communication states home node remote nodes participate rendezvous process however assume process eventually enter communication state rendezvous actions offered assumption syntactically checked refinement process introduces transient states unexpected messages handled denote th remote node r home node h simplicity assume remote nodes follow protocol form communication processes asynchronous rendezvous protocols messages ie forms communication global variables available discussed restrict communication topology star since home node communicate remote nodes behaves like server remotenode requests natural allow generalized inputoutput guards home node protocols eg figure 1a contrast restrict remote nodes contain input nondeterminism ie remote node either specify wishes active participant single rendezvous home node eg figure 1b may specify willing passive participant rendezvous number messages eg figure 1c also figure 1c allow guards remote node model autonomous decisions cache evictions decisions empirically validated number real dsm protocols help synthesize efficient protocols finally assume fairness conditions placed nondeterministic communication options available communication state exception forward progress restriction imposed entire system described 24 forward progress assuming loops home node remote nodes refinement process guarantees least one refined remote nodes makes forward progress forward progress possible rendezvous protocol notice forward progress guaranteed remote node every remote node assuring forward progress remote node requires allocating much buffer space home node n remote nodes assure every remote node makes progress home node needs buffer hold n requests impractical nonscalable n dsm machines high thousands guarantee progress remote node buffer hold 2 messages suffices see section 3 3 refinement procedures systematically refine communication actions h r inspecting syntactic structure processes technique split rendezvous row state buffer contents action c1 communication active empty request rendezvous b goto transient state c2 communication active request delete request b request home rendezvous c goto transient state c3 communication passive request acknack request transient ack successful rendezvous transient nack go back communication state t3 transient request ignore request table 1 actions taken remote node enters communication state transient state action message buffer removed two halves request rendezvous acknowledgment ack negative acknowledgment nack indicate success failure rendezvous given time refined process one three states internal communication transient internal communication states refined process corresponding unrefined process rendezvous protocol transient states introduced refinement process following manner whenever process p qme one guards communication state p sends request q awaits transient state acknack request rendezvous q transient state p behaves follows receives ack q rendezvous successful p changes state appropriately r2 p receives nack q rendezvous failed p goes back communication state tries rendezvous different rendezvous r3 p receives request q action taken depends whether p home node remote node p remote node q home node p simply ignores message discussed next sentence p knows q get request tantamount nack qs request p home node goes back communication state though received nack implicit nack processes qs request communication state rules r1r3 govern remote node home node refined detailed 31 refining remote node every remote node buffer store one message home node remote node receives request home node request would held buffer remote node communication transient state actions shown table 1 rows table explained c1 remote node communication state wishes active participant rendezvous request home node pending buffer remote node sends request rendezvous home goes transient state awaits acknack request rendezvous home node c2 row similar c1 except request home pending buffer case also remote sends request home goes transient state addition request buffer deleted explained rule r3 home receives remotes request acts though nack received implicit nack deleted request c3 remote node communication state passive rendezvous waits request rendezvous home request satisfies guards communication state sends ack home changes state reflect successful rendezvous sends nack home continues wait matching request cases request removed buffer t1 t2 remote node receives ack rendezvous successful state process appropriately changed reflect completion rendezvous remote node receives nack home home node sufficient buffers hold request case remote node goes back communication state retransmits request reenters transient state t3 explained rule r3 remote node receives request home simply deletes request buffer continues wait acknack home 32 refining home node home node buffer capacity k messages k 2 incoming messages entered buffer space following exception last buffer location called progress buffer reserved incoming request rendezvous known complete rendezvous current state home reservation made livelock result example consider situation buffer full none requests buffer enable guard home node due lack buffer space new requests rendezvous must nacked thus home node longer make progress addition home node transient state expecting acknack r additional buffer need reserved message ack nack request rendezvous r held refer buffer ack buffer home communication transient state actions taken shown table 2 rows table explained c1 home communication state accept one requests pending buffer home finishes rendezvous arbitrarily picking one messages c2 requests pending buffer satisfy guard communication state one guards communication state r home node sends request rendezvous r enters transient state described sending message also reserves ack buffer assure hold messages r step may require home generate nack one requests buffer order free buffer location also note condition c states request r pending buffer rationale behind condition request r pending r communication state r active participant rendezvous due syntactic restrictions placed description remote nodes row state condition action communication buffer contains request ack sent r r satisfies rendezvous b delete request buffer c2 communication request buffer ack buffer allocated satisfies required rendezvous enough buffer space b home node active nack may generated rendezvous r ie b request rendezvous guard state sent r c request r pending c goto transient state buffer transient ack r rendezvous completed transient nack r rendezvous failed go back communication state send next request requests left repeat starting first guard t3 transient request r treat request b waiting acknack r nack plus request transient request r j 6r arrived enter request buffer b waiting acknack r c buffer transient request r j 6r arrived enter request b waiting acknack r progress buffer c buffer request satisfy guard communication state t6 transient request r j arrived nack request cases covered table 2 home node actions enters communication transient state requests rendezvous communication state hence wasteful send request r case t1 reception ack transient state indicates completion pending rendezvous t2 reception ack transient state indicates failure complete rendezvous hence home goes back communication state state checks new request buffer satisfy guard communication state ack generated corresponding request rendezvous completed home tries next output guard communication state output guards starts first output guard reason even though previous attempt rendezvous failed may succeed remote node question might changed state guard communication state t3 home expecting acknack r receives request r instead uses implicit nack rule r3 first assumes nack received hence goes communication state requests including request r processed row t2 t4 home receives request r j expecting acknack different remote r sufficient room buffer request added buffer t5 home transient state two buffer spaces receives message r j adds request buffer according buffer reservation scheme ie request entered progress buffer iff request satisfy one guards communication state request cant satisfy guards would handled row t6 request rendezvous r j received insufficient buffer space cases covered t4 t5 home nacks r j r j retransmits message 33 requestreply communication generic scheme outlined replaces rendezvous action two mes sages request ack cases possible avoid ack message example two messages say req repl used following manner req sent remote node home node service home node receiving req message performs internal actions andor communications remote nodes sends repl message remote node case possible avoid exchanging ack req repl statements hreqe hreplv always appear together hreqe hreplv remote node r repl always appears r req home node acks dropped whenever home node sends repl message remote node always ready receive message hence home node doesnt wait ack addition reception repl remote node also acts ack req course remote node receives nack instead repl remote node would retransmit request rendezvous scheme also used req sent home node remote node responds repl argue refinement correct analyzing different scenarios arise execution asynchronous protocol argument divided two parts rendezvous happen asynchronous protocol allowed rendezvous protocol b forward progress assured least one remote node rendezvous finished asynchronous protocol remote node executes rows c1 c3 t1 table 1 home node executes rows c1 table 2 see rendezvous accordance rendezvous protocol consider happens remote node active participant rendezvous case home node active participant similar remote node r sends request rendezvous home h starts waiting acknack three cases consider 1 h sufficient buffer space case request nacked rendezvous takes place 2 h sufficient buffer space either internal state transient state expecting acknack different remote node r j case message entered hs buffer h enters communication state accept request sends ack r completing rendezvous clearly rendezvous allowed rendezvous protocol h sends nack r later make space buffer row c2 r would retransmit request case rendezvous taken place 3 h sent request rendezvous r waiting acknack r transient state corresponds rule r3 case r simply ignores request h h knows request would dropped hence treats request r combination nack request already sent request rendezvous thus case becomes exactly like one two cases h generates acknack accordingly hence ack generated would allowed rendezvous protocol ack generated case 2 case rendezvous allowed rendezvous protocol informal argument formalized help pvs 16 proved refinement rules safety preserving ie showed transition taken refined protocol allowed original rendezvous protocol pvs theory files proofs obtained first authors www home page proof forward progress see least one remote nodes makes forward progress observe home node h makes forward progress one remote nodes also makes forward progress since disallow process stay internal states forever every internal state h eventually enters communication state may go transient state note restriction h sends request remote node remote would eventually respond ack nack request rendezvous forward progress possible rendezvous protocol show h would eventually leave communication transient state following case analysis 1 h communication state completes rendezvous row c1 table 2 clearly progress made 2 h communication state conditions row c1 c2 table 2 enabled h continues wait request rendezvous would enable guard since buffer location used progress buffer progress possible rendezvous protocol least one request would entered buffer enables c1 3 h communication state row c2 table 2 enabled case h sends request rendezvous goes transient state cases argue eventually makes progress 4 h transient state receives ack row t1 table 2 rendezvous completed hence progress made 5 h transient state receives nack row t2 table 2 implicit nack row t3 table 2 response nack home goes back rolrdata roinv rigrdata rolrdata roiddata f rjgrdata home node hreq rw hlrdata hiddata hgrdata evict b remote node fig 2 rendezvous migratory protocol communication state case progress argument based requests rendezvous h received transient state buffer reservation scheme one requests received enable guard communication state least one request entered buffer rows t4 t5 hence ack sent response one request h goes back communication state row c1 thus making progress requests received h sends request rendezvous corresponding another output guard row c2 reenters transient state process repeated h makes progress taking actions c1 t1 progress possible eventually either t1 would enabled since h keeps trying output guards repeatedly c1 would enabled since h repeatedly enters communication state repeatedly t2 t3 checks incoming requests rendezvous unless rendezvous protocol deadlocked asynchronous protocol makes progress 5 example protocol take rendezvous specification migratory protocol avalanche show protocol refined using refinement rules described architectural team avalanche previously developed asynchronous migratory protocol without using refinement rules described paper protocol followed home remote nodes shown figure 2 initially home node starts state f free indicating remote node access permissions line remote node r needs readwrite shared line sends req message home node home node sends gr grant message r along data addition home node also records identity r variable owner later use home node goes state e exclusive owner longer needs data may relinquish line lr message result receiving lr message home node goes back f home node e receives req another remote node home node revokes permissions current owner grants line new requester revoke permissions either sends inv invalidate message current owner waits new value data obtained id invalid done message waits lr message revoking permissions current owner gr message sent new requester variable modified reflect new owner remote node initially starts state invalid cpu tries read write shown rw figure req sent home node permissions gr message arrives remote node changes state v valid cpu read write local copy line line evicted capacity reasons example lr sent home node another remote node attempts access line home node may send inv response inv id invalid done sent home node line reverts back state refine migratory protocol note messages req gr refined using requestreply strategy remote node sends req home node sends gr response similarly messages inv id refined using requestreply except case inv sent home node remote node responds id following requestreply strategy pair consecutive rendezvous r req r gr r inv r id data takes 2 messages shown figures 3 refined home remote nodes shown figure 3 figures use instead emphasize communication asynchronous figures transient states shown dotted circles dotted arrows explained later discussed section 32 refined home node transient state receives request process expecting acknack would treated combination nack request write nack imply home node received nack either explicit nack message implicit nack discussed section 32 home node doesnt sufficient number empty buffers nacks requests irrespective whether node internal transient communication state sake clarity left nacks one transient state labeled rxmsgnack explained section 31 remote node transient state receives message home node remote node ignores message acknack ever generated response request figure 3 showed self loop transient states remote node label h asynchronous protocol designed avalanche design team differs protocol shown figure 3 protocol dotted lines actions ie ack exchanged lr message believe loss efficiency due extra ack small currently process quantifying efficiency asynchronous protocol designed hand asynchronous protocol obtained refinement procedure verification expected verification rendezvous protocols much simpler verification asynchronous protocols modelchecked rendezvous asynchronous versions migratory protocol invalidate another dsm protocol used avalanche using spin 10 number states visited time taken seconds two protocols shown figure 3c complexity verifying hand designed migratory invalidate comparable verification asynchronous protocol seen verifying rendezvous protocol generates far fewer states takes much rxmsgnack rolrdata rjgrdata roinv rigrdata roack rolrdata roack roiddata home node rw v h evict h hlrdata hnack hnack hgrdata hack b remote node protocol n asynchronous rendezvous protocol protocol migratory 2 23163284 5401 unfinished 23504 8 unfinished 96505 invalidate 2 1933891923 54606 unfinished 1868623 6 unfinished 228334184 c modelchecking efficiency fig 3 refined remote node migratory protocol less run time verifying asynchronous protocol fact rendezvous migratory protocol could model checked 64 nodes 32mb mem ory asynchronous protocol model checked two nodes 64mb currently developing simulation environment evaluate performance various asynchronous protocols 6 conclusions presented framework specify dsm protocols highlevel using rendezvous communication rendezvous protocols efficiently veri fied example using modelchecker protocol translated efficient asynchronous protocol using refinement rules presented pa per refinement rules add transient states handle unexpected messages rules also address buffering considerations assure refinement process generates efficient asynchronous protocol syntactic restrictions placed processes restrictions namely enforcing star configuration restricting use generalized guard inspired domain specific considerations currently studying letting two remote nodes communicate asynchronous protocol obtain better efficiency however relaxing star configuration requirement rendezvous protocol add much descriptive power however relaxing constraint asynchronous protocol improve efficiency refinement rules presented also guarantee forward progress per line per remote node forward progress per node guaranteed modest buffer follows every home manages buffer pool shared resource cache lines however instead using progress buffer per line progress buffer per node used request node entered shared buffer pool buffer space progress buffer node satisfies progress criterion strategy guarantees forward progress per node per line however virtuall modern processors bounded instruction issue window using proerpty protocol actions line interfere another line 15 one show forward progress guaranteed per line well remote node r effective implementation generalized inputoutput construct csp comparison software hardware synchronization mechanisms distributed shared memory multiprocessors language support writing memory coherency protocols cray research protocol verification hardware design aid using formal verificationanalysis methods critical path system design case study computer architecture quantitative appo rach communicating sequential processes state spin stanford flash multiprocessor pretending atomicity stanford dash multiprocessor method proving properties parallel programs s3 pvs combining specification protocol verification aggregation distributed transac tions tr design validation computer protocols temporal logic reactive concurrent systems stanford dash multiprocessor stanford flash multiprocessor teapot computer architecture 2nd ed effective implementation generalized inputoutput construct csp communicating sequential processes reduction synchronous asynchronous communication protocol verification hardware design aid exploiting parallelism cache coherency protocol engines using formal verificationanalysis methods critical path system design protocol verification aggregation distributed transactions pvs
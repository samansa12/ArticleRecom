universal constructions large objects abstractwe present lockfree waitfree universal constructions implementing large shared objects previous universal constructions require processes copy entire object state impractical large objects previous attempts address problem require programmers explicitly fragment large objects smaller manageable pieces paying particular attention pieces copied contrast constructions designed largely shield programmers fragmentation furthermore many objects constructions result lower copying overhead previous ones fragmentation achieved constructions use loadlinked storeconditional validate operations large multiword shared variable presenting constructions show operations efficiently implemented similar oneword primitives b introduction paper extends recent research universal lockfree waitfree constructions shared objects 3 4 constructions used implement object lockfree waitfree manner thus used basis general methodology constructing highlyconcurrent objects unfortunately generality often comes price specifically space time overhead excessive many objects particular source inefficiency previous universal constructions require processes copy entire object state impractical large objects paper address shortcoming presenting universal constructions used implement large objects low space overhead take starting point lockfree waitfree universal constructions presented herlihy 4 constructions operations implemented using retry loops herlihys lockfree universal construction processs retry loop consists following steps first shared object pointer read using loadlinked opera tion private copy object made desired operation performed private copy finally storeconditional sc operation executed attempt swing shared object pointer point private copy sc operation may fail case steps repeated algorithm waitfree sc loop iteration may fail ensure termination herlihys waitfree construction employs helping mechanism whereby process attempts help processes performing pending operations together mechanism ensures work supported part nsf contract ccr 9216421 young investigator award us army research office grant number daaho49510323 process repeatedly unsuccessful swinging shared object pointer eventually helped another process fact two loop iterations herlihy points constructions perform poorly used implement large objects overcome problem presents lockfree construction large object fragmented blocks linked pointers construction operations implemented blocks must accessed modified copied herlihys lockfree approach implementing large objects suffers three short comings first required fragmentation left programmer determine based semantics implemented object programmer must also explicitly determine copying done second herlihys approach difficult apply waitfree implementations particular directly combining helping mechanism waitfree construction small objects results excessive space overhead third herlihys largeobject techniques reduce copying overhead long chains linked blocks avoided consider example large shared queue fragmented linear sequence blocks ie linked list replacing last block actually requires replacement every block sequence particular linking new last block requires pointer previous block changed thus nexttolast block must replaced repeating argument follows every block must replaced approach implementing large objects also based upon idea fragmenting object blocks however differs herlihys arraybased rather pointerbased ie view large object long array fragmented blocks unlike herlihys approach fragmentation approach visible user also copying overhead approach often much lower herlihys approach example implement shared queues constant copying overhead constructions similar herlihys operations performed using retry loops however herlihys constructions employ single shared object pointer need manage collection pointers one block array deal problem employing sc validate vl operations access large shared variable contains block pointers large variable stored across several memory words 1 first part paper show efficiently implement using usual singleword sc vl primitives present two implementations one may return special value indicates subsequent sc fail call weakll another usual semantics implementations sc wword variable take ow time vl takes constant time first implementations simpler second weakll return consistent multiword value case interference concurrent sc also weakll used avoid unnecessary work universal algorithms point performing private updates subsequent sc certain fail reasons use weakll universal constructions waitfree universal construction first construction incorporate techniques implementing large objects construction impose upper bound number private blocks process may bound assumed large enough accommodate single operation bound affects manner processes may help one another specifically process attempts help many processes simultaneously runs risk using private space avail able solve problem process help many processes possible operation choosing processes help way processes 1 multiword operations considered access single variable spans multiple words thus multiword operations considered 1 2 5 6 access multiple variables stored separate word multiword operations consider admit simpler efficient implementations considered 1 2 5 6 shared initially initial value implemented variable v private initially proc long weak llvar r wordtype returns 0n 1 curr llx 2 ri buf curr pid curr tag 3 vlx return n 4 else return x pid fi proc long sc val returns boolean 4 5 buf p ji val return sc x p j figure 1 wword weakll sc using 1word vl sc wword vl implemented validating x eventually helped enough space available processes helped one process time call parallel helping otherwise several rounds helping must performed possibly several processes call serial helping tradeoff serial parallel helping one time versus space remainder paper organized follows section 2 present implementations sc vl operations large variables discussed present lockfree waitfree universal constructions preliminary performance results section 3 end paper concluding remarks section 4 due space limitations defer detailed proofs full paper 2 sc large variables section implement vl sc operations wword variable v using standard oneword vl sc operations 2 first present implementation supports weakll operation described previous section present implementation supports operation usual semantics latter implementation guaranteed return correct value v even subsequent sc operation fail unfortunately guarantee comes cost higher space overhead complicated implementation many applications however operation suffices particular lockfree waitfree universal constructions including sc used pairs way sc fails none computation since preceding effect object using weakll avoid unnecessary computation 21 weakll vl sc operations large variables begin describing implementation weakll vl sc shown figure 1 3 long weak long sc procedures implement weakll sc operations wword variable v values v stored buffers shared variable x indicates buffer contains current value v current value value written assume sc operation fail spuriously shown 1 sc operation fail spuriously efficiently implemented using sc operation might fail spuriously 3 private variables figures assumed retain values procedure calls v recent successful sc operation initial value v preceding successful sc vl operation v implemented simply validating x sc operation v achieved writing wword variable stored buffer using oneword sc operation x make buffer current ensure sc operation overwrite contents current buffer sc operations process p alternate two buffers buf p 0 buf p 1 process p performs weakll operation v three steps first executes oneword operation x determine buffer contains current value second reads contents buffer third performs vl x check whether buffer still current vl succeeds buffer modified ps read value read p buffer safely returned vl fails weakll rereads x order determine id last process perform successful sc process id returned call process whose id returned witness failed weakll see section 32 witness failed provide useful state information held execution weakll note vl line 3 fails buffer read p longer current hence subsequent sc p fail implementation yields following result theorem 1 weakll vl sc operations wword variable implemented using vl sc operations oneword variable time complexity ow o1 ow respectively space complexity onw 2 22 vl sc operations large variables show implement sc usual semantics although operation implemented sufficient constructions uses large sc might require operation always return correct value v complicated fact w words v cannot accessed atomically implementation vl sc operations wword variable v shown figure 2 like previous implementation one employs shared variable x along set buffers also shared array tags used buffer management buffer management differs described previous subsection several respects first process p 4n instead two another difference buffer contains information specifically old value v new value v two control bits control bits used detect concurrent readwrite conflicts bits together tags array employed ensure returns correct value despite interference figure shows two procedures long long sc implement sc operations v respectively vl v performed simply validating x long procedure similar long weak procedure except event vl x fails work required order determine correct return value buffer management scheme employed guarantees following two properties buffer cannot modified process reads buffer ii process concurrently read buffer written process obtains correct value either old field new field buffer full paper prove properties formally describe implementation shown figure 2 detail paying particular attention ii describing long procedure focus code executed event vl x fails code distinguishes long long weak procedure previous subsection process p executes long shared initially initial value l private var val1 initially tag 0 last tag sucessfully sc proc long returns wordtype 1 curr llx 2 val1 buf curr pid curr tag new 3 vlx return val1 else 4 curr 5 ap curr 7 bit buf curr pid curr tag b 8 val2 buf curr pid curr tag old 9 buf curr pid curr tag return val2 else return val1 proc long sc newval wordtype 10 read aj 11 select diff flast n tags readg flast n tags selectedg flast tag successfully sc dg 12 vlx return false fi 13 bit buf p diff c 14 buf p diff c bit 15 buf p diff old val1 17 buf p diff new newval return sc x p diff figure 2 wword sc using 1word vl sc wword vl trivially implemented validating x procedure vl x fails p might read corrupt value buffer due concurrent write order obtain correct return value p reads x ascertain current buffer reads entire contents buffer new b old c fields within buffer written reverse order read long procedure thus property ps read cross one concurrent write another process comparing values reads b c fields p determine whether crossing point occurred p read old field new field based comparison p choose correct return value essence formal proof required establish property ii describing long sc procedure focus buffer selection mechanism buffer selected procedure simply updates old new b c fields buffer explained primary purpose buffer selection mechanism ensure property holds time process p executes long sc reads tag value written ar process r line 10 tag values read processes turn n sc operations v p read tag process process p selects buffer sc choosing new tag line 11 new tag selected differ last n tags read p differ last n tags selected p differ last tag used successful sc p last three conditions ensures p overwrite current buffer first two conditions ensure property holds explain tags selected first however explain selection mechanism ensures property observe process qs vl x line reading one ps proc read tagv deleteread else deleteselect dequeueread q last q enqueueselect proc store tagv deleteselect enqueuelast dequeuelast q enqueueselect proc select tag returns dequeueselect q enqueueselect return figure 3 pseudocode implementations operations tag queues buffers buf p v lines 6 9 q writes p v aq line 5 p selects modifies buf p v process q reading buf p v p select buf p v next n sc operations thus p selects buf p v p reads aq line 10 long p v remains aq among last n tags read p hence p select buf p v modified therefore property holds conclude subsection describing tag selection line 11 efficiently implemented accomplished process maintains three local queues last select read queue records last n tags read last queue records last tag successfully written using sc x tags reside select queue new tags selected tag queues maintained means read tag store tag select tag procedures shown figure 3 procedures enqueue dequeue denote normal queue operations deleteq v removes tag v q modify q v q x 2 q holds iff tag x queue q process p selects tag line 11 figure 2 calling select tag select tag moves front tag ps select queue back returns tag tag subsequently written x successful sc operation line 18 p calls store tag move tag select queue last queue tag previously last queue removed read queue returned select queue process p reads tag p v line 10 calls read tag record tag read p v already read queue read tag simply moves p v end read queue p v already read queue enqueued read queue removed select queue necessary finally tag front read queue removed longer one last n tags read tag also last tag written x returned select queue read queue always contains last n tags read last queue always contains last tag successfully written x thus tag selected select tag certainly last tag successfully written x among last n tags read full paper show maintaining total 4n tags ensures tag selected also one last n tags selected required maintaining static index table allows tag located constant time representing queues doublylinked lists queue operations described implemented constant time thus following result theorem 2 vl sc operations wword variable implemented using vl sc operations oneword variable time complexity ow o1 ow respectively space complexity 2 w 2 blocks bank pointers current blocks process ps replacement pointers process ps replacement last object block mem array made sword blocks figure 4 implementation mem array large object constructions 3 large object constructions section present lockfree waitfree universal constructions large objects begin brief overview previous constructions due herlihy 4 herlihy presented lockfree waitfree universal constructions small objects well lockfree construction large objects 4 described section 1 operation herlihys smallobject constructions copies entire object severe disadvantage large objects herlihys largeobject construction implemented object fragmented blocks linked pointers modification amount copying performed operation often reduced copying blocks affected operation however fragmentation significant amount creative work part sequential object designer often required advantages herlihys largeobject construction realized also approach provides advantage common objects queue described section 1 finally herlihy present waitfree construction large objects lockfree waitfree universal constructions large objects designed overcome problems constructions described next sections 31 32 respectively section 33 present performance results comparing constructions herlihys 31 lockfree universal construction large objects lockfree construction shown figure 5 construction implemented object stored array unlike herlihys smallobject constructions array actually stored contiguous locations shared memory instead provide illusion contiguous array fact partitioned blocks operation replaces blocks modifies thus avoids copying whole object describing code figure 5 first explain illusion contiguous array provided figure 4 shows array mem divided b blocks words memory words mem 0 mem gamma 1 stored first block words mem stored second block bank pointers one block array maintained order record blocks currently part array order change contents array operation makes copy block changed attempts update bank pointers installing new shared pointers array blocks array copy blocks initially kth block initial value private var oldlst copy initially returns wordtype return blk ptrs addr div saddr mod blkidx addr div index address dirty blkidx havent changed block dirty blkidx record block changed memcpyblk copy dirtycnt blk ptrs blkidx sizeof old block new oldlst dirtycnt ptrs blkidx dirtycnt ptrs blkidx copy dirtycnt dirtycnt new block record old block prepare next one ptrs blkidx addr mod val write new value proc lf opop optype pars paramtype true loop operation succeeds 1 long weak llbank object pointer dirty false od dirtycnt copied yet 2 ret perform operation object 3 dirtycnt unnecessary sc 4 long sc bank ptrs operation successful reclaim old blocks 0 dirtycnt gamma 1 copy oldlst od return ret od figure 5 lockfree implementation large object pointers changed blocks pointers left unchanged achieved using weakll sc operations large variables presented section 21 4 figure 4 process p preparing modify word last block others thus bank pointers written p current bank except last pointer points ps new last block operation process p accesses word array say mem x block currently contains mem x must identified ps operation modifies mem x p must replace block order hide details identifying blocks replacing modified blocks address translation recordkeeping necessary work performed special read write procedures called sequential operation order read write mem array result constructions completely transparent sequential object designer example instead writing mem 1 mem 10 designer would write write1 read10 however discussed section 4 preprocessor could used provide complete transparency turn attention code figure 5 figure bank b word shared variable treated array b pointers actually indices blk array points block words together b blocks pointed bank make implemented array mem assume upper bound number blocks modified operation therefore addition b 4 extra parameter added procedures section 21 explicitly indicate shared variable updated blocks required object copy blocks needed per process giving total blocks blocks stored blk array although blocks blk nt blk nt initial array blocks blk pt blk p process ps initial copy blocks roles blocks fixed particular p replaces set array blocks copy blocks result successful sc p reclaims replaced array blocks copy blocks thus copy blocks one process may become blocks array later become copy blocks another process process p performs lockfree operation calling lf op procedure loop lf op procedure repeats sc line 3 succeeds iteration process p first reads bank local variable ptrs using bword weakll recall section 21 weakll return process identifier f0 n gamma 1g following sc guaranteed fail case point attempting apply ps operation loop restarted otherwise p records dirty array block yet modified operation initializes dirtycnt counter zero next p calls op procedure provided parameter lf op op procedure performs sequential operation reading writing elements mem array reading writing performed invoking read write procedures shown figure 5 read procedure simply computes block currently contains word accessed returns value appropriate offset within block write procedure performs write word mem computing index blkidx block containing word written already done write procedure records block dirty ie modified copies contents old block one ps copy blocks copy block linked ps ptrs array making block part ps version mem array displaced old block recorded oldlst possible reclaiming later finally appropriate word new block modified contain value passed write procedure bank modified another process ps weakll object contained ps version mem array pointed ps ptrs array correct result applying ps operation therefore ps sc successfully installs copy object ps operation applied sc p reclaims displaced blocks recorded oldlst replace copy blocks used performing operation hand another process modify bank ps weakll sc ps sc fails case process completes operation implementation lockfree concluding subsection one complication bears mentioning bank variable modified another process ps sequential operation executed possible p read inconsistent values mem array observe result p installing corrupt version object ps subsequent sc fails however risk ps sequential operation might cause error division zero range error reads inconsistent state object problem solved ensuring bank invalidated control returns directly read procedure lf op procedure without returning sequential operation unix longjmp command used purpose details omitted figure 5 full paper prove following theorem 3 suppose sequential object obj implemented array b sword blocks operation modifies blocks worstcase time complexity c obj implemented lockfree manner space overhead 5 onb nts contentionfree time complexity ob interesting compare complexity figures herlihys lockfree 5 space overhead mean space complexity beyond required sequential object construction consider implementation queue storing head tail pointers actually array indices pointers designated block enqueue dequeue performed construction copying two blocks block containing head tail pointer update block containing array slot pointed pointer space overhead case onb ns small compared obs size queue contentionfree time complexity ob ob greater time sequential enqueue dequeue contrast mentioned section 1 process herlihys construction must actually copy entire queue even using largeobject techniques thus space overhead least n times worstcase queue length nbs also contentionfree time complexity sinceomegagamma bs time required copy entire queue worst case implementing balanced tree constructions require space overhead logbs local blocks however pay logarithmic time cost performing operation whose sequential counterpart modifies logarithmic number array slots contrast herlihys construction entails logarithmic time cost copying almost every operation whenever block modified chain block pointers must updated block block containing root tree 32 waitfree construction large objects waitfree construction large objects shown figure 6 lockfree construction presented previous subsection construction uses read write procedures figure 5 provide illusion contiguous array principal difference lockfree waitfree constructions processes waitfree construction help order ensure operation process eventually completed enable process perform operation least one process together process p 2t private copy blocks recall maximum number blocks modified single operation helping mechanism used waitfree largeobject construction similar used herlihys waitfree smallobject construction several respects enable processes perform others operations process q begins announcing operation parameters anc q line 11 figure 6 also process stores sufficient information object allow helped process detect operation completed determine return value operation information also ensures operation helped subsequently reapplied also several differences helping mechanism herlihys first herlihys construction time process performs operation also performs pending operations processes however construction restricted amount private copy space might prevent process simultaneously performing pending operations processes therefore construction process helps many processes operation order ensure process eventually helped help counter added shared variable bank used lockfree construction help field indicates process helped next time process p performs operation p helps many processes possible starting process stored help field achieved helping processes private copy blocks remain accommodate another operation lines 22 24 recall write procedure figure 5 increments dirtycnt whenever new block modified process p updates help field next process successfully perform operation starts helping p stops helping mechanism also differs herlihys way process detects completion operation herlihys construction completion detected means applied copied boolean end shared announce array blocks operation return values last ret block updated process initially private var oldlst copy match done bit loop boolean applyop initially 1 match anc q bit 2 ret rbq applied 6 match 3 applyop anc q op 4 applypars anc q pars 5 ret rbq val applyopapplypars applied match proc return block returns 0n 7 tmp long weak llbank ptrs 8 tmp 6 n 9 return last tmp else 10 return ptrs ret proc wf opop optype pars paramtype announce operation 12 b done return block false 13 done ret bpcopied 6 bit loop update succeeds operation helped 14 long weak llbank object pointers 15 0 dirty false od dirtycnt modified yet old return block install new one 17 memcpyret rb ret oldrb sizeof private copy return block applied operations 19 ret rbjapplied 20 ret rbjcopied apply operation 22 dirtycnt sufficient space remains 24 try try ptrs help loop true fi 25 last p ptrs help rb try return block modified operation successful reclaim old blocks copy oldlst od 28 ret rbpcopied rb done bit copied bit next time current recent return block 30 return ret bpval get return value operation figure waitfree implementation large object collection toggle bits one process stored current version object attempting apply operation process p first announces new toggle bit value another process helps p copies bit value current version object detect completion operation p tests whether bit value stored current version object matches bit value previously announced access current version object p first reads shared object pointer reads buffer pointed pointer order avoid race condition result operation returning incorrect value herlihys construction requires sequence reads performed twice race condition arises p attempts access current buffer ps access another process subsequently reclaims buffer privately updates dereferencing object pointer checking toggle bit second time p ensure first buffer accessed reclaimed ps operation already applied process reclaimed buffer helped processes operation therefore ensured ps operation applied construction guarantee process helps processes p might reread shared object pointer read toggle bit many times ensure operation applied therefore use different mechanism explained determining whether operation applied enable process detect operation applied determine return value operation use set return blocks n blocks ret 0 ret n time one blocks current indicated new ret field bank variable process owns one return blocks current return block contains process q return value qs recent operation along two bits applied copied bits used q detect operation completed roughly speaking applied bit indicates qs operation applied object copied bit indicates another operation completed since qs operation applied interpretation bits determined anc qbit example qs operation applied iff qs applied bit current return block equals anc qbit see two bits needed detect whether qs operation complete consider scenario figure 7 figure process p performs two operations first ps sc successful p replaces ret 5 ret 3 current return block line 26 ps first operation q starts operation however q starts operation late helped p ps execution line 26 q reads bank line 7 determines ret 5 current return block p starts second operation p previously replaced ret 5 current return block ret 5 ps private copy ps second operation uses ret 5 record operations helps p executes line 6 changes qs applied bit indicate applied qs operation note stage qs operation applied ps private object copy p yet performed sc however q reads applied bit ret 5 previously determined current ret block line 13 q incorrectly concludes operation applied object terminates prematurely similarly possible q detect copied bit return block ret b equals anc qbit sc makes ret b current however qs copied bit updated applied bit successfully installed part current return block follows process must previously applied qs operation thus q terminates correctly case see line 13 remains describe process q determines return block contains current state qs operation sufficient q perform weakll bank read ret field weakll guaranteed return value bank successful 14 26 14 6 ancqbit ret5qapplied figure 7 process q prematurely detects applied bit equal anc qbit sc operation interferes case weakll returns id witness process performs successful sc bank weakll operation preparation possibility process p records return block using last p line 25 attempting make block current line 26 q detects interference successful sc q uses last entry witness process determine return block read last entry contains index return block current qs weakll operation block subsequently written current copy recent current return block contents still valid waitfree construction gives rise following result theorem 4 suppose sequential object obj whose return values r words implemented array b sword blocks operation modifies blocks worstcase time complexity c 2t obj implemented waitfree manner space overhead onnr worstcase time complexity odn minn bmt ceb nr 33 performance comparison subsection describe results preliminary experiments compare performance herlihys lockfree construction large objects two constructions 32processor ksr1 multiprocessor results one set experiments shown figure 8 experiments sc primitives implemented using native ksr locks processors performed 1000 enqueues 1000 dequeues shared queue testing constructions chose b number blocks size block approximately square root total object size also chose queue operation accesses two words waitfree construction chose sufficient guarantee process help least one operation fact two consecutive enqueue dequeue operations usually access choosing sufficient ensure process often helps processes time performs operation choices result low space overhead compared required herlihys construction expected lockfree waitfree constructions significantly outperform herlihys construction queue size grows operation herlihys construction copies entire object copy small parts object interesting note waitfree construction outperforms lockfree one 6 shown successful operation guaranteed advance help pointer minn bmt c thus process ps sc fails dn minn bmt ce times ps operation helped considering bounds note many objects r small constant also queues c constant balanced trees c logarithmic size object time forenqueues anddequeues queue size comparison large object constructions shared queue lockfree waitfree herlihylockfree herlihylockfreebackoff figure 8 performance experiments ksr believe cost recopying blocks event sc fails dominates cost helping also interesting note exponential backoff significantly improve performance herlihys lockfree construction stands contrast herlihys experiments small objects exponential backoff played important role improving performance believe performance herlihys large object construction dominated copying contention point deliberately chosen queue show advantages constructions herlihys full paper also present implementation skew heap object considered herlihy expect constructions still outperform herlihys albeit less dramatically copy logarithmic number blocks sequential operation herlihys whenever block near bottom tree modified concluding remarks constructions improve space time efficiency lockfree waitfree implementations large objects also contrast similar previous constructions require programmers determine object fragmented object copied however require programmer use special read write functions instead assignment statements used conventional programming nonetheless demonstrated figure 9 resulting code close ordinary sequential implementation construction could made completely seamless providing compiler preprocessor automatically translates assignments mem calls read write functions applicability construction could improved addition dynamic memory allocation mechanism would provide convenient interface objects balanced trees naturally represented nodes dynamically allocated released wellknown techniques implementing dynamic memory management array techniques could applied directly sequential object programmer could provided subroutine library several issues arise design library first dynamic memory allocation pro int dequeue int item readhead readtail return empty return item int enqueueitem int item int newtail int newtail newtail readhead newtail head return full return full return success return success figure 9 c code used queue operations comments show usual enqueue code cedures must modify small number array blocks advantages constructions preserved second fragmentation complicates implementation allocate release procedures complications make procedures quite inefficient even cause allocate procedure incorrectly report insufficient memory available problems significantly reduced size allocation requests fixed advance many objects restriction consequence example nodes tree typically size finally constructions allow parallel execution operations even operations access disjoint sets blocks would like extend constructions allow parallel execution possible example shared queue implementations enqueue operation might unnecessarily interfere dequeue operation 1 addressed similar concerns implementing waitfree operations multiple objects acknowledgement would like thank lars nyland help performance studies section 33 r universal constructions multiobject operations method implementing lockfree shared data structures waitfree synchronization methodology implementing highly concurrent data objects disjointaccessparallel implementations strong shared memory primitives software transactional memory tr ctr maged michael high performance dynamic lockfree hash tables listbased sets proceedings fourteenth annual acm symposium parallel algorithms architectures august 1013 2002 winnipeg manitoba canada mark moir laziness pays using lazy synchronization mechanisms improve nonblocking constructions proceedings nineteenth annual acm symposium principles distributed computing p6170 july 1619 2000 portland oregon united states maged michael safe memory reclamation dynamic lockfree objects using atomic reads writes proceedings twentyfirst annual symposium principles distributed computing july 2124 2002 monterey california simon doherty maurice herlihy victor luchangco mark moir bringing practical lockfree synchronization 64bit applications proceedings twentythird annual acm symposium principles distributed computing july 2528 2004 st johns newfoundland canada yuhjzer joung asynchronous group mutual exclusion distributed computing v13 n4 p189206 november 2000 maurice herlihy victor luchangco paul martin mark moir nonblocking memory management support dynamicsized data structures acm transactions computer systems tocs v23 n2 p146196 may 2005 hagit attiya eyal dagan improved implementations binary universal operations journal acm jacm v48 n5 p10131037 september 2001
fast simple character classes bounded gaps pattern matching application protein searching problem fast searching pattern contains classes characters bounded size gaps cbg text wide range applications among important one protein pattern matching instance one prosite protein site associated cbg rk x2 brackets match letters inside x2 3 gap length 2 3 currently way search cbg text convert full regular expression however sophisticated cbg searching pattern matching algorithm complicates search makes slow reason design article two new practical cbg matching algorithms much simpler faster search techniques first one looks exactly text character second one need consider text characters hence usually faster first one bad cases may read text character propose criterion based form cbg choose apriori fastest performed many practical experiments using prosite database show algorithms fastest virtually cases b introduction paper deals problem fast searching patterns contain classes characters bounded size gaps cbg texts problem occurs various elds like information retrieval data mining computational biology particularly interested latter one computational biology problem many applications among important protein matching last years huge protein site pattern databases developed like prosite 7 11 databases collections protein site descriptions protein site database contains diverse information notably pattern expression formed classes characters bounded size gaps amino acid alphabet size 20 pattern used search possible occurrence protein longer one example protein site number ps00007 pattern expression rk x2 brackets mean position match letters inside x2 means gap length 2 3 dept computer science university chile blanco encalada 2120 santiago chile gnavarrodccuchilecl work developed author postdoctoral stay institut gaspard monge univ de marnelavallee france partially supported fundacion andes ecosconicyt equipe genome cellule et informatique universite de versailles 45 avenue des etatsunis 78035 versailles cedex email raffinotmongeunivmlvfr work done author institut gaspardmonge cite descartes champssurmarne 77454 marnelavallee cedex 2 france currently patterns considered full regular expressions res xed alphabet ie generalized patterns composed basic characters alphabet adding empty word also special symbol x match letters ii concatenation denoted closure latter operation l set words l means accept words made concatenation words l instance previous pattern considered regular expression rjk x x xj dje x x xj note jrej length number symbols search done classical algorithms searching however quite complicated needs converted automaton searched text converted deterministic automaton dfa worst case time o2 jrej search linear size n text giving total complexity o2 jrej n also converted nondeterministic automaton nfa linear time ojrej searched text jrej time giving total jrej time give review methods section 3 majority matching softwares use techniques 13 22 none presented techniques fully adequate cbgs first algorithms intrin sequely complicated understand implement second techniques perform poorly certain type res dicult res general whose dfas large common case translating cbgs res third especially regard sizes dfas simplicity cbgs translated corresponding res least resorting res implies solving simple problem converting complicated one indeed experimental time results applied cbg expressions far reasonable regard simplicity cbgs compared search expressions contain classes characters 18 motivation paper present two new simple algorithms search cbgs text also experimentally much faster previous ones algorithms make plenty use bitparallelism consists using intrinsic parallelism bit manipulations inside computer words perform many operations parallel competitive algorithms obtained using bit parallelism exact string matching 2 26 approximate string matching 2 26 27 3 17 res matching 15 25 20 although algorithms generally work well patterns moderate length simpler exible eg easily handle classes characters low memory requirements performed two dierent types time experiments comparing algorithms fastest known searching algorithms use cbgs patterns prosite database rst compared pure pattern matching ie searching cbgs compilation 6 megabytes protein sequences tigr microbial database compared library matching search large set prosite patterns protein sequence 300 amino acids algorithms far fastest cases moreover second case search time improvements dramatic algorithms 100 times faster best matching algorithms two algorithms present patented french centre national de la recherche scientique cnrs 1 use following denitions throughout paper alphabet word nite sequence characters means set words build word x 2 factor substring p 2 p written factor x p called sux p prex p 1 patent number 00 11093 deposed cnrs 083000 information please contact sbastien chirie sebastienchiriestfr fist 135 boulevard saint michel 75005 paris france note brackets subset elements art means subset fa r tg single letter expressed way add special symbol x denote subset corresponds whole alphabet also add symbol xa b b bounded size gap minimal length maximal b cbg formally nite sequence symbols brackets ii x iii bounded size gaps xa b dene total number symbols cbg use notation text n characters searching cbgs cbg matches position j alignment cbg considering bracket matches text letter appears inside brackets ii x matches text letter iii bounded gap xa b matches minimum maximum b arbitrary characters denote minimum size possible alignment l size maximum one example rk x2 matches text position 11 3 dierent alignments see figure 1 l 7 r 2y figure 1 three dierent alignments cbg rk x2 text ahlrkdedaty ending position searching cbg text consists nding positions j alignment cbg sux paper organized follows begin section 2 summarizing two main bitparallel approaches lead fast ecient matching algorithms simple strings also patterns contain classes characters section 3 explain detail approaches search full res present section 4 new algorithm call forward algorithm reads characters text exactly based new automaton representation simulation present section 5 another algorithm call backward algorithm despite processes text basically left right allows us skip characters text generally faster however used types cbgs sometimes slower forward one consequently give next section 6 good experimental criterion enables us choose apriori fastest depending form cbg section 7 devoted experimental results algorithms compared fastest searching algorithms 2 bitparallelism simple pattern matching 2 new approach text searching proposed based bitparallelism 1 technique consists taking advantage intrinsic parallelism bit operations inside computer word using cleverly fact number operations algorithm performs cut factor w w number bits computer word since current architectures w 32 64 speedup signicative practice figure 2 shows nondeterministic automaton searches pattern text classical pattern matching algorithms kmp 14 convert automaton deterministic form achieve worst case search time shiftor algorithm 2 hand uses bitparallelism simulate automaton nondeterministic form achieves omnw worstcase time ie optimal speedup classical omn simulation w shiftor twice fast kmp better use computer registers moreover easily extended handle classes characters use notation describe bitparallel algorithms use exponentiation denote bit repetition eg denote bits mask length stored somewhere inside computer word length w use clike syntax operations bits computer words ie j bitwiseor bitwiseand complements bits moves bits left enters zeros right eg b b also perform arithmetic operations bits addition subtraction operate bits formed number instance explain basic algorithm later improvement b b b figure 2 nondeterministic automaton search pattern text 21 forward scanning present shiftand algorithm easiertoexplain though little less ecient variant shiftor given pattern algorithm builds rst table b character stores bit mask mask bc ith bit set c state search kept machine word matches end text read another way see consider tells whether state numbered figure 2 active therefore report match whenever dm set set originally new text character j update using formula formula correct ith bit set 1th bit set previous text character new text character matches pattern position words possible relate formula movement occurs nondeterministic automaton new text character state gets value previous state happens text character matches corresponding arrow finally j shift allows match begin current text position operation saved shiftor bits complemented corresponds selfloop initial state automaton cost algorithm patterns longer computer word ie w algorithm uses dmwe computer words simulation active time worstcase cost omnw still average case cost 22 classes characters extended patterns shiftor algorithm simple also advantages immediate one easy extend handle classes characters pattern position may match single character set characters c set characters match position pattern set ith bit bc c 2 c necessary algorithm 2 show also allow limited number k mismatches occurrences onm logkw cost paradigm later enhanced support extended patterns 26 allow wild cards regular expressions approximate search nonuniform costs combinations development bitparallelism approach approximate string matching lead fastest algorithms short patterns 3 17 cases key idea simulate nondeterministic nite automaton bitparallelism became general way simulate simple nondeterministic automata instead converting deterministic use paper new type extended patterns focusing 23 backward scanning main disadvantage shiftor inability skip characters makes slower algorithms boyermoore 5 bdm 10 9 families describe section bndm pattern matching algorithm 18 algorithm combination shiftor bdm advantages bitparallel forward scan algorithm addition able skip text characters bndm based sux automaton sux automaton pattern automaton recognizes suxes p nondeterministic version automaton regular structure shown figure 3 original algorithm bdm 10 9 automaton made deterministic bndm instead simulates automaton using bitparallelism shiftand keep state search using bits computer word b b b figure 3 nondeterministic sux automaton pattern lines represent transitions ie occur without consuming input important fact automaton used recognize suxes p also factors p note path labeled x initial state x factor p nondeterministic automaton run active states long read factor p sux automaton used design simple pattern matching algorithm algorithm time worst case optimal average log mm time complex variations turbobdm 10 multibdm 9 21 achieve linear time worst case search pattern text sux automaton p ie pattern read backwards built window length slid along text left right algorithm searches backward inside window factor pattern p using sux automaton ie sux automaton reverse pattern fed characters text window read backward backward search ends two possible forms 1 fail recognize factor ie reach window letter makes automaton run active states means sux window read anymore factor p figure 4 illustrates case shift window right starting position corresponding position following letter cannot miss occurrence case sux automaton would found factor window new search window search factor dawg fail recognize factor new window secure shift figure 4 basic search sux automaton 2 reach beginning window therefore recognizing pattern p since lengthm window factor p indeed equal p report occurrence shift window 1 bitparallel simulation works follows time position window text initialize scan window backward new text character read window update run 1s cannot match suspend scanning shift window perform iterations report match use mask b character c stores bit mask mask sets bits corresponding positions reversed pattern character c shift algorithm formula update bndm faster shiftor bdm 5 100 accommodate extensions mentioned particular interest work easily deal classes characters altering preprocessing far fastest algorithm search type patterns 18 19 note type search called backward scanning text characters inside window read backwards however search progresses left right text window shifted 3 regular expression searching usual way dealing expression character classes bounded gaps actually search full regular expression 13 22 gap form xa b converted letters x followed b subexpressions form xj traditional technique 23 search length om text length n convert expression nondeterministic nite automaton nfa om nodes possible search text using automaton omn worst case time convert nfa deterministic nite automaton dfa worst case time o2 scan text time techniques proposed obtain good tradeo extremes 1992 myers 15 presented fourrussians approach obtains omn log n worstcase time extra space simulation techniques aim good tradeos based combinations dfas bitparallel simulation nfas given 26 20 exist currently many dierent techniques build nfa regular expression r classical one thompsons construction 23 builds nfa 2m states counted number letters second one glushkovs construction popularized berry sethi 4 nfa resulting construction advantage 1 states counted number letters lot research gluskovs construction pursued like 6 shown resulting nfa quadratic number edges worst case 12 long time open question minimal number edges nfa without transition linear number states answered showing construction om states omlog 2 edges well lower bound om log edges hence glushkov construction spaceoptimal research done also try construct directly dfa regular expression without constructing nfa 8 show figure 5 thompson gluskov automata example cbg b c e translate regular expression b c x xj xj e thompson gluskov automata present particular properties algorithms like 15 26 make use thompsons automaton properties others like 20 make use gluskovs ones finally work pursued skipping characters searching simple heuristic variable success implemented gnu grep try nd plain substring inside use search substring lter search complete 24 propose reduce search multipattern search possible strings length match using multipattern boyermoore like algorithm 20 propose use automaton recognizes reversed factors strings accepted fact manipulation original automaton using bndmlike scheme search factors see section 2 however none presented techniques seems fully adequate cbgs first algorithms intrinsequely complicated understand implement second techniques perform poorly certain type res dicult res general whose dfas large common case translating cbgs res third especially regard sizes dfas simplicity cbgs translated corresponding res example cbg rk x2 considered introduction yields dfa needs 600 pointers represented least resorting res implies solving simple problem converting x e e e x e e e e14 15 1611785a thompson construction b c x x x e b gluskov construction figure 5 two classical nfa constructions example b c x xj xj e recall x matches whole alphabet gluskov automaton free present diculties perform ecient bitparallelism complicated one indeed experimental time results applied cbg expressions far reasonable regard simplicity cbgs seen section 7 show section cbgs searched much faster designing specic algorithms next sections 4 forward search algorithm cbg patterns express search problem pattern classes characters gaps using nondeterministic automaton compared simple automaton section 2 one permits existence gaps consecutive positions gap minimum maximum length automaton use correspond presented section 3 although functionality figure 6 shows example pattern b c x1 e letters c inserted three transitions followed letter corresponds maximum length gap two transitions leave state abc recognized skip one two subsequent edges respectively allows skipping one three text characters nding cd end pattern initial selfloop allows match begin text position build nfa start initial state 0 read pattern symbol symbol class characters gap 2 add new automaton edges states new symbol read creating state next pattern symbol class characters c create state i1 add edge labeled c state state i1 hand new pattern symbol gap form xa b create b states labeled 2 note x single letters also seen classes characters b c x x x e e e figure nondeterministic automaton pattern b c x1 linking state j j1 additionally create b transitions state states last state created whole process nal state interested ecient simulation automaton despite particular case regular expression simplicity permits ecient simulation particular fast bitparallel simulation possible represent automaton state bit computer word initial state represented always active normal shiftand shift bits left use table masks b indexed current text character accounts arrows go states j j1 remaining problem represent transitions sake chose 3 represent active states 1 inactive states 0 call gapinitial states states transition leaves gapinitial state corresponding gap xa b dene gapnal state ib a1 ie one following last state reached transition leaving example figure 6 one gapinitial state 3 one gapnal state 6 create bit mask 1 gapinitial states another mask f 1 gapnal states keep state search bit mask performing normal shiftand step simulate moves operation rationale follows first isolates active gapinitial states subtracting f two possible results gapinitial state first active result 1 states ib successfully propagating active state desired target states second inactive result 1 ib a1 undesired 1 removed operating result f propagation done result already active states note propagations dierent gaps interfer since subtractions local eect let us consider example figure 6 corresponding f masks 00000100 00100000 respectively recall bit masks read righttoleft let us also consider read text abc hence mask 00000100 point transitions take eect indeed f states 3 4 5 activated hand propagation formula yields 00100000 00000000 nothing changes figure 7 shows complete algorithm simplicity code assumes cannot gaps beginning end pattern meaningless anyway value maximum length match obtained om time simple pass pattern p summing maximum gap lengths individual classes recall number symbols p preprocessing takes oljj time scanning needs time 3 possible devise formula opposite case unlike shiftor faster however need several machine words simulation thus takes ondlwe time search p 1m 1n preprocessing maximum length match c 2 bc 0 l 0 l f 0 l p j form xa b gap j 1 1 else p j class characters final state scanning report match ending figure 7 forward scanning algorithm 5 backward search algorithm cbg patterns searched patterns contain classes characters backward bitparallel approach see section 2 leads fastest algorithm bndm 18 19 search done sliding text forward direction window size minimum possible alignment read window backwards trying recognize factor pattern reach beginning window found alignment else shift window beginning longest factor found extend bndm deal cbgs recognize reverse factors cbg use quite automaton built section 4 reversed pattern without initial selfloop considering states active beginning create initial state transitions state automaton figure 8 shows automaton pattern b c x1 read automaton factor cbg long exists least one active state b c x x x e e e e e e e e ee e figure 8 nondeterministic automaton built backward algorithm recognize reversed factors cbg b c x1 bitparallel simulation automaton quite forward automaton see section 4 modications build iton p r reversed pattern b bit mask registers state search initialized perform initial transitions c 0 l 1 1 shift initial loop backward cbg matching algorithm shifts window size along text inside window traverses backward text trying recognize factor cbg automaton recognizes factors built reverse pattern p r backward search inside window fails ie active states backward automaton reaching beginning window search window shifted beginning longest factor recognized exactly like rst case classic bndm see section 2 begining window reached automaton still holding active states factor length cbg recognized window unlike case exact string matching occurrences length pattern automatically imply recognized whole pattern need way verify possible alignment much longer starting beginning window read characters beginning window forward automaton section 4 without initial selfloop forward verication ends 1 automaton reaches nal state case found pattern 2 active states automaton case pattern occurrence starting window initial loop forward verication surely nishes reading l characters text shift search window one character right resume search figure 9 shows complete algorithm optimizations shown clarity example many tests avoided breaking loops inside variables reused etc worst case complexity backward scanning algorithm onl quite bad theory particular let us consider maximum gap length g cbg g every text window length factor cbg surely traverse window backward scan always shift 1 complexity n least consequently backward approach presented must restricted least cbgs g backward search p 1m 1n maximum length match preprocessing minimum length match p j form xa b gap f f j 1 1 b b j 1 l else p j class characters final state forward scan pos 0 scanning pos n b 6 0 l j 0 f 6 0 l pos report match beginning pos b 1 figure 9 backward scanning algorithm however average backward algorithm expected faster forward one next section gives good experimental criterion know cases backward algorithm faster forward one experimental search results see section 7 database show backward algorithm almost always fastest 6 algorithm use two dierent algorithms forward backward one natural question one chosen particular problem seek simple criterion enables us choose best algorithm noted end previous section backward algorithm cannot eciently applied length g maximum gap pattern exceeds minimum length string matches pattern backward traversal window never nish traversing whole window string length g factor possible pattern occurrence carried time position window text know least g 1 characters window inspected shifting moreover window shifted g positions hence total number character inspections across search least g larger n number characters inspected forward scan whenever 2g 1 hence dene g 1 simple parameter governing performance backward scan algorithm predict 05 point backward scanning worse forward scanning course measure perfect disregards eect gaps classes characters cost forward checking backward scan full analysis extremely complicated see next section simple criterion gives good results according criterion design optimized version backward scanning algorithm idea choose best prex pattern ie prex 1 backward scanning done using prex forward verication potential matches done full pattern could extended selecting best factor pattern code would complicated verication phase would scan directions buering would complicated see next section dierence large 7 experimental results tested algorithms example 1168 prosite patterns 13 11 6 megabytes mb text containing concatenation protein sequences taken tigr microbial database set originally 1316 patterns selected 1230 whose l maximum length match exceed w number bits computer word machine leaves us 93 patterns excluded 62 5 g explained cannot reasonably searched backward scanning leaves us 1168 patterns used intel pentium iii machine 500 mhz running linux show user times averaged 10 trials three dierent algorithms tested fwd forwardscan algorithm described section 4 bwd backwardscan algorithm section 5 opt bwd select backward searching best prex pattern according criterion previous section rst experiment aims measuring eciency algorithms respect criterion previous section figure 10 shows results patterns classied along x axis g predicted 05 value bwd starts worse fwd except exceptions dierence big anyway also clear opt avoids many worst cases bwd finally plot shows time fwd stable forward scan runs always around 5 mbsec backward scan fast 20 mbsec g1ell secsmb bwd g1ell secsmb opt figure 10 search times seconds per mb patterns classied g 1 value figure fails show fact prosite patterns low g 1 value figure 11 plots number patterns achieving given search time removing outliers 12 took 04 seconds bwd fwd large peak stable time backward scanning algorithms wider histogram whose main body well peak fwd indeed 956 patterns searched faster bwd fwd percentage raises 976 consider opt plot also shows little statistical dierence bwd opt rather opt useful remove bad cases bwd third experiment aims comparing search method converting pattern regular expression resorting general regular expression searching existing algorithms search regular expressions selected following dfa builds deterministic nite automaton uses search text nfa builds nondeterministic nite automaton uses search text updating states text position myers intermediate dfa nfa 15 nondeterministic automaton formed blocks 4 experiments block deterministic automaton subset states xj expressed syntax software agrep existing software 26 25 implements another intermediate dfa nfa transitions handled using bitparallelism transitions deterministic table xj expressed syntax software secsmb frequency bwd opt figure 11 histogram search times dierent algorithms grep gnu grep option e make accept regular expressions software uses heuristic addition lazy deterministic automaton searching looks long enough literal pattern substrings uses fast lter search gaps xa b converted fabg permit specialized treatment grep bndm uses backward approach extended cbgs adapted general res instead 20 needs build deterministic automata one backward search another forward verication multipattern reduces problem multipattern boyermoore searching strings length match 24 used agrep f multipattern search algorithm added fwd opt algorithms figure 12 shows results forward scanning algorithms ie fwd dfa nfa myers unable skip text characters fastest fwd algorithm thanks simplicity agrep mean much variance dfa suers high preprocessing times large generated automata nfa needs update many states one one text character read myers suers combination shows two peaks come specialized code deal small automata backward scanning algorithms opt grep able skip text characters faster previous ones almost cases among opt faster average less variance times grep extend range surpasses time fwd algorithm nonnegligible portion patterns grep cannot always nd suitable ltering substring case resorts forward scanning note bndm multipattern excluded plots due poor performance set patterns apart faster text scanning algorithms also benet lower preprocessing times compared algorithms resort regular expression searching barely noticeable previous experiment important common scenario protein searching problem patterns set searched inside new short protein case preprocessing time patterns much important scanning time normally rather short protein secsmb frequency opt dfa nfa myers agrep grep figure 12 histogram search times best algorithms regular expression searching algorithms simulated scenario selecting 100 random substrings length 300 text running previous algorithms 1168 patterns table 1 shows time averaged 100 substrings accumulated 1168 patterns dierence favor new algorithms drastic note also problem interesting eld research multipattern cbg search algorithms algorithm fwd bwd opt dfa nfa myers agrep grep time table 1 search time seconds 1168 patterns random protein length 300 conclusions presented two new search algorithms cbgs ie expressions formed sequence classes characters bounded gaps cbgs special interest computational biology applications current approaches rely converting cbg regular expression much complex therefore search cost much higher necessary cbg algorithms specically designed cbgs based bndm combination bitparallelism backward searching sux automata combination recently proved eective patterns formed simple letters classes characters 18 19 extended bndm allow limited gaps presented experiments showing new algorithms much faster predictable algorithms based regular expression searching addition presented criterion select best among two experimentally shown reliable makes algorithms special interest practical applications protein searching plan extend present work designing algorithm able skip characters time ensures linear worst case time extending scope present optimized algorithm select best factor best prex search challenging types search allowing negative gaps errors matches see eg 16 algorithms especially easy extend permit errors pursuing direction r text retrieval theory practice new approach text searching faster approximate string matching regular expression deterministic automata fast string searching algorithm generalized pro regular expression dfas using nfas algorithms speeding two stringmatching algorithms database juraj hromkovi fast pattern matching strings approximate matching network expressions spacers fast bitvector algorithm approximate pattern matching based dynamic progamming fast exible string matching combining bitparallelism sux automata fast regular expression matching multi backward dawg matching algorithm multibdm screening protein nucleic acid sequences libraries patterns regular expression search algorithm taxonomies toolkits regular language algorithms fast text searching allowing errors tr regular expressions deterministic automata four russians algorithm regular expression pattern matching new approach text searching fast text searching regular expressions finite automata text algorithms fast bitvector algorithm approximate string matching based dynamic programming programming techniques regular expression search algorithm fast flexible string matching combining bitparallelism suffix automata textretrieval translating regular expressions small epsilonfree nondeterministic finite automata fast regular expression search bitparallel approach suffix automata ctr alberto policriti nicola vitacolonna michele morgante andrea zuccolo structured motifs search proceedings eighth annual international conference resaerch computational molecular biology p133139 march 2731 2004 san diego california usa gonzalo navarro mathieu raffinot fast flexible string matching combining bitparallelism suffix automata journal experimental algorithmics jea 5 p4es 2000
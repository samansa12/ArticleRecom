purely functional realtime deques catenation describe efficient purely functional implementation deques catenation addition intriguing problem right finding purely functional implementation catenable deques required add certain sophisticated programming constructs functional programming languages solution worstcase running time o1 push pop inject eject catenation best previously known solution ologk time bound kth deque operation solution faster simpler key idea used result algorithmic technique related redundant digital representations used avoid carry propagation binary counting b introduction persistent data structure one change structure made without destroying old version versions structure persist least accessed structure said partially persistent even modified structure said fully persistent functional programming literature fully persistent structures often called immutable purely att laboratories florham park nj work done princeton university supported office naval research contract n0001491j1463 nsf grants ccr8920505 ccr9626862 united statesisrael educational foundation usief fulbright grant hklresearchattcom department computer science princeton university princeton nj 08544 usa intertrust technologies sunnyvale ca research princeton university partially supported nsf grants ccr8920505 ccr9626862 office naval research contract n0001491j1463 retcsprincetonedu functional 1 programming without side effects property every structure created automatically fullypersistent persistent data structures arise functional programming also text program file editing maintenance computational geometry algorithmic application areas see 6 10 11 12 13 14 15 16 24 37 38 39 40 41 number papers discussed ways making specific data structures search trees persistent smaller number proposed methods adding persistence general data structures without incurring huge time space costs obvious method copy entire structure whenever change made particular driscoll sarnak sleator tarjan 14 described make pointerbased structures persistent using technique called nodesplitting related fractional cascading 7 way yet fully understood dietz 11 described method making arraybased structures persistent additional references persistence found driscoll et al dietz papers general techniques fail work data structures combined rather changed locally driscoll sleator tarjan 13 coined term confluently persistent refer persistent structure update operations combine two different versions perhaps simplest probably important example combining data structures catenation appending lists confluently persistent lists catenation surprisingly powerful example using selfcatenation one build list exponential size linear time paper deals problem making persistent list catenation efficient consider following operations manipulating lists return new list consisting singleton element x return list formed adding element x front list l popl return pair consisting first element list l list consisting second last elements lfor purposes paper purely functional data structure one built using lisp functions car cons cdr though state constructions explicitly terms functions routine verify structures purely functional definition purely functional extremely strict example allow techniques memoization contrasts work example okasaki 33 34 35 36 discussion issue see sections 2 7 return list formed adding element x back list l return pair consisting last element list l list consisting first nexttolast elements l catenatek l return list formed catenating k l k first observe push inject special cases catenate convenient us treat separate operations however accordance convention call list subject push pop inject eject stack list subject inject pop push eject queue adopting terminology knuth 29 call list subject four operations push pop inject eject doubleended queue abbreviated deque pronounced deck departure existing terminology call list subject push pop inject stackended queue steque pronounced steck knuth called steques outputrestricted deques stackended queue easy shorten evokes idea steque combines functionalities stack queue steques catenation stacks catenation since catenation makes inject push matter redundant call data structure constant worstcase time bounds operations realtime structure main result realtime purely functional hence confluently persistent implementation deques catenation data structure efficient simpler previously proposed structures 4 13 addition interesting problem right data structure provides way add fast catenation listbased programming languages scheme implement sophisticated programming constructs based continuations functional programming languages see 15 16 key ingredient result algorithmic technique related redundant digital representations devised avoid carry propagation binary counting remainder paper consists six sections section 2 surveys previous work dealing problems related making lists persistent adding catenation efficient list operation section 3 motivates approach section 4 describes make deques without catenation purely functional thereby illustrating ideas simple setting section 5 describes make stacks steques catenation purely functional illustrating additional ideas needed handle catenation comparatively simple setting stacks section 6 presents general result implementation deques catenation result uses additional idea needed handle underlying treelike recursive structure place linear structure section 7 mentions additional related results open problems preliminary version part work presented 27 th annual acm symposium theory computing 27 previous work work related found three branches computer science data structures functional programming perhaps surprisingly turing machine complexity shall describe work approximately chronological order detail attempt sort somewhat tangled history let us put aside catenation moment consider problem making noncatenable lists fully persistent easy make stacks persistent represent stack pointer singlylinked list elements top element stack first element list push element onto stack create new node containing new element pointer node containing previously first element stack pop stack retrieve first element pointer node containing previously second element standard lisp representation list collection persistent stacks represented way consists collection trees pointer child parent two stacks common suffixes share one list representing common suffix common suffixes guarantee sharing however since two stacks identical content built two separate sequences push pop operations maximum sharing suffixes achieved using hashed consing technique new node created corresponds distinct new stack see 1 42 making queue steque deque persistent simple one approach advantage giving purely functional solution represent data structure fixed number stacks operation becomes fixed number stack operations seek realtime simulation queue steque deque fixed number stacks problem giving realtime simulation deque fixed number stacks closely related old problem turing machine complexity giving realtime simulation onedimensional multihead tape unit fixed number onedimensional onehead tape units two problems reduced one another noting deque simulated twohead tape unit onehead tape unit simulated two stacks thus deque problem reduced tape problem conversely khead tape unit simulated deques two stacks stack simulated onehead tape thus tape problem reduced deque problem two gaps reductions first deque element potentially chosen infinite universe whereas universe tape symbols always finite allows possibility solving tape problem using clever symbol encoding might applicable deque problem none known solutions tape problem exploits possibility give solutions deque problem reduction second gap reductions necessarily minimize numbers stacks onehead tapes simulation goal deque tape problem must addressed directly first step toward solving tape simulation problem taken stoss 43 produced lineartime simulation multihead tape fixed number onehead tapes shortly thereafter fisher meyer rosenberg 17 gave realtime simulation multihead tape fixed number onehead tapes latter simulation uses tapefolding technique directly related method stoss later leong seiferas 32 gave realtime multiheadtape simulation using fewer tapes cleverly augmenting stosss idea approach also works multidimensional tapes apparently true tapefolding idea reduction described deque simulation problem already solved two different methods time work problem began appearing data structure functional programming literature nevertheless latter work important deals deque simulation problem directly leads efficient conceptually simpler solution although several works 5 8 19 20 21 22 23 34 39 dealing deque simulation problem describe essentially solution solution based two key ideas mimic ideas stoss leong seiferas first idea deque represented pair stacks one representing front part deque representing rear part one stack becomes empty many pop eject operations deque one stack copied two stacks containing half deque elements fiftyfifty split guarantees copying even though expensive happens infrequently simple amortization argument using potential function equal absolute value difference stack sizes shows gives lineartime simulation deque constant number stacks k deque operations starting empty deque simulated ok stack operations see 44 discussion amortization potential functions simple idea essence stosss tape simulation idea representing queue two stacks way appears 5 20 22 representation deque appears 19 21 23 39 second idea use incremental copying convert lineartime simulation realtime simulation soon two stacks become sufficiently unbalanced recopying create two balanced stacks begins recopying must proceed concurrently deque operations among things causes size deque moving target details simulation little complicated hood melville 22 first spelled details method case queue hoods thesis 21 describes simulation deque see also 19 39 chuang goldberg 8 give particularly nice description deque simulation okasaki 34 gives variation simulation uses memoization avoid explicit stacktostack copying solution gives persistence strictly functional since memoization side effect completely different way make deque persistent apply general mechanism driscoll et al 14 solution strictly functional constant time bound per deque operation amortized worstcase catenation added operation problem making stacks deques persistent becomes much harder methods mentioned fail kosaraju obtained couple intriguing results deserve mention although solve problem consider first 30 gave realtime simulation catenable deques noncatenable deques unfor tunately solution support confluent persistence particular kosaraju explicitly disallows selfcatenation solution also realtime fixed number deques time per deque operation increases least linearly number deques second 31 gave realtime randomaccess implementation catenable deques find minimum operation problem discussed section 7 solution realtime variable number deques support confluent persistence indeed kosaraju 31 states ideas might helpful making mindeques confluently persistent however previous solutions problem making catenable deques fully persistent straightforward use balanced trees gives representation persistent catenable deques operation deque deques total size n takes olog n time driscoll sleator tarjan 13 combined tree representation several additional ideas obtain implementation persistent catenable stacks k th operation takes olog log buchsbaum tarjan 4 used recursive decomposition trees obtain two implementations persistent catenable deques first time bound 2 olog k second time bound olog k k th operation log k iterated logarithm defined log 1 log 2 k log 1g work motivated 3 recursive slowdown section describe key insight led result although insight explicit ultimate construction needed understand idea may helpful making progress problems reason offer spark work observation concerning recurrence gives time bounds buchsbaumtarjan data structures recurrence following form c constant operation structure size n takes constant amount time plus fixed number operations recursive substructures size log n first version buchsbaumtarjan structure c fixed constant greater one recurrence gives time bound n second version structure c equals one recurrence gives time bound n olog n suppose could design structure constant c less one recurrence would give bound n o1 indeed recurrence gives bound n o1 constant c 1 used similar observation improve time bound selection minheap ok2 log k ok thus obtain o1 time bound operations data structure operation requires o1 time plus half operation smaller recursive substructure achieve effect data structure requires one operation recursive substructure every two operations toplevel structure call idea recursive slowdown main new feature data structure mechanism implementing recursive slow stated abstractly basic problem allocate work cycles levels linear recursion top level gets half cycles second level gets one quarter cycles third level gets one eighth cycles exactly happens binary counting specifically begin zero repeatedly add one binary addition one causes unique bit position change zero one every second addition position ones bit every fourth addition twos bit every eighth addition fours bit course binary counting addition one change many bits zero obtain realtime performance additional work must avoided one using redundant digital representation numbers one representation single digit change needed add one clancy knuth 9 used idea implementation finger search trees descriptions redundant representations well applications found 2 9 28 clancyknuth method represents numbers base two using three digits 01 2 redundant binary representation rbr nonnegative number x sequence digits n representation general unique call rbr regular every j exists words scanning digits significant least significant finding 2 must find 0 finding another 2 running digits implies particular 0 6 2 add 1 number x represented regular rbr first add 1 0 result rbr x 1 may regular restore regularity finding least significant digit 1 setting rbr already regular straightforward show method correctly adds 1 changing constant number digits thus avoiding explicit carry propagation work allocation mechanism lists uses threestate system corresponding three digits 0 1 2 clancyknuth number representation instead digits use colors level recursive data structure green yellow red color based state structure level red structure bad converted green structure cost degrading structure one level deeper green yellow yellow red maintain invariant levels two red levels separated least one green level ignoring intervening yellow levels greenyellowred mechanism applied underlying linear structure suffices add constanttime catenation stacks handle deques must extend mechanism apply underlying tree structure involves adding another color orange whereas greenyellowred system close analogue clancyknuth number representation extended system distantly related postpone discussion extension section 6 used 4 deques without catenation section present realtime purely functional implementation deques without cate nation example illustrates ideas simple setting provides alternative implementation based pair incrementally copied stacks described section 2 section 5 modify structure support stacks catenation add catenate operation remove eject finally section 6 modify structure support catenable deque operations last step involves extending work allocation mechanism mentioned end section 3 recall operations possible deque pushxd popd injectxd ejectd subsequent sections say data structure set stores elements 41 representation represent deque recursive structure built boundedsize deques called buffers buffer hold five elements buffers two kinds prefixes suffixes nonempty deque set represented ordered triple consisting prefix prefixd elements child deque childd whose elements ordered pairs elements suffix suffixd elements order elements within one consistent orders component parts child deque childd nonempty represented way thus structure recursive unwinds linearly define descendants fchild dg deque standard way namely child 0 child child nonempty observe elements elements elements childd pairs elements elements childchildd pairs pairs elements one think element child complete binary tree depth 2 elements 2 leaves one also think entire structure representing stack descendants element prefixsuffix pair elements stored prefixes suffixes various levels structure grouped binary trees appropriate depths level contains prefix suffix child see figure 41 pairing bring two elements level one pop eject level 1 similarly move two elements level one push inject level 1 twoforone payoff gives recursive slowdown leads realtime performance obtain realtime performance must guarantee toplevel deque operation requires changes constant number levels recursive structure reason impose regularity constraint structure assign buffer deque color either green yellow red buffer green two three elements yellow one four red zero five observe add one element delete one element green yellow buffer without violating size constraint green buffer stays green becomes yellow yellow buffer becomes green red order colors red yellow green red bad green good higher buffer color 2 depth complete binary tree number edges roottoleaf path figure 41 representation deque square brackets denote deque descendant deques parentheses denote buffers curly brackets denote expansion deque component parts numbers denote levels deques triangles level three denote pairs pairs pairs equivalently complete binary trees depth three indicates insertions deletions buffer possible size outside allowed range define color nonempty deque minimum colors prefix suffix unless child one buffers empty case color deque color nonempty buffer regularity constraint deque constraint colors sequence descendant deques childd child call semiregular two red deques sequence green deque ignoring intervening yellows formally semiregular two red deques child child j k child k green call regular semiregular addition first nonyellow deque sequence green observe regular semiregular childd indeed child 0 semiregular furthermore semiregular red childd regular strategy obtaining realtime performance maintain constraint toplevel deque regular except possibly middle deque operation deque temporarily become semiregular regular deque top level green yellow means deque operation performed operating appropriate toplevel buffer may change top level green yellow yellow red either cases deque may longer regular semiregular semiregular topmost nonyellow descendant deque red restore regularity changing red deque green process possibly changing child deque green yellow yellow red green observe color changes effect restore regularity process corresponds addition 1 redundant binary numbering system discussed section 3 process changing red deque green change elements contains order merely move elements buffers buffers child thus making change obtain toplevel regular deque merely restoring levels top changed deque topmost red deque may arbitrarily deep recursive structure since separated top level many yellow deques achieve realtime performance need constanttime access topmost red deque reason represent deque obvious way stack prefixsuffix pairs instead break stack substacks one substack toplevel deque one nonyellow descendant deque top level substack consists toplevel nonyellow deque consecutive yellow proper descendant deques represent entire deque stack substacks prefixsuffix pairs using partition substacks equivalent pointerbased representation use node four pointers nonempty descendant deque two pointers prefix suffix corresponding level one pointer node child deque deque nonempty yellow one pointer node nearest nonyellow proper descendant deque deque exists nonyellow toplevel see figure 42 figure single deque operation require access top three substacks top two elements substack color changes caused deque operation produce minor changes stack partition substacks changes made constant time particular changing color toplevel deque affect partition g r g r figure 42 pointer representation stack substacks structure horizontal lines denote buffers letters indicate deque colors left pointers link elements within substacks right pointers link tops substacks null pointers denoted substacks changing topmost red deque green child yellow nonyellow splits one substack first element new substack rest substack pop operation changing topmost red deque green child green yellow merges singleton substack substack substack push operation 42 deque operations remains describe details buffer manipulations verify produce claimed color changes perform push pop push pop appropriate element onto toplevel prefix unless prefix child deque empty case toplevel suffix inject eject symmetric original deque regular top level originally green yellow operation performed without overflowing underflowing buffer unless try pop eject already empty deque top level may change green yellow yellow red may make new deque semiregular restore semiregular deque regular regular follows let topmost red th st level prefixes st th level suffixes respectively viewing elements perspective level call elements p i1 i1 pairs since pair leveli elements note either p i1 i1 empty i1 since level cannot red apply appropriate one following three cases twobuffer case jp 2 p i1 empty pop pair i1 inject eject pair p i1 push onto i1 jp eject two elements p pair push pair onto p i1 js j 4 pop two elements pair inject pair i1 jp pair p i1 inject two elements individually p js eject pair i1 push two elements bottommost level p i1 i1 empty eliminate level 1 onebuffer case jp 2 level bottommost level create new empty level 1 js pop pair i1 inject p i1 eject two elements p pair push pair onto p i1 js j 4 pop two elements pair inject pair p i1 jp pair p i1 inject two elements p js eject pair p i1 push two elements onto nobuffer case jp contain 2 3 leveli elements two paired p i1 i1 move elements exists note even though deque operation one end deque regularization procedure operates ends descendant deques concurrently theorem 41 given regular deque method described perform push pop inject eject operation o1 time resulting regular deque proof nontrivial part proof verify regularization procedure correct straightforward verify deque operation performed correctly time bound o1 given stackofsubstacks representation twobuffer case occurs p i1 i1 nonempty level yellow first two steps level starts green yellow semiregularity making p i1 i1 nonempty cannot make level red remaining steps make level green change sizes p i1 i1 one situation level green end red jp initially jp finally case level must bottommost level eliminated end case thus case makes color changes needed restore regularity onebuffer case occurs since level initially red level must bottommost level case makes level green makes level empty case eliminated thus case also makes color changes needed restore regularity nobuffer case occurs p i1 i1 must contain pair otherwise level empty hence nonexistent level yellow nonempty contradicts fact level topmost red level also one p contain element follows case restores regularity 2 data structure described simplified subset four operations push pop inject eject allowed example push allowed prefixes restricted size 0 3 0 red 1 yellow 2 3 green similarly eject allowed suffixes restricted size 0 3 0 1 green 2 yellow 3 red thus represent queue inject pop buffers size 3 alternatively represent steque pair consisting stack queue pushes onto stack injects queue pop stack unless stack empty case queue 5 realtime catenation next goal deque structure supports fast catenation since catenable steques deques without eject easier implement catenable deques discuss catenable steques delay discussion structure supports full set operations section 6 throughout rest paper refer catenable steque simply steque 51 representation representation steques like structure section 4 two major differences component parts section 4 use buffers two different kinds prefixes suffixes unlike section 4 buffer noncatenable steque upper bound size steque implemented using either method section 4 stackreversing method sketched section 2 possible efficiency enhancement store buffer size although fact necessary obtain constanttime operations require prefix contain least two elements lower bound size suffix indeed suffix empty second difference components pairs stored child steque define pair set recursively follows pair consists prefix elements possibly empty steque pairs represent nonempty steque either suffix suffixs elements triple consisting prefix prefixs elements child steque childs pairs suffix suffixs elements child steque nonempty represented way nonempty steque one pairs childs order elements within steque one consistent order component paths figure 51 figure 51 partial expansion representation steque square brackets denote catenable steques horizontal lines denote buffers curly brackets denote expansion steque component parts arrows denote membership circles denote elements base set numbers denote levels steques figure structure doubly recursive steque structure either toplevel steque child another steque second component pair stored another steque define level steque structure follows toplevel steque level 0 steque level child leveli steque pair stored leveli observe every leveli steque type elements namely elements level0 steques elements elements level1 steques pairs elements level2 steques pairs pairs steques catenated need level otherwise elements different types extra kind recursion compared structure section 4 one sequence descendent steques many toplevel steque steque stored pair structure begins sequence consisting steque child grandchild among descendants one represented suffix instead prefix child suffix triple last one may order steque operations terms implementation complexity follows push inject simplest catenate nextsimplest pop mostcomplicated push inject simple operation single buffer buffers grow arbitrarily large means overflow problem perform catenate operation push inject operations extra kind recursion pop complicated operation require catenate may also threaten buffer underflow prevent mechanism like used section 4 prefix color red prefix contains two elements yellow three green four nonempty steque structure also color color prefix one otherwise green call steque semiregular pair red steques descendent sequence within green steque ignoring intervening yellows call steque regular semiregular addition first nonyellow steque sequence child 1 child green section 4 maintain invariant toplevel steque regular except possibly middle steque operation may temporarily semiregular observe regular childs semiregular semiregular steque green prefix child steque regular representation steques corresponds section 4 namely represent descendent sequence stack substacks breaking descendent sequence subsequences beginning first steque nonyellow steque containing consecutively following yellow steques element substack pair consisting prefix suffix corresponding steque null indicator nonexistent prefix element prefix suffix element base set prefix suffix level 0 pair appropriate type prefix suffix deeper structure see figure 52 r g r g figure 52 pointer representation substack decomposition part partially expanded steque figure 51 sequences descendants shown letters denote steque colors left pointers link elements within substacks right pointers link tops substacks null pointers denoted 52 steque operations noted push inject operations simplest steque operations implement changes single buffer increasing size one specifically inject element x steque inject x suffixs push element x onto steque push x onto prefixs unless prefix case push x onto suffixs push may change color toplevel steque red yellow yellow green helps regularity constraint change substack decomposition catenate operation somewhat complicated consists push inject operations specifically form catenation 3 two steques 1 2 apply appropriate one following three cases case 1 1 triple suffixs 1 contains least two elements inject pair suffixs 1 childs 1 converts suffixs 1 prefix otherwise suffixs 1 contains one element push element onto 2 2 triple inject pair prefixs 2 3 triple prefixs 1 case 2 1 suffix 2 triple jsuffixs 1 j 4 push pair prefixs 2 onto let result 3 triple suffixs 1 green prefix otherwise pop three elements suffixs 1 push opposite order onto prefixs 2 let 3 prefixs 2 case 3 1 2 suffixes jsuffixs 1 j 4 let 3 suffixs 1 suffixs 2 makes suffixs 1 green prefix otherwise pop three elements suffixs 1 push opposite order onto suffixs 2 let 3 suffixs 2 lemma 51 1 2 semiregular 3 semiregular addition 1 regular 3 regular proof case 3 steque 3 toplevel one green thus 3 regular case 2 push onto childs 2 happens preserves semiregularity childs 2 prefix result steque 3 green thus 3 regular case 1 childs 1 childs 2 semiregular injections childs 1 preserve semiregularity steque 1 prefix 1 child steque 1 save possibly one two injects thus 3 semiregular 1 regular 1 2 pop complicated steque operation pop steque suffix merely pop suffix pop steque triple pop prefix may result steque longer regular semiregular restore regularity modifying nearest red descendant steque say 1 toplevel steque follows childs 1 empty pop two elements prefixs 1 push opposite order onto suffixs 1 represent 1 suffix otherwise pop pair say p pop two elements prefixs 1 push opposite order onto p catenate 2 childs 1 form 3 replace 1 triple p 3 lemma 52 restoration method described converts semiregular steque regular thus implementaiton pop correct proof let 1 nearest red descendant steque childs 1 empty 1 replaced green steque child result regular steque suppose childs 1 nonempty pop regular semiregular since 1 semiregular since 1 red nearest nonyellow descendant childs 1 must green hence childs 1 least semiregular pop triple p 3 replacing 1 p green 3 semiregular means regular 2 theorem 51 push pop inject regular steque takes o1 time results regular steque catenation two regular steques takes o1 time results regular steque proof o1 time bound per steque operation obvious stack substacks representation used regularity obvious push inject true catenate lemma 51 pop lemma 52 2 alternative way build realtime catenable steques using noncatenable stacks buffers see 25 6 catenable deques finally extend ideas presented previous two sections obtain data structure supports full set deque operations namely push pop inject eject catenate o1 time omit certain definitions obvious extensions previous sections common feature two data structures presented far underlying linear skeleton sequence descendants structure catenable deques replaces linear skeleton binarytree skeleton seems required efficiently handle pop eject branching skeleton turn requires change workallocation mechanism must funnel computation cycles branches tree add one color orange color scheme replace twobeat rhythm greenyellowred mechanism threebeat rhythm obtain o1 time bound per deque operation essentially 23 1 2 corresponds branching factor tree structure 3 corresponds rhythm work cycle connection redundant numbering systems much looser greenyellow red scheme used sections 4 5 nevertheless able show directly extended mechanism solves problem 61 representation representation deques uses two kinds buffers prefixes suffixes buffer noncatenable deque implement buffers either described section 4 using incremental stackreversing method outlined section 2 henceforth deque mean catenable deque unless explicitly state otherwise section 5 optionally store buffer size may provide constantfactor speedup define triple set recursively prefix elements possibly empty deque triples suffix elements triple deque call stored triple represent nonempty deque either one triple called triple ordered pair triples left triple right triple deques within triple represented recursively way order elements within deque one consistent order component parts define parentchild relation triples follows deque suffix triple deque 6 children one two triples make deque define ancestors descendants standard way relation triples group trees whose nodes unary binary toplevel triple stored triple root tree deque represented one two trees rooted toplevel triples figure 61 figure 61 partial expansion representation catenable deque conventions figure 51 two triples comprising deque separated comma figure 61 four different kinds triples stored triples triples left triples right triples impose size constraints buffers triple depending upon kind stored triple require p contain least three elements unless one buffers empty case buffer must contain least three elements triple require p contain least five elements unless one buffers empty case buffer contain nonzero number elements left triple require p contain least five elements exactly two symmetrically right triple require contain least five elements p exactly two assign colors triples based types buffer sizes follows let triple stored triple green left triple 6 green p contains least eight elements yellow p contains seven orange six red five symmetrically right triple 6 green contains least eight elements yellow seven orange six red five triple 6 green p contain least eight elements yellow one contains seven least seven orange one contains six least six red one contains five least five triples grouped trees parentchild relation partition trees paths follows yellow orange triple preferred child left child child triple yellow right child child triple orange preferred children define preferred paths starting triple preferred child passing successive preferred children reaching triple without preferred child thus preferred path consists sequence zero yellow orange triples followed green red triple every triple children green assign preferred path color green red according color last triple impose regularity constraint structure like sections 4 5 little complicated call deque semiregular following conditions hold 1 every preferred path starts child red triple green path 2 every preferred path starts nonpreferred child orange triple green path definition implies deque semiregular deques constituent triples semiregular call deque regular semiregular addition preferred path starts toplevel triple one one two representing entire deque green path maintain invariant toplevel deque regular except possibly middle deque operation may temporarily semiregular note empty deque regular need representation trees triples allows us shortcut preferred paths end introduce notions adopted child adoptive parent every green red triple preferred path least three triples adopted child first triple path adoptive parent adoptive parentadopted child relationship first last triples preferred path containing least three triples define compressed forest parentchild relation triples except adopted child child adoptive parent instead natural parent compressed forest triple three children one may adopted represent deque compressed forest node triple containing prefix suffix triple pointers nodes representing child triples see figure 62 figure operations describe next section rely following property compressed forest representation given node triple extract constant time pointer compressed forest representation toplevel triple stored triple color either red green 62 deque operations simplest deque operations push inject next catenate may require push inject complicated operations pop eject violate regularity may force repair deep forest triples shallow compressed forest begin describing push inject symmetric let deque onto wish push element empty create new triple represent new deque one nonempty buffer containing pushed element nonempty let left triple triple p 1 nonempty push new element onto otherwise push new element onto 1 g r g g figure 62 toplevel trees compressed forest representation deque letters denote triples corresponding colors dashed arrows denote adoptiveparent adoptivechild relationships replace natural parentchild relationships marked hatched arrows complete compressed forest representation shown would include buffers triples lowerlevel compressed trees rooted stored triples lemma 61 push onto semiregular deque produces semiregular deque push onto regular deque produces regular deque proof push change color lemma immediate push change color must yellow green orange yellow red orange redtoorange happen original deque semiregular regular yellow togreen case obviously preserves semiregularity regularity orangetoyellow case let u nonpreferred child push nonpreferred child u exists semiregularity implies preferred path containing u green path push adds front path means push preserves semiregularity regularity u exist push change preferred paths changes orange yellow case also push preserves semiregularity regularity redtoorange case push every child starts preferred path green means push nonpreferred child exists starts preferred path green thus push preserves semiregularity 2 note effect push preferred path decomposition add delete front preferred path means compressed forest updated o1 time push next describe catenate let e two deques catenated assume nonempty otherwise catenate trivial catenate e apply appropriate one following four cases case 1 buffers two three four toplevel triples e nonempty new deque consist two triples u formed toplevel triple triples u formed toplevel triple triples e four subcases formation subcase 1a deque consists two triples containing exactly two elements single buffer p 3 eject last two elements 2 add new buffer 3 2 rest inject p 3 subcase 1b deque consists two triples inject elements 1 p 2 p 1 form p 0 1 replace representation triple p 0 apply subcase 1c 1d appropriate subcase 1c deque consists triple eject last two elements 1 add new buffer 2 let remainder 1 0 1 form new triple 0 inject 1 form 0 subcase 1d deque consists triple contains eight elements move last two elements 1 p 1 form p 0 let remaining two elements 1 form 0 contains eight elements move first three elements 1 p 1 form p 0 move last two elements 1 new buffer 2 let remainder 1 0 1 push triple 0 empty deque form deque 2 let operate symmetrically e form u case 2 deque consists triple one nonempty buffer buffers toplevel triple triples e nonempty let left triple e combine 1 2 form new triple left triple new deque right triple e exists right triple new deque form let p 3 nonempty one p 1 1 p 3 contains less eight elements push elements otherwise form triple p 2 push onto 2 case 3 deque e consists triple one nonempty buffer buffers toplevel triple triples nonempty case symmetric case 2 case 4 deques e consist triple single nonempty buffer let p nonempty buffer nonempty buffer e either p contains fewer eight elements combine single buffer b let lemma 62 catenation two semiregular deques produces semiregular deque catenation two regular deques produces regular deque proof consider case 1 shall show subcase triple descendants satisfy semiregularity regularity constraints appropriate symmetric argument applies u gives lemma case 1 subcase 1d triple green either green child grandchildren child either case satisfies regularity constraints consider subcase 1c deque 0 1 formed semiregular deque 1 injection hence semiregular lemma 61 color triple least good color triple since color depends size p 1 whereas color 1 depends minimum sizes p 1 1 must consider several cases depending color 1 whether trying verify regularity semiregularity 1 green descendants satisfy regularity constraints 1 red semiregularity implies 1 hence 0 1 regular descendants satisfy semiregularity constraints 1 orange regular 1 hence 0 1 must regular descendants satisfy regularity constraints 1 orange semiregular nonpreferred child 1 exists starts green path corresponding nonpreferred child also starts green path argument like lemma 61 means descendants satisfy semiregularity constraints 1 yellow semiregularity 0 1 implies descendants satisfy semiregularity constraints finally 1 yellow regular preferred child 1 green path corresponding child argument like lemma 61 thus descendants satisfy regularity constraints subcase 1b creates onetriple representation semiregular original representation regular original one subcase 1b followed application 1c 1d appropriate case triple descendants satisfy semiregularity regularity constraints appropriate last subcase subcase 1a case 1c argument depends color whether trying verify regularity semiregularity case 1 exactly color deque 0 1 semiregular lemma 1 since 1 2 semiregular remainder argument exactly subcase 1c consider case 2 p 3 contains less eight elements formed seven pushes onto 2 satisfies regularity semiregularity lemma 61 otherwise deque 0 2 formed deque 2 push triple either green color triple remainder argument exactly subcase 1c case 3 symmetric case 2 case 4 obviously preserves semiregularity regularitya catenate changes colors compositions triples constant number levels top compressed forest structure hence structure updated constant time catenate come finally last two operations pop eject shall describe pop eject symmetric pop consists two parts first removes element popped second repairs damage regularity caused removal let left triple deque popped first part pop consists popping prefix popping suffix prefix empty replacing triple 0 resulting pop forming 0 shall see 0 may regular semiregular preferred path starting 0 may red case let u red triple end preferred path using compressed forest representation access u constant time second part pop replaces u descendants tree triples representing elements green root v satisfies regularity constraints produces regular representation 0 finishes pop repair apply appropriate one following cases since u red case 1 triple u left triple pop first triple p 1 rest 1 case 1a p 2 2 nonempty push 2 onto 0 1 push elements 2 catenate deques 2 00 case 1b one p 2 2 empty combine single buffer p 3 let case 2 triple u triple apply appropriate one following three cases case 2a suffix 1 contains least eight elements proceed case 1 obtaining containing least eight elements case 2b prefix p 1 contains least eight elements proceed symmetrically case 1 obtaining containing least eight elements case 2c p 1 1 contain seven elements pop first triple p 1 without repair let 0 1 rest 1 0 otherwise eject last triple 1 without repair let 00 1 rest 0 1 one p 2 2 empty combine single buffer p 4 let 00 push elements p 1 onto p 2 forming p 4 catenate 2 000 1 form 4 symmetrically one p 3 3 empty combine p 3 3 1 single buffer 4 let otherwise inject p 3 4 forming 0 inject elements 1 4 3 form 5 let lemma 63 removing first element first buffer regular deque produces semiregular deque whose violation regularity constraint preferred path containing left toplevel triple may red removing first last elements first last buffers respectively regular deque produces semiregular deque proof let regular deque let left triple let 0 formed popping p 1 let 0 formed replacing 0 green yellow orange cannot red regularity 0 yellow orange red respectively one transitions occur unless 0 green case 0 regular since case easy verify regularity implies triple 0 satisfies appropriate semiregularity constraint triples since colors dont change possible violation regularity preferred path containing 0 may red analogous argument shows last element 0 removed form 00 00 still semiregular triple two removals degrade color one color left triple argument symmetric applies sibling 2 lemma 64 popping regular deque produces regular deque proof let deque popped let 0 deque formed removing first element first buffer let 0 left triple 0 lemma 63 0 semiregular violation regularity preferred path containing 0 may red preferred path green 0 regular pop finished lemma true suppose hand preferred path red let red triple path since 0 semiregular u red 1 must regular claim repair described cases 1 2 replaces u descendants tree triples green root satisfying semiregularity constraints implies deque 00 resulting repair regular thus giving lemma consider case 1 since 1 regular deque 0 1 formed 1 popping triple case 1a push onto 0 1 form 00 leaves 00 lemma 61 deque 2 semiregular since 1 regular lemma 62 deque 3 formed catenating 2 00 1 semiregular triple gives claim case 1b triple 1 semiregular giving claim consider case 2 argument case 1 verifies claim cases 2a 2b case 2c 0 green 2 semiregular gives claim case 2c 00 1 semiregular lemma 63 deque 5 semiregular appropriate applications lemmas 61 62 v green claim true 2 operations pop changes constant number levels top compressed forest hence performed constant time theorem 61 deque operations takes o1 time preserves regularity proof straightforward verify compressed forest representation allows deque operations performed described o1 time lemmas 61 62 64 give preservation regularity 2 deque representation presented hybrid two alternative structures described 25 one based pairs quadruples suggested okasaki 34 based triples quintuples present structure offers conceptual simplifications alternatives buffer size constraints representation reduced slightly cost making structure less symmetric example lower bounds suffix sizes right triples triples reduced one modifying definition colors appropriately 7 results open problems conclude section additional results open problems begin two extensions structures mention recent work finally give open problems set elements stored deque total order extend structures described support additional heap order based order specifically support additional operation finding minimum element deque deleting operation remains constanttime implementation remains purely functional merely store buffer deque pair minimum element contained related work see 3 4 19 31 also support flip operation deques structures sections 4 6 flip operation reverses linear order elements deque ith front becomes ith back viceversa noncatenable deques section 4 implement flip maintaining reversal bit flipped flip operation reversal bit set push becomes inject pop becomes eject inject becomes push eject becomes pop support catenation well flip requires little work need symmetrize structure add reversal bits levels nonsymmetry structure definition preferred children preferred child yellow triple left child preferred child orange triple right child flipping exchanges left right want operation change preferred children want partition compressed forest preferred paths unaffected flip thus create brandnew triple designate current left child preferred child yellow current right child preferred child orange triple changes orange yellow yellow orange switch preferred child irrespective current left right handle flipping add reversal bit every deque every buffer structure reversal bit set 1 means entire deque buffer flipped reversal bits cumulative along paths descendants compressed forest given deque buffer reversed odd number ancestors including reversal bits set 1 flip entire deque flip reversal bit whenever deque operation push reversal bits structure deque actually manipulated reversed reversed buffers push inject pop eject switch roles details straightforward turn recent related work work independent okasaki 33 35 devised confluently persistent implementation catenable stacks steques implementation realtime gives constant amortized time bounds per operation also purely functional uses memoization okasaki uses rooted trees represent stacks elements popped using memoized version path reversal technique previously used data structure disjoint set union problem 45 though okasakis solution neither realtime purely functional simpler extending okasakis method case deques open problem seeing early version work 27 okasaki 35 36 observed amortized time bounds suffice memoization allowed data structures considerably sim plified idea perform fixes lazy fashion using memoization record results avoids need maintain stack stacks structures representations also allows buffers shorter okasaki called resulting general method implicit recursive slow argues standard techniques amortized analysis 44 suffice case need deal persistence idea fact much general recursive slowdown however standard techniques 44 indeed suffice analysis working okasaki devised even simpler versions structures need constantsize buffers take o1 amortized time per deque operation using replacement operation generalizes memoization 26 finally mention open problems noted one extend okasakis path reversal technique deques second one modify structure section 6 use buffers bounded size know case stacks doubleended case unresolved technicalities course one solution plug structure section 4 inline structure section 6 simplify extent possible direct approach may well work lead simpler solution another open problem devise version structure section 6 uses one subdeque instead two thus leading linear recursive structure final open problem devise purely functional implementation finger search trees randomaccess lists constanttime catenation best solution problem olog log n catenation time 28 acknowledgements thank adam buchsbaum david wagner ian munro chris okasaki vital contributions paper adam buchsbaum engaged extensive fruitful discussions concerning ideas david wagner suggested idea color invariant alternative explicit use binary counting work allocation mechanism ian munro seeing presentation ideas pointed connection color invariant redundant binary representation 9 chris okasaki provided valuable comments drafts work also thank referees insightful valuable suggestions r anatomy lisp data structural bootstrapping confluently persistant deques via data structural bootstrapping efficient functional implementation fifo queues search history fractional cascading programming problemsolving seminar fully persistent arrays efficient uses past fully persistent lists catenation making data structures persistent theory practice firstclass prompts abstract continuations mathematical semantics handling full functional jumps optimal selection minheap deques heap order science programming efficient implementation veryhighlevel programming language constructs symmetric set efficient list operations stores partial continuations firstclass objects language environment purely functional lists simple confluently persistent catenable lists extended abstract persistent lists catenation via recursive slowdown purely functional representations catenable sorted lists fundamental algorithms optimal ram implementation catenable min doubleended queues new realtime simulations multihead tape units persistence lists catenation via lazy linking simple efficient purely functional queues deques purely functional data structures catenable doubleended queues searching past searching past persistent data structures planar point location using persistent search trees control delimiters hierarchies example hierarchical design proof amortized computational complexity worst case analysis set union algorithms tr worstcase analysis set union algorithms search history planar point location using persistent search trees searching sorting similar lists deques heap order abstract continuations mathematical semantics handling full jumps making data structures persistent stores partial continuations firstclass objects language environment theory practice firstclass prompts control delimiters hierarchies realtime deques multihead turing machines purely functional programming optimal algorithm selection minheap fully persistent lists catenation confluently persistent deques via datastructural bootstrapping datastructural bootstrapping linear path compression catenable heapordered doubleended queues persistent lists catenation via recursive slowdown purely functional representations catenable sorted lists catenable doubleended queues purely functional lists purely functional data structures worstcase efficient priority queues optimal ram implementation catenable min doubleended queues realtime simulation multihead tape units new realtime simulations multihead tape units example hierarchical design proof art computer programming volumes 13 boxed set science programming anatomy lisp simple confluently persistent catenable lists extended abstract fully persistent arrays extended array amortization lazy evaluation persistence realtime simulation concatenable doubleended queues doubleended queues preliminary version programming problemsolving seminar efficient implementation veryhighlevel programming language constructs persistent data structures ctr amos fiat haim kaplan making data structures confluently persistent proceedings twelfth annual acmsiam symposium discrete algorithms p537546 january 0709 2001 washington dc united states amos fiat haim kaplan making data structures confluently persistent journal algorithms v48 n1 p1658 august george lagogiannis yannis panagis spyros sioutas athanasios tsakalidis survey persistent data structures proceedings 9th wseas international conference computers p16 july 1416 2005 athens greece
characterizing performance algorithms lockfree objects abstractconcurrent access shared data objects must regulated concurrency control protocol ensure correctness many concurrency control protocols require process set lock data accesses recently considerable interest lockfree concurrency control algorithms lockfree algorithms offer potential better system performance slow failed processes block fast processes process slowdowns occur due cache line faults memory bus contention page faults context switching numa architectures heterogeneous architectures differences operation execution time much work done characterize performance locking algorithms little done characterize performance lockfree algorithms paper present performance model analyzing lockfree algorithms studies effects slowdowns performance find lockfree algorithms better locking algorithms slowdowns transient worse slowdowns permanent one implication result lockfree concurrent objects appropriate uma architectures numa architectures require special protocols b introduction processes tasks threads etc concurrent system often access shared objects coordinate activities whether performing user computation maintaining system resources regard shared object shared data structure set operations data structure paper dont allow nested calls inheritance processes access shared data objects must follow concurrency control protocol ensure correct executions concurrent access shared data often moderated locks data item protected lock process must acquire lock accessing data item type lock process requests depends nature shared data access different lock types different compatibilities different priorities example readonly access data item granted acquisition shared lock read write access requires exclusive lock shared locks compatible exclusive lock compatible lock locking protocols concurrent database access wellknown 10 addition locking protocols concurrent access wide variety specialized data structures proposed examples include binary search trees 33 37 avl trees 15 btrees 8 53 priority queues 12 46 30 shasha goodman 54 developed framework proving correctness lockbased concurrent search structure algorithms analytical tools needed study performance lockbased data structure algorithms established 27 28 47 general analytical model modeling performance lockbased concurrent data structure algorithms developed 29 28 performance locking protocols also well studied tay suri goodman 57 ryu thomasian 52 developed analytical models performance twophase locking variants database systems herlihy proposed general methods implementing nonblocking concurrent objects ie concurrent data structures 21 nonblocking object one processes accesses object guaranteed make progress computation within finite number steps nonblocking algorithm fault tolerant since failed process make object unavailable addition fast processes execute expense slow operations hopefully improves performance object typical nonblocking algorithm reads state object computes modifications attempts commit modification conflicting operation modified object commit successful operation finished otherwise operation tries operation typically uses compare andswap 65 9 43 atomic readmodifywrite instruction try commit modifications one work uses loadlockedstoreconditional instruction 22 several special architecture support lockfree algorithms developed 23 56 many additional nonblocking lockfree algorithms proposed essential form herlihy also proposed methods waitfree concurrent objects every operation guaranteed completion within bounded number steps address performance waitfree objects paper considerable research lockfree concurrent algorithms done lately 25 22 58 2 23 56 researchers work lockfree algorithms claim lockfree algorithms improve performance concurrent systems fast operations execute expense slow operations process slowdowns occur due cache line faults memory bus contention page faults context switching numa architectures heterogeneous architectures differences operation execution time work done measure performance lockfree algorithms 22 23 45 performance lockfree algorithms relative blocking algorithms received little study 45 work develop performance model lockfree algorithms model studies effects transient permanent slowdowns speed operation execution find lockfree algorithms better locking algorithms slowdowns transient worse slowdowns permanent extend explanatory model model accurately predicts utilization shared object algorithms herlihy 21 introduced idea nonblocking algorithm implementing concurrent data structures concurrent algorithm nonblocking guaranteed processor makes progress computation finite number steps process sets lock fails process make progress hence nonblocking algorithms must avoid conventional locks herlihy describes method transforming sequential implementation object concurrent nonblocking implementation object represented pointer current instantiation process performs operation object taking snapshot object computing new value object private shared workspace using sequential implementation committing update setting object pointer address newly computed object interference operation succeed commit interfering operation modified object commit fail since object updated changing object pointer process set object pointer address updated object object pointer value process read initial snapshot action performed atomically using compareandswap cns instruction cns instruction available ibm370 cedar bbn motorola 68000 family intel 80486 cns instruction equivalent atomic execution program code 1 object pointoldnew f ifpointoldf point new returnsuccess else returnfailure typical nonblocking algorithm form herlihys smallobject protocol shown code 2 paper abstracting away memory management problems result aba problem 26 object accesspointparameters object point f object old object new object old object snapshotpoint new object serial updateold objectparameters ifcnspointold objectnew break smallobject lockfree protocol one problem protocol code 2 entire object must copied wasting time memory herlihy also proposed large object protocol efficiently updates serial object largeobject protocol similar shadowpage technique used atomically update diskresident index often modified portions object must copied replaced largeobject protocol essential form smallobject protocol herlihys algorithms serialized access shared object researchers propose algorithms permit concurrent access nonblocking object stone 55 proposes queue permits concurrent enqueues dequeues enqueuer puts record empty queue block dequeuers categorize algorithm lockfree instead nonblocking stones algorithm performance characteristics nonblocking algorithm prakash lee johnson 44 45 give algorithm nonblocking queue permits concurrent enqueues dequeues solution based classifying every possible queue configuration one finite number states current state defined atomic snapshot value head pointer tail pointer nextrecord pointer tail record authors provide protocol taking atomic snapshot operation executes might find queue valid state case operation tries commit updates decisive instruction via compareandswap queue invalid state operation takes queue valid state starts execution plj queue shown program code 3 object accessobject instanceparameters object object instance f boolean done obj state object state donefalse whilenot done f object state snapshotobject instance ifobject state valid compute action object instance apply action object instance done true else cleanupobject instance cleanupobject instance code 3 plj concurrent lockfree protocol valois 59 developed similar nonblocking algorithms queues linked lists binary search trees herlihy moss 25 present nonblocking algorithms garbage collection anderson woll 3 present waitfree algorithms unionfind problem turek shasha prakash 58 techniques transforming concurrent objects implemented locks concurrent nonblocking objects every operation keeps program publicly available location instead setting lock record process attempts make lock field record point program attempt fails blocked process executes program process holds lock lock removed contention setting lock similar phenomena modeled work researchers investigated hybrid techniques primarily locking force processes release locks process experiences context switch 2 11 methods use nonlocking algorithms ensure correctness several architectures support lockfree algorithms proposed 56 23 cache coherence mechanism allows processor reserve several words shared memory informs processor conflict occurs 3 processor slowdowns since claimed advantage lockfree algorithms superior performance spite processor slowdowns must examine possible causes variations time execute operation first type processor slowdowns small slowdowns small slowdowns caused cache line faults contention memory module contention bus interconnection network 13 another source small slowdowns lies dependence execution time operation data data structure example priority queue might implemented sorted list enqueue slow list big fast list small lockfree algorithms take advantage small slowdowns giving temporarily fast operations priority temporarily slow operations example lock free algorithm would give preference dequeue operations priority queue large enqueue operations priority queue small permitting greater overall throughput second type processor slowdowns large slowdowns slowdowns caused page faults context switches multitasking parallel computers process holds critical lock experiences context switch processes compete lock delayed lock holding process regains control processor many researchers worked avoiding problems caused long slowdowns one approach delay context switch process process holds lock 5 38 64 authors report large improvement efficiency multitasking parallel processors avoiding large slowdowns however approach several drawbacks requires complex kernel requires complex userkernel interaction allows user grab control multiprocessor processes lock dummy semaphores alemany felton 2 bershad 11 proposed hybrid schemes primarily locking force processes release locks context switch using technique similar nonlocking protocols ensure correctness schemes avoid possibility user grabbing processors still require additional kernel complexity complex user interface contrast lockfree algorithms solve large slowdown problem without operating system support types slowdowns discussed literature transient slowdowns cause slowdown eventually resolved process executes operation fast processes system another type slowdown permanent slowdown process executing operation shared object always slower processes system access object permanent slowdown occur processor hence processes executing executes slower rate processors system multiprocessor might contain heterogeneous cpus perhaps due incremental upgrades multiprocessor architecture might nonuniform memory access numa architecture processors access memory module faster others typical numa architecture globally shared memory colocated processors addition topology multicomputer processors closer together others example hierarchical bus mesh topology numa architecture shared object accessed quickly processors close slowly processors far process might experience permanent slowdown executing operation operation different operations shared object might require different times compute example herlihy 22 observed enqueues priority queue experienced discrimination take longer compute earlier work 45 ran several simulation studies compare performance nonblocking queue lockbased implementation different conditions expected nonblocking queue would perform better equivalent lockbased queue execution times operations varied considerably simulation studies operations arrived poisson stream assigned processor execute operations program first set experiments assigned fast processor 90 time slow processor 10 time thus simulated permanent slowdowns surprised find locking queue substantially better performance nonblocking queue processors experience permanent slowdowns second set experiments operations assigned identical processors processors occasionally become slow thus simulated transient slowdowns transient slowdowns nonblocking algorithm substantially better performance locking algorithm key observation performance lockfree algorithms relative blocking algorithms depends nature slowdown processes experience lockfree algorithms work well transient slowdowns occur poorly permanent slowdowns occur models develop work explore phenomenon 4 previous work considerable work done analyze performance synchronization methods many analyses synchronization methods examined relative performance shared memory locks mellorcrummey scott 39 present performance measurements show good performance algorithm relative testandset ticketbased algorithms agrawal cherian 1 present simulation results simple analytical model explore performance adaptive backoff synchronization schemes anderson presents measurement results performance several spin locks suggests new ticketbased spin lock woest goodman 61 present simulation results compare queueonlockbit synchronization techniques testandset spin locks mellorcrummey scott lock graunke thakkar 18 present performance measurements testandset ticket based locks authors examined particular aspects synchronization performance lim agrawal 36 examine performance tradeoffs spinning blocking present analytical models derive best point blocked process switch spinning blocking glenn pryor conroy johnson 16 present analytical models show thrashing phenomenon occur due contention synchronization variable anderson lazowska levy 6 present simple queuing models critical section access study thread management schemes zahoran lazowska eager 64 present variety analytical simulation models study interaction synchronization scheduling policies multitasking parallel processor previous analytic studies multiprocessor synchronization address effects slowdowns performance shared objects work zahoran lazowska eager 64 uses simulation study effect scheduling policies furthermore spin lock algorithms essentially different nature lockfree algorithms many algorithms ie ticket locks mcs lock qolb locks competition occurs lock free afterwards blocked processes cooperate perform synchronization lock granted atomic step testandset locks hence analyses primarily queuing models counted number accesses required obtain lock lockfree algorithms different nature process attempting perform operation must complete operation another process performs conflicting operation hence synchronization competitive nonatomic two synchronization algorithms similar form lamports fast mutual exclusion algorithm 35 processes compete obtain lock using read write operations however algorithm used practice performance studied analytical simulation models testandtestandset lock 50 similar lockfree algorithms blocked processors receive signal lock free cache line invalidation compete lock effect slowdowns testandtestandset lock never analyzed though methods described paper applied however result likely great interest testandtestandset lock widely used discrimination due numa architecture likely great effect system performance considerable work done analyze performance concurrent data structure algorithms 29 28 techniques assume algorithm lockbased concentrate analyzing waiting times lock queues since queuing lockfree algorithms techniques apply researchers 22 observed nonblocking data structure algorithms similar optimistic concurrency control occ databases 10 optimistic concurrency control named makes optimistic assumption data conflicts rare transaction accesses data without regard possible conflicts data conflict occur transaction aborted restarted given relationship occ nonlocking algorithms try apply performance models developed analyze occ analyze nonlocking algorithms menasce nakanishi 40 present markov chain model occ aborted transactions leave reenter transaction processing system new transactions morris wong 41 42 note generating new transactions replace aborted ones biases transaction processing system towards executing short fast transactions authors provide alternative solution method avoids bias requiring transaction replaces aborted transaction identical aborted transaction ryu thomasian 51 extend model occ permit wide variety execution time distributions variety occ execution models yu et al 63 62 develop approximate models occ locking concurrency control evaluate performance transaction processing systems models approach ryu thomasian best suited application analyzing nonlocking algorithms previous models similar nature 40 41 42 general analyses 63 62 focus issues buffering resource contention assume data conflicts rare contrast ryu thomasian abstracts away operating environment focuses analyzing effects data conflicts furthermore ryu thomasian model produces accurate results rate data conflict high approach extend simple flexible model ryu thomasian 51 analyze lockfree algorithms ryuthomasian model requires transaction aborted execution time identical first execution however explicitly want account variations execution time work load model since lockfree algorithms intended fast spite temporarily permanently slow processors therefore start extending ryuthomasian performance model account two new workload models next apply performance models analyze several lockfree algorithms show closedsystem model ryu thomasian converted open system model validate analytical tools use explore relative performance algorithms 5 model description data access conflicts occ detected use timestamps data granule g smallest unit concurrency control associated timestamp tg contains last time data granule written transaction keeps track read set rt write set w assume rt oe w every time new data granule accessed time access recorded commit point data granule last write time greater access time transaction aborted otherwise transaction committed last write time granule w set current time procedure used shown code 4 readgt read g ts local workspace access timegglobal time g 2 rt access timegtg abortt g 2 w tgglobal time code 4 occ validation noted elsewhere 22 lockfree protocols types described code 2 3 essentially similar occ validation described code 4 types algorithms read data values commit interfering writes occurred although many implementation details different occ lock free algorithms detect conflicts different mechanisms abort makes operation reexecute loop analysis counts conflicts calculate probability committing applies equally well types algorithms operation executes nonblocking algorithm acts like transaction obeys occ develop analytical methods context transactions apply methods analyzing operations following ryu thomasian distinguish static dynamic concurrency control static concurrency control data items accessed read transaction starts dynamic concurrency control data items read needed also distinguish silent broadcast concurrency control pseudocode code 4 silent optimistic concurrency control operation doesnt advertise commit transactions abort continue execute alternatively transaction broadcast commit conflicting transactions restart immediately 48 20 model transaction processing system closed system v transactions execute one c transaction types new transaction enters system class c transaction probability f c class c transaction assumed execution time fiv b c x fiv increase execution time due resource contention factoring fiv example resource contention decomposition approximation 57 51 28 lets us focus concurrency control mechanism allows analysis applied different computer models assume analysis ie one processor per operation transaction executes transactions commit executions committing transaction conflicts must aborted denote phik c probability committing class transaction conflicts executing class c transaction model stochastic process committing transactions conflict executing transaction poisson process ryu thomasian 51 show assumption makes analysis tractable leads accurate model predictions wide variety conditions differentiate three models depending actions occur transaction aborts 51 transaction samples execution time first enters system transaction aborted executed execution time first execution time call transaction model fixed timefixed class model ff model 1 ff model avoids bias fast transactions permitting fair comparison lockbased concurrency control analyzing transaction processing systems variability execution time operation could due resource contention decisions operation makes executes combination cases execution time operation changes operation reexecuted abort however processors might slower others operations might take longer compute others introduce variable timefixed class vf model represent situation processors experience transient permanent slowdowns vf model aborted transaction chooses new execution time next execution however new operation still class ie processor type operation might want model situation processors experience temporary slowdowns ie uma processor operations require amount computation fast next execution variable timevariable class vv model new transaction type picked replace aborted transaction possibly transaction type 51 model solution methods given transaction model solve system occ models way method solving system depends transaction model ff vf models use method vv model solved using different method 511 solving ff vf models solution method ff vf models involves taking system utilization u portion time spent useful work finding perclass utilizations u c system utilization u computed perclass utilizations ryu thomasian show equations solved quickly iteration mean useful residence time class c transaction denoted r c v transaction might required restart several times due data conflicts expected time transaction spends executing aborted attempts denoted r c v total residence time class c transaction 1 results present ff model taken 51 v utilization class proportion expected residence time spent execution commits u v expected residence time transaction r v r v rv calculated taking expectation perclass expected residence times system efficiency u calculated taking expectation perclass utilizations f c r c 1 order calculate perclass efficiencies need calculate probability transaction aborts due data conflict define phik c probability class k transaction conflicts class c transaction know proportions committing transactions calculate probability committing transaction conflicts class c transaction phi c calculate rate committing transactions conflict class c transaction fl c setting fl c proportion committing transactions conflict class c transaction b expected execution time transactions given system utilization calculate perclass conflict rate perclass conflict rate calculate perclass utilizations perclass utilizations calculate system utilization output system utilization decreasing function input system utilization ff model utilization bounded 1 unique root 01 found using binary search iteration vf model possible utilization greater 1 bias towards fast executions root finder must use one standard nonlinear equation solution methods 7 512 solving vv model vv transaction model transaction aborts leaves system new transaction enters result proportion committing class c transactions longer f c instead depends probability class c transaction commits p c average execution time class c transaction solution method vv model based iteratively finding root vector p order calculate conflict rate need know proportion transactions k executing class k transaction process executing class k transaction executes expected b k seconds one observe large number transaction executions say class k transaction would executed mf k times thus observation period would take seconds class k transaction would executed mf k b k seconds theory alternating renewal processes 49 process executing class k transaction finish rate 1b k transaction completes commit rate p k commits conflict class c transaction probability phik c therefore given probability transactions transaction class commits c calculate conflict rate fl c transaction class given conflict rate transaction class fl c calculate probability transaction commit p c unlike case ff vf models vv model need iterate vector make use property system equations find rapidly converging iterative solution f transformation f p old new f p vector relation refers componentwise comparison words jacobian f strictly nonpositive algorithm use find solution vv calculates th value p c 6 analysis section present calculations needed solve systems discussed previous section four types optimistic concurrency control present calculation three transaction models 61 analysis silentstatic occ section examine simplest occ scheme silentstatic scheme transactions access entire data sets start executions detect conflicts attempt commit 611 fixed timefixed class 51 transaction executes seconds aborts execute seconds restarts operation requires seconds probability commit e gammafl since assume conflicts form poisson process therefore number times class c transaction running time must execute distribution mean e fl c class c transaction running time therefore mean residence time te class c transactions running time r 1te c first derivative laplace transform b c 32 finally perclass utilization calculated iteration note b c must ot gamma1 e gammafl c integral converge 612 variable time fixed class variable timefixed class model every time class c transaction executes running time sampled b c therefore unconditional probability operation commits number times operation executes geometric distribution operation execute 1p c times first 1p c gamma 1 times operation executes unsuccessful knowing operation unsuccessful tells us probably required somewhat longer average execute since slow operations likely aborted similarly successful operations likely faster particular operation successful reaches commit point conflict occurs unsuccessful conflict occurs reaches commit point distributions execution times successful unsuccessful operations calculated taking order statistics 14 k k f normalizing constants computed z 1e gammafl c b c tdt c b f c expected values b c b f c respectively expected time complete class c operation c 12 observe need calculate b c combining 11 13 get therefore find c b c note variable time model restriction distributions b c finite means 613 variable time variable class silentstatic vv model calculate conflict rate formula 4 probability class c transaction commits formula 8 62 analysis staticbroadcast occ staticbroadcast occ transactions access entire data sets start execution abort whenever conflicting transaction commits 621 fixedfixed probability transaction restarts calculated way silentstatic model given conflict rate wasted time per transaction truncated exponential distribution result 622 variablefixed probability transaction commits p c expected execution time transactions commit c calculated way silentstatic model execution time aborted transactions different since transaction abort transaction conflicts seconds starts yet committed c theta fl c e gammafl c r 1fl c e gammafl c 1gammab c tdt r 1e gammafl c r tb c ddt since conflict aborts transaction early make use equation 13 simplify equation 11 instead must actually calculate expected values b c b f c ds b c ss putting formulae equation 11 r c v find note b c exponential distribution u relation used directly solve system execution times exponentially distributed simplify calculations execution time distributions exponentially distributed 623 variablevariable silentstatic case class k transaction executes expected b k seconds broadcaststatic case transaction terminates early aborted average amount time transaction spends executing class k transaction b k weighted average execution time depending whether transaction commits using equations 17 18 find therefore proportion time process spends executing class k transaction conflict rate class c transaction given conflict rate fl c calculate p c using equation 8 63 analysis silentdynamic dynamic optimistic concurrency control transaction accesses data items needed class c transaction requests n c data items n c phases transaction accesses data items acquires higher conflict rate redefine conflict function phi model different phases transactions class k transaction commits conflicts class c transaction stage probability phik c probability committing transaction conflicts class c transaction stage conflict rate class c transaction stage amount time class c transaction spends stage distribution b ci mean ci average time execute transaction b 631 fixedfixed transaction moves different stages encounters different conflict rates conflict rate class c transaction vector similarly execution time class c transaction vector distribution density b ci x probability class c transaction aborts therefore taking expectations times processing stages ryu thomasian find c gammafl ci 632 variablefixed use transaction model fixedfixed case transaction commit completes every stage without conflict define p ci probability class c transaction completes th stage without conflict calculate p ci using formula 8 substituting b ci b fl ci given p ci calculate p c case silentstatic concurrency control unconditional expected time spent executing class c transaction b c variablevariable vv model use formula 4 appropriately modified calculate conflict rates formula 26 calculate p c 64 dynamicbroadcast 641 fixedfixed analysis dynamicbroadcast concurrency control fixedfixed model uses combination previously discussed techniques ryu thomasian show r c d2 r c c 0 theta r c 642 variablefixed use formula 26 calculate p c processing phase use formulae 17 18 calculate b ci b f ci transaction commits successfully completed phase ci 28 transaction fails commit might failed one stages define c probability transaction aborts q ci probability transaction aborts stage given aborts transaction aborts stage must successfully completed previous stages transaction aborts exactly one stages transaction aborts stage expected execution time cj therefore b f c unconditional expected execution time cia use formulae 28 29 formula 11 find r c v variablevariable use formula 26 calculate p c formulae 28 29 formulae 21 23 calculate conflict rate 7 model validation experiments wrote occ simulator validate analytical models parameterized number transactions executed concurrently committing transactions conflicted transactions depending sample phi ran simulation 10000 transaction executions reported statistics throughput execution time commit probabilities ryu thomasian already validated ff model present validation vf vv models also simulated ff model found close agreement simulation analysis first validation study modeled system single transaction type one transaction type vf vv models present results vf model also ran simulations analytical calculations vv model obtained nearly identical results calculated phi assuming transactions randomly accessed data items database contained data items transactions overlapping data sets conflict ryu thomasian provide following formula probability two access sets size n overlap database n data items report probability transaction commits variety access set sizes degrees concurrency table 1 execution times static concurrency control experiments phase execution times dynamic concurrency control experiments exponentially distributed experiments show close agreement analytical simulation results though calculations least accurate dynamic concurrency control level conflict high also performed validation study system two transaction classes first transaction class accesses four data items second accesses eight data items save space reports results dynamicbroadcast occ least accurate models table 2 reports simulation analytical results vf vv transaction models variety degrees concurrency experiments f close agreement simulation analytical predictions staticsilent staticbroadcast access set size 4 ana 9444 6366 4586 9414 5272 2797 ana ana 7755 3481 2241 7281 1567 0608 dynamicsilent dynamicbroadcast ana 9704 7189 4879 9700 6967 4325 ana ana 8554 3703 1910 8479 3078 1319 table 1 validation study vf model p c reported single transaction class exponentially distributed execution times varyingfixed varyingvarying analytical simulation analytical simulation class 1 class 2 class 1 class 2 class 1 class 2 class 1 class 2 table 2 validation study dynamicbroadcast occ two transaction classes p c reported execution phase times exponentially distributed 8 analysis nonblocking data structures section apply analytical framework model performance nonblocking data structures explore several performance implications analytical framework used model nonblocking data structure algorithms basic form described section 2 codes 2 3 nonblocking algorithms use different mechanism 24 17 34 recently proposed methods 45 58 19 55 59 60 56 23 similar techniques 81 atomic snapshot examine first algorithms similar code 2 taking snapshot consists performing one read ie reading pointer object approach used herlihy 21 step tureks algorithms 58 approximation algorithms proposed prakash et al 45 valois 59 60 harathi johnson 19 want model transient permanent slowdowns vf model accounts transient permanent slowdowns vv model permits transient slowdowns modeling algorithms snapshot performed atomically operations execute ss transactions herlihys algorithms every operation conflicts every experiments use two transaction classes model fast slow processors first transaction class models fast processors execution time chosen uniformly randomly 8 12 f 9 execution time second transaction class represents slow processors chosen uniformly randomly 8 12 plot throughput nonblocking queue permanent transient slowdown models vf vv increasing v figure 1 comparison also plot throughput locking algorithm algorithm constant 119 nonblocking queue permanent slowdown model lower throughput locking queue spite preference shown towards fast executions phenomena occurs extremely long times required completion operations executed slow processors running times shown figure 2 throughput transient slowdown model increases increasing v considerably greater locking queue model predictions agreement simulation results 45 ryu thomasian models assume closed system calculate throughput response time function number competing operations access shared data structure better modeled open system operations arrive receive service depart use results closedsystem model approximate performance measures open system throughput values closed system used statedependent service rates flowequivalent server 31 steps compute open system response times ff vf transaction models 1 calculate perclass average response times 2 model number jobs system finitebuffer queue use average response times across transaction types statedependent service times given arrival rate calculate state occupancy probabilities 3 use state occupancy probabilities weight perclass response times compute average response time taking sum vv model perclass execution times arent meaningful instead one calculates average transaction execution time expected probability vv transaction commits transaction reexecutes commits thus number executions geometric distribution expected value 1p vv c therefore expected time execute transaction c using parameters previous experiment plot response time singlesnapshot algorithm permanent transient slowdown processor models increasing arrival rate figure 3 also report results simulation processor models chart shows vv analytical model accurately predicts response times transient slowdown model vf model overly optimistic figure 4 compares analytical simulation predictions probability system idle processor models see vv model makes accurate predictions vf model optimistic include figure 3 plot response time equivalent locking algorithm modeled mg1 queue 32 locking algorithm considerably better response time nonblocking algorithm permanent slowdown model nonblocking algorithm transient slowdown model similar response time light load lower response time heavy load observing simulations noticed response time operations alone system complete close response times two operations system occurs jobs complete alone system often slow jobs forced restart several times therefore make approximation call vf approx flowequivalent setting service rate one operation system two jobs system predictions made approximation vf model labeled vf approx figures 3 4 vf approx makes poor predictions response times accurate predictions system utilization test robustness models face different service time distributions ran experiments permanent slowdown processor model service time distributions exponential distribution results experiments shown figures 5 6 figures also show vf model optimistic vf approx model makes poor predictions response times good predictions system utilization 82 composite snapshot several nonblocking algorithms take snapshot several variables determine state data structure 45 59 60 19 22 taking atomic composite snapshot requires complex algorithm reduces amount copying needed perform operation improves performance addition architectures support lockfree algorithms proposed 23 56 architectures allow process reserve several words shared memory inform processor conflicting write occurs code 5 taken 45 shows typical protocol take atomic snapshot algorithm implements nonblocking queue nonblocking queue needs determine simultaneous values three variables order determine state queue call three variables b c protocol reads simultaneous values b c repeat aa repeat bb cc code 5 composite snapshot time operation taking snapshot modification data structure cause snapshot fail snapshot taken different modifications cause snapshot fail thus snapshot progress operation uses db optimistic concurrency control snapshot successfully taken operation calculates update attempts commit update operation abort time calculates update stage operation uses ss optimistic concurrency control since optimistic concurrency control used compositesnapshot nonblocking algorithms variation db concurrency control use methods similar discussed section 64 calculate execution times probability success last stage calculation terminate early conflicting commits therefore value b f cn c 1 29 calculated using method described section 612 b fss assume operation equally likely enqueue dequeue operation queue usually full case enqueue operation commits kills enqueue operations applies dequeue operations therefore one operation kills another upon commit probability 12 start counting operations execution point executes statement aa first stage ends first statement executed requires 4 instructions second stage ends second statement executed requires 1 instruction third stage ends operation tries commit operation requires 8 instructions fast processors require time uniformly randomly chosen 8 12 execute instructions stage slow processors require time uniformly randomly chosen 8 12 time execute stage number instructions stage multiplied sample uniformly randomly selected lo hi results experiments shown figures 7 8 figures show response times idle probability respectively draw conclusions vv model makes accurate predictions vf model optimistic vf approx model makes poor predictions response times good predictions idle probability 9 conclusion work present model analyzing performance large class nonlocking algorithms model extension ryu thomasian model optimistic concurrency control extensions allow operations resample execution time abort vf transaction model also change change operation class vv transaction model validate models closed system variety concurrency control models next apply analytical tools compare performance nonlocking locking algorithms shared objects use two processor models permanent slowdown model execution speed processor fixed modulo small variations transient slowdown model execution speed processor changes executions use vf transaction model permanent slowdown processor model vv transaction model transient slowdown processor model permanent slowdowns occur due numa architectures heterogeneous architectures differences operation execution time transient slowdowns occur due cache line faults memory bus contention page faults context switching datadependent operation execution times compared performance nonlocking locking algorithms closed system found nonlocking algorithms variable speed model significantly better throughput locking algorithm nonlocking algorithms permanent slowdown model significantly worse throughput closed system model give direct performance results real system indicates relative performance algorithms provides bound rate operations execute extend closed system model open system using flowequivalent approximation analytical results approximation show performance ranking respect response times exists closed system vv model slightly pessimistic vf model optimistic making us confident performance ranking describe approximation lets us accurately calculate utilization concurrent object vf model analytical models accurate enough useful predicting impact nonlocking concurrent object system performance work indicates nonlocking algorithms potential provide better performance locking algorithms processors executing operations experience transient slowdowns thus lockfree algorithms appropriate uma architectures operations data require processing time however work shows lockfree algorithms poor performance processors experience permanent slowdowns slow processors receive significant discrimination reducing overall throughput thus lockfree algorithms appropriate heterogeneous numa architectures types operations require significantly computation others cases nonblocking algorithms must incorporate fairness mechanism provide good performance approachs mechanisms described 2 11 r adaptive backoff synchronization techniques performance issues nonblocking synchronization shared memory multiprocessors performance spin lock alternatives shared memory multiprocessors scheduler activations effective kernel support userlevel management parallelism performance implications thread management alternatives shared memory multiprocessors introduction numerical analysis concurrency operations btrees concurrency control recovery database systems practical considerations nonblocking concurrent objects simultaneous update priority structures models access delays multiprocessor memories order statistics concurrent search insertion avl trees bistability throughput phenomenon sharedmemory mimd machine coordinating large numbers processors synchronization mechanisms sharedmemory multiprocessors priority synchronization algorithm multiprocessors observations optimistic concurrency control schemes methodology implementing highly concurrent data structures methodology implementing highly concurrent data objects transactional memory architectural support lockfree data structures axioms concurrent objects watson research center approximate analysis reader writer access shared resource performance concurrent data structure algorithms performance concurrent data structure algorithms concurrent operations priority queues introduction computer system performance evaluation queueing systems concurrent manipulation binary search trees specifying concurrent program modules fast mutual exclusion algorithm waiting algorithms synchronization largescale multiprocessors concurrency control dynamic search structure dynamic processor allocation policy multiprogrammed sharedmemory multiprocessors algorithms scalable synchronization sharedmemory multiprocessors optimistic vs pessimistic concurrency control mechanisms database management systems performance concurrency control algorithms nonexclusive access performance analysis locking optimistic concurrency control algorithms concurrent access priority queues performance analysis concurrentread exclusivewrite experiments transaction processing multiprocessor stochastic processes dynamic decentralized cache schemes mimd parallel processors performance analysis centralized database optimistic concurrency control analysis database performance dynamic locking concurrent operations b concurrent search structure algorithms simple correct sharedqueue algorithm using compareandswap multiple reservations oklahoma update locking performance centralized databases locking without blocking making lock based concurrent data structure algorithms nonblocking analysis lockfree queue concurrent dictionaries without locks analysis synchronization mechanisms sharedmemory mul tiprocessors modeling database concurrency control modeling analysis timestamp history based certification protocol concurrency control effect scheduling discipline spin overhead shared memory parallel systems tr ctr salvatore march charles wood gove n allen research frontiers object technology information systems frontiers v1 n1 p5174 july 1999
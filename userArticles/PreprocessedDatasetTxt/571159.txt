towards primitive higher order calculus broadcasting systems ethernetstyle broadcast pervasive style computer communicationin stylethe medium single nameless channelprevious work modelling systems proposed rst order process calculus called cbsin paper propose fundamentally different calculus called hobscompared cbs hobs 1 higher order rather first order 2 supports dynamic subsystem encapsulation rather staticand require underlying language turingcomplete moving higher order calculus key increasing expressivity primitive calculus alleviating need underlying language move however raises need significantly machinery establish basic properties new calculusthis paper develops basic theory hobs presents two example programs illustrate programming language key technical underpinning adaptation howes method hobs prove bisimulation congruence result hobs shown embed lazy calculus b introduction ethernetstyle broadcast pervasive style computer communication bare medium provided ethernet single nameless channel typically sophisticated programming idioms pointtopoint communication named channels built top ethernet using ethernet allow programmer make better use bandwidth exploit broadcast powerful natural programming primitive paper proposes primitive higher order calculus broadcasting systems hobs models many important features bare ethernet develops basic operational properties 11 basic characteristics ethernet basic abstractions hobs inspired ethernet protocol medium single nameless channel node broadcast message instantaneously delivered nodes messages need specify either transmitter receiver transmitter message decides transmitted receiver consume whatever net time one message transmitted time collision detection resolution provided protocol hobs operational semantics abstract view two nodes trying transmit simultaneously one chosen arbitrarily nodes treated equally position net matter hobs renes extends previously proposed system called calculus broadcasting systems cbs 16 although hobs cbs models ethernet two systems take fundamentally dierent approaches subsystem encapsulation illustrate dierences take closer look ethernet addresses issues 12 modelling ethernetstyle encapsulation whenever basic mode communication broadcast encapsulating subsystems absolute necessity ethernet bridges used regulate communication ethernet subsystems bridge stop translate messages crossing local transmission either side unaected bridge either side bridge seen subsystem cbs models bridges pairs functions lter translate messages going direction across bridge intuitively appealing model suitable many applications limitations 1 cbs relies completely separate underlying lan guage particular cbs rst order process cal culus meaning messages distinct pro cesses separate computationally rich language needed express function pairs 2 cbs provides static model ethernet architec tures example real bridges change routing behaviour cbs provides neither change mobile systems might cross bridges 3 broadcast cross bridge cbs instantly unrealistic real bridges usually buer messages hobs addresses limitations supporting rstclass transmittable processes providing novel encapsulation primitives combined features hobs yield turingcomplete language sucient expressing translators limitation 1 allow us model dynamic architectures lim itation 2 new encapsulation primitives allow us model buering messages cannot consumed immediately limitation 3 13 problem working higher order calculus comes cost developing theory hobs particular whereas denition behavioural equivalence rst order language require exact match transmitted mes sages denition discriminating messages involve processes nonrst order values thus behavioural equivalence must require transmission equivalent messages unfortunately syntactically small change notion equivalence introduces signicant complexity proofs basic properties calculus particu lar standard technique proving bisimulation congruence 11 go key diculty seems standard technique cannot used directly show substitution equivalent processes variables preserves equivalence problem detailed section 41 14 contributions organisation main contributions paper design hobs formal verication properties presenting syntax semantics hobs sec tion 2 give formal denition applicative equivalence hobs section 3 key step technical development use howes method 10 establish applicative equivalence hobs congruence section 4 typical treatment concurrent calculi also introduce notion weak equivalence essentially development used develop notion equivalence section 5 application results section 6 use show hobs embeds lazy calculus 1 turn allows us dene various basic datatypes encoding relies fact hobs higher order possible encodings cbs calculus 12 discussed brie details found extended version paper 14 two examples one dealing associative broadcast 2 dealing database consistency 2 presented section 7 results lay groundwork applied theoretical investigation hobs future work includes developing implementations compile ethernet internet protocols comparing expressive power different primitive calculi concurrency conclude paper discussing related calculi future works sec tion 8 remarks knowledge assumed cbs process calculus formal development paper selfcontained readers familiar ccs 11 chocs 18 cbs roughly hobs cbs chocs ccs extended version paper available online 14 gives details denitions proofs additional results 2 syntax semantics hobs eleven process constructs formally dened next subsection informal meaning follows 0 process says nothing ignores everything hears x variable name scoping variables substitution essentially calculus receives message q becomes p1 qx p1 p2 say p1 become p2 ignores everything hears becomes p3 except hears something say q whereupon becomes p1 qx p1 jp2 parallel composition p1 p2 interact environment p1 jp2 interacts one process countable set names groundterms guarded choice composition buers f 2 f p p feed buer messages actions 2 contexts syntax indexed set freevariables l figure 1 syntax inlter construct behaves p1 except incoming messages ltered p2 inlter asymmetric p2 hears environment p1 speaks nameless private channel connects p2 p1 construct represents lter waiting incoming message process p1 progress independently represents inlter busy state process p1 suspended p2 processes input message later p2 sends processed message p1 p1 resumed outlter construct behaves p2 except outgoing messages p2 ltered p1 outlter also asymmetric p2 hears environment p1 speaks nameless private channel connects p2 p1 ltering construct represents outlter passive state waiting p2 produce output message process p2 progress independently represents outlter busy state process p3 suspended p1 processes output message processing p1 sends message envi ronment p3 resumed case process p1 fails process message environment sends message outlter rollback previous state represented process p2 feed construct consists p1 fed p2 later consumption incoming mes sage cannot speak environment p1 consumed p2 thus hobs built around syntax semantics cbs 16 without need underlying language instead required expressivity achieved adding ability communicate processes higherorderness well feed ltering constructs 21 formal syntax semantics hobs syntax hobs presented figure 1 terms treated equivalence classes convertible terms set pl set process terms free variables set l example p set closed terms remark 1 notation names ranging syntactic category given figure 1 thus process terms always p q r natural number subscripts indicate subterms p1 subterm p primes mark result transition transitions p q figure 2 denes semantics terms transition relation p p freevariables substitution context lling dened usual see 14 details semantics given labeled transitions labels form p p p process former broadcast speech transmission latter hearing reception transmission consistently interpreted autonomous action reception controlled environment processes always ready hear anything transmission absorbs reception parallel composition encapsulation ltering receive transmit silence nil input xp1 q output p1 p2 q choice compose outfilter internal figure 2 semantics stop reception hide transmission discussion see 16 lter constructs required careful design one diculty lters able hide messages tech nically means lters able produce silent messages result silence message process construct therefore lter produces mes senger process result messenger process sends actual result ltration discarded way messenger process produce message process silent transition relation fails function rst two arguments composition rule allows arbitrary exchange messages subprocesses choice construct introduce nondeterminism since broadcast collision resolved allowing left subprocess parallel composition broadcast however calculus deterministic input input enabled easily shown induction derivation p discussion design decisions refer reader extended version paper 14 3 applicative bisimulation surprises notions simulation bisimulation hobs development uses techniques channelbased calculi 11 transition relation carries processes labels notions higher order simulation bisimulation account structure processes use following notion message extension convenience relation process terms message extension r dened following rules tauext msgext thomsens notion applicative higher order simulation 18 suitable strong simulation hobs take nongrounded higher order nature messages account applicative simulation relation r p p closed process terms strong higher applicative simulation written sr 1 2 use standard notion bisimulation definition 3 applicative bisimulation relation r p p closed process terms applicative bisimulation written br sr sr 1 hold using standard techniques show identity relation closed processes simulation bisimula tion property simulation bisimulation spectively preserved relational composition union also bisimulation property preserved converse two closed processes p q equivalent written p q exist bisimulation relation r p q 2 r words applicative equivalence union bisimulation relations definition 4 applicative equivalence applicative equivalence relation p p dened union bisimulation relations rpp proposition 1 1 b bisimulation 2 equivalence exive symmetric transitive calculus enjoys following basic properties proposition 2 let input 1 x0 0 parallel composition 1 pj0 p 2 p1 jp2 p2 jp1 3 p1 jp2 jp3 p1 jp2jp3 filters 1 2 p1 p2 3 xp 0 0 4 hxp1 choice 1 2 hxp1p2 p3 ijxp4 hxp1 jp4 p2 p3 jp4 p2 xi 4 equivalence congruence section use howes method 10 show applicative equivalence relation congruence motivate need howes proof method start showing diculties standard proof technique 11 present adaptation howes basic development hobs conclude section applying adaptation applicative equivalence equivalence congruence two equivalent terms distinguishable context equivalence relation process terms r congruence comp nil p1 r q1 p2 r q2 r q1 q2 comp p1 r q1 p2 r q2 comp infilter rx comp var p1 r q1 p2 r q2 r q1 jq2 comp comp p1 r q1 p2 r q2 r q1 q2 comp infilterb comp p1 r q1 p2 r q2 r q1 q2 comp feed p1 r q1 p2 r q2 comp outfilter comp choice p1 r q1 p2 r q2 p3 r q3 comp outfilteri figure 3 compatible renement 41 difficulty standard proof method notion compatible renement b r allows us concisely express case analysis outermost syntactic constructor definition 6 compatible refinement let r p p relation process terms compatible rene ment b r dened rules figure 3 standard congruence proof method show induction syntax equivalence contains compatible renement b standard method proving congruence centers around proving following lemma lemma 1 let r p p equivalence relation process terms r congruence b r r standard proof show b proceeds case analysis several cases simple nil 0 variable output x case feed slightly complicated cases problematic especially composition j since require substitutivity equivalence substitutivity dened usual way definition 7 substitutivity let r p p relation process terms r called substitutive following rule holds p1 p2x r q1 q2 x rel subst hobs standard inductive proof substitutivity equivalence requires equivalence congruence stuck attempt prove substitutivity simultaneously work either since terms size increase makes use induction syntax impossible similar problems seem common higher order calculi see example 18 7 1 42 howes basic development howe 10 proposed general method proving certain equivalences based bisimulation congruences following similar adaptations howes method 9 7 present adaptation hobs along necessary technical lemmas use standard denition restriction r relation r closed processes cf 14 extension relation open terms also standard one definition 8 open extension let r p p relation process terms open extension dened following rule 8 key part howes method denition candidate relation r definition 9 candidate relation let r p p relation process terms candidate relation dened least relation satises rule cand denition candidate relation r facilitates simultaneous inductive proof syntax reductions note denition compatible renement b r involves case analysis syntax inlining compatible renement b r denition candidate relation would reveal inductive use candidate relation r relevant properties candidate relation r summed lemma 2 let r p p preorder exive transitive relation closed process terms following rules valid cand ref p r q cand sim r q cand cong p r r r r q cand right p1 p2x r q1 q2 x cand subst corollary 1 r r immediate consequence rule cand subst rule cand ref eq c r c r l n figure 4 transmit lemma lemma 3 let r p p equivalence relation r symmetric next lemma says two candidaterelated processes closed terms derivation involves closed terms last derivation step lemma 4 closed middle r r r q 43 congruence equivalence relation goal twofold rst show candidate relation coincides open extension second use fact complete congruence proof first x underlying relation r already know lemma 2 rule cand sim show converse begin proving closed restriction candidate relation simulation requires showing two simulation conditions definition hold split proof two lemmas lemma 5 receive lemma 6 transmit prove respective condi tions similarly standard proof parallel composition case dicult actually requires stronger receive condition hold rst lemma receive proves restriction rst condition second lemma transmit proves second condition makes use receive lemma lemma 5 receive let p q 2 p two closed processes p q 8m n proof relatively straightforward proof induction height inference transition interesting case case rule xp1 q p1 qx makes use substitutivity candidate relation lemma 6 transmit let p q 2 p two closed processes p q 8m n 3 proof first note lemma 4 closed middle also denition equivalence fact r q closed processes know remains prove 8m joining statements 5 4 using lemma 2 rule cand right infer p 0 q 0 n gives us result figure 4 shows idea pictorially normal lines respectively dotted lines universally respectively existentially quantied prove statement 5 proceed induction height inference transition describe interesting case parallel composition compose two parallel composition rules since rules symmetric show proof one know p p1 jp2 four related subprocesses p1 r1 p2 r2 suppose process p made following 0since candidate relation contains compatible renement enough show subprocess r mimic corresponding subprocess p r1 using induction hypothesis get r1 l r 0and p 0 r 0 l r2 would use simulation condition would get 0 would allow us show r corresponding transition since inference transition requires labels point use stronger receive condition lemma 5 get precisely need case similar simpler since require use lemma 5 receive two lemmas established restriction candidate relation simulation also using lemma 3 get symmetric means bisimulation conclude section ready state prove main proposition proposition 3 congruence proof first show rule cand sim know two lemmas lemma 3 know bisimulation implies since open extension monotone corollary 1 get equivalence equal candidate relation contains compatible renement c lemma 2 rule cand cong lemma 1 implies congruence 5 weak bisimulation many purposes strong applicative equivalence ne sensitive number silent transitions performed process terms silent transitions represent local computation many cases desirable analyse communication behaviour process terms ignoring intermediate local computations example strong applicative equivalence distinguishes following two terms communication behaviour equipped weak transition relation tion 10 dene weak simulation weak bisimulation standard way11 weak equivalence also dened standard way union weak bisimulation relations strong equivalence prove weak bisimulation equivalence proposition 4 moreover technique used proving strong equivalence congruence works also equivalence proposition 5 exive transitive closure weak transition dened proposition 4 1 weak bisimulation 2 equivalence proposition 5 congruence proof proof follows proposition 3 interesting dierence induction hypothesis used example case parallel composition using induction hypothesis get appropriate subterms perform weak transition interleave transitions possibly performing action interleaving possible since every process receive without change process see rule silence figure 2 expressions embedding figure 5 syntax semantics embedding lazy calculus 6 embeddings encodings driving criterion design hobs simplicity resemblance ethernet long term technical goal use simple uniform calculus interpret sophisticated proposals broadcasting calculi bcalculus 5 hobs interpretations handshake calculi calculus calculus groups 3 ccs could also provide means studying expressive power calculi section present embedding lazy calculus consequences brie discuss possible encodings cbs calculus 61 embedding calculus syntax semantics lazy calculus along direct translation hobs presented figure 5 function e e smallstep semantics language using weak equivalence prove analog equivalence hobs holds simple proof proposition using weak bisimulation technique found extended version paper 14 proposition 6 proposition 7 soundness let standard calculus notion observation equivalence able embed calculus justies explicit construct hobs either recursion datatypes calculus recursive combinator hobs express recursion derived construct rec dened left recursive construct expected behaviour stated right rec xp wxp wxp rec xp prec xpx point view calculus signicant embedding possible particular broadcasting viewed impurity technically computational eect 13 yet presence eect invalidate rule view positive indicator design hobs 62 encodings concurrent calculi cbs precursor development hobs natural ask whether hobs interpret cbs first cbs assumes underlying language data types hobs provides form embedded lazy calculus using standard church data encodings second cbs translator construct present hobs interpret use special parametrised queue con struct queue construct together parameter translating function used oneway translator linking two process via lter constructs gives cbsstyle translator decoupled translation using church numerals encode channel names easily interpret calculus without new operator devising sound encoding full calculus challenging since several technical diculties example explicit conversion solved discussion proposed solutions see extended version paper 14 soundness proof encodings ongoing work 7 examples hobs equiped relatively highlevel abstractions broadcasting communication hobs includes lazy calculus extend full functional language gives us tool experimenting broadcasting algorithms theory develops hope hobs also tool formal reasoning algorithms section present implementation coordination formalism called associative broadcast 2 together implementation database consistency algorithm expressed formalism compared previous implementations algorithm see example 6 hobs implementation generic retains full expressive power associative broadcast allows straightforward representation associative broadcast algorithms hobs interpreter implemented ocaml addi tion also use ocamllike syntax hobs functional terms datatypes use juxtaposition instead feed construct symbol purposes paper reader treat typing information simply comments 71 associative broadcast bayerdorer 2 describes coordination formalism called associative broadcast formalism uses broadcasting communication primitive formalism object participates communication prole prole seen set attributevalue pairs special subset pairs contains values functions modify prole subset divided functions used broadcasting used locally since associative broadcast coordination formalism objects locally connected external system invoke operations system conversely external system invoke local functions object communication objects proceeds follows broadcast message contains specication set cipients operation recipients execute specication rstorder formula examines prole operation call one functions modify prole message broadcasted object received objects including sender object evaluates formula prole determine whether execute operation operation executed prole satised formula generic part associative broadcast represented called rts run time system takes care communication protocol following basic denitions needed implementation rts hobs type operation message selector operation internal operation type tag let rec xmatch x outp p0p1 inp 0 0p1 xmatch x outp 0 0p3 inp p0p3 outp inpm inp let rec obj profile xmatch x messageselop sel profile op profile obj else obj profile internalop op profile obj recipient specication formulas type selector operations type operation viewed function takes prole type continuation returns prole messages object receive type message key component rts representation object hobs object implemented process obj executes main object loop runs protocol ltering processes p1 p2 p3 p4 mirroring process take care broadcast message loopback routing message objects object loopback routing uses simple intuitive tagging messages implemented associative broadcast rts implement associative broadcast algorithms creating prole required algorithm run algorithm need create parallel composition appropriate number objects proles 72 database consistency distributed database may several copies data entity ensuring consistency various copies becomes concern inconsistency arise transaction occurs connection two nodes broken know concurrent modications rare downtime short employ following optimistic protocol 2 failure occurs network nodes broken partitions network nodes log transactions discovering network reconnection construct global precedence graph log transactions graph contain cycles database consistent transaction t1 precedes transaction t1 t2 happened one partition t2 read data previously written t1 t1 t2 happened one partition t1 read data later written t2 t1 t2 happened dierent partitions t1 read data written t2 algorithm represents item table row etc depending locking scheme rts coordination object object keep log local transac tions object hold part precedence graph connect parts full graph object broadcast token objects along precedence graph edges object receives token propagate token along precedence edges object already maintains token returns originating object found inconsistency parallel token propagation object also sends merge message actually merge update values item dierent partitions object modied item receives merge message also declares inconsistency follows present key denitions im plementation code full implementation found figure 6 last page prole used object dened follows oidint mutable itemname string mutable itemvalue int mutable reads transaction list mutable written bool mutable partition int mutable merged bool mutable mcount int mutable tw transaction propagate int int profile operation merge int bool profile operation uponpartitioning unit profile operation uponcommitingtransaction int profile operation upondetectingreconnection profile operation object keeps unique identier oid name item monitors value item set transactions reads ag signal item written partition number also keeps set local attributes merged ag check whether item values already merged 1 item written also considered read partitions number merge messages received mcount last logged write transaction tw object two broadcasting operations propagate propagate token along precedence edges contains merge possibly update item new value object three local operations upon partitioning record local partition number upon commiting transaction record committed transactions upon detecting reconnection starts graph construction functions external system assumed provide local partition id get partition iden log log transactions modifies check whether transaction modies item precedes check using local log whether transaction precedes trans action declare inconsistency declare database incon delay transactions pause running trans actions count objects get number objects count local objects get number objects par tition write locked check whether item locked writing 8 related work section review works related basic design choices central proof technique used paper 81 alternative approaches modelling dynamic connectivity one approach modelling dynamic broadcast architectures support special messages change bridge behaviour corresponds transmission channel names calculus 12 another approach allow processes transmitted copies run elsewhere system makes calculus higher order like chocs 18 approach taken paper preliminary variant hobs sketched 15 retains underlying language messages functions resulting calculus seems unnecessarily complex underlying language seems redundant hobs processes entities used characterise bridges since processes broad casted interesting see hobs model features calculus arrival bridge delivery across happen sequence hobs avoids cbss insistence actions simultaneous comes cost less powerful synchronisation subsystems 82 related calculi bcalculus 5 seen version calculus broadcast communication instead pointto point particular bcalculus borrows whole channel name machinery calculus including operator creation new names thus bcalculus model ethernet directly obviously mobile version cbs reusing ideas sketched calculus encoding yield simple bcalculus encoding using l terss model scopes new names seems promising encoding might compositional expect appropriate type system achieve fully abstract encoding bcalculus type system would mixture hindleymilner polymorphic calculus systems ambient calculus 4 calculus mobile processes computation based notion movement equipped intraambient asynchronous communication similar asynchronous calculus since choice communication mechanism independent mobility primitives may interesting study broadcasting version ambient calculus also broadcasting ambient calculus might simple encoding hobs hobs join calculus 8 viewed extensions calculus hobs adds parallel composition broadcast communication top bare calculus join calculus adds parallel composition parallel pattern top calculus explicit let relationship two calculi remains studied feed operator foreshadowed implementations cbs see 16 achieve apparent synchrony allowing subsystems fall behind 83 congruence proofs ferreira hennessy jerey 7 use howes proof show weak bisimulation congruence cml use late bisimulation leave open question whether howes method applied early bisimulation paper directly answer question since late early semantics bisimulations coincide hobs proof late semantics hobs elegant one found extended version paper 14 thomsen proves congruence chocs 18 adapting standard proof nonwell founded induction proof eect similar proof howes technique tailored specically chocs abandons higher order bisimulation reasons specic pointtopoint communication private channels uses context bisimulation adapts standard proof proof similar diculty proof presented especially case process appli cation involving substitution dicult 9 acknowledgements would like thank dave sands bringing howes method attention jorgen gustavsson martin wei chert gordon pace many discussions anonymous referees constructive comments 10 r lazy lambda calculus bryan bayerdor secrecy group creation mobile ambients expressivness pointtopoint versus broadcast communications broadcastbased calculus communicating systems alan je bisimilarity theory functional programming minicourse proving congruence bisimulation functional programming languages communication concurrency communicating mobile systems notions computation monads karol ostrovsk status report ongoing work higher order broadcasting systems reasoning broadcasts calculus broadcasting systems expressing mobility process algebras firstorder higherorder paradigms plain chocs second generation calculus higher order processes polymorphic picalculus theory implementation tr communication concurrency notions computation monads lazy lambda calculus calculus broadcasting systems proving congruence bisimulation functional programming languages reflexive cham joincalculus communicating mobile systems mobile ambients secrecy group creation expressiveness pointtopoint versus broadcast communications ctr massimo merro observational theory mobile ad hoc networks electronic notes theoretical computer science entcs 173 p275293 april 2007 patrick eugster typebased publishsubscribe concepts experiences acm transactions programming languages systems toplas v29 n1 p6es january 2007
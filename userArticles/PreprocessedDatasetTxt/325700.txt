framework combining analysis verification present general framework combining program verification program analysis framework enhances program analysis takes advantage user assertions enhances program verification assertions refined using automatic program analysis enhancements general produce better way reasoning programs using verification techniques alone analysis techniques alone importantly combination better simply running verification analysis isolation combining results last step words framework explores synergistic interaction verification analysis paper start representation program user assertions given analyzer program framework describe induces algorithm exploits assertions analyzer produce generally accurate analysis important features flexible number assertions used anywhere open employ arbitrary analyzer modular reason conditional correctness assertions incremental tuned accuracyefficiency tradeoff b introduction abstraction 9 successful method abstract interpretation abstract domain constructed given finite set predicates program variables intuitive easily though necessarily efficiently computable within traversal method programs control flow structure recently success predicate abstraction enhanced process discovery copyright notice appear abstract domain generally known cegar counterex ample guided abstraction refinement one major disadvantage predicate abstraction true many realizations abstract interpretation principle process abstraction performed every step traversal phase indeed survey section 19 states abstractions often defined small parts program abstractions modelchecking often overapproximate generally easy optimize somewhat performing abstraction eg several consecutive asignments may compressed abstraction performed according one composite assignment blast system 11 systematic way another disadvantage arising partly abstract description limited fixed number variables adhoc method would compositional example 2 required elaborate extension predicate abstraction essentially considers second set variables called symbolic constants order describe behaviour function language predicate abstrac tion provided limited form compositionality paper present general proof method program reasoning based predicate abstraction process abstraction intermittent approximation performed selected program points restriction abstraction performed even though termination issues usually restrict choices key advantages abstract domain required ensure convergence algorithm minimized b cost performing abstractions inter mittent reduced example reason executing x one needs know final assignment also consider proving following program snippet 1 n textbook hoarestyle loop invariant loop 2i proposition predicate abstraction would however suffice one fact needs know holds two increments c thus general proper loop invariant useful could propagate information exactly main challenge exact propagation reasoning required strongestpostcondition operator associated arbitrarily long program fragment essentially means dealing constraints unbounded number variables describing states start end program fragment hand advantages terms efficiency however significant less predicates needed abstract domain also less frequent execution abstraction operation important additional feature proof method compositional represent proof hoarestyle triple given program fragment relates input values variables output values represented formula general formula must contain auxiliary variables addition program vari ables generally impossible represent projection formula using predefined set vari ables equivalently possible perform quantifier elimination consequently order unrestricted composition proofs necessary deal unbounded number variables latter part paper introduce technology constraint logic programming clp basis efficient implementation briefly advantages clp handles terms containing anonynous primary variables constraints variables also arbitrary number auxiliary variables b efficiently represents projection terms c handles backtracking summary show method provides flexible combination abstraction hoarestyle reasoning predicate transformers loopinvariants composi tional practical implementation feasible 11 related work important category tools use program verification technology developed within framework java modelling language jml project jml allows specify java methods pre postconditions class invariants examples program verification tools jack 4 escjava2 7 krakatoa 15 tools employ weakest preconditionstrongest postcondition calculi generate proof obligations reflect whether given postconditions class invariants hold end method whenever corresponding preconditions valid procedures entry point resulting proof obligations subsequently discharged theorem provers simplify 7 coq 3 pvs 17 hol light 10 systems perform exact propagation depend userprovided loop invariants opposed abstract domain recently emerged systems based abstract interpretation particular predicate abstraction examples blast 11 slam 1 magic 5 murphi 8 amongst others abstract interpretation central systems employ technique automatically determining abstract domain needed given assertion technique called cegar see eg description 6 based iteratively refining abstract domain failure abstract domain previous iteration systems perform exact propagation systematic way 2 preliminaries apart program counter k whose values program points let n system variables domains respectively paper shall use two example domains integers integer arrays assume number system variables larger number variables required program fragment procedure definition 1 states transitions system state simply state form kd 1 n pc program point 1 n values system variables transition pair states follows define language firstorder mulas let v denote infinite set variables type 1 n let denote set func tors p denote set constraint symbols term either constant 0ary functor form term primitive constraint form ft 1 f mary constraint symbol term constraint constructed primitive constraints using logical connectives usual manner constraint write x denote possibly refers variables x write x denote existential closure away x substitution mapping simultaneously replaces variable term constraint ex pression e term constraint write eq denote result applying q e special kind substitution renaming maps variable given sequence say corresponding variable another given sequence say write denote mapping another special kind substitution grounding maps variable expression value respective domain thus effect applying grounding substitution q expression e obtain set eq ground instances q write denote set possible groundings e 3 constraint transition systems key concept program fragment p operates sequence anonymous variables corresponding system variable various points computation p particular consider two sequences n anonymous variables denote system values executing p target points p respectively typically always target point terminal point p proof obligation assertion form 1 constraints said variables possibly including new variables like hoaretriple states p executed state satisfying states target points satisfy 1 note unlike hoaretriple p may nonterminating 1 may refer states point reached infinitely often formalize example let one system variable x let p 0 x let target point 1 meaning p successor function x similarly p perpetual program 0 true x 1 target point truepx state 1x point 1 satisfies zx shows amongst things parity x always remains unchanged proof method accomodates concurrent programs fixed number processes n processes shall use program point sequence n program points th program point one comes th process next represent program fragment p transition system executed symbolically following definition serves two main purposes first high level representation operational semantics p fact represents exact trace semantics p second executable specification assertion checked definition 2 constraint transition system constraint transition p formula k k 1 variables program points x x 1 sequence variables representing system even5 even5 figure 1 even counts process 1 true process 2 true figure 2 two process bakery figure 3 cts two process bakery state constraint x possibly additional auxiliary variables constraint transition system cts p finite set constraint transitions p consider example program section 1 call even figure 1 contains cts even consider another example bakery algorithm two processes figure 2 cts program call bak given figure 3 note use first second arguments term bub denote program points first second process respectively clearly variables constraint transition may renamed freely scope local transition thus say constraint transition variant another one identical renaming subsitution performed may simplify constraint transition renaming one variables x expression provided groundings constraint tran sition example may simply state last constraint transition figure 3 replacing variable 1 original transition 0 formulation program transitions familiar literature purpose defining set transi tions new however use cts define symbolic transition sequences thereon notion proof similarity logic programming use term goal deonote literal subjected unfolding process order infer logical consequence definition 3 goal query goal cts k program point sequence variables system states constraint variables x possibly additional variables variables x called primary variables goal additional variable called auxiliary variable goal thus goal like conclusion constraint transition say goal start goal k start program point similarly goal target goal k target program point running start goal tantamount asking question values x satisfy lead goal target points idea successively reduce one goal another resulting goal target point inspect results next define means cts prove goal definition 4 proof step sequence tree let cts p let xy goal proof step g obtained via variant pk transition cts variables fresh result goal g form 1 providing constraints 1 satisfiable proof sequence finite infinite sequence proof steps proof tree defined proof sequences obvious way tree complete every internal node representing goal g succeeded nodes representing every goal obtainable proof step g figure 5 proof tree even counts program consider cts figure 1 wish prove fact one proof sequence start goal equivalently even0 10 proof sequence shown figure 5 note counterrepresented last goal variable c 2 value 2 hereafter shall consider program cts synonymous given program p say x start variables p denote x variables first constraint transition p definition 5 assertion let p program start variables x let constraint let x denotes sequence variables representing system states appearing p represent target values system assertion p wrt x form particular k start program point may abberviate assertion using notation intuitively clear means assertion hold execution every instance q pk cannot lead target state property 1 violated example could prove assertion understood final variable c corresponds start variable c note last occurrence n assertion means comparing c initial final value n though example two fact state essential property proof sequences theorem 1 let cts p start point k target x x 1 sequences variables figure 4 proof tree 2process bakery algorithm partially shown system states assertion holds goal form pk appearing proof sequence goal pk x following holds theorem provides basis search method remains provide means ensure termination search toward end next define concepts subsumption coinduction allow successful termination proof sequences however generally insufficient next section present version abstraction whose purpose transform proof sequence applicable termination criteria subsumption coinduction 31 subsumption consider finite complete proof tree start goal goal g tree subsumed different path tree containing goal g g principle simply memoization one may terminate expansion proof sequence constructing proof tree encountering subsumed goal 32 coinduction principle within one proof sequence proof obligation associated final goal may assume proof obligation ancestor goal already met formally explained principle coinduction see eg appendix b 16 importantly simple form coinduction require base case wellfounded ordering shall simply demonstrate principle example suppose transition p0x p0x wished prove assertion p0x evenx x difference x final value even consider derivation step may use latter goal fact earlier goal satisfies assertion may reduce obligaton latter goal simple matter inferring whether formula holds general practice application coinduction testing largely equivalent testing one goal simply instance another 33 compostionality intuitively clear since proof obligation relates start final values program equivalently obeys assumeguarantee paradigm 18 proof method sequentially compositional thus omit formal treatment cts programs directly invoke programs instead next section provide simple example 4 abstraction literature predicate abstraction abstract description specialized data structure monomial abstraction operation serves propagate structure though small program fragment contiguous group assignments test obtaining another struc ture strength method simplicity using finite set predicates fixed number program variables basis abstract description choose follow method however abstract description shall distinguished data structure abstract description goal goal definition 6 abstraction abstraction applied goal specified program point pca sequence variables vara corresponding subset system variables finally finite set constraints preda vara called predicates let abstraction g goal pk xy x denote subsequence x corresponding system variables vara let x denote remaining subsequence x without losing generality assume x 1 initial subsequence x x abstraction ag g z sequence fresh variables renaming 2 finite set constraints example let first variable abstracted negative nonnegative value let g p0 x 1 x 2 x 3 x 1 abstraction ag goal form p0 zx 2 x 3 x simplified p0 zx 2 x 3 x note orginal goal ground instances p0 1 1n n abstracted goal instances p0 m1n n nonnegative note second variable x 2 abstracted even though tightly constrained first variable x 1 note value x 3 unchanged abstraction would allow constraint x 3 example goal contained constraint propagated lemma 1 let abstraction g goal critical point abstraction goal format goal thus abstract goal expressive power regular goal yet containing notion abstraction sufficient produce finitestate effect facilitated ability reason unbounded number variables consider bubble program cts figures 7 8 simplified skeleton bubble sort algorithm without arrays consider subprogram corresponding start point 2 whose target point 6 considering inner loop suppose following assertion already proven bub2 j n subprogram increments n preserving n j consider proof sequence goal bub0 j nn 0 want prove program point 8 n2 proof tree depicted figure 6 proof shows combination use intermittent abstraction compositional proof point abstract goal bub2 using predicates i2 call abstraction set variables hence variables correspond respectively system variables 1 n1 3 j ni1 figure 7 program bubble bub0 j n bub1 bub1 j n bub8 j n n1 bub1 j n bub2 j n n1 bub2 j n bub3 bub3 j n bub6 j n j n 1 bub3 j n bub4 j n j n 1 bub4 j n bub5 bub5 j n bub6 j n j n 1 bub5 j n bub4 j n j n 1 bub6 j n bub7 bub7 j n bub8 j n n1 bub7 j n bub2 j n n1 figure 8 cts bubble renamed fresh variables 2 2 mean variables j n retain original values performing abstraction reuse proof inner loop immediately move program point 6 incrementing updating j unknown value however n retain original values 2 result intermittent abstraction obtain coinductive proof b 5 whole algorithm summarize proof method assertion suppose start program point p k start variables p x consider start goal pk incrementally build search tree path tree constructed far leading goal g g either subsumed coinductive consider path closed ie expanded g goal abstraction defined replace g ag g target goal constraints primary variables x 1 g satisfy yq q renames target variables coinduction using satisfies satisfies proof composition intermittent abstraction bub0 j nn 0 figure 6 compositional proof theorem 2 algorithm applied assertion asertion holds 6 clp technology almost immediate cts implementable clp given cts p build clp program following way every transition form k use clp rule clause pk ing constraint domain clp implementation hand b every terminal program point k use clp fact pk number anonymous variables number variables x see later key implementation challenge clp system incremental satisfiability problem roughly stated problem successively determining monotonically increasing sequence constraints interpreted conjunction satisfiable 61 exact propagation clphard informally demonstrate incremental satisfiability problem reducible problem analyzing straight line path program consider constraints form linear diophantine equations ie multivariate polynomials integers without loss generality assume constraint written form integer suppose already sequence constraints corresponding path programs control flow suppose add new constraint one variables say new add assignment x z new variable created correspond remaining variables x z either new corresponding variable x z however xy z new add statement program variables corresponding x z respectively hereafter pursue branch statement similarly suppose new constraint form correspond possibly new x new simply add assignment x n x newly created correspond x otherwise add statement path pursue branch statement clearly exact analysis path constructed leading successful traversal required incrementally solving constraint sequence 0 n 62 key elements clp systems clp system attempts find answers initial goal g searching valid substitutions variables depthfirst search used path search tree fact involves solving incremental satisfiability problem along way unsatisfiability constraints hand would entail backtracking key issue clp incremental satisfiability problem mentioned standard approach follows given sequence constraints 0 determined satisfiable represent fact solved form essentially means new constraint i1 encountered solved form efficiently combinable i1 order determine satisfiability new conjunction constraints method essentially requires representation projection set constraints onto certain variables con sider example set x assuming new constraint would involve variable x happens vastly ten desire representation x projection problem well studied clp systems 13 system clpr 14 example various adaptations fouriermotzkin algorithm implemented projection herbrand linear arithmetic constraints finally mention another important optimization clp tail recursion technique uses space procedure call stack recursive calls amongst bebefits technique allows potentially unbounded number recursive calls tail recursion particurly relevant context recursive calls arising cts programs often tailrecursive clpr system use implement prototype engineered handle constraints auxiliary variables efficiently using techniques 7 experiments performed two kinds experiments first set performs exact propagation look comparable abstract runs blast system exact runs system results presented section 71 second set experiments presented section 72 compare intermittent predicate abstraction normal predicate abstraction blast system used pentium 4 28 ghz system 512 mbram running gnulinux 2422 71 exact runs start experiment shows concrete execution potentially less costly abstract execution simply compare timing concrete execution using clpbased implementation predicate abstractionbased model checker also run simple looping program whose c code shown figure 9 first blast generate 100 predicates requires rerun blast providing predicates blast took 2206 seconds explore state space machine without abstraction verification engine took seconds comparison spin model checker 12 executes program written promela less seconds consider synthetic program consisting initial assignment x 0 followed 1000 increments x objective proving 1000 end consider also another version program contains single loop increments counter x 1000 times input two programs program verifier without using abstraction escjava 2 well results shown table 1 verifier escjava 2 run x initialized 0 initialized hopefully forcing symbolic execution table 1 shows verifier runs faster nonlooping version however noticeable slowdown int main int i0 j x0 i7 j7 x j error figure 9 program loop time seconds clp tabling escjava 2 nonlooping 245 247 989 968 looping 2205 2195 100 100 table 1 timing comparison escjava 2 looping version implementation caused fact implementation coinductive tabling subsumption check done based similarity program point therefore program point inside loop visited ith time 1 subsumption checks performed results total 500000 subsumption checks looping program comparison nonlooping version requires 1000 subsumption checks however implementation currently prototype stage tabling mechanism implemented efficient way looping version escjava 2 employs weakest precondition propagation calculus since program small straightforward invariant loop condition computation fast table also shows almost difference x initialized 0 72 experiments using abstraction next show example demonstrates intermittent approach requires fewer predicates let us consider second looping program written c shown figure 10 programs postcondition proven providing invariant xi i50 exactly first statement loop body outer loop specify abstraction domain following predicates xi i50 respectively negations xi i50 program point verifier using information proof process finishes less 001 seconds provide abstract domain verification process finishes 2034 sec onds intermittent predicate abstraction requires fewer predicates also run program blast provide predicates xi i50 blast would auto int main int i0 j x0 i50 j10 x j xi x error figure 10 second program loop true figure 11 bakery algorithm peudocode process matically also consider negations blast finishes 133 seconds addition also produces 23 predicates refinements running predicates given blast finishes 028 seconds also tried proof method version bakery mutual exclusion algorithm need abstraction since bakery algorithm infinitestate program pseudocode process shown figure 11 would like verify mutual exclusion two processes critical section program point 2 time version bakery algorithm concurrent program asynchronous composition processes encoded sequential program nondeterministic choice first encode algorithm 2 3 4 processes blast nondeterministic choice implemented blast using special variable blast nondet nondeterministic value show blast code 2process bakery algorithm figure 12 within code use program point annotations pc considered comments notice program points concurrent version encoded using integer variables pc1 pc2 translate blast sequential versions algorithm 2 3 4 processes cts version shown figure 13 also corresponding clp code input prototype verifier experiments attempt verify mutual exclusion property two processes critical section time perform 3 sets runs consisting runs 2 3 4 processes 3 sets use basic set predicates x 0 x 0 pc 0 pc 1 int main 0 int pc10 pc20 unsigned int x10 x20 1 1 2 pc11 pc21 3 abstraction point 1 4 pc10 pc20 5 abstraction point 2 else pc12 pc22 6 error 7 blast nondet 8 pc10 else pc11 else pc12 else 12 pc20 else pc21 else pc22 figure 12 sequential 2process bakery n number processes also negations set 1 use predicate abstraction every state full predicate set using prototype system perform ordinary predicate abstraction abstract every state encountered search addition basic predicates also require predicates shown table 2 negations avoid producing spurious counterexample set 2 intermittent predicate abstraction full predicate set second set use intermittent abstraction technique prototype implementation abstract process pc 1 holds figure 12 abstraction point marked comment abstraction point 1 set predicates use predicates use first experiment otherwise spurious counterexample generated set 3 intermittent predicate abstraction reduced predicate set third set also use intermittent abstraction technique tabled clp system abstract whenever n1 processes program point 0 2process sequential version condition either pc10 pc20 bak3 pc1 pc2x1x2 bak4 pc1 pc2x1x2 bak5 pc1 pc2x1x2 bak7 pc1 pc2x1x2 2 bak6 pc1 pc2x1x2 bak7 pc1 pc2x1x2 bak7 pc1 pc2x1x2 bak8 pc1 pc2x1x2 bak7 pc1 pc2x1x2 bak12 pc1 pc2x1x2 2 2 2 2 figure 13 cts sequential 2process bakery bakery2 x1x2 bakery3 x1x2 x1x3 x2x3 bakery4 x1x2 x1x3 x1x4 x2x3 x2x4 x3x4 table 2 additional predicates time seconds clp tabling blast bakery3 083 014 009 238 bakery4 13111 885 502 7847 table 3 timing comparison blast marked comment astraction point 2 figure 12 bakery algorithm n processes need basic predicates negations without additional predicates shown table 2 also compared results blast supplied set predicates used first second sets blast blast specify negations explicitly interestingly 4process bakery algortihm blast requires even predicates avoid refinement x1x31 x2x31 x1x21 1x4 x1x3 x2x3 x1x2 suspect due fact precision predicate abstractionbased statespace traversal depends power underlying theorem prover blast generate additional predicates needs prerun run blast using since run blast refinement lazy abstraction technique 11 effect blast uses supplied predicates represent abstract state problems using intermittent abstraction clp tabling also markedly faster full predicate abstraction clp blast show timing results table 3 smallest recorded time 3 runs first set blast run abstraction every visited state timing difference second third sets shows performing abstraction every visited state expensive third set shows gain second understand intricacies system acknowledgement thank ranjit jhala help blast r automatic predicate abstraction c programs polymorphic predicate abstraction coq proof assistant reference manualversion v6 java applet correctness developeroriented approach modular verification software components c escjava2 uniting escjava jml experience predicate abstraction construction abstract state graphs infinite systems pvs hol light tutorial introduction lazy ab straction spin model checker primer reference manual projecting clpr clpr krakatoa tool certification javajavacard programs annotated jml principles program analysis pvs prototype verification system proof technique relyguarantee properties model checking programs tr constraint logic programming methods logics proving programs based program analysis modern compiler implementation ml simplification cooperating decision procedures abstract interpretation systematic design program analysis frameworks flexible approach interprocedural data flow analysis programs recursive data structures proving safety properties integrating static analysis theorem proving abstraction program analysis using mixed term set constraints experiments theorem proving model checking protocol verification powerful techniques automatic generation invariants verifying invariants using theorem proving pvs
parallel linear programming fixed dimension almost surely constant time fixed dimension time information processing letters v22 n1 p2124 january 2 1986 b introduction linear programming problem fixed dimension maximize linear function fixed number variables subject n linear inequality constraints n fixed megiddo 11 showed problem solved time clarkson 4 dyer 7 improved constant proportionality clarkson 5 later developed lineartime probabilistic algorithms even better complexity problem fixed dimension interesting point view parallel computation since general linear programming problem known pcomplete algorithm 11 parallelized efficiently exact parallel complexity problem fixed dimension still known 1 develop efficient probabilistic parallel algorithm based clarksons 5 scheme paper say sequence events fe n g 1 occurs almost surely mean exists ffl 0 probe n consequence estimate probability 1 finite number events occur main result paper generalizes known fact 12 10 maximum n items computed almost surely constant time mentioned basic idea underlying sequential algorithm due clarkson 5 beautiful iterative sequential algorithm uses idea welzl 14 clarksons algorithm also sample constraints repeatedly variable probabilities several additional ideas modifications however required order achieve result paper probabilistic analysis also different focuses probabilities failure meet time bounds rather expected running times particular suitable sequential implementation algorithm shown terminate almost surely within best known asymptotic bounds expected time 1 ajtai megiddo recently developed deterministic algorithms run linear number processors polylog log n time section 2 present special form output required linear programming problem unifies cases problems optimal solutions unbounded ones section 3 describe algorithm provide necessary probabilistic analysis 2 preliminaries purpose section state required form output linear programming problem turns useful purposes paper 21 special form output ng suppose linear programming problem given form minimize c delta x subject fc 1 n g ae r b 1 b n real scalars inequality delta x b called constraint denote lp similar problem subset ae n constraints imposed lp infeasible ie x exists set z n jzj lpz infeasible case refer lexicographically minimal z defining subset n fixed scalar denote p problem minimize subject objective function p strictly convex hence lp feasible p unique optimal solution x easy see latter characterized closest point origin among points x c fix let n denote set indices delta x n obviously moreover classical karushkuhntucker optimality conditions imply nonnegative linear combination vectors 2 ie classical theorem linear programming exists set b fa g i2b linearly independent i2b follows x n moreover delta x n b particular value optimal solution change inequalities pb replaced equalities importance argument b shows piecewise linear nature parametric solution 22 analysis parametric solution denote b matrix whose rows vectors 2 b let bb denote vector whose components corresponding b assuming lpb feasible since subject bx bb follows exists jbj since rows b linearly independent represent solution form vector u however solution pb b 0 denote b set values b 0 also delta 2 n obviously b precisely interval ts x n shown lp feasible x n varies piecewise linearly linearly independent set b contributes one linear piece thus exists last set z ae n jzj exists 0 0 given correct z easy compute semiinfinite interval z x n interesting distinguish two possible cases first v means original problem minimum constraints corresponding z present case u z optimal solution minimum norm among optimal solutions second v z 6 0 original problem unbounded fu z feasible ray along c delta x tends gamma1 moreover point ray minimum norm among feasible points value c delta x view define vectors u n v n equal u z v z respectively indeed subset n whose corresponding vectors may linearly dependent define appropriate vectors u v describe output required problem lp summarize proven following proposition 21 ray coincides optimal solution pn sufficiently large exists subset z ae n whose corresponding vectors linearly independent ray coincides optimal solution pz every point polyhedron exists precisely one face polyhedron contains point relative interior consider lexicographically minimal set z describes face say set z defining subset solution 23 fundamental property denote v u v set indices 2 n sufficiently large values say corresponding constraint asymptotically violated u v obviously set indices 2 n delta either delta following proposition essentially due clarkson 5 proposition 22 ae n v ae n valn sufficiently large proof contrary v arrive contradiction sufficiently large strict inequality follows uniqueness solution p importance proposition 22 explained follows set found least one constraint violated optimal solution lp least one violated constraints must belong defining set thus probabilistic weight violated constraint increases know weight least one constraint defining set increases 3 algorithm mentioned underlying scheme algorithm iterative algorithm paper clarkson 5 adaptation parallel machine requires many details modified single iteration processors sample subset constraints solve subproblem lp brute force latter infeasible original one done also solution latter feasible original problem terminate typically though constraints original problem violated solution sampled subproblem case remainder iteration devoted modifying sample distribution next iteration violated constraints become likely sampled process modifying distribution much involved context parallel computation amounts replicating violated constraints processors keep sampling uniform distribution replicating procedure carried two steps first set violated constraints compressed smaller area processors attempt replicate run algorithm probability entire defining set included sample increases rapidly order implement ideas efficiently pram several parameters algorithm chosen care special mechanisms introduced algorithm utilizes processors largest integer first describe organization memory shared processors 31 shared memory shared memory consists four types cells follows base b consisting k cells b 1 bk 2 notation means exists constant c 0 fn cgn ii sequence consisting 2n cells 1 s2n also partition sequence 2n 34 blocks length n 14 cells also addressed si j iii table consisting log16d 2 also partition table c blocks length cells also addressed j iv area r consisting n 34 cells r 1 rn 34 also partition area n 14 blocks size n cells also addressed ri j memory cell stores either halfspace h space r initially cells store space r base always describes subproblem lpk k set constraints stored base choice parameters every base problem solved brute force olog 2 time show proposition 31 sequence sample space constraints maintained initially sequence stores one copy constraint throughout execution algorithm copies added depending constraints discovered violated solutions subproblems role table area facilitate process modifying sample distribution 32 base problem already indicated algorithm repeatedly solves brute force subproblems consisting k constraints proposition 31 using 2nd log 2 dprocessor crcw pram subproblem lpk constraints solved deterministically olog 2 time proof recall order solve base problem p processors allocated subset b ae k thus number processors assigned b bounded maxfd 3 kd log 2 dg follows subproblems lpb solved olog 2 time amounts solving system linear equations order 2d theta 2d least 3 processors see 2 lpb discovered infeasible lp infeasible algorithm stops otherwise b algorithm checks whether asymptotically feasible ie feasible sufficiently large lpk log 2 processors takes olog 2 time evaluate inner product two dvectors 3 since least kd log 2 processors assigned b 3 easy see inner product evaluated log processors olog time afford olog 2 time save number processors asymptotic feasibility lpk checked olog 2 time finally algorithm finds best among solutions lpb feasible lpk case none feasible lpk algorithm recognizes lpk hence also lp infeasible final step essentially computation minimum algorithm valiant 4 13 easily implemented crcw pram finds minimum elements using p processors ologlog logpm time time olog 33 iteration describe sampling works sample space maintained sampling base problem iteration algorithm starts sampling base problem indicated sample space stored scells 2n cells stores either constraint entire space one constraint may stored one scell perform sampling first k processors p generates random integer 5 uniformly 1 2n copies contents scell si bcell 4 note different choice k namely k gamma k p use valiants algorithm avoided 5 assume processors generate random numbers olog n bits constant time processors jointly solve subproblem lpk currently stored base see proposition 31 olog 2 time asymptotically violated constraints assuming lpk feasible algorithm checks scells store constraints violated asymptotically ray fu k sufficiently large task accomplished assigning log 2 processors cell follows processors p j 1 assigned cell check asymptotic feasibility constraint stored therein explained section 2 step also takes olog 2 time since essentially amounts evaluation inner products dvectors brevity say scell storing asymptotically violated constraint violated replicating violated constraints identified violated scells processors replicate contents cell n 14d times idea repeating step several times members defining set get sufficiently large probability included sample case problem solved since known advance scells violated since processors algorithm cannot decide advance processors replicate cells reason replication step carried probabilistic crcw pram two parts first violated scells injected table whose size 1gamma12d replications made table back sequence using predetermined assignment processors cells first part step performed follows injecting table operation 1 first violated cell processor p generates random integer 1 0 attempts copy contents attempted write failed generates random integer 2 attempts copy contents general processor attempts write c gamma 1 times time different block table proposition 32 conditional probability least n 14 processors fail write c given n 16d processors attempt write first trial e gammaomegagamma n 14 proof let x random variable representing number processors failed write first rounds therefore attempt write 1st round suppose 16d note processor attempting write ith round conditional probability involved write conflict given information success failure processors round x thus apply estimates independent bernoulli variables estimate due chernoff 3 apply proposition 41 part let j denote largest integer log16d n sufficiently large notice indeed hence thus 16d probability j satisfy latter e gammaomegagamma n 14 combining proposition 41 part ii get note pointed one referees analysis last proposition somewhat simplified processors try inject violated constraints table c 0 times succeed easy see say c 0 16d conclusion proposition 32 hold however increase running time phase algorithm omegagamma therefore better perform first part injection described alternatively time increase avoided making c 0 attempts parallel case one success erase first successful replication omit details implementation injecting table operation 2 complete step injecting table one final operation performed operation algorithm uses predetermined assignment processors 2n 34 sblocks eg processor p j assigned block scell said active point failed c injected table sblock said active contains least one active cell 6 active block q processors assigned j attempt write symbol j area r follows ith processor among assigned j generates random 7 integer 1 p n attempts write symbol j cell ri 6 takes constant time reach situation q processors knows whether assigned active sblock 7 last step also done deterministically hash functions proposition 33 less n 14 active sblocks probability conflicts occur every single rblock less e gammaomegagamma n 14 proof n 14 processors attempt write rblock whose length n probability conflict within fixed rblock less 12 thus probability conflicts every single rblock less 2 gamman 14 takes constant time reach situation processors recognize specific block r j conflict assuming least one block exists point names active sblocks moved one commonly known block r j role area r facilitate organization work involved replicating remaining active sblocks last block next n 14 processors assigned cell ri j n cell either empty contains index j active sblock j latter case processors assigned ri j copy contents active cells j last block according predetermined assignment table sequence second half replication step algorithm uses predetermined manyto assignment first c n 1gamma14d processors cells n 14d processors assigned cell processor p j copies contents oej cell depends processor iteration number later discuss actual number iterations show almost surely 2n unlikely event number iterations gets large algorithm simply restarts 34 probabilistic analysis section analyze probability algorithm fails include defining set sample certain constant number iterations estimating number violated scells let fixed weak linear order n given contents sequence random base set k denote k number scells store halfspaces h 8 j oe j h j base proposition 34 possible contents sequence every ffl 0 8 write j oe j 6 j proof x 0 particular d1 ffl probability claim follows fact n lpm feasible denote weak linear order induced n asymptotic behavior quantities b tends infinity precisely j sufficiently large brevity denote 0 corollary 35 ffl 0 conditional probability violated scells u k lpk feasible less proof consider set l orders b corresponds set linearly independent vectors hence jbj lpb feasible lpk feasible proposition 21 exists z k whose corresponding constraints linearly independent 2 l proposition 34 fixed proposition 36 iteration probability least one active scell fail inject contents table e gammaomegagamma n 116d proof proof follows immediately corollary 35 propositions 32 33 successful iterations let lpk denote current base problem iteration considered successful either following cases problem lpk discovered infeasible hence lp algorithm stops ii problem lpk feasible solution u turns feasible lp sufficiently large also solution lp algorithm stops iii least one defining set z see section 2 h asymptotically violated storing h injected table proposition 37 iteration given past history conditional probability failure e proof proposition 22 solution lp found h violated least one 2 z hence every processor checking copy h attempt inject table result follows proposition 36 proposition 38 fixed probability algorithm finish within 9d 2 iterations e gammad 2 n 116d proof notice 9d 2 iterations sufficiently large n first n possibly accessed proposition 37 itera tion conditional probability failure given past history e gammaomegagamma n 116d therefore probability less 5d 2 successes 9d 2 iterations less complete proof show impossible 5d 2 successes many successes exists least one defining set z least 5d iterations contents scells storing halfspace h successfully injected table 9 means least scells storing h whereas total length sequence 2n hence contradiction thus proven following theorem 39 exists probabilistic parallel algorithm linear programming problem variables n constraints runs 2nd log 2 dprocessor crcw pram performance follows algorithm always finds correct lution exists ffl 0 eg every fixed sufficiently large n probability algorithm takes od 2 log 2 time less e gammaomegagamma n ffld improvement difficult modify algorithm obtain one two constants independent performance follows every fixed dimension sufficiently large n probability running time exceed 9 table erased iteration 2 gammaomegagamma n ffl done choosing size k base problem k n enables us solve iteration random base problems simultaneously processors assigned scells processor chooses randomly one base problems processor checks whether constraint cell violated solution base problem base problems associate table size n 1 32d next processor violated scell respect base problem chosen processor attempts inject contents cell table base problem done corresponding steps algorithm described call base problem successful processors attempting write succeed eventually note base problem successful many scells among whose processors chose base problem violated therefore high probability many scells altogether violated solution base problem algorithm chooses successful base problem continues previous algorithm ie checks scells violated injects cells table size 2c n 1gamma14d replicates violated ones n 15d times say iteration successful least one base problems successful contents violated scells injected successfully table difficult check conditional probability iteration successful given information success failure previous iterations e omit details remarks total work done processors algorithm od 3 n whereas clarksons sequential algorithm 5 runs expected od 2 n time easily modify algorithm run probabilistic crcw pram nd log 2 processors od 3 log 2 time total work od 2 n moreover probability longer running time exponentially small terms n end observe using previous algorithm solve od 2 log 2 time nd log 2 processors base problem size nd 2 hence repeat previous algorithm choosing base problems size nd 2 solving checking violated scells od 2 log 2 time replicating violated scell times algorithm terminates almost surely od iterations hence total parallel time od 3 log 2 4 appendix following proposition summarizes standard estimates binomial distribution used paper random variable x binomial distribution parameters n p sum n independent 0 1variables expectation p proposition 41 x binomial random variable parameters n p every 0 ag particular 05np ii e 2 np probfx ag e gammaa proof part due chernoff 3 see also 1 p 237 part ii follows immediately fact ag en acknowledgement thank moni naor helpful suggestions concerning step injection table led significant improvement estimate failure probabilities also thank two anonymous referees helpful comments r probabilistic method fast parallel matrix gcd compu tations measure asymptotic efficiency tests hypothesis based sum observations linear programming on3 2 time las vegas algorithms linear integer programming dimension small optimal parallel algorithm linear programming plane multidimensional search technique application euclidean onecenter problem randomized algorithm fixed dimensional linear pro gramming linear programming two variables per inequality poly log time parallel algorithms finding maximum median almost surely constanttime linear programming linear time dimension fixed fast probabilistic parallel sorting algorithm parallelism comparison algorithms partition trees triangle counting range searching problems tr linear programming myampersandtimes 3supscrptdsupscrpt2 time multidimensional search technique application euclidean one centre problem partition trees triangle counting range searching problems randomized algorithm fixeddimensional linear programming linear programming two variables per inequality polylog time linear programming linear time dimension fixed ctr sandeep sen parallel multidimensional search using approximation algorithms applications linearprogramming related problems proceedings eighth annual acm symposium parallel algorithms architectures p251260 june 2426 1996 padua italy surender baswana sandeep sen simple linear time randomized algorithm computing sparse spanners weighted graphs random structures algorithms v30 n4 p532563 july 2007
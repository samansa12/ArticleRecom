stack queue integrity hostile platforms computationally intensive tasks carried trusted limited platforms smart cards becomes necessary compensate limited resources memory cpu speed offloading implementations data structures available insecure untrusted fast coprocessor however data structures stacks queues rams hash tables corrupted made behave incorrectly potentially hostile implementation platform adversary knowing choosing data structure operations paper examines approaches detect violations datastructure invariants placing limited demands resources secure computing platform b introduction smart cards settop boxes consumer electronics forms trusted hardware 2 3 16 available proposed 1 applications electronic commerce shall refer devices devices typically composed circuit card encased epoxy similar substance strewn various electronic tamperdetection devices physical design constraints devices include heat dissipation difficulties size often credit card pcmcia low power consumption requirements etc leads particularly credit card format devices exceedingly low data transfer rates mem ory omputing resources resources limitation applications areas cash cards identity cards etc however general purpose multiapplication cards resource limitations significant exploring use trusted hardware software engineering 7 6 see section 6 appears ieee computer society symposium research security privacy oakland ca may 1998 pp 198206 context becomes necessary store large amounts data form various data structures stacks queues arrays dynamicstatic symbol tables various types trees etc data structures cannot fit limited resources device however devices usually used concert larger powerful presumably adverse host computer h data structures stored h integrity assured data structures invariants instance data struc ture invariants stored digested form signatures within device data structure operations performed conjunctions modifications signatures maintain digested form invariants approach differs earlier work 4 5 protocols much simpler use o1 memory trusted computer transfer o1 amount data push pop operation online mode previous approaches used ologn trusted memory ologn data transfer operation n size stack queue ever previous work 4 5 assumed extremely powerful adversaries information theoretic bounds follow line work quite different techniques applicable computationally bounded adversaries paper organized follows section 2 present goals threats related work section 3 describes protocol stacks evaluation section 4 describe protocol queues evaluation section 5 describes previous work handle random access memory discusses relationship stacks queues work section 7 describes extensions protocols section 6 describes applications using protocols section presents concluding remarks background section discuss goals work threats related work goal work maintain integrity stacks queues maintained potentially hostile platform also wish manner extensible desired properties described section 7 need make assumptions adversary environment may focus description security data structure application assume channel h authenticated allow adversary may learn information channel assume h dishonest need follow protocol assume adversary also submit high level commands thus data structure protocols need secure chosen known attacks context chosen attack one adversary complete control data operations data structure known attack one attacker assumed know operations data assume computationally bounded adversary limited number operations submitted data structure amount information may stored number operations required process data andor fill storage data assume adversary may try replay data instances data structures replays may due multiple concurrent runs protocol lead vulnerability assume adversary may try compose new messages using message fragments sessions issues beyond scope paper paper address recover corrupt lost data thus attempt replicate data structures operations sharing data structures multiple secure processors also beyond scope paper 21 related work work follows memory protection investigations 4 5 considered problem verifying correctness large memory size n bits maintained allpowerful adversary p subject update requests originator v limited amount trusted memory schemes based merkle signature trees 12 described detail section 5 shown p fool v incorrect memory whenever v access less logn bits trusted memory also describe implementations stacks queues 5 stack implementation uses logh memory accesses operations stack height h approach also relates differs work lamport 10 onetime password scheme precomputes chain hashes secret w sequence w w password fo th idenfication session 1 defined w lamports scheme chain decreases useage also use chain digests signatures andor hashes protocols however scheme computes chain differently addition chain grows shrinks based change state data structure approach expect p constant factor faster v use constant number bits trusted memory irrespective size stack queue also perform constant number untrusted memory operations stack push pop assume signature scheme collisioncomputation resistant 2 nd preimage resistant goldreich 8 ostrovsky 14 give solutions oblivious machines machine oblivious sequence accesses memory locations equivalent two programs running time work solves different problem yet relies techniques protecting integrity memory eg ostrovsky uses sequence numbers protecting rams address methods protecting integrity stacks queues 3 stacks begin defining stack follows interface 7 invariants propose implement using secure processor trusted insecure processor h hostile using following algorithm actions taken shown prefixed others italics r 0 random numbers generated oex signature datum x trusted processor basic protocol ie one trusted host represent cryptographic hash function ei ther keyed unkeyed public key based digital signature assume oex collisioncomputation resistant 2 nd preimage resistant assume probability signature collision made arbitrarily small changing parameters signature scheme also assume good source random numbers functionality starting become available hardware devices oex keyed separate key generated instance key destroyed upon delete key never leaves assume authenticated channel message stream integrity h also entries stack simple strings arrows indicate direction transmission use represent new value oe data structure operation requests h shown double quotes eg push followed relevant operands new selects random r init 2r f0 1g l initialize stack generates new random signs sends h new stack command henceforth signature oer init used identify stack pushx h stores two top stack push request sent h along current stack signature new value stack signature updated signing string formed appending pushed value current signature signature always retained refer oe top pops top stack oer init error stack underflow error computes oex jj oe top compare stored oe bottom top hostile platform maintains stack r init trusted host figure 1 resourcelimited secure implementation stacks oer init comparisons fail terminate error upon pop h returns value ostensibly top stack x signature stack oe top value pushed stored current stack signature recomputed checked shown verifies empty stack claim recomputing using local copy r init comparing returned copy oe delete command resets stack protocol associated signatures held discarded stack protocol illustrated figure 1 arrows show inputs computed signature always signature stack maintained device prior executing push signature oe stack device item x needs pushed ith member stack computes new signature oe i1 shown figure new item x old signature oe given h stack implementation request execute push normally push takes one argument since using fixed length signature two arguments new item old signature represented single bit string inclusion signature adds constant amount external storage transmission overhead operation new signature oe i1 retained devices memory defense tampering h thus pop command issued h expected return top item x signature rest stack oe original signature oe i1 recomputed checked value stored infeasible h spoof forging values x oe long retains oe i1 thus stack invariants preserved argued detail following section 31 evaluation argue stack integrity checking protocols work provided signature schemes use collision resistant 2 nd preimage resistant stack one works correctly according standard specification stack specifications stack found page 2 9 page 170 nonideal stacks show flaws pop executed returns value top ideal stack define incorrect stack one series returns value different one would top ideal stack operations definition 3 protocol checking stack implementations secure incorrect stack always detected whenever returns wrong value pop present main claim correctness stack protocol theorem 1 stack protocol secure long signature scheme based collision resistant 2 nd preimage resistant prove theorem first define notion correct digest stack next argue protocols ensure series operations omega correct digest ideal stack argue correct digest ideal stack incorrect stack operation h detected definition 4 correct digest stack initializing value 0 items defined follows ready state main claim digest maintained protocol series protocol always maintains correct digest ideal stack providing operates correctly according protocol b underlying signature scheme collision resistant 2 nd preimage resistant shown induction assuming works according stack protocol given correctness digest initial state trivial suppose correct digest oe igamma1 ideal stack first operations two significant cases may push pop push pushx compute signature thus correct definition see description push protocol 1 inductive assumption pop upon pop h expected return two values item top stack x signature rest stack oe r checks following holds since assume collision resistant 2 nd preimage resistant signature scheme would infeasible h find values x oe r satisfy constraint x oe r indeed values used compute oe originally means oe correctly digests ideal stack oe r pop executed operation may also delete new either case effect either create new inde pendent correctly initialized digest new stack andor terminate current stack instance even elements final claim shown claim established theorem proven always stores correct digest ideal stack every sequence incorrect stack operation always detected provided underlying signature scheme collision resistant 2 nd preimage resistant without loss generality assume execute pop assume correctly digests ideal stack operationsomega oe n operation n computed x item currently top stack collision resistance signature scheme h cannot feasibly substitute another x oe r therefore incorrect stack operation detected via bad signature 4 queues queues implemented keeping two items trusted memory signature entire queue including items used rear queue signature items removed queue begin brief description interface queue queue ht interface axiomatization provided found standard texts formal specification guttag horning 9 case stacks assume messages h sent authenticated channel message stream integrity bitstring entries queue simplicity new signing key queue instance newq selects random r init 2r fo 1g l case stack generates new random signs sends h identifier initialize new queue nqq x rear q1 front q hostile platform maintains queue r init trusted host removed elements r m1 r init figure 2 resourcelimited secure implementation queues enqueue computes new signature signing string formed appending new item current signature entire queue signature sent h along current item signature also updates current queue signature enqueue operation computes checks nb h says queue empty ensure oe h gets dequeue request returns item ostensibly front queue signature oe front appends returned item stored oe r signs result compares signature oe front signatures match approves oper ation updates oe r oe front queue protocol illustrated figure 2 retains two signatures oe q digest entire queue oe r digest items removed enqueue request updates oe q include item queue digest h asked store item current digest assume oex represents keyed cryptographic hash public key signature upon dequeue request h asked return item front queue x associated signed digest oe front uses oe r item value stored trusted memory authenticate dequeued value signature represents items ever removed queue compares new oe 0 r value result signing string obtained appending item x claimed front queue old signature oe r following section examines correctness protocol closely 41 evaluation argue queue protocol detects incorrect operation queues h definition 5 ideal queue one works according usual lifo discipline incorrect queues ones series operations dequeue return item one would head ideal queue set operations definition 6 define incorrect queue one series returns value different one would head ideal queue operations definition 7 protocol checking queue implementations secure incorrect queue always detected whenever returns wrong value dequeue main claim correctness queue protocol theorem 2 queue protocol secure long signature scheme based collision resistant 2 nd preimage resistant use notion correct digest well however case queue two pieces digest oe q represents entire histor ical queue including items ever en queued oe r represents items dequeued see figure 2 definition 8 correct digest queue initializing value currently queue q 1 item next de queued items r removed r 1 first item removed r item recently removed consists two signatures oe q oe r computed follows series protocol always maintains correct digest ideal queue providing operates correctly according protocol b underlying signature scheme collision resistant 2 nd preimage resistant show induction initialization claim holds trivially consider queue operation enqueue enqueuex request oe r unchanged protocol 2 specified definition 8 oe q computed follows specified definition 8 dequeue dequeuex request oe q unchanged protocol 2 specified definition 8 oe r updated described protocol 2 h returns signature oe 0 r item x following equality checked equality holds assuming signature scheme used desired prop erties setting oe r oe 0 r correctly update oe r note h compute oe 0 r since signing key secret assume collision resistant 2 nd preimage resistant signature schemes value given h time x enqueued h returns value checks correctness digest preserved note way signatures used different stack protocol stack protocol h returns item old signature ie inputs signature algorithm signed yield value identical digest held case queues h return item output signature item oe r digest signed together match output signature returned h operations delete new create new independent correctly initialized digest new queue andor terminate current stack instance following claim established theorem proven 4 always stores correct digest ideal queue every sequence operations incorrect queue always detected provided underlying signature scheme collision resistant 2 nd preimage resistant assume execute dequeue assume correctly digests ideal queue operationsomega oe q oe r dequeue h returns item x new signature r verified x item currently head queue collision resistance signature scheme cryptographic assumption h unable compute signature h cannot feasibly substitute another x oe 0 r therefore incorrect queue operation detected via bad signature 5 schemes ram trees several schemes proposed literature handle random access memory ram 5 schemes based merkle signature trees 12 describe signature tree discuss tradeoffs implementing secure stacks queues using 51 prior work rams given nbit address space one construct secure ram binary tree 2 n leaves 2 n interior nodes using 2 n1 data elements insecure memory array stands insecure bit address selects branch binary tree figure 3 shows tiny ram 4 bit address space node ram unambiguously designated bit substring address leaves store values ram given com plete nbit address string buggy ram actual value memory cell address tampering values adversary deterred high probability storing signatures interior nodes signatures computed follows given interior node address j j n note treat bit string different index insecure memory array thus 0011 11 accomplished simple transformation bit string integer array index root value 0 kept address accessed n values interior nodes1001000 figure 3 ram address shown 1010 along address path well n additional values need compute signatures interior nodes well root value also accessed address modified signature values interior nodes along address path recomputed 52 stacks queues ram since rams general type memory question naturally arises simply implement secure stacks queues using secure ram answer question given specific situations depends set engineering design issues main consideration using ram number signature computations time particular leaf value addressed binary tree represen tation n signature computations required could avoided partitioning ram large pages reducing effective number signature computations another approach retain certain number pages swap pages h needed would amount secure virtual memory several complications implementing secure paging systems based ram schemes described limited program text space device eg smart card may preclude implementation secure virtual memory limitations data memory limit amount trusted pages kept within bandwidth limitations force high penalties page faults decreasing page size much increase number signature computations page fault n bit address space signature computations page fault signatures checked outdated dirty page read recomputed upon write another page swapped another set signatures checked application primarily uses stacks queues mentioned complications dominate stack queue schemes useful ever highquality implementation virtual secure memory available would reasonable use however authors aware implementations devices currently market unlike secure virtual memory schemes must carefully implemented tuned schemes relatively simple built application programmer 6 applications problem checking large data structures limited memorywas motivated new applications software tools 7 6 goal work place trusted software tools static analyzers type check ers proof checkers compilersinstrumenters etc trusted hardware output tools would attested signature publickey crypto system one particular application concerns java tm bytecode verification 11 process similar typechecking carried java tm virtual machine jvm programs jvm stackoriented machine typechecking process ensures every control flow path leading given point jvm program types stack entries com patible eg object type netsocket never conflated object type circle properties bytecode verification ensures key typesafety property core security policies jvm currently process carried browsers netscape tm prior execution mobile java tm code applets perfor mance security configuration management intellectual property protection advantages claimed bytecode verification similar static analysis processes conducted trusted machine result analysis attested pubickey based cryptographic signature mobile code bytecode verification algorithm 11 involves inter alia maintaining agenda control flow paths expanded b computing state evaluation stack c looking typing rules various types instructions maintaining symbol tables variables resourceintensive data usage taxes resources powerful expen devices another application discussed 6 placing proof checker device necula 13 suggests mobile code carry proof applicable safety property unfortunately proofs reveal great deal data structure layouts loop invariants algorithms vendors may balk revealing intimate details prod ucts proof checker device vendor check proof site bare binary sans proof signed device attest correctness proof remain secret yet another application creation trusted signed analysis products control dependency graphs data dependency graphs slices etc accompany mobile code trusted analysis products used security environments optimally sand box 15 mobile code techniques ones suggest form useful implementation technique placing trusted software analysis tools trusted hardware trusted hardware devices expected become powerful inherent physical design constraints form factor energy usage heat dissipation likely prevent performance gap conventional machines narrowing implementation techniques remain applicable 7 extensions future work techniques discussed simply insure integrity stacks queues discuss extensions future work address related issues confidentiality key expiration data structure sharing providing confidentiality confidentiality may concern applications stacks queues protocol designs allow layering integrating confidentiality mechanism top basic protocols updating keys since assume computationally bounded adversary cryptographic keys used protect integrity data structure limited lifetime relying keys beyond lifetime could compromise integrity instance data structure discuss manage keys instances data structures one general approach replacing keys obvious complete rewrite temporarily suspend normal usage data structure remove elements one instance data structure add new instance new key issues arise approach may possible go directly one stack another since order elements would reverse however problem corrected repeating process another stack alternatively operation performed single pass using queue second general approach updating keys gradual transition one key another eliminate need data structure unavailable key updates multiple signatures using different keys maintained entire structure updated new key sharing data structures multiple entities may wish share operations data structure issues involved sharing data structure concern sharing recent signatures keys associated structure schemes may built top secure quorum schemes however unclear whether schemes satisfy security performance requirements sharing data structures area topic future research 8 conclusion described protocols resource limited trusted computers store stacks queues untrusted hosts retaining constant amount memory trusted machine tahis approach differs earlier work 4 5 protocols much simpler use o1 memory trusted computer transfer o1 amount data push pop operation online mode previous approaches used ologn trusted memory ologn data transfer operation n size stack queue however unlike previous approaches use information theoretic bounds assume computationally limited ad versaries present arguments show protocols detect attacks return incorrect values 9 acknowledgements work greatly benefited result early discussions dave mcallester ram trees recent discussions philip fong associative ar rays well feedback anonymous reviewers conference r javacard 20 application programming inter faces mondex magazine checking linked data structures checking correctness memories techniques trusted software engineering cryptographic verification test coverage claims towards theory software protection simulation oblivious rams larch languages tools formal specification password identification insecure communications java tm virtual machine specification certified digital signature efficient computations oblivious rams efficient softwarebased fault isolation secure coprocessors electronic commerce applications tr towards theory software protection simulation oblivious rams efficient computation oblivious rams certified digital signature languages tools formal specification efficient softwarebased fault isolation access control signatures via quorum secret sharing proofcarrying code cryptographic verification test coverage claims techniques trusted software engineering password authentication insecure communication java virtual machine specification
industrial strength theorem prover logic based common lisp abstractacl2 reimplemented extended version boyer moores nqthm kaufmanns pcnqthm intended large scale verification projects paper deals primarily scaled nqthms logic industrial strength programming languagenamely large applicative subset common lispwhile preserving use total functions within logic makes possible run formal models efficiently keeping logic simple enumerate many important features acl2 briefly summarize two industrial applications model motorola cap digital signal processing chip proof correctness kernel floating point division algorithm amd5k86 microprocessor advanced micro devices inc b introduction formal verification use mathematical techniques verify properties system description work reported performed authors employed computational logic inc matt kaufmann motorola lakewood po box 6000 md f52 austin z j moore department computer sciences university texas austin austin received oct 25 1996 revised mar 31 1997 recommended acceptance c heitmeyer sr faulk information obtaining reprints article please send email transsecomputerorg reference ieeecs log number 1048920 particular style formal verification shown considerable promise recent years use generalpurpose automated reasoning systems model systems prove properties every reasoning system requires considerable assistance user makes important system provide convenient ways user interact one stateoftheart generalpurpose automated reasoning system acl2 computational logic applicative common lisp number automated reasoning systems exist discuss subsection 11 paper describe acl2s offerings user convenient industrialstrength use begin section 2 history acl2 project next section 3 describes logic supported acl2 designed convenient specification verification section 4 discusses guards connect acl2 efficient execution common lisp provide powerful specification capability illustration role guards section 5 section 6 discuss important features acl2 section 7 present two industrial applications conclude section 8 11 brief comparison theorem provers mentioned many automated reasoning systems besides acl2 ancestors although beyond scope paper survey field provide descriptions systems say words order provide context work active research continues automated reasoning number areas incomplete list case give one two representative systems certainly areas contain considerable overlap ffl provers providing strong support specification computing systems see ffl ctl model checkers 29 11 ffl geometry provers 13 ffl firstorder provers 28 ffl classical mathematics 21 41 constructive mathematics 15 16 ffl provers symbolic computation engines 14 ffl metatheoretic systems 34 provers first category distinguished convenience offer specifying computing systems cases could made prover first category capabilities categories conversely provers categories could placed one first category may subdivided follows ffl higherorder tacticbased provers eg hol 20 ffl higherorder heavilyautomated provers eg pvs 18 ffl firstorder heavilyautomated provers eg acl2 nqthm ffl provers integrated program verification systems eg nevereves 17 space permit detailed comparisons bill youngs paper 42 special issue compares pvs acl2 particular example acl2s ancestral sys tem nqthm compared nuprl 3 extremely difficult compare two generalpurpose theorem provers least part experienced users dramatically affect system behavior proper formulation problems said systems cited support logics powerful acl2 hand acl2s theorem prover encourages reliance user systems automatic aspects users happy essentially quantifierfree firstorder logic believe acl2 offers overall convenience type reasoning required model prove properties digital computing systems addition sophisticated inference engine provides acl2 provides extremely efficient evaluation allowing formal models often serve simulators systems described turn provides immediate proofindependent payoff eg requirements testing code development additional reasons acl2s convenience broadly lumped proof engineering considerations discussed section 6 see url httpwwwformalstanfordeducltars arsdbhtml data base automated reasoning systems including brief descriptions links home pages systems mentioned many 2 history acl2 direct descendant boyermoore sys tem nqthm 8 9 interactive enhancement pc nqthm 23 see 7 introduction two ancestral systems including reasonably large set references accomplishments using systems particular successes described 4 5 10 22 32 26 36 38 tutorial introduction systems may found 24 like nqthm acl2 supports lisplike firstorder quantifierfree mathematical logic based recursively defined total functions experience earlier systems supports claim logic sufficiently expressive permit one address deep mathematical problems realistic verification projects fact nqthm logic executable also important asset using model hardware software systems models executed means corroborating accuracy consider example 2 nqthm model mc68020 corroborated fabricated chip running 30000 test vectors nqthm model largest formal verification projects done far carried nqthm cite explicitly cli short stack 4 design fabrication fm9001 microprocessor 22 verification berkeley c string library top mc68020 microprocessor 10 formal models projects collectively several hundred pages long involve many functions despite successes nqthm designed kinds largescale projects several inadequacies important inadequacy nqthm lack theorem proving power would quickly settle every question put one could proceed efficiently always looking better proof techniques eg 33 know build significantly powerful automatic theorem prover nqthms logic 2 therefore scale nqthm focused engineering issues decided good first step would adopt logic applicative subset commonly used programming language thereby gaining access many efficient execution platforms models written logic many program development ie modeling environments chose common lisp expressiveness efficiency familiarity properly formulated common lisp execute speeds comparable c three guiding tenets acl2 project 1 conform compliant common lisp implementations 2 add nothing logic violates understanding users input submitted directly common lisp compiler executed environment suitable acl2specific macros functions acl2 kernel defined 3 use acl2 implementation language acl2 system third tenet akin recoding nqthm nqthm logic task believe would produce unacceptably slow performance programming acl2 system acl2 emphasize word significantly acl2s theorem prover fact powerful nqthm many ways see section 6 repeatedly forced us extend subset could acceptably efficient code several iterations system built current system consists 5 megabytes applicative source code including documentation first version system written summer fall 1989 boyer moore time went boyers involvement decreased kaufmanns increased eventually boyer decided longer considered coauthor acl2 used modeling verification projects within computational logic inc cli several years released first public version acl2 september 1995 see url httpwwwclicom 3 acl2 logic definition common lisp used work 39 40 also closely studied 35 acl2 logic firstorder quantifierfree logic total recursive functions providing mathematical induction ordinals ffl 0 two extension principles one recursive definition one encapsulation sketch logic 31 syntax syntax acl2 common lisp formally acl2 term either variable symbol quoted constant application nary function symbol lambda expression f n terms written f 1 n illustrate syntax primitive constants formal syntax extended facility defining constant symbols macros 32 rules inference rules inference nqthm namely propositional calculus equality together instantiation mathematical induction ffl 0 two extension prin ciples recursive definition encapsulation also pro vided discussed subsection 36 33 axioms primitive data types following primitive data types axiomatized ffl acl2 numbers numbers consist rationals complex numbers rational components examples numeric constants 5 227 ffl character objects acl2 supports 256 distinct characters including common lisps standard char acters character constants newline space ffl strings acl2 supports strings characters eg string constant arithmetic overflow ffl symbols common lisp provides sophisticated class objects called symbol constants logically speaking symbol constant object containing two strings package name constant package mc68020 name exec written mc68020execby con vention one package always selected cur rent name need written thus mc68020 current package symbol may simply written exec packages may import symbols packages al though acl2 importation must done time package defined mc68020exec imported stringlib package stringlibexec fact symbol mc68020exec ffl lists acl2 supports arbitrary ordered pairs acl2 objects eg list constant x mc68020x hello 1 227 34 axioms defining primitive function symbols essentially common lisp functions data types axiomatized defined functions macros acl2 common lisp functions mean programs specified 39 40 applicative ii dependent state implicit parameters data types acl2 iii completely specified unambiguously hostindependent manner approximately 170 functions axiomatized common lisp functions partial defined possible inputs acl2 functions total roughly speaking logical function given name acl2 completion common lisp function name obtained adding arbitrary natural values arguments outside intended domain common lisp function acl2 requires every acl2 function symbol guard may thought predicate formals function describing intended domain guards entirely extralogical involved axioms defining functions discuss role guards explain relation acl2 common lisp 35 axioms additions common lisp applicative common lisp add four important new features introducing new function symbols appropriate axioms ffl add new multiplevalued function call return primitives syntactically restrictive similar common lisp primitives multiplevaluebind values primitivesrequire functionalways return number values called contexts ex pecting appropriate number values restrictions allow multiplevalued functions implemented efficiently common lisps least case gnu common lisp logically speaking vector multiple values returned function list values implementation efficient list actually constructed ffl add explicit notion state allow acl2 programmer accept input cause output putoutput functions common lisp acl2 applicative dependent implicit notion current state acl2 state ntuple containing among things file system open inputoutput channels files primitive inputoutput functions axiomatized take state explicit parameter return new state explicit result usually one several results syntactic checks language ensure state singlethreaded ie function takes state argument calls function returns new state new state precisely final descendant must returned gives rise welldefined notion current state supplied toplevel calls statedependent acl2 functions state returned calls becomes definition next current state restrictions execution statedependent function need actually construct new state ntuples literally modifies underlying common lisp state ffl add fast applicative arrays imple mented behind scenes common lisp arrays manner always returns values accordance axioms operates efficiently provided certain programming disciplines followed namely used singlethreaded way recently updated version array used syntactic enforcement discipline failure follow simply leads inefficient cor rect execution warning messages ffl add fast applicative property lists manner similar arrays 36 extension principles finally acl2 two extension principles definition encapsulation preserve consistency extended logic 25 indeed standard model numbers lists always extended include newly introduced function symbols inconsistency thus caused user adds new axiom directly rather via extension principle encapsulation principle allows user introduce new function symbols constrained axioms certain properties consistency ensured requiring user exhibit witness functions satisfying constraints set function symbols constrained witnesses used establish consistency irrelevant axioms new functions stating constraints theorems proved constrained functions theorems instantiated higherorder way derive analogous results functions satisfying constraints made possible derived rule inference called functional instantiation 6 name encapsulation stems way principle implemented encapsulation command essentially wrapper around admissible sequence definitions theorems wrapper allows one mark certain definitions theorems local local definitions theorems exported wrapper nonlocal ones exported within local context established encapsulation constrained functions locally defined witnesses constraints nonlocal theorems functions outside encapsulation function symbols undefined theorems appear consistent axioms implementation makes encapsulation useful even new function symbols introduced allows large proofs structured see section 6 definitional principle ensures consistency requiring proof defined function terminates done nqthm identification ordinal measure formals decreases recursion 8 show nqthm ensures one one settheoretic function satisfies recursive definition proof carries acl2 case appropriate treatment nonuniqueness constrained functions used definition form acl2 function definition common defun f acl2 extends common lisps declare permit specification guard expression g x 1 x n well permit optional specification ordinal measure hints additional syntactic restrictions put body ensure common lisp version f execute efficiently accordance claims make roughly speaking enforce syntactic notion current state single threaded restricting use variable named state ensure multiple values used appropriately syntactic restrictions met required termination theorems proved axiom f x1 added new axiom observe axiom added independent guard 4 relation acl2 common guards role logic however crucial relation logic common lisp implicit guards common lisp allow great effi ciency implementations common lisp example gnu common lisp performance compiled code generated arithmetic list processing functions comparable handcoded c arithmetic pointer manipulation exceptional execution efficiency wide variety platforms combined clear applicative semantics used properly one great attractions basing acl2 logic common lisp consider example primitive function car page 411 40 says argument car must cons nil page 6 learn places stated soandso must must may case error stated requirement met page 5 learn error means valid common lisp program cause situation occur situation occurs effects results completely undefined common lisp implementation required detect error thus implementation function car may assume actual cons nil suitable representation data implementation car simply fetch contents memory location actual stored checks necessary course car applied 7 results unpredictable possibly damaging runtime image usually implementation dependent aspects lisp make difficult debug compiled lisp code also raises problems direct embedding applicative common lisp logic situation far worse merely knowing value car 7 know value object logic car 7 might example worse still know car function form equal car 7 car 7 instance axiom equal x x might sometimes evaluate nil common lisps first car 7 might return 0 second might return 1 acl2 solves problem axiomatizing car x total function returns nil outside intended main described guard consp x equal x nil claim axioms describe common lisps car argument car satisfies guard acl2 provides general means verifying situation obtains evaluation given expression containing car reading rest section reader may wish consider possibility approach could carried programming languages 3 although programs commercially available mainstream languages c check certain kinds errors believe utilities match capability making arbitrary semantic checks statically describe acl2 perhaps analogous approach c would present opportunity integration formal verification mainstream software development practice lessening need dynamic errorchecking 41 gold function symbols terms make precise relation acl2 common lisp define two interrelated notions function gold term gold hypothesis hypothesis given implicitly true hypothesis roughly speaking function symbol gold guard true guards subroutines encountered evaluation true arguments ffl acl2 logic primitive function symbols gold ffl defined function f guard g body b gold every function symbol mentioned g gold term g gold every function symbol besides f mentioned b gold term b gold g ffl variables quoted constants gold terms ffl term b c gold h gold h b gold h c gold h ffl term f 1 f guard v formals f gold h provided gold 3 thank one referees posing question h implies h g 1 theorem formula must proved called guard conjecture subterm question sometimes say function term common lisp compliant synonym saying gold call process checking whether function symbol term gold guard checking guard verification 42 story relating logic common lisp claim function symbol acl2 gold gold theorem proved every execution function compliant common lisp produces answers consistent theorem provided arguments function satisfy guard resource errors eg stack overflow occur less precisely gold acl2 theorems describe behavior common lisp claim made precise follows present claim restrictive setting simplicity suppose f function symbol one argument defined certified book eg file admissible acl2 definitions theorems guard f f gold equal f x necessarily gold theorem acl2 proved book consider common lisp compliant 40 acl2 kernel loaded load book lisp let x common lisp object also object acl2 application lisp f x returns else causes resource error eg stack overflow memory exhaustion essence proof claim observe f x evaluates logic soundness logic computation step exercise function symbol outside guarded domain f gold since logic common lisp agree inside guarded domain common lisp computation f x returns also less restrictive alternative formulation thm gold theorem certified book acl2 instance thm evaluates nonnil compliant common lisp acl2 kernel book loaded 43 guards efficiency one obvious implication story one formal model proved common lisp compliant one wishes evaluate gold applications model one ignore acl2 theorem prover altogether load model compliant common lisp containing acl2 kernel directly execute model obtain results consistent axioms example one might build gold simulator microprocessor highlevel language provide users via standalone common lisp engine acl2 theorem prover need present less obvious use claim made inside acl2 theorem prover course theorem proving uncommon ground subexpressions arise certain instantiations lemmas case splits enumerated mains base cases inductions etc like nqthm acl2 interpreter evaluating ground expressions acl2 completions common lisp primitives built runtime type checks done interpreter eg determine value axioms car applied constant interpreter determines whether consp either uses lisps car returns default value nil interpreter calls userdefined functions require recursive evaluation typechecking body repeatedly acl2 evaluates call gold function symbol use direct common lisp computation guard evaluates nqthm acl2 interpreter implemented defining compiling auxiliary common lisp functions runtime type checking gold acl2 functions generally compiled acl2 type checking thus interpreter approach gold shortcircuit enjoy benefits compilation efficiency difference acl2s avoidance runtime type checking certain subexpressions make substantial difference industrialsized models summary one important incremental effect proving acl2 function symbol gold subsequent applications function efficiently computed 44 guards specification device guards may also used type specifications gold functions welltyped however guards much expressive conventional types arbitrary terms logic course acl2 type checking decidable reason related work see 1 one attaches restrictive guards ones functions proves functions gold one obtains assurance functions exercised intended domains precisely one gains knowledge computed value provably equal function application weakened logical system equality function application body conditional guard true nqthm provides assurance mechanism 5 example section illustrate points made guards 51 admitting definition consider problem concatenating two lists define function app follows defun app x declare xargs measure x guard truelistp x equal x nil cons car x app cdr x ignore declaration moment observe function terminates x nil otherwise cdrs x recursion intention x always true list ie cons tree whose rightmost branch terminates nil function applied 7 8 common lisp result would unpredictable 76nil recur cdr 7 8 cdr 7 undefined common lisp replacing equal x nil test atom x sensible know x cons cdr lisp programmers tend use test efficient type check 4 equivalent provided x true list declaration guard truelistp x makes clear intended domain logically speaking must admit function reason logically speaking guard irrelevant must show measure arguments decreases recursion matter x used suitable measure x supplied user declaration x defined elsewhere 0 x nil otherwise one greater length rightmost branch x easy show measure decreases recursion ie cdr x x6nil intuitively recursion terminates acl2 cdr completed return nil nonconses recursion hits atom bottom rightmost branch stops atom nil otherwise goes one step cdring atom produce terminating nil function admitted axiom axiom app x equal x nil cons car x app cdr x added note axiom mention guard 4 equality test symbol done single address comparison require memory reference type checks 52 theorems prove surprising theorem theorem surprisingappcall equal app 7 cons nil 8 return surprising example later also prove useful powerful unconditional equality stating app associative theorem associativityofapp equal app app b c app app b c proof takes advantage fact car cdr return nil noncons arguments numbers guard app infected definition app limiting applicability true lists app would unconditionally associative identifying sufficient conditions difficult since appears first argument call app conjecture must true list order use definition app call similarly b must true list app b also first argument call app use definition app call system must able establish either third hypothesis proof hypotheses app b true list short guard function infects definitional axiom theorems inherit complexity compositionally weakened encumbering hypotheses weakened theorems raise problems three ways ffl harder user state accurately ffl often harder prove induction induction hypothesis weakened ffl harder use subsequently one must relieve hypotheses points made 27 decision guards affect definitional axioms thus far reaching effect fact guards play logical role earlier versions acl2 driven return nqthm paradigm total functions complexity guards introduced industrialstrength proof efforts particularly cap project described later 53 compliance returning app example next ask relationship common lisp prove app gold ie common lisp compliant every function used definition except app gold primitive body evaluated every guard encountered true guard app true initially latter condition expanded follows three subroutines body app nontrivial guards car cdr recursive call app definition gold theorem must proved call subroutine body app particular call must prove guard app together tests leading call imply guard call prove app gold therefore suffices observe x nonnil true list x must cons cdr true list extralogical nature guards brought home observation could define another function say xapp analogous app contains guard ie guard two functions provably equiva lent app common lisp compliant xapp guard conjectures cannot proved know app common lisp compliant story tells us call app satisfies guard executes accordance axioms acl2 put another way wish determine value axioms app b b constants simply execute expression common lisp provided true list thus user wishing execute formal model concrete data satisfying guard run model common lisp provided model proved compliant furthermore guards gold terms suitability data determined common lisp evaluation also 54 gold theorems theorems gold function app surprising result equal app 7 cons nil 8 know every compliant common lisp evaluate true theorem gold guard app violated 7 nothing inferred common lisp via claim common lisps may cause severe trouble commanded evaluate app 7 8 associativity result app expect app unconditionally associative common lisp answer theorem gold however following theorem gold 5 theorem goldassociativityofapp implies truelistp equal app app b c app app b c 5 implies thought lazy ie implies p q read p q given proper treatment definition gold course must prove theorem proof trivial given unconditional associativity result must also verify gold ie guard every call satisfied arguments call context call two truelistp hypotheses true guards three calls app first argument variable symbol guards requiring variable question b appropriately truelistp guard conditions trivial given hypotheses finally guard condition app app b c generates interesting guard condition app b true list b 55 separation concerns note acl2s treatment guards separates con cerns theorem proving simplicity nqthm tradition acl2 makes functions total completing primitives arbitrary natural default values functions introduced logic without addressing question whether compliant common lisp properties proved without concerning oneself questions whether guards satisfied often allows properties simply stated allows data base rules less restrictive powerful easily applied nevertheless nongold functions evaluated axioms nqthm efficiency system acl2 functions defined logical properties proved one move question common lisp compliance either gain execution efficiency acl2 setting standalone common lisp gain type assurance efficiency gained incrementally guard verification core subroutines outlying checkers preprocessors postprocessors typically involved big system proved certain functions gold one stop settle corresponding efficiency type assurance one prove key properties proved also gold recall example one carry following sequence steps ffl admit app function ffl prove unconditionally associative ffl prove gold ie common lisp compliant welltyped ffl trivially prove restricted version associativity ffl prove restricted version associativity gold common lisp compliant versions acl2 predating version 18 guards part definitional equations issues often intertwined impossible address separately makes little difference setting simple app associativity makes great deal difference models involving thousands functions properties 6 proof engineering argued acl2 industrial strength main argument improved efficiency nqthm virtue executable common lisp special consideration efficient execution operations involving arrays property lists state also indicated expressive kind typecorrectness gained guard verification yet capability separated logic proper proofs needlessly hindered belowwe consider strengths acl2 besides efficiency programming language robustness general features maintainability proof support 61 robustness notion industrial strength robustness tool put considerable effort making program bulletproof handling user errors graciously appropriate messages interface consistent providing ability submit definitions theorems well ability execute applicative lisp code efficiently 62 usability yet another notion industrial strength tool support features crucial get job done partial list features offered acl2 ffl extensible online documentation may read terminal well text way hypertext emacs info html ffl support undoing back given command well undoing undo ffl notion books allows independent development inclusion libraries definitions theorems books share underlying implementation encapsulation forms within marked local author book reader book sees nonlocal definitions theorems possibly complex environment necessary certify book need exported readers environment books hierarchical may include books locally otherwise reader may include many independently developed books create environment authors books install theory invariants help readers manage environments created multiple books authors books document definitions theorems book books inclusion updates online documentation within consistency checks done books included books carry certificates help community versioncontrol ffl program mode allows definition execution functions without proof burden imposed without risk unsoundness introduced prover know pro gram mode functions ffl realistic collection data types includes strings complex rational numbers support reasoning data eg fully integrated linear arithmetic decision procedure rationals extensive capabilities controlling prover see ffl common lisp macros ease programming specification without cluttering collection functions one needs reason ffl many useful programming primitives including efficient use multiple values arrays property lists file io ffl common lisp packages support distinct name spaces mutually recursive definitions supported 63 maintainability also found applicative style programming amenable maintenance fixing bugs implementing enhancements moreover subset common lisp acl2 supports sufficient code lowest levels system needed implement primitives believe common lisp program applicative perhaps even performs io fact acl2 program nearly 64 proof support nqthm pcnqthm proofs significant theorems acl2 tend require serious effort part user prove appropriate supporting lemmas primarily stored used conditional rewrite rules however acl2 offers many ways user control proof engine ffl nqthm proof commentary english assists users debugging failed proofs ffl pcnqthm interactive loop proof discovery extensible macros access full power theorem prover ffl capability apply hints individual subgoals ffl proof tree displays show evolving structure proof real time also make convenient inspect failed proofs efficient handling propositional logic normally clause generator much efficient nqthms also facility integrates ordered binary decision diagrams rewrit ing ffl functional instantiation facility gives acl2 like nqthm convenience higherorder logic without sacrificing simplicity first order logic ffl breakrewrite facility sophisticated nqthm prover far know allows prooftime debugging rewrite stack ffl theory mechanism makes easy manipulate sets rules especially turning also checking desired invariants sets rules ffl forcing mechanism gives prover permission defer checking hypotheses specified rules end main proof ffl support variety types rules 17 including types supported nqthm include conditional rewrite rules may used replace equals equals may also work respect userdefined equivalence relations linear arithmetic rules together mechanism create rules certain simple orders standard lessthan order rationals compound recognizer forward chaining type prescription equivalence congru ence builtin clause rules efficient automatic use certain facts improved meta lemma facility allows lemmas conditional ie hypotheses rules use outside simplifierrewriter elimination generalization thus claim acl2 industrial strength efficiency consistent robust interface array general features ease maintenance flexibility theorem prover 7 industrial applications course ultimately test whether tool indus trial strength must whether used jobs interest industry first two important applications acl2 support claims task ap plications summarized discussed detail 12 31 also detail time manpower resources spent component tasks 71 motorola cap digital signal processor bishop brock cli working collaboration mo torola inc produced executable formal acl2 specification motorola cap 19 digital signal processor designed motorola execute 1024 point complex fft 131 microseconds every welldefined behavior cap modeled including pipeline io interrupts breakpoints traps excluding hard soft reset sequences cap much complex processors recently subjected formal modeling namely fm90001 22 mc68020 10 aamp5 30 principle cap single instruction simultaneously modify well 100 registers brocks acl2 model cap bitaccurate cycleaccurate runs faster motorolas spw model furthermore acl2 used reason cap model acl2 compute symbolic effects complicated instruction seconds acl2 brock proved suitable conditions model cap equivalent simpler pipelinefree model perhaps important aspect cap work acl2 possible prove correctness programs complexity instruction set mechanical analysis cap microcode programs perhaps way assure programs certain properties brock used acl2 verify microcode produced motorolas assembler several application programs including fir filter peak finding algorithm uses adder array chain comparators work discussed 12 following approach used nqthm mc68020 10 brock configured acl2 make easy symbolically execute cap microcode program data specified mechanically proved total correctness microcode programs consid ered possible often less labor intensive use cap model acl2 prove weaker properties mi crocode errors occur believe microcode engine cap specified acl2 application programs mechanically verified subsequent microcode applications done rou tinely routinely mean technical details symbolic execution particular microcode managed acl2 effort verification task dominated consideration specification behavior given program another important aspect acl2 cap model executes cap programs faster motorolas spw model makes convenient debugging tool two reasons speed one coded somewhat higher level spw model ie arithmetic model arithmetic common lisp simulated combinational logic brock used strict guards ensure model type correct registers contain data appropriate size addresses legal objects used cap machine states appropriate form etc functions cap model proved gold thus acl2 cap model compiled faithfully executed directly common lisp 72 amd5k 86 floatingpoint division another test industrial applicability acl2 collaborated tom lynch advanced micro devices inc formalize mechanically prove correctness microcode kernel floating point divisionop eration used amd5k 86 microprocessor amds first pentiumclass processor particular 31 prove p double extended precision floatingpoint numbers 6 0 mode rounding mode specifying rounding style target format precision n 64 result algorithm pd rounded according mode explained detail 31 algorithm uses table obtain 8bit approximation reciprocal two iterations efficiently computed variation newtonraphson iteration used refine approximation relative error less 2 gamma28 approximation used compute four floatingpoint numbers whose sum sufficiently close pd rounded according mode result rounding pd instead algorithm implemented microcode computations use floating point operations directed rounding prove algorithm works specified developed acl2 much floatingpoint folk lore also formalized algorithm acl2 used acl2 check fairly deep mathematical proof necessary step proof show every intermediate result fits floatingpoint resources allocated amd industrial strength aspects acl2 used proof fact acl2 executable impor tant proof two applications newtonraphson iteration produce sufficiently accurate answer generalizes away particular table used amd define predicate recognizes table contains sufficiently accurate 8bit approximations prove newtonraphson steps start table correct answer produced predicate executable given concrete table common lisp determine evaluation whether satisfies predicate thus apply result actual amd table acl2 merely executes predicate amd table aspects acl2 crucial proof encapsulation macros books using encapsulation macros able conveniently configure acl2 temporarily derive key steps proof without impose proof strategy key step using books able partition responsibility various parts proof among collaborators assemble final results subsequent proof floatingpoint division microcode david russinoff used acl2 prove correctness amd5k 86 floatingpoint square root microcode 37 8 conclusion acl2 reimplemented extended version boyer moores nqthm kaufmanns pcnqthm intended large scale verification projects acl2 logic extension large applicative subset common lispsup porting practical collection data types single threaded states io multiplevalued functions arrays property lists careful design notion guards acl2 allows elegant expression proof theorems logic without many encumbrances typelike hy potheses time allowing functions logic related common lisp way allows extremely efficient computation furthermore design allows clear separation problems admission logical definitions proofs simply stated properties typecorrectness common lisp compliance efficient execution design allows incremental achievement goals via proof allowing user focus effort important aspects project acl2 provides widevariety features supportiveof industrial strength goals including rugged extensively documented implementation many convenient features constructing models developing structuring proofs good maintainability finally demonstrated acl2 used tackle problems importance industry acknowledgments especially initial stages acl2 development quite possible acl2 would never created also especially grateful bishop brock providing valuable feedback based heavy use acl2 many months bill young improved contributed tutorial material documentation art flatau noah friedman laura lawless contributed technical aspects documentation provided useful feedback also acknowledge contributions bill bevier alessandro cimatti rich cohen john cowles warren hunt jun sawada bill schel ter mike smith finally grateful utility provided gnu emacs particular richard stallman provided texinfo patch assist building documen tation also thank anonymous referees paper provided many valuable suggestions paper extended version paper acl2 industrial strength version nqthm appeared proceedings eleventh annual conference computer assurance compass96 ieee computer society press pp 2334 june 1996 work reported supported part computational logic inc advanced research projects agency arpa order d245 contract n66001 95c8634 arpa order 7406 office naval search contract n0001494c0193 views conclusions contained document authors interpreted representing official policies either expressed implied computational logic inc united states government r strong static type checking functional common lisp model validation testing boyermoore prover nuprl experimental comparison special issue system verification machine checked proofs design faulttolerant circuit functional instantiation first order logic boyermoore theorem prover interactive enhancement computationallogic computational logic handbook automated correctness proofs machine code programs commercial microprocessor acl2 theorems commercial microprocessors mechanical geometry theorem prov ing theorem prover mathematica implementing mathematics nuprl proof development system coq proof assistant eves overview architecture complex arithmetic processor com municationsignal processing introduction hol theorem proving environment higherorder logic imps interactive mathematical proof system users manual interactive enhancement boyermoore theorem prover interaction boyermoore theorem prover tutorial study using arithmeticgeometric mean theorem ramsey theorem boyermoore logic types harmless otter 30 reference manual guide symbolic model checking formal verification aamp5 microprocessor case study industrial use formal methods mechanically checked proof correctness kernel amd5k86 floating point division algorithm formal model asynchronouscom munication use mechanically verifying biphase mark protocol introductionto obdd algorithm atp community isabelle generic theorem prover draft proposed american national standard information systems programming language common lisp mechanical proof quadratic reciprocity mechanically checked proof correctness amd5k 86 floatingpoint square root microcode comparing verification systems interactive consistency acl2 tr ctr michael lowry daniel dvorak analytic verification flight software ieee intelligent systems v13 n5 p4549 september 1998 george avrunin stephen f siegel andrew r siegel finitestate verification high performance computing proceedings second international workshop software engineering high performance computing system applications may 1515 2005 st louis missouri sean w smith vernon austel trusting trusted hardware towards formal model programmable secure coprocessors proceedings 3rd conference usenix workshop electronic commerce p88 august 31september 03 1998 boston massachusetts josiah dykstra software verification validation destiny parallel approach automated theorem proving crossroads v8 n3 p2327 spring 2002 zaher andraus karem sakallah automatic abstraction verification verilog models proceedings 41st annual conference design automation june 0711 2004 san diego ca usa j strother moore mechanically checked proof multiprocessor result via uniprocessor view formal methods system design v14 n2 p213228 march 1999 young comparing verification systems interactive consistency acl2 ieee transactions software engineering v23 n4 p214223 april 1997 stephen mccamant greg morrisett evaluating sfi cisc architecture proceedings 15th conference usenix security symposium p1515 july 31august ruben gamboa correctness fast fourier transform structured proof acl2 formal methods system design v20 n1 p91106 january 2002 matt kaufmann j strother moore structured theory development mechanized logic journal automated reasoning v26 n2 p161203 february 2001 zaher andraus mark h liffiton karem sakallah refinement strategies verification methods based datapath abstraction proceedings 2006 conference asia south pacific design automation january 2427 2006 yokohama japan j strother moore towards mechanically checked theory computation acl2 project logicbased artificial intelligence kluwer academic publishers norwell 2000 matthew wilding david greve david hardin efficient simulation formal processor models formal methods system design v18 n3 p233248 may 2001 alessandro armando silvio ranise constraint contextual rewriting journal symbolic computation v36 n12 p193216 july paolo bientinesi john gunnels margaret e myers enrique quintanaort robert van de geijn science deriving dense linear algebra algorithms acm transactions mathematical software toms v31 n1 p126 march 2005 andrew ireland alan bundy automatic verification functions accumulating parameters journal functional programming v9 n2 p225245 march 1999 jeremy w nimmer michael ernst automatic generation program specifications acm sigsoft software engineering notes v27 n4 july 2002 j strother moore thomas w lynch matt kaufmann mechanically checked proof amd5k86tm floatingpoint division program ieee transactions computers v47 n9 p913926 september 1998 ramesh bharadwaj constance l heitmeyer model checking complete requirements specifications using abstraction automated software engineering v6 n1 p3768 january 1999 jack minker introduction logicbased artificial intelligence logicbased artificial intelligence kluwer academic publishers norwell 2000
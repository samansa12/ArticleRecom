new faster filters multiple approximate string matching present three new algorithms online multiple string matching allowing errors extensions previous algorithms search single pattern average running time achieved cases linear text size moderate error level pattern length number patterns adapt higher costs cases however algorithms differ speed thresholds usefulness theoretically analyze algorithm used show performance experimentally previous solution problem allows one error algorithms first allow errors faster previous work moderate number patterns eg less 50100 english text depending pattern length b introduction approximate string matching one main problems classical string algorithms applications text searching computational biology pattern recognition etc given text 1n length n pattern p 1m length sequences alphabet sigma size oe maximal number errors allowed want find text positions pattern matches text k errors errors substituting deleting inserting character use term error level refer paper interested online problem ie text known advance classical solution single pattern based dynamic programming running time omn 26 recent years several algorithms improved classical one 22 improve worst average case using properties dynamic programming matrix 30 11 16 31 9 others filter text quickly eliminate uninteresting parts 29 28 10 14 24 sublinear average moderate ff ie inspect text characters yet approaches use bitparallelism 3 computer word w bits reduce number operations 33 35 34 6 19 problem approximately searching set r patterns ie occurrences anyone considered recently problem many applications instance work supported part fondecyt grant 1990627 ffl spelling many incorrect words searched dictionary time order find likely variants moreover may even search dictionary correct words text misspelled words hopefully much less cost ffl information retrieval synonym thesaurus expansion done keyword text errorprone may want search variants allowing errors batched queries system receives number queries process may improve efficiency searching single pass ffl singlepattern queries algorithms single pattern allowing errors eg pattern partitioning 6 reduce problem search many subpatterns allowing less errors benefit multipattern search algorithms trivial solution multipattern search problem perform r searches far know previous attempt improve trivial solution due muth manber 17 use hashing search many patterns one error efficient even one thousand patterns work present three new algorithms extensions previous ones case multiple search section 2 explain basic concepts necessary understand algorithms present three new techniques section 3 present automaton extends bitparallel simulation nondeterministic finite automaton section 4 present exact partitioning extends filter based exact searching pattern pieces 7 6 24 section 5 present counting based counting pattern letters text window 14 section 6 analyze algorithms section 7 compare experimentally finally section 8 give conclusions detailed analyses left appendices b although 17 allows searching many patterns limited one error first algorithms multipattern matching allowing one error moreover even one error improve 17 number patterns large say less 50100 english text depending pattern length multipattern extensions improve sequential counterparts ie one separate search per pattern using base algorithm error level high ff 04 english text filter based exact searching fastest small error levels bitparallel simulation nfa adapts better errors relatively short patterns previous partial preliminary versions work appeared 5 20 21 2 basic concepts review section basic concepts used algorithms follow paper denotes ith character string 1 first character ij stands substring i1 j particular ffl empty string 21 filtering techiques multipattern search algorithms consider work based concept filtering therefore useful define filtering based fact normally easier tell text position match ensure matches therefore filter fast algorithm checks simple necessary though sufficient condition approximate match occur text areas satisfy necessary condition safely discarded expensive algorithm run text areas passed filter since filters much faster approximate searching algorithms filtering algorithms competitive fact dominate large range parameters performance filtering algorithms however sensitive error level ff filters work well low error levels bad errors related amount text filter able discard evaluating filtering algorithms important consider time efficiency also tolerance errors term normally used referring filters sublinearity said filter sublinear inspect characters text like boyermoore 8 algorithms exact searching best onm throughout work make use two following lemmas derive filtering conditions k errors concatenation subpatterns substring matches least one p bkjc errors proof otherwise best match p inside least bkjc errors occurrence p involves occurrence p total number errors occurrences least sum errors pieces summing errors pieces errors therefore complete match possible notice even consider matches p must proper order disjoint deletions may needed connect general one filter search pattern length k errors search j subpatterns length mj kj errors text areas surrounding occurrences pieces must checked complete matches important particular case lemma 1 arises one considers since case pattern piece appears unaltered zero errors lemma 2 32 j edt ij p k j gammam1j includes least gamma k characters p proof suppose opposite observe less characters p ij hence k characters must deleted p match text observe k characters ij p hence must insert k characters p match text contradiction cases note case repeated characters pattern must counted different occurrences example search aaaa one error text last four letters occurrence must include least three simplification 32 says essentially design filter approximate searching based finding enough characters pattern text window without regarding ordering instance pattern survey cannot appear one error text window surger five letters pattern text however filter cannot discard possibility pattern appears text window yevrus 22 bitparallelism bitparallelism technique common use string matching 3 first proposed 2 4 technique consists taking advantage intrinsic parallelism bit operations inside computer word using cleverly fact number operations algorithm performs cut factor w w number bits computer word since current architectures w 32 64 speedup significant practice improves technological progress order relate behavior bitparallel algorithms works normally assumed dictated ram model computation prefer however keep w independent value notation use bitparallel algorithms order denote b b 1 bits mask length stored somewhere inside computer word use clike syntax operations bits computer words eg j bitwiseor moves bits left enters zeros right eg b b also perform arithmetic operations bits addition subtraction operates bits formed number instance b b x explain first bitparallel algorithm since basis much follows work algorithm searches pattern text without errors parallelizing operation nondeterministic finite automaton looks pattern figure 1 illustrates automaton l h figure 1 nondeterministic automaton searches aloha exactly automaton 1 states simulated nondeterministic form omn time shiftor algorithm achieves omnw worstcase time ie optimal speedup notice convert nondeterministic automaton deterministic one search time get improved version kmp algorithm 15 however kmp twice slow algorithm first builds table b character c stores bit mask mask bc bit b zero p c state search kept machine word matches end text read ie state numbered figure 1 active therefore match reported whenever dm zero set ones originally new text character j updated using formula formula correct ith bit zero gamma 1th bit zero previous text character new text character matches pattern position words j possible relate formula movement occurs nondeterministic automaton new text character state gets value previous state happens text character matches corresponding arrow patterns longer computer word ie w algorithm uses dmwe computer words simulation active time algorithm omnw worst case time preprocessing om average algorithm even w since first o1 states automaton active states average hence first o1 computer words need updated average easy extend shiftor handle classes characters extension position pattern matches set characters rather single character classical string matching algorithms easily extended shiftor enough set ith bit bc every c 2 p p set instance search survey caseinsensitive form set first bit bs bs match zero rest shiftor also search multiple patterns complexity omnw consider total length patterns arranging many masks b machine word shiftor later enhanced 34 support larger set extended patterns even regular expressions recently 25 shiftor combined sublinear string matching algorithm obtaining flexibility efficiency competitive best classical algorithms many online text algorithms seen implementations clever automata classically deterministic form bitparallelism since invention became general way simulate simple nondeterministic automata instead converting deterministic advantage much simpler many cases faster since makes better usage registers computer word easier extend handle complex patterns classical counterparts main disadvantage limitations imposes regard size computer word many cases adaptations cope longer patterns efficient 23 bitparallelism approximate pattern matching present application bitparallelism approximate pattern matching especially relevant present work consider nfa searching patt errors shown figure 2 every row denotes number errors seen first one 0 second one 1 every column represents matching pattern given position iteration new text character considered automaton changes states horizontal arrows represent matching character followed corresponding match occurs others represent errors move next row vertical arrows represent inserting character pattern since advance text pattern solid diagonal arrows represent replacing character since advance text pattern dashed diagonal arrows represent deleting character pattern since ffltransitions advance pattern text loop initial state allows considering character potential starting point match automaton accepts character end match whenever rightmost state active initially active states row 2 0k columns 0 represent deletion first characters pattern p 1m errors figure 2 nfa approximate string matching show active states reading text pait interesting application bitparallelism simulate automaton nondeterministic form first approach 34 obtained okdmwen time packing automaton row machine word extending shiftor algorithm account vertical diagonal arrows note even states fit single machine word k sequentially updated ffltransitions happens classical dynamic programming algorithm 26 regarded columnwise simulation nfa paper interested recent simulation technique 6 show packing diagonals automaton instead rows columns new values computed one step fit computer word give brief description idea ffltransitions state diagonal active subsequent states diagonal become active define minimal active row diagonal diagonals numbered looking column start eg 1 2 enclosed dotted lines figure 2 new values read new text character c computed always holds report match whenever dmgammak k formula accounts replacements insertions matches respectively deletions accounted keeping minimum active row interesting matches caught considering diagonals 1 mgammak use bitparallelism represent unary one hold k plus overflow bit stored sequentially inside bit mask interestingly effect read diagonals bottomup exchange 0 1 bit representing state nfa update formula seen either arithmetic implementation previous formula unary logical simulation flow bits across arrows nfa shiftor table bits long masks b built representing match mismatch pattern table bc built mapping bits b appropriate positions inside figure 3 shows states represented inside masks b separator separator final state p figure 3 bitparallel representation nfa figure 2 representation requires k2 bits per diagonal total number bits gamma kk2 number bits exceed computer word size w update done o1 operations resulting algorithm linear fast practice purposes important realize connection pattern algorithm given b table pattern use classes characters shiftor algorithm use property next search multiple patterns 3 superimposed automata section describe approach based bitparallel simulation nfa described suppose search r patterns interested occurrences one k errors extend previous bitparallelism approach building automaton one superimpose automata assume patterns length otherwise truncate shortest one hence automata structure differing labels horizontal arrows superimposition defined follows build b table pattern take bitwiseand tables recall 0 means match 1 means mismatch resulting table matches position ith character patterns build automaton using table resulting automaton accepts text position ends occurrence much relaxed pattern classes characters namely example search patt wait shown figure 4 string pait accepted zero errors w errors errors w w figure 4 nfa filter search patt wait moderate number patterns filter strict enough cost single search occurrence reported automaton verified involved patterns use singlepattern automaton step retraverse last characters determine actually occurrence patterns number patterns large filter relaxed trigger many verifications case partition set patterns groups r 0 patterns build automaton group perform drr 0 e independent searches cost search orr 0 n r 0 small enough make cost verifications negligible r 0 always exists since r single pattern per automaton verification needed grouping use heuristic sorting patterns packing neighbors group trying first characters 31 hierarchical verification simplest verification alternative call plain superimposed automaton reports match try individual patterns one one candidate area however smarter verification technique call hierarchical possible assume first r power two automaton reports match run two new automata candidate area one superimposes first half patterns another second half repeat process recursively two automata finds match end automata represent single patterns find match know patterns really found see figure 5 course automata required subsets patterns preprocessed since correspond internal nodes binary tree r leaves space preprocessing cost change r power two one halves may one pattern other2424 figure 5 hierarchical verification method 4 patterns node tree represents check root represents fact global filter node passes check two children tested leaf passes check pattern found advantage hierarchical verification remove number candidates consideration single test moreover even find pattern really matched actually checking specific pattern ie may happen none two halves match spurious match whole group worstcase overhead plain verification constant factor twice many tests candidate area r average show later analytically experimentally hierarchical verification far superior plain verification 32 automaton partitioning considered short patterns whose nfa fit computer word case ie partition problem subsection next adapt two partitioning techniques described 6 simplest technique cope large automaton use number machine words simulation idea follows large automata superimposed partition superimposed automaton matrix subautomata one fitting computer word subautomata behave slightly differently simple one since must propagate bits neighbors figure 6 illustrates automaton partitioned run text updating subautomata step takes time proportional number cells update ie okm gamma kw observe however necessary update subautomata since right may active state following 31 keep track need update matrix subautomata working active cells information flow affected area000000000111111111111111111000111111 rows j columns c r figure large nfa partitioned matrix theta j computer words satisfying r 1 c w 33 pattern partitioning technique based lemma 1 section 21 reduce size problem divide pattern j parts provided search subpatterns bkjc errors match subpattern must verified determine fact complete match perform partition pick smallest j problem fits single computer word ie dmje w limit method reached since case search zero errors algorithm case qualitatively different described section 4 divide pattern j subpatterns evenly possible partition r patterns left j theta r subpatterns searched bkjc errors simply group independent patterns search general method difference determining subpattern appeared verify complete pattern another kind hierarchical verification call hierarchical piece verification applied case shown 23 24 singlepattern algorithm verify hierarchically whether complete pattern matches given piece matches see figure 7 instead checking complete pattern check concatenation two pieces containing one matched matches check concatenation four pieces works lemma 1 applies level tree figure 7 method orthogonal hierarchical verification idea hierarchical piece verification works bottomup instead topdown operates pieces pattern rather sets patterns using hierarchical verification sets pattern pieces determine piece matched given superimposition matched coupling two different hierarchical verification techniques case first use new mechanism determine piece matched superimposed group use hierarchical piece verification determine occurrence complete pattern piece belongs figure 8 illustrates whole process aaabbbcccddd aaabbb cccddd ccc ddd bbb aaa figure 7 hierarchical piece verification method pattern split 4 parts boxes leaves elements actually searched root represents whole pattern least one pattern level must match occurrence complete pattern bold box found bold lines may verified p22 p22 p22 one split 4 3 pieces search superimposed groups pieces arranged hierarchical verif p22 found searched hierarchical piece verif p2 finally found figure 8 whole process pattern partitioning hierarchical verifications partitioning exact searching technique called exact partitioning short based singlepattern filter reduces problem approximate searching problem multipattern exact searching algorithm first appeared 34 later improved 7 6 24 first present single pattern version extension multiple patterns 41 filter based exact searching particular case lemma 1 shows pattern matches text position k errors split pattern k1 pieces least one pieces must present errors occurrence folklore property used several times 34 18 12 searching zero errors leads completely different technique since efficient algorithms search set patterns exactly partition pattern k similar length apply multipattern exact search pieces occurrence piece verified check surrounded complete match many verifications algorithm extremely fast many algorithms multipattern search extension sundays algorithm 27 gave us best results build trie subpatterns text position search text characters trie leaf found match path follow mismatch jump next text position precomputed minimum jumps allowed subpattern sunday algorithm 24 use technique hierarchical piece verification single pattern presented section 33 42 searching multiple patterns observe easily add patterns scheme suppose search r patterns cut one search parallel rk pieces piece found text use classical algorithm verify pattern candidate area note important difference superimposed automata multipattern search know piece matched case superimposed automata know piece matched even possible piece really matched work determine matching piece carried hierarchical verification superimposed automata necessary moreover detect real matches matches union patterns sum individual matches therefore point separating search rk groups reason superimpose less patterns shifts sunday algorithm reduced number patterns grow show experiments never justifies practice splitting one search two 5 counting filter present filter based counting letters common pattern text window filter first presented 14 simple variant 13 use slightly different version variant uses fixedsize instead variablesize text window possibility already noted 32 makes better suited parallelization first explain singlepattern filter extend handle many patterns using bitparallelism 51 simple counter filter based lemma 2 section 21 passes text examining mletters long window keeps track many characters p present current text window accounting multiplicities given text position j characters p window j gammam1j window area verified classical algorithm implement filtering algorithm follows keep counter count pattern characters appearing text window also keep table initially number times character c appears p kept ac throughout algorithm entry ac indicates many occurrences c still taken belonging p example h appears p count one hs text window belonging p ac negative means c must exit text window gammaac times take belonging p example run pattern aloha text aaaaaaaa hold value counter 2 independent k advance window must include new character j1 exclude last character include new character subtract one j1 greater zero decremented new character j1 p increment count exclude old character j gammam1 add one j gammam1 greater zero incremented j gammam1 considered p decrement count whenever count reaches verify preceding area seen algorithm linear excluding verifications number operations per character small 52 keeping many counters parallel search r patterns text use bitparallelism keep counters single machine word must table count values entries lie range gammamm need exactly 1e bits store also enough count since range 0m hence pack patterns length single search recall w number bits computer word patterns different lengths either truncate shortest length use window size longest length patterns must divide set subsets maximal size search subset separately focus attention single subset algorithm simulates simple one follows table packs tables entry divided bit areas length 1 area machine word corresponding pattern store normal value set 1 significant bit area subtract 1 ie store algorithm add subtract 1 easily parallel without causing overflow area next moreover corresponding value positive significant bit area zero also parallel counter mcount areas aligned initialized setting 1 significant bit area subtracting one ie store later add subtract 1 parallel without causing overflow moreover window must verified pattern whenever significant bit area reaches 1 condition checked parallel significant bits reach 1 need sequentially check one finally observe counters want selectively increment decrement correspond exactly areas 1 significant bit ie whose value positive allows obvious bit maskshiftadd mechanism perform operation parallel counters figure 9 illustrates mcount l h e count mgammak false figure 9 bitparallel counters example corresponds pattern aloha searched 1 error text window hello values 0 6 analysis interested complexity presented algorithms well restrictions ff r must satisfy mechanism efficient filtering unrelevant part text effect define two concepts first say multipattern search algorithm optimal searches r patterns time takes search one pattern call c nr cost search r patterns text size n algorithm optimal c say multipattern search algorithm useful searches r patterns less time takes search one one corresponding sequential algorithm ie c nr r c n1 work filters interested average case analysis since worst case none useful compare table 1 complexities limits applicability algorithms muth manber included completeness analysis leading results presented later section algorithm complexity optimality usefulness simple superimp r oe automaton part ffm 2 r oe pattern part mr oe w1gammaff part exact search ffoe 1ff log oe rmthetalog oe log oe rm log oe mthetalog oe log oe counting r log muth manber mn table 1 complexity optimality limit applicability different algorithms present figure 10 schematical representation areas algorithm best terms complexity show later experiments match figures exact partitioning fastest choice reasonable scenarios error levels applied first faster counting log ffoe 1ff w hold asymptotically holds practice reasonable values second faster superimposing automata min true practical cases ffl algorithm faster exact partitioning muth manber 17 namely r ffoe 1ff however limited ffl increasing counting asymptotically fastest algorithm since cost grows olog instead om thanks optimal use bits computer word however applicability reduced grows useless point wins exact partitioning ffl error level high exact partitioning superimposing automata remaining alternative automaton partitioning better pattern partitioning asymptotically better algorithms limit usefulness higher error levels filter improve sequential search pattern partitioning partitioning automaton partitioning exact search oe 1 log oe ff oe 1 log oe partitioning exact search superimposed automata r muthmanber ffoe 1ff ff figure 10 areas algorithm better terms ff r left plot varying assumed moderate r ie less 50 61 superimposed automata suppose search r patterns explained partition set groups r 0 patterns search group separately r 0 automata superimposed size groups large possible small enough verifications significant analyze optimal value r 0 complexity search 6 prove probability given text position matching random pattern error level ff ofl also proved oe experimentally shown holds precisely practice replace e 109 fact abrupt phenomenon occurs since matching probability low oe high otherwise formula 1oe stands probability character crossing horizontal edge automaton ie probability two characters equal extend result note r 0 characters edge mentioned probability smaller r 0 oe use upper bound pessimistic approximation stands case r 0 characters different tight r 0 oe singlepattern algorithm time multipattern algorithm optimal average whenever total cost verifications o1 per character since verification costs om use lineartime algorithm area length om need total number verifications performed o1m per character average used plain verification scheme would mean probability superimposed automaton matches text position o1mr perform r verifications hierarchical verification used r increases matching becomes probable easier cross horizontal edge automaton costs check r patterns one one results two different limits maximum allowable r one two facts stated limit due increased cost verification stringent increased matching probability resulting analysis without hierarchical verification complex omitted hierarchical verification yields considerably better results simpler analysis show appendix average cost verify match superimposed automaton om hierarchical verification used instead orm cost plain verification cost grow number patterns increases hence limit prevents us superimposing r patterns matching probability becomes higher ff roe matching probability high spend much time verifying almost text positions hand superimpose much like limit reached tells best r call r maximum one reaching limit ie r 1 since partition sets small enough make verifications significant cost simply orr n means algorithm optimal taking error level constant alternatively ff roe hand oe cost orn better trivial solution ie r hence superimposition occurs algorithm useful figure 11 illustrates automaton partitioning analysis case similar simple one except step large automaton takes time proportional total number subautomata ie rts pr oe r ff r oe figure 11 behavior superimposed automata left cost increases linearly r slope depending ff right cost parallel search p approaches r single searches fact worst case since average cells active use worst case superimpose patterns worst case search almost reached therefore cost formula rn optimal constant ff alternatively ff roe useful ff oe pattern partitioning jr patterns search bkjc errors error level subproblems recall subpatterns length mj determine piece matched superimposed group pay om independently number pieces superimposed thanks hierarchical verification hence limit grouping given eq 1 superimposed singlepattern algorithm also pay verify match piece part complete match show 23 cost negligible ff oe less strict limit given eq 1 jr pieces search need analytical expression j since j large enough subpatterns fit computer word dw ff shown o1 w maximizing terms ff see 23 therefore complexity oe rn hand search cost singlepattern algorithm ojrn respect simple algorithm short patterns costs multiplied j therefore limits optimality usefulness compare complexities pattern versus automaton partitioning pattern partitioning better k w means constant ff increasing pattern partitioning asymptotically better 62 partitioning exact searching 6 analyze algorithm follows except verifications search time made worst case using ahocorasick machine 1 offn best case use multipattern boyermoore algorithm search pieces length mk1 1ff interested analyzing cost verifications since cut pattern k 1 pieces length bmk 1e probability piece matching 1oe bmk1c hence probability piece matching k easily extend analysis case multiple search since rk pieces length hence probability verifying rk check matches using classical algorithm dynamic programming note case know pattern verify since know piece matched show 23 total verification cost pieces length 2 case hence search cost ffoe 1ff 1 must changed ff consider best case consider optimality usefulness optimal algorithm pay total search time holds algorithm always useful since searches cost independently number patterns number verifications triggered exactly searched pattern separately however ff 1log oe thetalog oe log oe algorithms single multipattern work much dynamic programming hence multipattern search useful case algorithm could useful shifts boyermoore search shortened many patterns point better perform separate searches never happens practice 63 counting number verifications negligible pass algorithms case multiple patterns ow log patterns packed single search cost search r patterns orn logmw difficult part analysis maximum error level ff filtration scheme tolerate keeping number verifications low assume use dynamic programming verify potential matches call probability verifying logmwm 2 algorithm keeps linear ie optimal average algorithm always useful since number verifications triggered multipattern search singlepattern version however 1m algorithms work ormn dynamic programming hence filter useful derive appendix b pessimistic bound limit optimality usefulness namely grows tolerate smaller error levels limit holds condition type independently constant c case need usefulness 7 experimental results experimentally study algorithms compare previous work tested megabytes lowercase english text patterns randomly selected text use sun ultrasparc1 running solaris 251 64 megabytes ram data point obtained averaging unixs user time 10 trials present times tenths seconds per megabyte present results random text avoid excessively lengthly exposition general filters improve alphabet size oe grows lowercase english text behaves approximately random text inverse probability two random letters equal figure compares plain hierarchical verification methods sequential application r searches case superimposed automata automaton fits computer word show cases increasing r increasing k clear hierarchical verification outperforms plain verification cases moreover analysis hierarchical verification confirmed since maximum r cost parallel algorithm grow linearly close r hand algorithm simple verification degrades sooner since verification cost grows r mentioned maximum r value point parallelism ratio maximized search 2r patterns better split two groups size r search group sequentially stress point figure 12 right shows quotient parallel sequential algorithms optimum clear superimposed automata hand parallelism ratio exact partitioning keeps improving r grows predicted analysis optimum larger related sunday shifts still justify split search two compare algorithms others consider hierarchical verification use r value obtain optimal grouping superimposed automata algorithms exact partitioning hand performs searches single pass counting clear speedup optimal pack many patterns single search notice plots depend r show point r selected depend k fixed r hand show parallelization works error level increases cannot controlled algorithm compare algorithms among others begin short patterns whose nfa fit computer word figure 13 shows results increasing r increasing k low moderate error levels exact partitioning fastest algorithm particular faster previous work 17 number patterns 50 english text r r rts r r rts rts sequential nfa superimposed plain verif exact partitioning superimposed hierarchical verif figure 12 comparison sequential multipattern algorithms 9 rows correspond respectively left plots show search time right plots show ratio parallel p sequential time r theta error level increases superimposed automata best choice agrees analysis r r exact partitioning superimposed automata counting figure 13 comparison among algorithms 9 top plots show increasing r 3 bottom plots show increasing k consider longer patterns 14 shows results increasing r increasing k exact partitioning best applied improves previous work 17 r 90100 longer patterns superimposed automata technique also degrades rarely able improve exact partitioning cases begins best others longer useful figure summarizes experimental results becoming practical version theoretical figure 10 main differences exact partitioning better practice complexity suggests clear winner pattern automaton exact partitioning pattern partitioning automaton partitioning counting figure 14 comparison among algorithms 30 top plots show increasing r 4 bottom plots show increasing k partitioning run would resort exact partitioning partitioning exact search superimposed automata r muthmanber apartitioning exact search 9 superimposed automata figure 15 areas algorithm better practice english text right plot assumed 9 compare figure 10 conclusions presented number different filtering algorithms multipattern approximate search ing algorithms allow arbitrary number errors hand previous work allows one error outperformed number patterns search 50100 english text depending pattern length explained analyzed experimentally tested algorithms also presented map best algorithms case many ideas propose used adapt singlepattern approximate searching algorithms case multipattern searching instance idea superimposing automata adapted bitparallel algorithms 19 another fruitful idea exact partitioning multipattern exact search easily adapted search pieces many patterns many filtering algorithms type eg 28 hand exact multipattern search algorithms may better suited search parameters eg working better many patterns number practical optimizations algorithms possible instance ffl patterns different lengths truncate shortest one superimposing automata select cleverly substrings use since character position two patterns improves filtering mechanism ffl used simple heuristics group subpatterns superimposed automata improved maximize common letters general technique could group patterns similar terms number errors needed convert one ie clustering technique ffl free partition pattern k pieces like exact partitioning used 24 minimize expected number verifications letters alphabet probability occurrence eg english text om 3 dynamic programming algorithm presented select best partition could applied multipattern search acknowledgements thank robert muth udi manber implementation 17 also thank anonymous referees detailed comments improved work r efficient string matching aid bibliographic search efficient text searching text retrieval theory practice new approach text searching multiple approximate string matching faster approximate string matching fast practical approximate pattern matching fast string searching algorithm theoretical empirical comparisons approximate string matching algorithms sublinear approximate string matching biological applications improved algorithm approximate string matching simple efficient string matching k mismatches comparison approximate string matching algo rithms fast parallel serial approximate string matching approximate multiple string search sublinear algorithm approximate keyword searching fast bitvector algorithm approximate pattern matching based dynamic progamming multiple approximate string matching counting approximate text searching guided tour approximate string matching improving algorithm approximate pattern matching fast simple approximate string matching theory computation evolutionary distances pattern recognition fast substring search algorithm using qgram locations approximate string matching approximate boyermoore string matching algorithms approximate string matching finding approximate patterns strings approximate string matching qgrams maximal matches approximate string matching using withinword parallelism fast text searching allowing errors tr algorithms approximate string matching fast parallel serial approximate string matching efficient text searching fast substring search algorithm improved algorithm approximate string matching new approach text searching fast text searching approximate stringmatching italicqitalicgrams maximal matches approximate boyermoore string matching approximate string matching using withinword parallelism comparison approximate string matching algorithms fast simple approximate string matching fast string searching algorithm efficient string matching guided tour approximate string matching textretrieval multiple approximate string matching fast practical approximate string matching theoretical empirical comparisons approximate string matching algorithms approximate multiple strings search bitparallel approach suffix automata fast bitvector algorithm approximate string matching based dynamic programming using qgram locations approximate string matching ctr atsuhiro takasu approximate multiword matching algorithm robust document retrieval proceedings 15th acm international conference information knowledge management november 0611 2006 arlington virginia usa kimmo fredriksson online approximate string matching natural language fundamenta informaticae v72 n4 p453466 december 2006 kimmo fredriksson gonzalo navarro averageoptimal single multiple approximate string matching journal experimental algorithmics jea v9 nes 2004 josu kuri gonzalo navarro ludovic fast multipattern search algorithms intrusion detection fundamenta informaticae v56 n12 p2349 january josu kuri gonzalo navarro ludovic fast multipattern search algorithms intrusion detection fundamenta informaticae v56 n12 p2349 july federica mandreoli riccardo martoglia paolo tiberio syntactic approach searching similarities within sentences proceedings eleventh international conference information knowledge management november 0409 2002 mclean virginia usa
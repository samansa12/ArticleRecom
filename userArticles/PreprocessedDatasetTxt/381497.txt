encoding program executions dynamic analysis based collecting data program runs however raw traces tend voluminous unstructured used directly visualization understanding address problem two phases first phase selects subsets data compacts second phase encodes data attempt infer structure major compactionselection techniques include gprofstyle ndepth call sequences selection based class compaction based time intervals encoding whole execution directed acyclic graph structure inference techniques include runlength encoding contextfree grammar encoding building finite state automata b keywords software understand program tracing dynamic program analysis software understanding requires inferring behavior software systems static techniques analyzing programs code dynamic techniques based running program collecting data runs analyzing resultant data dynamic case inherent tradeoffs concerning amount collected data types analyses performed overhead collection regard frameworks suitable dynamic analysis three parts bottom layer closest program suite tools gathering information program exe cutes middle layer selects relevant portions data later compacts analyzes effectively building model top layer closest user displays models process building frame work first part described 17 also briefly review section 2 bulk paper discusses middle layer tools envision top layer least capabilities previous tools 15 enhanced abilities specifying meaningful visualizations demand task arises purpose middle layer build models collected data two reasons build model first impossible visualize raw data volume complexity second model used automatically check properties traces want models useful least following tasks summarizing parts program execution summaries would allow us show execution multiple levels detail helping user navigate modeling class behavior track outside calls methods invoked objects specific class suite programs use class correctly use abstractions generated execution analysis model class used modeling library usage view whole library object track external calls would allow us build model correct library usage test future users library model detecting unusual events model program behavior able find events conform model events often significant represent exceptional condi tions example program executes one sequence synchronization steps almost time occasionally executes alternate sequence denotes potential problem checking existing models already model aspects behavior system say specifications process able efficiently check whether model produced traces conforming original one also see opportunity building models design patterns verifying program implements correctly especially useful behavioral patterns 8 hard specify otherwise 16 performance analysis want able annotate models performance information existing performance tools except using fixed limited model prof using simple function invocation model gprof 9 digram model visualization want models fit exploration graphical means visualization en vironment leave user separate data noise course noise particular application useful another therefore essential models rich enough least hint user focus hand cannot include everything model volume work describe paper provides framework necessary addressing problems using trace data important aspects research 1 framework separates collection analysis encoding data framework provides flexibil ity needed address wide range problems described 2 specific data selection techniques address problems 3 specific encoding techniques facilitate different types analysis combined various selection techniques overall significance research thus lies spe cific techniques used ability combine various ways application combination broad range problems remainder paper organized follows section 2 describes data trace tools currently gener ate different data compaction selection approaches described section 3 section 4 describes different sequence encoding techniques utilize ap proaches note techniques used many approaches described section 3 section 5 discusses results various encodings commenting degree compaction accuracy conclude discussion impact work extensions currently planning first part framework collects data running program suite tools traces binary executables java programs binary tracers tuned c c nothing would prohibit working executables produced say pascal java native compiler table 1 summarizes tracing dataour tracer binaries wolf patches executable inserting hooks entry exit routine also instruments basic blocks keep count many instructions executed per function invocation entry exit hooks used generate trace file thread program call record emitted including called address calling address first argument call latter used determine object used method calls size memory allocation thread threadrelated activities synchronization object synchronization call return record includes address function called return value addition trace files contain periodic records recording thread run time real time clock number instructions executed thread records thread output separate file second tracer development minimal work emitting called address first argument function calls piggybacking count intervening function returns next function call java programs different tool tmon 17 uses standard java profiling interface jvmpi produce multiple trace files one per thread files contain records method entry exit object allocation deallocation thread creation termination monitor synchronization activity trace files also contain records thread run time real time reason use one trace file per thread cases avoids synchronizing calls would otherwise synchronized get intermingling effect back use another program tmerge outputs unified trace file dictionary file maps identifiers like function addresses binaries object identifiers java trace file meaningful symbols even though data recording fairly highlevel amount data large longrunning system immense resultant trace data files contain one gigabyte data every two seconds cc execution ten seconds jited java execution minimal tracer reduces factor 25 imposes certain requirements efficiency tools deal files primarily however creates need compaction selection techniques describe next section data compaction selection techniques range lossless transformations aggregation trace data basically dynamic call tree tree includes node routine invocation edge invocation invocations directly generates tree augmented time information like run time real time instructions spent call memory usage infor 1 common java cc function entry function id first argument c object function exit function object allocatefree object thread startend run time execution time thread real time accumulated real time 2 cc lock pthread synchronization object cre atedestroywaittestunlock lock memory allocatefree address size instruction count instructions executed thread 3 java class loadunload class gc startstop number nongarbage objects total nongarbage object space total object space monitor enterexit object monitor wait object id timeout table 1 trace record summary mation like size number allocations done call following discussion compactionselection schemes talking encoding sequences calls events strings combining using various encodings degree compaction depends largely particular structures operations choose purpose example represent sequence calls string run length encoded string also represent sequence automa ton combine nodes would collapsed strings combining automata example taking union different approaches described section 4 effectiveness combination compaction choice representation described section 5 string compaction simplest way representing dynamic call tree string example function calls function b function c could represent abcthisisof course ambiguous since string would result calling b b calling c without returning need therefore insert markers return two cases become follows abc abc note thread control generates string thus output string encoding execution tree sequence encoded strings one per thread java threadnames allow threads similar names grouped encoding purposes strings apply techniques section 4 class selection applications like modeling behavior class parts trace irrelevant interested constitutes typical use class need number applications use class correctly trace applications isolate calls methods particular class class hierarchy group object interested inner workings class monitor methods object invokes interested external interface forego grouping calls per object need track first argument calls methods pointer largely system dependent behavior seems norm pointer becomes interesting first argument constructor becomes uninteresting first argument destructor using similar approach provide models usage library package entity easy principle difficulty practice comes attempting define meant single use given library entity trick use objects work general case example consider c library file terface file accessible program pointer file data structure specific address becomes interesting returned function fopen also sometimes first argument function fprintf fscanf sometimes fourth fread fwrite need somehow specify return value fopen linked first argument fprintf fourth argument fread top specification difficulty harder trace program since might need emit records arguments one approach interpose library exactly extra step selecting arguments nlevelcalcompaction standard unix prof tool provides use useful performance data grouping calls single routine single node collecting statistics node gprof accumulates statistics calling pairs even found inadequate 20 using trace data provide simple nlevel generalization create nlevel call encoding look call stack start call create 1 nthei tuple includes call i1 top items call stack point tuple accumulate statistics collected trace data computing sums averaging sum squares computing standard deviation interval compaction another way compacting data consider program trace chunks break execution small figure 1 interval visualization set intervals example 1024 simple analysis within intervals highlight system point currently define system two distinct ways providing two different analyses intervals first one concentrates calls interval combining per class multithreaded applications also keeps track much time spent waiting within class using model produce overview visualization shown figure 1 second interval analysis looks allocations class basis interval records number size allocations objects class thread used provide high level visualization allocation behavior system combined call interval analysis provide additional details behavior system dag compaction one effective way compact dynamic call tree transform directed acyclic graph dag dag built traversing tree postorder fashion collapsing nodes identical strings calls every string appears exactly dagthe algorithm compact tree follows 1 postorder fashion nodes tree construct string consisting function node opening parenthesis encoding strings children maintaining order closing parenthesis 2 compute signature string hashing otherwise 3 node dag node containing resulting string nothing 4 otherwise create node create arc nodes containing tree nodes chil drens strings retaining order dont keep strings strings use representation sequence operation replace concatenation way defining unambiguously head sequence parentheses building dag need merge performance statistics associated individual nodes keeping dag node count number original nodes sums statistic original nodes sum squares statistic original nodes lets us provide averages well standard deviations dag node compaction generally quite effective since much execution repetitive nature dag allows repetitions collapsed single node dealing multiple threads start forest call trees apply algorithm trees simultaneously without starting empty dag every time construct single dag represents threads control individual threads represented root nodes resultant graph effectiveness many compaction techniques relies representation sequences items two approaches representations first provide exact representation sequence possibly com pressed second provide lossy representation one represents original sequence sequences one could example detect repetitions sequence ignore counts say aaaabababc would become bas bc regular expression notation ababc kind approximation sequences particularly useful one attempting identify similarities case one attempting encode group related sequences using single encoding several compaction techniques previous section use approach example compacting tree dag make nodes dag describe whole families call sequences example take case function calls function b loop classical string representation would mapped different dag node depending number iterations though loop say run length encoding scheme ignores counts would mapped node cases approximation better understanding visualization framework allows variety sequence encoding techniques include approximations exact encodings vary simple complex correct one use depend particular com pactionselection scheme used specific understanding task runlength encoding simplest approach provide encoding find immediate repetitions replace count followed item repeated thus string abbbbbbbbbcdddbcdc encoded 9b c 3d bcdc fast often quite effective terms compression runlength encoding algorithm also takes parameter k indicating longest repetition expressed exactly repetition size longer k look thus sequence would encoded b c 3d bcdc grammarbased encoding alternative simple runlength encoding finds immediate repetitions find common subsequences encode string using grammar subsequence represented rule natural extension rle encoding one approach sequitur algorithm 14 algorithm builds contextfree grammar representing original string ensures pair adjacent symbols appear grammar every rule used algorithm works looking successive digrams whenever new digram formed duplicates existing one adding new rule process needs applied recursively nonterminals replace digrams rules need eliminated number uses falls one standard sequitur algorithm provides exact encoding single sequence implementation algorithm provides encoding groups sequences done building global table variables sequence thenencoded separately sequence encoding com plete nonterminals merged global variable table unique right hand side variable appears final encodings given terms global variables example consider string abbbbbbbbbcd ddbcdc would encoded subsequence bcd isolated sequence bs encoded two rules r2 basic sequitur algorithm good job finding common subsequences encoding efficiently produces grammar compact rule meaningful hand best job handling repetitions needs log n rules encode sequence n identical symbols encoding 9 bs take account balanced strings strings number calls returns handle alternation modified basic algorithm two basic ways first find immediate repetitions represent runlength encoding done post processing step rule processed nonterminals used processed instance nonterminal right hand side rule replaced newly computed expansion algorithm runlength encoding new right hand side rule become since longer needed yields gramma logical representation original sequence repetition b shown explicitly approach combined runlength encoding k repetitions represented x lets rules merged representation sequence abbbbbbbbbcdddbcdc using sequitur runlength encoding cutoff 3 second modification sequitur designed produce balanced rules useful simple string compaction section 3 dissertation 14 nevillmanning notes sequitur restricted create rules contain closing symbols opening ones done considering digrams unbalanced resultant grammar start produce balanced rules use modification algorithm ensures generated rules balanced done postprocessing start restricting grammar generated rules either completely balanced rule starts open bracket either directly nested rule contains open brackets close brackets neville mannings balancing algorithm runlength encoding rules first modifica tion time encounter unbalanced nonterminal expand place makes rules final grammar longer subsequences appear however resultant grammar balanced rules finite state automata encoding way provide alternation repetition encoding use finite state automata accept se quence one vary accuracy precision encoding using different means constructing automa ton one extreme one build chain automaton accepts given sequence extreme one build single state automaton accepts everything via self arcs every possible input symbol naturally neither approaches useful want automaton good intuition sort sequence possible words automaton reveal something structure sequence automaton represents multiple sequences collective structure must revealed significant previous work inferring finite state automata input sequences work concentrated use positive negative examples ie providing set inputs valid sequences set inputs previous work looked interactive models inference procedure able ask user whether particular input valid neither approaches practical types sequences looking atin ways sequences special path ex ample automata reflect internal flow graph single procedure encode loops conditional branches pure sequential flow provides us direction applications using automata describe methods class used clear cut however even way classes designed used result fairly structured flow diagram order take advantage presumed structure behind sequence still provide reasonably high degree abstraction building automata developed new algorithm inferring automaton one sequences basic fsa construction algorithm algorithm constructs deterministic fsas property given sequence three symbols start one state formalize little use definitions hopcroft ullman 10 deterministic finite state automaton defined set states q input alphabet initial state q0 2 q transition function andasetoffinalstatesf q addition define string length k element k use extended definition allows second argument word instead single symbols q specific purposes define f one element achieve extending strings sequence length k special symbol say state q ktail 2 k iff exists state q0 qtq0 iff starting q possible see sequence call relation tailqt algorithm maintains two invariants determinism mapping ktails states basic algorithm maps every ktail one state two states ktail common merged merging two states actually recursive process since two states merged outgoing arcs symbol target states arcs must also merged process also affect possible ktails state however number potential additions need considered one adds arc grows nk n size input alphabet prohibitive building large automaton therefore ignore associations building automaton merge states based associations post processing step final postprocessing step classical minimization fsa example algorithms output given sequence abbbbbbbbbcdddbcdc k 3is shown figure 2 handling self loops basic algorithm reasonably well finding appropriate automaton fails however detect sequences k less single token consider input sequence abbbc automaton generated using basic algorithm would consist seven states single transition next one seven rather six states algorithm adds transition end actually want generate automaton selfloop indicates repetition b requires two simple modifications algo rithm first occurs building automaton current state already input current token instead creating new state create selfloop sufficient create selfloops repetitive input sequences consider result applying modified algorithm example shown figure 2 selfloop input b state s1 created determinism enough 3 ds state s2thefirstd takes us new state s3 get second three ds sequence new check fires self loop created shown figure 3 last next sequence bcd associated state s1 however selfloop state would require s1 s3 merged result shown figure 3b second modification bit complex selfloops tend cause spurious state merging consider automaton part figure 3b states s1 s2 potential successor string ddd general state q selfloop input x qxq state q0 transition state input x q0xq would merged behavior want therefore changed postprocessing step situations like initial instance x causes transition state representing loop part loop 5 experience used various encoding approaches variety program traces java c programs generated traces include following knightstour solves problem finding hamiltonianb c abbbbbbbbbcdddbcdc bd b abbbbbbbbbcdddbcdc figure 3 examples self loops path graph induced knights moves chessboard written c simulate motion pendulum magnetic field written java onsets engine onsets board game core program builds valid logic formulas set characters written c decaf optimizing compiler small subset java written c showmeanings webserver whose main function finding alternate meanings words elaborate web searches raw trace data ranges size one megabyte simple c program implementing knights tour twenty gigabytes test commercial java system handles webbased requests tried various encodings traces evaluate quality results done spot checks trace detailed analysis knights tour example encodings evaluated two ways one goals various encodings especially dag call encodings provide concise version trace data cases measure amount compaction encoding provides note good absolute measure program repetitive condensed encoding one independent encoding technique note also giving information encodings encodings typically look dynamic call graph ignore memory management synchronization information trace moreover also discard information individual objects based experience however still encode quarter original trace data finally note raw trace files already quite dense since contain packed binary data encoded output files text files containing xml data compression results various encodings seen table 2 s5 cdd figure 2 sample run fsa inducing algorithm grammar encodings seem grow size trace fsa encodings grow number functions program grammars also tend grow larger fsas however would dangerous make definite assertions sizes models second way evaluating encodings especially automatabased ones see resultant automata reflect intuitive behavior system pur pose spotchecked routines knights tour exam ple classes java program io classes standard library see corresponding automata looked like example given figure 4 spot checks automata generated seem correspond quite well one would expect given code one thing evaluated generating encodings determine good values k parameter automata cases looked value k 2 collapsed many states value k 4 make much difference resultant automata cases automata change much one come examples require arbitrary k find right intuition value k 3seems good compromise 6 related work tracing programs done number different ways essentially program emit records state one modify program code generate trace data approach taken data visualization sys tems like balsa 2 polka18 approach works well goal something like algorithm animation tracing actually part finished program second approach modify executable done either compile time like gprof finished ex ecutable apart system eel 13 takes approach lastly one run executable tracing environment like jvm modified jvm like jinsight 5 significant work encoding call tree essentially algorithm jerding et al 11 except incorporate steps keep encoding phase approaches 1 21 lose information processjerding et al 11 also focus class selection prof gprof 9 kept statistics function invocations callercallee pairs respectively try derive automaton based usage classes effectively discovering path expressions 3 kind result akin work ernst notkin 6 trying discover data invariants program sequitur used compress basic block trace data larus 12 nevillemanning reports work gaines 7 focused discovering control flow albeit use absolute value program counter discovering fsas positive examples long history general impossible discover correct minimal fsa impossible even probably approximately correct model algorithm closest cook wolf 4 difference collapse two nodes iff one includes ktails one since constraint stricter end bigger fsas research described paper represents first step toward system afford broad basis understand visualizing dynamic behavior large complex sys tems current efforts involve extending basis variety ways area trace data collection working extensions reduce size trace files impact tracing program execution working interface specifying trace records interesting outputting also incorporating minimal tracing section 2 larger framework addition implementing variety minor extensions let trace collection system used effectively multiple process distributed systems next working developing incorporating additional selectioncompaction techniques one looking first involve generating sequences memory events eg allocations memory compaction involving moving objects garbage collector frees garbage col lections generating sequences reflect use library arbitrary program abstraction program name functions raw trace size daggrammar dagfsa stringgrammar stringfsa knighttour 268 700k 120k 208k 12k 40k onsets 542 833m 6m 464k 15m 80k decaf 5443 26g 29m 5m 61m 700k showmeanings 1488 21g 82m 623k 34m 110k table 2 compression achieved encodings finally working developing additional encoding 8 techniques sequence encodings investigating use probabilistic models like hidden markov models approximate fsas probabilistic models flex 9 ible well known train capable various things fsa cannot like segregation program trace phases hand one tune lot parameters work properly since learning process optimization procedure sometimes 10 resulting model gets stuck local optima meaningful r exploiting hardware performance counters flow context sensitive profiling interesting events specifi cation process scheduling path expressions discovering models soft 14 ware processes eventbased data visualizing reference patterns solving memory leaks java dynamically discovering likely program invariants support program evolution behaviourstructure transformations un 18 der uncertainty gprof call graph execution profiler sigplan automata theory visualizing interactions program executions whole program paths acm sigplan language design implementation plan95 conference programming language design implementation pldi inferring sequential structure phd thesis working patterns code 33rd hawaii international conference system sciences generating java trace data smooth continuous animation portraying algorithms processes knightsquareinfofindrestoftourknightsolution sol solisvalid return true sq figure 4 case fsa algorithm discovers control software visualization programming practical experience limitations gprof tr practical experience limitations gprof visualizing interactions program executions exploiting hardware performance counters flow context sensitive profiling software visualization desert environment discovering models software processes eventbased data whole program paths dynamically discovering likely program invariants support program evolution generating java trace data portable samplingbased profiler java virtual machines introduction automata theory languages computation visualizing reference patterns solving memory leaks java gprof working patterns code ctr alessandro orso james jones mary jean harrold john stasko gammatella visualization programexecution data deployed software proceedings 26th international conference software engineering p699700 may 2328 2004 james jones alessandro orso mary jean harrold gammatella visualizing programexecution data deployed software information visualization v3 n3 p173188 september 2004 steven p reiss overview bloom proceedings 2001 acm sigplansigsoft workshop program analysis software tools engineering p25 june 2001 snowbird utah united states valentin dallmeier christian lindig andreas zeller lightweight bug localization ample proceedings sixth international symposium automated analysisdriven debugging p99104 september 1921 2005 monterey california usa steven p reiss visualizing java action proceedings acm symposium software visualization june 1113 2003 san diego california ludovic langevine mireille ducass tracer driver hybrid execution analyses proceedings sixth international symposium automated analysisdriven debugging p143148 september 1921 2005 monterey california usa davide lorenzoli leonardo mariani mauro pezz inferring statebased behavior models proceedings 2006 international workshop dynamic systems analysis may 2323 2006 shanghai china alessandro orso james jones mary jean harrold visualization programexecution data deployed software proceedings acm symposium software visualization june 1113 2003 san diego california stuart marshall kirk jackson craig anslow robert biddle aspects visualising reusable components proceedings asiapacific symposium information visualisation p8188 january 01 2003 adelaide australia ankit goel abhik roychoudhury tulika mitra compactly representing parallel program executions acm sigplan notices v38 n10 october rhodes brown karel driesen david eng laurie hendren john jorgensen clark verbrugge qin wang step framework efficient encoding general trace data acm sigsoft software engineering notes v28 n1 january tao wang abhik roychoudhury using compressed bytecode traces slicing java programs proceedings 26th international conference software engineering p512521 may 2328 2004 murali krishna ramanathan ananth grama suresh jagannathan pathsensitive inference function precedence protocols proceedings 29th international conference software engineering p240250 may 2026 2007 john whaley michael c martin monica lam automatic extraction objectoriented component interfaces acm sigsoft software engineering notes v27 n4 july 2002 ben liblit alex aiken alice x zheng michael jordan bug isolation via remote program sampling acm sigplan notices v38 n5 may glenn ammons rastislav bodk james r larus mining specifications acm sigplan notices v37 n1 p416 jan 2002 robert j walker kevin viggers implementing protocols via declarative event patterns acm sigsoft software engineering notes v29 n6 november 2004 sebastian elbaum madeline hardojo empirical study profiling strategies released software impact testing activities acm sigsoft software engineering notes v29 n4 july 2004 manos renieris shashank ramaprasad steven p reiss arithmetic program paths acm sigsoft software engineering notes v30 n5 september 2005 sebastian elbaum madeline diep profiling deployed software assessing strategies testing opportunities ieee transactions software engineering v31 n4 p312327 april 2005 david lo siaucheng khoo smartic towards building accurate robust scalable specification miner proceedings 14th acm sigsoft international symposium foundations software engineering november 0511 2006 portland oregon usa jinlin yang david evans deepali bhardwaj thirumalesh bhat manuvir das perracotta mining temporal api rules imperfect traces proceeding 28th international conference software engineering may 2028 2006 shanghai china
verification large stateevent systems using compositionality dependency analysis stateevent model concurrent version mealy machines used describing embedded reactive systems paper introduces technique uses compositionality dependency analysis significantly improve efficiency symbolic model checking stateevent models makes possible automated verification large industrial designs use modest resources less 5 minutes standard pc model 1421 concurrent machines results paper implemented next version commercial tool visualstatetm b introduction symbolic model checking powerful technique formal verification finitestate concurrent systems technique initially developed verify digital systems class systems proven efficient hardware systems extremely large number reachable states verified however clear whether model checking effective kinds concurrent systems example software systems one reason symbolic model checking may efficient software systems tend larger less regularly structured hardware example many results reported verifying large hardware systems linear structures like stacks pipelines see eg 7 known 17 size transition relation represented robdd grows linearly size system recently first experiments larger realistic software systems reported 3 18 supported cit danish national center research brics basic research computer science basic research center funded danish government aarhus aalborg paper presents new technique significantly improves performance symbolic model checking embedded reactive systems modeled using stateevent model stateevent model concurrent version mealy chines consists fixed number concurrent finite state machines pairs input events output actions associated transitions machines model synchronous input event reacted upon machines lockstep total output multiset union output actions individual machines synchronization machines achieved associating guard transitions guards boolean combinations conditions local states machines way firing transitions one machine made conditional local state machines machine enabled transition particular input event simply perform state change stateevent model convenient describing control portion embedded reactive systems including smaller systems cellular phones hifi equipment cruise controls cars large systems train simulators flight control systems telephone communication protocols model used commercial tool visualstate tm 16 tool assists developing embedded reactive software allowing designer construct stateevent model analyze either simulating running consistency checker tool automatically generates code hardware embedded system consistency checker fact verification tool checks range properties stateevent model checks must passed generated code correct instance crucial model deterministic checks issued warnings might design errors transitions never fire stateevent models extremely large unlike traditional model checking number checks least linear size model paper reports results models 1421 concurrent state machines 10 476 states systems size traditional symbolic model checking techniques fail even using partitioned transition relation 5 backwards itera tion present compositional technique initially considers machines determining satisfaction verification task necessary gradually increases number considered machines machines considered determined using dependency analysis structure system results encouraging number large stateevent models industrial applications verified even largest model 1421 concurrent machines verified modest resources takes less hour standard pc compared current version visualstate tm results improve efficiency checking smaller instances dramatically increase size systems verified related work use robdds 4 model checking introduced burch et al 6 coudert et al 12 several improvements developed since using partitioned transition relation 5 13 simplifying robdd representation fixedpoint iteration 11 many improvements implemented tool smv 17 techniques like abstraction 9 compositional model checking 10 reduce complexity verification task require human insight interaction experiments anderson et al 3 sreemani atlee 18 verified large software systems using smv technique presented significantly improves results obtained using smv makes possible verify larger systems compositional technique shares ideas partial model checking 1 2 15 explicitly analyzes structure model outline stateevent model described section 2 section 3 explains range consistency checks performed visualstate tm reduced two simple types checks section 4 shows stateevent systems encoded rob dds compositional technique dependency analysis introduced section 5 developed section 6 technique evaluated section 7 section 8 draws conclusions stateevent systems stateevent system consists n machines input event alphabet e output alphabet machine triple local states initial state set transitions set transitions relation mo multiset outputs g set guards containing references machine guards generated following simple grammar boolean expressions atomic predicate l read machine j local state p tt denotes true guard global state set stateevent system product local state sets guards interpreted straightforwardly 2 exactly jth component p notation gs j l j denotes j substituted l j occurrences atomic propositions form l replaced tt tt depending whether j identical p considering global state guards transition relation evaluated define version transition relation guards evaluated relation denoted e expressing machine receiving event e makes transition 0 generates output formally e e e fig 1 two stateevent machines corresponding parallel combination guards formally form l simply written state p since location l j derivable name state small arrows indicate initial states reference r requirement state third machine shown two machines combined one generally j compositions two disjoint sets machines j j combine one theta j ands 0 j transition relation ij subset ij theta e theta g ij theta mo theta ij g ij guards composite machine construction ij guards g ij contain references machines j define ij introduce predicate idle holds states transitions enabled state receiving event e transition relation ij defined following inference rules symbol denotes multiset union particular full combination n machines yields mealy machine transitions e gammagamma 0 defined true stateevent systems figure 1 illustrates two machines parallel composition synchronizing event e restricted cyclic iteration total state space side effect generate output finished 3 consistency checks consistency checker visualstate tm performs seven predefined types checks reduced verifying one two types properties first type reachability property instance visualstate tm performs check conflicting transitions ie checks whether two transitions become enabled local state leading nondeterminism reduced questions reachability considering pairs guards g 1 g 2 transitions local state input event e conflict occur global state reachable l total five seven types checks reduce reachability checks four check transitions never enabled check states never reached generate number reachability checks linear number transitions worstcase check conflicting transitions gives rise number reachability checks quadratic number transitions however practice transitions starting local state input event thus practice number checks generated much smaller remaining two types consistency checks reduce check absence local deadlocks local deadlock occurs system reach state one machines idles forever input events check made n machines total least checks performed making verification stateevent systems quite different traditional model checking typically key properties verified attempt reduce number reachability checks performing implicational analysis guards checks guard g 1 implies another guard g 2 clearly g 1 reachable g 2 use information start sorting guards ascending order size satisfying state space way specific guards checked first new guard checked compare already checked reachable guards new guard includes one know satisfiable worstcase quadratic number tests however experiments reduction 40 94 obtained 4 robdd representation section describes reduced ordered binary decision diagrams rob dds 4 used represent sets states transition relation also show perform forward iteration construct set reachable states straightforward check reachability checks construct robdd e transition relation first construct local transition relations e machine variables robdd represents encoding inputs current states nextstates variables ordered follows first kek variables encodes input events e kxk denotes dlog 2 jxje denoted encoding current un primed variables nextstates primed variables machine transition relation e constructed robdd predicate variables construct robdd transition conjunction robdd encoding e g 0 outputs encoded influence reachable states system encoding e 0 straightforward encoding guard g done converting atomic predicates l robdd predicates currentstate variables machine j performing boolean operations guard encoding transitions machine obtained disjunction encoding individual transitions e e robdd encoding input e e e 0 robdd encodings currentstate nextstate 0 properly encode global transition relation need deal situations transitions enabled cases want machine stay current state construct robdd neg representing transition enabled negating guards machine including robdd equ encodes machine change state requiring nextstate identical currentstate local transition relation machine e robdd e full transition relation conjunction local transition relations e e one way check whether state reachable construct reachable state space r construction r done standard forward iteration transition relation starting initial state 0 v set currentstate variables v 0 set nextstate variables denotes result replacing primed variables v 0 unprimed versions construction full transition relation avoided using partitioned transition relation 5 local transition relations used without ever building full approaches implemented tested examples shown section 7 see calculation reachable state space using full transition relation fast efficient small examples however models approximately machines approaches fail complete compositional backwards reachability problems forwards iteration typically solved using backwards reachability analysis verification task determine whether guard g satisfied instead computing reachable state space check g valid somewhere set start set states g valid compute several backwards iterations states reach state g satisfied goal determine whether initial state among states novel idea perform backwards iteration compositional manner considering minimal number machines initially machines mentioned g taken account later also machines depend included notice compared forwards iteration approach apparent drawback performing large number reachability checks instead one fixedpoint iteration construct reachable state space r trivially verify properties new fixedpoint iteration necessary property checked however experiments clearly demonstrate using compositional backwards iteration fixedpoint iterations completed even large models whereas forwards iteration fails complete construction r even medium sized models formalize backwards compositional technique need semantic version concept dependency subset machines two states 0 2 iequivalent written subset p reachable states constrained components index set think p sort leads following definition subset p isorted m3 fig 2 left figure example showing effect bi g x guard guard l transitions si seem depend machines j mk outside however guards x x together span possibilities therefore selecting either e1 e2 e3 state si reach g irrespective states machines j mk right figure illustrates dependencies 9 state machines taken real example example hifi section 7 arrow one machine another j indicates existence transition guard depends state machine example consider guard g mentions machines 1 3 set states defined g isorted containing 1 3 1 another understanding definition set p isorted independent machines complement ng n isorted set g perform backwards reachability computation including states irrespective states machines reach g one backward step given function b g defined gammagamma 00 00 1 definition b g isorted set b g defined b set states independently machines input e reach state g observe b g monotonic g figure 2 shows state machine included b g although syntactically seems depend machines outside iterating application b compute minimum set states containing g closed application b minimum fixedpoint x refer b g note b f1 ng g becomes desired set states may reach g set indices said dependency closed none machines depend machines outside formally dependency closed 2 states inputs e outputs e basic properties sets b g captured following lemma 1 guard selfcontradictory always false isorted reflects fact semantic sortedness precise syntactic occurrence compositional reachability lemma assume g isorted subset subsets machines j j following holds 2 b g 3 dependency closed results lemma applied following manner check whether guard g reachable first consider set machines 1 syntactically mentioned g clearly g 1 sorted compute b i1 g initial state 0 belongs b i1 g 1 f1 ng g therefore g reachable 0 done extend 1 larger set machines 2 adding machines syntactically mentioned guards transitions machines 1 compute b i2 g b i1 g correct 2 continue like 0 found one sets index set k dependency closed latter case 3 k f1 ng g g unreachable unless k g example assume want determine whether guard reachable example figure 2 right initial index set 3g enough show g reachable second index set used since set dependency closed g reachable initial state belongs b i1 g construction based backwards iteration dual version forwards iteration could defined however definition would make use dependency information since 0 isorted ng therefore machines would considered first fixedpoint iteration reducing complete forwards iteration mentioned previous section seemingly definition b g requires knowledge global transition relation therefore seem yield computational advantage however explained using robdds may avoided leading efficient computation b g robdd e eg representing one iteration backwards states represented robdd e g constructed immediately definition 1 e equal eg variables v replaced primed versions v 0 essential avoid building global transition relation e done writing 9v 0 9v 0 9v 0 e e i2i e allows us push existential quantification v 0 e since g isorted thus independent variables v 0 9v 0 tautology equation 2 reduces e uses local transition relations machines refers primed variables v 0 allowing early variable quantification machine individually e equation efficiently computes one step fixedpoint iteration constructing e eg notice existential quantifications performed order chosen order machines occur input orders might exist improves performance 6 local deadlock detection checking local deadlocks use construction similar backwards reach ability make compositional backwards lemma applicable work notion machine live exact dual local deadlock words machine live always case exists way make machine move new local state formally global state live machine exists sequence states j e gammagamma j1 e k machine live reachable states live simple example stateevent system local deadlock shown figure 3 fig 3 stateevent system local deadlock global state live machine right since input events guard p1 remains false state reachable eg initially receiving e1 thus machine right local deadlock check divided two parts first set live states l machine computed second check reachable states l straightforward inefficient approach would compute two sets check inclusion however take advantage compositional construction used backwards reachability parts check similar definition b g define l ii x set states immediately live machine 2 independently machines outside leads states x states assumed live machine notice compared definition 1 difference extra possibility state immediately live ie 6 00 set states live machine independently machines outside set l ii minimum fixed point defined l three properties lemma 1 also holds l dependency closed follows property 3 lemma l equals l precisely set live states machine gives efficient way compute sets l ii different choices start 1 equal fig continue larger k exactly backwards reachability difference termination conditions one possible termination case l k becomes equal k case trivial set reachable states contained l k monotonicity property 1 lemma follows machine live thus free local deadlocks termination case k becomes dependency closed check whether exists reachable states l k done compositional backwards reachability check k 7 experimental results technique presented used range real industrial stateevent systems set systems constructed students course embedded systems examples constructed using cover large range different applications structurally highly irregular examples hifi surround flow motor intervm dkvm multicd ice1 ice2 industrial examples hifi control part advanced compact hifi system surround surround sound control unit video player flow control part flow meter motor motor control intervm dkvm advanced vending machines multicd control multivolume cd player ice1 ice2 independent subsystems train simulator remaining examples constructed students vcr simulation video recorder cyber alarm clock jvc control compact hifi system video video player volvo simulation complete functionality dashboard car characteristics stateevent systems shown table 1 experiments carried 166 mhz pentium pc ram running linux implement robdd operations constructed robdd package comparable stateoftheart packages terms performance experiments limit total number robdd nodes one million corresponding 20 mb memory check transition whether guard reachable whether conflicting transitions furthermore check machine whether local deadlock total runtime memory consumption checks shown table 2 total number checks far quadratic worstcase table 1 stateevent systems used experiments last two columns show size declared reachable state space declared state space product number local states machine reachable state space reported systems forwards analysis completes system machines local states transitions declared reachable vcr 7 cyber 8 19 dkvm 9 flow motor 12 surround 12 multicd 28 table 2 runtime memory consumptions experiments second column table shows total number guards checked reachability number reduced implicational analysis forward columns show results using forward iteration full partitioned transition relation backward columns show results backwards iteration using full transition relation compositional backwards reachability visualstate column shows runtimes obtained using explicit state enumeration implemented version 30 visualstate tm gamma denotes ran memory runtime exceeded two hours without finishing forward backward system guards full partitioned full compositional visualstate checked sec mb sec mb sec mb sec mb sec cyber dkvm flow motor surround 173 89 6 2690 14 97 6 130 6 3780 volvo multicd 199 49 fig 4 fraction machines actually used compositional backwards reachability analysis guards largest system ice2 size dependency closed set line drawn minimum maximum fraction machines used verifying guards dependency closed sets size stance guards dependency closed sets 234 machines rightmost line 1 32 machines needed prove guard reachable supports claim practice checks needed check conflicting rules see section 3 expected forwards iteration full transition relation efficient smaller systems remarkable robdd technique superior explicit state enumeration even systems small number reachable states using partitioned transition relation forwards iteration works poorly could due fact use early variable quantification since straightforward backwards iteration two largest systems compositional backwards technique suc ceeds fact four largest systems efficient small examples performance comparable full forward technique despite fact number checks high backward iterations must repeated check experiments seems compositional backwards technique better full forwards somewhere around 20 machines order understand compositional backwards technique successful analyzed largest system ice2 detail see figure 4 guard computed size smallest enclosing dependency closed set machines backwards iterations kept track many times set machines used b g need enlarged many machines contained set iteration terminated dependency closed sets cardinality 63 66 85 86 125 127 contain least one machine guard unreachable clearly seen figure cases iteration include entire dependency closed set order prove initial state cannot reach guard fact case unreachable guards 32 machines dependency closed set ever needed ignoring small dependency closed sets less 12 machines reduction 32 amounts reduction runtime much larger third due potential exponential growth robdd representation number transition relations e 8 conclusion presented verification problem stateevent systems characterized large number reachability checks new compositional technique presented significantly improves performance symbolic model checking stateevent systems demonstrated variety industrial systems several could verified using traditional symbolic model checking eg using smv expect results translated models embedded control systems stateevent model example statecharts 14 furthermore two types checks general nature clearly reachability key property captures number important properties system moreover check local deadlock shows properties requiring nesting fixed points checked efficiently compositional backwards analysis thus seems straightforward implement general checks expressed instance ctl 8 r partial model checking robdds partial model checking extended abstract model checking large software specifications symbolic model checking partitioned transition relations symbolic model checking 10 20 states beyond symbolic model checking sequential circuit verification automatic verification finitestate concurrent systems using temporal logic specifications model checking abstraction compositional model checking verification synchronous sequential machines based symbolic execution verifying temporal properties sequential machines without building state diagrams efficient model checking automated ordering transition relation partitions statecharts visual formalism complex systems compositional proof readtime mutual exclusion protocol beologic r symbolic model checking feasibility model checking software requirements case study tr graphbased algorithms boolean function manipulation statecharts visual formalism complex systems compositional model checking verification synchronous sequential machines based symbolic execution model checking abstraction requirements specification processcontrol systems model checking large software specifications tearing based automatic abstraction ctl model checking symbolic model checking partial model checking robdds compositional proof realtime mutual exclusion protocol stepwise ctl model checking stateevent systems verifying temporal properties sequential machines without building state diagrams iterative approach language containment efficient model checking automated ordering transition relation partitions automatic abstraction techniques propositional myampersand181calculus model checking verification hierarchical stateevent systems using reusability compositionality partial model checking
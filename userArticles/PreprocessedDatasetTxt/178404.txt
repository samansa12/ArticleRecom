implementing complex elementary functions using exception handling algorithms developed reliable accurate evaluations complex elementary functions required fortran 77 fortran 9 namely cabs csqrt cexp clog csin ccos algorithms presented pseudocode convenient exceptionhandling facility tight error bound derived algorithm corresponding fortran programs ieee environment also developed illustrate practicality algorithms programs tested carefully help confirm correctness algorithms error bounds results tests included paper fortran programs b introduction purpose develop algorithms along error bounds reliable accurate evaluations complex elementary functions required fortran 77 1 fortran 90 4 namely cabs csqrt cexp clog csin ccos seemingly oxy moronic complex elementary functions expressed terms formulas involving real arithmetic real elementary functions complex arithmetic needed care taken formulas usually arranged serious numerical cancellation occur evaluation cannot arranged higher precision may necessary critical points calculations work supported natural sciences engineering research council canada information technology research centre ontario well applied mathematical sciences subprogram office energy research u department energy contract w31109eng38 stars program office af order resd632 authors addresses e hull f fairgrieve department computer science university toronto toronto ontario canada m5s 1a4 email ftehulltffgcsutorontoca ping tak peter tang mathematics computer science division argonne national laboratory 9700 south cass ave argonne il usa 604394801 email tangantaresmcsanlgov main difficulty remains evaluations possibility overflow underflow might occur intermediate stages calculation exceptions often spurious sense final mathematical result within range machine representable numbers circumstances normally occur rarely algorithms must provide alternative calculations may lengthy able circumvent spurious exceptional situations suggests designing algorithms help exception handling facilities algorithm would begin direct evaluation original carefully arranged formulas would efficient almost always successful exception occur calculation would cause control calculations transferred exception handler would needed circumvent difficulty possible possible cause appropriate exception returned function capture essential feature algorithms present pseudocode possesses convenient exception handling facility section 2 provides basic information error bounds assume real arithmetic real elementary functions used evaluating complex func tions special attention given real sine cosine functions three functions needed later introduced conventions exceptions returned complex functions also specified precisely section 3 introduces exception handling construct used pseudocode pseudocode algorithms presented section 4 along error analyses special implementations testing described section 5 formulas error bounds derived section 4 tabulated section 5 extensive testing done ieee binary arithmetic 3 sun systems 6 issues considered production implementations discussed section 6 concluding remarks given section 7 emphasize assume throughout function arguments exact argument z slightly error induced error corresponding value function fz generally small special situations error also large relative error fz deltaf zfz approximately zf 0 zfz times relative error z deltazz relative error magnification factor zf 0 zfz large example one extreme case fz logz factor 1 logz arbitrarily large z near 1 complex exponentiation included paper difficult develop algorithm much better simply evaluating cexpw clogz approximate z lambdaw hope consider problem separate paper earlier version paper appeared argonne preprint 2 2 basic numerical operations complex elementary functions described section 4 depend real arithmetic operations real elementary functions main purpose section introduce notation errors error bounds associated real operations used later derive error bounds complex functions bounds associated real sine cosine functions discussed separate subsection implementation log1px considered separately since log1p always available one standard real functions two special functions manipulating exponents also specified possible exceptions complex functions specified final subsection 21 errors error bounds assume input values complex elementary functions normalized complex floatingpoint numbers assumption arranged internal operations might generate errors rounding errors operate normalized real floatingpoint numbers associated error analyses mostly relatively straightforward produce results simple easy use would also straightforward matter make provision input output values complex numbers whose components could denormalized error analyses would much complicated also distinguish signed zeros latter context see kahan 5 except cabs whose output normalized real floatingpoint number overflow returned output example normalized complex floatingpoint number exception returned main assumption make real arithmetic x normalized real floatingpoint numbers op one four basic arithmetic operations relative roundoff error bound e f l x op ffl j ffl j e provided exception occurs f l x op rounded floatingpoint approximation x op produced machine assume f l x op also assume corresponding error bounds known real elementary functions example assume bound e sqrt f l ffl sqrt similarly assume relative error bounds namely real elementary functions used section 4 bound small multiple e bound sin cos needs special attention considered detail next subsection also assume underflow sin cos assumptions derive bounds errors evaluating expressions arise section 4 example conclude program expression x sqrtx f l xy p x value xy hence correct within relative error bounded 2ee sqrt neglect terms small multiples e 2 provided exception returned notation convenient note different occurrences ffl necessarily use results like derive relative error bounds approximations obtain complex functions section 4 general f complex function f r f real imaginary parts respectively f c f c r f c corresponding calculated approximations magnitude relative error f c f r f r r r r relative errors f c r f c respectively assuming f r f zero either one zero cases treated separately let us denote bounds f r r r bounded maxe r useful bound e r e different turns case examples section 4 except clog two examples section 4 csqrt cexp examine detail expression bound obtained able determine bounds somewhat smaller maxe r case clog able obtain bound dramatically smaller maxe r 22 errors sine cosine approximations stated previous subsection assume relative error bound e sincos sine cosine functions means assume bound e sincos f l assumption use unless restrict range values x hold section 5 give result measuring value system use testing remainder subsection examine detail result depends range x accuracy range reduction done radix precisions used calculating approximations consider detail one relatively common case namely case sinx cosx approximated first finding x 0 x 0 approximately x mod 2 j x using x 0 standard way determine final approximation sinx cosx suppose approximation 2 used range reduction p iby2 expecting choose bound e 2 ffl 2 much smaller e first determine n relatively high precision good discussion might accomplished see payne hanek 7 value would rounded x 00 say x least e x 00 would used argument sine cosine approximation valid gamma4 4 common practice use possibly simulated high precision arithmetic computations case ffl 00 would likely bounded small multiple e 2 final approximation sinx gamma1 n2 sinx 00 even gamma1 ngamma12 cosx 00 relative errors introduced stage errors committed approximating sine cosine functions interval gamma4 4 bounded small multiples e similar expressions obtained approximate cosx n even calculated approximation sinx therefore f l first require p iby2 accurate enough neglected j j bounded small multiple e replace thus relative error f l neglecting small multiples expression shown j u thus relative error f l sinx bounded neglecting small multiples e 2 max taken machine representable values x appropriate range course e sincos expected somewhat smaller expression shows clearly factors need controlled keep reasonably small result applicable n even n odd cotx must replaced tanx e singamma44 e cosgamma44 similar results derived approximations cosx results combined one bound applicable approximations either sinx cosx namely neglecting small multiples e 2 max taken machine representable values x appropriate range impose even stringent requirement accuracy p iby2 must chosen error contributions involving tangent cotangent terms expression bounded small multiple e choice depend radix precision number system well appropriate range values x number system illustrate let us consider one example x 24bit binary number determined max j n2 tanx almost stored accurately possible 66 bits default case sun systems 6 p 53 turns j n2 tanx circumstances bound relative errors sine cosine functions indicates storing p iby2 bits accurate enough j x allow larger range j x almost 586e suggests considerably accurate value p iby2 used range reduction option sun system provides access high precision approximation consider detail point enough illustrate sort considerations taken account practice bounds section 4 depend would helpful quantity carefully documented individual systems algorithms might implemented 23 log1p function subsection 44 need evaluate real elementary log function situation argument log function must evaluated known approximately introduces serious problem value argument near say 1x x small turns often calculate x working precision real elementary function log1px approximates log1 without explicitly adding 1 x ideally suited purposes since log1p always available present simple way specify reasonably accurate log1p function using log function accurate implementa 7function possible exceptions domainerror real real e appropriately initialized real oneovere appropriately initialized return domainerror return logx return x else return logy endif fig 1 implementation log1p using log looking three special cases program takes care obtain accurate approximation log1 tion rely log function see tang 8 program figure 1 first looks exceptional case x gamma1 x large log1px replaced logx program makes replacement sufficient x 1e also ensures replacement made one case necessary x large x x largest machine representable number rounding mode roundup j x j small log1px replaced x program makes replacement sufficient also necessary make replacement arithmetic happens truncated otherwise could binary machine example would 1 gamma e2 instead 1 logy would gammae2 plus possibly small multiple depending accurate log function returned value would 0 small multiple instead gammae 3 either case relative error enormous looked special cases program assigns rounded value x recovers error x approximate relative error rounded value quotient xy denote relerr equal x high accuracy high accuracy tested program standard rounding mode ieee 3 arithmetic two elsif clauses needed believe program also valid arithmetic systems reasonable rounding conventions including truncation 24 logb scalb functions need two functions manipulating exponents first returns integer value j x jc x 6 0 use function second function x real n integer unless overflows underflows case appropriate exception raised functions exact provided course overflow underflow second one 25 exceptions examples section 4 exceptions returned overflow underflow domainerror adopted convention overflow returned whenever either one components result overflows overflow try provide component values minor modifications would needed provide values sigma1 appropriate considered desirable appropriate normalized value component overflow underflow could also provided one component underflows value component much larger setting underflowed component zero alter error bound small multiple set underflowed component zero return underflow fact situation occurs csqrt clog csin ccos underflowed component smaller normal component factor e quite arbitrary still set underflowed component zero return underflow increase bound required otherwise criterion setting underflowed component zero met components underflow return underflow described last sentence occur cexp setting underflowed component zero accounted error analysis increases bound 5 system use testing underflow returned try provide component values minor changes would needed provide special values denormalized numbers 3 pseudocode notation needed exception handling construct shown figure 2 calculations enable block normally produce required result enable handle fig 2 exception handling construct enable block would normally produce required result handler takes exception occurs enable block exception occurs course calculations control transferred handle block handler action taken circumvent otherwise cope exceptional situation various ways constructs implemented depending programming language used discuss ways briefly sections 5 6 present purposes matter constructs implemented particular matter whether transfer control takes place soon first exception occurs whether possible ieee environment 3 calculation continues end enable block test made determine whether exception occurred make use intermediate results might obtained enable block assume indication exceptions occurred enable block disappears leaving handler also exception handling constructs nested within handlers constructs however assume indication type exception overflow underflow etc caused transfer control available handler seems appropriate considering impre ciseness interrupts pipelined machines presence parallelism allow exits exception handling constructs except possible returns within handlers whether returns values returns exceptions otherwise pseudocode reasonably selfexplanatory intended provide easytounderstand description algorithms calculating good approximations complex elementary functions implementing programs convenient languages others matter return sections 5 6 4 pseudocode algorithms section present algorithms form pseudocode programs six complex elementary functions required fortran 77 fortran 90 error bounds derived section repeated tabular form section 5 term precision used programs denote number significant digits machine representations real numbers example ieee 3 binary representation single precision 24 41 complex absolute value cabs first consider absolute value function j z j z program figure 3 calculating approximation function based formula result calculation representable real value value z except overflow extreme cases x large main difficulties developing program function dealing possibility spurious overflows underflows since occur rarely calculations good strategy attempt calculate immediately required approximation directly basis formula since efficient reasonably accurate works time approach fails program take time needs look exceptional cases handler first looks special cases x zero otherwise logbx logby exist used determine whether x differ greatly magnitude differ enough smaller j x j neglected otherwise close enough scaled corresponding scaled result calculated without spurious overflows underflows finally scaled value result unscaled provide required result might happen unscaling produce result overflows case overflow must returned error analysis first consider case exception occurs analysis proceeds follows f l since sign f l f l neglected f l f l small multiples ffl 2 neglected thus relative error final result bounded e e sqrt small multiples e 2 neglected straightforward matter check error cannot exceed bound paths handler unless course overflow occurs final unscaling bound therefore valid values input argument long overflow returned function possible exceptions overflow real x integer logbx logby integer precision appropriately initialized x zrealpart zimagpart enable try simplest formula work time answer sqrtx lambda2 handle overflow underflow occurred answer else logbx logbx logby logby exponents different one x ignored answer maxabsx absy else scale scale absx near 1 scaledx scalbx gammalogbx scaledy scalby gammalogbx scaledanswer sqrtscaledx lambda2 enable unscale possible might overflow answer scalbscaledanswer logbx handle must overflow scalb return overflow endif endif return answer fig 3 program absolute value function first attempts approximate directly efficient reasonably accurate almost always successful overflow underflow occurs attempt handler takes manages avoid spurious overflows underflows usually scaling however final result still overflow exceptional cases scaling undone overflow returned function possible exceptions overflow real x x zrealpart zimagpart enable answer sqrtx lambda2 handle must overflow underflow maxmag maxabsx absy enable handle must underflow enable answer maxmag temp handle must overflow return overflow return answer fig 4 alternative figure 3 approach error bound somewhat larger conclude section mention another different approach leads alternative program shown figure 4 noted error bound approach somewhat larger namely 225e 42 complex square root csqrt consider square root function r e i2 r sin2 r r adopt conventions real part nonnegative zero imaginary part also nonnegative otherwise sign sign note neither component overflow function cannot overflow furthermore one components underflows component set zero without altering error bound small multiple according criterion described subsection 25 function cannot underflow avoid loss accuracy due cancellation rewrite finally obtain according sign form mathematical specification satisfies sign conventions stated also avoids possibility loss accuracy due cancellation writing pin place avoids possibility underflow latter form two remaining difficulties taken account program figure 5 one avoid spurious overflows underflows evaluating approximation done way analogous done cabs exception occurs handler first looks cases x zero exponents differ enough depending larger exponent smaller j x j j j ignored corresponding expressions quite simple finally cases scaling used avoid exceptions scaling must done terms even exponent final unscaling terms integer exponent two square root operations required final approximation cannot overflow unlike case final approximation cabs function possible exceptions none real x real sqrt2 appropriately initialized integer logbx logby evennearlogbx integer precision appropriately initialized complex answer x zrealpart zimagpart enable answerrealpart t2 answerimagpart yt answerrealpart absyt answerimagpart signy t2 else answerrealpart temp answerimagpart signy temp endif handle overflow underflow occurred answerrealpart temp answerimagpart signy temp answerrealpart sqrtx answerimagpart 0 else answerrealpart 0 answerimagpart sqrtgammax endif else determine logbx logbx logby logby x ignored ignored else scale unscale scale absx near 1 even exponent evennearlogbx scaledx scalbx gammaevennearlogbx scaledy scalby gammaevennearlogbx scaledt sqrt2 sqrtscaledx lambda2 scaledy endif answerrealpart t2 enable answerimagpart yt handle underflow occurred answerimagpart 0 enable answerrealpart absyt handle underflow occurred answerrealpart 0 answerimagpart signy t2 endif endif return answer fig 5 program square root function first attempts approximate directly successful final approximation p z obtained according whether x overflow underflow occurs attempt handler takes manages avoid overflow underflow two places handler underflow might still occur component involved set 0 approximation obtained approximations real imaginary parts p z easily obtained depending whether x greater less zero remaining difficulty handler approximation j jt might underflow occur program figure 5 replaces underflowed value zero safe still preserve error bound obtained since case part approximation z real part x 0 imaginary part x 0 always well level required subsection 25 situations error analysis first consider case exception occurs begin final result cabs namely f l f l f l binary machines another ffl needed nonbinary machines r f l r f l r binary machines another 05ffl needed nonbinary machines course assuming small multiples ffl 2 neglected binary machines division one components final result x 6 0 means relative error component error component assuming constant sqrt2 initialized within 1 ffl 2 also easily seen errors path exception handler cannot greater thus conclude notation subsection 21 one e r e 2e maximum bound relative error approximation p neglecting small multiples binary machines bound tightened somewhat examining error formula detail subsection 21 f r r r x 0 gives f r r right hand side inequality reaches maximum value large possible however x f less 2e result x 0 bound even smaller 0 thus conclude relative error approximation z bounded q neglecting small multiples binary machines nonbinary machines extra 05ffl bound also division one component well division 2 component x 6 0 error bounds components result equal final relative error bound nonbinary machines therefore neglecting small multiples 43 complex exponential cexp complex exponential function z easily expressed terms real elementary functions x relationship form leads immediately enable block program figure 6 handler expx first tested overflow overflow returned admittedly ignores narrow fringe possible values x overflow could avoided namely values x expx overflows small amount multiplication cosy siny would produce values overflow level chosen ignore fringe values worth trouble detect reinstate however one wishes include one possibility would develop special procedure return separately significand exponent e expx use results procedure determine scalbs cosy e scalbs siny e overflow occur one components actually overflow otherwise handler must cope underflow expx underflows even expx maxj cosy underflow must returned otherwise components underflow one agreed upon function possible exceptions overflow underflow real x real e appropriately initialized complex answer x zrealpart zimagpart enable expx expx answerrealpart expx cosy answerimagpart expx siny handle overflow underflow occurred enable expx expx handle return overf low else return underf low endif cosy cosy siny siny enable handle components underflow return underf low one component underflows underflowed component set zero answerrealpart expx cosy answerimagpart 0 else answerrealpart 0 answerimagpart expx siny endif else return underf low endif return answer fig 6 program complex exponential function handler first deals overflow underflow expx one component underflows determines whether one component safely set zero test case whether used determine whether result setting underflowed component 0 accepted otherwise underflow returned error analysis straightforward absence exceptions relative error real part ffl imaginary part ffl gives overall bound e neglecting small multiples bound somewhat larger case one underflowed part set zero relative error underflowed part 1 relative error overall approximation bounded neglecting small multiples hence cases overall relative error approximation e z bounded q neglecting small multiples provided overflow underflow turned bound turns 5 system use testing 44 complex natural logarithm clog complex natural logarithm z expressed terms components follows gamma arg function approximated fortrans atan2yx evaluate components function convenient first introduce maximum minimum j x j j j respectively exception must returned designated domainerror program figure 7 imaginary part logarithm function easily calculated arg function might underflow real part simply logm shown underflowed part set zero without significant increase error bound main difficulties complex log function arise evaluating real part program first deals case real part simply logm serious difficulty occurs x near 1 accurate approximation log function would require accurate approximation 2 1 cannot obtained directly possible serious cancellation postpone dealing difficulty time first consider cases interval 12 2 ensures 2 2 interval 12 2 remaining difficulty spurious overflow underflow may occur evaluation deal exceptions way analogous cabs csqrt indicated program ignored exponents sufficiently different resulting real part simply logm otherwise scaling used avoid overflow underflow scaled factor radix gammascale logarithm must corrected adding scale theta logradix logarithm scaled value important scaling chosen possibility cancellation addition let us consider case 2 case 14 2 want calculate accurate approximation best way evaluate expression double working precision round result back working precision evaluation done working precision error analysis becomes complicated shall see turns error real part enormous although overall error bound turns less double quite modest bound obtain case doubled precision used doubled precision available could simulated since simulation likely extremely slow may worthwhile avoiding simulation cases cancellation ie 1 cancellation serious ie close magnitude turn error analysis program figure 7 first assume arithmetic binary error bound imaginary part course unless imaginary part underflows underflow occur imaginary part safely set zero already indicated since real part simply logm error bound e log overall relative error bound otherwise real part consider first case 12 exception occurs f l neglect small multiples know j logm 2 2 log 2 relative error bound real part function clog possible exceptions domainerror real x integer scale complex answer real sqrt2 logradix appropriately initialized integer precision appropriately initialized x zrealpart zimagpart return domainerror endif enable answerimagpart argz handle must underflow arg answerimagpart return answer determine real part answerrealpart enable answerrealpart 05 logm handle must overflow underflow ignored answerrealpart else scale exceptions avoided two terms answerrealpart sign must overflow scale else must underflow scale logbm endif scaledm scalbm gammascale scaledm scalbm gammascale scaledr scaledm lambda2 answerrealpart scale logradix endif else enable use doubled precision possible evaluating argument log1p answerrealpart handle must underflow lambda2 answerrealpart endif return answer fig 7 program complex logarithm function first looks three special cases argument zero imaginary part underflows 0 real part calculated way depending whether maxj x outside interval 12 first case scaling may needed cope spurious overflow underflow second case accuracy final result sensitive accurately argument log1p calculated 2e log 2 e log bounded 2886e e log neglect small multiples exception occur bound obviously still valid scaling required scaling required bound valid second term expression real part first term scale logradix bounded 2e logradix stored accurately possible since two terms sign error sum bounded 2886ee log thus cases 12 2 overall relative error bound max2886e neglecting small multiples consider case 2 exception occurs case real part logm error bound e log otherwise need determine errors evaluation affect log1p expression expression evaluated within factor 1 f l log1p neglect small multiples j 2 fflj know show error bound real part h bound j j j doubled precision used evaluated exactly sum two expressions suffer rounding error ffl 2 final rounding working precision presents log1p argument ffl final relative error real part pis therefore bounded 2165e neglect small multiples overall relative error therefore bounded neglect small multiples e 2 provided course domainerror returned completes error analysis program figure 7 argument log1p near end program calculated within factor case doubled precision used evaluate argument 2886 2165 bound must replaced 3886 3165 respectively nonbinary machines multiplication 05 expressions evaluated doubled precision used situation quite bit complicated since serious cancellation may occur evaluation obviously cancellation argument log1p simply accurate within factor 1 case doubled precision 1 also cancellation argument accurate within factor 1 leads us bound replaces 2165 6495 1 cancellation 4m 2 cancellation serious shown case argument accurate within factor 1 bound therefore leaves us situation serious cancellation take place derive following f l log1p hi neglect small multiples second term expression see relative error real part could enormous confirmed tests next section continue towards finding relative error bound overall result see absolute error real part bounded since j turn bounded expression bound e r substituted overall relative error bound developed subsection 21 namely f r r r proceed follows f r considering first part bound e r second part relative j f r j lead overall error bound acceptably small second term obviously bound first term consider two cases one j j imaginary part argz first case j argz j contribution first part relative error bounded since second case j argz contribution first part relative error also turns 4457e thus end overall relative error bound 4457e e log1p case serious cancellation take place collecting together results obtained program figure 7 working precision used throughout established following overall relative error bound clog function neglect small multiples provided course domainerror returned 2886 6495 4457 must increased 1 nonbinary machines multiplication 05 expressions evaluated 45 complex sine csin sine function z xiy represented terms real elementary functions follows program figure 8 based formula overflow occurs evaluation real imaginary parts function coshy sinhy large magnitude probably handler returns overflow case cexp fringe values z real function possible exceptions overflow real x complex answer x zrealpart zimagpart enable answerrealpart sinx coshy answerimagpart cosx sinhy handle enable coshy coshy sinhy sinhy handle must overflow return overflow answerrealpart sinx coshy enable answerimagpart cosx sinhy handle must underflow answerimagpart 0 return answer fig 8 program complex sine function straightforward although acknowledged overflow returned fringe values z whose corresponding real imaginary parts actually slightly overflow threshold imaginary parts sinz slightly overflow threshold even though least one coshy sinhy alone overflow neglected cexp auxiliary procedure computes exponent fraction part expy separately could used avoid situation since sinhy coshy effectively equal expy2 magnitude functions overflow underflow occurs occur multiplication associated imaginary part happens real part much larger underflowed part set zero without significant increase error bound upper bound overall relative error function neglecting small multiples course overflow returned 46 complex cosine ccos cosine function z represented terms real elementary functions follows function possible exceptions overflow real x complex answer x zrealpart zimagpart enable answerrealpart cosx coshy answerimagpart gammasinx sinhy handle enable coshy coshy sinhy sinhy handle must overflow return overflow answerrealpart cosx coshy enable answerimagpart gammasinx sinhy handle must underflow answerimagpart 0 return answer fig 9 program complex cosine function straightforward although acknowledged overflow returned fringe values z whose corresponding real imaginary parts slightly overflow threshold program figure 9 based formula overflow occurs coshy sinhy large magnitude probably csin previous section handler returns overflow also csin fringe values z neglected although could included help auxiliary procedure returns exponent fraction part expy separately underflow occurs occur multiplication associated imaginary part happens real part much larger underflowed part set zero without significant increase error bound upper bound overall relative error function neglecting small multiples course overflow returned 5 special implementations testing implemented algorithms presented section 4 sun 440 fortran 77 compiler version 14 order test correctness especially correctness error bounds implementations special sense table observed error bounds single precision real elementary functions sun library version 14 units e relative error bound single precision real arithmetic result given e sincos 1000 1152 1102 2326 1382 1000 1000 close possible pseudocode descriptions section 4 particular modified way improve efficiency efficiency production implementation issues discussed next section except portion one version clog alternative suggested subsection 44 floating point operations implementations single precision care taken make sure case examined generated assembly language instructions ensure extended precision used intermediate calculations enabled us use corresponding double precision results sun system true results test purposes assume true results correct single precision accuracy exception handling construct implemented allowing enable block executed testing exception flags raised possible ieee environment would natural interpretation use ieee handler traphandling facility provided sun system 6 p 67 turned inefficient somewhat difficult use testing floating point exception flags using ieee flags subroutine 6 p 64 also inefficient instead accessed flags using math library routine swapex test correctness error bounds examples section 4 must first determine bounds turn system using requires determination e etc convenient present units e results given table relative error bounds determined examining relevant single precision arguments except case e sincos considered values argument less 10 6 absolute value case e arg determined bound adding e e atan extra allows additional error induced using f l yx argument atan place yx boundaries arg function least one x 0 also considered bounds log1p sinhcosh 1000e single precision versions functions use correctly rounded results double precision implementations bound version log1p figure 1 uses single precision 2198e results table used determine theoretical bounds column 3 table ii observed bounds column 4 table ii obtained comparing results implementations true results provided sun systems double precision functions large number mostly random input arguments ieee single precision arguments observed bounds occurred given hexadecimal form column 5 random arguments constructed random real parts random imag table ii comparison theoretical observed relative error bounds sun fortran version 14 implementations complex elementary function programs figures 39 columns 3 4 units e relative error bound real arithmetic sp pdp stand ieee single precision partial ieee double precision respectively cexp real csin ccos imag function theoretical bound gamma based table observed bound argument cabs2 225e e sqrt 3250 2495 e0723701 csqrt sqrt cexp clog inary parts generating random exponents random significands within appropriate ranges ten thousand random arguments generated 4 semiaxes 100 000 000 generated 4 quadrants origin also tested regions restricted necessary overflow underflow would avoided time time ensuring good coverage proper domain function many special cases also tested including many near boundaries regions separated points would probably lead exceptions returned points would probably lead exceptions returned important special cases terms trying observe large errors arguments real imaginary parts chosen maximize errors relevant real elementary functions fact special cases produced observed maximums much random testing seen table ii nonexceptional results error would expected basis theoretical error bounds fact theoretical bounds much larger observed bounds sort discrepancy shown table surprising considering kinds reasoning used determining theoretical error bounds especially case two clog functions happens relatively large discrepancy case cabs2 explained ieee arithmetic system satisfies assumed subsection 21 accurate within half unit last place make significant difference error analysis cabs2 special form expression argued contribution expression final relative error bound cabs2 maximum value greater 15 followed argument obtain finally relative error bound 2650 cabs2 place 3250 special mention made results clog version makes use double precision computation argument log1p much accurate terms observed overall relative error bound version uses single precision however real part former much accurate real part latter observed bound 3604e former approximately latter enormous error occurred 3f7ffffc i3a3504f3 observed error bounds imaginary parts equal 2292e course claim experimental results actually prove correctness theoretical error bounds believe evidence convincing however correctness programs involves correctness error bounds values argument lead exceptions returned must also true exceptions returned reasonable otherwise program could considered correct always returned exception matter input argument according subsection 25 overflow returned either component overflows one function programs return overflow particular value input argument test program considers correct return least one components true result within relative error bound true overflow specifically huge largest machine representable number ulpup unit last place huge direction 1 test underflow return correct either 1 components true result within relative error bound true underflow specifically 2 one component underflows nevertheless within error bound greater value within error bound component specifically min j f r min j f r iny smallest positive machine representable number ulpdown unit last place iny direction 0 criteria modified slightly obvious way allow fact fringe areas neglected algorithm cexp csin ccos test case overflow underflow returned test program determined appropriate criterion satisfied exceptional return domainerror clog special case easy check separately 6 production implementations exception handling construct ada reasonably close used paper except unfortunate fact ada recognize underflow exception construct simpler adas expect handler told effect exceptions occurred proposal somewhat like adas recognize underflow proposed fortran 90 rejected favor exception handling facility construct could implemented pl1 elegantly extensions existing languages often provide facilities implementing con struct example providing access trapping exception flags ieee environments already indicated preceding section absence exception handling facilities pretesting used example case cabs j x j j j tested advance make sure overflow underflow occur evaluation x case evaluate expression carry calculations handler using another pretest determine whether final unscaling cause overflow implementation original pretesting determine conditions satisfied sufficient ensure spurious exceptions occur may necessary cases cause program execute handler often necessary course higher precision available may possible avoid pretest ing long exponent range higher precision sufficiently broader example cabs entire calculation done higher preci sion test needs performed result calculation coerced original precision idea little use working precision already highest available apart trying implement exception handling efficient way implementations made slightly efficient mostly writing programs intermediate store operations avoided addition floating point status register would saved entry function subprograms later restored updated include exception flag returned function 7 concluding remarks presented algorithms reliable accurate evaluations complex elementary functions required fortran 77 fortran 90 convenient describe algorithms help exception handling construct implementations fortran sun systems tested extensively observed error bounds 64 98 theoretical bounds convincing evidence correctness theoretical bounds also indicates theoretical bounds quite tight interesting discover choosing arguments near thought largest error might occur usually led observed bounds larger found even extensive random testing one case 13 tests also found exceptions returned reasonable acknowledgments much work inspired discussions members ada numerics working group chairmanship gil myers jim cody particularly helpful early stages investigation also wish thank referees helpful suggestions r american national standard programming language fortran implementing complex elementary functions using exception handling ieee standard binary floatingpoint arithmetic branch cuts complex elementary functions part radian reduction trigonometric functions tr tabledriven implementation logarithm function ieee floatingpoint arithmetic ctr technical report floatingpoint exception handling acm sigplan fortran forum v15 n3 p128 dec 1996 e hull thomas f fairgrieve ping tak peter tang implementing complex arcsine arccosine functions using exception handling acm transactions mathematical software toms v23 n3 p299335 sept 1997 e hull thomas f fairgrieve ping tak peter tang implementing complex arcsine arccosine functions using exception handling acm transactions mathematical software toms v23 n3 p299335 sept 1997 david smith algorithm 786 multipleprecision complex arithmetic functions acm transactions mathematical software toms v24 n4 p359367 dec 1998 david bindel james demmel william kahan osni marques computing givens rotations reliably efficiently acm transactions mathematical software toms v28 n2 p206238 june 2002 milo ercegovac jeanmichel muller complex square root operand prescaling journal vlsi signal processing systems v49 n1 p1930 october 2007 john r hauser handling floatingpoint exceptions numeric programs acm transactions programming languages systems toplas v18 n2 p139174 march 1996
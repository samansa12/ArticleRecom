efficient implementations software architectures via partial evaluation notion flexibility ability adapt changing requirements execution contexts recognized key concern structuring software many architectures designed effect however corresponding implementations often come performance code size overheads source inefficiency identified loose integration components flexibility often present design level also implementation solve flexibility vs efficiency dilemma advocate use partial evaluation automated technique produce efficient specialized instances generic programs supporting case studies consider several flexible mechanisms commonly found software architectures selective broadcast pattern matching interpreters software layers generic libraries using tempo specializer c show partial evaluation safely optimize implementations mechanisms optimization automatic preserves original genericity extensibility implementation b introduction partial evaluation partial evaluation technique partially execute program input data available consider program p requiring two inputs x 1 x 2 specific values 1 2 given two inputs run program producing result one input value 1 given cannot run p partially evaluate producing version p d1 p specialized case x partial evaluation instance program specialization specialized version p d1 p called residual program example consider following c function powern x computes x raised nth power int nx f int p n n 2 else given values 7 compute power57 obtaining result exploits x even integers n suppose need compute powern x great many different values x partially evaluate function obtaining following residual function int x f int p compute power 57 obtain result 7 fact input x computing power 5x produce result computing department computer science university copenhagen universitetsparken 2 department mathematics physics royal veterinary agricultural university thorvaldsensvej 40 dk1871 frederiksberg c denmark power5x since value variable n available partial evaluation say n static conversely variable x dynamic value unavailable example shows strengths partial evaluation residual program power 5 tests arithmetic operations involving n eliminated flow control conditions statements original program completely determined static variable n suppose needed compute powern7 many different values n opposite problem n dynamic unknown x static known little case since flow control determined dynamic variable n one could imagine creating table precomputed values 7 n values n know values relevant many cases control flow determined static variables cases substantial speedups achieved partial evaluation 11 notation consider program two ways function transforming inputs outputs also data object input output programs need distinguish function computed program program text writing p program text write function computed want make explicit language l p written consequently denotes result running program p input lmachine assert power 5 correct residual program c power given input 5 12 interpreters compilers interpreter sint language written language l satisfies program input data running input smachine gives result using interpreter sint run lmachine includes possible nontermination sides compiler stcomp source language generating code target language written language l satisfies p compiled target program p 0 running p 0 tmachine input gives result running p input smachine though equation doesnt specify normally assume compilation always produce target program partial evaluators 21 partial evaluator partial evaluator program performs partial evaluation produce residual program specializing given program respect part input let p lprogram requiring two inputs x 1 x 2 residual program p respect x program p d1 values 2 remaining input partial evaluator program peval given program p part 1 input produces residual program p d1 words partial evaluator peval must satisfy peval socalled partial evaluation equation reads follows partial evaluation p respect 1 produces residual program p d1 running d1 input 2 gives result running program p input 1 compilers equation guarantee termination lefthand side implication contrast compilers however always assume partial evaluation succeed desirable partial evaluation always terminate guaranteed large number existing partial evaluators see sections 22 55 termination issue specified language l partial evaluator written language source programs accepts language residual programs produces languages may different notational simplicity assume note opens possibility applying partial evaluator see instance partial evaluation equation consider 5 must follow power57 22 achieved partial evaluation definition partial evaluator stipulate specialized program must better original program indeed easy write program peval satisfies partial evaluation equation trivial way prepending new specialized function power 5 original program new function simply calls original one given argument int nx f int p n n 2 else int x f returnpower5 x g program correct residual program faster original program quite possibly slower even construction used prove existence partial evaluators proof similar kleenes 1952 proof smn theorem 63 theorem essentially stipulates existence partial evaluators recursive function theory example introduction demonstrated sometimes possible obtain residual programs arguably faster original pro gram amount improvement depends partial evaluator program specialized programs lend spe cialization computation done input known sometimes choosing different algorithm may help cases problem illsuited specialization example specializing power function known value x discussed introduction looking definition power one would think specialization respect value x would give good result assignments involve n executed specialization loop however controlled n since termination condition known cannot fully eliminate loop x p different values different iterations loop cannot replace constants hence find cannot perform computations x p anyway could force unfolding loop keep values x p known since bound number different values x p obtain finite amount unfolding eliminate x p program conflict termination specialization quality residual program common partial evaluator must try find balance ensures termination often enough interesting preferably always yielding sufficient speedup worthwhile due undecidability halting problem perfect strategy exists suitable compromise must found see section 55 subject 3 another approach program specialization generating extension twoinput program p program p gen given value 1 first input p produces residual program p d1 p respect 1 words generating extension takes given value 1 first input parameter x 1 constructs version p specialized x example show generating extension power program introduction int n f printfint xn printff int pn n n 2 else f printf printf returnpn note powergen closely resembles power parts power depend static input n copied directly powergen parts also depend x made strings printed part residual program running powergen input yields following residual program int x f int p almost one shown introduction difference made priori distinction static variables n dynamic variables x p since p dynamic assignments made part residual program even executed specialization time example shown introduction later shall see generating extension constructed applying sufficiently powerful partial evaluator one even construct generator generating extensions way 4 partial evaluation interpreters compila tion 41 compilation using partial evaluator section 12 defined interpreter program taking two inputs program interpreted input program often expect run program repeatedly different inputs hence natural partially evaluate interpreter respect fixed known program unknown input program using partial evaluation equation get using definition interpreter get residual program thus equivalent source program difference language residual program written input output languages partial evaluator identical residual program written language l interpreter sint hence compiled language interpreter interprets l language written 42 compiler generation using selfapplicable partial eval uator seen compile programs partially evaluating terpreter typically want compile many different programs amounts partially evaluating interpreter repeatedly respect different programs situation calls optimization yet another application partial evaluation hence use partial evaluator specialize partial evaluator peval respect program sint without argument sint using partial evaluation equation get peval peval peval sint using results get peval sint recall definition compiler section 12 see peval sint fulfills requirements compiler case input output languages partial evaluator identical language compiler written target language compiler language l interpreter written note guarantee partial evaluation terminates neither producing compiler using experience shown may problem often case compilation terminates general programs terminates note compiler peval sint generating extension interpreter sint according definition shown section 3 generalizes program interpreters partially evaluating partial evaluator peval respect program p yields generating extension p program 43 compiler generator generation seen interesting partially evaluate partial evaluator may want repeatedly partially evaluate partial evaluator respect range different programs eg interpreters may exploit partial evaluation peval peval since generating extension p see peval peval generator generating extensions program peval peval generating extension partial evaluator peval peval peval case p interpreter generating extension p gen compiler hence peval gen compiler generator capable producing compiler interpreter 44 summary futamura projections instances partial evaluation equation applied interpreters directly selfapplication partial evaluator collectively called futamura projections three futamura projections first futamura projection compilation peval second futamura projection compiler generation peval peval third futamura projection compiler generator generation first second equations devised futamura 1971 40 latter independently beckman et al 12 turchin et al 94 around 1975 5 techniques partial evaluation 51 polyvariant specialization polyvariant specialization technique partial evaluation works range languages program thought collection program points connected controlflow edges flowchart language program points controlflow edges respectively labelled basic blocks jumps functional language defined functions function calls logic language predicates predicate applications atoms polyvariant specialization constructs residual program creating zero specialized variants program point connecting residual controlflow edges 511 exponentiation example revisited illustrate polyvariant specialization consider power function section 1 flowchart form explicitly labelled basic blocks lab1 n n 2 goto lab1 goto lab1 lab3 returnp program form specialized given values static variables specializing basic blocks basic block set static variable values may executed one creates specialized basic block residual program polyvariant specialization 24 57 instance basic block labelled lab1 may executed static hence one creates specialized basic block whose label lab1 fn5p1g consists original label bindings static variables body specialized basic block consists specialized residual commands original basic block naturally specialized version jump goto lab jump goto lab fg specialized decorated version lab see works let us specialize program known value unknown value x first get lab1 using information specialize basic block perform conditional ifs statically find n 0 false n 2 0 true must jump lab2 still create residual goto command new specialized label lab2 fn5p1g goto lab2 fn5p1g corresponding specialized basic block block lab2 specialized respect 1 assignment specializes residual since x dynamic means p longer static assignment executed n static new static environment 4 hence goto lab1 specializes goto lab1 fn4g get goto lab1 fn4g note generate constant expression 1 represent static value 1 p residual program say static value p lifted appear residual program next must specialize basic block lab1 respect 4 process continues specialized basic blocks created specialized labels occurring residual program total following residual program obtained goto lab2 fn5p1g goto lab1 fn4g goto lab1 fn2g goto lab1 fn1g goto lab2 fn1g goto lab1 fn0g goto lab3 fn0g returnp simplified replacing jumps gotos code jump called transition compression unfolding result almost section 1 returnp technique polyvariant specialization turns work languages demonstrated later sections functional languages logic languages specialization process builds graph whose nodes specialized program points labels whose edges residual controlflow edges jumps may done maintaining set pending specialized program points still created mapping specialized program points specialized program code fragments basic blocks one repeatedly chooses removes program point pp pending constructs corresponding specialized program code fragment code pp extends mapping pp 7 code pp moreover one extends set pending new specialized labels reachable code pp precisely pending extended set set program points pp 0 jump goto pp 0 code pp begin pending contains programs entry point together initial values static variables empty procedure terminates pending becomes empty case contains residual program process may fail terminate discussed section 55 52 online versus offline partial evaluation two types partial evaluators online partial evaluator kind generalized interpreter needs priori division variables static dynamic partial evaluation environment maps static variables concrete values dynamic variables symbolic expressions processing expression e partial evaluator makes online decision whether evaluate giving concrete value residualize giving residual expression based current bindings variables appearing e offline partial evaluator constrast works two phases first phase bindingtime analysis classifies programs variables definitely static possibly dynamic similarly classifies operations second phase specialization proper phase simply uses staticdynamic classification variables operations processing ex pression evaluateresidualize decisions made offline never uses actual value variable expression unless bindingtime analysis guarantees static hence indeed concrete value since offline partial evaluators rely program analysis usually conservative online partial evaluators missing opportunities specialization hand offline specializers simpler structure may exploit global knowledge program gained bindingtime analysis experience shows harder construct selfapplicable online specializers offline ones hybrids online offline specializers constructed instance one may use threevalued bindingtime analysis classifies variables expressions definitely static definitely dynamic undecided 92 specialization phase obey static dynamic annotations use actual specialization time value variables decide whether evaluate residualize generator generating extensions similar offline partial evaluator since generating extension embodies priori distinction early static inputs late dynamic inputs generator generating extension usually includes bindingtime analysis online partial evaluation studied scheme ruf weise 82 100 many researchers logic programming community 53 bindingtime analysis classification variables static dynamic called division division must congruent value dynamic expression e may assigned variable must made dynamic expression e static contains dynamic variables considering flowchart version power function section 51 see n static x dynamic outset p must classified dynamic p x assigned p whereas n remains static n never assigned dynamic value simple binding time analysis may performed means abstract interpretation variable expression takes one abstract values static dynamic one builds initial division variables except dynamic input parameters assignments program abstractly executed possibly reclassifying variables dynamic satisfy congruence requirement variables need reclassified dynamic alternatively bindingtime analysis may done type inference sub types considered subtype meaning may coerced corresponding lifting static value kind bindingtime analysis may implemented efficiently constraint solving 53 composite data structures tuples records lists considered data structure may partially static instance value variable may whose first component static whose second component dynamic may described bindingtime theta similarly list pairs may described bindingtime theta list type inference approach bindingtime analysis especially useful handling partially static data structures strongly typed languages standard ml pascal c latently typed languages scheme handled essentially considering dynamic expressions untyped division computed bindingtime analysis one must decide operation program whether must evaluated sidualized producing residual code partial evaluation arithmetic operation must residualized unless operands static statement must residualized unless condition static shall assume assignment residualized unless assigned variable static also assume gotos residualized excess gotos may removed subsequent transition compression visualize classification operations annotate dynamic operations underlining power function annotation would lab1 n n 2 goto lab1 goto lab1 lab3 returnp polyvariant specialization program blindly following annotations obtain transition compression returnp result obtained generating extension section 3 generator generating extensions presuppose priori distinction static n dynamic x p variables 54 residual programs containing loops residual program generated contains loops conditionals statically decidable transitions could compressed however machinery section 51 suffices creating residual programs containing loops consider following contrived example n else written flowchart program lab1 n goto lab3 lab2 goto lab3 lab3 goto lab1 lab4 returnsum let us specialize respect static dynamic sum n specializing basic block lab1 respect must create residual version first conditional n dynamic whereas second conditional reduced k static nonzero giving residual jump lab2 fk3g n goto lab2 fk3g next specialize code label lab2 respect goto lab3 fk3g continuing manner obtain residual program n goto lab2 fk3g goto lab3 fk3g goto lab1 fk3g returnsum transition compression get n goto lab1 fk3g returnsum decorated labels lab1 fk3g lab4 fk3g may replaced simple ones lab1r lab4r see partial evaluation eliminated tests k inside loop effectively found loopinvariant loop recreated residual program simply jump lab3 fk3g goes back specialized program point lab1 fk3g beginning program 55 termination partial evaluation transition compression applied care program shown attempt repeatedly unfold remaining occurrences goto lab1 fk3g would never terminate infinite looping due transition compression avoided fairly easily either unfolding jump residual label exactly one way reach label 21 ascertaining unfolding must stop due descending chain condition 87 termination problems caused infinite specialization harder deal illustration consider power program section 51 static straightforward application polyvariant specialization attempt produce infinite residual program n n 2 goto lab1 fx49p1g goto lab1 fx7p7g n n 2 goto lab1 fx2401p1g goto lab1 fx49p49g program incomplete cannot completed using finite number program points insist keeping x p static online partial evaluatior one may recognize configuration similar previously encountered two program points therefore merged single general one eg making x dynamic eventually forces p dynamic also process called generalization offline partial evaluator one may recognize bindingtime analysis tests dynamic decided static variables static data constructed dynamic control sign danger indicating x p made dynamic making specialization completely trivial safe holst developed finiteness analysis used ensure termination polyvariant specialization 54 56 generalized partial evaluation one lesson may learnt partially constructed residual program shown basic block labelled lab3 fx49p1g superfluous reaching would require tests n 0 n 2 0 fail test n2 succeed impossible integral n former two imply 2 superfluous basic block created static environment outlined takes account values static variables x p outcome previously encountered dynamic tests n polyvariant specialization may enhanced giving generalized partial evaluation theorem prover required decide static conditionals decide whether two static environments equivalent 41 certain data domains applications less powerful methods may suffice 46 6 partial evaluation languages 61 functional languages 611 firstorder languages partial evaluation firstorder functional language may done polyvariant specialization described section 51 notions label basic block global variable must replaced notions function name function definition function parameter henceforth specialized program point specialized function name residual program collection specialized function definitions illustration consider functional version power program section 1 using standard ml syntax else n mod else x powern1 x specializing function power respect static dynamic x obtain fun power fn5g power fn4g power fn2g power fn1g power fn0g note specialized function name power fn5g consists original function name power together binding static parameters n residual program may simplified unfolding trivial function calls reducing subexpression x x 1 arising unfolding fun power fn5g power fn2g residual program equivalent generated c version power section 1 bindingtime analysis may proceed flowchart language application f e e may dynamic reclassify formal parameter f dynamic since language firstorder f must known function flowchart languages partial evaluator may either offline online offline partial evaluator perform bindingtime analysis program classify parameters either static dynamic embarking specialization phase proper complete description simple offline self applicable partial evaluator firstorder functional language may found 58 chapter 5 appendix 612 higherorder functional languages polyvariant specialization applied higherorder functional languages functions may passed around values well main new challenges represent static functional values partial evalu ation lift functional values static dynamic specialize respect functional values bindingtime analysis functional value may represented closure g vs consisting function name g together values vs static free variables gs body lifting partially static functional value dynamic value complicated usually avoided offline partial evaluators requiring every partially static functional value must applied argument functional value occurring dynamic context reclassified dynamic bindingtime analysis specializing function f respect fully static functional closure g vs simple specialize respect function name g values vs static free variables specializing f respect partially static g vs involved since body g may dynamic free variables variables may free also residual expression resulting applying g vs hence dynamic must lifted gs body specialization time must passed extra parameters residual function f gvs higherorder functional program may contain applications evaluates function closure analysis provide approximation set functions e 1 may evaluate using information bindingtime analysis may proceed firstorder language 58 chapter 15 alternatively bindingtime analysis may based type inference 53 preferable one wants permit partially static data structures also selfapplicable partial evaluators exist realistic higherorder functional languages scheme 20 21 28 29 31 standard ml 70 well callbyvalue lambda calculus extensions 51 pure lambda calculus 74 75 information see eg 58 chapter 10 full details see abovementioned papers 62 logic programming languages prolog distinguishing feature prolog logic programming languages ability run incomplete input seems similar partial evaluation number differences ffl result running prolog program incomplete input pos sibly infinite list instantiations input output variables though considered list facts hence restricted form program generally want partial evaluator able produce nontrivial residual programs possibly containing loops ffl prolog nonlogical features means running program incomplete input generalization running complete input example calling predicate defined partially instantiated input paa returns result running complete input paa would fail research partial evaluation partial deduction often called logic languages tended avoid second issue working pure logic languages 43 68 systems however deal nonlogical features prolog 76 84 partial evaluation logic languages typically done using basic techniques functional languages call unfolding polyvariant specializ ation program points predicates major source speedup partially evaluating logic programs ability detect failing computations specialization time cut away residual program way static computations also dynamic computations failing branches eliminated partial evaluation makes potential speedup partial evaluation greater logic languages functional imperative languages online specialization preferred technique logic language community usually combined powerful techniques avoiding nontermination 23 71 logic languages online specialization presents opportunities specialization offline specialization unification often instantiate otherwise dynamic variables selfapplication major goal offline specialization used also 52 76 example prolog specialization shown specializes program regular expression matching acceptsr nullabler acceptsrcs firstrc nextrcr1 acceptsr1s program takes regular expression string arguments string empty regular expression tested nullability acceptance empty string string starts character c tested whether among first set regular expression case new regular expression matching rest string produced next predicates nullable first next shown note set cs first succeeds determined r hence partial evaluation first respect known r unknown c yield number instantiations c specializing program respect r regular expression ajb aba yields following residual program accepts3 since nullable depends static values completely eliminated visible failed true cases empty string call first instantiated c b instantiation made possible fully evaluate next yielded total four different regular expressions giving rise specialized version accepts accepts0 regular expression ajb aba accepts1 ajb abajba accepts2 ajb abaja accepts3 ajb abajbajffl 63 full imperative language c seen polyvariant specialization suffices partial evaluation flowchart languages hence simple imperative languages realistic imperative language c includes composite data structures records indexed arrays pointers dynamic data structures functions may side effects global variables etc offline partial evaluator c needs sophisticated bindingtime analysis deal pointers composite data structures instance pointer variable p may dynamic pointer may static point dynamic object pointer pointedto object may static bindingtime analysis may require programs wellbehaved assume array program contains assignment form e e dynamic principle variable program may become dynamic result assignment case address outside allocated array would conservative making partial evaluation trivial instead one require programs wellbehaved address indeed inside taste difficulties caused combination nonlocal side effects recursive functions consider function side effect static global variable side effect controlled dynamic expression dyn int global int stmts else call foo value global may either 1 1 cannot know one partial evaluation time dyn dynamic simplest solution reclassify global dynamic wastes static information might useful partially evaluating stmts another solution unfold call foo giving residual program form int global int f dyn f stmts fglobal1g g else f stmts fglobalgamma1g g stmts fglobal1g specialized version stmts however function foo recursive unfolding impossible third solution introduce dynamic continuation variable cont assigned different value branch residual version foo foo function main call foo switch cont int global int switch cont f case 1 stmts fglobal1g break case 2 stmts fglobalgamma1g break however work foo recursive recursion dynamic control since number paths foo statically bounded case hence recursive procedures feasible option may reclassify global dynamic many problems studied lars ole andersen constructed two systems specialization c programs first one selfapplicable partial evaluator c subset including procedures well pointers arrays 6 8 second one generator generating extensions ansi c 9 latter system licensed university copenhagen techniques c carry eg ada modula pascal little modification knowledge done 7 partial evaluation perspective 71 program specialization without partial evaluator far focused mainly specialization using partial evaluator ideas methods presented indeed used without using partial evaluator specialization hand quite common programmers handtune code particular cases often amounts partial evaluation hand example quote paper 80 programming videogame nevryon manages keep speed basically two ways write routine one complex multipurpose routine everything quickly example sprite routine handle size flip sprites horizontally vertically piece code many simple routines one thing using sprite routine example routine plot sprite one way another plot flipped vertically second method means code required speed advantage dramatic nevryon written way separate sprite routines plotted sprites slightly different ways specialization used doubtful general purpose partial evaluator used specialization instead specialization performed hand possibly without ever explicitly writing general purpose routine forms basis specialized routines using handwritten generating extensions saw section 3 generating extension power function easily produced original code using knowledge variables contained values known specialization time always quite simple example often particularly difficult write generating extensions small medium sized procedures programs situations partial evaluator available often viable way obtain specialized programs using generating extension instead writing specialized versions hand useful either large number variants must generated known advance values program specialized respect common use handwritten generating extensions runtime code generation piece specialized code generated executed runtime sprite example one often generates specialized code plot operation large bitmaps involved typical situation general purpose routine used plotting small bitmaps special code generated large bitmaps specialized routines exploit knowledge alignment source bitmap destination area respect word boundaries well clipping source bitmap aspects scaling differences colour depth etc also targets runtime specialization bitmapplotting code handwritten generating extensions used optimizing parsers specializing respect particular tables 78 converting interpreters compilers 77 handwritten generating extension generators recent years become popular write generating extension generator instead partial evaluator 9 16 55 approach quite old 12 generating extension generator used instead traditional partial evaluator follows specialize program p respect data first produce generating extension p gen apply p gen produce specialized program p conversely selfapplicable partial evaluator produce generating extension generator cf third futamura projection two approaches seem equally powerful write generating extension generator instead selfapplicable partial evaluator reasons ffl generating extension generator written another higher level language language handles whereas selfapplicable partial evaluator must able handle text ffl reason among others may easier write generating extension generator selfapplicable partial evaluator ffl partial evaluator must contain interpreter may problematic typed languages explained neither generating extension generator generating extensions need contain interpreter writing interpreter strongly typed language one must use single type interpreter represent unbounded number types used programs interpreted true partial evaluator single universal type must used static input program specialized hence static input must coded means partial evaluation equation must modified take coding account peval overlining means value coded eg 1 coding value 1 selfapplying partial evaluator static input program program normally represented special data type represents program text data type must coded universal type peval peval double encoding space timeconsuming reported make selfapplication intractable unless special attention paid make encoding compact 67 generating extension produced selfapplication must also use universal type represent static input even though always type observation leads idea making generating extensions accept uncoded static input achieve generating extension generator simply copies type declarations original program generating extension generating extension generator takes single input program need deal arbitrarily typed data generating extension handles values single program types known generating extension constructed hence neither generator generating extensions generating extensions need handle arbitrarily typed values equation specialization using generating extension generator shown note absence coding usually expect generator generation terminate normal partial evaluation allow construction residual program performed gen loop 72 partial evaluation worthwhile section 22 saw cannot always expect speedup partial eval uation sometimes significant computations depend known input virtually work postponed residual program executed even computations appear depend known input evaluating specialization may require infinite unfolding seen section 22 much unfolding residual programs become intractably large hand example section 1 manages perform significant part computation specialization time even partial evaluation pay residual program executed often enough amortize cost specialization must two conditions expect benefit partial evaluation computations depend static data executed repeatedly either repeated execution program whole repetition looping recursion within single execution program static known data obtained several ways may constants appearing program text part input quite common library functions called constant para meters format strings cases partial evaluation may speed programs even input given cases partial evaluator works kind optimizer often achieving speedup optimizing compilers would hand partial evaluators may loop create excessive amount code trying optimize programs hence illsuited default optimizers specialization respect partial input common situation often opportunities speedup exploiting constant parameters cases eg specializing interpreters computation done partial evaluation sometimes yielding speedups order magnitude similar speed difference interpreted compiled programs choice running program interpreted compiled choose former program executed times contains significant repetition whereas want compile run many times involves much repetition principle carries specialization partial evaluation often gets benefit replication loops unrolled index variables exploited constant folding functions specialized respect several different static parameters cases replication result enormous residual programs may undesirable even much computation saved example section 1 amount unrolling hence size residual program proportional logarithm n static input expansion small enough doesnt become problem expansion linear n would acceptable small values n specialization interpreters typically yield residual programs proportional size source program reasonable hand quadratic exponential expansion hardly ever acceptable may hard predict amount replication caused partial evaluator fact seemingly innocent changes program dramatically change expansion done partial evaluation even make difference termination nontermination specialization process similarly small changes make large difference amount computation performed specialization hence speedup obtained similar way parallelizing compilers sensitive way programs writ ten hence specialization offtheshelf programs often require usually minor modification get optimal benefit partial evaluation ideally programmer write program partial evaluation mind avoiding structures cause problems like programs parallel machines best written limitations compiler mind 73 partial evaluation optimizing compilers modern machines many compilers perform transformations constant folding inlining small functions improve target programs transformations similar performed partial evaluator however contrast partial evaluator compiler rarely produces one specialized version given piece code except possibly inlining kind specialization essential partial evaluators must handled correctly also presence loops recursive procedures complex memory hierarchies modern computer hardware hard know program modification actually achieves speedup exploiting memory hierarchy well data registers instruction pipeline two levels cache main memory virtual memory crucial performance modern machines hence may detrimental unroll loop fit cache beneficial inline procedure replaces indirect jumps linear code sequences much unrolling inlining replication perform machine dependent often see optimizations improve performance one machine degrade others increasing degree microparallelism modern microprocessors one may even get benefit eliminating static computations may part critical path hence may executed parallel dynamic computations hand elimination variables specialization reduces register pressure unrolling loops inlining functions increase basic block size giving opportunities lowlevel optimization means hard predict amount speedup obtained partial evaluation examples exist residual program twice fast original program one machine slower original another machine speedup also affected optimizations performed compiling residual programs 8 applications partial evaluation saw section 4 partial evaluation used compile programs generate compilers one main practical uses partial evaluation making compilers c similar languages rapidly obtaining implementations acceptable performance experimental specialpurpose languages since output partial evaluator typically highlevel language traditional compiler used backend compiler generated partial evaluation 1 14 25 27 30 33 61 cases compilation language case purpose make certain computation strategies explicit eg continuation passing style add extra information eg debugging program 20 42 83 93 many types programs eg scanners parsers use table data structure control program often possible achieve speedup partially evaluating tabledriven program respect particular table 7 78 however may produce large residual programs tables unless sparse often represent information compactly code examples converting structural knowledge representation procedural knowledge representation choice two types representation usually determined idea structural information compact easy modify slow use procedural information fast use hard modify less compact automatically converting structural knowledge procedural knowledge overcome disadvantage difficult modifiability procedural knowledge retains disadvantage large space usage section 71 mentioned applications specialization computer graph ics one areas seen applications partial evaluation early example 49 extended form partial evaluation used specialize renderer used flight simulator flight simulator landscape viewed repeatedly different angles though occlusion surfaces depend angle view often case knowledge particular surface occludes another decide occlusion question pairs surfaces hence partial evaluator simulates sorting surfaces cannot decide two surfaces must plotted first leaves test residual program furthermore uses inequalities occlusion test positive negative constraints branches conditional generates constraints used decide later occlusion tests attempting solve constraints simplex method time test cannot decided information added constraint set effectively constrains viewangle allowing later tests decided goad reports typical landscape 1135 surfaces forming triangulation landscape typical depth paths residual decision tree 27 compared 10000 comparisons needed full sort 49 rather extreme speedup due nature landscapes many surfaces almost parallel hence occlude narrow viewing angles another graphics application raytracing raytracing scene rendered tracing rays lines pixel screen imaginary world behind scene testing objects rays hit process repeated rays using fixed scene since may millions pixels hence rays typical raytracing application specialization respect fixed scene unknown ray give speedup even rendering single pictures speedups 6 reported simple raytracer 73 realistic raytracer speedups range 15 3 reported 10 speedup gained several sources rayobject intersection routine specialized object highly parametrized shading colouring function specialized object furthermore representation scene converted procedural form figure 1 example raytraced picture made raytracer 73 picture shows 3d diagram process partial evaluation program p one inputs x fed partial evaluator pe yielding residual program p x partial evaluation also applied numerical computation particular simulation programs programs part model constant simulation parts change specializing respect fixed parts model speedup obtained example nbody problem simulating interaction moving objects gravitational forces simulation masses objects constant whereas position velocity change specializing respect mass objects speed simulation berlin reports speedups 30 problem 15 however residual program written c whereas original one scheme may account part speedup another experiment specialization standard numerical algorithms gave speedups ranging none 5 47 neural networks trained usually run several thousand times number test cases training various parameters fixed eg topology net learning rate momentum specializing trainer parameters speedups 25 50 reported 56 list applications exhaustive give impression range possibilities 9 reading first sketch history 1952 1984 give number pointers literature partial evaluation related topics book jones gomard sestoft 58 includes material subjects mentioned large bibliography updated source text bibliography available anonymous ftp ftpdikudk file pubdikudistsjonesbookpartialevalbibz 91 history kleenes smn theorem 1952 asserts feasibility partial evaluation 63 constructive proof provides design partial evaluator design intended provide improvement specialized program improvement symbolic reductions similar goal subsequent work partial evaluation lombardi probably first one use term partial evaluation 69 futamura first researcher consider partial evaluator program well transformer thus consider application partial evaluator 40 futamuras paper gives equations compilation compiler generation partial evaluation compiler generator generation figure 1 partial evaluation action three equations called futamura projections andrei ershov 38 futamuras early ideas implemented around 1975 beckman haraldsson oskarsson sandewall developed partial evaluator called redfun substantial subset lisp 12 described possibility compiler generator generation double selfapplication turchin group also worked partial evaluation early 1970s context functional language refal gave description selfapplication double selfapplication 94 history work briefly summarized english 95 andrei ershov worked imperative languages used term mixed computation mean roughly partial evaluation 34 35 1984 jones sestoft sndergaard constructed selfapplicable partial evaluator simple firstorder functional language 59 60 86 neither single double selfapplication carried practice time interest partial evaluation logic programming areas increasing background 1987 workshop partial evaluation mixed computation 19 39 subsequent proceedings partial evaluation may found 2 3 4 5 32 88 92 partial evaluators imperative languages early papers partial evaluation imperative languages include 34 36 37 bulyonkov ershov reported selfapplicable partial evaluator flow chart language 25 gomard jones 50 gluck et al created nonselfapplicable specializer numeral algorithms fortran 11 47 andersen 6 8 9 developed two systems specialization c programs see section 63 lisp scheme first major partial evaluator lisp redfun reported beckman et al 12 weise et al constructed fully automatic online partial evaluator subset scheme 100 jones et al constructed self applicable partial evaluator firstorder functional language 59 60 romanenko improved various respects 81 consel constructed selfapplicable partial evaluator schism scheme subset handling partially static structures polyvariant binding times 28 29 31 bondorf danvy constructed selfapplicable partial evaluator similix subset scheme 20 21 standard ml danvy heintze malmkjaer developed partial evaluator pellmell 70 birkedal welinder created generator generating extensions 17 18 refal supercompilation turchin created refal language developed program transformation techniques driving supercompilation generalize partial evaluation 95 96 97 number recent surveys driving supercompilation exist 48 89 90 91 prolog partial evaluation pioneered komorowski 64 65 subsequent work prolog includes 13 44 45 66 93 98 99 sahlin constructed practical nonselfapplicable partial evaluator full prolog 84 85 bondorf mogensen 76 constructed selfapplicable partial evaluator prolog subset gurr one logic language godel 52 jrgensen leuschel created generator generating extensions prolog 62 93 related topics mccarthy used program transformation rules calculational proofs recursive functional programs 72 boyer moore automated proofs kind 22 burstall darlington viewed manual program transformation application types meaningpreserving program rewritings definition instantiation unfolding folding abstraction laws 26 partial evaluation specializes program forwards using knowledge available input conversely program slicing specializes program backwards using knowledge demand output 79 r compiler based partial evalu ation new partial evaluation c automatic compiler generation extended abstract program analysis specialization c programming language partial evaluation applied ray tracing partial evaluation numerical programs fortran partial evaluator partial evaluation procedure logic pro grams compiling scientific code using partial evaluation partial evaluation applied numerical computation partial evaluation standard ml partial evaluation mixed computation automatic autoprojection higher order recursive equations proving theorems lisp functions general criterion avoiding infinite unfolding polyvariant mixed computation analyzer programs adhoc compiler constructs appear universal mixed computation processes transformation system developing recursive programs compiling orparallelism andparallelism new insights partial evaluation schism experiment binding time analysis higher order untyped functional lan guages schism manual dagstuhl seminar partial evaluation compiling embedded languages lisp partial computation principle mixed computation class recursive program schemata essence compilation mixed computation potential applications problems study futamura projections special issue selected papers workshop partial evaluation mixed computation partial evaluation computation process approach compilercompiler generalized partial computation transforming logic programs specialising interpreters tutorial specialisation logic programs lowlevel source transformations logic programs specialisation prolog fcp programs using abstract interpretation generating optimizing specializers application metasystem transition function inversion transformation automatic construction special purpose programs compiler generation partial evaluation partial evaluator untyped lambda calculus efficient type inference higherorder bindingtime analysis finiteness analysis handwriting cogen avoid problems static typing speeding backpropagation algorithm partial evaluation automatic program specialization reexamination basic principles partial evaluation automatic program generation experiment partial evaluation generation compiler generator generating compiler lazy language partial eval uation efficiently generating efficient generating extensions prolog introduction metamathematics specification abstract prolog machine application partial evaluation partial evaluation means inferencing data structures applicative language theory implementation case prolog prolog partial evaluation system stronglytyped selfapplicable partial evaluator partial evaluation logic program ming lisp language incremental computer ml partial evaluation using setbased analysis ensuring global termination partial deduction allowing flexible polyvariance basis mathematical theory computation application partial evaluation raytracing converting interpreters compilers comparative efficiency general residual parsers program specialization via program slicing realm nevryon compiler generator produced selfapplicable specializer surprisingly natural understandable structure specialization online program specializers meta interpreters real mixtus approach automatic partial evaluation full prolog automatic partial evaluator full prolog structure selfapplicable partial evaluator automatic call unfolding partial evaluator special issue partial evaluation turchins supercompiler revisited algorithm generalization positive supercompilation towards unifying partial eval uation cake eat partial evaluation prolog programs application meta programming basic refal implementation computers supercompiler system based language refal concept supercompiler program transformation metasystem transitions prolog metainterpreter partial evaluation application source source transformation queryoptimisation partial evaluation system prolog practical considerations automatic online partial evaluation tr ctr mohan rajagopalan saumya k debray matti hiltunen richard schlichting profiledirected optimization eventbased programs acm sigplan notices v37 n5 may 2002 arvind krishna aniruddha gokhale douglas c schmidt venkatesh prasad ranganath john hatcliff towards highly optimized realtime middleware software productline architectures acm sigbed review v3 n1 p1316 january 2006 arvind krishna aniruddha gokhale douglas c schmidt contextspecific middleware specialization techniques optimizing software productline architectures acm sigops operating systems review v40 n4 october 2006 yasushi shinjo calton pu achieving efficiency portability systems software case study posixcompliant multithreaded programs ieee transactions software engineering v31 n9 p785800 september 2005 annefranoise le meur julia l lawall charles consel towards bridging gap programming languages partial evaluation acm sigplan notices v37 n3 p918 march 2002 jacques carette gaussian elimination case study efficient genericity metaocaml science computer programming v62 n1 p324 september 2006 annefranoise le meur julia l lawall charles consel specialization scenarios pragmatic approach declaring program specialization higherorder symbolic computation v17 n12 p4792 marchjune 2004
robust plane sweep intersecting segments paper reexamine framework robust computation bentleyottmann algorithm reporting intersecting pairs segments plane algorithm reported sensitive numerical errors indeed simple analysis reveals involves predicates degree 5 presumably never evaluated exactly implementations within exactcomputation paradigm introduce two models computation aimed replacing conventional model realnumber arithmetic first model predicate arithmetic assumes exact evaluation signs algebraic expressions degree second model exact arithmetic assumes exact computation value boundeddegree expressions identify characteristic geometric property enabling correct report intersections plane sweeps verification property involves predicates optimal degree 2 straightforward implementation appears highly inefficient present algorithmic variants low degree models achieve performance original bentleyottmann algorithm technique applicable general case curved segments b introduction well known computational geometry traditionally adopted arithmetic model exact computation real numbers model extremely productive terms algorithmic research since permitted vast community focus elucidation combinatorial topological properties geometric problems thereby leading sophisticated eoecient algorithms approach however substantial shortcoming since computer calculations nite precision feature aoeects quality results even validity specic algorithms words model algorithm correctness automatically translate program correctness fact several reports failures implementations theoretically correct algorithms see eg for87 hof89 stateofaoeairs engendered vigorous debate within research community amply documented literature several proposals made remedy unsatisfactory situation split two broad categories according whether perform exact computations see eg approximate computations see eg mil88 hhk89 mil89 paper netunes exactcomputation paradigm numerical computations geometric algorithm basically two types tests predicates constructions clearly distinct roles tests associated branching decisions algorithm determine aeow control whereas constructions needed produce output data approximations execution constructions often acceptable approximations execution tests may produce incorrect branching leading inconsistencies object criticisms leveled geometric algorithms exactcomputation paradigm therefore requires tests executed total accuracy guarantee result geometric algorithm topologically correct albeit geometrically approximate also means robustness principle achievable one willing employ required precision reported failures structurally correct algorithms entirely attributable noncompliance criterion therefore geometric algorithms also characterized basis complexity predicates complexity predicate expressed degree homogeneous polynomial embodying evaluation degree algorithm inria maximum degree predicates algorithm robust adopted precision matches degree requirements idegree criterionj design principle aimed developing lowdegree algo rithms approach involves reexamining degree criterion rich body geometric algorithms known today possibly without negatively aoeecting traditional algorithmic eoeciency previous paper lpt96 considered illustration approach issue proximity queries two three dimensions additional case degreedriven algorithm design paper confront another class important geometric problems caused considerable dif culties actual implementations planesweep problems sets segments shall see planesweep applications involve number predicates dioeerent degree algorithmic power analysis lead new robust implementations outcome substantial practical interest elucidate theoretical level deeper issues pertaining structure several related problems mechanism planesweeps plane sweep intersecting segments given nite set line segments plane segment dened coordinates two endpoints discuss three following problems see figure report pairs segments intersect construct arrangement ie incidence structure graph obtained interpreting union segments planar graph pb3 construct trapezoidal map obtained drawing two vertical line segments walls one one endpoint segments intersection point walls extended either meet another segment innity segments let k number intersecting pairs say segments general position two intersecting segments intersect single point endpoints intersection points distinct rr n 3270 figure 1 inria number intersection points number intersecting pairs segments equal segments general position therefore number vertices k number edges number vertical walls 2n k bounds tight segments general position thus sizes k didnt consider 2dimensional faces either including would change problems address 3 algebraic degree arithmetic models well known eoecient algorithms solve pb1pb3 unstable implemented programs several frustrating experiences reported for85 motivates us carefully analyze predicates involved algorithms rst introduce terminology borrowed lpt96 consider input data ie coordinates endpoint segment variable elementary predicate sign gamma 0 homogeneous multivariate polynomial whose arguments subset input variables degree elementary predicate dened maximum degree irreducible factors rationals polynomials occur predicate constant sign predicate generally boolean function elementary predicates degree maximum degree elementary predicates degree algorithm dened maximum degree predicates degree problem p dened minimum degree algorithm solves p problems computational geometry however aoeects speed andor robustness algorithm important measure precisely rest paper consider degree additional measure algorithmic complexity note qualitatively degree memory requirement similar since arithmetic capabilities demanded given degree must available albeit may never resorted actual run algorithm since input may predicates may evaluated reliably lower precision rr n 3270 consider two arithmetic models rst one called predicate arithmetic degree numerical operations allowed evaluations predicates degree algorithms degree therefore implemented exactly predicate arithmetic model degree model motivated recent results show evaluating sign polynomial expression may faster computing value see abd model however conservative since nonavailability arithmetics required predicate assimilated entirely random choice value predicate second model called exact arithmetic degree demanding assumes values signs polynomials degree represented computed exactly ie roughly dfold precision integers however higherdegree operations eg multiplication one whose factors dfold precision integer appropriately rounded typical rounding rounding nearest representable number less accurate rounding also adequate demonstrated later let algorithm degree input data bbit integer size monomial occuring predicate upper bounded 2 b1d moreover let v number variables occur predicate geometric problems particular considered paper v small constant follows algorithm degree requires precision log v exact arithmetic model degree 4 predicates pb1pb3 use following notations coordinates point denoted x means xcoordinate point smaller xcoordinate point j similarly j denotes line segment whose left right endpoints respectively j denotes line containing means point lies line 41 predicates pb1 requires check two line segments intersect predicate 2 0 inria pb2 requires addition ability sort intersection points along line segment predicate 4 pb3 requires ability execute predicates listed two predicates appear algorithms report segment intersections 42 algebraic degree predicates analyze algebraic degree predicates introduced proposition 1 degree predicates 0 proof rst provide explicit formulae predicates evaluating predicate 2 equivalent evaluating sign implemented follows case 0 x 2 otherwise exchange roles 0 1 2 3 rr n 3270 else return false else else return false therefore cases predicate 2 0 reduces predicate 2 intersection point l given 1 predicate 4 reduces evaluating orienti 0 1 intersection follows 1 equivalent evaluating sign explicit formulas predicates 3 4 5 immediately deduced coordinates intersection points given 1 4 clear equation 1 common factor x inria intersect predicate 3 0 reduces predicate 2 otherwise reduces predicate 3 discussion shows degree predicates 0 establish exactly shown appendix polynomials predicates 2 3 4 0 5 well factor involved predicate 4 irreducible rationals follows proposition proved predicatesrecalling requirements various problems terms predicates proposition 2 algebraic degrees pb1 pb2 pb3 respectively 2 4 5 43 implementation predicate 3 exact arithmetic degree 2 useful sequel show implement predicate 3 degree exact arithmetic degree 2 equation 1 know predicate 3 written convenience let x stipulate employ aeoating point arithmetic conforming ieee 754 standard gol91 standard simple precision allows us represent bbit integers double precision allows us represent 53 coordinates endpoints segments represented simple precision computations carried double precision denote phiomega ff rounded arithmetic operations theta ieee 754 standard four arithmetic operations exactly rounded ie computed result aeoating point number best approximates exact result rr n 3270 polynomials degree 2 four terms x 01 x 21 b inequality 2 computed exactly following monotonicity property direct consequence exact rounding arithmetic operations monotonicity property 21omega x 01 theta b x 21 theta implies comparison two computed expressions x x 21omega evaluates predicate 3 except numbers equal algorithms intersection point compared many endpoints therefore eoecient compute store coordinates intersection point perform comparisons computed abscissae rather evaluating 2 repeatedly illustrate eoeective rounding procedure xcoordinates intersection points lemma 3 coordinates endpoints segments simple precision integers abscissa x intersection point rounded one two nearest simple precision integers using double precision aeoating point arithmetic operations proof assume coordinates endpoints segments represented bbit integers stored simple precision aeoating point numbers computations carried double precision rounded value x x given 21omega bxe denotes integer nearest x tie breaking rule strict bound modulus relative error arithmetic operations 21omega following relations x21 inria 21omega round x nearest integer b xe since b xe x 1 b error addition therefore x b 2bit integer absolute error x smaller 1 2 follows hypothesis lemma e endpoint intersection point corresponding rounded point following monotonicity property holds monotonicity property notice monotonicity property necessarily hold two intersection points remark 1 result similar lemma 3 obtained priest pri92 points aeoating point coordinates precisely endpoints segments represented simple precision aeoatingpoint numbers priest pri92 proposed rather complicated algorithm uses double precision aeoating point arithmetic rounds x nearest simple precision aeoating point number stronger result also implies monotonicity property 44 algebraic degree algorithms naive algorithm detecting segment intersections pb1 evaluates thetan 2 predicates thus degree 2 degreeoptimal proposition although timecomplexity naive algorithm worstcase optimal since 1 worth looking output sensitive algorithm whose complexity depends n k chazelle edelsbrunner ce92 shown lower bound pb1 therefore also pb2 pb3 recent algorithm balaban bal95 solves pb1 optimally log n time using space algorithm solve pb2 pb3 since uses predicate 3 0 degree 3 rr n 3270 pb2 solved rst solving pb1 subsequently sorting reported intersection points along segment easily done simple algorithm degree 4 using space direct asymptotically eoecient solution pb2 proposed chazelle edelsbrunner ce92 time complexity log algorithm constructs arrangement segments degree 4 solution pb3 deduced solution pb2 onk time using complicated algorithm chazelle cha91 deterministic simple algorithm due bentley ottmann bo79 solves pb3 n time slightly suboptimal using space classical algorithm uses sweepline paradigm evaluates n predicates types discussed therefore degree 5 incremental randomized algorithms cs89 bds construct trapezoidal map segments thus solve pb3 degree 5 time complexity space requirements optimal though expected performances paper revisit bentleyottmann algorithm show variant degree 3 instead 5 solve pb 1 sacrice performance section 61 although algorithm slightly suboptimal respect time complexity much simpler balabans algorithm also present two variants sweep line algorithms rst one section 62 uses predicates degree 2 applies restricted important special case segments belong two subsets non intersecting segments second one section 7 uses exact arithmetic degree 2 results based noneoecient lazy sweepline algorithm presented section 5 solves pb1 evaluating predicates degree 2 remark 2 segments general position number intersection points less number k intersecting pairs extreme algorithms adapted time complexities depend rather k bms94 however lower bound degree algorithms 4 since must able detect two intersection points identical therefore evaluate predicate 4 0 inria 5 lazy sweepline algorithm let set n segments whose endpoints succint review standard algorithm rst sorts increasing xcoordinates stores sorted points priority queue x next algorithm begins sweeping plane vertical line l maintains data structure represents subset segments currently intersected l ordered according ordinates intersections l intersections detected correspondence adjacencies created either insertiondeletion segment endpoints order exchanges intersections intersection upon detection inserted x according abscissa course given intersection may detected several times multiple detections resolved performing preliminary membership test intersection x omitting insertion intersection previously recorded stipulate use another policy resolve multiple detections namely remove x intersection point whose associated segments longer adjacent event reinserted x segments become adjacent policy also advantage reducing storage requirement bentleyottmanns algorithm bro81 describe modication sweepline algorithm need process intersection points increasing xcoordinates first algorithm sorts endpoints segments increasing xcoordinates array x sorted list endpoints algorithm uses also dictionary stores ordered subset line segments algorithm rests denitions active prime pairs given low need following notations denote le vertical line passing denotes open vertical slab bounded le denotes semiclosed slab obtained adjoining line open slab two segments k l denote kl rightmost left endpoint b kl leftmost right endpoint kl common point intersect see figure 2 addition w kl denotes set segment endpoints belong closed region bounded vertical lines two segments double wedge denote kl recently processed element w kl f kl element w kl processed next note e kl f kl always dened since may res rr n 3270 l kl kl f kl kl kl figure 2 denitions w gamma kl kl pectively coincide kl b kl lastly dene sets w kl kl follows k l intersect w kl kl consists points otherwise endpoint e 2 w kl belongs w kl resp w gamma kl slab resp contain kl denition 4 let k l pair segments assume without loss generality k le kl pair said active following conditions satised inria 1 k l adjacent 2 3 f kl kl observe emptiness condition implies segments intersect denition 5 pair active segments k l said prime next element processed belongs w kl therefore f kl kl say intersection active pair processed algorithm reports exchanges members updates set active pairs segments accordingly sorting segment endpoints lazy sweepline algorithm works follows active pairs algorithm selects processes active pairs algorithm proceeds next endpoint ie inserts removes corresponding segment appropriate updates set active pairs actually next endpoint may accessed prime pairs subset active pairs without placing deadline processing current active pairs long prime active pairs endpoints processed algorithm stops reasons clear algorithm specied nest detail since several dioeerent implementations possible main issue eoecient detection active prime pairs several solutions consistent described lazy algorithm discussed sections 6 7 noted deciding pair intersecting segments active prime reduces evaluation predicates 2 therefore algorithm described involves predicates 1 2 degree 2 proposition 1 also pointed two intersection points even intersection point endpoint wont necessarily processed order xcoordinate consequence wont necessarily represent ordered set segments intersecting vertical line l standard algorithm respectively snapshots data structure immediately processing event rr n 3270 segment e one endpoints let order relation denoted theorem 6 predicates 1 2 evaluated exactly described lazy sweepline algorithm detect pairs segments intersect proof algorithm correctly sorts endpoints segments increasing xcoordinates x consequently set segments intersect le set segments e coincide endpoint e proof theorem articulated two lemmas implications lemma 7 two segments exchanged positions intersect pair processed proof let us consider two segments say k l intersect without loss generality let k l assume contradiction l k positions never form active pair therefore l k gamma b kl happen exists segment l stage execution algorithm present together k l caused one following two events occur 1 sm l positions sm k exchanged 2 sm k positions sm l exchanged cases segments exchange positions consecutive violating condition 1 denition 4 therefore two segments exchange positions intersect happen intersection processed moreover intersection processed segments longer active cannot exchange positions second time 2 say endpoint e correctly placed subset segments e plane coincides subset segments inria otherwise e said misplaced lemma 8 predicates 1 2 evaluated exactly endpoints every segment correctly placed proof assume contradiction e rst endpoint misplaced algorithm misplaced exist least two intersecting segments k l gamma e e belongs w kl proof first recall predicate 2 predicate involved placing consider rst case e left endpoint pair k l segments gamma e either k l relative position respect k l depend relative order k l gamma e therefore e correctly placed e right endpoint since left endpoint correctly placed e misplaced exists segment intersecting relative positions 0 rightmost left endpoint 0 change executed algorithm ie 0 relative position l two segments gamma e e 2 w kl assume without loss generality k l e kl since e rst endpoint misplaced k le kl convenience say two segments p q exchanged e 0 e 00 two events rr n 3270 case e kl cause dioeculty since k l cannot active e kl e therefore k l cannot exchanged e kl e implies e correctly placed respect k l case e kl dioecult e correctly placed k l exchanged e kl e ie k l shall prove possible therefore conclude correctly placed case well assume contradiction k l exchanged e kl e e belongs w kl l cannot adjacent gamma e since otherwise would constitute prime pair would exchanged subsequence segments occurring k l assume k l pair intersecting segments e kl r minimal ie subsequence shortest direct consequence denition following belong w sects l e cannot belong w distinguish two following cases intersects l left le k l correctly placed rst endpoint misplaced misplaced gamma e follows claim 2 e l le e rst endpoint misplaced l since pair l active e k l e therefore cannot exchanged inequality holds gamma e contradicts denition k case entirely symetric previous one suoeces exchange roles k l reverse relations since contradiction reached cases lemma proved 2 complete proof theorem previous lemma implies endpoints correctly processed indeed let e endpoint e right endpoint simply remove corresponding segment update set inria active segments done exactly since predicates degree 2 evaluated correctly e left endpoint correctly placed basis previous lemma lemma also implies pairs intersect processed indeed two intersecting segments p lb pq lemma shows p q gamma b pq implies pair p q processed lemma 7 concludes proof theorem 2 remark 3 handling degenerate cases cause dioeculty previous algorithm work minor changes initial sorting endpoints take order relation compatible order xcoordinates eg lexicographic order remark 4 theorem 6 applies directly pseudosegments ie curved segments intersect one point lemmas 7 8 also extend case monotone arcs may intersect one point precise lemma 7 replace iintersectj iintersect odd number timesj lemma 8 proof unchanged provided dene w kl kl subset w kl consisting endpoints e slab e contains odd number resp none even number intersection points consequence lazy algorithm still uses detect pairs arcs intersect odd number times remark 5 line segments observe checking whether pair segments active require know therefore maintain e kl fact replace condition 3 denition active pair following condition two denitions identical kl x e kl pair active since lemma 8 condition 2 denition wont satised rr n 3270 6 eoecient implementations lazy algorithm predicate arithmetic model dioeculty eoeciently implement lazy sweepline algorithm using predicates degree 2 ie predicate arithmetic model degree 2 due verication emptiness condition denition 4 condition expressed denition 5 one easily check various known implementations sweep achieve straightforward verication emptiness condition introducing algorithmic complications following subsection describes eoecient implementation lazy algorithm predicate arithmetic model degree 3 second subsection improves result special important instance pb1 namely case two sets nonintersecting segments algorithm presented uses predicates degree 2 61 robustness standard sweepline algorithm shall run lazy algorithm predicate arithmetic model degree 3 capability correctly compare abscissae intersection endpoint rene lazy algorithm following way let e last processed endpoint let e i1 endpoint processed next active pair k l occurs processed intersection point kl lies right e right slab free endpoints interior pair adjacent segments encountered intersect within slab active moreover intersection points prime pairs belong slab follows instance lazy algorithm need explicitly check whether pair active therefore much eoecient lazy algorithm section 5 algorithm basically original algorithm bentley ottmann becomes predicates degree 3 evaluated recall standard algorithm requires capability correctly execute predicates degree 5 policy concerning multiple detections intersections stipulated beginning section 5 inria therefore conclude following theorem theorem 9 predicates 1 2 3 evaluated exactly standard sweepline algorithm solve pb1 appropriate brieaey comment implementation details described modied algorithm data structure implemented usual dic tionary data structure x however even simpler standard algorithm uses priority queue dictionary access x primary component realized static dynamic search tree abscissae endpoints points secondary data structure le j realized conventional linked list containing arbitrary order adjacent intersecting pairs remember intersecting pair le j active insertion performed one ends access reporting plane sweep reaches slab eoeect constanttime removal pair due loss adjacency however pointer could maintained xed member pair say one smaller left endpoint lexicographic order record stored x notice described insertionremoval policy guarantees elements x correspond pairs adjacent segments ensures one record pointed member nally observe segment adjacency arising execution algorithm must tested intersection however intersecting pair adjacent segments eligible insertion x long plane sweep gone beyond slab containing intersection question regards running time beside initial sorting endpoints creation corresponding primary tree time log n easily seen intersection uses olog n time amortized thereby achieving performance standard algorithm finally note predicates degree 2 evaluated correctly algorithm bentleyottmann may fail report set intersecting pairs segments see figure 3 example remark 6 fact sweep line algorithm need sort intersection points already observed myers mye85 schorn sch91 myers use solving robustness problems developing algorithm expected running time log n k schorn uses fact decrease rr n 3270 figure 3 computed xcoordinate intersection point 1 2 erroneously found smaller xcoordinate left endpoint 3 3 4 correctly inserted 2 1 respectively intersection 3 4 detected observe missed intersection point arbitrarily far intersection point involved wrong decision inria precision required sweep line algorithm fold three fold ie schorns algorithm uses exact arithmetic degree 3 using theorem 6 show section 7 double precision suoeces 62 reporting intersections two sets nonintersecting line segments subsection consider two sets line segments plane b blue set r red set two segments b similarly r intersect problem arises many applications including union two polygons merge two planar maps denote n b n r cardinalities b respectively let mairson stol ms88 proposed algorithm works arcs curve well line segments time complexity log n k optimal requires space case line segments asymptotic timebound obtained chazelle et al cegs94 chazelle edelsbrunner ce92 latter algorithm restricted two sets nonintersecting line segments algorithms proposed nievergelt preparata np82 guibas seidel gs87 case segments b r edges subdivision convex faces exception algorithm chazelle et al cegs94 algorithms construct resulting arrangement therefore degree 4 algorithm chazelle et al requires sort intersection points two segments vertical line passing endpoint therefore degree 3 propose instead algorithm computes intersections arrangement algorithm uses predicates degree 2 time say point e vertically visible segment b 2 b vertical line segment joining e b intersect segment b notion applicable r two intersecting segments b 2 b r vertical line right br segment intersects l b r ie b r adjacent let br denote wedge dened b r slab l li kl rr n 3270 algorithm based following observation contains blue endpoints contains blue endpoint vertically visible b similarly br contains red endpoints contains red endpoint vertically visible r proof suoecient condition trivial prove necessity assume without loss generality r subset blue endpoints belong br ch e upper convex hull clearly vertices ch e vertically visible b 2 algorithm two phases second one lazy algorithm section 5 rst one considered preprocessing step help eoeciently nd active pairs segments specically objective develop quick test emptiness condition based previous lemma preprocessing phase aimed identifying candidate endpoints potential belonging wedges formed intersecting adjacent pairs referring b analogously r rst sweep segments b construct blue segment b lists b l b blue endpoints vertically visible b lie respectively b sweep takes time log n constructed lists sorted increasing abscissa since intersection point predicates degree 2 used total size lists r l r mentioned crucial point decide whether wedge br pair intersecting segments b r adjacent contains endpoints segments without loss generality assume r b endpoints exist br contains either blue vertex ch red vertex ch show using predicates degree 2 lists preprocessed time log n deciding whether br contains endpoints done time olog n using predicates degree 2 assuming moment primitive available execute plane sweep algorithm described earlier specically sweep b r simultaneously inria using lazy sweepline algorithm section 5 time detect pair adjacent intersecting segments b r decide time olog n whether active active using predicates degree 2 sum results section following theorem theorem 11 given n line segments plane belonging two sets b r two segments b analogously r intersect exists algorithm optimal degree 2 reports intersecting pairs using storage return implementation primitive described suppose segment r constructed upper convex hull detect olog n time element list say lies segment r specically rst identify among edges slopes respectively smaller greater slope r requires evaluation olog predicates degree 2 remains decide whether common endpoint e two reported edges lies line containing r answered evaluating orientation predicate oriente r crucial requirement adopted data structure ability eoeciently purpose propose following solution data structure associated list r represents upper convex hull ch similarly data structure associated list l represents lower convex hull ch implies binary search convex hull slopes uniquely identies test vertex since elements list already sorted increasing xcoordinates data structures constructed time proportional sizes therefore time total easily checked orientation predicates degree 2 involved process guarantee availability ch ensure data structure eoeciently handle deletion elements elements deleted order increasing abscissa done amortized olog per deletion hs90 hs96 follows preprocessing lists takes time uses space requires evaluation predicates degree 2 adopt policy processing active pairs next endpoint rr n 3270 7 eoecient implementation lazy algorithm exact arithmetic model degree 2 shall run lazy algorithm section 61 exact arithmetic model degree 2 ie predicates 1 2 evaluated exactly predicate 3 implemented exact arithmetic degree 2 explained section 43 several intersection points may found abscissa endpoint rene lazy algorithm following way let e last processed endpoint let endpoint abscissa strictly greater abscissa e processed next active pair k l processed intersection point found lie right e right e i1 claim policy leads eoecient verication emptiness condition indeed intersections prime pairs belong kl monotonicity property kl found crucial observation drastically reduces time complexity following pair adjacent segments k l encountered whose intersection point found lie slab active kl e kl indeed since kl found x e i2 monotonicity property implies kl x e i2 therefore checking pair active suoecient consider next endpoint theorem 6 therefore applies two endpoints xcoordinate algorithm use data structures algorithm section 61 time complexity clearly bentleyottmanns algorithm otherwise construct x distinct abscissae endpoints store endpoints identical xcoordinates secondary search structure endpoints sorted ycoordinates secondary structure allow determine pair active logarithmic time binary search conclude following theorem theorem 12 exact arithmetic model degree 2 instance lazy algorithm described solves pb1 inria 8 conclusion pursuing investigations context exactcomputation para digm paper illustrated important problems segment sets intersection report arrangement trapezoidal map viewed equivalent realram model computation distinct arithmetic degree taken account sheds new light robustness issues intimately connected notion algorithmic degree illustrates richness new direction research example shown wellknown planesweep algorithm bentley ottmann uses machinery strictly necessary appropriately modied report segment intersections arithmetic capabilities close optimal sacrice performance another result work exact solutions problems obtained even approximate even random evaluations predicates performed specically using less powerful arithmetic demanded application able compute vertices arrangement line segments constructing arrangement may dioeerent actual one may even correspond set straight line segments still vertex set work shows sweepline algorithm robust usually believed proposes practical improvements leading robust implementations provides better understanding sweeping line paradigm key technique relax horizontal ordering sweep one step similar attemps aimed though dioeerent purposes mye85 ms88 eg89 host interesting open questions remain one question devise outputsensitive algorithm reporting segment intersections optimal time complexity optimal algorithmic degree 2 would also interesting examine planesweep paradigm general example regard construction voronoi diagrams plane one elucidate reasons apparent gap algorithmic degrees fortunes planesweep solution optimal divideandconquer incremental algorithms rr n 3270 acknowledgments indebted h brnnimann pointed error previous version paper devillers discussions lead lemma 3 pion teillaud yvinec also gratefully acknowledged comments work r optimal algorithm applications random sampling online algorithms computational geometry computing exact geometric predicates using modular arithmetic single precision jochen k degeneracy geometric computations algorithms reporting counting geometric intersections introduction higher algebra comments ialgorithms reporting counting geometric intersectionsj eoecient exact evaluation signs determinants optimal algorithm intersecting line segments plane algorithms bichromatic line segment problems polyhedral terrains triangulating simple polygon linear time applications random sampling computational geometry topologically sweeping arran gement computational geometry practice computational geometry software engineering towards geometric computing environment eoecient exact arithmetic computational geometry every computer scientist know aeoating point arithmetic computing convolutions reciprocal search robust set operations polyhedral solids problems accuracy robustness geometric computation applications semidynamic convex hull algorithm robust proximity queries implicit voronoi diagrams double precision geometry general technique calculating line segment intersections using rounded arithmetic oe log e properties aeoating point arithmetics numerical stability cost accurate computations robust algorithms program library geometric com putation robust adaptive aeoatingpoint geometric predi cates towards exact geometric computation tr ctr olivier devillers alexandra fronville bernard mourrain monique teillaud algebraic methods arithmetic filtering exact predicates circle arcs proceedings sixteenth annual symposium computational geometry p139147 june 1214 2000 clear water bay kowloon hong kong ferran hurtado giuseppe liotta henk meijer optimal suboptimal robust algorithms proximity graphs computational geometry theory applications v25 n12 p3549 may leonardo guerreiro azevedo ralf hartmut gting rafael brand rodrigues geraldo zimbro jano moreira de souza filtering raster signatures proceedings 14th annual acm international symposium advances geographic information systems november 1011 2006 arlington virginia usa menelaos karavelas ioannis z emiris root comparison techniques applied computing additively weighted voronoi diagram proceedings fourteenth annual acmsiam symposium discrete algorithms january 1214 2003 baltimore maryland elmar schmer nicola wolpert exact efficient approach computing cell arrangement quadrics computational geometry theory applications v33 n12 p6597 january 2006
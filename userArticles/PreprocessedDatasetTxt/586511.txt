unifying approach goaldirected evaluation goaldirected evaluation embodied icon snobol built notions backtracking generating successive results therefore always something challenge specify implement article address challenge using computational monads partial evaluationwe consider subset icon specify monadic semantics list monad consider spectrum monads also fit bill relate example derive continuation monad church encoding list monad resulting semantics coincides gudemans continuation semantics iconwe compile icon programs specializing interpreter ie using first futamura projection using typedirected partial evaluation various back ends including runtime code generator generate ml code c code ocaml byte code bindingtime analysis partial evaluation continuationbased interpreter automatically give rise c programs coincide result proebstings optimized compiler b introduction goaldirected languages combine expressions yield multiple results backtracking results generated one time expression either succeed generate result fail expression fails control passed previous expression generate next result control passed back original expression order try whether succeed time goaldirected programming specifies order subexpressions retried thus providing programmer succint powerful controlflow mechanism wellknown goaldirected language icon 11 backtracking language feature complicates semantics imple mentation gudeman 13 gives continuation semantics goaldirected language continuations also used implementations languages control structures similar goaldirected evaluation prolog 3 15 30 proebsting townsend implementors icon compiler java observe continuations compiled ecient code 1 14 nevertheless dismiss notoriously dicult stand target languages directly support 23 p38 instead compiler based translation scheme proposed proebsting 22 based fourport model used describing control flow prolog 2 icon expressions translated flowchart language conditional direct indirect jumps using templates subsequent optimization amongst things reorders code performs branch chaining necessary produce compact code reference implemention icon 12 compiles icon byte code byte code executed interpreter controls control flow keeping stack expression frames article present unified approach goaldirected evaluation 1 consider spectrum semantics small goaldirected language relate deriving semantics gudemans 13 instantiations one generic semantics based computational monads 21 unified approach enables us show equivalence dierent semantics simply systematically furthermore able show strong conceptual links dierent semantics continuation semantics derived semantics based lists streams results churchencoding lists streams respectively 2 link semantics implementation semanticsdirected compilation using partial evaluation 5 17 particular bindingtime analysis guides us extract templates specialized interpreters templates similar proebstings partial evaluation give rise similar flowchart programs demonstrating templates good ideathey intrinsic semantics icon provably derived rest paper structured follows section 2 first describe syntax monadic semantics small subset icon instantiate semantics various monads relate resulting semantics present equivalence proof two section 3 describe semantics directed compilation goaldirected language section 4 concludes 2 semantics subset icon intuitive explanation goaldirected evaluation given terms lists listmanipulating functions consequently introducing subset icon treated paper define monadic semantics terms list monad show also stream monad two dierent continuation monads used give example prove equivalence resulting monads using monad morphism 21 subset icon programming language consider following subset icon intuitively icon term either fails succeeds value succeeds subsequently resumed case either succeed fail process ends expression fails informally succeeds value succeeds sum subexpressions e 1 e 2 called succeeds value e 1 subsequent resumption yields rest integers value e 2 point succeeds value e 2 larger value produces results produces results e 3 generators nested example icon term 4 5 7 generates result expressions 4 5 4 6 4 7 concatenates results functional language scheme ml haskell achieve eect icon terms using functions map concat example define fun ml evaluating concat map 6 4 5 6 7 list integers produced icon term 4 5 7 22 monads semantics computational monads introduced structure denotational semantics 21 basic idea parameterize semantics monad many language ex tensions adding store exceptions carried simply instantiating semantics suitable monad correspondence join figure 1 monad operators types standard monad operations unit join l join l l special operations sequences empty empty l empty l append l figure 2 list monad proofs semantics arising instantiation dierent monads conducted modular way using concept monad morphism 28 monads also used structure functional programs 29 terms programming languages monad described unary type constructor three operations unit map join types displayed figure 1 operations socalled monad laws hold section 24 give denotational semantics goaldirected language described section 21 anticipating semanticsdirected compilation partial evaluation describe semantics terms ml eect defining interpreter semantics int parameterized monad represents sequence values type xjoin else append unit figure 3 monadic semantics subset icon 23 monad sequences order handle sequences structure needed addition three generic monad operations displayed figure 1 add three operations empty append empty stands empty sequence empty discriminator function given sequence two additional inputs returns first input sequence empty returns second input otherwise append appends two sequences straightforward instance monad sequences list monad l displayed figure 2 lists join sometimes also called flatten ml concat 24 monadic semantics monadic semantics goaldirected language described section 21 given figure 3 explain semantics terms list monad literal interpreted expression yields exactly one result consequently mapped singleton list using unit semantics given terms bind2 function type int int int list type function bind2 l list list list ie takes two lists containing values type function mapping list values type eect definition bind2 l f xs ys 1 map f x ys x xs 2 flatten resulting list lists steps found example end section 21 eect goaldirected evaluation achieved ml using lists 25 spectrum semantics following describe four possible instantiations semantics given figure 3 semantics corresponds directly interpreter thus create four dierent interpreters 251 listbased interpreter instantiating semantics list monad figure 2 yields listbased interpreter eager language ml listbased interpreter always computes results behavior may desirable situation first result interest matter whether exists result consider example conditional examines whether given expression yields least one result fails alternative use laziness 252 streambased interpreter implementing list monad figure 2 lazy language results monad finite lazy lists corresponding interpreter generates one result time eager language eect achieved explicitly implementing data type streams ie finite lists built lazily thunk used delay computation definition corresponding monad operations straightforward 253 continuationbased interpreter gudeman 13 gives continuationbased semantics goaldirected language derive semantics instantiating monadic semantics continuation monad c defined figure 4 typeconstructor c continuation monad defined r r r called answer type continuation conceptual link list monad continuation monad answer type list list made church encoding 4 higherorder representation lists proposed hughes 16 hughes observed constructing partially applied concatenation function ys xs ys rather list xs lists appended constant time resulting representation empty list corresponds function appends ele ments ie identity whereas function appends single element standard monad operations unit join special operations sequences empty c empty c xs ys append c figure 4 continuation monad represented partially applied cons function cons churchencoding data types means abstracting selector functions case cons resulting representation lists typed indeed corresponds c answer type notice nil cons list representation yield empty c unit c respectively similarly remaining monad operations correspond usual list operations figure 5 displays definition operations inlined resulting expressions reduced 254 interpreter explicit success failure continuations tailrecursive implementation continuationbased interpreter icon uses explicit success failure continuations result interpreting icon expression type int first argument success continuation second argument failure continuation note success continuation takes failure continuation second argument failure continuation determines resumption behavior icon term success continuation may later apply c else figure 5 continuation semantics failure continuation generate results corresponding continuation monad c 2 standard monad operations continuation monad displayed figure 4 sequence operations empty empty c 2 xs ys append continuation monad figure 4 conceptually linked list monad present continuation monad linked stream monad church encoding data type streams x fact second component stream thunk suggests one give selector function type int 1 1 1 resulting type end x xs int choosing result type selector functions yields type continuation monad answer type interpreter defined semantics starting point semanticsdirected compilation described section 3 figure 6 displays definition monad operations inlined resulting expressions reduced basic monad operations c 2 c semantics based c 2 c dier definitions leq handled jto c 2 else figure semantics success failure continuations 26 correctness far related various semantics presented section 25 con ceptually four dierent interpreters presented section 25 created instantiating one parameterized semantics dierent monads formal correspondence proof conducted modular way building concept monad morphism 28 n two monads h n monad morphism preserves monad operations 1 ie following lemma shows semantics resulting two dierent monad instantiations related defining monad morphism two sequence monads question n monads sequences specified section 23 h monad morphism n every icon expression e strengthen definition monad morphism somewhat considering sequence preserving monomorphism also preserves monad operations specific monad sequences proof induction structure e lemma eect shown induction use lemma 2 show listbased interpreter section 251 continuationbased interpreter section 253 always yield comparable results proposition 3 let show c l defined show unit l x xs empty l show expressions e proof show 1 h l c defined unit c x h xs monad morphism l c 2 function show h identity function lists proposition follows immediately lemma 2 27 conclusion taking intuitive listbased semantics subset icon starting point defined streambased semantics two continuation semantics inital semantics defined instantiation monadic semantics list monad semantics defined stream monad two dierent continuation monads respectively modularity monadic semantics allows us relate semantics relating corresponding monads conceptually formally best knowledge conceptual link listbased monads continuation monads via church encoding observed known continuations compiled ecient code relatively easily 1 14 following section show partial evaluation su cient generate ecient code continuation semantics derived section 254 3 semanticsdirected compilation goal partial evaluation specialize source program two arguments fixed static argument result residual program must yield result applied dy namic argument original program applied static dynamic arguments ie p interest partial evaluation due use semanticsdirected com pilation source program p interpreter static argument term domain p p compiled version represented implementation language p often possible implement interpreter functional language based denotational semantics starting point functional interpreter implementing denotational semantics figure 6 source language interpreter shown figure 7 section 31 present icon interpreter written ml section 31 32 33 use typedirected partial evaluation specialize interpreter icon terms yielding ml code c code ocaml byte code output partialevaluation techniques could applied yield essentially results structure struct datatype icon icon plus icon icon leq icon icon icon icon icon figure 7 abstract syntax icon terms 31 typedirected partial evaluation used typedirected partial evaluation compile icon programs ml standard exercise semanticsdirected compilation using typedirected partial evaluation 9 typedirected partial evaluation approach oline specialization higherorder programs 8 uses normalization function map value trivially specialized program dps text target program input typedirected partial evaluation bindingtime separated program static dynamic primitives separated implemented ml source program conveniently wrapped functor parameterized structure dynamic primitives functor instantiated evaluating primitives running source program residualizing primitives specializing source program 311 specializing icon terms using typedirected partial evaluation case dynamic primitives operations addition add integer comparison leq fixedpoint operator fix conditional functional cond quoting function qint lifting static integers dynamic domain signature primitives shown figure 8 residualizing primitives let partial evaluator produce functions generate ml programs meaningful variable names 8 parameterized interpreter shown figure 9 main function eval takes icon term two continuations res res yields result type res intend specialize interpreter static icon term keeping continuation parameters k f dynamic consequently residual programs parameterized two continuations continuations also considered static residual programs would simply list generated integers signature type tunit type tint type tbool type res val qint int tint val add tint tint tint res val fix tint res tint res tint res figure 8 signature primitive operations output typedirected partial evaluation text residual program residual program long betaeta normal form contain beta redexes fully etaexpanded respect type example 4 following result specializing interpreter respect icon 4 7 fix fn loop0 fn i0 cond leq i0 qint 7 fn loop0 add i0 qint 1 qint struct fun loop pfix fn walk pcond pleq j fn walk padd pqint 1 fun select pcond pleq j fn k j f f fun sum fun eval lit eval toe1 eval e1 fn eval e2 fn j loop eval pluse1 eval e1 fn eval e2 fn j sum eval leqe1 eval e1 fn eval e2 fn j select eval ife1 e2 eval e1 fn fn eval e2 k f fn eval e3 k f figure 9 parameterized interpreter 312 avoiding code duplication result specializing interpreter figure 9 may exponentially large due continuation parameter k duplicated clause example specializing interpreter icon term 100 yields following residual program context cond leq qint 1 qint 2 code duplication wellknown problem partial evaluation 17 equally wellknown solution bind continuation residual program used introduce new primitive save two arguments k g applies g two copies continuation k signature res val save succ succ succ res res final clause interpreter modified save continuation parameter proceeds follows fun eval lit eval ife1 e2 save k fn k0 k1 eval e1 fn fn eval e2 k0 f fn eval e3 k1 f specializing new interpreter icon term yields following residual program context add100 occurs save fn v0 fn resume0 k add qint 100 v0 fn resume0 fn k00 k10 cond leq qint 1 qint 2 two copies continuation parameter k bound k0 0 k1 0 continuation used twice body second lambda order prevent code duplication passing one copy continuation parameter actually enough translation c introduced section 32 uses two dierently named variables case k00 k10 determine ifbranch inside continuation applied 32 generating c programs residual programs long betaeta normal form type tint tunit res res tunit res res imposes restrictions residual program must take two arguments success continuation res failure continuation res must produce value type res also consider types primitives may occur residual programs see values type res result applying success continuation k integer n function type tunit res applying failure continuation f applying primitive cond boolean two functions type tunit res applying primitive fix function two arguments loop n res tint integer inside function passed fix applying function loop n integer applying primitive save two arguments first function two arguments vn tint resumen tunit res second function pair arguments k 0 type tint tunit res res inside first function passed save applying function resumen inside second function passed save applying one functions n integer function type tunit res similar analysis applies values type tint arise evaluating integer n variable variable vn applying add two argument type tint result observe residual programs specializing icon interpreter using typedirected partial evaluation restricted grammar figure 10 restriction variables loop n vn resume n must occur inside function binds cannot expressed using contextfree grammar problem development expressed grammar ml datatype used datatype represent output typedirected partial evaluation thus essentially used type system ml theorem prover show following lemma lemma 5 residual program generated applying typedirected partial evaluation interpreter figure 9 generated grammar figure 10 idea generating grammars residual programs studied eg malmkjr 20 used runtime specializer tempo generate code templates 6 f cond e fn fn fix fn loop n fn e loop n e save fn vn fn resumen resume n vn add e e leq e e figure 10 grammar residual programs simple structure output programs allows viewed programs flowchart language choose c concrete example language figure 11 12 show translation residual programs c programs translation replaces function calls jumps except call resume n occurs result compiling ifstatements name function uniquely determines corresponding label jump jumps resume n end two dierent places corresponding two copies continuation use boolean variable gate n distinguish two possible destinations calls loop n kn pass arguments names formal parameters known n vn respectively therefore arguments passed assigning variable jump translation conditional new label l must generated entire translated term must wrapped context defines labels succ fail corresponding initial continuations statements following label succ allowed jump resume translation figure 11 12 generates c program successively prints produced integers one one lemma eect translation residual ml programs c semantics preserving would require giving semantics c subset ml presented figure 10 showing equivalence example 6 consider icon 4 7 example 4 translated following c program loop0 i0 7 goto l0 goto fail goto succ succ printfd value goto resume goto succ resume f cond e fn fn e e goto l l fix fn loop n fn e goto loop save fn vn fn resumen succn resumen goto resume 0 gate goto resume figure translating residual programs c statements qint figure 12 translating residual programs c expressions resume goto loop0 succ printfd value goto resume c target programs corresponds target programs proebstings optimized templatebased compiler 22 eect automatically generating flowchart programs denotation icon term 33 generating byte code previous two sections developed two compilers icon terms one generates ml programs one generates flowchart programs section unify two composing first compiler third authors automatic runtime code generation system ocaml 25 composing second compiler handwritten compiler flow charts ocaml byte code 331 runtime code generation ocaml runtime code generation ocaml works deforested composition traditional typedirected partial evaluation compiler ocaml byte code deforestation standard improvement runtime code generation 6 19 26 removes need manipulate text residual programs specialization time result instead generating ml terms runtime code generation allows typedirected partial evaluation directly generate executable ocaml byte code specializing icon interpreter figure 9 icon 7 using runtime code generation yields residual program 110 bytecode instructions functions implemented closures calls implemented tailcalls compiling residual ml program using ocaml compiler yields 90 bytecode instructions 332 compiling flow charts ocaml byte code modified translation figure 11 12 produce ocaml bytecode instructions instead c programs result embedding icon ocaml using 4 7 yields 36 bytecode instructions functions implemented labelled blocks calls implemented assignment argument passed followed jump style target code promoted steele first compiler scheme 27 34 conclusion translating continuationbased denotational semantics interpreter written ml using typedirected partial evaluation enables standard semanticsdirected compilation icon terms ml compilation residual programs c yields flowchart programs corresponding produced proebstings icon compiler 22 4 conclusions issues observing list monad provides kind backtracking embodied icon specified semantics icon parameterized monad considered alternative monads proven also provide fitting semantics icon inlining continuation monad particular yields gudemans continuation semantics 13 using partial evaluation specialized interpreters respect icon programs thereby compiling programs using first futamura projection used combination typedirected partial evaluation code generation either ml c ocaml byte code generating code c particular yields results similar proebstings compiler 22 gudeman 13 shows continuation semantics also deal additional control structures state expect diculties scaling codegeneration accordingly monad lists hand oer enough structure deal eg state possible ever create rich enough monad combining list monad monads state monad 10 18 observation traditional partial evaluation generalization success continuation avoids code duplication proebsting presents problematic compiler also studying results defunctionalizing continuations la reynolds 24 obtain stackbased specifications corresponding runtime architectures acknowledgments thanks due anonymous referees comments andrzej filinski discussions work supported esprit working group appsem httpwwwmdchalmerssecsresearch semanticsappsem r compiling continuations understanding control prolog programs implementing prolog functional programming calculi lambdaconversion tutorial notes partial evalua tion general approach runtime specialization application c representing layered monads icon programming lan guage implementation icon programming language denotational semantics goaldirected language representing control presence firstclass continuations prological features functional settingaxioms implementations reverse partial evaluation automatic program generation combining monads optimizing ml runtime code generation abstract interpretation partialevaluation algo rithms computational lambdacalculus monads simple translation goaldirected evaluation new implementation icon language definitional interpreters higherorder programming languages phd thesis two price one composing partial evaluation compilation steele jr comprehending monads monads functional programming easy implementation pil prolog lisp tr novel representation lists application function reverse implementation icon programming language computational lambdacalculus monads representing control presence firstclass continuations denotational semantics goaldirected language compiling continuations partial evaluation automatic program generation tutorial notes partial evaluation optimizing ml runtime code generation general approach runtime specialization application c representing layered monads icon programmng language definitional interpreters higherorder programming languages typedirected partial evaluation semanticsbased compiling combining monads monads functional programming ctr mitchell wand dale vaillancourt relating models backtracking acm sigplan notices v39 n9 september 2004 dariusz biernacki olivier danvy chungchieh static dynamic extents delimited continuations science computer programming v60 n3 p274297 may 2006
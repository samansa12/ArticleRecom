using program slicing software maintenance program slicing applied software maintenance problem extending notion program slice originally required variable line number decomposition slice one captures computation given variable ie independent line numbers using lattice single variable decomposition slices ordered set inclusion shown slicebased decomposition programs formed one delineate effects proposed change isolating effects single component decomposition gives maintainers straightforward technique determining statements variables may modified component may using decomposition set principles prohibit changes interfere unmodified components provided semantically consistent changes merged back original program linear time b introduction kill code 32 gerald weinberg alludes private list worlds expensive program errors top three disasters caused change exactly one line code one involved change single digit previously correct program argument goes since change one line usual mechanisms change control could circumvented course results catastrophic weinberg offers partial explanation unexpected linkages ie value modified variable used place program top three list ignominy attributed linkage recently special section march 1987 issue ieee transactions software engineering schneidewind 30 notes one reasons maintenance difficult hard determine code change affect piece code present herein method maintainers use addresses issue may view software maintenance less intellectually demanding activity development central premise work software maintenance demanding added difficulty due large part semantic constraints placed maintainer constraints loosely characterized attempt avoid unexpected linkages 4 14 addressed problem attempting eliminate semantic constraints providing maintainer tool pinpoint potential inconsistencies changes implemented makes maintenance appear like development since programmer need worry linkages change made tool invoked inconsistencies located one would expect tool would proceed resolve inconsistencies shown problem nphard 14 thus maintainer presented problem difficult resolve original change take opposite view present maintainer semantically constrained problem let construct solution implements change within constraints semantic context propose constrain maintainer one prohibit linkages portions code maintainer want change approach uncovers potential problems earlier aforementioned methods believe worth inconvenience may encountered due imposition constraints program slicing based techniques give assessment impact proposed modifications ease problems associated revalidation reduce resources required maintenance activities work unstructured programs usable older systems may used whitebox spareparts backbone maintenance without regard whether maintenance corrective adaptive perfective preventive background program slicing introduced weiser 33 36 technique restricting behavior program specified subset interest slice sv n program p variable v set variables statement n yields portions program contributed value v statement n executed sv n called slicing criteria slices computed automatically source programs analyzing data flow control flow program slice added advantage executable program slicing done implicitly programmers debugging 33 35 slices combined isolate sections code likely contain program faults significantly reduce debugging times 23 24 25 flurry recent activities slicing plays significant role horwitz reps et al 15 16 28 use slices integrating programs results built seminal work ottenstein ottenstein 7 27 combining slicing robust representation afforded program dependence graphs korel laski 20 21 22 use slices combined execution traces program debugging testing choi et al 6 use slices traces debugging parallel programs reps wang 29 investigated termination conditions program slices hausler 13 developed denotational approach program slicing gallagher 8 improved lyles 23 algorithm slicing presence gotos developed techniques capturing arbitrarily placed output statements discuss slicing techniques paper instead refer interested reader works since want avoid getting bogged details particular language identify program flowgraph node graph correspond single source language statement define yes 1 else inword f 22 g 26 g figure 1 program sliced henceforth term statement mean node flowgraph using common representation scheme makes presentation clear although clear tool based techniques need account nuances particular language paper also ignore problems introduced dead code source program declare programs consideration dead code see 8 slicing based techniques eliminate dead code figures 26 illustrate slicing program figure 1 bare bones version unix utility wc word count taken 19 program counts number characters words lines text file slightly modified illustrate clearly slicing principles slices figures 24 complete programs compute restriction specification slice nw fig 2 output number words file slice nc fig count number characters input text file slice fig count number lines file 3 using slices decomposition section presents method using slices obtain decomposition program objective use slicing decompose program directly two components program slice one components construction two step process first step build one variable decomposition slice union certain slices taken certain line numbers given variable component decomposition called complement also obtained original program complement constructed way certain statements decomposition slice removed original program program remains slice define yes 1 else inword f 22 g 26 g figure 2 slice nw26 word counter 22 g 26 g figure 3 slice nc26 character counter 22 g 26 g figure 4 slice nl26 line counter else inword f 22 g 26 g figure 5 slice inword26 22 g 26 g figure slice 1 input 6 print figure 7 requires decomposition slice corresponds complement sense defined given criteria respect variables defined program thus complement also program slice decomposition slice used guide removal statements systematic fashion construct complement insufficient merely remove slice statements original program since require slice executable certain crucial statements necessary slice complement example start slice figure 2 remove statements original program resulting object even compile use decomposition break program manageable pieces automatically assist maintainer guaranteeing ripple effects induced modifications component use complement provide semantic context modifications decomposition slice complement must remain fixed change decomposition ideas presented section independent particular slicing method slice obtained slicing algorithm program decomposition may computed clearly quality decomposition affected quality slice sense refined slices give finer granularity also deliver semantic information maintainer program slice dependent variable statement number decomposition slice depend statement numbers motivation concept easily explained using example figure 7 slice st 4 statements 1 2 3 4 slice st 6 statements 1 2 5 6 slicing statement last case 6 program insufficient get computations involving slice variable decomposition slice captures relevant computations involving given variable construct decomposition slice borrow concept critical instructions algorithm dead code elimination presented kennedy 18 brief reprise follows usual method dead code elimination first locate instructions useful sense declared critical instructions typically dead code elimination algorithms start marking output instructions critical usedefinition 18 chains traced mark instructions impact output statements code left unmarked useless given computation v set statements program p output variable v let last last statement p let flastg statements sv form decomposition slice v denoted sv decomposition slice union collection slices still program slice 36 include statement last variable output may still used decomposition criteria also capture defining computation decomposition variable last statement displays value successfully take slice statement last invoke one crucial differences slicing definitions reps weiser lyle work reps slice must taken point respect variable defined referenced p weisers slices taken arbitrary variable arbitrary line number difference prohibits reps slicing techniques applicable current context since want slice every variable program last statement begin examine relationship decomposition slices place use decomposition slices perform actual decompositions determine relationships take decomposition slice variable program form lattice decomposition slices ordered set inclusion easier gain clear understanding relationship decomposition slices regard without output statements may seem unusual light definition since used output statements obtaining relevant computations view output statements windows current state computation contribute realization state coincides informal definition slice statements yield portions program contributed value v statement n executed assuming output statements contribute value variable precludes discussion output statements therefore programs output values reused case random access files output files later reopened input moreover describing decomposition technique dependent particular slicing technique way knowing whether slicing technique includes output statements say slice outputrestricted output statements removed restricted decomposition slices sv sw independent would peculiar program independent decomposition slices would share neither control flow data flow effect would two programs nonintersecting computations disjoint domains merged together lattice would two components otts slice metric terminology 26 independence corresponds low coincidental temporal cohesion outputrestricted decomposition slices independent said weakly dependent sub sequently speak independence dependence slices always context outputrestricted decomposition slices definition 3 let sv sw outputrestricted decomposition slices w 6 v let sv ae sw sv said strongly dependent sw thus outputrestricted decomposition slices strongly dependent independent slices independent definitions independence dependence presented herein dependent notion slice analogous definitions used bergeretti carre 3 define slices otts metric terminology 26 strong dependence corresponds high sequential functional cohesion strong dependence decomposition slices binary relation cases however always need explicit reference containing slice henceforth write sv strongly dependent shorthand sv strongly dependent slice sw context permits definition 4 outputrestricted slice sv strongly dependent slice said maximal maximal decomposition slices ends lattice definition gives motivation output restriction want concerned possible effects output statements maximality slices decomposition slices observed considering decomposition slices nw inword figures 2 5 regarded output statements defining maximal could force slice inword maximal addition print statement referencing inword along others end program statement would collected slice nw since added statement slice slice inword would maximal figure 8 gives lattice desire snc snl snw maximal decomposition slices sinword strongly dependent snw sc strongly dependent decomposition slices decomposition slices snw snc snl figures 2 4 weakly dependent maximal output statements removed independent decomposition slices example recall independent decomposition slices cannot share control flow surrounding control statements would make dependent begin classify individual statements decomposition slices definition 5 let sv sw outputrestricted decomposition slices program p statements called slice dependent statements snc snl snw sinword sc figure 8 lattice decomposition slices slice independent statements statements slice dependent refer slice dependent statements slice independent statements dependent statements independent statements dependent statements contained decomposition slices interior points lattice independent statements maximal decomposition slice union decomposition slices properly contained maximal slice terms arise fact two slices depend computation performed dependent statements independent statements contribute computation slice modifying program dependent statements cannot changed effect ripple focus interest example statement 12 slice nc fig 3 slice independent statement respect decomposition slice statements 13 14 slice nl fig also slice independent statements respect decomposition slice decomposition slice c fig 6 strongly dependent slices thus statements slice dependent statements respect decomposition slice statements 6 1520 slice nw fig 2 slice independent statements respect decomposition slices snc snl sc statement 19 slice independent compared sinword statements 6 1518 20 decomposition slice inword fig 5 slice independent statements respect decomposition slices snc snl sc statements slice independent compared snw relationship maximal slices independent statements proposition permits us apply terms slice independent statement slice dependent statement sensible way particular statement given maximal decomposition slice without reference binary relation decomposition slices required definition 5 proposition 1 let 1 varsetp set variables program p 2 sv outputrestricted decomposition slice p 3 let 4 let statements sv gamma u2u independent proof umg u2u end relationship maximal slices program recall dead code excluded discussions proposition maximalg proof statements p m2m sm dead code end maximal slices capture computation performed program maximal slices respective independent statements also related proposition 3 outputrestricted decomposition slice maximal iff least one independent statement proof suppose sv maximal definition sv least one statement slice statement independent statement suppose sv independent statement slice slice contains maximal end conversely slice independent statements strongly dependent also another characterization strongly dependent slices proposition 4 let 1 varsetp set variables program p 2 sv outputrestricted decomposition slice p 3 let strongly dependent swg 4 let 5 let outputrestricted decomposition slice sv strongly dependent sd iff u2u proof suppose sv strongly dependent need show maximal slice partially order set inclusion let one maximal elements element maximal properly contained another slice 1 contains sv 2 6 v sv makes contribution union suppose u2u makes contribution union proposition 3 sv strongly dependent end position state decomposition principles given maximal outputrestricted decomposition slice sv program p delete independent output statements p denote program p v call complement decomposition slice sv respect p henceforth speak complements always context decomposition slices decomposition slice subset program computes subset specification complement computes rest specification figures 9 11 give complements slices nw nc nl figures 4 using proposition 4 obtain complement slice inword slice c entire program 22 g 26 g figure 9 nw complement slice nw computes line count character count yields approximation direct sum decomposition program preserves computational integrity constituent parts also indicates useful decompositions done maximal decomposition slices complement p maximal slice decomposed decomposition may continued slices independent statements ie maximal ones obtained practice maintainer may find strongly dependent slice starting point proposed change method permit changes change may viewed properly extending domain partial function program computes preserving partial function original domain 4 application modification testing statement independence used build set guidelines software modification need make one set definitions regarding variables appear independent dependent statements definitions give set rules maintainers must obey order make modifications without ripple effects unexpected linkages rules obeyed algorithm merge modified slice back complement effect change driving motivation following development restrictions must placed modifications decomposition slice complement remains intact definition 6 variable target dependent assignment statement called dependent vari able alternatively equivalently assignments variable independent statements variable called independent variable assignment statement independent statement target independent variable program figure 12 two maximal decomposition slices sa se figures 13 14 slice figure 15 strongly dependent sa sf figure 16 strongly dependent sb sa sd sc shown strongly dependent maximal slices sa statements 8 10 11 independent proposition variables b targets assignment statements 6 5 respectively decomposition slice sa variable f independent variable define yes 1 else inword f 22 g 26 g figure 10 nc complement slice nc computes word count line count define yes 1 else inword f 22 g 26 g figure nl complement slice nl computes character count word count 3 int b c e f figure 12 dependent variable sample program 3 int b c e f figure 13 slice 3 int b c e f figure 14 slice e 3 int b c e f figure 15 slice b 3 int b c e f figure 16 slice f similar argument applies independent control flow statements reference dependent variables dependent variable independent statement corresponds situation variable question required compilation complement statement question contribute complement variable referenced dependent statement necessary complement cannot independent decomposing single variable yields strongly dependent slice able construct slice original slice variable independent variable proposition 5 let 1 varsetp set variables program p 2 sv strongly dependent output restricted decomposition slice p 3 let strongly dependent swg 4 let 5 let u2u variable v independent variable words sv strongly dependent slice union maximal slices upon sv strongly dependent v independent variable proof show complement p references v variable v complement maximal slice complement upon sv strongly dependent contradicts hypotheses complement references v variable v independent end interpreted variable version proposition 1 refers statements addressed problem presented decomposition slice variable maximal variable remains dependent situation occurred example beginning chapter slice variable figure 13 maximal variable dependent solution straightforward construct slice union slices variable dependent proposition 6 let 1 varsetp set variables program p 2 sv output restricted decomposition slice p 3 dependent variable swg 4 let two cases thus empty also case v independent variable 2 e 6 empty variable v independent variable proof case 1 sv contains references v particular sv contains assignments v v independent variable sv end case 1 case 2 contains references v particular contains assignments v v independent variable end case 2 end proposition variables 41 modifying decomposition slices position answer question posed beginning section present restrictions collection rules justifications modifications take three forms additions deletions changes change may viewed deletion followed addition use second approach determine statements decomposition slice deleted forms statements added must rely fact union decomposition slices slice since complementary criteria usually involve one maximal variable also assume maintainer kept modified program compilable obtained decomposition slice portion software needs changed locating code may highly nontrivial activity sake current discussion assume completion since independent statements affect data flow control flow complement rule 1 independent statements may deleted decomposition slice reason independent statements affect computations complement deleting independent statement slice impact complement end result applies control flow statements assignment statements statement may deleted even assignment statement targets dependent variable control statement references dependent variable point keep mind statement independent affect complement independent statement deleted certainly effect slice purpose methodology keep complement intact number situations consider statements added progress simple complex also note additions new variables may introduced long variable name clash name complement instance new variable independent decomposition slice following independent variable means independent variable new variable rule 2 assignment statements target independent variables may added anywhere decomposition slice independent variables unknown complement thus changes cannot affect computations complement end type change permissible even changed value flows dependent variable figure 13 changes permitted assignment statement line 8 targets f change would propagate values dependent variables b lines 10 11 maintainer would responsible changes would occur variables lines 10 11 dependent ie contained another decomposition slice line 8 would also contained slice variable f would dependent adding control flow statements requires little care required control statements two parts logical expression determines flow control actions taken value expression assume side effects evaluation logical expressions discuss addition ifthenelse statements since language constructs realized 5 rule 3 logical expressions output statements may added anywhere decomposition slice inspect state computation anywhere evaluation logical expressions inclusion output statement even affect computation slice thus complement remains intact end must guarantee statements controlled newly added control flow interfere complement rule 4 new control statements surround ie control dependent statement cause complement change suppose newly added code controls dependent statement let c criteria yield complement using criteria modified program newly added control code included complementary slice due fact dependent statements slice complement thus control statements control dependent statements also slice complement end making change violated principle complement remain fixed thus new control statements may surround dependent statement short list necessary sufficient keep slice complement intact also impact testing change discussed later changes may required computations involving dependent variable v extracted slice maintainer choose one following two approaches 1 use techniques previous section extend slice v independent slice 2 add new local variable slice copy value new variable manipulate new name course new name must clash name complement technique may also used slice independent statements ie strongly dependent 42 merging modifications complement merging modified slice back complement straightforward key understanding merge operation comes observation technique maintainer editing entire program method gives view program unneeded statements deleted dependent statements restricted modification slice gives smaller piece code maintainer focus rules previous subsection provide means deleted restricted parts cannot changed accidentally present merge algorithm 1 order statements original program following examples one statement per line ordering merely line numbering program slice complement identified subsequence statement numbers original program call sequence numbering slice slice sequence numbering complement complement sequence view editing process addition deletion associated sequence numbers 2 deleted statements delete sequence number slice sequence observe since independent statements deleted number complement sequence 3 statements inserted slice new sequence number needs generated let p sequence number statement preceding statement inserted let least value slice sequence greater p let insert new statement sequence number 2 although works principle practice care needs taken generation insertion sequence numbers avoid floating point errors 10 inserts 4 merged program obtained merging modified slice sequence values ie statements complement sequence thus unchanged dependent statements used guide reconstruction modified program placement changed statements within given control flow arbitrary becomes clearer editing process viewed modification entire program following example help clarify 43 testing change since maintainer must restrict changes independent newly created variables testing reduced testing modified slice thus need regression testing complement eliminated two alternative approaches verifying change needs testing first slice original criteria plus new variables minus eliminated variables compare complement complement original match exactly second approach preserve criteria produced original complement slicing must produce modified slice exactly axiomatic consideration illumines idea slice complement perform subset computation computations meet dependencies modifying code independent part slice leaves independent part complement invariant slice vice versa required change merely module replacement preceding techniques still applicable slice provide harness replaced module complete independent program supporting module obtained one principle benefits slicing highlighted context side effects module replaced also slice thus full impact change brought attention modifier example make changes snw slice nw word counter figure 2 changed slice shown figure 17 original program determined word string non white symbols terminated white symbol space tab newline modification changes ch isspacec isalphach ch 22 g 26 g figure 17 modified slice nw word counter requirement alphabetical characters terminated white space example illustrating change advocating note changes deleted independent variables yes added new totally independent variable ch revamped independent statements addition c macros isspace isalpha safe since results referenced test program independently complement figure shows reconstructed modified program taking decomposition slice nw generates program figure 17 complement already given figure 9 starred statements indicate new statements would placed using line number generation technique 5 new software maintenance process model usual software maintenance process model depicted figure 19 request change arrives may adaptive perfective corrective preventive making change wish minimize defects effort cost maximizing customer satisfaction 12 software changed subject pending priorities change composed two parts understanding code may require documentation code reading execution program modified maintainer must first design change may subject peer review alter code trying minimize side effects change validated altered code verified assure conformance specification new code integrated existing system insure conformance system specifications task involves regression testing new model depicted figure 20 software changed subject pending priorities change composed two parts understanding code require documentation code reading execution use decomposition slices decomposition slices may read executed decided advantage executable program slices code modified subject strictures outlined using guidelines side effects unintended linkages induced code even accident lifts substantial burden maintainer change tested decomposition slice since change cannot ripple modules regression testing unnecessary maintainer need verify change correct applying merge algorithm change code complete ch isspacec isalphach ch 22 g 26 g figure modified program 6 future directions underlying method tool based 9 needs empirically evaluated underway using goalquestionmetric paradigm basili et al 2 naturally also addressing questions scale determine existing software systems decompose sufficiently via techniques order effect technology transfer also evaluating decomposition slices candidates components reuse library although seem well practice slicing algorithms relatively bad worst case running times e loge n number variables e number edges flowgragh obtain slices running time becomes 2 e loge worst case times would seem make interactive slicer large ie real programs impractical difficulty assuaged making data flow analysis one component deliverable products handed development team maintenance team interactive tool could built using products changes made maintainers data flow data updated using incremental techniques keables 17 interprocedural slices attacked using techniques weiser 36 barth 1 interprocedural slicing algorithms horwitz et al 16 cannot used since require slice taken point slice variable id defed refed require slices taken last statement program separate compilation worst case assumption must made external variables source available source available one proceeds procedures berzins 4 attacked problem software merges extensions programs quote extension extends domain partial function without altering initially defined values modification redefines values defined initially addressed modification problem first restricting domain partial function slice complement modifying function values defined independent variables slice request change change software design change alter code test change adaptive perfective corrective preventive minimize defects minimize effort minimize cost maximize satisfaction documentation code reading test runs minimize side effects regression testing pending priorities integrate revalidate figure 19 software maintenance process model request change change software design change alter component test change merge adaptive perfective corrective preventive minimize defects minimize effort minimize cost maximize satisfaction documentation code reading test runs decomposition slicing side effects regression testing pending priorities figure 20 new software maintenance process model merging two disjoint domains horwitz et al 15 addressed modification problem start base program two modifications b whenever changes made base create b interfere sense defined paper algorithm produces program integrates b algorithm predicated assumption differences behavior variant programs base rather differences text significant must preserved horwitz et al restrict changes made base thus algorithm produces approximation undecidable problem determining whether behaviors interfere sidestepped unsolvable problem constraining modifications made technique akin limits placed software maintainers changes must done context independence dependence provides context interesting note however work uses program slicing determine potential interferences merge note program variants name easily embedded change control system rcs 31 moreover direct sum nature components exploited build related families software components summed long dependent code sections match exactly intersection independent domains also follow approach component construction weiser 34 discusses slicebased metrics overlap measure many statements slice found slice measured mean ratio nonunique unique statements slice parallelism number slices statements common computed number slices pairwise overlap certain threshold tightness number statements every slice expressed ratio program length programs high overlap parallelism low tightness would decompose nicely lattice would get deep tangled shown data flow technique program slicing used form decomposition software systems decomposition yields method maintainers use maintainer able modify existing code cleanly sense changes assured completely contained modules consideration unseen linkages modified code infecting modules r practical interprocedural dataflow analysis algorithm experimentation software engineering merging software extensions flow diagrams languages two formation rules techniques debugging parallel programs flowback analysis program dependence graph use optimization using program slicing software maintenance surgeons assistant limits side effects using program decomposition guide modifications program decomposition scheme applications software modification testing measuring managing software maintenance denotational program slicing integrating noninterfering versions programs integrating noninterfering versions programs interprocedural slicing using dependence graphs data flow analysis application software maintenance survey data flow analysis techniques c programming language dynamic program slicing data flow testing stad evaluating variations program slicing debugging experiments slicingbased debugging aids automatic program bug location program slicing relationship slices module cohesion program dependence graph software development environ ments semantics program slicing state software maintenance rcs system version control kill code program slicing formal program slicing programmers use slices debugging program slicing tr informationflow dataflow analysis whileprograms rcsmyampersandmdasha system version control c programming language experimentation software engineering merging software extensions program dependence graph use optimization experiments slicingbased debugging aids state software maintenance dynamic program slicing integrating noninterfering versions programs integrating nonintering versions programs relationship slices module cohesion interprocedural slicing using dependence graphs data flow testing stad using program slicing software maintenance programmers use slices debugging practical interprocedural data flow analysis algorithm flow diagrams turing machines languages two formation rules semanticsbased program integration program slicing program dependence graph software development environment program slices evaluating variations program slicing debugging dataflow ada ctr samadzadeh w wichaipanitch interactive debugging tool c based dynamic slicing dicing proceedings 1993 acm conference computer science p3037 february 1618 1993 indianapolis indiana united states daniel jackson abstract analysis aspect acm sigsoft software engineering notes v18 n3 p1927 july 1993 zhang jose emilio labra gayo agustn cernuda del ro monadic program slicer acm sigplan notices v41 n5 may 2006 tomas vagoun alan hevner feasible input domain partitioning software testing rcs case study annals software engineering 4 p159170 1997 melissa p chase steven christey david r harris alexander yeh recovering software architecture multiple source code analyses acm sigplan notices v33 n7 p4350 july 1998 csaba farag tams gergely handling pointers unstructured statements forward computed dynamic slice algorithm acta cybernetica v15 n4 p489508 december 2002 christian lindig gregor snelting assessing modular structure legacy code based mathematical concept analysis proceedings 19th international conference software engineering p349359 may 1723 1997 boston massachusetts united states sandrine blazy philippe facon partial evaluation program comprehension acm computing surveys csur v30 n3es sept 1998 jarrett rosenberg problems prospects quantifying software maintainability empirical software engineering v2 n2 p173177 1997 hee beng kuan tan tok wang ling correct program slicing database operations ieee software v15 n2 p105112 march 1998 ettore merlo pierreyves gagn jeanfrancois girard kostas kontogiannis laurie hendren prakash panangaden renato de mori reengineering user interfaces ieee software v12 n1 p6473 january 1995 ramachenga r valasareddi doris l carver representation model procedural program maintenance proceedings 1999 acm symposium applied computing p580585 february 28march 02 1999 san antonio texas united states jianjun zhao hongji yang liming xiang baowen xu change impact analysis support architectural evolution journal software maintenance research practice v14 n5 p317333 septemberoctober 2002 keith gallagher mark harman sebastin danicic guaranteed inconsistency avoidance software evolution journal software maintenance research practice v15 n6 p393416 november mangala gowri nanda ramesh slicing concurrent programs acm sigsoft software engineering notes v25 n5 p180190 sept 2000 jingde cheng task dependence net ada software development acm sigada ada letters vxii n4 p2435 julyaug 1992 daniel jackson eugene j rollins new model program dependences reverse engineering acm sigsoft software engineering notes v19 n5 p210 dec 1994 david binkley precise executable interprocedural slices acm letters programming languages systems loplas v2 n14 p3145 marchdec 1993 paolo tonella filippo ricca web application slicing presence dynamic code generation automated software engineering v12 n2 p259288 april 2005 jenchieh ou daniel g saab qiang qiang jacob abraham reducing verification overhead rtl slicing proceedings 17th great lakes symposium great lakes symposium vlsi march 1113 2007 stresalago maggiore italy fangjun wu tong yi slicing z specifications acm sigplan notices v39 n8 august 2004 markus mock darren c atkinson craig chambers susan j eggers program slicing dynamic pointsto sets ieee transactions software engineering v31 n8 p657678 august 2005 tibor gyimthy rpd beszdes istn forgcs efficient relevant slicing method debugging acm sigsoft software engineering notes v24 n6 p303321 nov 1999 ettore merlo giuliano antoniol static measure subset intraprocedural data flow testing coverage based node coverage proceedings 1999 conference centre advanced studies collaborative research p7 november 0811 1999 mississauga ontario canada xiaoxia ren fenil shah frank tip barbara g ryder ophelia chesley chianti tool change impact analysis java programs acm sigplan notices v39 n10 october 2004 jon beck david eichmann program interface slicing reverse engineering proceedings 15th international conference software engineering p509518 may 1721 1993 baltimore maryland united states vivekananda vedula jacob abraham jayanta bhadra raghuram tupuri hierarchical test generation approach using program slicing techniques hardware description languages journal electronic testing theory applications v19 n2 p149160 april durga p mohapatra rajeev kumar rajib mall kumar mayank bhasin distributed dynamic slicing java programs journal systems software v79 n12 p16611678 december 2006 martin p robillard automatic generation suggestions program investigation acm sigsoft software engineering notes v30 n5 september 2005 houari sahraoui hakim lounis walclio melo hafedh mili concept formation based approach object identification procedural code automated software engineering v6 n4 p387410 october 1999 thomas reps genevieve rosay precise interprocedural chopping acm sigsoft software engineering notes v20 n4 p4152 oct 1995 donglin liang mary jean harrold equivalence analysis application improving efficiency program slicing acm transactions software engineering methodology tosem v11 n3 p347383 july 2002 bogdan korel satish yalamanchili forward computation dynamic program slices proceedings 1994 acm sigsoft international symposium software testing analysis p6679 august 1719 1994 seattle washington united states bogdan korel computation dynamic program slices unstructured programs ieee transactions software engineering v23 n1 p1734 january 1997 rob law overview debugging tools acm sigsoft software engineering notes v22 n2 p4347 march 1997 jehad al dallal using computingallslices algorithm measuring functional cohesion proceedings 25th conference iasted international multiconference software engineering p198203 february 1315 2007 innsbruck austria jehad al dallal efficient algorithm computing program static slices proceedings 4th wseas international conference software engineering parallel distributed systems p15 february 1315 2005 salzburg austria thomas reps susan horwitz mooly sagiv genevieve rosay speeding slicing acm sigsoft software engineering notes v19 n5 p1120 dec 1994 loren larsen mary jean harrold slicing objectoriented software proceedings 18th international conference software engineering p495505 march 2529 1996 berlin germany paolo tonella giuliano antoniol roberto fiutem ettore merlo flow insensitive c pointers polymorphism analysis application slicing proceedings 19th international conference software engineering p433443 may 1723 1997 boston massachusetts united states jingde cheng task dependence nets concurrent systems ada 95 applications proceedings conference triada 97 p6778 november 0913 1997 st louis missouri united states markus mock darren c atkinson craig chambers susan j eggers improving program slicing dynamic pointsto data acm sigsoft software engineering notes v27 n6 november 2002 markus mock darren c atkinson craig chambers susan j eggers improving program slicing dynamic pointsto data proceedings 10th acm sigsoft symposium foundations software engineering november 1822 2002 charleston south carolina usa annie ying gail c murphy raymond ng mark c chucarroll predicting source code changes mining change history ieee transactions software engineering v30 n9 p574586 september 2004 tun li yang guo sikun li automatic circuit extractor hdl description using program slicing journal computer science technology v19 n5 p718728 september 2004 hiralal agrawal slicing programs jump statements acm sigplan notices v29 n6 p302312 june 1994 anthony sloane jason holdsworth beyond traditional program slicing acm sigsoft software engineering notes v21 n3 p180186 may 1996 martin p robillard gail c murphy concern graphs finding describing concerns using structural program dependencies proceedings 24th international conference software engineering may 1925 2002 orlando florida mangala gowri nanda ramesh interprocedural slicing multithreaded programs applications java acm transactions programming languages systems toplas v28 n6 p10881144 november 2006 j bieman l ott measuring functional cohesion ieee transactions software engineering v20 n8 p644657 august 1994 gautier bastide abdelhak seriai mourad oussalah adapting software components structure fragmentation proceedings 2006 acm symposium applied computing april 2327 2006 dijon france ingo brckner bjrn metzler heike wehrheim optimizing slicing formal specifications deductive verification nordic journal computing v13 n1 p2245 june 2006 david binkley semantics guided regression test cost reduction ieee transactions software engineering v23 n8 p498516 august 1997 erwan jahier mireille ducass generic program monitoring trace analysis theory practice logic programming v2 n45 p611643 july 2002 john field g ramalingam frank tip parametric program slicing proceedings 22nd acm sigplansigact symposium principles programming languages p379392 january 2325 1995 san francisco california united states harman danicic projecting functional models imperative programs acm sigplan notices v28 n11 p3341 nov 1993 jens krinke slicing chopping path conditions barriers software quality control v12 n4 p339360 december 2004 sebastian danicic mark harman rob hierons john howroyd michael r laurence equivalence linear free liberal structured program schemas decidable polynomial time theoretical computer science v373 n12 p118 march 2007 hon f li juergen rilling dhrubajyoti goswami granularitydriven dynamic predicate slicing algorithms message passing systems automated software engineering v11 n1 p6389 january 2004 ahmed e hassan richard c holt replaying development history assess effectiveness change propagation tools empirical software engineering v11 n3 p335367 september 2006 roberto giacobazzi isabella mastroeni nonstandard semantics program slicing higherorder symbolic computation v16 n4 p297339 december z alkhanjari r woodward haider ali ramadhan n kutti efficiency critical slicing fault localization software quality control v13 n2 p129153 january 2005 michael r laurence sebastian danicic mark harman rob hierons john howroyd equivalence conservative free linear program schemas decidable theoretical computer science v290 n1 p831862 1 january g griswold david notkin architectural tradeoffs meaningpreserving program restructuring tool ieee transactions software engineering v21 n4 p275287 april 1995 filippo lanubile giuseppe visaggio extracting reusable functions flow graphbased program slicing ieee transactions software engineering v23 n4 p246259 april 1997 gerardo canfora aniello cimitile ugo de carlini andrea de lucia extensible system source code analysis ieee transactions software engineering v24 n9 p721740 september 1998 g b mund rajib mall efficient interprocedural dynamic slicing method journal systems software v79 n6 p791806 june 2006 sebastian danicic mark harman espresso slicer generator proceedings 2000 acm symposium applied computing p831839 march 2000 como italy g griswold david notkin automated assistance program restructuring acm transactions software engineering methodology tosem v2 n3 p228269 july 1993 thomas w reps louis b rall computational divided differencing divideddifference arithmetics higherorder symbolic computation v16 n12 p93149 marchjune dave binkley sebastian danicic tibor gyimthy mark harman kos kiss bogdan korel theoretical foundations dynamic program slicing theoretical computer science v360 n1 p2341 21 august 2006 ducasse tichelaar dimensions reengineering environment infrastructures journal software maintenance research practice v15 n5 p345373 septemberoctober ramkrishna chatterjee barbara g ryder william landi complexity pointsto analysis java presence exceptions ieee transactions software engineering v27 n6 p481512 june 2001 mark harman david binkley sebastian danicic amorphous program slicing journal systems software v68 n1 p4564 15 october sebastian danicic mohammed daoudi chris fox mark harman robert hierons john r howroyd lahcen ourabya martin ward consus lightweight program conditioner journal systems software v77 n3 p241262 september 2005 dave binkley sebastian danicic tibor gyimthy mark harman kos kiss bogdan korel formalisation relationship forms program slicing science computer programming v62 n3 p228252 15 october 2006 j hagemeister b lowther p oman x yu w zhu annotated bibliography software maintenance acm sigsoft software engineering notes v17 n2 p7984 april 1992 g j van den brand p klint c verhoef reverse engineering system renovationan annotated bibliography acm sigsoft software engineering notes v22 n1 p5768 jan 1997 david binkley nicolas gold mark harman empirical study static program slice size acm transactions software engineering methodology tosem v16 n2 p8es april 2007 barbara g ryder william landi philip stocks sean zhang rita altucher schema interprocedural modification sideeffect analysis pointer aliasing acm transactions programming languages systems toplas v23 n2 p105186 march 2001 david binkley source code analysis road map 2007 future software engineering p104119 may 2325 2007 c verhoef towards automated modification legacy assets annals software engineering v9 n14 p315336 2000 hafedh mili fatma mili ali mili reusing software issues research directions ieee transactions software engineering v21 n6 p528562 june 1995 baowen xu ju qian xiaofang zhang zhongqiang wu lin chen brief survey program slicing acm sigsoft software engineering notes v30 n2 march 2005
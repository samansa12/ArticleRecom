multiframe model realtime tasks abstractthe wellknown periodic task model liu layland 10 assumes worstcase execution time bound every task may pessimistic worstcase execution time task much longer average paper give multiframe realtime task model allows execution time task vary one instance another specifying execution time task terms sequence numbers investigate schedulability problem model preemptive fixed priority scheduling policy show significant improvement utilization bound established model b introduction wellknown periodic task model liu laylandll 1 assumes worstcase execution time bound every task reasonable assumption processcontroltype realtime applications may overly conservative 4 situations averagecase execution time task significantly smaller worstcase case critical ensure completion task deadline worstcase execution time used price excess capacity approaches considered make better use system resources substantial excess capacity example many algorithms developed schedule besteffort tasks resources unused hardrealtime periodic tasks aperiodic task scheduling studied extensively different aperiodic server algorithms developed schedule together periodic tasks 6 7 8 9 10 etc imprecise computation model used system cannot schedule desired computation also investigated adaptive scheduling model timing parameters realtime task may parameterized 3 however none work mentioned addresses scheduleability realtime tasks execution time task may vary greatly follows known pattern paper propose multiframe task model takes account execution time patterns shall show better schedulability bounds obtained multiframe model execution time task specified finite list numbers repeating list periodic sequence numbers generated execution time instance frame job task bounded corresponding number periodic sequence consider following example suppose computer system used track vehicles registering status every vehicle every 3 time units get complete picture computer takes 3 time units perform tracking execution ie computer 100 utilized suppose addition computer required execute routine task takes 1 time unit task executed every 5 time units obviously computer cannot handle tasks routine tracking figure 1 schedule vehicle tracking system however tracking task relaxed requires 1 time unit execute every period computer able perform tracking routine tasks see timing diagram figure 1 solution cannot obtained model since worstcase execution time tracking task 3 periodic task set model given f3 3 1 5g first component pair execution time second period task set utilization factor 12 thus unscheduleable also notice cannot replace tracking task pair periodic tasks f3 6 1 6g since scheduler may defer execution 3 first execution extends past interval 03 fact must finished time3 paper shall investigate schedulability tasks multiframe task model preemptive fixed priority scheduling policy generality allow tasks sporadic instead periodic sporadic task one whose requests may occur periodically minimum separation two successive requests task periodic task limiting case sporadic task whose requests arrive maximum allowable rate shall establish utilization bounds model shown subsume result 1 obtain results however require execution times multiframe tasks satisfy fairly liberal constraint seen schedulability bounds improved substantially large variance peak nonpeak execution time task using multiframe model safely admit realtime tasks model paper organized follows section 2 presents multiframe realtime task model defines terminology prove basic results scheduling multiframe tasks section 3 investigates schedulability bound fixed priority scheduler multiframe model section 4 conclusion 2 multiframe task model rest paper shall assume time values domain set nonnegative real numbers timing parameters following definitions nonnegative real numbers remark results still hold domain time nonnegative integers realtime task tuple gamma p gamma array n execution times minimum separation time ie ready times two consecutive frames requests must least p time units apart execution time ith frame task c igamma1 mod n 1 deadline frame p ready time example multiframe task minimum separation time 2 execution time alternates 2 1 separation two consecutive ready times always p ready time first frame task time0 task reduces periodic task proofs follow shall often associate multiframe task whose gamma one element ie n1 periodic task model execution time whose period minimum separation multiframe task example task 1 5 one execution time corresponding task 1 5 shall call periodic task model task whenever confusion shall call multiframe task simply task consider task one execution time let shall call c peak execution time task shall call pair corresponding task multiframe task set n tasks ft call u peak utilization factor call u maximum average utilization factor given scheduling policy call u utilization bound task set scheduleable whenever u u note u also utilization factor ss corresponding task set example 1 consider task set 5g corresponding task set 0 isft 0 5g peak utilization factor u 12 maximum average utilization factor u pessimistic way analyze scheduleability multiframe task set consider schedulability corresponding task set however may result rejecting many task sets actually scheduleable example task set example 1 rejected use model whereas actually scheduleable fixed priority scheduler rma rate monotonic assignment shall show later respect scheduling policy task set said fully utilizing processor scheduleable increasing execution time frame task result modified task set unscheduleable note u greatest lower bound fully utilizing task sets respect scheduling policy lemma 1 scheduling policy u 1 proof shall prove contradiction suppose u larger 1 arbitrarily form task set c peak execution time sigma n peak frames tasks start time cannot finished within p scheduler violates definition u cannot exceed 1 qed suppose scheduling policy used schedule multiframe task sets let utilization bound u multiframe task sets let utilization bound corresponding task sets u c u proof proof contradiction consider task set size n suppose u u c set unscheduleable corresponding task set 0 utilization factor u 0 scheduleable suppose ith frame task j miss deadline time j every task locate time point k ready time latest frame k k j transform ready time pattern follows interval 0 k push ready times frames toward k separation times consecutive frames equal p k set execution times peak execution time k add peak frames k maximum rate interval k j transformed ready time pattern least stringent original case ith frame j still misses deadline however transformed case actually ready time pattern 0 scheduleable hence contradiction qed inequality lemma 2 strict intuitively u task set larger u c much framebyframe variance execution times tasks set task set unlikely scheduleable however variance sufficiently big scheduling policy admit tasks quantified determining utilization bound task model shall show establish exact bound execution times tasks satisfy rather liberal restriction maximum array execution times c array said accumulatively monotonic sigma mj said array execution times intuitively task task whose total execution time sequence l 1 frames largest among sizel frame sequences first frame sequence frame peak execution time instance tasks example 1 note tasks multimedia applications usually satisfy restriction following section assume tasks satisfy property seen without loss generality assume first component array execution time every task peak execution time ie c c 0 fixed priority scheduling section shall show preemptive fixedpriority scheduling policy multiframe task model higher utilization bound model consider execution time variance explicitly utilization bound model given following theorem much cited paper 1 theorem 1 theorem 5 1 task sets size n utilization bound preemptive fixed priority schuduling policy n2 1n gamma 1 definition 5 critical instance multiframe task period peak execution time requested simultaneously peak execution times higher priority tasks higher priority tasks request execution maximum rate theorem 2 preemptive fixed priority scheduling policy multiframe task scheduleable scheduleable critical instance proof suppose task scheduleable critical instance shall prove frames scheduleable regardless ready times first prove first frame k scheduleable let k ready time first frame finishes end trace backward time timet locate point 0 none higher priority tasks executed 0 always exists since time 0 task scheduled let us pretend k first frame becomes ready time 0 still finish time end let us shift ready time pattern higher priority task frame becomes ready 0 becomes ready 0 postpone finish time k first frame point earlier end say end words end 0 end higher priority task shift ready time every frame 0 toward time0 separation two consecutive frames always minimum separation time postpone finish time k first frame earlier 0 end words 0 end shift higher priority tasks frames peak frame starts 0 since gamma k shifting effect postponing finish time k 000 end construction resulting request pattern critical instance k since scheduleable critical instance 000 first frame scheduleable next prove frames k also scheduleable done induction induction base case first frame k scheduleable induction step suppose first frames k scheduleable let us consider i1th frame apply argument suppose frame starts time finishes end trace backward along time line hit point 0 higher priority tasks executed 0 always exists since higher priority task executed finish time ith frame let 1th frame start time 0 still finish time end shift requests higher priority task frame starts 0 starts 0 postpone finish time k 1th frame point time earlier end say end higher priority task shift ready time every frame 0 toward time0 separation time two consecutive frames always minimum separation time task postpone finish time k 1th frame earlier 0 end words end higher priority tasks shift frames peak frames start 0 since gamma postpones finish time k 1th frame 000 end last case actually critical instance k since k scheduleable critical instance 000 1th frame also scheduleable thus proved theorem qed shall say task passes critical instance test scheduleable critical instance corollary 1 task set scheduleable fixed priority scheduler tasks pass critical instance test assume without loss generality c 0 peak execution time task without affecting schedulability task set always replace task whose peek execution time first frame one whose execution time array obtained rotating array peek execution time c 0 argument proof theorem 2 clear task replacement affect result critical instance test example 2 task set f2 1 3 3 7g scheduleable ratemonotonic assignment u tasks pass critical instance test however corresponding task set f2 3 3 7g unscheduleable fixed priority assignment example 3 task set f3 3 1 5g utilization factor 12 obviously unscheduleable scheduling policy however requirement first task relaxed every frame needs 1 time unit task set becomes scheduleable rma relaxed case given multiframe task set f3 1 3 1 5g passes critical instance test remark example 3 specifies vehicle tracking system mentioned beginning paper argument establish schedulability examples also show even total peak utilization exceeds 1 task set may still schedulable course average utilization must larger 1 scheduleability complexity scheduleability test based corollary 1 op p biggest period theorem 3 feasible priority assignment exists multiframe task set ratemonotonic priority assignment feasible task set proof suppose feasible priority assignment exists task set let j two tasks adjacent priority assignment higher priority one suppose us interchange priorities j difficult see resultant priority assignment still feasible checking critical instances ratemonotonic priority assignment obtained priority ordering finite sequence pairwise priority reordering qed compute utilization bound need following lemma definition 6 let psin ff denote minimum expression sigma subject constraint 2 proof substitution x pn compute minimize sigma n subject x strictly convex problem unique critical point absolute minimum symmetry minimization problem variables means x equal solution x definition 7 task set said extremely utilizing processor scheduleable increasing peak execution time lowest priority task amount result task set unscheduleable shall use u e denote greatest lower bound extremely utilizing task sets important note distinction fully utilizing extremely utilizing task sets crucial proof lemma 4 lemma 5 lemma 4 consider task sets size n satisfying restriction r proof theorem 2 theorem 3 need consider case tasks start time 0 request maximum rates thereafter use ratemonotonic priority assignment check scheduleability interval time 0 p n since know c 0 c 1 involved critical instance tests first utilization bound corresponds case every c 0 c 1 equals r since increase c 1 without changing u increasing c 1 take cpu time following proof assume ratios equal r scheduleable extremely utilizing task set u shall prove four claims 1 second request must finished p n suppose ffi c 1 scheduled p n derive new task set 0 changing following execution times n arbitrarily reducing execution times maintain property execution time arrays easy show 0 schedulable also extremely utilizes processor contradicts assumption u e minimum extremely utilizing task set second request completed p n 2 0 derive new task set 0 changing following execution times n arbitrarily reducing execution times maintain property execution time arrays easy check 0 scheduleable also extremely utilizes processor contradicts assumption u e minimum c 0 3 n finished p instead proving claim 3 prove following equivalent claim consider extreme utilizing task set satisfying claim 1 claim 2 last part c 0 finishes p p i1 correspond minimal case claim 2 derive new task set 0 changing following execution times n arbitrarily reducing execution times n maintain property execution time arrays suppose p j smallest value satisfying according claim 1 claim 2 second requests tasks n scheduled p j p n since know first requests tasks n scheduled p j extremely utilizes cpu know part c n scheduled p j larger scheduled p j guarantees new task set 0 still scheduleable extremely utilizes cpu r hence task set cannot minimal case establishes claim 3 second request completed exactly time p i1 second request completes ahead p i1 processor idle completion time p i1 shows extremely utilize processor cannot true ffi second request derive new task set 0 changing following execution times i1 arbitrarily reducing execution times maintain property execution time arrays easy check 0 schedulable also extremely utilizes process contradicts assumption u e minimum second request completed exactly time i1 four claims lemma 3 conclude r sets size n u r proof assume c 0 c 1 equals r tasks request maximum rate task extremely utilizing task set p p 0 increase c 0 n amount needed extremely utilize processor increase smaller c 1 1 let old new utilization factors u u 0m respectively therefore conclude minimum utilization occurs among task sets longest period larger twice shortest period establishes lemma 5 qed theorem 4 let sets size n utilization bound given r r proof definition least upper bound minimum u e task sets size ranging 1 n min n r r observe liu laylands theorem 1 special case theorem 4 frame separation time equals period following tables summarize relative advantage using multiframe model model determining whether set task scheduleable column ull gives utilization bound model 5 0743 136 195 228 249 263 274 282 289 294 345 50 0698 167 240 282 308 327 341 352 360 367 433 100 0696 168 243 285 312 331 345 355 364 371 438 table 1 utilization bound percentage improvement conclusion future research 17 table 1 shows percentage improvement bound liu layland bound specifically table entries denote 100 u ull gamma 1 different combination r ratio peak execution time execution time second frame n number tasks task set example suppose system capable processing one gigabyte data per second set tasks needs process one megabyte data per second using utilization bound ln 2 allow 693 tasks theorem 4 allow least 863 tasks 24 improvement r 3 r increases bound improvement increases actually r 1 simple calculation shows bound 1 says model excels execution time task varies sharply also interesting compare maximum average utilization bound however maximum average utilization factor may arbitrarily low even maximum utilization factor high one simple example f10 5 10g take instead average first two frames task table 2 calculate 100 1 r u ratio biggest possible maximum average utilization factor liu layland bound table 3 shows still maintain good overall system utilization task execution time varies 4 conclusion future research paper give multiframe model realtime tasks amenable specifying tasks whose execution time varies one instance another model execution times successive instances task specified finite array numbers rather single number worstcase execution time classical liu layland model using new model derive utilization bound preemptive fixed priority scheduler assumption execution time array tasks satisfies accumulative conclusion future research 3 0780 835 774 743 723 710 700 693 688 683 641 5 0743 852 797 767 749 737 728 721 716 712 673 100 0696 876 828 803 787 776 768 762 758 754 719 table 2 ratio maximum average bound monotonic property property rather liberal consistent common encoding schemes multimedia applications one execution times array dominates others show significant improvement utilization bound liu layland model results using model useful dynamic applications number tasks vary figure merit resource allocation number tasks system admit without causing timing failures work way apply model reallife applications video stream scheduling reported future r scheduling algorithms multiprogramming hard realtime environment fundamental design problems distributed systems hardrealtime envi ronment load adjustment adaptive realtime systems rate monotonic scheduling algorithm exact characterization average case behavior assigning realtime tasks homogeneous multiprocessor systems deferrable server algorithm enhanced aperiodic responsiveness hard realtime environments practical method increasing processor utilization aperiodic servers deadline scheduling environment aperiodic task scheduling hard realtime systems scheduling periodic jobs allow imprecise results tr ctr teiwei kuo lipin chang yuhua liu kweijay lin efficient online schedulability tests realtime systems ieee transactions software engineering v29 n8 p734751 august marek jersak rafik henia rolf ernst contextaware performance analysis efficient embedded system design proceedings conference design automation test europe p21046 february 1620 2004 jrn migge alain jeanmarie nicolas navet timing analysis compound scheduling policies application posix10031b journal scheduling v6 n5 p457482 septemberoctober samarjit chakraborty thomas erlebach simon knzli lothar thiele schedulability eventdriven code blocks realtime embedded systems proceedings 39th conference design automation june 1014 2002 new orleans louisiana usa sanjoy k baruah dynamic staticpriority scheduling recurring realtime tasks realtime systems v24 n1 p93128 january changgun lee lui sha avinash peddi enhanced utilization bounds qos management ieee transactions computers v53 n2 p187200 february 2004 michael palis granularity metric finegrain realtime scheduling ieee transactions computers v54 n12 p15721583 december 2005 tarek f abdelzaher vivek sharma chenyang lu utilization bound aperiodic tasks priority driven scheduling ieee transactions computers v53 n3 p334350 march 2004 christopher gill david l levine douglas c schmidt design performance realtime corba schedulingservice realtime systems v20 n2 p117154 march 2001 chinfu kuo teiwei kuo cheng chang realtime digital signal processing phased array radars ieee transactions parallel distributed systems v14 n5 p433446 may lui sha tarek abdelzaher karlerik rzn anton cervin theodore baker alan burns giorgio buttazzo marco caccamo john lehoczky aloysius k mok real time scheduling theory historical perspective realtime systems v28 n23 p101155 novemberdecember 2004
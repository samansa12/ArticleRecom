resourcebounded kolmogorov complexity revisited take fresh look cd complexity cdtx size smallest program distinguishes x strings time tx also look cnd complexity new nondeterministic variant cd complexity timebounded kolmogorov complexity denoted c complexitywe show several results relating timebounded c cd cnd complexity applications variety questions computational complexity theory including following showing approximate size set using cd complexity without using random string needed sipsers earlier proof similar result also give new simpler proof result sipsers improving bounds almost strings using extractors proof valiantvazirani lemma directly sipsers earlier cd lemma relativized lower bound cnd complexity exact characterizations equivalences c cd cnd complexity showing satisfying assignments satisfiable boolean formula enumerated time polynomial size output unique assignment found quickly answers open question papadimitriou new kolmogorov complexitybased proof bppsubseteqsigma2p new kolmogorov complexity based constructions following relativized worlds exists infinite set p sparse infinite np subsets expnexp exists nexp machine whose accepting paths cannot found exponential time satisfying assignments cannot found nonadaptive queries sat b introduction originally designed measure randomness strings kolmogorov complexity become important tool computability complexity theory simple lower bound showing exist random strings every length several important applications see lv93 chapter 6 early history computational complexity theory many people naturally looked resourcebounded versions kolmogorov complexity line research initially fruitful led interesting results particular sipser sip83 invented new variation resourcebounded complexity cd complexity one considers size smallest program accepts given string others sipser used cd complexity first proof bpp contained polynomialtime hierarchy complexity theory marched past two decades resourcebounded kolmogorov complexity seen little interest computational complexity theory matured bit ought look back resourcebounded kolmogorov complexity see new results applications draw first use algebraic techniques give new upper bound lemma cd complexity without additional advice required sipsers lemma sip83 lemma approximately measure size set using cd complexity also give new simpler proof sipsers lemma show implies important valiant lemma vv85 randomly isolates satisfying assignments surprisingly sipsers paper predates result valiant vazirani define cnd complexity variation cd complexity allow nondeterministic com putation prove lower bound cnd complexity show exists infinite set every string high cnd complexity even allow access ora cle use lemma prove negative result nondeterministic search vs deterministic decision tools place use unify several important theorems complexity theory answer open question papadimitriou pap96 characterizing exactly set satisfying assignments formula enumerated output polynomialtime also give straightforward proofs bpp sigma p first proven gacs see sip83 create relativized worlds assignments sat cannot found non adaptive queries sat first proven buhrman thierauf bt96 exists nexp machine whose accepting paths cannot found polynomial time first proven impagliazzo tardos it89 results original form require great deal time fully understand proof either ideas andor technical details quite complex show understanding resourcebounded kolmogorov complexity one see full complete proofs results without much additional effort also look polynomialtime c cd cnd complexity collide give precise characterization equality classes interesting consequences thereof preliminaries use basic concepts notation computational complexity theory texts like balcazar diaz gabarro bdg88 kolmogorov complexity excellent book li vitanyi lv93 use jxj represent length string x jjajj represent number elements set logarithms base 2 formally define kolmogorov complexity function cxjy u fixed universal deterministic turing machine define unconditional kolmogorov complexity basic facts kolmogorov complexity ffl choice u affects kolmogorov complexity additive constant ffl constant c cx jxj ffl every n every x also use timebounded kolmogorov complexity fix fully timecomputable function define c xjy complexity function runs tjxj let c different universal u may affect complexity constant additive factor time log factor usual kolmogorov complexity asks smallest program produce given string may also want know smallest program distinguish string difference affects unbounded kolmogorov complexity constant make difference timebounded case sipser sip83 defined distinguishing complexity cd 1 x accepts rejects z 6 x runs tjzj steps z 2 sigma fix universal nondeterministic turing machine u n define nondeterministic distinguishing complexity cnd 1 u n p x accepts rejects z 6 x runs tjzj steps z 2 sigma let cnd also allow relativized kolmogorov complexity example cd ta xjy defined except universal machine u access oracle since one distinguish string generating lemma 21 8t 9c ct c constant likewise since every deterministic computation also nondeterministic computation get lemma 22 8t 9c ct section 5 examine consequences converses lemmas approximating sets distinguishing complexity section derive lemma enables one deterministically approximate density set using polynomialtime distinguishing complexity lemma 31 1g x 2 least half primes proof x holds n different prime numbers p chinese remainder theorem x dn primes p prime number theorem ing32 states approximately lnm logm primes less least 4dn primes less 4dn 3 least half primes p must lemma 32 let set strings x 2 n holds cd pa n olog n polynomial p proof fix n let prime p x fulfilling conditions lemma 31 x cd poly program x works follows input 62 n reject else mod else reject size program jp 2 logjjajj olog n clear program runs polynomial time accepts x 2 note lemma also works cnd p complexity p polynomial corollary 33 let set p string x 2 holds ologn polynomial p proof use scheme lemma 32 using 2 p specifying length x yielding extra logn term jxj plus additional 2 log logn penalty concatenating strings 2 corollary 34 1 set sparse x 2 cd ps x ologjxj polynomial p 2 set 2 p sparse x 2 cd p x ologjxj polynomial p 3 set 2 np sparse x 2 cnd p x ologjxj polynomial p proof lemma 32 yields strings sparse set ologn cd p complexity hand simple counting shows set must string x 2 cnd x logjjajj 2 31 also use lemma 31 give simple proof following important result due sipser sip83 lemma 35 sipser every polynomialtime computable set exists polynomial p constant c every n r sigma pn every x 2 n cd pa n proof k 1 k n let r k list 4kn randomly chosen numbers less r concatenation r k fix x 2 n let consider one numbers listed r k prime number theorem ing32 probability prime less 2 least 1 probability fulfills conditions lemma 31 x least 1 4 log 4k probability 1e n1 12 n1 r k fulfills condition lemma 31 probability least 12 every x 2 listed r k fulfilling conditions lemma 31 x describe x x mod pointer r 2 note sipser get tighter bound c log n applications additional olog n additive factor makes substantial difference comparing lemma 32 sipsers lemma 35 able eliminate random string required sipser cost additional log ja n j bits 4 lower bounds section show exists infinite set every string high cnd complexity even relative fortnow kummer fk96 prove following result relativized cd complexity theorem 41 infinite set every polynomial p cd pa x jxj5 almost x 2 extend strengthen result cnd complexity theorem 42 infinite set cnd 2 proof fortnow kummer theorem 41 uses fact one start large set strings length polynomialtime algorithm input x cannot query however nondeterministic machine may query every string given length thus need careful proof proof based proof corollary 43 goldsmith hemachandra kunen ghk92 section 7 also describe rough equivalence result xsearch theorem impagliazzo tardos it89 proof theorem 42 create sets stages stage k pick large n add nonempty set strings b length n nondeterministic programs p running time 2 n accepts either zero one strings first create b makes many programs possible accept zero strings b carefully remove strings b guarantee rest programs accept least two strings let p set nondeterministic programs size less n4 clock programs reject take time 2 n also assume every program p p input x oracle p x queries x set x let pick sets maximizes jdeltaj jhj jhj wjdeltaj x sigma note h 6 sigma n since jhj wjdeltaj wjp always accepts delta 6 p final b subset sigma guarantees p 2 delta p ab accept strings b create b accepts least two strings b initially let integer 1 following pick minimal x b 2 x p x accepts fix accepting path let q p queries made path let note jq pi n remove jp jv2 strings total cannot find appropriate x violated maximality jdeltaj jhj note pi 2 x pi q pi x pi disjoint initially set x pi unmarked following twice pick unmarked x pi mark x qj x qj q pi 6 let pi 2 b p b pi accepts every x pi processed 2 delta 2 x qj get marked finished always find unmarked x pi finally note b sigma least two 2 b p b accepts since also guarantees b 6 thus fulfilled requirements stage k 2 using theorem 42 get following corollary first proved goldsmith hemachandra kunen ghk92 corollary 43 goldsmithhemachandrakunen relative oracle exists infinite polynomialtime computable set infinite sparse np subsets proof let theorem 42 oracle set p suppose infinite sparse subset np pick large x x 2 applying corollary 343 follows cnd ap x ologn contradicts fact x 2 theorem 42 2 argument shows actually something stronger corollary 44 relative oracle exists infinite polynomialtime computable set infinite subset np density less 2 n9 5 cd vs c cnd section deals consequences assumption one complexity measures c cd cnd coincide polynomial time see assumptions equivalent well studied complexity theoretic assumptions allows us apply machinery developed previous sections use following function classes definition 51 1 class fp nplogn class functions computable polynomial time adaptively access oracle np c logn times c 2 class fp np tt class functions computable polynomial time non adaptively access oracle np theorem 52 following equivalent 1 logjxj 2 logjxj 3 fp tt first need following claim due lozano see jt95 pp 184185 53 fp tt every f fp np exists function 2 fp generates polynomialsize set fx 2 gx following let f 2 fp np tt let see exists p c logjyj assume fx produces list queries sat let c exact number queries q sat thus satjj consider following cnd p program given x input z use fx generate q guess sat guess satisfying assignments q reject q satisfiable compute fx q answered yes q answered accept size program c logjyj accepts runs time p polynomial p constant c depending f follows also prefixes cnd p complexity bounded c logjyj o1 assumption exists polynomial p 0 constant cd p 0 prefix since enumerate simulate cd p programs size logjyj time polynomial jyj generate list possible candidates well follows using claim 53 fp tt string cnd p 0 program length k consider following function exists z length th bit equal turing machine e given x nondeterministically accepts z l steps note e cnd program runs l steps accepts exactly one string length hence fe 0 l hard see general f fp np tt assumption fp nplogn via machine next given l x c logn answers np oracle makes generated time p polynomial depending hence c p next corollary use results jt95 use following class limited nondeterminism defined dt90 definition 54 let fn function 7 class npfn denotes class languages accepted polynomialtime bounded nondeterministic machines inputs length n make fn nondeterministic moves corollary 55 8p 2 9p k 1 nplog k n included p 2 sat 2 np n log k n 3 sat 2 dtime2 n o1 log log n 4 exists polynomial q every formulae oe variables least one satisfiable exists oe satisfiable proof consequences corollary follow assumption fp tt follows theorem 52 2 use corollary 55 get complete collapse constant difference cd cnd complexity theorem 56 following equivalent 1 2 3 proof easy combined assumption formulae oe least one satisfiable log logn satisfiable oe enumerate programs p length c log logn find formula oe poe thus given oe polynomialtime create subset size log c n contains satisfiable formula original list apply standard treepruning algorithm find satisfying assignment satisfiable formula 2 simple modification proof shows theorem 56 holds replace constant c log n 1 next corollary need following definition see esy84 definition 57 promise problem pair sets q r set l called solution promise problem q r 8xx 2 q r function f fsat denotes set boolean formulas fn satisfying assignments formulae length n next theorem states nondeterministic computations accepting computations compressed nondeterministic computations nondeterministic moves c poly cd poly theorem 58 following equivalent 1 2 1satsat solution p 3 time constructible f fsatsat solution np2 logfn ologn proof 1 2 proven fk96 3 fact dt90 oe formula fjoej satisfying assignments lemma 32 yields every satisfying assignment oe exists polynomial p cd p ologjoej hence using 1 2 follows c p 0 constant c polynomial p 0 limited nondeterministic machine guesses c p 0 program program e size 2 logfjoej logjoej runs relative oe accepts iff generated string satisfying assignment oe 2 corollary 59 fp tt implies following 1 k promise problem 2 log k n satsat solution p 2 k class languages accepted nondeterministic machines 2 log k n accepting paths inputs length n included p proof follows theorem 52 theorem 58 corollary 55 2 6 satisfying assignments show several connections cd complexity finding satisfying assignments boolean formulae cooks theorem coo71 finding satisfying assignments equivalent finding accepting computation paths np computation 61 enumerating satisfying assignments papadimitriou pap96 mentioned following hypothesis hypothesis 61 exists turing machine given formula oe output set satisfying assignments oe time polynomial joej jjajj use cd complexity show following theorem 62 hypothesis 61 equivalent 1sat sat solution p hypothesis 61 require machine halt printing assignments machine required halt time polynomial oe jjajj hypothesis 61 equivalent proof theorem 62 implication 1sat sat solution p straightfor ward concentrate direction 32 theorem 58 every element x c q xjoe log dc log n polynomial q constant c simply try every program p length increasing order enumerate poe satisfying assignment oe 2 62 computing satisfying assignments section turn attention question complexity generating satisfying assignment satisfiable formula wt93 hnos96 ogi96 bkt94 well known kre88 one generate leftmost satisfying assignment fp np tantalizing open question whether one compute necessary leftmost satisfying assignment fp np tt formalizing question define function class f sat f 2 f sat 2 sat f satisfying assignment question becomes f sat translating cnd setting following lemma 63 f sat oe 2 sat exists satisfying assignment oe cnd p j oe c logjoej polynomial p constant c toda watanabe wt93 showed relative random oracle f sat hand buhrman thierauf bt96 showed exists oracle f sat result also holds relative set constructed theorem 42 theorem 64 relative set constructed theorem 42 f sat proof n let oe formula n variables tt 6 follows lemma 63 exists x 2 cnd pa x ologjxj polynomial p contradicting fact x 2 63 isolating satisfying assignments section take kolmogorov complexity view statement proof famous lemma vv85 valiantvazirani lemma gives randomized reduction satisfiable formula another formula non negligible probability exactly one satisfying assignment state lemma terms kolmogorov complexity lemma 65 polynomial p oe sat r cr jrj satisfying assignment oe cd p ajhoe ri olog joej usual valiantvazirani lemma follows statement lemma 65 choosing r olog joej program randomly show derive valiantvazirani lemma sipsers lemma lemma 35 note sipsers result predates valiantvazirani couple years proof lemma 65 let consider set satisfying assignments oe apply lemma 35 conditioned oe using part r random strings let get every element cd program length bounded log n constant c since two different elements must different programs least 1n c strings length must distinguish assignment use rest r list n 2c different strings length log n since r random one strings w must program distinguishes assignment give cd program olog n bits giving pointer w r 2 7 search vs decision exponentialtime given satisfiable formula one use binary search find assignment one might expect similar result exponentialtime computation ie one find witness nexp computation exponential time however proof polynomialtime breaks one binary search input questions get long impagliazzo tardos it89 give relativized evidence problem indeed hard theorem 71 it89 exists relativized world exists nexp machine whose accepting paths cannot found exponential time give short proof theorem using theorem 42 proof theorem 71 let theorem 42 encode tally set exp nondeterministic oracle machine runs time 2 n b b nexp b complete initially let every string w lexicographic order put 1 2w aphit x accepts phi end construction since mw could query strings length 2 jwj w construction give us exp show exists nexp b machine whose accepting paths cannot found time exponential relative b consider nexp b machine input n guesses string length n accepts note runs time 2 jnj n suppose accepting computations b found time 2 jnj k relative b theorem 42 fix large n n 6 x 2 n show following claim assuming claim 72 theorem 71 follows since jw 1 thus contradiction equation 1 proof claim 72 construct program p nondeterministically distinguish x use log n bits encode n first p reconstruct using w suppose reconstructed length 2 construction strings length 2 i1 depend oracle strings length 2 nondeterministically verify strings also time 2 log k n find x 2 impagliazzo tardos it89 prove theorem 71 using xsearch problem also relate problem cnd complexity theorem 42 definition 73 xsearch problem player given n input variables zero wants find one player ask r rounds l parallel queries certain type wins player discovers one impagliazzo tardos use following result xsearch problem prove theorem 71 theorem 74 it89 queries restricted kdnfs n 2klr player lose nonzero setting variables one use proof similar theorem 71 prove similar bound theorem 74 needs apply theorem 42 relative strategy player one also use theorem 74 prove variant theorem 42 suppose theorem 42 fails every x exists small program nondeterministically distinguishes x x suppose know p find x asking dnf question based p ith bit x general know p many possibilities use additional round queries try programs test answers parallel give us general strategy xsearch problem contradicting theorem 74 8 bpp second level polynomial hierarchy one applications sipsers sip83 randomized version lemma 32 proof bpp sigma p 2 show approach taken lemma 32 yields new proof result first prove following variation lemma 31 1g exists prime number p logn proof consider prime numbers c 2c x holds log c logc different prime number p x p moreover gamma 1 different pairs strings exists prime number p among first gamma 1 logn logc prime numbers x holds x 6j x j mod p applying prime number theorem ing32 follows take c idea use claim 81 way approximate number accepting paths bpp machine note set accepting paths acceptmx x p set small exists prime number satisfying claim 81 hand set big prime number exists verified sigma p exists number p pairs accepting paths x order apply idea need gap number accepting paths x set square x set jjaccept mx jj kjxj x set jjaccept mx jj k 2 jxj apply zuckermans zuc96 oblivious sampler construction obtain gap theorem 82 let probabilistic machine witnesses set bpp assume mx uses random bits exists machine 0 uses 3m9m log random bits x 2 prm 0 proof use sampler zuc96 ffl 16 log 2 let 2 bpp witnessed probabilistic machine apply theorem 82 obtain 0 sigma palgorithm works follows input x guess log log log claim 81 guarantees program accepts hand x 2 jjaccept 0 log gamma1 every prime number log log pair strings acceptm 0 x congruent modulo p follows every number p log log 2 2m18m log log different u holds u 6j v mod p 2 acknowledgments would like thank jose balcazar leen torenvliet comments subject thank john tromp current presentation proof lemma 32 also thank sophie laplante important contributions section 5 thank richard beigel bill gasarch leen torenvliet comments earlier drafts r structural complexity functions computable nonadaptive queries np complexity generating checking proofs mem bership complexity theoremproving procedures classes bounded nondeterminism complexity promise problems applications publickey cryptography computing solutions uniquely collapses polynomial hierarchy distribution prime numbers decision versus search problems superpolynomial time jenner toran complexity optimization problem introduction kolmogorov complexity ap plications functions computable limited access np complexity knowledge representation complexity theoretic approach randomness np easy detecting unique solutions structural analysis complexity inverse functions tr ctr harry buhrman troy lee dieter van melkebeek language compression pseudorandom generators computational complexity v14 n3 p228255 january 2005 troy lee andrei romashchenko resource bounded symmetry information revisited theoretical computer science v345 n23 p386405 22 november 2005 allender nlprintable sets nondeterministic kolmogorov complexity theoretical computer science v355 n2 p127138 11 april 2006
coordination heterogeneous distributed cooperative constraint solving paper argue alternative way designing cooperative constraint solver systems using controloriented coordination language idea take advantage coordination features manifold improving constraint solver collaboration language bali demonstrate validity ideas presenting advantages realization practical well conceptual improvements constraint solving convinced cooperative constraint solving intrinsically linked coordination coordination languages manifold particular open new horizons systems like bali b introduction need constraint solver collaboration widely rec ognized general approach consists making several solvers cooperate order process constraints could solved least efficiently single solver bali 21 23 22 realization system terms language constraint solver collaboration language constraint programming solver collaboration glassbox mechanism enables one link blackbox tools ie solvers bali allows one build solver collaborations solver cooperation 25 solver combination 17 composing component solvers using collaboration primitives implementing eg sequential concurrent parallel collaboration schemes control primitives iterators fixedpoints conditionals hand concept coordinating number activities run concurrently parallel distributed fashion recently received wide attention 4 5 iwim model 1 2 ideal worker ideal manager based complete symmetry decoupling producers consumers well clear distinction computational coordina tioncommunication work performed process direct realization iwim terms concrete coordination language namely manifold 3 already exists due lack explicit coordination concepts con structs implementation bali fully realize formal model treatment disjunctions search jeopardized completely satisfactory constraint solving point view mainly due two causes 1 dynamic aspect formal model bali 2 use heterogeneous solvers ie solvers written different programming languages different data rep resentations coordination language able deal dynamic processes channels creation duplication dis reconnection able handle external heterogeneous solvers routines automatic data conversions fullfil requirements formal model bali overcome problem current implementation guided us different coordination models lead us iwim model manifold language coordination cooperative constraint solving intrinsically linked motivated investigation new organizational model bali based manifold results show widerthanexpected range implications system improved terms robust ness stability required resources constraint solving activity also improved resulting clarity search efficient handling disjunctions modularity system implemented closer formal model split three parts 1 constraint programming activity 2 solver collaboration lan guage 3 coordinationcommunication component qualified roughly quantified improvements coordination languages specifically manifold bring cooperative constraint solving conclusions promising feel confident undertake future implementation bali using manifold rest paper organized follows next section brief overview bali organizational model weaknesses implementation section 3 overview manifold describe coor dinationcommunication bali using features manifold system highlight improvements feel significant constraint solving sec tion 4 finally conclude section 5 discuss future work bali 21 environment solver collaboration ie solver cooperation 25 14 solver combination 26 29 separates constraint programming host language constraint solving solver collaboration language host language constraint programming language 34 possibly constraint logic programming language 16 11 necessary expresses required solver collaboration solver collaboration language solver collaboration language supports three strategies called solving strategies first strategy consists determining satisfiability constraint store time new constraint occurs incremental use solver second strategy alternative method solves constraint store final state reached eg end resolution logic programming last strategy allows user trigger solvers demand example test satisfiability store several constraints settled furthermore bali allows several solver collaborations conjunction different solving strate gies coexist single system example solver s1 used incrementally s2 executes end s3 s4 always triggered user since constraint programming part bali less interesting point view coordination 1 paper focuses constraint solving techniques ie constraint solver collaboration language bali domain independent language designed realizing solving mechanism terms solver collaborations following certain solving strategies basic objects handled language heterogeneous solvers used inside collaboration primitives integrate several paradigms sequentiality parallelism concur rency commonly used solver combination cooperation order write finer strategies also introduced control primitives iterator fixedpoint conditional collaboration language implementation level bali distributed cooperative constraint programming system composed language solver collaboration whose implementation allows one realize servers potential clients connect plus host language whose implementation special client server solver collaboration glassbox mechanism enables one link blackbox tools ie solvers applications already used bali 23 exam ple simulation cosac 25 realized solver collaborations designed nonlinear constraints 21 constraint solver collaboration language bali detailed description solver collaboration language bali found 23 21 section give brief overview collaboration primitives bali complete syntax solver collaboration language bali given figure 1 sequentiality denoted seq means solver e2 execute constraint store c 0 result 1 constraint programming part bali described 21 22 application solver e1 constraint store c several solvers working parallel denoted split constraint store c sent every one results solvers gathered together order constitute new constraint store analogous c concurrency denoted dc interesting several solvers based different methods applied nondisjoint parts constraint store result collaboration result single solver composed constraints manipulate result must also satisfy given property concurrency function set psi figure 1 example basic standard function psi returns result first solver finishes executing complex functions considered solved form selects result first solver whose solution specific solved form computation domain results solvers may even stopped soon chosen taken account concurrency primitive similar dont care commitment also provides control choosing new store using functions positive integers boolean observation functions e j e ar figure 1 syntax solver collaboration language bali primitives comprise computation part collaboration language connected combinators compose control part using primitives iterators conditionals fixedpoints order design complex solver collaborations fixedpoint combinator denoted f p repeatedly applies solver collaboration information extracted constraint store combinator allows one create idempotent solvercollaboration nonidempotent solvercollaboration primitives combinators completely statically defined introduce observation functions constraint store allow one get dynamic primitives functions evaluated runtime entering primitive using current constraint store functions may either arithmetic set oa figure boolean set ob figure 1 arithmetic observation functions profile stores n three functions 1 card var computes number distinct variables constraint store interesting solvers sensitive number vari ables 2 card c returns number atomic constraints comprise store important solvers whose complexity function number constraints solvers based propagation 3 card uni var returns number univariate atomic constraints essential solvers whose efficiency improved univariate constraints interval propagation solvers boolean observation functions profile stores boolean three functions 1 linear tests whether exists variable occurs atomic constraint interest deciding applicability linear solver 2 uni var tests whether least one univariate equality store information important since example univariate constraints generally starting point interval propagation 3 tri tests whether store triangular form ie equality constraints variable x variables x x z interesting eliminating variables determining ordering grobner bases computation repeat combinator denoted rep similar fixedpoint combinator allows applying solver n times n result application observation function composition observation functions constraint store since primitive takes account constraint form runtime improves dynamic aspect collaboration language finally conditional combinator denoted applies one solvercollaboration another depending evaluation condition also depend observation functions constraint store following example illustrates solver collaboration language seqadcbasicbcdspliteff pg consider applying collaboration scheme constraint store c 2 first applied c returns c1 b c applied c1 first one finishes gives new constraint store c2 e f execute c2 solution c3 composition c 0 3 solution e c 00 3 solution f finally g repeatedly applied c3 fixpoint c4 reached final solution collaboration 22 organizational model implementation role organizational model implemented 1 create distributed environment integrating heterogeneous solvers 3 2 establish communication solvers spite differences 3 coordinate ex ecutions organizational model turns solver collaborations servers clients implementation host language kinds processes requiring solver connect model enabled us implement bali createexecute solver collaborations 21 2 order simplify explanation consider solvers return one solution one disjunct detail treatment disjunctions next sections 3 solver software library tools clientserver architecture data representation written different programming language executes different architecture operating system 221 agent realizations solvers solver collaborations het erogeneous however encapsulation mechanism homogenize system obtain call agents agent autonomous created works terminates independently others hence agents execute parallel concurrently distributed architecture solvers encapsulated create simple agents shown 21 solver collaboration solver applying concept architecture encapsulation becomes hierarchical operation hence several simple agents encapsulated order build complex agent however viewed outside capsule simple complex agents identical admissibility converter recomposition eclipse internal eclipse converter figure 2 simple agent current implementation bali solvers encapsulated eclipse 4 processes see figure 2 hence eclipse launches solvers reconnects input output pipes data structure converters written prolog data exchanges capsules solvers performed via strings encapsulation also provides constraint store solver represents local database storing information admissibility function able recognize constraints store handled solver recomposition function recreates equivalent store using constraints treated solvers constraints admissible solver interface agent eclipse process moreover prolog terms transmitted two eclipse processes interagent communication thus realized high level terms strings bits furthermore need syntactic analyzers pairs agents complex agent encapsulation solver collabora behaves like simple agent though internal environment bit different see figure 3 constraint store keeping information receives knowledge base managing base recomposition function rebuilds constraint store agents send solutions major work complex agent coordination determined collaboration primitive represents agents encapsulates 4 eclipse 20 common logic programming system developed ecrc eclipse coordinator eclipse encapsulation internal eclipse recomposition encapsulation figure 3 complex agent 222 coordination describe coordination implementation bali see 21 details coordination formal model agent one three different states running r sleeping waiting w agent receive constraint c becomes running solve c agent w state waiting answer one agents agent state neither running waiting states together communication among agents enable us describe coordination constraint solvers sequential primitive seqs1 s2 sn tries solve constraint sequentially applying several solvers first sends constraint s1 waits solution c1 receives solution s1 sends s2 waits solution c2 sends s3 reaches sn finally solution cn sn forwarded superior agent one solutions sequential primitive since consider solvers enumerate solutions ie solution represents disjunct complete solution sequential agent must wait disjuncts sn treated way cn backtracking performed sngamma1 sngamma2 back s1 sequential collaboration several agents pipelined work parallel solutions passed sequentially one agent next primitive splits1 s2 sn applies several solvers parallel constraints solution split cartesianproductlike recomposition solutions s1 s2 sn split agent receives solve request superior forwards waits stores solutions finally split agent creates elements cartesianproduct solutions sends one one superior agent dont care primitive dc1 s1 s2 sn introduces concurrency among solvers upon receiving constraint c superior dont care agent forwards c subagents waits solution c 0 subagents c 0 satisfy 1 5 c 0 forgotten dont care agent waits solution another subagent one produced c 0 soon dont care agent receives solution c 0 5 1 element set boolean functions test whether constraint satisfies properties satisfies 1 subagents stopped c 0 well solutions produced forwarded superior agent fixpoint primitive f ps repeatedly applies con straint information extracted constraint solving process starts fixpoint agent receives constraint c superior iterative process iteration k consider set ck disjuncts treated eg iteration 1 c1 consists single element c iteration k mk disjuncts ck must treated fixpoint agent chooses one element ck cki removes ck sends collects solutions 6 solution equal cki fixpoint reached dis junct fixpoint agent forwards superior agent otherwise solutions produced added ck1 treatment applied elements ck complete set ck1 solving process enters iteration 1 process terminates end iteration k set ck1 empty repeat primitive coordination repeat primitive identical fixpoint collaboration except stops given number n iterations number n computed runtime result application arithmetic function ffi current constraint store arithmetic function ffi composed observation functions constraint store ele ments oa see figure 1 solving process starts repeat agent receives constraint c superior first n computed coordination analogous one fixpoint primitive process terminates end iteration n every solution returned every disjunct cn sent superior agent conditional primitive iffls1s2 reather simple receives constraint c superior agent primitive applies function fl c boolean function composed arithmetic boolean observation functions constraint store flc true c forwarded subcollaboration s1 otherwise sub collaboration s2 primtive becomes intermediary one subagents superior agent ie soon selected subagent sends solution forwarded immediately superior agent fact evaluation flc conditional primitive acts similarly sequential primitive single subagent 23 weaknesses implementation although eclipse provides functionality managing processes communication coordination language thus implementation exactly realize formal model bali features jeopardized even missing described disjunctions constraints disjunctions constraints returned solver treated one primitives even stored treatment delayed sequential primitive drastically jeopardize solving process fixpoint primitive really endangers resolution must wait disjuncts given iteration entering next one solution would duplicate due encapsulation mechanism 6 reaching fixpoint solver return one solution reasonable treatment disjunction leads loss efficiency mixed search 7 solving completely convenient constraint programming point view static architecture another limitation bali due fact architectures representing collaborations fixed due implementation constraints limitations coordination features eclipse collaborations first completely launched used solve constraints thus loss dynamics 1 parts architecture created even required 2 agents cannot duplicated although would interesting primitives fixpoint stated disjunctions always handled efficiently compromised features although formal model bali allows use light solvers implementation well suited support agents coarse grain encapsulation uses memory cpu solver thus mixing heavy solvers gb 10 maple 12 light solvers rewrite rules transformation rules recommended checks made ensure architecture communication channels created properly management resources load balancing static launching collaboration user must decide machine solver run 3 manifold new coordination bali explain use coordination language manifold 3 significantly improve implementation bali remain closer formal model 31 coordination language manifold manifold language managing complex dynamically changing interconnections among sets independent concurrent cooperative processes 1 manifold based iwim model communication 2 basic concepts iwim model thus also manifold processes events ports channels advantages targetedsendreceive model objectoriented programming models tools pvm 13 par macs 15 mpi 7 based discussed 1 27 manifold application consists potentially large number processes running network heterogeneous hosts may parallel systems processes application may written different programming languages manifold system consists compiler runtime system library number utility programs libraries builtin predefined processes link file generator called mlink runtime configurator called config system ported several different platforms eg sgi irix 63 sun 4 solaris 52 ibm sp1 sp2 linux mlink uses object files produced manifold language compilers produce link files makefiles needed compose executables files required platform run time ap plication config determines actual hosts processes created manifold application run 7 search strategy breadthfirst fixpoint repeat primitives depthfirst sequential dont care primitives library routines comprise interface manifold processes written languages eg c automatically perform necessary data format conversions data routed various different machines manifold successfully used number applications including parallelization reallife heavy duty computational fluid dynamics algorithm originally written fortran77 8 9 18 implementation looselycoupled genetic algorithms parallel distributed platforms 31 33 32 32 bali manifold although bali solvers blackboxes heterogeneous cause problems manifold integrates solvers external workers thus communication coordination defined among way normal manifoldagents manifold bring many improvements bali robustness managing faults system easy task eclipse ffl portability manifold runs several architectures requires thread facility subset pvm 13 ffl modularity current implementation constraint solving separated constraint programming using manifold also split coordination part solving part ffl extension collaboration language primitive independent coordinator thus adding new primitive simplified ffl additional new features manifold provides tools implement certain functionalities available current version bali eg choice machines light weight processes architectures load etc following elaborate significant points ie ones make intensive use manifold features ones significant constraint solving 321 lighter agents denoted coordinator rec conv solver adm conv figure 4 lighter simple agent current encapsulation one eclipse process solvercollaboration really heavy manifold produce lighter capsules using threads realize filters workers replace computation modules eclipse thus simple agent see figure 4 consist ffl coordinator managing messages agents inside encapsulation coordinator also inout gate capsule communicating superior agents ffl solver previous implementation ffl four filters manifold workers first filters constraints solver handle second converts data syntax solver third converts solutions solver global syntax 8 last recomposes equivalent solutions based solutions solver constraints cannot handle complex agent see figure 5 encapsulation several simplecomplex agents together filters filters coordinator coordinators described section 322 specialized collaboration primitive agent represents split collaboration one filter required store manager collects solutions subagent incrementally builds elements cartesianproduct soon one element completed sent coordinator dont care primitive one filter required applying function constraints sequential primitive well fixpoint filters required seq coordinator coordinator split dc coordinator sn sn sn store man coordinator fixpoint figure 5 lighter complex agent new kind encapsulation several advantages global architecture representing solver collaboration require less processes also less mem ory due several facts use threads instead heavy processes notion filters sharing workers filters solvers several agents see figure 6 creation another instance solver depend activity already running instances agents blackboxes anymore become glass boxes sharing solvers filters agents main advantage certainly following coordination separated filters encapsulated individual modules depends specific type collaboration implements use features manifold thus possible arrive coordination scheme respects formal model bali 8 global syntax syntax used filters agents store sn coordinator coordinator solver conv rec conv coordinator dc coordinator split conv conv solver adm f sn man rec figure shared solvers filters 322 coordinators using manifold new encapsulation process possible overcome problems inherent previous implementation bali dynamic handling solvers since coordination features separated filters workers set distributed architecture use longer disjoint phases means solving request sent collaboration built incrementally agent agent necessary components created example conditional guarded collab oration else subcollaboration launched another request sent collab oration launched components reused possibly augmented newly created components solvercollaboration requested solve con straint several cases arise solvercollaboration already launched instance created already launched instances busy ie instances currently working con straints another instance created otherwise one instances reused new computation function find instance manages functionality see appendix a1 dynamic handling disjunctions contrary current implementation 9 disjunctions treated dynami cally demonstrate sequential collaboration seqs1 s2 sn disjuncts produced s1 must sent s2 eclipse disjunct c1 s1 completely solved s2 sn meaning possible disjuncts created s2 sn produced treating next disjunct c2 s1 manifold allows us use pipelines solve c2 soon produced s1 s2 still working c1 instances s2 busy new instance s2 created solving c2 treatment c2 longer postponed mechanism applies subagents sequential agent introduces new problem may combinatorial explosion number instances s2 sn however rarely happen agent producing solutions agent i1 already solving already solved previous constraints thus 9 currently fixpoint coordinator waits solutions subcollaboration entering next iteration instances already returned sleeping state reused nevertheless following case may arise suppose solvers arranged index grows designated solvers become slower suppose every creates disjuncts number instances become exponential case system therefore run resources order overcome problem number instances limited see appendix a1 thus solving request sent agent maximal number instances reached instances busy superior agent wait first instance return sleeping state mechanism imply completely dynamic treatment disjunctions however gives good compromise delay solving disjunct physical limitation resources coordinators primitives describe coordinators sequential primitive primitives detailed appendix algorithms presented pascallike language extended event functionality consider queue messages p meaning message received port p task p alg means remove message port p execute algorithm alg message p condition executing task alg latter cannot interrupted end message sent agent enumerated disjuncts agents number flags representing states described section 222 figure 7 duplication sequential primitive coordinator seqs1sn s1sn subagents s0 supagent ports p0in pnin 0in1 piin linked psiout si p01out p0n1out 0in1 p0iout linked psiin si p0n1out linked ps0in s0 task c piin jnull send c pji1out mimi1 else send c piin c sent piin till instance si1 becomes free task end piin si1 sleeping si sleeping task end pnin sn1 sleeping sn sleeping send end p0n1out task c piin used forward solution i1 instance i1 free possible create new instance message sent treated later detect end sequential primitive count solutions end messages subagent agent becomes sleeping igamma1 already sleeping produces many end messages number solutions igamma1 superior agent s0 never duplicated inside collab oration since coordinator create subarchitec ture collaboration duplicate job superior agent either finds free instance collaboration creates one maximal number instances yet reached see figures 7 8 example duplication dc dc ys ss figure 8 duplication dont care primitive seen coordination languages manifold particular helpful implementing cooperative constraint solving however advantages implementation level manifold allows implementation closer formal model bali implies significant benefits constraint solving faster execution time better debugging clarity search 28 constraint solving see table 9 architecture also gains improvements robustness reliabil ity quality better management resources see table 10 last point also consequences end user architectures representing solver collaboration become lighter end user build complex collaborations thus solve problems could tackled constraint solving treatment disjunctions key point constraint solving commonly required search depthfirst time several candidates appear take one continue reaching solution backtrack try candidates one reasons choice generally one solution quired contrary first implementation bali coordination described manifold leads call parallel depthfirst quickfirst search parallel depthfirst search obvious quickfirst search arises fact constraint flows agents independently others hence ignoring boundary condition reaching instance limits solvers mentioned never delayed another constraint stops input solver queue result solution fastest compute even originated first disjunct solver better chance become first solution given solver collaboration 10 debugging collaboration improvement graphical interface present output eased coordinators duplicate messages send special worker latter linked display window text graphic profiler enable users observe flow data collaboration thus users extract statistics utilization solvers draw conclusions efficiency newly designed collaboration process lead methodology designing solver collaborations due encapsulation techniques current implementation jeopardizes use fine grain solvers solvers require little memory cpu although envisage encapsulating single function eclipse pro cess reasonable though really designed fine grain agents manifold still gives freedom use single functions rewrite rules constraints trans formations solvers manifold single functions simplifying constraints easily inserted collaboration threads without compromising efficiency whole architecture significantly enlarges set solvers integrated bali bali eclipse manifold search solving mixed depthfirst first solution execution time treatment disjunctions use fine grain solvers add solvers encapsulation extension collaboration language debugging tools improvement solver collab input graphical interface output graphical interface figure 9 improvements constraint solving coordination separated collaboration collaboration primitive implies coordinator separated converters recomposition functions admissibility branch leads faster solution find quickly explore branches one functions thus filters easily implement new primitives coordinator modi fied cases filter must added architecture major limitation bali large amount resources requires course intrinsic problem cooperative solvers generally costly memory cpu etc another limiting factor overhead current encapsulation mechanism new encapsulation technique manifold decrease required resources furthermore dynamic handling disjunctions expect new architecture less voracious bali eclipse manifold construction architecture static dynamic robustness extension bali stability graphical interface inoutput quality communication coordination functionalities number processes solvers number communications figure 10 improvements architectures system gain robustness since currently failure detection architecture possible collaborations stable less susceptible broken communication memory allocation problems dynamic building architecture decrease number unnecessary processes agents required computation launched negative point increased communica tion current implementation encapsulation composed two communicating processes eclipse solver filters modules eclipse process manifold filters independent agents also exchange information however create bottleneck since messages generally short communicating agents usually threads process using shared memory communicate single agent conducts monitors communication 5 conclusion introduced alternative approach designing cooperative constraint solving systems coordination lan guages manifold particular exhibit properties appropriate implementing bali however implementation improvement advantage using manifold produce system closer formal model bali significant benefits also obvious constraint solving major improvements treatment disjunctions homogenization search reduction required resources fare management disjuncts returned solver often leads quicker solutions moreover due replication complete set solutions always computed efficiently although mixed search used current implementation bali really influence resolution looking solutions problem becomes real nuisance looking one solution furthermore observing resolution following flow constraints conceiv able manifold overcomes problem providing parallel depthfirst quickfirst search disjunct handled independently thus constraint resolution delayed queued comparing bali systems cc 30 oz 19 easy since objectives 21 cc formal framework concurrent constraint programming oz concurrent constraint programming system however one major distinctions bali contrary oz cc enables collaboration heterogeneous solvers another essential difference concerns separation tasks oz cc constraint pro gramming constraint solving coordination agents mixed bali constraint programming separated cooperative constraint solving using manifold cooperative constraint solving split coordination agents constraint solving aspect cooperative constraint programming independent task since implementation model bali manifold clearly defined surely start implementation phase moreover know feasibility task already qualified well roughly quantified improvements hence know worthwhile work future plan integrate visual interface assist programmers writing complex solver collab orations achieved using visifold 6 predefined graphical coordinators order perform optimization thinking adding another search technique bali best solution search branch bound kind search generally managed constraint language however manifold coordinators represent collaboration primitives perform following tasks eliminate disjuncts current best solution also manage updating current best solution branching thus improved performed sooner constraint solver extension mechanism solex 24 consists rulebased transformations seen elementary solvers implementation solex bali really conceivable rulebased transformations fine grain solvers encapsulated new model implementation solex becomes reasonable finally convinced cooperative constraint solving intrinsically linked coordination coordination languages open new horizons systems like bali r coordination massively concurrent activities iwim model coordination concurrent activities manifold20 reference manual mean coordination languages parallel programming visifold visual environment coordination language introduction mpi standard restructuring sequential fortran code paral leldistributed application using coordination parallelize sparsegrid methods 3d cfd problems maple v users guide reference manual symbolicnumerical branch prune algorithm solving nonlinear polynomial sys tems parmacs v6 constraint logic pro gramming survey combining symbolic constraint solvers algebraic domains multiple semicoarsened multigrid 3d cfd eclipse user manual collaboration de solveurs pour la programmation logique contraintes phd thesis universite henri poincarenancy environment designingexecuting constraint solver collaborations constraint solver collaboration language bali solex domainindependent scheme constraint solver ex tension implementing nonlinear constraints cooperative solvers simplifications cooperating decision procedures search strategies computer problem solving cooperation decision procedures satisfiability problem concurrent constraint programming distributed evolutionary optimization manifold rosenbrocks function case study parallel distributed evolutionary computation manifold parallel evolutionary computation multi agents genetic algorithm strategic directions constraint programming tr ctr monfroy carlos castro basic components constraint solver cooperations proceedings acm symposium applied computing march 0912 2003 melbourne florida
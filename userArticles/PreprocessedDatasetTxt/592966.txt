continuous data block placement elevation tertiary storage hierarchical storage servers given cost memories large storage bandwidth requirements largescale multimedia databases hierarchical storage servers consist diskbased secondary storage tapelibrarybased tertiary storage becoming increasingly popular server applications rely upon tape libraries store media exploiting excellent storage capacity cost per mb characteristics also rely upon disk arrays exploiting high bandwidth satisfy large number requests given typical access patterns server configurations tape drives fully utilized uploading data requests fall tertiary level upload operations consume significant secondary storage device bus bandwidth addition present technology trends disk array serve fewer requests continuous objects store mainly due io andor backplane bus bandwidth limitations work address comprehensively performance hierarchical continuousmedia storage servers looking three main system resources tape drive bandwidth secondarystorage bandwidth hosts ram provide techniques fully utilizing tape drive bandwidth expensive resource introduce bandwidth savings allow secondary storage devices serve requests without increasing demands hosts ram space specifically consider issue elevating continuous data permanent place tertiary display purposes develop algorithms sharing responsibility playback secondary tertiary devices placing blocks continuous objects tapes show achieve goals study issues different commercial tape library products different bandwidth tape capacity environments without multiplexing tape libraries b introduction future multimedia information systems likely contain large collections delay sensitive data objects eg audio video various lengths requirements main data characteristics present serious challenges building multimedia servers large size delaysensitivity data high display bandwidth requirements multimedia objects large size one example 100 minutes mpeg2 video may require 6 gb storage thus storage requirements future continuous media servers many different applications easily exceed several terabytes cost memory strongly depends type memory em ployed currently ram memory cost 10 per mb individual magnetic disk storage cost 01 per mb see ex ample cost high performance disk drives quantum atlas httpwwwquantumcomand seagate cheetah httpwwwseagatecom large number disk drives grouped using disk array technology store large amounts data cost disk storage becomes greater 03 per mb see example maximum strategys gen5 disk array product httpwwwmaxstratcom magnetic tape storage cost less 0004 per mb higherend tape libraries tape storage cost per mb ranges per mb eg highperformance ampex dst812 library 50gb tapes httpwwwampexcomhtml significantly lower figures 330gb tapes capital costs different types memories also include organizations costs managing storage systems quite significant disk storage reported 7 per mb tape library storage due automated functions cost minimal sim97 indication absolute dollar costs companys capital investment storage required fullfledged video server thousand videos currently around 12tb would around 400000 highperformance tape library chosen 128tb ampex dst812 library four drives 256 50gb tapes 4000000 eight gen5 disk arrays storing 17tb given small midsized companies reported willing spend annually less 50000 120000 mass storage respectively cost difference ensures dominant place market tape libraries fact annual tape library market reported growing pace 34 submarkets growing pace around 50 sim97 thus tape library storage attractive storage cost primary concern hand access speeds memory units point different direction tertiary storage characterized slow access times order tens seconds minutes lowerend products magnetic tape libraries magnetic disks access times order tens milliseconds whereas ram memories access times order tens nanoseconds strong arguments employing hierarchy memory tech nologies forming hierarchical storage management system hsms including rambased primary storage ps magnetic diskarraybased secondary storage ss tapebased tertiary storage ts key idea hsms store objects inexpensive ts elevated ss ps levels accessed solves problems owing large storage space requirements continuous media servers costs memory units complementary idea use higher levels cache levels objects reside permanently ts popular objects ex ample reside long periods time ss portions reside long periods time ps idea addresses problems owing memories access times delaysensitivity high display bandwidth requirements many continuous objects given reported market growth tape libraries becoming increasingly popular low level hsms fact respect continuous media applications several companies developed video storage solutions based tape libraries applications broadcasting hen97 envisaged solutions tape libraries occupying lowest level hierarchy used mainly storing vast amounts data exploiting excellent cost per mb characteristics disk arrays used high bandwidth order serve many requests possible time colder hoter data objects migrate disks tapes tapes disks mind paper addresses cleverly exploit bandwidth offered table storage display parameters explanation typical values bd display bandwidth consumption rate blocks object varies userdefined block size varies userdefined time display time 1 block varies depends bt tape drive bandwidth 05 20 mbsec tape drives 1 64 e robot exchange time 6 40 sec c switch search tape cartridges r bt bd 05 50 jobs multiplexed varies blocks time slice multiplexing varies modern tape drives employed hsmss continuous media applications help increase overall systems performance 11 hierarchical storage management systems discuss hsmss detail paying attention specifications functionality order gain relevant insights put contributions work context summary hsmss relevant parameters typical values given table 1 appropriate candidate ss appears arrays magnetic disks pgk88 given high bandwidth requirements many multimedia objects typical relatively low effective bandwidth magnetic disks nominal bandwidths range 415 mbsec striping techniques sgm86bmgj94tf98 likely prove beneficial since striping objects across several disks effective ss bandwidth objects several tape cdrom based elevate primary storage ps secondary storage ss diskbased tertiary storage ts figure 1 conceptual model hierarchical storage management system hsms times single disk currently average seek rotational delays approximately 810 35 msec respectively respect ts technological developments led emergence robotbased magnetictape libraries making best candidate ts devices given desirable cost per megabyte figures tape libraries consist series shelves storing number tape cartridges number tape drives onto tapes must loaded objects accessed number robot arms usually 1 responsible loading unloading tapes drives despite tss high data transfer rates see table devices remain comparatively slower magnetic disks due high exchange costs unload tape put shelf get another tape load cost searching within tape proceeding maximum pace less 16 gbsec conceptual model hsms illustrated figure 1 conceptual model shows three levels hsms data elevated one level time rest paper term elevate reserved elevate ts ss figure 2 illustrates physical architectural view hsms key feature must noted ps serves intermediate staging area ts ss device object required ssresident order displayed also displayed ts display consume upload tape controller disk array secondary storage ss robotic tape library tertiary storage ts disk controller primary storage ps retrieve flush figure 2 physical model hierarchical storage management system hsms 12 related work motivations problem 121 big picture great consensus io subsystem computer system become performance bottleneck pgk88pat93 observation motivation large body research area storage servers aiming increase available ss bandwidth system one thread research led development disk arrays pgk88 development new methods placing data objects disk arrays attempt exploit inherent potential high performance reliability sgm86pgk88cp90 gea94 mainly data placement techniques striping multimedia data video audio require large storage capacities large io bandwidths making disk arrays natural choice ss medium researchers multimedia video storage servers started paying attention placement multimedia data ss devices way increase systems performance effectively utilizing available ss bandwidth system rv93ls93grtea93bmgj94kk95 ors96tf98 another thread concentrated developing techniques reduce number required secondary storage ios exploiting mainmemory buffer caches characteristics several emerging applications video demand servers buffer data sharing techniques batching bridging adaptive piggybacking prefetching smartdisk caches research attained reduction required number ss io streams required support video object requests krt94rz95glm96ds94dan95ass96th99 thus far related research concentrated techniques cleverly exploiting ps ss resources system order increase perfor mance respect tertiary storage efforts modelling performance characteristics individual tape drives robotic tape libraries hs96bhs96ajm98ajm98b joh96jm98ajm98b respectively predict future references prefetch documents ss kw98 digital library applications derive intelligent placement strategies data library ctz97 well efforts derive intelligent scheduling algorithms multiplexed video streams tape drives kmp90llw95 mentioned introduction diskbased storage viewed presently costly store thousands video objects fullfledged video server thus ts employed storage augmentation purposes continuous object played either ts ss che94 kdst95gr98che98 one may play ts object issuing upload requests ts uploaded blocks object placed ps buffers subsequently consumed 1 either transmitted network remote client displayed local client however note bandwidth ts tape drives typically significantly greater display bandwidth objects thus playing objects directly ts general create serious ps buffer space problems result much preferable choice first elevate object ts ss physically upload ts ps flush ps ss subsequently play ss object issuing retrieval requests ss blocks displayed gs94kdst95 furthermore given users would tolerate high response times playback process must started immediately enough data elevated ss hence typically retrieval 1 terms consume display playback play used interchangeably paper operations executing behalf playback process executed parallel elevate operations move future blocks object ss gds95 let us refer procedure ie elevate ts ss simultaneously play ss represents research state art displaying continuous objects residing ts conventional play method 122 problem paper assumes framework continuous media server based hierarchical storage manager research reported first addresses important problem continuous data elevation permanent place ts higher levels ct95 particular concentrate ondemand elevation ie elevation occurs display request object arrives ondemand elevation nontrivial problem since must deal bandwidth mismatch problem firstly display bandwidth requirements objects different bandwidths ts ss devices secondly sustained available effective ts bandwidth vary time depending requirements current workload eg whenever multiplexing employed example system configuration problem setup let us consider example hsms system configuration employed media server movieviewing teleteaching digital libraries videobased multimedia applications lower level high performance tape library based ampex dst812 tape library 128 storage four drives 256 50gb tapes costing 400000 ss level acts cache high performance disk array based maximum strategys gen5 array consisting 95 magnetic disks storing totaling 10 tertiary storage costing 500000 125 tertiary cost considering 90 minute mpeg2 videos require 3gb storage 6 videos fit disk thus ss level store 570 videos total assuming simplicity 500kb video disk blocks display time one second present technology disk drive array isolation support uninterrupted display 16 videos eg 12mbs transfer rate 8ms average seek cost 4 ms average rotational delay 1 ms trackcylinder switch cost however due bandwidth limitations frontend backend io buses combined data transfer rate array 250mbsec 20 times single member drive thus although whole ss store 570 videos support playback 20 theta 16 320 video requests assuming realworld system several hundred video requests system time zipf accessrequest distribution videos eg 1015 popular videos receiving 70 requests thus important create copies popular videos employ clever video placement copies ss disks load balanced serve many video requests possible given considerable ss bandwidth addition sustaining playback ssresident videos required elevating colder video blocks ts ss easy see systems ss io bandwidth consumed fact please note products servers supporting large numbers disks currently constrained backplane bus limitations many times smaller combined raw disk bandwidth www98www97 fact recognized many storage system researchers rgf98kp98 key problem focus framework using conventional play method ts used storage augmentation purposes simply store large number colder videos elevate ss request arrives since typically ts bandwidth sufficient support requests fall ts level che98 ts drives fully utilized elevating colder video data ss ss io bandwidth including backplane bus bandwidth also fully utilized supporting retrieval requests video blocks elevation requests ts blocks mentioned even without bandwidth consumed data elevation ts ss stores many videos support ss bandwidth consumed need elevate colder videos ts available ss bandwidth decreases significantly key goal work develop techniques cleverly exploit bandwidth tape drives elevation save io bandwidth saved bandwidth allow ss serve additional requests videos stores thus improve overall system performance easy task despite high transfer rates modern tape drives average access cost tape libraries remains high currently three orders magnitude higher due high costs robotic movements head positioning delays thus focus requests delaysensitive data elevation ts higher levels goals achieving io bandwidth savings addition hiccupfree displays video streams low startup latencies saved io bandwidth used accept serve additional requests ssresident data time handle bandwidth mismatch problem data elevation manner allows savings io bandwidth requiring extra ps buffer space remainder paper structured follows section 2 present alternate play novel algorithm ondemand data elevation levels hierarchy discuss benefits respect io bandwidth savings compromises respect ps buffer space section 3 contribute set novel techniques place blocks video objects tertiary storage media manner alleviates need extra ps buffer space companion play algorithms achieve ss bandwidth savings alternate play algorithm subsequently contribute notion strips streams use makes techniques applicable even display bandwidth requirements larger available ts bandwidth eg lowend tape drives section 4 revisit issues contributing algorithms analyses case tape library multiplexed across streams avoid experiencing unacceptablylong startup latencies able offer ss savings earlier sections many video requests section 5 revisit issues assumption fixed known priori multiprogramming degree removed section 6 discuss realworld pitfalls algorithms used avoid finally section 7 present conclusions work 2 data elevation alternate play section present novel elevation method achieving io bandwidth savings compared conventional play new method integral part many algorithms rest paper 21 alternate play obvious advantage conventional play method requires additional ps buffer space 2 hand obvious deficiency ss additionally taxed result execution flush retrieval operations reducing thus available io bandwidth significantly since target environment expect io bandwidth one two scarcest resources observation must noted seriously following present approaches aiming alleviate problem initial attempt overcome shortcomings conventional play method centers following idea uploaded blocks ts maintained ps buffers made available playback process save significant io bandwidth course blocks belonging popular objects may still flushed ss addition maintaining ps buffers consumed alteration play ts method ie play ts flush ss compared conventional play saves bandwidth current request since retrievals ss needed also future requests object additionally tax ts ss since uploads flushes ssresident blocks needed despite unquestionable benefits obvious concern regarding amount ps buffer space needed realize aforementioned bandwidth savings example 2 ps space requirements 50 size entire object displayed since last block uploaded half blocks consumed general ps space requirements r gamma 1r objects size given ps buffer space another scarce system resource care must taken use wisely effort reconcile tradeoff ps space requirements io bandwidth savings use hybrid techniques blocks conventional play method essentially play ss employed blocks play ts method followed refer newly 2 throughout paper ps buffer space requirements refer maximum number ps buffers holding 1 block required instance display object buffers holding blocks currently displayed displayed next time unit currently elevated ss counted since cases using buffer unavoidable table example alternate play r 2 b13 time elevated uploaded block unit ss ps displayed proposed method alternate play algorithm special case example alternate play algorithm 13block object playing oddnumbered blocks ts evennumbered blocks ss shown table 2 newly arriving blocks underlined alternate play algorithm terminates blocks read ts display requested object continues consuming remaining blocks strict alternation ps ss end half blocks played ts half ss two features described alternate play algorithm must noted first execution ie first l time units objects display ss bandwidth requirements even time units twice ss bandwidth requirements odd time units remaining time units ss bandwidth requirements equal odd time units second algorithms execution every two time units number ps buffers needed hold play ts blocks increases 1 end algorithms execution half b2 play ts blocks still ps thus follows ps space requirements 25 objects size 22 generalizing alternate play 221 integer r r2 alternate play algorithm last section generalized handle arbitrary r ratios follows every time unit r blocks read ts r blocks k blocks uploaded ps played remaining rgammak blocks elevated ss arbitrarilyappropriately chosen gives us family alternate play algorithms one different value k pseudocode described alternate play given algorithm 1 given algorithm uses routines upload indicated block ps buffer algorithm 1 alternate play input objects blocks ts next upld blk next displ blk uploadnext upld blk time unit 1 l r parbegin 1 1 playfromssnext displ blk else consumenext displ blk 2 j 1 r gamma k elevatenext upld blk j 1 k uploadnext upld blk parend elevate ie upload flush indicated block ss parbeginparend construct intended indicate display consume playfromss block occurs parallel readings elevate upload next two blocks ts reader may verify table 2 trace algorithm 1 r2 k1 case obvious question best value k answer question examine impact choice k ss bandwidth savings required ps buffer space value k ss bandwidth savings bkr blocks since k every r blocks neither flush retrieve ss required also value k ps buffer space requirements bkr gamma 1r 2 holds algorithm runs br time units bkr table example brc alternate play r 35 k1 b22 time elevated uploaded block unit ss ps displayed blocks uploaded ps k blocks per time unit bkr 2 blocks kr blocks br time units played ts therefore blocks still ps algorithm terminates thus see tradeoff ss bandwidth savings required ps buffer space higher blocks played ss blocks played ts ratio lower ps space requirements become lower ss bandwidth savings achieved k parameter general algorithm acts knob finetuning tradeoff 222 real r alert reader may realized far made implicit assumption r arbitrary integer r real number likely case realworld situations one may apply ideas uploading k every brc blocks ps playing example shown table 3 newly arriving blocks underlined block brackets indicates part block uploadedelevated clearly ss bandwidth savings outlined algorithm compared conventional play algorithm bk brc blocks ps space requirements algorithm bkr gamma 1r brc bkr holds algorithm runs br time units displaying br blocks time bk brc blocks uploaded ps bkr brc blocks k brc blocks eac h br time units played ts therefore algorithm terminates number blocks still ps one might course chose upload k every dre blocks alternatively ps space scarce one might chose upload sometimes k every brc blocks times k every dre blocks method discussed section 322 3 data elevation without multiplexing alternate play methods preceding section blocks played ts ss starting point derivation better playing algorithms 31 apwat discussed earlier high ps buffer requirements alternate play method due long time ps buffer dedicated holding particular play ts block observe also long time dependent r r large play ts blocks occupy ps buffer long time since come ps buffer far ahead consumption times trying attain reductions ps space requirements key idea altering order blocks object recorded ts media large values r ie bandwidth mismatches ts display accounted way reduces occupancy time ps buffers play ts blocks algorithm 2 placement algorithm given inputs b r algorithm 2 twisted placement integer r input b integer r output rtwisted sequence objects blocks placed ts i0 l r randomly place blocks b b r blank tape positions determines rtwisted placementsequence objects blocks locations tape examples twisted sequences given figure 3 randomly place blocks algorithm 2 sequentially b figure 3 2twisted b 4twisted placements 13block object place blocks given examples one may immediately see produced rtwisted sequence given r objects blocks read tape sequentially every rth block boldfaced figure 3 uploaded ps precisely time consumed br blocks thus played ts without ps buffer space requirements remaining blocks elevated ss played ss needed algorithm 3 materializes idea notational conventions algorithm 1 used algorithm 3 apwat rtwisted sequence systems bandwidth ratio r input rtwisted placement objects blocks ts next upld blk next displ blk uploadnext upld blk time unit 1 l r parbegin 1 consumenext displ blk 2 j1 r gamma 1 elevatenext upld blk uploadnext upld blk parend note given alternate play twist apwat algorithm essentially alternate play algorithm blocks played ts others ss applied specific arrangement objects blocks boldfaced blocks played ts apwat algorithm terminates blocks read ts display requested object continues consuming one block ps remaining blocks exclusively ss ss bandwidth requirements remain constant r gamma 1 blocks per time unit throughout algorithms execution display remaining blocks requires constant bandwidth 1 block per time unit example apwats action 2twisted sequence figure shown table 4 newly arriving blocks underlined one immediately see ss bandwidth savings apwat method br blocks since 1r blocks played ts object clearly also ps buffer requirements zero 32 generalizing apwat 321 disassociating integer r twisting given system parameter r apwat applied r twisted sequence also r twisted sequence k divisor r case apwat play boldfaced blocks r twisted sequence ts example apwats action 2twisted sequence 13block object see figure 3a r4 given table 5 newly arrived blocks underlined clearly systems bandwidth ratio r ss bandwidth savings newest apwat algorithm applied r twisted sequence bkr blocks since kr boldfaced b blocks never flushed retrieved ss ps buffer space requirements new algorithm bkgamma1r true algorithm runs br time units number blocks ps increased k uploaded ts decreased note space requirements zero note also apwat always better alternate play sense attainable ss bandwidth savings apwats ps requirements less alternate plays ps requirements follows since bkrgamma1 r equivalent r k always true 322 real r case alternate play algorithm section 222 apwat algorithm companion twisted placement algorithm require r integer one may generate brctwisted sequence apply apwat playing boldfaced blocks ts lets call algorithm brc apwat algorithm obvious drawback brc apwat algorithm ps buffer space requirements zero indeed one may routinely verify worst case ps buffer requirement increase brr gamma 1 apwat algorithm runs br time units displaying br blocks time b brc blocks uploaded ps since blocks played ts algorithm terminates number blocks still left ps b brc ps space scarce alternative brc apwat possible main idea generate twisted sequence apwatplayed figure 4 23twisted sequence 20block object boldfaced block ever uploaded earlier time consumed actually since r may integer block allowed uploaded earlier time consumed fraction time unit example twisted sequence given figure 4 pseudocode given algorithm 4 since distances boldfaced blocks new algorithm 4 twisted placement real r input b real r output rtwisted sequence objects blocks placed ts i1 l r randomly place blocks b b r blank tape positions method sometimes 1 brc sometimes 1 dre refer new twist play method brcdre apwat algorithm clearly ss bandwidth savings newest brcdre apwat algorithm br blocks ps requirements 1 block needed hold parts partially uploaded blocks 323 disassociating real r twisting system parameter real number r apwat applied rtwisted sequence also r 0 twisted sequence r 0 r apwat play boldfaced blocks r 0 twisted sequence ts reasoning section 321 one may easily verify ss bandwidth savings case br 0 blocks ps requirements b 1 table 6 summarizes performance examined play algorithms table play algorithms performance comparison ps ss bandwidth requirements savings remarks conventional play 0 alternate play r integer r r integer r r divisor r integer r real gammar real 33 ssresident objects strips streams although mentioned explicitly far previously described algorithms work r 1 one may notice r 1 situation may indeed arise eg lowend products see table 1 one may also immediately see r 1 restriction obviously deficiency algorithms r1 object resides exclusively ts algorithm display without hiccups without long response time r 1 object resides ss well one may use ideas presented previous sections display object manner requiring less ss bandwidth obvious play ss algorithm still requiring zero ps buffer space goal contribute concept strip stream 331 integer r strip stream subset blocks stream object define 1 r strip stream strip consisting every 1 r th block object except 1st block object example 2strip b3 b5 b7 b9 3strip b4 b7 b10 b13 etc store 1 r strip partial replica object permanently ts one may see continuous uploading ts blocks results block brought ps precisely consumed pseudocode displaying object manner given algorithm 5 nota algorithm 5 strips stream playing r 1 1 r strip brbgamma1c blocks ts ffl rest objects blocks ss next upld blk first block strip next displ blk uploadnext upld blk time unit 1 1 r playfromssnext displ blk time unit b parbegin 1 consumenext displ blk playfromssnext displ blk 2 uploadnext upld blk parend tional conventions algorithms 1 3 used trace algorithm given table 7 unlike previous algorithms given strips stream play algorithm terminates blocks displayed simply read ts eventually rb objects b blocks played ts remaining 1gammarb ss compared conventional play algorith strips stream play algorithm achieves rb blocks ss bandwidth savings ps buffer space requirement algorithm zero table example strips stream play b12 r05 time uploaded block unit ts strip displayed 56 b7 b5 b6 78 b9 b7 b8 table example strips stream play 23 time uploaded block unit ts strip displayed 1023 b4 b1 b2 b3 2346 6992 148161 171184 332 real r given definition 1 r strip meaningful 1 r integer r arbitrary real 1 r strip defined block strip uploaded precisely consumed example reader invited verify 23 the23 strip 20block object b 4 analogy 1 23 strip boldfaced blocks 23twisted sequence figure 4 obvious strips stream play applied 1 23 strip play object shown table 8 notation 03 block b 3 displayed pseudocode generating r strip arbitrary r given algorithm 6 algorithm 6 1 r strip generation real r1 input b real r1 r strip s1 sb r 1 l r 4 data elevation known multiplexing degree many environments consisting highend tape library products large bandwidth tertiary storage level multimedia server satisfying one requests simultaneously order avoid unacceptably high startup latencies desirable ts multiplexed bandwidth multiplexed across several concurrent streams effective ts bandwidth b teff effective ratio r eff reduced assume round robin scheduling discipline multiplexed requests moments thought reveals using say apwat algorithm twisted sequence r work consider example twisted sequence r 4 given figure 3b number multiplexed jobs multi plexing degree two multiplexed jobs 3 apwat algorithm round robin scheduling time slice equal suffer hiccups instance b1s two objects displayed apwat elevateupload next 4 blocks first object take time unit switch elevateupload next 4 blocks second object also take 1 time unit thus apparent displays starve another approach use apwat algorithm twisted sequence figure 3a instead figure 3b example apwat algorithm round robin scheduling time slice equal d2 3 readability purposes assume exchange overhead display objects without hiccups elevateupload pair blocks first object take 12 time unit switch elevateupload pair blocks second object take another 12 time unit method playing boldfaced blocks ts rest ss requires extra ps buffers achieves 50 ss bandwidth savings since half blocks played ts compared conventional play algorithm crucial factor last approachs success besides use twisted sequence r fact time slice time needed blocks see indeed crucial consider example extreme case time slice equal time needed upload 12 blocks last approach could achieve 50 ss bandwidth savings extra ps buffers sequence r suggests small time slices better big ones one thus use time slices small possible unfortunately discussed earlier approach oversimplified since switch cost c includes possibly tape exchange cost plus search within tape associated round robins switch one object another therefore derived minimum time slice sufficient display objects without hiccups nevertheless position describe general approach derive minimum time slice 41 apwat round robin basic idea split objects blocks groups blocks called ttuples simply tuples appropriate value follows first ttuple contain blocks second ttuple contain blocks b t1 b 2t etc order process upload elevate display ttuple efficient way use rtwisted placement blocks within ttuple desired twisting slightly different one produced algorithm 2 twisted placement produced algorithm 2 places first blocks object locations 1 r1 2r1 3r1 etc integer r twisted placement useful case places first blocks tuple locations r 2r 3r within tuple arrangement objects blocks called rorganization simply torganization example shown figure 5 pseudocode deriving rorganization given algorithm 7 figure 5 84organization 17block object number full ttuples possibly one ttuple fewer blocks note xi r bold blocks ttuple general contents nth ttuple set blocks occupy tape positions first bold block nth ttuple b ngamma1t2 ith bold block ttuple placed position ir within positions occupied ttuple r algorithm 7 twisted rorganization input b integer r outputt rorganization n1 place bold blocks proper position i1 xi r randomly place unassigned blocks set fb blank tape positions set fn gamma 1t stated earlier j objects displayed multiplexed round robin fashion time slice process one ttuple employing apwat algorithm example suppose r4 consider 84organization figure 5 displaying b 1 first object round robin algorithm elevate b 4 displaying b 2 elevate start displaying b 3 switch second object processing first 9 blocks possibly third object also processing first 9 blocks etc uploadselevations blocks second third etc objects display process first object finish consuming b 3 subsequently start playing 9 ss guarantee play objects hiccups round robin return first object display b 9 started last remark used derive relationship j explained time required read j ttuples one tuple object less equal time needed display blocks tuple read time slices earlier since time needed upload ttuple tsb tdr switch cost c follows time required read j ttuples tdrcj tsb also time needed display blocks one object td thus td td r hold allows us derive minimum allowable value given systems characteristics c r equivalently since drsb r b number j multiplexed jobs cjr j r condition intuitively correct number jobs multiplexed greater number blocks uploaded time unit multiplexing possible mathematically consequence 0 condition must hold together 1 note also 2 gives min jb multiplexing possible example 1 consider object consisting 12000 blocks 05 mb residing ts bandwidth 20 mbsec exchange cost 10 sec assume time needed display one block 1 sec figures imply r40 eqn 2 says display objects multiplexed using apwat round robin object split 30 tuples least 400 blocks inequality 1 may seen different angle assume size tuple somehow fixed gives us maximum number jobs multiplexed rtd cr tsr ts example 2 given configuration described example 1 eqn 3 says object split 30 tuples 400 blocks 20 objects multiplexed given system bandwidth ratio r apwat algorithm using r configuration zero ps buffer requirements since uploaded boldfaced figure 5 block j objects uploaded precisely consumed clearly also ss bandwidth savings br j jobs yielding total savings jbr blocks j jobs compared conventional play algorithm elevating blocks ss playing note discussed section 321 given systems ratio r one need use rconfiguration one may use instead r k configuration dividing r case see table 6 ps buffer requirements ss bandwidth savings jbkr blocks j jobs similarly also handle case r real omit relevant details space reasons since similar description presented section 322 42 startup latency considerations algorithms sections 2 3 issue startup latency addressed detail since important assuming one display request time startup latency equal time needed upload 1st block object however multiplexed environment issue deserves attention assuming requests j objects arrive simultaneously display 1st object start delay sb ie b 1 1st object uploaded display 2nd object start delay sb tsb c ie 1st ttuple first object uploaded switched beginning 2nd object b 1 2nd object uploaded etc therefore display jth object start 4 worst case scenario assuming techniques bridging batching adaptive piggy backing employed delay r precise effect choice becomes clear given certain multiplexing degree j one chooses min startup latency higher implied 4 ts idling since time slice 1st object arrives blocks uploaded previous time slice consumed allowing used purposes nonetheless display object done correctly ie without hiccups ps space requirement still zero total ss bandwidth savings still jbr j jobs worth noting configuration example 1 20 maximum startup latency witnessed multiplexed stream smaller 7 minutes multiplexing performed serve 20 streams maximum startup latency witnessed would one hour thirty eight minutes course unacceptable videoondemand applications 5 data elevation unknown multiplexing degree algorithms previous section generating rorganizations subsequently apwatplaying work number j multiplexed jobs known advance section discuss methods overcoming limitation assuming r1 j r multiplexing j display requests possible may thus assume known upper bound j maximum value multiplexing degree j system obviously order display j objects arbitrary 2 j j suffices use min j organization according 2 min j j discussion last paragraph section 42 implies using min j organization work correctly without changing attained ss bandwidth savings jbr blocks required zero ps buffer space one drawback last proposal fact ts may idling discussed section 42 additionally proposal suffers increased startup latency shown 4 startup latency great importance tradedoff additional ts media storage space follows create store min j 1 organization min j 2 organization etc various values used min j organization full replica object ts frequently workload guessed using past experience used guide decide replicas create run time given current multiplexing degree j curr use smallest min j value larger min j curr result smallest possible startup latency hand shown 3 selecting smallest min j value larger min j curr results smaller value maximum allowable number multiplexed jobs since total ss bandwidth savings offered methods potentially greater allowable multiprogramming degree higher beneficial point view use min value highest possible number multiplexed jobs resolve tradeoff startup latencies achievable ss bandwidth savings suggest following algorithm use smallest min j value larger min j curr ffl requests arrive ts multiplexing depart ts service dynamically switch smallest min j value larger min j curr new value j curr algorithm exploit replicas different ttuple organi zations order dynamically adapt new j curr value allow maximum number requests multiplexed ts time enforcing smallest possible penalty startup latencies 6 pragmatic concerns section focus pragmatic concerns arising tape technology mpegbased videoserver application peculiarities present difficulties implementation placement strategies developed earlier sections 61 streaming mode recording first concern regard fact tape drives usually recorded streaming mode relatively high error rates means errors detected recording rewrite affected block occurs without stopping rewinding tape creating essentially number bad spots holes amidst useful data tape course complicates requirements twisted placements proposed solution technical recall section 3 given system parameter r play algorithms operate r 0 twisted sequence r 0 r note essentially aforementioned holes tape effect reducing transfer rate realuseful data words given r estimation writeerror rate tape drive perhaps pessimistically avoid hiccups estimate parameter r 0 create twisting sequence r 0 example estimations tape writeerror rate lead us r instead using 4twisting sequence shown figure 3b use 2twisting sequence figure 3a recorded tape holes blocks sequence average time unit tape head scanned much tape required hold data blocks read tape one played ts directly 62 twisting variable sized blocks champion application video servers predominant encoding technique videos mpeg given wellestablished practice normalizing video block lengths respect playback duration time recorded mpeg video blocks necessarily become variable size variability block sizes course complicates twisted placements fact complicates videodata placement problems reason related work placement algorithms analyses video data ss assume constant block sizes done section solve problem adopt following approach let us assume b denotes size block denoting average block size recalling time unit lasts seconds time unit delta mb read tape assuming none b blocks size greater delta pseudocode twist algorithm given algorithm 8 observations 1 time unit design one partition read 2 blocks playfromts blocks algorithm 8 twisted placement variable block sizes 1 store b 1 beginning tape 2 split remaining movie size partitions partition size delta mb l partitions l deltad 3 store blocks bl1 right end partition 1 2 l respectively 4 distribute remaining blocks empty spaces partitions playfromss blocks 3 long playfromts block flushed right partition additional ps space requirements blocks arrive time display starts 4 step 4 requirement npcomplete reduced wellknown bin packing problem partition corresponds bin want employ bins partitions possible step 4 wish fit remaining playfromss blocks tightly possible partitions playfromts blocks closer right end partitions minimize additional requirements ps space thus finding solution minimum ps space requirements npcomplete problem want approximation algorithm step 4 computationally inexpensive performs close optimal solution simple algorithm meets demands decreasing first fit dff algorithm gj79 dff translated problem setting works follows first sorts blocks decreasing order sizes blocks placed order first partition fit shown gj79 performance dff never worse 22 optimal solution problem setting means 1 occasion dff result requiring 22 tape storage video holes partition playfromss play 3fromts blocks also implies worst case 22 time required read blocks video tape 2 however playfromts block require zero additional ps space obvious solution problem first shift left play block partition fill empty space second shift left partitions cover empty spaces partitions eliminate holes also result worst case 22 additional ps space thus need algorithm strike effective balance read time ps space overhead pseudocode algorithm given algorithm 9 essence algorithms contribution step 6 guarantees never requirement additional ps space greater mb achieved expense fewer playfromts blocks ie lower ss bandwidth savings since partitions lose playfromts blocks following example using typical parameter values illustrate usefulness algorithm 63 average io bandwidth savings algorithm 9 provide analysis showing average io bandwidth savings algorithm worst case performance dff algorithm total empty space worst case would result running algorithm 8 22 total space total 5 number partitions average empty space per partition thus average one every k partitions loses playfromts block algorithm 9 polynomialtime twisted placement variable block sizes input playfromss fromts blocks b 1 placed beginning next remaining blocks set playfromss blocks next available tape partitions size delta mb 1 put right end partition next part block next ts block 2 sort remaining blocks decreasing order 3 run dff algorithm partition next part filled ie empty space smaller minimum block size remaining blocks 4 inherit empty amount empty space partition next part 5 shift left playfromts block partition next part cover partitions empty space 6 inherit empty delta f last block partition next part marked playfromss block ie partition next part lost playfromts block 7 remove remaining blocks ones placed 8 next part 1 9 next ts block 1 10 repeat blocks placed therefore number partitions without playfromts block l k io bandwidth savings k example 7 consider object consisting 3000 blocks 05 mb mbsec example total 5 number partitions without playfromts block 60 worst case require 5mb ps space 80 partitions retain playfromts block 7 conclusions paper addressed problem continuous data elevation multimedia servers based hsmss problem view received adequate attention despite facts current cost per megabyte figures make tape libraries costefficient medium applications ii several realworld products already employing tape libraries storing continuous media iii significant continuous annual increase tape library market promises nearfuture technological improvements improve performance first contributed notion alternating playback delaysensitive data ts ss discussed idea save significant ss bandwidth also pointed requires nonzero buffer space sub sequently contributed twisted placement algorithm companion play algorithm called alternate play twist placement algorithm determines proper placementrecording order blocks objects tapes play algorithm achieves ss bandwidth savings zero ps buffer space requirements time subsequently contributed notion strips streams special partial replicas stream objects residing permanently ts consist blocks played ts strips streams allow previous contributions enjoyed even 1 bandwidth ts smaller display bandwidth objects 2 objects also reside ss case popular objects later considered subject multiplexing tsresident video streams tape drives multiplexing desirable two reasons first drastically reduce average startup latency videos residing ts second employing placement play algorithms environments offer associated ss bandwidth savings streams multiplexed increasing total benefits approach derived algorithms employ previouslydeveloped techniques continue offering ss bandwidth savings additional ps buffer space presented algorithm showing store stream tapes high multiplexing degree j maintained j jobs algorithm continues achieve aforementioned savings thus total savings significantly greater many applications expect data objects exhibit skewed access distributions eg popular movies movieondemand application large majority cases popular objects uploaded residing ss scenarios ss responsible satisfying great percentage requests referring popular streams present technology however even highend ss server products enough bandwidth satisfy requests streams store expected hold future well given pace improvement storage capacities taking account io bandwidth required uploading colder streams ts ss available io bandwidth becomes even smaller paper shown techniques exploit everincreasing bandwidth modern tape drives increasing available io bandwidth satisfying requests made effort view problem comprehensively sense focus main resources host ram memory ss io bus bandwidth ts bandwidth techniques overall io bandwidth increased without requiring extra host ram still avoiding video hiccups sense aforementioned contributions suggest collaboration ts ss order improve systems throughput essence proposed techniques ts hsms simply used augment storage capacity ss traditional role would indicate augment ss bandwidth well high level contribution research r dynamic batching policies ondemand video server staggered striping multimedia information systems tertiary storage evaluation new applications challenges tertiary storage multimedia servers maximizing performance striped disk array research development issues largescale multimedia information systems principles optimallly placing data tertiary storage libraries buffering caching largescale video servers buffer management policy ondemand video server pipelining mechanism minimize latency time hierarchical multimedia storage managers computers intractability guide theory npcompleteness adaptive piggybacking novel technique data sharing videoondemand storage servers continuous retrieval multimedia data using parallelism study use tertiary storage multimedia systems multimedia repositories role data storage broadcasting future modeling performance characteristics serpentine tape drive random io scheduling online tertiary storage systems benchmarking tape system performance performance measurements models tertiary storage devices analytical performance model robotic storage libraries using tertiary storage videoondemand servers evaluating video layout strategies high performance storage server optimum execution order queries linear storage case intelligent disks idisks buffer management continuous media sharing multimedia database systems integrated document prefetching caching hierarchical storage based markovchain predictions design storage server continuous media keynote speech case redundant arrays inexpensive disks raid active storage largescale data mining multimedia applications efficient storage techniques digital continuous multime dia buffer management video database systems striping untangle tape storage costs overlay striping optimal parallel io modern applications prefetching smartdisk caches highperformance continuous media servers tpc executive summaries tr ctr simulated annealing approach multimedia data placement journal systems software v73 n3 p467480 novemberdecember 2004 athena vakali evimaria terzi elisa bertino ahmed elmagarmid hierarchical data placement navigational multimedia applications data knowledge engineering v44 n1 p4980 january
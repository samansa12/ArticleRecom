lightweight reasoning program correctness automated verification tools vary widely types properties able analyze complexity algorithms amount necessary user involvement paper propose framework stepwise automatic verification describe lightweight scalable program analysis tool combines abstraction model checking tool guarantees true false answers sound respect original system also check effectiveness tool implementation safetyinjection system b introduction recent years seen increasing interest computersupported techniques analyzing correctness software artifacts particular interest caused effectiveness potential lightweight formal methods 18 approach verification consists automated checking artifact critical properties eg deadlock security fairness often concentrating debugging instead assurance often lightweight methods include model checking 5 technique automatically verifying properties system given system prop erty model checker buildsthe reachability graph exhaustively exploring statespace system number industrial model checkers developed including spin 15 smv 22 muroe 10 althoughmodel checking started technique verifying hardware effectively applied variety software projects ex ample smv used verify correctness mode logic a7 aircraft 25 tcas specifications 4 spin applied validation remote object invocation corbagiop 20 checking java programs 14 many others model checking became part routine vv process development lucents new server product 16 applied reasoning user interfaces 12 business processes 19 model checking offers potential pushbutton verifi cation however potential easily realizable especially checking correctness programs opposed specifications protocols software artifacts first model checking mostly limited finitestate systems ie every variable system finite domain several model checkers allow reasoning infinitestate systems executing paths system certain depth 13 15 however systems cannot guarantee system satisfies desired property check pro grams analyst utilize abstractions computed either automatically hand 16 although highly desirable properties hold abstracted model hold original model 6 assurance difficult obtain different abstraction built class properties analysis 9 given large number available verification techniques potential complexity expense application interpretation results propose layered approach automatic verification depicted figure 1 given system property p would like know p holds would like start verification level 1 fairly inexpensive terms work required user terms computing resources required step result one three conclusions p definitely true definitely false point verification stops analysis cannot yield information latter case analyst apply technique verification property true expensive analysis property false verification step 2 verification step 1 step n verification figure 1 framework automatic verification level 2 technique expensive verification level 1 may help determining whether holds analyst proceeds applying complex expensive techniques 1 p definitely proved definitely disproved 2 levels exhausted resources exhausted note precision lost level properties concluded definitely hold definitely hold verification level proceed level k benefit stepwise verification framework outlinedabove allows us categorize existing tools based effectiveness verifying properties complexity application complexity metric includes effort needed human effort needed com puter also allows one utilize verification efforts effectively paper discuss verification sequential programs fairly complex properties involving temporal logic arithmetic values variables eg never less b immediately 2a true however approach build level 1 verifier first compute abstraction behaviors program analysis using abstract interpretation abstraction dependent choice properties verify computed automatically even though program may finitestate model check abstracted system analysis yields true property holds original system yields false property hold yields maybe analysis inconclusive cases properties verified using expensive techniques idea verification presence abstraction explored several researchers particular jackson 17 proposed model checking method analyze infinite specifications expressed z vdm approach defines abstract state space abstract state represents possibly infinite equivalence class concrete states dams 9 demonstrated abstract reactive systems abstracted transition systems preserves certain forms combined safetyliveness properties pardo 24 built abstract concrete models system conservatively verified properties expressed calculus abstracted model formula proved false related states successively refined given formula verified computational resources exhausted rest paper organized follows section 2 gives overview model checking abstract interpre tation section 3 discusses theoretical goals work introduces new algorithms program verification system proofs correctness algorithms given appendix design system described section 4 section 5 demonstrates results using abstract model checker analyze safetyinjection sys tem conclude paper summary work outline future research directions background section recall basic definitions abstract interpretation model checking 21 abstract interpretation abstract interpretation 8 9 way symbolically executing programs using abstract instead concrete domain familiar dataflow analysis algorithms eg constant propagation live variables examples abstract interpretation let c concrete abstract domains spectively abstraction function ff 2 c maps set concrete values abstract value ff inverse concretization function abstraction valid pair functions ff fl forms galois connection example perform sign analysis replacing set integers signs gamma 0 execute program abstract values example fgamma1345g theta f17g ff however abstract values cannot always determined exactly consider following example fgamma1345g theta f17g represented set fgamma 0g interpretation result values abstract domain finite abstract interpretor acts dataflow analyzer however may also want use abstract interpretationto reason infinitedomain variables order achieve tractability need ensure abstraction converging 1 finite representation infinite set val ues one way abstract set interval taking minimum maximum value set left right bound interval example 2 ensure convergence finite number steps finitedomain abstraction convergence guaranteed achieve convergence infinitedomain abstrac tion 8 introduced abstract binary operator widen ing denoted r represents jump abstract values 0 ri 1 8 defined widening follows example 22 model checking paper concern withctl model checking automatic technique verifyingproperties expressed propositionalbranchingtime temporal logic called computational tree logic ctl 5 system defined kripke structure properties evaluated tree infinite computations produced model system standard notation indicates formula f holds state model formula holds initial state considered hold model kripke structure consists set states transition relation r theta set initial states set atomic propositions p labeling function l must total function ie 8s 2 state n successors add selfloop intuitively 2 labeling function provides list atomic propositionswhich true state use ctl boolean expressions include variables arithmetic operations set p atomic propositions defined follows p 1 p 2 terms atomic propositions terms defined recursively 1 every identifier every constant term 2 term 3 1 2 terms 1 mod exp mod exponentiation functions respectively example following atomic propositions version ctl ctl defined follows 1 every atomic proposition 2 ctl formulas logic connectives usual meanings existential universal quantifier e used quantify paths operator x means next step f represents sometime future u fore ex ax means holds every immediate successor current program state ef af means holds future along every path emanating current state eu au means every computation path starting current state continuously holds becomes true formally exists path note af j atrue u ef j etrue u using strong also use abbreviations eg ag represent property holds every state every path emanating 0 eg ag defined 3 lightweight model checking goal work use abstract interpretation alleviate state explosion problem model checking ensuring properties verified abstract system properly interpreted original system goal achieved constructing abstract model checker threevalued logic returns values true false maybe analysis results true false sound using static analysis build abstract system associating line program abstraction set values program variables attain control reaches point along execution path abstraction reduces statespace finitestate infinite state systems computed completely automatically section introduce language constructing programs describe process building labeled transition machine present model checking algorithm threevalued logic 31 input language input language called c sequential language syntax similar c language includes following constructs booleanandinteger types conditionalcon trol structures else loops input output print fprint scan fscan assignments functions procedures dynamic features recursion pointers provided language also allow userdefined compound data structures complete grammar language available 11 figure 2 gives example program written c 32 construction labeled transition system describe transformation program representation labeled transition system start infinitestate program infinite set states 0 2 w initial state r w theta w total accessibility rela tion lt lf truth falsity labeling functions mapping state set propositionsthat true false respectively state l c c onetoone correspondence assignments variables lines code fact attempting verify programs expressed c need give welldefined formal semantics ie describe way construct transforms program state 23 define state mapping set global variables values thus state change occurs least one global variables changes value goal construct abstract finite kripke structure every edge represents state change program order define set variables v let vw v set variables accessible lexical scope associated state w 2 w g v set variables accessible every point pro gram thus g set global variables state w program n1tuple v ln corresponds line number state program subset values concrete domain v ctl properties programs expressed terms global variables start analysis parsing program building abstract syntax tree ast ast intermediate representation structure program interpreta tion next propagate information variables global local current scope throughout ast reach fixpoint abstractions formed mapping concrete state w onto abstract state w ff w 2 2 mapped onto abstract value ff result abstract state space w ff w ff 2 w ff n1tuple w notice line numbers set variables concrete abstract state space ff chosen w ff finite abstract state w ff represent one even infinite number concrete states due abstraction moreover one state associated line code let r ff transition relation abstract state space r ff w ff theta w ff r ff constructed follows labeling functions become concrete domain 8w 2 w assumptions galois connection framework abstract system least many behaviors corresponding concrete one typically verification abstracted systems done either conservatively optimistically former case provides reliable negative answers l ff lt l ff f lf latter case provides reliable positive answers either case one side answer cannot trusted goal work ensure get reliable positive reliable negative answers ie l ff lt l ff f lf case resulting abstract finitestate program pg order construct abstract kripke structure every transition corresponds change global variable define global variable changed predicate p state py true iff 9x x 2 r ff 9g 2 g st gs abstract value state x construct abstract aggregate state space ff every element contains one state w ff involves change global variable states involve changes global variables reached w ff via transitive closure r ff denoted r ff ff defined recursively follows ffl pw ff true w ff 2 ff 1 int b 12 2 int xy 13 else 3 int main 14 4 int 15 5 int c 16 2 7 8 printxy xy 9 20 printb b figure 2 program fragment note values global variables within ff refer l ff l ff f labeling functions map ff 2 ff set atomic propositions global variables true false state finally transitions states ff e ff ff theta ff thus defined abstract kripke structure k ready 33 model checking algorithm present algorithm receives kripke structure k ff constructed correctness propertyexpressed version ctl described section 2 determines whether property holds system mentioned previous section want ensure analysis yields reliable positive reliable negative answers ie analysis concluded property true holds original system analysis concluded property false hold original system order introduce third logical value maybe thus analysis concluded property maybe holds system unknown whether property holds concrete system algorithm recursively goes structure property analysis associating subproperty pair sets states yes yes ff set states true formally ff 2 represents set states false defined similarly also define predecessor function pred 2 ff given set states q returns states reach state q one transition algorithm inspired bultanssymbolic model checker infinitestate systems 3 given figure 3 exam ple property p q holds state ff ff yes sets p q property hold state ff ff set either p q verifying exp note p holds immediate successor state ff exp holds ff immediate successor p may hold ff gamma nop excluded noexp apuq computed recursively follows apuq true states 0 q holds also true predecessors 0 p holds successors 0 apuq false state ff iff q hold ff either p hold ff one successors lead q implementation figure 4 architecture abstract model checker implemented abstract model checker amc 26000line c program figure 4 shows architecture procedure check 2 3 return qm 2 3 return qm figure 3 model checking algorithm software ctl formulas input language described sections 2 3 respectively abstract interpretor ai receives program analysis builds kripke structure k using process described section 3 structure together set ctl formulas becomes input model checker checks property returns true formula holds program false formula hold maybe validity formula cannot established latter two cases model checker also returns counterexample moment counterexample facility includes line number variablevalue mappings states formula true ai receives program interprets starting input context consists set values variables program statement executing state ment producing output context output context stored part state abstract values finite domain variables boolean enumerated types consist sets concrete values variables attain undef undefined 1 however values infinitedomain variables integers abstracted section 2 briefly discussed abstraction function ff applied set get interval however bet 1 brevity discuss treatment undef details please refer 11 ter precision associate infinitedomain variable finite set intervals following interpreta tion current implementation ai set consist 5 intervals define ff union set intervals let intervals assume without loss generality n fag ff fag ff ff ff ng fag ff encounter two sets containing one interval first union elements set less intervals case fa 1 amg one interval union result interval set interval operations unionand difference usual meaning widening intervals defined section 2 operations sets intervals ff ff r widening similar additional operations including comparison arithmetic defined formally 11 algorithm used ai analyzing conditional statements depicted figure 5 given input abstract statements execute iexpr true false stmt stmt f respec tively either execute stmt stmt f based return resulting abstract state call omega calculator get abstract states correspond taking else part f respectively execute state ments compute union resulting output con texts omega calculator set c classes 21 manipulating integer tuple relations sets described presburger formulas use symbolically executing conditional expressions involving intervals procedure evalif evaluate iexpr iexpr true execute stmt starting get return else iexpr false execute stmt f starting get return else iexpr maybe call omega calculator get f execute stmt starting get execute stmt f starting f get f return f figure 5 algorithm analyzing conditional statements example suppose running ai program fragment depicted figure 2 figure 6 shows controlflow graph fragment state associated program line number let input context executing state 11 xy fgamma20 52g fgamma5 8g b f13 2g condition xy 0 evaluates maybe therefore call omega calculator determine value xy input contexts states 12 14 f0 0gand fgamma20 gamma1 1 52g respectively values b output contexts states f5 5g f26 26g unioned obtain f5 25g input context state 15 values executing state 15 state 16 fgamma3 gamma1 1 8gand fgamma3 gamma1 1 1 3 3 respectively point reached limit five intervals splitting cannot done instead union intervals get fgamma3 8g proceed execution introduces loss information precision strictly conservative 11 outputvalue state 17 fgamma3 gamma3 gamma1 8g loops executed fixpoint values variables achieved order ensure fixpoint occurs finite number steps change values variables loop 20 times keeping track whether decrease increase iterations fixpoint achieved widen values nonconverged variables increase decrease leading values 1 gamma1 respectively afterwards proceed executing loop ensure dependencies variables adequately captured table 1 lists several values variables b xy attain input context state 9 execute main loop program figure 2 first iteration values f13 13g gamma20g respectively following19 iterations note maximum values b xy attain creasing whereas minimum values stay thus widening occurs 20th iteration changes maximum values variables 21th iteration bring changes thus achieving fixpoint figure 7 shows final kripke structure built controlflow graph figure 6 state associated line number statement changes global variable original program withthe abstract values global variables execution state example state 10 figure 7 aggregation states 10 11 figure 6 int xy int b 8 10 true 11 xy 0 14 false 15 a2 true true 19 print xy int int c 7 912 20 print b true false false false 3 main end true false figure controlflow graph program figure 2 iteration b xy table 1 execution loop program figure 2 resulting kripke structure becomes input model checker whose algorithm described section 3 ex figure 7 kripke structure k ff built program fragment figure 2 ample model check structure depicted figure 7 ctl properties ef b 12 amc returns false first property violated state corresponding line 12 program second property determined true satisfied state corresponding line 12 third property determined maybe maybe holds state corresponding line 14 definitely hold state 41 performance given programpg let jv j total number variables global local n number statements pg worst case ai algorithm occurs program jv j loops loop widens exactly one variable go loop 20 times therefore statement pg changed 20 theta jv j times n theta 20 theta jv j changes altogether furthermore every state predecessors change state union abstract values variables prede cessors takes n steps constant proportional number intervals associated variable therefore entire computation abstract interpretor takes 20 theta jv j theta n theta theta n gamma 1 theta jv j steps ojv compute performance model checker let jp j length property p among ctl mulas au complex algorithm q change value n times fixpoint reached takes steps compute q predecessors time verification property takes theta n gamma 1 steps therefore total running time model checker check formula p ojp j theta n 2 5 case study determine effectiveness abstract model checker analyzed simplified version safetyinjection system 7 safetyinjection embedded system monitors water pressure injects coolant reactor core pressure falls certain threshold manual control operator use prevent system injecting coolant causes system overridden reset switch prevents system overridden system inputs value water pressure outputs boolean condition signifying whether inject coolant addition maintains internal state reflecting water pressure water pressure falls threshold low systems pressure level becomes low water pressure raises permit systems pressure level becomes high otherwise level within permitted range implemented safetyinjectionsystem 200 line c program 8 global variables closely reflecting specification waterpres type integer block reset type boolean injection type boolean overridden type boolean constants low permit toolow permitted high pressure type integer system allow enumerated types last three constants used indicate symbolic values pressure implementation also includes 7 functions 8 local variables specification language system expressive enough capture complex properties safetyinjectionsys tem 1 agreset pressure 2 agreset 3 agblock reset pressure 6 high 4 permitted waterpres permit axwaterpres permit example property 2 states system inject coolant pressure lowand reset button pressed whereas property 4 states whenever pressure permitted water pressure raises allowed thresh old system eventually transit state pressure high verified properties sun ultrasparcii 4 400 mhz processors 4 gb ram entire verification effort includingbuildingthe abstract kripke structure checking properties took 392 seconds user 620 seconds system modelchecker yielded true four properties final kripke structure consisted abstract states safetyinjection verified two research groups bultan 2 built infinitestate symbolic model checker uses binary decision diagrams bdds system linear constraints reason models presburger arithmetic model checker also uses omega library together abstract interpretation achieve finitetime convergence analysis properties verified optimistically allowing false positives addition procedure partial convergence dependent structure program formula verified approach utilize abstraction statespace reduc tion bultan verified properties 1 2 able determine exact size models bharadwaj heitmeyer 1 analyzed scr specifications using spin 15 model checker technique allows finitedomain variables including integer subranges enumerated types size concrete state space reduced two meth ods eliminating variables relevant property verified scr ensures dependencies variables form partial order replacing input variables predicates latter approach makes verification conservative allowing false negatives unabstracted system properties 1 2 spin performs onthefly ver ification without building complete state space consists 17 million states whereas combination abstractions brings state space 650 states 6 summary future work paper proposed framework stepwise automatic verification described implementation cheap particularly precise model checker model checker verifies infinitestate sequential programs written subset c ctl formulas containing arithmetic op erations applies propertyindependent abstract interpretation create abstract kripke structure uses extremely compact structure verify properties loworder polynomial time usercreated abstractions nec essary verification always converges guaranteed sound model checker yields true property holds concrete system yields false property hold approach limited analysis programs applied finitestate infinite state specifications equally well also believe tightening code model checker making state encoding symbolic improve running time however results work limited several ways 1 implementation tool cannot handle complex constructs input language include recur sion userdefined data types dynamic memory allocation pointers etc also currently limit verification sequential programs 2 tool interacts omega library handle operations integervalued variables thus reasoning floatingpointnumbers currently supported 3 one builtinlevel abstraction provided system 4 input language subset c formal semantics particular notion state transition poorlydefined chose associate state values global variables state transition changes values global variables perhaps flexible way determine granularity state transitions appropriate 5 model checker returns maybe cannot determine whether property holds system believe reduce number cases verification inconclusive improving reasoning abstract values andor choosing propertyspecific abstractions shortterm future work hope extend modelchecker reasoning ctl 5 combines branchingtime lineartime operations strictly expressive ctl would also like address issue state granularity either asking users specify global variables constitute state add language constructs explicitly stating beginning end state either via beginstateendstate via adding notion time timetick state occurs consecutive timeticks acknowledgments would like thank ric hehner radu iosif reading earlier versions paper mark pichora albert yu daniel house many interesting discussions acknowledge financial support nserc postgraduate scholarship appendix section give proofs correctness algorithms checking au see 11 proofs correctness algorithms let ff indicate model checker returns true false checking formula oe state ff abstract model ff assume model state concrete pro gram respectively expressions state model checker sound respect yes answers prove 1 2 1 proof induction length path ff state holds ih let set states reached n steps assume 8t ff prove formula holds paths length n consider case covered base case 2 au hold state ff either 1 occur path emanating ff 2 path emanating ff first occurrence state hold algorithm expanded follows case 1 case case 1 starts set states true recursively intersects states successors holds result set states never reach ie 2 results set states neither hold ie r model checking complete requirements specifications using abstrac tion verifying systems integer constraints boolean predicates composite approach symbolic model checking infinite state programs using presburger arithmetic decoupling synchronization local control efficient symbolic model checking statecharts automatic verification finitestate concurrent systems using temporal logic specifications model checkingand abstraction documentation safety critical software static determination dynamic properties programs abstract interpretation reactive systems muroe verification system analyzing infinitestate programs abstract interpretation model checking graphical user interfaces using abstractions verisoft tool automatic analysis concurrent reactive software model checking java programs using java pathfinder model checker spin practical method verifying eventdriven software abstract model checking infinite spec ifications lightweight formal meth ods model checking managers validation remote object invocation object migration corba giop using promelaspin omega calculator library symbolic model checking abstract dynamic semantics c automatic abstraction techniques propositional calculus model check ing feasibility model checking software requirements case study tr ctr steve easterbrook marsha chechik benet devereux arie gurfinkel albert lai victor petrovykh anya tafliovich christopher thompsonwalsh chek model checker multivalued reasoning proceedings 25th international conference software engineering may 0310 2003 portland oregon marsha chechik benet devereux steve easterbrook arie gurfinkel multivalued symbolic modelchecking acm transactions software engineering methodology tosem v12 n4 p371408 october
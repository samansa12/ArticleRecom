study termination negotiation dialogues dialogue represents powerful means solve problems using agents explicit knowledge representation exhibit goaloriented behaviour recent years computational logic gave relevant contribution development multiagent systems showing logicbased formalism effectively used model implement agent knowledge reasoning interactions used generate dialogues among agents prove properties termination success paper discuss meaning termination agent dialogue identify tradeoff ensuring dialogue termination therefore robustness agent system achieving completeness problem solving building existing negotiation framework dialogues obtained product combination reasoning activity two agents logic program define syntactic transformation existing agent programs purpose ensure termination negotiation process show transformations make existing agent systems robust possible situations nonterminating dialogues reducing class reachable solutions specific application domain resource reallocation b introduction dialogue one exible interaction patterns multiagent systems something completely xed protocols totally free conversations 3 intuitively dialogue purely reactive questionanswer sequence client server architecture framed rigid protocol rather kind interaction grounded expressive enough knowledge representation dialogues start general need achieve explicit goal goal initiating dialogue could example persuade another party nd information verify assumption 15 case negotiation dialogues instance agents need negotiate operate environments limited resource availability goal dialogue obtain resource general idea applies dierent scenarios dierent meanings recent years computational logic gave relevant contribution development multiagent systems 11 4 proved eective model implement agent knowledge reasoning interactions work argumentation per suasion certain circumstances considered suitable techniques strategies support conversation goal achievement led many argumentative frameworks 1 9 10 often try embrace hard problems result good descriptive models lack times execution model 13 sadri et al described logicbased approach negotiation take account persuasion argumentation classic understand ing hand allows proving properties termination correctness completeness strength approach proposes execution model used achieve implementation system area negotiation general results dialogue proper ties like termination success 16 authors consider use logicbased languages negotiation identify two important computational problems use logicbased languages negotiation problem determining agreement reached negotiation problem determining particular negotiation protocol lead agreement paper tackle problem termination agent dialogues start discussing meaning termination agent dialogue show tradeo ensuring termination dialogues therefore robustness agent system achieving completeness problem solving show ideas apply practice concrete case negotiation framework building 12 agent dialogue obtained product combination reasoning activity two agents performing abductive derivation logic program show agent programs transformed order ensure termination negotiation process dene three dierent degrees transformation show make agents robust possible situations nonterminating dialogues reducing class solutions found specic application domain resource reallocation agent dialogue termination robustness vs com pleteness 2 agent societies categorized terms openness exibility stability trustfulness claimed whereas open societies support openness ex ibility closed societies support stability trustfulness author suggests two classes societies semiopen semiclosed balance tradeo aspects many situations need societies support case dialogue problem determining tradeo still holds dialogue used means let heterogeneous agents communi cate despite dierences among without necessarily sticking given protocol hand let agents openly join societies control individuals access problems could arise diversity instance dialogues last forever work focuses negotiation dialogues let us start describing intend dialogue let us example dene formally next section following dialogue inspired 10 agent ask agent b resource nail needed carry task ie hang picture request refused asks b reason purpose acquiring additional information nding alternative solution goal example 1 general dialogue sequence alternative dialogue moves performa tives performative message form tellsender recipient subject time time particular understood transaction time concept termination negotiation dialogue recovered idea certain point agent makes nal move 16 course agent supposed recognize move intended terminate dialogue agent makes nal move agents could keep exchanging messages without getting end example 2 shows dialogue two particularly overpolite agents exchanging greetings example 2 situation example 2 could due fact agents programs force reply incoming greeting equal greeting imagine loop conditions like could unpredictably arise time put together open society agents independently programmed obvious solution problem could force agents tell thing twice measure really solve problem example 3 shows agents could exchanging slightly dierent messages still get stuck loop condition example 3 could think introduce restrictive measure eg based message patterns prevents agents telling message whose pattern previous one dialogue 1 could result preventing agents nding solutions agreements case negotiation could found otherwise example 4 shows possibly successful dialogue would solve resource reallocation problem agent obtains screw b therefore execute plan achieve goal hanging picture dialogue would permitted agent b prevented making move propose exchange meaning promise performative inherit 1 twice example 4 still unless consider generic therefore restrictive patterns threat nontermination remains example 5 could evoke familiar situationthe pattern could case tell b hello underline indicates whatever ground expression spent moments life dealing small children example challenge performative also derived 1 meaning asking justication dialogue partner said example 5 end realize intuitively follows reduce set dialogue moves agents exchange course dialogue reduce universe reachable solutions negotiation problem think choice extent dialogue constrained certain patterns must left system designers next section describe concrete negotiation framework rstly introduced 13 extended 12 makes use logic formalism framework course agent dialogues ruled knowledge expressed agents abductive logic programs based introduce several syntactic transformations programs make robust various degrees nontermination ect discussed tradeo finally section 4 prove theorem determines bound maximum length dialogue measured terms number exchanged messages extend result dialogue sequences 3 abduction negotiation dialogue framework going sketch section derived 13 composed knowledge representation including abductive logic program alp language proofprocedure communication layer agents provided suitable architecture including particular planner communication layer shared blackboard agents post retrieve messages far knowledge representation say agents declar ative representation goals g beliefs b intentions ie plans achieve goals agents access beliefs means predicates haveresource needresource similar way intentions intendintention purpose negotiation agent obtain missing resources retaining available ones necessary plan current intention focus paper termination issue space limitations describe framework detail although need give intuition abductive proofprocedure adopted agents order prove termination results section 4 31 negotiation framework classical understanding abduction reasoning mechanism allows nd suitable explanation certain observation goal based abductive program general abductive program expressed terms triple logic program set abducible predicates ie open predicates used form explaining sentences ic set integrity constraints given goal g abduction aims nding set abducible predicates supposed true thus enlarge p order entail g adoption automatic proof procedures 5 6 supported suitable agent cycle instance observethinkact 8 implement concrete concept entailment respect knowledge bases expressed abductive logic programming terms execution proof procedure within agent cycle allows produce hypotheses explanations consistent agent constraints ic certain phases agent cycle reached constraints play major role abduction since used drive formulation hypotheses prevent procedure generating wrong explanations goals reason abduction originally used diagnosis expert systems recent times many dierent understandings abductive reasoning conceived abduction used eg planning scheduling hypotheses made refer task scheduling constraints used eg prevent task overlapping resource con ict argumentation framework abduction proposed build arguments knowledge base 7 13 abduction used model agent dialogue following argumentative approach particular abducible hypotheses dialogue per formatives abductive agent program provided dialogue constraints red time agent expected produce dialogue move eg time another agent sends request resource move produced hypothesis must assumed true order keep knowledge base consis tent agent knowledge considered consistent agent replies partners moves according current status knowledge base use abduction agent dialogue context opposed less formal approaches several advantages among possibility determine properties dialogue 11 relationship holding specication implementation due operational semantics adopted abductive proofprocedure following show dialogue constraint taken simple agent program example 6 constraints expressed terms conditionaction rules leading particular case perception another agents dialogue move observation phase expression new dialogue move action phase instance rst constraint example reads agent receives request another agent x resource r tells x accept request rules interpreted think phase iff abductive proof procedure framed observethinkact agent cycle 8 32 iffterminating programs paper make concrete assumptions syntax language knowledge base agents except assuming contains notions literal complement sentences true false language equipped notion entailment every ground literal language either literal complement entailed literal complement entailed time iff 5 rewriting abductive proofprocedure consisting number inference rules two basic inference rules unfolding backward reasoning propagation forward reasoning implications obtained repeatedly applying inference rules proof procedure either integrity constraint given program alp result rewriting negative literals false describe proofprocedure detail focus issue proof termination give characterization class iffterminating programs ie abductive logic programs ifftrees grounded queries nite intuitively reason program iffterminating recovered presence program rules constraints whose combination leads innite propagation unfolding possible identify three cases generalized 2 following p q represent literals unfolding unfolding sake simplicity consider ground programs thus assuming p ic already instantiated results could generalized nonground programs unfolding propagation propagation propagation cases p unfolds propagates q vice versa ad innitum order characterize class programs terminate dene property aciclicity tailored case alp relationship iff proof procedure iffaciclicity fact alp iffacyclic iffterminating alp iffacyclic found level mapping jj 1 every ground instance every clause ifdenition p say 2 every ground instance every integrity constraint ic say k negative literal say body integrity constraint presence level mapping ensures situations occur agent program call iffacyclic programs acceptable fact cannot guarantee termination agent gets stuck innite branch derivation tree producing therefore dialogue move following always require agent programs acceptable work builds results identies class agent programs ensure termination negotiation dialogues sequences dialogues 33 dialogues let us formally dene intend dialogue sequel capital letters stand variables lowercase letters stand ground terms denition 1 performative dialogue move performative dialogue move instance schema form tellx utterer receiver performative time performative uttered subject content per formative expressed given content language denition 2 language negotiation language negotiation l possibly innite set possibly non ground per formatives given l dene two possibly innite subsets performatives il fl l called respectively initial moves nal moves example language negotiation following taken 13 initial nal moves l 1 g paper interested negotiation exchange resources assume always exists request move initial moves language negotiation denition 3 agent system agent system nite set x 2 ground term representing name agent equipped knowledge base kx assume agent system agents share common language negotiation well common content language given agent x 2 equipped l dene sets l x performative schemata x receiver utterer l x performative schemata x utterer receiver note allow agents utter performatives sequel often omit x clear context simply write l l alp framework outgoing performatives abducibles implies denition allowed words exist rule agent program contains outgoing performative head negotiation protocols specied sets dialogue constraints dened follows denition 4 dialogue constraint given agent system equipped language negotiation l agent dialogue constraint x possibly nonground ifthen rule form utterer pt receiver c conjunction literals language knowledge base x 3 variables dialogue constraint implicitly universally quantied outside performative pt referred trigger next move c condition dialogue constraint intuitive meaning dialogue constraint pt agent x follows certain time dialogue agent utters performative pt corresponding instance dialogue constraint triggered condition c entailed knowledge base x x receiver next time 1 behaviour dialogue constraints achieved employing automatic proof procedure 5 within observethinkact agent cycle 8 said execution proof procedure within agent cycle allows produce dialogue moves immediately dialogue constraint red concrete example dialogue constraint allowing agent x accept request example 6 trigger tell request give r condition r next move tell accept request refer set dialogue constraints associated agent x 2 sx call agent program x often omit x clear context unimportant order able generate dialogue two agent programs must properly combined exhibit two important properties determinism exhaustiveness say agent program deterministic exhaustive generates exactly one next move pt condition c except pt nal move call p space 3 note c general might depend several time points possibly necessarily including therefore indicate explicitly time variable acceptable exhaustive deterministic agent programs examples programs found 12 denition 5 dialogue dialogue two agents x set ground performatives fp given 0 1 8 0 p uttered time 2 8 0 p uttered agent x viz p i1 uttered agent viz x 3 8 0 p uttered agent 2 fx yg exists grounded dialogue constraint condition 1 dialogue fact sequence performatives condition 2 agents utter alternatively dialogue condition 3 dialogues generated dialogue constraints together given knowledge base determine whether condition triggered dialogue constraints entailed dialogue ground nal move namely p ground instance performative fl intuitively dialogue begin initial move according given language negotiation kind dialogue relevant purposes started request resource r knowledge representation chose reference framework call missing rs set resource agent missing start executing intention request dialogue initiated agent x whose intention contains r set missing resources denition 6 request dialogue request dialogue respect resource r intention agent x dialogue agent 2 0 consequence dialogue agents intentions might change according way intentions modied classication types terminated request dialogues given 12 sequel assume terminated request dialogue given resource r intention returns intention 0 ensuring termination consider dialogue particular iff derivation obtained interleaving resolution steps made two agents therefore extend termination results 32 dialogue programs 41 terminating dialogue programs argue possible reasons innite derivation tree still mutatis mutandis section 32 let us consider three cases see occur knowledge distributed two agents b put left side rule constraint name agent whose program contains assume agents programs acceptable unfolding unfolding unfolding propagation unfolding propagation propagation propagation 1 2a forbidden program acceptability requirement 2b represent possible cause nontermination 4 since q abducible therefore possible communicate b third case let us consider pt tellb subject qt tella b subject apparently threat termination instance case example 2 subject hello could therefore introduce restrictions dialogue protocols order prevent situation cost reduction space reachable solutions explained examples 4 way pass computation thread agent dialogue partner b abducible representing dialogue move head one diaolgue constraints 42 three degrees restrictions order try prevent propagation causing innite dialogue move generation case 3 make sure integrity constraint agent program triggered innitely many times purpose dene transformation maps element 2 p domain acceptable exhaustive deterministic agent programs another element domain dened follows denition 7 agent program transformation given language l agent x agent program sx 2 p transformation respect given set literals dened following way otherwise therefore 11 correspondence restriction p check transformation function called restricted according programs elements codomain acceptable program restricted according partner agent produces move triggering dialogue constraint whose condition restriction veried agent jump nal state thus interrupting dialogue easy prove given transformation function associated restriction p check p check ground possible instantiations pt exhaustive deterministic programs exhaustive deterministic programs ie maps p p choice restriction made several ways dene three dierent kinds restrictions formally ect considerations section 2 check made ground instances predicates ii check made predicate patterns iii check made ordering let us consider one one case check made ground instances predicates restricts applicability dialogue constraint preventing triggered twice instance dialogue move dierent times line characterization dialogue given 13 prevents situations innite pure loop one example 2 generated constraint agent restriction case could check guarantee termination nite number steps though shown example 3 check predicate patterns could implemented case restriction check case check made predicate patterns restrictive policy already mentioned drawbacks limitations particular situation example 5 could caused agent contains program following dialogue constraint tellb anything solution could establish ordering among dialogue constraints agent going let us point problem nontermination agent starts negotiation dialogue although results independent fact true dialogue terminated either agent hand broadly speaking one started one expect waiting reply vice versa intuition agent started negotiation process let us say ideally draw tree possible dialogues root initial move let us say tella b request 0 correct tree could drawn knew bs program exactly assumption want make however rst approximation assume b constraints generate tree nodes possible dialogue moves branches integrity constraints lead one move another one example tree language l 1 negotiation program dened 13 figure 1 purpose drawing tree goes initial move possible nal moves ordering function allows order dialogue moves consider ongoing dialogue valid far tree graph explored one direction one leads nal moves important notice agent programs p allow us draw tree order ordering function must exist call existence function acyclicity section 32 case iffterminating programs function exist possible adopt policy iii easy imagine dialogue two agents nonacyclic program likely terminate formally instance ordering function call rank function dened follows request accept refuse challenge justify refuse promise refuse accept request accept refuse challenge justify refuse promise refuse accept figure 1 dialogue tree denition 8 rank function rank function mapping language l set natural numbers n procedurally dened given agent program 2 p follows two steps first label performatives l applying one following rules rule produces change labeling p 2 l labeled yet p 2 l labeled yet p 2 l already labeled let labelp r 9ic possible apply labeling language ie possible complete procedure nitely many steps means program acyclic otherwise labeling language let r max p2l labelp r nite rank dened labelp rank function rankp n n 2 n dened p 2 l restriction turns check move higher rank made move lower rank worth notice introduction restrictions modify existing language ranking call policy check ordering restrictive previous ones since allow jumping backwards one branch another one possibly successful dialogues could rejected hand applied acceptable exhaustive deterministic programs enough ensure termination stated following theorem theorem 1 finite termination dialogue check ordering let b two agents provided acceptable exhaustive deterministic pro grams let program restricted according check ordering policy therefore dialogue b terminate nitely many moves particular r maximum rank dialogue move moves proof proof theorem given inductively given dialogue agents b started let r maximum rank dialogue move program denition rank nodes ranked 0 must leaves therefore nal moves leaves ranked r initial moves p j nal dialogue terminated p j nal rankp uttered b ie j even p j1 must computed either nal move ranked rankp j1 p j nal rankp uttered ie j odd p j1 must computed b either nal move move next move p j2 nal dialogue terminate otherwise p j2 ranked denition therefore move p j ranked r r r1 j dialogue two moves rank next move last one since cannot two moves rank maximum rank r maximum number moves computed dialogue r 2 nonnal move uttered either agent exists unique next move p j1 since agent programs exhaustive deterministic moreover reasoning required either party compute dialogue move terminates nite number steps since programs acceptable therefore dialogue terminates moves 43 termination dialogue sequences easily extend termination result case dialogue sequences formally dened 12 aimed collecting nitely many missing resources missingi respect intention whose cost dened cardinality missingi space formally describe dialogue sequence dialogues still would like give intuition sketchy proof second theorem going enunciate following dialogue sequences dened agent cannot ask resource twice agent within sequence since dialogues modify agents intentions dialogue sequence fd associated series intentions fi agent intention resulting initial intention denition 9 termination sequence dialogues sequence dialogues si respect initial intention agent terminated given n intention n exists possible request dialogue respect n start could due two reasons either missing resources intention ie costi n program constraint start request order ensure termination could program agent every single dialogue set missing resources rather shrinks grows size agent program dialogue decrease cost intention call agent selfinterested rational case given system n agents intention length lengthsi sequence si dialogue respect intention ie number dialogues si bounded product n costi possible prove termination property holds selfinterested rational agents whose programs restricted according check ordering policy theorem 2 termination sequence dialogues restricted agent program let system n 1 agents si sequence dialogues respect initial intention selfinterested rational agent 2 let agent programs acceptable exhaustive deterministic particular let program restricted according check ordering policy si terminate nitely many dialogue moves particular r maximum rank dialogue move according ranking function si terminate moves proof sketch number dialogues si bounded product costi dialogue terminated r moves whole sequence dialogues terminate terminate ncostir2 dialogue moves 5 end would like make parallel concept restriction introduced ensure termination negotiation dialogue selfinterested rationality assumption theorem 2 indeed selfinterested rationality could considered limitation reduces space agent programs ects reduction space achievable solutions resource reallocation problem easy imagine situations two negotiating agents get stuck local maximum none wants give away resource results respect 14 due reduction weak notion completeness introduced 12 work dealt problem termination dialoguebased agent negotiation building existing dialogue framework course dialogue determined rules constraints embodied agents programs introduced several syntactic transformation rules modify programs towards better robustness two results proven determining upper limit maximum length dialogue sequence dialogues measured terms number exchanged messages results generalized reect existing tradeo need ensure termination negotiation process loss terms reachable states universe possible solutions problems addressed negotiation r arguments dialogue negotia tion categories arti dialogue team formation iff proof procedure abductive logic programming relation truth maintenance abduction role abduction logic programming logic programming multiagent systems reaching agreements argumen tation agents reason negotiate arguing dialogues negotiation agent varieties dialogue sequences logic agents negotiation among selfinterested computationally limited agents commitment dialogue basic concepts interpersonal reasoning languages negotiation tr loop checking logic programming reaching agreements argumentation speculative computation multiagent belief revision logic programming towards multiagent systems categories artificial societies dialogue team formation dialogues negotiation ctr ralf schweimeier michael schroeder parameterised hierarchy argumentation semantics extended logic programming application wellfounded semantics theory practice logic programming v5 n12 p207242 january 2005 pietro baroni massimiliano giacomin giovanni guida selfstabilizing defeat status computation dealing conflict management multiagent systems artificial intelligence v165 n2 p187259 july 2005 iyad rahwan sarvapali ramchurn nicholas r jennings peter mcburney simon parsons liz sonenberg argumentationbased negotiation knowledge engineering review v18 n4 p343375 december
optimizing computations effective blockprocessing blockprocessing decrease time power required perform given computation simultaneously processing multiple samples input data effectiveness blockprocessing severely limited however delays dataflow graph computation placed suboptimally paper investigate application retiming improving effectiveness blockprocessing computations particular consider kdelay problem given computation dataflow graph positive integer k wish compute retimed computation graph original delays relocated k data samples processed simultaneously fully regularly give exact integer linear programming formulation kdelay problem also describe algorithm solves kdelay problem fast practice relying set necessary conditions prune search space experimental results synthetic random benchmarks demonstrate performance improvements achievable blockprocessing efficiency algorithm b introduction many application domains computations defined semiinfinite long streams data rate incoming data dictated nature application often cannot satisfied straightforward implementation specification although speed hardware components increasing steadily throughput requirements new applications increasing even faster pace recent studies show computational requirements per sample stateoftheart communication preliminary version work presented 33rd acmieee design automation conference june 1996 b figure 1 improving effectiveness blockprocessing retiming blockprocessing factor original computation dataflow graph part 1 blockprocessing factor retimed graph part b 3 doubling every year processing power hardware doubling every three years 5 furthermore new applications requirements low power dissipation impose additional design constraints often add gap speed hardware primitives rate incoming data order meet increasing computational demands todays communication ap plications required compute simultaneously multiple samples incoming data stream approach known blockprocessing vectorization widely used satisfy throughput requirements use parallelism pipelining block processing enhances regularity locality computations thus greatly facilitating efficient implementation many hardware platforms 6 9 enhanced regularity reduces effort software switching address calculation improved locality improves effectiveness codesize reduction methods 13 moreover blockprocessing enables efficient utilization pipelines efficient implementations vectorbased algorithms fftbased filtering errorcorrection codes 2 general block processing beneficial cases net cost processing n samples individually higher net cost processing n samples simultaneously typical cost measures include processing time memory requirements energy dissipation per sample several ways increase blockprocessing factor computation number data samples processed simultaneously example one unfold basic iteration computation schedule computational blocks different iterations execute successively however technique may uniformly increase blockprocessing factor computational blocks another transformation used increasing blockprocessing factor retiming contrary architectural transformation techniques targeted highlevel synthesis 8 17 retiming used traditionally clock period minimization 7 10 12 logic synthesis 14 15 figure 1 illustrates use retiming improving blockprocessing computation dataflow graph cdfg figure three computation blocks b c three delays input stream coming block output stream generated assuming computation implemented uniprocessor system expression block gives initiation time x computation time per block input initiation time includes contextswitching overhead fetching data instructions background memory cost reconfiguring pipelines single iteration computation figure 1a completes 75766334 cycles executing blocks order three iterations computational blocks executed order case new input consumed every 34 cycles entire computation needs 3 theta cycles hand functionally equivalent cdfg figure 1b obtained retiming original cdfg complete three iterations single block iteration requires 7 cycles grouping three delays one edge computations three iterations executed order 1 thus amortizing initiation time block three inputs recently retiming studied context optimum vectorization class dsp programs 16 18 specifically technique linear vectorization dsp programs using retiming presented 18 technique involves redistribution delays cdfg representation dsp program way maximizes concentration delays edges however fully regular vectorization cannot achieved using linear vectorization approach paper moreover retiming problem computing linear vectorizations formulated nonlinear program computationally expensive solve paper consider problem retiming computation dataflow graphs achieve given blockprocessing factor k call kdelay problem first present integer linear programming ilp formulation kdelay problem formulate set necessary conditions use develop efficient branchand bound algorithm kdelay problem given cdfg positive integer k algorithm computes retimed cdfg achieves blockprocessing factor k determines retiming exist important feature approach blocks retimed cdfg achieve blockprocessing factor k execution order across iterations result retimed cdfgs operate faster less expensive implement generic blockprocessed cdfgs provide extensive experimental results demonstrate effectiveness optimization efficiency algorithms remainder paper organized follows section 2 describe representation computations dataflow graphs give background material block processing retiming also give precise mathematical formulation kdelay problem section 3 present integer linear programming formulation kdelay problem section 4 describe set effective necessary conditions using necessary conditions develop branchandbound algorithm section 5 solving kdelay problem efficient practice present experimental results section 6 conclude directions future work section 7 preliminaries section first describe dataflow graph representation computations subsequently provide background blockprocessing give conditions must satisfied effective blockprocessing also provide background material retiming give mathematical formulation kdelay problem 21 graph representation cdfg computation structure edgeweighted directed graph nodes v 2 v model computation blocks subroutines arithmetic boolean oper ators directed edges e 2 e model interconnection data control depen dencies computation blocks edge e 2 e associated weight denotes number delays registers associated interconnection figure 3a gives graph representation sample cdfg delay state behavioral synthesis corresponds iteration boundary software compilation register gatelevel description results paper translated one domain two straightforward manner translation results behavioral logic synthesis involves semantic interpretation 22 blockprocessing blockprocessing strives maximize throughput computation simultaneously processing multiple samples incoming data maximum number samples processed simultaneously immediately block v called blockprocessing factor k v block blockprocessing linear blocks b figure 2 types linear blockprocessing regular linear blockprocessing factor 2 b irregular linear blockprocessing factor 2 blockprocessing factor k given linear blockprocessing factor k k delta jv j computational block evaluations generate k iterations computation constitute block iteration linear blockprocessing factor k regular k data samples processed simultaneously every computational block accessed block iteration retimed cdfg figure 2a example blockprocessed linearly regularly blockprocessing factor 2 computation blocks cdfg execute order 1 two input samples consumed blockiteration regular blockprocessing leads efficient implementations cdfgs reduces costs address calculation software switching cdfg figure 2a illustrates indices 1 2 computed block used block b well first blockiteration linear blockprocessing need regular illustrated cdfg figure 2b blockprocessed blockprocessing factor 2 computation blocks cdfg execute order delta blockprocessing irregular however computation blocks process different samples given block iteration first block iteration example block b processes samples 1 2 block processes samples 2 3 following lemma gives necessary sufficient conditions achieving linear regular blockprocessing cdfg achieve linear regular block processing g factor k every edge e 2 e proof relation 1 satisfied cdfg blockprocessed linearly regularly factor k exists edge u e v 1 process samples per iteration since k remaining k gamma samples must accessed previous block iteration contradicts regularity 23 retiming retiming cdfg integer valued vertexlabeling r integer value denotes assignment lag vertex transforms g r edge u e defined equation retimed cdfg g r wellformed edges several important properties retiming transformation stem directly relation 2 one property use repeatedly proofs paper given vertex pair u v v retiming r changes original delay count every path u v amount verify property express postretiming delay count w r p along path p sum delay counts constituent edges since sum equation 4 telescopes thus change delay count path depends endpoints path corollary follows immediately equation 4 retiming change delay count around directed cycles cdfg based property straightforward show given edge e 2 e maximum number delays retiming place e cannot exceed w v 24 kdelay problem according lemma 1 linear regular blockprocessing factor k achieved cdfgs exactly 0 least k delays edge given cdfg satisfy condition relation 1 redistribute delays retiming nodes achieve desired blockprocessing factor k call problem computing retiming kdelay problem problem kdp kdelay problem given cdfg positive integer k compute retiming function r z every edge u e e determine retiming exists problem kdp cannot expressed directly linear programming form disjunction requirement relation 6 section rely notion companion graph described 10 express problem kdp integer linear program ilp companion graph g cdfg g constructed segmenting every edge u e two edges v x uv dummy vertex thus edge u e figure 3 illustrates construction companion graph following lemma gives necessary sufficient conditions hold retiming solves problem kdp cdfg let g companion graph exists retiming function r solves problem kdp g exists retiming function r z every edge u e every edge u e e f b f figure 3 constructing companion graph original cdfg companion graph generated segmenting every edge e two edges introducing dummy vertex first edge delay count 1 edge g segmented generate edges c w1 xcd xcd w2 g 0 proof inequality 7 ensures retimed circuit wellformed inequalities 8 ensure delay counts g 0 r 0 satisfy definition companion graph inequality ensures every edge u e x uv one delay retiming edge x uv v least k gamma 1 delays thus edge u e e delays least k delays retiming construction solution r problem kdp g derived r 0 simply setting following theorem expresses problem kdp set oe integer linear programming constraints theorem 3 let computation flow graph let g companion graph exists retiming function r solves problem kdp exists retiming function r z every edge every edge u e e proof follows directly linearity relation 2 form inequalities lemma 2 necessary conditions main challenge solving problem kdp determine edges delays ilp formulation problem kdp determine edges explicitly resulting constraints formulation appear special structure thus need resort general integer linear programming solvers compute solution computationally expensive large cdfgs section give set necessary conditions determine implicitly edges delays next section develop branchandbound technique based necessary conditions considerably efficient practice ilp formulation following four subsections derive necessary conditions feasibility problem kdp given cdfg first derive conditions ensure cycles enough delays around identify paths must necessarily contain delays paths must necessarily free delays based paths derive necessary conditions feasibility problem kdp finally describe construction constraints graph captures explicitly necessary conditions feasibility problem kdp 41 delays around cycles retiming leaves delay count around cycles unchanged therefore given cdfg g blockprocessing factor k problem kdp feasible delay count around cycles g greater k following lemma gives mathematical characterization result feasibility problem kdp cdfg problem kdp feasible g every vertex proof contradiction let problem kdp feasible g let exist vertex pair u v inequality 15 hold since w u v minimum delay count simple cycle u v exists directed cycle c g delay count less k since retiming change delay count around cycles conclude c edge delay count 1 every retiming contradicts assumption problem kdp feasible every vertex pair u v 2 v w u v computed efficiently allpairs shortestpaths computation ov steps thus assume remainder paper given cdfg g already satisfies inequality 15 42 paths delays using property retiming changes delay count paths given vertex pair amount determine vertex pairs paths must necessarily contain delays solution problem kdp following lemma gives necessary condition vertex pairs cdfg let r z solution problem kdp g every vertex pair u v 2 v exists path u p g proof contradiction suppose r solves problem kdp w r u v vertex pair u v 2 v satisfies condition lemma show exists edge e 2 e relation 6 hold path u q minimum delay w r u v nonzero delay count exceed k gamma 1 thus edge path violates relation 6 path u q statement lemma furthermore c b figure 4 illustration explicit implicit delayessential de vertex pairs cdfg part transformed algorithm addedges generate cdfg part b finally cdfg part c bold edges part b explicit de pairs weights edges indicate excess delay associated corresponding vertex pairs bold edges part c denote explicit implicit de pairs example pair b implicitly de becomes apparent de vertex pairs b c c made explicit thus p nonzero delay count exceed k gamma 1 consequently edge p violates relation 6 following lemma casts necessary conditions lemma 5 retiming problem appropriately constructed constraints graph given cdfg let g constraints graph generated g follows every vertex pair u v 2 v exists path u p g delay count wp w u v wp k add new edge problem kdp g every edge u e proof relation 2 definition wellformedness inequality 17 holds every edge e 2 e remains show inequality 17 holds edges set e gamma e consider vertex pair u v 2 v connected edge e purpose contradiction suppose problem kdp feasible rv gamma ru construction g since r solves problem kdp lemma 5 implies w r u v k contradicts inequality 19 call vertex pair u v 2 v delayessential de shortest path u q every retimed cdfg satisfies relation 6 must contain delays example every vertex exists path u p v w u delayessential since satisfies condition lemma 5 shown suffices compare delay count two shortest paths vertex pair check existence path u p v w u algorithm addedges1 figure 5 transforms given graph g g algorithm determines delayessential vertex pairs checking delay counts shortest strictlysecond shortest path every vertex pair differ less k every delayessential vertex pair u v edge u e introduced ensure w r u v k important note order determine whether given vertex pair delay essential one needs compare delay counts shortest path strictlysecond shortest simple path path whose weight strictly greater shortestpath weight although problem computing strictlysecond shortest simple path given vertex pair npcomplete corresponding problem without simple path requirement solved polynomial time 11 graphs satisfy inequality lemma 4 straightforward show strictlysecond shortest path nonsimple delay count exceeds shortest path least k conversely delay counts shortest strictlysecond shortest paths differ less k strictlysecond shortest path guaranteed simple following lemma shows algorithm addedges1 runs polynomial time addedges1g 1 every vertex pair u muv false 4 run allpairs strictlysecondshortest paths algorithm g 5 every vertex pair u v 2 v u p1 two shortest paths u v 6 7 muv true 8 introduce u e return g figure 5 algorithm addedges1 transforms lemma 7 ov 2 e steps algorithm addedges1 transforms given cdfg hv ewi g proof steps 12 take ov 2 time since allpairs secondshortest paths computed ov ev e time 11 step 4 takes ov 2 e time steps 510 take ov 2 time complete thus algorithm addedges1 terminates ov 2 e steps lemma 5 captures explicit delay requirements implicit hidden require ments let us assume example wish solve problem kdp cdfg figure 4a 2 since shortest secondshortest paths vertices b 1 4 delays respectively condition lemma 5 apply appear delayessential verify however shortest path b must necessarily contain delays solution problem kdp since impossible retime given cdfg zero delay count b since vertex pairs b c c must satisfy condition lemma 5 need least 2 delays shortest paths thus delay along path moved outside b since retiming changes delay along paths vertex pair identical manner delay edge cannot moved b order expose implicit delay requirements construct new graph g delayessential vertex pairs explicit algorithm addedges2 figure 6 transforms graph g generated given cdfg g algorithm addedges1 g determines implicit delayessential vertex pairs delayessential vertex pairs determined comparing every vertex pair delay counts shortest path 3 repeat 4 every delayessential vertex pair u v 2 q 5 muv true 6 introduce edge u e 8 every delayfree vertex pair u 9 mvu true run allpairs shortest paths algorithm g compute w u v every vertex pair u 20 delete edge u e v g 22 q 23 every pair u 26 elseif w delete edge v e u g 28 mvu false figure algorithm addedges2 transforms g steps new graph g delayessential delayfree vertex pairs g explicit transformed graph current iteration shortest path original graph vertex pair u v delay counts two paths differ edge u e weight introduced ensure w r u v k shown sufficient place additional edge delay counts two shortest paths differ less k difference exceeds k condition w r u v k implicitly taken care intuitively w u excess delay pair u gives upper bound number delays contributed pair rest graph new edges introduced new vertex pairs become delay essential shown figure 4 example pair b becomes delayessential delay requirements pairs b c c become explicit following lemma proves constraints introduced delayessential vertex pairs iteration algorithm addedges2 necessary problem kdp cdfg let g transformed graph generated repeat loop algorithm addedges2 iterations let g graph generated iterations augmenting e follows every vertex pair u v edge u e introduced e let r z solution problem kdp g every edge u e every edge u e proof let u e case w inequality 20 follows immediately inequality 19 let u e construction w u v w u v therefore r adding left righthand side parts inequality 19 along edges shortest path u v g obtain w r u v 0 inequality 22 implies w r u v 0 since r solution problem kdp infer otherwise edge along shortest path g r would contain fewer k delays therefore edge u e thus r satisfies inequality 20 43 paths without delays contrast delayessential paths paths must contain delays solution call vertex pair u v 2 v delayfree df shortest path u q every retimed cdfg satisfies relation 6 must contain delays example g constraints graph constructed g vertex pair u v delayfree since retiming change delay count around cycles cannot result w r u v k result every vertex pair condition w r u must hold otherwise relation 6 violated edge along shortest path u p construction graph g algorithm addedges2 delayfree vertex pairs determined checking every vertex pair u v whether edge v e introduced ensure w r u process repeated every delayfree vertex pair made explicit additional edges example figure 7a pair b delayessential introduce bold edge new edge introduces cycle fewer k delays thus vertex pair b must delayfree enforce constraint weight bold edge b changed gammaw b following lemma proves iteration algorithm addedges2 introduces constraints necessary problem kdp feasible lemma 9 let given cdfg let g transformed graph generated repeat loop algorithm addedges iterations let g graph generated iterations augmenting e follows every vertex pair u k edge v e ca b figure 7 delayfree path given cdfg 2 cycle formed less k delays therefore b must delayfree weight bold edge changed gammaw b b achieve introduced e let r z solution problem kdp g every edge u e every edge u e proof u e inequality 23 follows immediately inequality 22 consider edge v e vertex pair u v 2 v construction e i1 adding parts inequality 22 along edges shortest path v u e obtain w r v u 0 therefore r v u since r solves problem kdp last inequality implies w r u edge along shortest path u v e contains fewer k delays thus edge v e r satisfies inequality 20 44 constraints graph generation necessary conditions lemmas 5 8 9 encoded edges edgeweights constraints graph g generated algorithm addedges2 de vertex pair u v 2 g algorithm introduces edge u e k moreover df vertex pair u introduces edge v e weight w v following lemma summarizes necessary conditions feasibility problem kdp given cdfg g terms transformed graph g cdfg let g transformed graph generated algorithm addedges2 let r z solution problem kdp g every edge u e proof follows directly lemmas 8 9 following lemma gives running time algorithm addedges2 lemma 11 ov 3 ev 4 lg v steps algorithm addedges2 transforms given cdfg g determines transformation possible proof repeat loop step 3 execute ov 2 times worst case iteration one additional edge de df vertex pair gets added modified graph shown delay count additional edge gets modified loops algorithm addedges2 execute ov 2 steps since ov 2 vertex pairs step 15 takes ov using johnsons algorithm computing allpairs shortest paths 4 thus body repeat loop completes ov 5 practical branchandbound algorithm section describe efficient branchandbound scheme solving problem kdp scheme relies necessary conditions derived section 4 effectively prune search space computing solution g 1 every vertex ru 0 6 return r 7 else return infeasible figure 8 algorithm solvekdp solving problem kdp figure 8 describes algorithm solvekdp problem kdp generating constraints graph g algorithm initializes r searches solution using procedure branchandbound described figure 9 recursive procedure branchandbound computes retiming r satisfies constraints g exists violating edge e retimed graph g r edge delay count 1 k gamma 1 algorithm branchandbound adds constraints g force e least k delays subsequently computes retiming satisfies augmented constraints set step repeated solution found obtain set necessary conditions cannot satisfied retiming case algorithm branchandbound backtracks backtracking step state constraints graph restored new constraint added forces violating edge e take delay count zero given cdfg g optimal blockprocessing factor kmax largest number samples processed successively computation blocks g number equals maximum number delays placed edge bounded f thus kmax determined binary search integers range 1 f feasibility value checked using algorithm solvekdp 6 experimental results developed three programs computing optimal blockprocessing factor kmax three programs kmax determined binary search section present results application programs real synthetic dsp computations purpose experiments determine much blockprocessing speeds computations compare efficiency different implementations evaluate effectiveness necessary conditions first program ilp solves integer linear programming formulation problem branchandbound satisfies inequality 24 exists 3 return fail 6 save g r 8 introduce edge u e 12 return success else restore g r 19 return success else restore g r 22 return fail return success figure 9 algorithm branchandbound called algorithm solvekdp solving problem kdp kdp described section 3 first generates ilp constraints solves integer program separately using lp solve publicdomain mixedinteger linear programming solver 1 second program ncilp first checks necessary conditions given section 4 screen infeasible problems problems satisfy necessary conditions solved ilp formulation fed lp solve third program bb implementation algorithm solvekdp given section 5 branchandbound scheme relies necessary conditions section 4 effectively prune search space order explore computational speedup possible blockprocessing applied kdelay optimization computation dataflow graphs four real dsp programs test suite comprised adaptive voice echo canceler adaptive video coder two examples 18 size cdfgs dsp programs ranged 10 25 nodes results speedup experiments given table figure 10 data obtained uniprocessor implementations cdfg improvement design cycles kmax cycles improvement original cdfg optimized cdfg echo canceler 1215 3 840 31 figure 10 experimental results uniprocessor implementations given fraction cycles optimized cdfg cycles original cdfg kdelay retiming reduction achieved execution time given fraction sum contextswitching overheads nodes c sum computation times experiments initiation computation times obtained using measurements typical dsp general purpose processors tms32020 motorola 56000 order evaluate efficiency implementations experimented large synthetic graphs addition real dsp programs synthetic graphs test suite generated using sprand function random graph generator described 3 graphs generated using sprand connected integer edge weights chosen uniformly range 0 5 given number vertices edges desired sprand generates graphs randomly placing edges vertices randomly assigning weights specified range size computation dataflow graphs 10 300 vertices 20 750 edges results application three programs synthetic test suite summarized figure 11 experiments conducted sparc10 64mb main memory cpu times three programs computing kmax results show ilp inefficient running time becomes impractical graphs vertices 70 edges ilp searches entire solution space detecting infeasible solutions binary search solutions feasible problems computed relatively fast fast two programs furthermore detection infeasible problems extremely timeconsuming ncilp efficient ilp primarily due quick screening infeasible problems based necessary conditions section 4 however ncilp cannot name ilp ncilp bb figure 11 comparison running times cpu seconds taken ilp ncilp bb compute kmax random graphs entries marked indicate running times exceeding 30000 cpu seconds handle efficiently cdfg 50 nodes bb efficient three programs orders magnitude faster ilp ncilp moreover handle graphs least one order magnitude larger graphs handled ilp ncilp thus conclude necessary conditions effective pruning search space 7 conclusion future work blockprocessing speeds execution computations amortizing context switching overheads several data samples paper investigated problem improving blockprocessing factor dsp programs using retiming transformation formulated problem computing retiming achieves given blockprocessing factor k integer linear program presented set necessary conditions problem computed polynomial time based conditions designed branchandbound scheme computing regular linear blockprocessings experiments real synthetic computation graphs branchandbound scheme orders magnitude efficient general integer linear programming approaches thus necessary conditions proved particularly powerful pruning search tree branchandbound scheme important question remains open whether necessary conditions also sufficient far able prove sufficiency hand discovered situation necessary conditions feasible yet kdelay problem infeasible nevertheless conjecture necessary conditions sufficient interesting direction investigation reduction critical path length conjunction maximization blockprocessing factor preliminary work area shows possible express critical path requirements form constraint edges transformed graph g future work area could explore applicability techniques compiling code long instruction word vliw architectures main challenge vliw machines issue many instructions possible clock cycle viewing instructions given program delay elements computation graph one could model compilation problem vliw architectures blockprocessing problem cdfg r lp solve mixedinteger linear programming solver fast algorithms digital signal processing shortest paths algorithms theory experimental evaluation introduction algorithms softwares chronic crisis optimizing twophase relative scheduling timing constraints algorithms highlevel synthesis digital circuits vlsi array processors delay efficient tool retiming realistic delay modeling computing strictlysecond shortest paths retiming synchronous circuitry storage assignment decrease code size retiming resynthesis optimizing sequential networks combinational techniques synchronous logic synthesis algorithms cycletime minimization optimum vectorization scalable synchronous dataflow graphs behavioral transformations algorithmic level ic design retiming dsp programs optimum vec torization tr vlsi array processors introduction algorithms storage assignment decrease code size practical application retiming design highperformance systems computing strictlysecond shortest paths fast algorithms digital signal processing ctr dongik ko shuvra bhattacharyya modeling blockbased dsp systems journal vlsi signal processing systems v40 n3 p289299 july 2005 mingyung ko chungching shen shuvra bhattachryya memoryconstrained block processing dsp software optimization journal signal processing systems v50 n2 p163177 february 2008 mingyung ko praveen k murthy shuvra bhattacharyya beyond singleappearance schedules efficient dsp software synthesis using nested procedure calls acm transactions embedded computing systems tecs v6 n2 p14es may 2007
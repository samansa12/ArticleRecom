fully dynamic algorithm recognizing representing proper interval graphs paper study problem recognizing representing dynamically changing proper interval graphs input problem consists series modifications performed graph modification deletion addition vertex edge objective maintain representation graph long remains proper interval graph detect ceases representation enable one efficiently construct realization graph inclusionfree family intervals problem important applications physical mapping dnawe give nearoptimal fully dynamic algorithm problem operates olog n worstcase time per edge insertion deletion prove close lower bound omegalog nloglog nlog b amortized time per operation cell probe model wordsize b also construct optimal incremental decremental algorithms problem handle edge operation o1 time byproduct algorithm solve olog n worstcase time problem maintaining connectivity dynamically changing proper interval graph b introduction graph g called interval graph vertices assigned intervals real line two vertices adjacent g iff intervals intersect set intervals assigned vertices g called realization g set intervals chosen inclusionfree g called proper interval graph proper interval graphs studied extensively literature cf 7 13 several linear time algorithms known recognition realization 2 3 paper deals problem recognizing representing dynamically changing proper interval graphs input series operations performed graph operation following adding vertex along edges incident deleting vertex edges incident adding edge deleting edge objective maintain representation dynamic graph long proper interval graph detect ceases representation enable one efficiently construct realization graph incremental version problem addition operations permitted ie operations include addition vertex addition edge decremental version problem deletion operations allowed motivation problem comes application physical mapping dna 1 physical mapping process reconstructing relative position dna fragments called clones along target dna molecule prior sequencing based information pairwise overlaps biological frameworks set clones virtually inclusionfree example clones similar length case instance cosmid clones case physical mapping problem modeled using proper interval graphs follows graph g built according biological data clone represented vertex two vertices adjacent iff corresponding clones overlap physical mapping problem translates problem finding realization g determining none exists overlap information accurate two problems would equivalent however biological techniques may occasionally lead incorrect conclusion whether two clones intersect additional experiments may change status intersection two clones resulting changes corresponding graph deletion edge addition edge set clones also subject changes adding new clones deleting bad clones chimerics 14 translate addition deletion vertices corresponding graph therefore would like able dynamically change graph reflect changes biological data long allow us construct map ie long graph remains proper interval graph several authors studied problem dynamically recognizing representing certain graph families hsu 10 given om n log ntime incremental algorithm recognizing interval graphs throughout denote number vertices graph n number edges deng hell huang 3 given lineartime incremental algorithm recognizing representing connected proper interval graphs algorithm requires graph remain connected throughout modifications algorithms 10 3 vertex increments handled recently ibarra 11 found fully dynamic algorithm recognizing chordal graphs handles edge operation time alternatively edge deletion log n time edge insertion log n time results follows general problem recognizing representing proper interval graphs give fully dynamic algorithm handles operation time od log n denotes number edges involved operation thus case vertex added deleted equals degree case edge added deleted 1 algorithm builds representation proper interval graphs given 3 also prove lower bound problem omega log nlog log n log b amortized time per edge operation cell probe model computation wordsize b 16 follows algorithm nearly optimal factor olog log n incremental decremental versions problem give optimal algorithms constant factor handle operation time od incremental problem generalizes result 3 arbitrary instances part general algorithm give fully dynamic procedure maintaining connectivity proper interval graphs procedure receives input sequence operations vertex addition deletion edge addition deletion query whether two vertices connected component assumed graph remains proper interval throughout modifications since otherwise main algorithm detects graph longer proper interval graph halts show implement procedure olog n time per operation compar ison best known algorithms maintaining connectivity general graphs require olog 2 n amortized time per operation 9 n worstcase deterministic time per operation 4 also show lower bound fredman henzinger 5 omega log nlog log nlog b amortized time per operation cell probe model wordsize b maintaining connectivity general graphs applies problem maintaining connectivity proper interval graphs paper organized follows section 2 give basic background describe representation proper interval graphs realization defines sections 3 4 present incremental algorithm section 5 extend incremental algorithm fully dynamic algorithm proper interval graph recognition representation also derive optimal decremental algorithm section 6 give fully dynamic algorithm maintaining connectivity proper interval graphs finally section 7 prove lower bound amortized time per operation fully dynamic algorithm recognizing proper interval graphs lack space proofs algorithmic details omitted preliminaries e graph denote set v vertices also v g set e edges also eg vertex n v n v fvg let r equivalence relation v defined urv iff equivalence class r called block g note every block g complete subgraph g size block number vertices two blocks b neighbors g hence vertices 2 b 2 b adjacent g straight enumeration g linear ordering phi blocks g every block block neighboring blocks consecutive phi l ordering blocks g 1 say ordered left b j b j ordered right b chordless cycle induced cycle length greater 3 claw induced k 13 graph clawfree contain induced claw basic definitions graph theory see eg 7 following useful facts interval proper interval graphs theorem 1 12 interval graph contains chordless cycle theorem 2 15 graph proper interval graph iff interval clawfree theorem 3 3 graph proper interval graph iff straight enumeration lemma 1 umbrella property let phi straight enumeration connected proper interval graph g b c blocks g adjacent c b adjacent c see figure 1 fig 1 umbrella property let g connected proper interval graph let phi straight enumeration g shown 3 connected proper interval graph unique straight enumeration full reversal define outdegree block b wrt phi denoted ob number neighbors b ordered right phi shall use following representation connected component dynamic graph maintain straight enumeration fact technical reasons shall maintain enumeration reversal details data structure containing information described information implicitly defines realization dynamic graph cf 3 follows assign vertex block b interval outdegrees hence realization graph computed data structure time 3 incremental algorithm vertex addition following two sections describe optimal incremental algorithm recognizing representing proper interval graphs algorithm receives input series addition operations performed graph upon operation algorithm updates representation graph halts current graph longer proper interval graph algorithm handles operation time od denotes number edges involved operation assumed initially graph empty alternatively representation initial graph known contig connected proper interval graph g straight enumeration g first last blocks contig called endblocks rest blocks called innerblocks mentioned component dynamic graph exactly two contigs full reversals maintained algorithm operation involves updating representation sequel concentrate describing one two contigs component second contig updated similar way 31 data structure following data kept updated algorithm 1 vertex keep name block belongs 2 block keep following end pointer null block endblock contig otherwise points endblock contig b size block c left right near pointers pointing nearest neighbor blocks left right respectively left right far pointers pointing farthest neighbor blocks left right respectively e left right self pointers pointing block f counter following shall omit details obvious updates name block vertex size block execution algorithm may need update many far pointers pointing certain block point another block order able o1 time use technique nested pointers make far pointers point location whose content address block far pointers point role special location served selfpointers value left right selfpointers b always address b say certain left right far pointer points b mean points left right selfpointer b let b blocks order change left right far pointers pointing point b require left right far pointer points b case simply exchange left right selfpointer left right selfpointer b means 1 previous left right selfpointer made point b algorithm records new left right self pointer b 2 previous left right selfpointer b made point algorithm records new left right selfpointer shall use following notation block b denote address memory b set far pointer point left right selfpointer b abbreviate set b denote left right near pointers b l b n r b respectively denote left right far pointers b f l b f r b respectively denote end pointer eb sequel often refer blocks addresses example b blocks n r sometimes refer b n r clear context also use name block denote vertex block given contig phi denote reversal phi r general performing operation denote graph operation carried g graph operation carried g 0 32 impact new vertex following describe changes made representation graph case g 0 formed g addition new vertex v degree also give necessary sufficient conditions deciding whether g 0 proper interval let b block g say v adjacent b v adjacent vertex b say v fully adjacent b v adjacent every vertex b say v partially adjacent b v adjacent b fully adjacent b following lemmas characterize assuming g 0 proper interval adjacencies new vertex lemma 2 g 0 proper interval graph v neighbors two connected components g lemma 3 3 let c connected component g containing neighbors v let contig c assume g 0 proper interval let 1 k following properties satisfied 1 v adjacent b b c v fully adjacent b b 2 v adjacent b b fully adjacent b b c b adjacent b c 3 adjacent b b v fully adjacent b one view contig phi connected proper interval graph c weak linear vertices c x phi iff block containing x ordered phi left block containing say phi 0 refinement phi every contig reversed also allow complete reversal phi lemma 4 g connected induced subgraph proper interval graph g 0 phi contig g phi 0 straight enumeration g 0 phi 0 refinement phi note whenever v partially adjacent block b g addition v cause b split two blocks g 0 namely b nn v b n v otherwise b block g v either fully adjacent adjacent b also block g 0 corollary 1 b block g v partially adjacent b n n v occur consecutively straight enumeration g 0 lemma 5 let c connected component g containing neighbors v let set blocks c adjacent v fb g assume contig g 0 proper interval following properties satisfied consecutive c 2 k 3 v fully adjacent b 3 v adjacent single block b 1 c b 1 endblock 4 v adjacent one block c neighbors another compo nent b 1 adjacent b k one b 1 b k endblock v fully adjacent innerblock proof claims 1 2 follow directly part 1 lemma 3 claim 3 follows part 3 lemma 3 prove last part lemma let us denote component containing neighbors v examine induced connected subgraph h g whose set vertices v h proper interval induced subgraph g composed three types blocks blocks whose vertices v c call henceforth cblocks blocks whose vertices v call henceforth dblocks fvg block h since fvg connected blocks c remain intact h except b 1 b k might split b j n n v surely contig h cblocks must ordered completely completely dblocks let phi denote contig h cblocks ordered blocks let x denote rightmost cblock phi umbrella property moreover x adjacent v lemma 4 phi refinement contig c hence precisely therefore one b 1 b k endblock wlog suppose contrary v fully adjacent b k lemma 4 contradicting umbrella property b 1 must adjacent b k else g 0 contains claw consisting vertex v dn v remains show b 1 innerblock suppose end block since b 1 b k adjacent c contains single block contradiction thus claim 4 proved 33 algorithm algorithm rely incremental algorithm deng hell huang 3 call henceforth dhh algorithm algorithm handles insertion new vertex graph od time provided neighbors connected component changing straight enumeration component appropriately refer reader 3 details perform following upon request adding new vertex v neighbor u v add one count block containing u call block full counter equals size empty counter equals zero partial otherwise order find set consecutive blocks contain neighbors v pick arbitrarily neighbor v march enumeration blocks left using left near neighbor pointers continue till hit empty block till reach end contig right way discover maximal sequence nonempty blocks component contain neighbors v call maximal sequence segment two extreme blocks segment allowed partial else fail lemma 52 segment found contains neighbors v use dhh algorithm order insert v g updating internal data structure accordingly otherwise lemmas 2 51 could one segment contains neighbors v case exactly one extreme block segment endblock v fully adjacent segment contains one block two extreme blocks segment adjacent else fail lemma 534 proceed find second segment containing neighbors v make sure two segments two different contigs checking endblocks point also check conditions 3 4 lemma 5 satisfied two segments cover neighbors v fail v adjacent vertices two distinct components c merge contigs let r two contigs c let l psi r two contigs way merge performed depends blocks v adjacent v adjacent b k b 0 umbrella property two new contigs refinements described following describe necessary changes data structure case new contigs three cases handled similarly block enumeration merge two enumerations blocks put new block fvg inbetween two contigs let leftmost block adjacent v new ordering let rightmost block adjacent v b 0 partial split two blocks order b 0 j partial split two blocks v order end pointers set eb 1 l nullify end pointers b k b 0 1 near pointers update n l n l b 0 case b split update n r made case b 0 split near pointers b 0 j1 far pointers b split set f l left selfpointer b left selfpointer split set f r 1 exchange right selfpointer j right selfpointer j addition set right far pointers left far pointers b 0 j fvg od time finally set f l 4 incremental algorithm edge addition section show handle addition new edge u v o1 time characterize cases g proper interval show efficiently detect update representation graph lemma 6 u v distinct components g g 0 proper interval iff u v endblocks respective contigs proof prove part let us examine graph fug h proper interval induced subgraph g g 0 proper interval lemma must endblock contig since u adjacent vertex component containing v argument applies u prove part give straight enumeration new connected component containing u v g 0 denote c components containing u v respectively let contig c l contig l straight enumeration new component check o1 time u v endblocks distinct contigs case update data structure according straight enumeration given proof lemma 6 o1 time remains handle case u v connected component c g n umbrella property follows c contains three blocks merged single block g 0 case g 0 proper interval updates internal data structure trivial following lemma analyses case n u 6 n v lemma 7 let contig c k assume n u 6 n v g 0 proper interval iff g proof prove part assume g 0 proper interval since b b j adjacent f r b suppose contrary addition f l b strict containment v z distinct blocks exists vertex b 2 n vn n z v b z u induce claw g 0 contradiction hence f l b f r b distinct blocks either u 62 eg vertex 2 n u n n x first case v u x vertices shortest path v induce chordless cycle g 0 second case u x v induce claw g 0 hence cases arrive contradiction proof f l b prove part shall provide straight enumeration c fu vg move v b j contained v f l b move u b b i1 u moved b oe fug split b b n fug fug order v moved b j oe fvg split b j fvg b j n fvg order easy see result straight enumeration c fu vg check o1 time condition lemma 7 holds case change data structure reflect new straight enumeration given proof lemma 7 done o1 time similar fashion update technique described section 33 details omitted following theorem summarizes results sections 3 4 theorem 4 incremental proper interval graph representation problem solvable o1 time per added edge 5 fully dynamic algorithm section give fully dynamic algorithm recognizing representing proper interval graphs algorithm performs operation od log n time denotes number edges involved operation supports four types operations adding vertex adding edge deleting vertex deleting edge based ideas used incremental algorithm main difficulty extending incremental algorithm handle types operations updating end pointers blocks deletions allowed bypass problem keep end pointers instead maintain connected components g use information algorithm next section show maintain connected components g olog n time per operation describe operation handled algorithm 51 addition vertex edge operations handled essentially way done incremental algorithm however order check endblocks two segments distinct components query data structure connected components olog n time similarly order check endpoints added edge distinct components check corresponding blocks distinct components olog n time 52 deletion vertex show next update contigs g deleting vertex v degree note g 0 proper interval induced subgraph g denote x block containing v x oe fvg change needed delete v hence concentrate case fvg find od time segment blocks includes x neighbors let contig containing x let blocks segment make following updates l check whether b merged b igamma1 f l b moving vertices b b igamma1 od time deleting b l act similarly wrt b j b j1 finally delete b l nonadjacent umbrella property longer connected component contig split two contigs one ending b lgamma1 one beginning b l1 merged update n r b updates made wrt case merged contig split nullify n r b lgamma1 l b l1 otherwise update n r b merged exchange right selfpointer b right selfpointer b igamma1 similar changes made wrt b j also set right far pointers previously pointing b l b left far pointers previously pointing b l b l1 od time note updates take od time require knowledge connected components g 53 deletion edge let u v edge g deleted let c denote connected component g containing u v let contig c resulting straight enumeration g 0 updates trivial case n one show g proper interval graph iff c clique k 1 assume henceforth k 1 wlog far neighbors split contig two contigs one ending b beginning b j otherwise updates straight enumeration derived following lemma lemma 8 let contig c k assume n u 6 n v g 0 proper interval iff f r b f l b g proof assume g 0 proper interval show f r b proof f l b adjacent g f r b suppose contrary f r b distinct blocks either vertex 2 n v n n x vertex b 2 n x n n v first case umbrella property u 2 eg therefore u x v induce chordless cycle g 0 second case x b u v induce claw g 0 hence cases arrive contradiction prove opposite direction give straight enumeration c n fu vg move u b igamma1 b contained u f r b j1 u moved fug order v moved fvg order result contig vg conditions lemma 8 fulfilled one update data structure according proof updates require knowledge connected components g shown take o1 time hence sections 52 53 obtain following result theorem 5 decremental proper interval graph representation problem solvable o1 time per removed edge 6 maintaining connected components section describe fully dynamic algorithm maintaining connectivity proper interval graph g ologn time per operation algorithm receives input series operations performed graph follow ing adding vertex adding edge deleting vertex deleting edge querying two blocks connected component algorithm depends data structure includes blocks contigs graph hence interacts proper interval graph representation algorithm response update request changes made representation graph based structure connected components prior update connected components graph updated let us denote bg block graph g graph vertex corresponds block g two vertices adjacent iff corresponding blocks adjacent g algorithm maintains spanning forest f bg order decide two blocks connected component algorithm checks belong tree f key idea design f efficiently updated upon modification g define edges f follows every two vertices u v bg corresponding blocks consecutive contig g conse quently tree f path representing contig crucial observation f addition deletion vertex edge g induces o1 modifications vertices edges f seen noting modification g induces o1 updates near pointers representation g remains show implement spanning forest trees may cut edge deleted f linked edge inserted f allows query vertex tree belong operations supported ettree data structure 8 olog n time per operation ready state main result theorem 6 fully dynamic proper interval graph representation problem solvable od log n time per modification involving edges 7 lower bound section prove lower bound ofomega log nlog log n log b amortized time per edge operation fully dynamic proper interval graph recognition cell probe model computation wordsize b 16 fredman saks 6 proved lower bound amortized time per operation following parity prefix sum pps problem given array integers execute arbitrary sequence addt sumt operations addt increases 1 sumt returns 2 fredman henzinger 5 showed lower bound applies problem maintaining connectivity general graphs showing reduction modified pps problem called helpful parity prefix sum proved lower bound slight change reduction yields lower bound problem maintaining connectivity proper interval graphs graph built reduction union two paths therefore proper interval using similar construction prove following result theorem 7 fully dynamic proper interval recognition takesomega log nlog log n log b amortized time per edge operation cell probe model wordsize b acknowledgments first author gratefully acknowledges support nserc second author supported part grant ministry science israel third author supported eshkol scholarship ministry science israel r establishing order human chromosomespecific dna fragments simple linear time recognition unit interval graphs recognition representation proper circular arc graphs siam journal computing lower bounds fully dynamic connectivity problems graphs cell probe complexity dynamic data structures algorithmic graph theory perfect graphs randomized dynamic graph algorithms polylogarithmic time per operation simple test interval graphs fully dynamic algorithms chordal graphs representation finite graph set intervals real line indifference graphs recombinant dna eigenschaften der nerven homologisch einfacher familien r n tables sorted tr ctr ron shamir roded sharan fully dynamic algorithm modular decomposition recognition cographs discrete applied mathematics v136 n23 p329340 15 february 2004 c crespelle c paul fully dynamic recognition algorithm certificate directed cograph discrete applied mathematics v154 n12 p17221741 15 july 2006 derek g corneil simple 3sweep lbfs algorithm recognition unit interval graphs discrete applied mathematics v138 n3 p371379 15 april 2004 jrgen bangjensen jing huang louis ibarra recognizing representing proper interval graphs parallel using merging sorting discrete applied mathematics v155 n4 p442456 february 2007
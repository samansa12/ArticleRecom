using redundancies find errors paper explores idea redundant operations like type errors commonly flag correctness errors experimentally test idea writing applying four redundancy checkers linux operating system finding many errors use errors demonstrate redundancies even harmless strongly correlate presence traditional hard errors eg null pointer dereferences unreleased locks finally show flagging redundant operations gives way make specifications fail stop bydetecting dangerous omissions b introduction programming languages long used fact many highlevel conceptual errors map lowlevel type errors paper demonstrates mapping diverent direction many highlevel conceptual errors also map lowlevel redundant operations exception stylized cases programmers generally attempting perform useful work perform action believed served purpose spurious operations violate belief likely errors example impossible boolean conditions signal mistaken expressions critical sections without shared state signal use wrong variables written read signal unintentionally lost result least conditions signal conceptual confusion would also expect correlate hard errors deadlocks null pointer dereferences etc even harmless redundancies use redundancies find errors three ways 1 writing checkers automatically flag redundancies 2 using errors predict nonredundant errors null pointer dereferences 3 using redundancies find incomplete program specifications discuss wrote four checkers flagged potentially dangerous redundancies 1 idempotent operations 2 assignments permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copies bear notice full citation first page copy otherwise republish post servers redistribute lists requires prior specific permission andor fee sigsoft 2002fse10 november 1822 2002 charleston sc usa never read 3 dead code 4 conditional branches never taken errors found would largely missed traditional type systems checkers example section 2 shows assignment variables signal mistakes yet assignments type check language know course legitimate actions cause redundancies defensive programming may introduce unnecessary operations robustness debugging code assertions check impossible conditions abstraction boundaries may force duplicate calculations thus evectively find errors checkers must separate redundancies induced error wrote redundancy checkers xgcc extensible compiler system 16 makes easy build systemspecific static analyses analyses depend extensible compiler make easier prototype perform focused suppression false positive classes evaluated evective flagging redundant operations finding dangerous errors applying four checkers linux operating system good test since linux large widelyused source code base check roughly 16 million lines serves known experimental base also written many people representative many diverent coding styles abilities expect redundancies even harmless strongly correlate hard errors relatively uncontroversial hypothesis confused incompetent programmers tend make mistakes experimentally test hypothesis taking large database hard linux errors found prior work 8 measuring well redundancies predict errors compared chance tests files redundancy errors roughly 45 100 likely hard errors compared files drawn chance diverence holds across diverent types redundancies finally discuss traditional checking approaches based annotations specifications use redundancy checks safety net find missing annotations incomplete specifications specification mistakes commonly map redundant operations example assume specification binds shared variables locks missed binding likely lead redundancies critical section shared state locks protect variables flag omissions know every lock protect shared variable every critical section contain shared state paper makes four contributions 1 idea redundant operations like type errors commonly flag correctness errors 2 experimentally validating idea writing applying four redundancy checkers real code errors found often surprised us 3 demonstrating redundancies even harmless strongly correlate presence traditional hard errors 4 showing redundancies give way make specifications fail stop detecting dangerous omissions main caveat approach errors count might errors since examining code write counter diagnosed errors reasonably sure close two years experience linux bugs reasonable confidence false positive rate bugs diagnose nonzero probably less 5 section 2 section 5 present four checkers section 6 correlates errors found traditional hard errors section 7 discusses check completeness using redundancies section 8 discusses related work finally section 9 concludes 2 idempotent operations system bugs minor false table 1 bugs found idempotent checker linux version 245ac8 checker section flags idempotent operations variable 1 assigned x x 3 bitwise ord x x 4 bitwise andd x x checker simplest paper requires 10 lines code system even found several interesting cases redundancies signal highlevel errors four apparent typos variable assignments clearest example following code programmer makes mistake copying structure sa structure da 241netappletalkaarpcaarprcv else need make copy entry good example redundant errors catch cases type systems miss code assignment variable type check languages know yet clearly contains error two errors caused integer overflow oring 8bit variable constant bits set upper 16 bits final one caused apparently missing conversion routine code seemed tested machine conversion unnecessary prevented tester noticing missing routine minor errors operations seemed follow nonsensical consistent coding pattern adding 0 variable typographical symmetry nonzero additions curiously three false positives annotated comment explaining redundant operation done gives evidence belief programmers regard redundant operations somewhat unusual macros main source potential false positives represent logical actions may map concrete action example networking code contains many calls form used reorder bytes variable x canonical network order machine receiving data unpack appropriately however machines data already network order macro expand nothing resulting code simply assign x suppress false positives modified preprocessor note lines contain macros simply ignore errors lines 3 redundant assignments system bugs false uninspected linux 245ac8 129 26 1840 table 2 bugs found redundant assignment checker linux version 245ac8 xgcc system used paper 1840 uninspected errors variables assigned never used linux expect large number actual errors given low number false positives inspected results checker section flags cases value assigned variable subsequently used checker tracks lifetime variables using simple global analy sis assignment follows variable forward paths emits error message variable read path either exiting scope assigned another value show many cases lost values signal real errors control flow followed unexpected paths results computed returned etc checker finds thousands redundant assignments system size linux since evective minimized chance false positives radically restricting variables would follow nonglobal variables aliased way checker code deals diverentiating errors three classes ranks following order 1 variables assigned values read empirically errors tend serious since flag unintentionally lost results 2 variables assigned nonconstant overwritten without read also commonly er rors tend less severe false positives class tend come assigning return value function call dummy variable ignored 3 variables assigned constant reassigned values without read frequently due defensive programming programmer always initializes variable safe value com monly null 0 0xffffffff 1 read use track value emit reporting error messages using common defensive value easily suppressed suppressing false positives many redundant checkers macros defensive programming cause false positives minimize impact macros checker track variables killed produced macros main remaining vulnerability values assigned passed debugging macros turned ov typically small number macros manually turn back use ranking minimize impact defensive pro gramming redundant operations errors done within span lines robust programming practice separated 20 thus rank errors based 1 line distance assignment reassignment 2 number conditions path close errors likely farther errors become arguably defensive programming errors checker found errors checkers written combined two interesting error patterns showed redundant signments 1 variables whose values unintentionally discarded 2 variables whose values used surprising control flow eg unexpected return figure 1 shows representative example first pat tern function signal pending returns true signal pending current process error code set code breaks enclosing loop value err must passed back calling application retry system call however code always returns 0 caller matter happens inside loop lead insidious error code usually works occasionally abort return success code causing client assume operation happened numerous similar errors caller side result function assigned variable ignored rather checked cases fact logically code contains errors readily flagged looking variables assigned used second class errors comes calculations aborted unexpected control flow figure 2 gives one ex ample paths loop end return wrongly aborting loop single iteration error caught fact assignment used walk linked list never read loop iterator would dead code figure 3 gives variation theme unexpected control flow statement extraneous statement terminator end making subsequent return always taken cases coding mistake caused dangling assignments used fact allows 241netdecnetafdecnetcdnwaitrun lost value break scpstate dnrun return 0 figure 1 lost return value caught flagging redundant assignment err 241netatmlecclecaddrdelete entry null bug never reached lecarpremoveprivlecarptables return 0 figure 2 singleiteration loop caught flagging redundant assignment entrynext assignment appears read loop iteration statement entry next dead code since loop always exits single iteration logical result entry loop trying delete first one list deleted us flag bogus structures even know control flows code presence errors led us write deadcode checker next section reassigning values typically harmless signal fairly confused programmers example 245ac8driversnetwansdlax25c allocandinitskbbuf struct skbuff new skb assigned value skb immediately reassigned another allocated value diverent case shows potential confusion cs iteration works 241driversscsiscsic scpnt scpnt scnext variable scnext assigned immediately reassigned loop logic behind decision remains unclear devious error values reassigned used suspicious lost values one worst interesting commercial system equivalent following code 245ac8fsntfsunistrcntfscollatenames ic c1 upcaselen c2 upcaselen meta stray terminator return errval c1 c2 return 1 figure 3 catastrophic return caught redundant assignment c2 last conditional accidentally terminated stray statement terminator end line causing routine always return err val 241netipv6rawcrawv6getsockopt switch optname case ipv6checksum optchecksum else bug always falls default return enoprotoopt figure 4 unintentional switch fall causing code always return error maps lowlevel redundancy value assigned val never used system bugs false linux 245ac8 66 26 table 3 bugs found dead code checker linux version 245ac8 first glance seems like obvious copyandpaste error turned redundancy flags much devious error array buf actually pointed memory mapped region kernel memory unlike normal memory reads writes memory cause cpu issue io commands hardware device thus reads idempotent two row rather one cause diverent results happen however code real silent error variant c code written pointers memory mapped io must declared volatile otherwise compiler free optimize duplicate reads away especially since case pointer stores could change values dangerously case buf declared normal pointer rather volatile one allowing compiler optimize wished fortunately error triggered gnu c compiler used weak optimizer conservatively optimize expressions many levels indirection however use aggressive compiler later version gcc could caused extremely diycult track bug surface 4 dead code checker section flags dead code since programmers generally write code run dead code catches logical errors signaled false beliefs impossible path execute core dead code checker straightforward markandsweep algorithm routine 1 marks blocks reachable routines entry node 2 traverses blocks routine flagging marked three modifications basic algorithm first truncates paths reach functions would return examples include panic abort bug used linux signal terminal kernel error reboot system code dominated calls cannot run second suppress error messages dead code caused constant conditions printfin foo since frequently signaled code commented using false condition also annotate error messages code flag single statement contains break return commonly result defensive pro gramming finally suppress dead code caused macros despite simplicity dead code analysis found high number clearly serious errors three errors caught redundant assignment checker also caught dead code extension 1 single iteration loop figure 2 2 mistaken statement terminator figure 3 3 unintentional fall figure 4 figure 5 gives frequent copyandpaste error macro pseterr returns caller realize thus seven call sites use macro dead code macro client intended executed 241driverscharriorioparamcrioparam retval riofail riospinunlockirqrestoreportpportsem flags returns return riofail figure 5 unexpected return call pseterr macro returns argument value error unfortunately programmer realize inserts subsequent op erations flagged dead code checker many similar mistaken uses macro figure 6 gives another common error singleiteration loop always terminates contains ifelse statement breaks loop paths hard believe code ever tested figure 7 gives variation one branch statement breaks loop uses cs continue statement skips rest loop body thus none code end body executed 241driversscsi53c78xxc returnoutstandingcommands struct ncr53c7x0cmd cnext ccmdscpbuffer printk break else printk duh break bug cannot reached struct scatterlist list list free figure broken loop first ifelse statement loop contains break paths causing loop always abort without ever executing subsequent code contains 5 redundant conditionals checker section flags redundant branch conditionals branch statements etc nonconstant conditionals always evaluate either 245ac8netdecnetdntablec dnfibtablelookup dnkeyleqk ffnkey break else bug cannot reached ffnstate dnsaccessed ffnstatednszombie ffnscope keyscope figure 7 useless loop body similarly figure 6 loop broken ifelse statement one branch aborts loop uses cs continue statement skip body begin another iteration 241driversnetarcnetarcrimic arcrimifound reserve irq requestirqdevirq arcnetinterrupt bugmsgdnormal cant get irq dn devirq return enodev figure 8 unexpected return misplaced braces insertion debugging statement causes control always return true false 2 switch statements impossible cases cases result logical inconsistency program therefore likely errors checker based falsepath pruning fpp feature xgcc system fpp originally designed prune away false positives arising infeasible paths symbolically evaluates variable assignments comparisons either constants eg variables eg using simple congruence closure algorithm 11 stop checker checking current execution path soon detects logical conflict fpp checker implemented using simple markandsweep algorithm routine explores feasible execution paths marks branches opposed basic blocks section visited along way takes set unmarked branches flags conditionals associated redundant checker able find hundreds redundant conditionals linux 241 main source false positives arises following two forms macros 1 embedded conditionals 2 constant macros used conditional statements eg debug debug defined 0 suppressing left three major classes 200 problematic cases describe first class errors least serious three characterize overly cautious programming style includes cases programmer checks condition multiple times within short program distances believe could indication novice programmer conjecture supported statistical analysis described section 6 figure 9 shows redundant check type linux 241 although almost certainly harmless shows programmer poor grasp code one might willing bet presence surrounding bugs 241driversmediavideocpiaccpiammap cam camops return enodev make really smpsafe downinterruptiblecambusylock return eintr cam camops redundant return enodev figure 9 overly cautious programming style second check cam camops redundant figure shows problematic case one see else branch second statement never taken first condition weaker negation second interestingly function returns diverent error codes essentially error indicating possibly confused programmer 241driversnetwansbnicsbniioctl ifslave slaveflags iffup devflags iffup print error message back return einval slave bug slave impossible else print error message return enoent figure 10 overly cautious programming style check slave guaranteed true also notice diverence return value second class errors catch seemingly harmless examine carefully find serious errors around guesswork cross referencing assume loop figure 11 trying recover hardware errors encountered reading network packet since variable err never updated loop body condition err success always true loop body never executed nonsensical could signal possible bug author forgets update err large chunk recovery code loop bug confirmed could diycult detect dynamically error recovery code easy miss testing third class errors clearly serious bugs figure 12 shows example detected redundant condi 241driversnettokenringsmctrc smctrrxframe large chunk apparent recovery code updates err err success break figure redundant conditional suggests serious program error tional checker one see second third statements carry entirely diverent actions identical condi tions apparently programmer cutandpasted conditional without changing one two node logged fourth possibility node present 241driversfciph5526c rscnhandler loginstate nodeloggedin loginstate nodeprocessloggedin else loginstate nodeloggedout txadiscfi elsadisc nodeid else bug redundant conditional loginstate nodeloggedout txlogifi elsplogi nodeid figure 12 redundant conditionals signal errors conditional expression placed else branch another identical one figure 13 shows another serious error one see author intended insert element pointed sp doublylinked list head qq first loop really nothing setting srb p null nonsensical checker detects error inferring exit condition loop conflicts true branch ensuing statement obvious fix replace condition srb p srb p srb pnext bug dangerous hard detect quietly discards everything original list constructs new one sp element matter fact bug still present latest 2419 release linux kernel source writing 6 predictingharderrorswithre dundancies section show correlation redundant errors hard bugs crash system redundant errors come previous four sections hard 241driversscsiqla1280c qla1280putqt srbp srbp bug branch never taken srbpsprev else qqfirst else qqlast figure 13 serious error linked list insertion imple mentation srb p always null loop appears check wrong boolean condition bugs collected linux 241 checkers described 8 bugs include use freed memory dereferences null pointers potential deadlocks unreleased locks security violations eg use untrusted value array index show strong correlation two error populations using statistical technique called contingency table method 6 show file containing redundant error roughly 45 100 likely hard error file selected random results indicate 1 files redundant errors good audit candidates 2 redundancy correlates confused programmers probably make series mistakes 61 methodology subsection describes statistical methods used measure association program redundancies hard errors analysis based 2 2 contingency table 6 method standard statistical tool studying association two diverent attributes popula tion case population set files checked two attributes whether file contains redundancies b whether contains hard errors contingency table approach sample population crossclassified four categories based two attributes say b population obtain counts ij category tabularize result follows true false totals true false totals values margin n 1 n 2 n row column totals n grand total null hypothesis h 0 test b mutually independent ie knowing give us additional information b precisely h 0 holds expecting 1 compute expected values four cells table follows use chisquared test statistic 15 measure far observed values ij deviates expected values e ij using statistic derive probability observing null hypothesis h 0 true called pvalue 2 smaller pvalue stronger evidence h 0 thus stronger correlation attributes b 62 data acquisition test results previous work 8 used xgcc system check 2055 files linux 241 kernel focused serious system crashing hard bug able collect 1800 serious hard bugs 551 files types bugs checked included null pointer dereference deadlocks missed security checks use bugs represent class serious hard errors derive correlation program redundancies crossclassify program files linux kernel following four categories obtain counts 1 number files redundancies hard errors 2 number files redundancies hard errors 3 number files hard errors redundancies 4 number files neither redundancies hard errors carry test described section 61 following three redundancy checkers redundant assignment checker dead code checker redundant conditional checker idempotent operation excluded small sample size result tests given tables 4 5 6 7 see correlation redundancies hard see true consider 100 white balls urn first randomly draw 40 put red mark put back urn randomly draw put blue mark obviously expect roughly 80 40 balls red marks blue marks expect roughly 80 remaining red mark blue mark 2 technically h 0 2 distribution one degree freedom pvalue looked cumulative distribution table 2 1 distribution example larger 4 pvalue go 5 redundant hard bugs assignments totals 551 1504 2055 table 4 contingency table redundant assignments vs hard bugs 345 files error types 435 files assign error hard bugs 206 files hard bug assignment error 1069 files bugs either type tstatistic value four gives pvalue less 05 strongly suggests two events independent observed value 19437 gives pvalue essentially 0 noticeably better standard threshold intuitively correlation error types seen ratio 345435 considerably larger ratio events independent expect two ratios close hard bugs dead code yes totals totals 551 1504 2055 table 5 contingency table dead code vs hard bugs errors extremely high pvalues approximately 0 four cases strongly suggests redundancies often signal confused programmers therefore good predictor hard serious errors 63 predicting hard errors addition correlation want know much likely find hard error file one redundant operations precisely let e event given source file contains one hard errors r event contains one forms redundant operations compute confidence interval measure much likely find hard errors file given program redundancies prior probability hard errors computed follows number files hard errors total number files checked tabularize conditional probabilities values table 8 excluded idempotent operation checker small bug sample shown ta ble given form redundant operation roughly likely find error file otherwise furthermore redundancies even predict hard errors across time carried test redundant hard bugs totals 551 1504 2055 table contingency table redundant conditionals vs hard bugs hard bugs aggregate totals 551 1504 2055 table 7 contingency table program redundancies aggre gate vs hard bugs dundancies found linux 245ac8 hard errors 241 roughly year older found similar results 7 failstop specification section describes use redundant code actions find several types specification errors omissions often program specifications give extra information allow code checked whether return values routines must checked null shared variables protected locks permission checks guard sensitive operations etc vulnerability approach code feature annotated included specification checked catch omissions flagging redundant operations cases many others least one specified actions makes little sense isolation critical sections without shared states pointless permission checks guard known sensitive actions thus code intend useless operations redundancies happen exactly checkable actions missed least caught something pointless deleted sketch four examples close checker uses redundancy find missing checkable actions detecting omitted null annotations tools lclint 12 let programmers annotate functions return null pointer null annotation tool emits error unchecked use pointer returned null routine real system many functions return making easy forget annotate catch omissions using redundancy know return value null functions checked thus check nonannotated function means either function 1 annotated null 2 function cannot return null programmer misunderstood interface finding missed lockvariable bindings data race detection tools warlock 20 let users explicitly bind locks confidence interval assign 353 889 03971 01289 00191 4811 1395 dead code conditionals aggregate 372 945 03937 01255 00187 4683 1365 table 8 program files redundancies roughly 50 likely contain hard errors variables protect tool flags annotated variables accessed without lock held however lock variable bindings easily forgotten causing variable silently unchecked use redundancy catch mistakes critical sections must protect shared state flagging find either 1 useless locking deleted good performance 2 places shared variable annotated missed volatile annotations described section 4 c variables unusual readwrite semantics must annotated volatile type qualifier prevent compiler optimizations safe normal variables incorrect volatile ones eliminating duplicate reads writes missing volatile annotation silent error software usually work occasionally give incorrect errors shown omissions detected flagging redundant operations reads writes make sense nonvolatile variables missed permission checks secure system must guard sensitive operations modifying file killing pro cess permission checks tool automatically catch mistakes given specification checks protect operations large number sensitive operations makes easy forget binding use redundancy find omissions assuming programmers redundant permission checks finding permission check guard known sensitive operation signals incomplete specification 71 case study finding missed security holes separate paper 3 describe checker found operating system security holes caused integer read untrusted sources network packets system call param eters passed trusting sink array indices memory copy lengths without checked safe upper lower bound single violation let malicious attacker take control entire system unfortunately checker vulnerable omissions omitted source means checker track data produced omitted sink means checker flag unsanitized data reaches sink implementing checker used ideas section detect omissions given list known sources sinks normal checking sequence 1 code reads data unsafe source 2 checks 3 passes trusting sink assuming programmers gratuitous sanitization missed sink detected flagging code steps 1 2 3 reading value known source sanitizing implies code believes value reach dangerous operation value reach known sink likely missed one similarly could infer missed sources converse analysis flagging os sanitizes data think tainted passes trusting sink analysis found roughly 10 common uses sanitized inputs linux 246 3 nine uses harmless however one security hole unexpectedly specification omission rather sink known interprocedural analysis overly simplistic causing us miss path fact redundancy flags errors specification tool nice surprise 8 related work two existing types analysis focused redundant operations optimizing compilers anomoly detection work optimizing compilers commonly deadcode elimination commonsubexpression elimination 1 remove redundancies improve performance one contribution work realization analyses silently finding errors since invention analyses closely mirror algorithms core several refinements first operate higherlevel representation typical optimizer since large number redundant operations introduced due compilation source constructs intermediate representation second order preserve semantics program compiler optimizers conservative analysis contrast since goal find possible errors perfectly reasonable flag redundancy even 95 sure legitimacy fact report suspicious cases sort order confidence heuristic eg distance redundancies etc report finally analysis tradeovs make diver example use pathsensitive algorithm suppress false paths optimizers omit path sensitive analyses time complexity outweighs benefit second type redundant analysis includes checking tools fosdick osterweil first applied data flow anomaly detection techniques context software reliability dave system 18 used depth first search algorithm detect fixed set variable defuse type anomalies uninitialized read double definition etc static approaches like 13 14 18 often pathinsensitive therefore could report bogus errors infeasible paths dynamic techniques 17 7 instruments program detect anomalies arise execution however dynamic approaches weaker find errors executed paths runtime overhead diy culty instrumenting operating systems limits usage approach dynamic system similar work huang 17 discusses checker similar assignment checker section 3 tracks lifetime variables using simple global analysis assignment follows variable forward paths gives error variable read path either exiting scope assigned another value however experimental results given dynamic seems predisposed report large numbers false positives case value read current executed path would used nonexecuted path tools lint lclint 12 gnu c compilers wall option warn unused variables routines ignored return values long found redundancies real code use daily redundancies commonly viewed harmless stylistic issues evidence perception best knowledge many recent error checking projects focus solely hard errors null pointer dereferences failed lock releases rather redundancy checking 4 10 5 9 2 19 21 main contribution paper showing redundancies signal real errors experimentally measuring well holds 9 conclusion paper explored hypothesis redundancies like type errors flag higherlevel correctness mistakes evaluated approach using four checkers applied linux operating system simple analyses found many surprising us error types correlated well known hard errors redundancies seemed flag confused poor programmers prone error types indicators could used decide audit system 10 acknowledgement would like thank anonymous reviewers helpful comments work supported nfs award 0086160 darpa contract mda90498ca933 11 r detecting races relay ladder logic programs using programmerwritten compiler extensions catch security holes automatically validating temporal safety properties interfaces static analyzer finding dynamic programming errors statistical inference empirical study operating systems errors enforcing highlevel protocols lowlevel software overview extended static checking system variations common subexpression problem tool using specifications check code algebra data flow anomaly detection data flow analysis software reliability system language building systemspecific detection data flow anomaly program instrumentation dynamic data race detector multithreaded programming first step towards automated detection buver overrun vulnerabilities tr compilers principles techniques tools aidamyampersandmdasha dynamic data flow anomaly detection system pascal programs lclint variations common subexpression problem static analyzer finding dynamic programming errors data flow analysis software reliability enforcing highlevel protocols lowlevel software automatically validating temporal safety properties interfaces empirical study operating systems errors system language building systemspecific static analyses detecting races relay ladder logic programs algebra data flow anomaly detection using programmerwritten compiler extensions catch security holes ctr david hovemeyer jaime spacco william pugh evaluating tuning static analysis find null pointer bugs acm sigsoft software engineering notes v31 n1 january 2006 zhang neelam gupta rajiv gupta locating faults automated predicate switching proceeding 28th international conference software engineering may 2028 2006 shanghai china zhang neelam gupta rajiv gupta pruning dynamic slices confidence acm sigplan notices v41 n6 june 2006 neelam gupta haifeng xiangyu zhang rajiv gupta locating faulty code using failureinducing chops proceedings 20th ieeeacm international conference automated software engineering november 0711 2005 long beach ca usa yuriy brun michael ernst finding latent code errors via machine learning program executions proceedings 26th international conference software engineering p480490 may 2328 2004 david hovemeyer william pugh finding bugs easy acm sigplan notices v39 n12 december 2004 sudarshan srinivasan srikanth kandula christopher r andrews yuanyuan zhou flashback lightweight extension rollback deterministic replay software debugging proceedings usenix annual technical conference 2004 usenix annual technical conference p33 june 27july 02 2004 boston
program profiling support value prediction paper explores possibility using program profiling enhance efficiency value prediction value prediction attempts eliminate truedata dependencies predicting outcome values instructions runtime executing truedata dependent instructions based prediction far published papers area examined hardwareonly value prediction mechanisms order enhance efficiency value prediction proposed employ program profiling collect information describes tendency instructions program valuepredictable compiler acts mediator pass information valueprediction hardware mechanisms information exploited hardware order reduce mispredictions better utilize prediction table resources distinguish different value predictability patterns still benefit advantages value prediction increase instructionlevel parallelism show new method outperforms hardwareonly mechanisms examined benchmarks b introduction modern microprocessor architectures increasingly designed employ multiple execution units capable executing several instructions retrieved sequential instruction stream parallel efficiency architectures highly dependent instructionlevel parallelism ilp extract program extractable ilp depends processors hardware mechanisms well programs characteristics 6 7 programs characteristics affect ilp sense instructions cannot always eligible parallel execution due several constraints constraints classified three classes truedata dependencies name dependencies false dependencies control dependencies 6 7 15 control dependencies name dependencies considered upper bound extractable ilp since handled even eliminated several cases various hardware software techniques 1 2 3 6 opposed name dependencies control dependencies truedata dependencies considered fundamental limit extractable ilp since reflect serial nature program dictating sequence data passed instructions kind extractable parallelism represented dataflow graph program 7 recent works 9 10 4 5 proposed novel hardwarebased paradigm allows superscalar processors exceed limits truedata dependencies paradigm termed value prediction attempted collapse truedata dependencies predicting runtime outcome values instructions executing truedata dependent instructions based prediction within concept shown limits truedata dependencies exceeded without violating sequential program correctness claim breaks two accepted fundamental principles 1 ilp sequential program limited dataflow graph representation 2 order guarantee correct execution program truedata dependent instructions cannot executed parallel also indicated value prediction cause execution instructions become speculative unlike branch prediction also cause instructions executed speculatively since control dependent value prediction may cause instructions become speculative since assured fed correct input values recent works area value prediction considered hardwareonly mechanisms paper provide new opportunities enabling compiler support value prediction using program profiling profiling techniques widely used different compilation areas enhance optimization programs general idea profiling study behavior program based previous runs past runs program executed based different sets input parameters input files training inputs runs required information profile image collected information available used compiler optimize programs code efficiently efficiency program profiling mainly based assumption characteristics program remain different runs well paper address several new open questions regarding potential profiling compiler support value prediction note attempt replace value prediction hardware mechanisms compiler profiler aim revising certain parts value prediction mechanisms exploit information collected profiler profile phase suggest collecting information instructions tendency valuepredictable value predictability classify accordingly eg detect highly predictable instructions unpredictable ones classifying instructions according value predictability patterns may allow us avoid unpredictable instructions candidates value prediction general capability introduces several significant advantages first allows us better utilize prediction table enabling allocation highly predictable instructions addition certain microprocessors mispredicted values may cause extra misprediction penalty due pipeline organization therefore classification allows processor reduce number mispredictions saves extra penalty finally classification increases effective prediction accuracy predictor previous works performed classification employing special hardware mechanism studies tendency instructions predictable runtime 9 10 4 5 mechanism capable eliminating significant part mispredictions however since classification performed runtime could allocate advance predictable instructions prediction table result unpredictable instructions could uselessly occupied entries prediction table evacuated predictable instructions work propose alternative technique perform classification show profiling provide compiler accurate information tendency instructions valuepredictable role compiler case act mediator pass profiling information value prediction hardware mechanisms special opcode directives show classification methodology outperforms hardwarebased classification examined benchmarks particular performance improvement observable pressure prediction table term potential instructions allocated high moreover indicate new classification method introduces better utilization prediction table resources avoidance value mispredictions rest paper organized follows section summarizes previous works results area value prediction section 3 presents motivation methodology work section 4 explores potential program profiling various quantitative measurements section 5 examines performance gain new technique section 6 concludes paper 2 previous works results section summarizes experimental results hardware mechanisms previous familiar works area value prediction 9 10 4 5 results significance broadly studied works however chosen summarize since provide substantial motivation current work subsections 21 22 dedicated value prediction mechanisms value predictors classification mechanisms subsection 23 24 25 describe statistical characteristics phenomena related value prediction relevance characteristics work presented section 3 2 1value predictors previous works introduced two different hardwarebased value predictors lastvalue predictor stride predictor simplicity assumed predictors predict destination values register operands even though schemes could generalized applied memory storage operands special registers program counter condition codes lastvalue predictor 9 10 predicts destination value individual instruction based last previously seen value generated computed predictor organized table eg cache table see figure 21 every entry uniquely associated individual instruction entry contains two fields tag lastvalue tag field holds address instruction part highorder bits case associative cache table lastvalue field holds previously seen destination value corresponding instruction order obtain predicted destination value given instruction table searched absolute address instruction stride predictor 4 5 predicts destination value individual instruction based last previously seen value calculated stride predicted value sum last value stride entry predictor holds additional field termed stride field stores previously seen stride individual instruction figure 21 stride field value always determined upon subtraction two recent consecutive destination values tag last value predicted value hitmiss instruction address lastvalue predictor tag last value stride hitmiss instruction address predicted value predictor figure 21 last value stride predictors 2 2classification value predictability classification value predictability aims distinguishing instructions likely correctly predicted tend incorrectly predicted predictor possible method classifying instructions using set saturated counters 9 10 individual saturated counter assigned entry prediction table occurrence successful unsuccessful prediction corresponding counter incremented decremented respectively according present state saturated counter processor decide whether take suggested prediction avoid section 5 compare effectiveness hardwarebased classification mechanism versus proposed mechanism 2 3value prediction accuracy benefit using value prediction significantly dependent accuracy value predictor accomplish previous works field 4 5 9 10 provided substantial evidence support observation outcome values programs tend predictable value predictability prediction accuracy measurements predictors described subsection 21 spec95 benchmarks summarized table 21 note floating point benchmarks specfp95 prediction accuracy measured benchmark two execution phases initialization program reads input data computation actual computation made broad study analysis measurements found 4 5 prediction accuracy integer loads alu instructions fp loads fp computation instructions init phase comp phase 28 notations predictor l lastvalue predictor table 21 value prediction accuracy measurements 2 4distribution value prediction accuracy previous studies 4 5 revealed tendency instruction valuepredictable spread uniformly among instructions program refer instructions assign outcome value destination register approximately 30 instructions likely correctly predicted prediction accuracy greater 90 addition approximately 40 instructions unlikely correctly predicted prediction accuracy less 10 observation illustrated figure 22 integer floating point benchmarks importance observation implication discussed subsection 31 2 5distribution nonzero strides previous works 4 5 examined efficiently stride predictor takes advantage additional stride field prediction table beyond lastvalue predictor maintains single field per entry last value considered stride fields utilized efficiently predictor accomplishes correct value prediction stride field equal zero nonzero stride order grade efficiency used measure term stride efficiency ratio measured percentages stride efficiency ratio ratio successful nonzero stridebased value predictions overall successful predictions 1 initialization phase floatingpoint benchmarks denoted 1 computation phase 2 2 gcc1 gcc2 denotes measurements benchmark run different input files perl1 perl2 jr pnvl jff jff frpsuh ol lmshj shuo shuo yruwh 7khglvwulexwlrqrisuhglfwlrqdffxudf vxfru vxfru kgur g kgur g 7khglvwulexwlrqrisuhglfwlrqdffxudf figure 22 spread instructions according value prediction accuracy measurements indicated integer benchmarks stride efficiency ratio approximately 16 floating point benchmarks varies 12 initialization phase 43 computation phase also examined stride efficiency ratio instruction program allocated prediction table observed instructions could divided two major subsets small subset instructions always exhibits relatively high stride efficiency ratio large subset instructions always tend reuse last value low stride efficiency ratio figure 23 draws histograms experiments illustrates instructions program scattered according stride efficiency ratio 0 20 40 80 100 sim 126gcc 129comp ress 130li 132ijpeg 134perl 147vorte x efficiency ratio instructions figure 23 spread instructions according stride efficiency ratio 3 proposed methodology profiling techniques broadly employed various compilation areas enhance optimization programs principle technique study behavior program based one set train inputs provide gathered information compiler effectiveness technique relies assumption behavioral characteristics program remain consistent programs runs well first subsection present previous knowledge area value prediction motivated us towards new approach second subsection present methodology main principles 3 1motivation consequences previous results described section 2 significant since establish basis motivation current work respect following aspects 1 measurements described subsection 23 indicated considerable portion values computed programs tends predictable either stride lastvalue predictors shown previous works exploiting property allows processor exceed dataflow graph limits improve ilp 2 measurements subsection 24 indicated tendency instructions value predictable spread uniformly among instructions program programs exhibit two sets instructions highly valuepredictable instructions highly unpredictable ones observation established basis emlpoying classification mechanisms 3 previous experiments 4 5 also provided preliminary indication different input files dramatically affect prediction accuracy several examined benchmarks observation found common enough may tremendous significance considering involvement program profiling may imply profiling information collected previous runs program running application training input files correlated true situation program runs real input files provided user property extensively examined paper 4 also indicated set valuepredictable instructions program partitioned two subsets small subset instructions exhibit stride value predictability predictable stride predictor large subset instructions tend reuse last value predictable predictors previous works 4 5 showed although first subset relatively smaller second subset appears frequently enough significantly affect extractable ilp one hand use lastvalue predictor cannot exploit predictability first subset instructions hand use stride predictor significant number entries prediction table extra stride field useless assigned instructions tend reuse recently produced value zero strides observation motivates us employ hybrid predictor combines stride prediction table lastvalue prediction table instance may consider relatively small stride prediction table instructions exhibit stride patterns larger table instructions tend reproduce last value combination schemes may allow us utilize extra stride field efficiently 3 2 classification based program profiling compiler support methodology introducing work combines program profiling compiler support perform classification instructions according tendency value predictable familiar previous works performed classification using hardware mechanism studies tendency instructions predictable runtime 4 5 9 10 mechanism capable eliminating significant part mispredictions however since classification performed dynamically could allocate advance highly value predictable instructions prediction table result unpredictable instructions could uselessly occupied entries prediction table evacuated useful instructions alternative classification technique proposed paper two tasks 1 identify highly predictable instructions 2 indicate whether instruction likely repeat last value whether exhibits stride patterns methodology consists three basic phases figure 31 first phase program ordinarily compiled compiler use available known optimization methods code generated second phase profile image program collected profile image describes prediction accuracy instruction program refer instructions write computed value destination register order collect information program run simulation environment eg shade simulator see 12 simulator emulate operation value predictor measure instruction prediction accuracy simulation emulates operation stride predictor also measure stride efficiency ratio instruction profiling information could indicate instructions tend valuepredictable also ones exhibit value predictability patterns form strides lastvalue output profile phase file organized table entry associated individual instruction consists three fields instructions address prediction accuracy stride efficiency ratio note profile phase program run either single multiple times run program driven different input parameters files compiler program c fortran binary executable simulator train input parameters files profile image file phase 1 phase 2 compiler new binary executable opcode directives phase 3 threshold value user figure 31 three phases proposed classification methodology final phase compiler inserts directives opcode instructions perform instruction scheduling form code movement respect code generated first phase inserted directives act hints value predictability instructions supplied hardware note consider use opcode directives feasible since recent processors powerpc 601 made branch predictions based opcode directives 11 compiler employs two kinds directives stride lastvalue stride directive indicates instruction tends exhibit stride patterns lastvalue directive indicates instruction likely repeat recently generated outcome value default none directives inserted opcode instruction recommended value predicted compiler determine instructions inserted special directives according profile image file threshold value supplied user value determines prediction accuracy threshold instructions tagged directive valuepredictable instance user sets threshold value 90 instructions profile image file prediction accuracy less 90 inserted directives marked unlikely correctly predicted prediction accuracy greater equal 90 marked predictable instruction marked valuepredictable type directive either stride lastvalue still needs determined done examining stride efficiency ratio provided profile image file possible heuristic compiler employ stride efficiency ratio greater 50 indicates majority correct predictions nonzero strides therefore instruction marked stride otherwise tagged lastvalue directive another way determine directive type ask user supply threshold value stride efficiency ratio process completed previous hardwarebased classification mechanism set saturated counters becomes unnecessary moreover use hybrid value predictor consists two prediction tables lastvalue stride prediction tables subsection 22 candidate instruction value prediction allocated one tables according opcode directive type new capabilities allow us exploit value predictability patterns stride lastvalue utilize prediction tables efficiently addition allow us detect advance highly predictable instructions thus could reduce probability unlikely correctly predicted instructions evacuate useful instructions prediction table order clarify principles new technique assisted following sample c program segment program sums values two vectors b c vector first phase compilation program gcc 272 compiler using o2 optimization yields following assembly code sunsparc machine sunos 413 1 ogljordgl 2 ogljlrdgm second phase collect profile image program sample output file process illustrated table 31 seen table includes instructions program assign values destination register load add instructions simplicity refer value prediction destination operand register however methodology limited means applied destination operand condition code program counter memory storage location special register instruction address prediction accuracy efficiency ratio 3 9999 9999 7 9999 9999 9 9999 9999 table 31 sample profile image output example profile image indicates prediction accuracy instructions compute index loop 9999 efficiency ratio 9999 observation reasonable since destination value instructions correctly predicted stride predictor instructions example accomplished relatively low prediction accuracy stride efficiency ratio user determines prediction accuracy threshold 90 third phase compiler would modify opcodes add operations addresses 3 7 9 insert opcodes stride directive instructions program unaffected 4 examining potential profiling quantitative measurements section dedicated examining basic question program profiling supply value prediction hardware mechanisms accurate information tendency instructions valuepredictable order answer question need explore whether programs exhibit similar patterns run different input parameters different runs programs patterns correlated confirms claim profiling supply accurate information experiments use different programs chosen spec95 benchmarks table 41 different input parameters input files order collect profile image traced execution programs shade simulator 12 sunsparc processor first phase benchmarks compiled gcc 272 compiler available optimizations benchmarks benchmarks description go game playing simulator 88100 processor gcc c compiler based gnu c 253 compress95 data compression program using adaptive lempelziv coding li lisp interpreter ijpeg jpeg encoder perl anagram search program vortex singleuser objectoriented database transaction benchmark mgrid multigrid solver computing three dimensional potential field table 41 spec95 benchmarks run program create profile image containing statistical information collected runtime profile image run regarded vector v coordinates represents value prediction accuracy individual instruction dimension vector determined number different instructions traced experiment result running program n times time different input parameters input files obtain set n vectors vector represents profile image run j note run may collect statistical information instructions may appear runs therefore consider instructions appear different runs program instructions appear certain runs omitted vectors measurements indicate number instructions relatively small omitting instructions organize components vector corresponding coordinates would refer prediction accuracy instruction ie set coordinates 1l 2l nl refers prediction accuracy instruction l different runs program first goal evaluate correlation tendencies instructions valuepredictable different runs program different input files parameters therefore set vectors collected need define certain metric measuring similarity correlation choose use two metrics measure resemblance vectors term first metric maximumdistance metric metric vector coordinates calculated illustrated equation 41 max equation 41 mmax metric coordinate mv max equal maximum distance corresponding coordinates pair vectors set second metric use less strict term metric averagedistance metric metric also vector average k coordinates equal arithmeticaverage distance corresponding coordinates pair vectors set equation 42 average 3 equation 42 average metric obviously one use metrics order measure similarity vectors eg instead taking arithmetic average could take geometric average however think metrics sufficiently satisfy needs metrics calculated profile image illustrate distribution coordinates building histogram instance count number mv max coordinates whose values intervals 010 1020 3040 90100 observe coordinates scattered lower intervals conclude measurements similar correlation vectors high figures 41 42 illustrate histograms two metrics mv max mv average respectively 0 20 40 80 100 126gcc 129com press 130li 132ijpeg 134perl 147vorte x spread coordinates mvmax figure 41 spread mv max 126gcc 129com press 130li 132ijpeg 134perl 147vorte x spread coordinates mv average figure 42 spread mv average histograms clearly observe benchmarks coordinates spread across lower intervals observation provides first substantial evidence confirms one main claims tendency instructions program value predictable independent programs input parameters data addition confirms claim program profiling supply accurate information tendency instructions value predictable previously indicated profile image program provided compiler better tuned indicate instructions tend repeat recently generated value tend exhibit patterns strides order evaluate potential classification need explore whether set instructions whose outcome values exhibit tendency strides common different runs program done examining stride efficiency ratio instruction program profile image file case obtain profile image file vector coordinates represents stride efficiency ratio individual instruction run program n times time different input parameters input files obtain set n vectors vector represents profile image run j vectors collected use one previous metrics either maximumdistance averagedistance order measure resemblance set vectors n simplicity chosen time averagedistance metric demonstrate resemblance vectors metric calculated profile information obtain vector ms average similar previous analysis draw histogram illustrate distribution coordinates ms average figure 43 0 20 40 80 100 099go 124m88ks im 126gcc 129compr ess 130li 132ijpeg 134perl 147vortex107mgrid9070503010 spread coordinate ms average figure 43 spread ms average histogram clearly observe benchmarks coordinates spread across lower intervals observation provides evidence confirms claim set instructions program tend exhibit value predictability patterns form stride independent programs input parameters data therefore profiling accurately detect instructions provide information compiler 5 effect profilingbased classification valueprediction performance section focus three main aspects 1 classification accuracy mechanism 2 potential better utilize prediction table entries 3 effect extractable ilp using value prediction also compare new technique versus hardware classification mechanism saturated counters 5 1the classification accuracy quality classification process represented classification accuracy ie fraction correct classifications overall prediction attempts measured classification accuracy new mechanism compared hardwarebased mechanism classification accuracy measured incorrect correct predictions separately using stride predictor illustrated figures 51 52 respectively note two cases represent fundamental tradeoff classification operation since improving classification accuracy incorrect predictions reduce classification accuracy correct predictions vice versa measurements currently isolate effect prediction table size since subsection wish focus pure potential proposed technique successfully classify either correct incorrect value predictions hence assume classification mechanisms infinite prediction table stride predictor hardwarebased classification mechanism also maintains infinite set saturated counters effect finite prediction table presented next subsection2060100 go m88ksim gcc compress li ijpeg perl vortex mgrid average fsm prof th90 prof th80 prof th70 prof th60 prof th50 precentages mispredictions classified correctly figure 51 percentages mispredictions classified correctly2060100 go m88ksim gcc compress li ijpeg perl vortex mgrid average fsm prof th90 prof th80 prof th70 prof th60 prof th50 thepercentages correct predictions classified correctly figure 52 percentages correct predictions classified correctly observations indicate cases profilingbased classification better eliminates mispredictions comparison saturated counters threshold value classification mechanism reduced classification accuracy mispredictions decreases well since classification becomes less strict threshold value less 60 hardwarebased classification gain better classification accuracy mispredictions proposed mechanism average decreasing threshold value classification mechanisms improves detection correct predictions expense detection mispredictions figure 52 indicates cases hardwarebased classification achieves slightly better classification accuracy correct predictions comparison profilingbased classification notice observation imply hardwarebased classification outperforms profilingbased classification effect table size included measurements 5 2the effect prediction table utilization already indicated using hardwarebased classification mechanism unpredictable instructions may uselessly occupy entries prediction table purge highly predictable instructions result efficiency predictor decreased well utilization table prediction accuracy classification mechanism overcome drawback since capable detecting highly predictable instructions advance hence decreasing pollution table caused unpredictable instructions table 51 show fraction percentages potential candidates allowed allocated table classification mechanism allocated saturated counters observed even threshold value 50 new mechanism reduce number potential candidates nearly 50 moreover number reduced even significantly threshold tightened eg threshold value 90 reduces number potential candidates 75 unique capability mechanism allows us use smaller prediction table utilize efficiently profiling threshold 90 80 70 60 50 fraction potential candidates allocated relative saturated counters table 51 fraction potential candidates allocated relative hardwarebased classification order evaluate performance gain classification method comparison hardwarebased classification mechanism measured total number correct predictions total number mispredictions table size finite predictor used experiments stride predictor organized 512entry 2way set associative table addition case profilingbased classification instructions allowed allocated prediction table tagged either lastvalue stride directives results summarized figures 53 54 illustrate increase number correct predictions incorrect predictions respectively gained new mechanism relative saturated counters observed profiling threshold plays main role tuning new mechanism choosing right threshold tune mechanism way outperforms hardwarebased classification mechanism benchmarks benchmarks go gcc li perl vortex accomplish significant increase number correct predictions reduction number mispredictions instance using threshold value range 8090 vortex mechanism accomplishes correct predictions less incorrect predictions hardwareonly mechanism similar achievements also obtained go range threshold values 6090 gcc range 7090 li threshold value 60 perl range 7090 benchmarks m88ksim compress ijpeg mgrid cannot find threshold value yields increase total number correct predictions decrease number mispredictions explanation observation benchmarks employ relatively much smaller workingsets instructions therefore much less exploit benefits classification mechanism also notice mispredictions increase observed classification mechanism m88ksim expected significantly affect extractable ilp since prediction accuracy benchmark already high jr pnvl jff frpsuh ol lmshj shuo yruwh pjulg figure 53 increase total number correct predictions jr pnvl jff frpsu ol lmshj shuo yruwh pjulg figure 54 increase total number incorrect predictions 5 3the effect classification extractable ilp subsection examine ilp extracted value prediction different classification mechanisms experiments consider abstract machine finite instruction window 40 entries unlimited number execution units perfect branch prediction mechanism addition type value predictor use table organization previous subsection case valuemisprediction penalty abstract machine 1 clock cycle notice machine model explore pure potential examined mechanisms without constrained individual machine limitations experimental results summarized table 52 present increase ilp gained using value prediction different classification mechanisms relative case value prediction used benchmarks observe mechanism tuned choosing right threshold value achieve better results gained saturated counters addition also observe decreasing threshold value 90 50 ilp gained new mechanism increases cases explanation phenomenon range threshold values contribution increasing correct predictions result decreasing threshold significant effect increasing mispredictions ilp increase prof 90 prof 80 prof 70 prof prof 50 go 10 9 10 13 13 13 gcc 15 16 17 21 21 21 compress 11 7 7 8 8 8 li 37 33 35 38 38 40 ijpeg 16 14 14 15 16 15 perl 19 23 24 28 28 27 vortex 159 175 178 180 179 179 mgrid 24 7 10 11 11 11 notations prediction using saturated counters x value prediction using profilingbased classification threshold value table 52 increase ilp different classification mechanisms relative case value prediction used 6 conclusions paper introduced profilingbased technique enhance efficiency value prediction mechanisms new approach suggests using program profiling order classify instructions according tendency valuepredictable collected information profiler supplied value prediction mechanisms special directives inserted opcode instructions shown profiling information extracted previous runs program one set input parameters highly correlated future runs sets inputs observation important since reveals various opportunities involve compiler prediction process thus increase accuracy efficiency value predictor experiments also indicated profiling information distinguish different value predictability patterns lastvalue stride result use hybrid value predictor consists two prediction tables lastvalue stride prediction tables candidate instruction value prediction allocated one tables according profiling classification capability allows us exploit value predictability patterns stride lastvalue utilize prediction tables efficiently performance analysis showed profilingbased mechanism could tuned choosing right threshold value outperformed hardwareonly mechanism benchmarks many benchmarks could accomplish significant increase number correct predictions reduction number mispredictions innovation paper important future integration compiler value prediction currently working properties program identified profiler enhance performance effectiveness value prediction examining effect profiling information scheduling instruction within basic block analysis critical path addition also explore effect different programming styles object oriented value predictability patters r experiments local microcode compaction horizontal machines compiler vliw architecture optimization horizontal microcode within beyond basic blocks application processor scheduling resources speculative execution based value prediction experimental analytical study speculative execution based value prediction computer architecture quantitative approach superscalar microprocessor design software pipelining effective scheduling technique vliw processors value locality load value prediction exceeding dataflow limit via value prediction branch prediction strategies branchtarget buffer design study branch prediction techniques limits instructionlevel parallelism study scalar compilation techniques pipelined supercomputers alternative implementations twolevel adaptive branch prediction tr bulldog compiler vlsi architectures study scalar compilation techniques pipelined supercomputers software pipelining effective scheduling technique vliw machines limits instructionlevel parallelism alternative implementations twolevel adaptive branch prediction value locality load value prediction exceeding dataflow limit via value prediction computer architecture 2nd ed study branch prediction strategies optimization horizontal microcode within beyond basic blocks ctr peng chen krishna kavi robert akl performance enhancement eliminating redundant function execution proceedings 39th annual symposium simulation p143151 april 0206 2006 youtao zhang jun yang rajiv gupta frequent value locality valuecentric data cache design acm sigops operating systems review v34 n5 p150159 dec 2000 youtao zhang jun yang rajiv gupta frequent value locality valuecentric data cache design acm sigplan notices v35 n11 p150159 nov 2000 chaoying fu jill bodine thomas conte modeling value speculation optimal edge selection problem ieee transactions computers v52 n3 p277292 march jun yang rajiv gupta frequent value locality applications acm transactions embedded computing systems tecs v1 n1 p79105 november 2002 jos gonzlez antonio gonzlez potential data value speculation boost ilp proceedings 12th international conference supercomputing p2128 july 1998 melbourne australia dean tullsen john seng storageless value prediction using prior register values acm sigarch computer architecture news v27 n2 p270279 may 1999 chaoying fu matthew jennings sergei larin thomas conte value speculation scheduling high performance processors acm sigops operating systems review v32 n5 p262271 dec 1998 daniel connors wenmei w hwu compilerdirected dynamic computation reuse rationale initial results proceedings 32nd annual acmieee international symposium microarchitecture p158169 november 1618 1999 haifa israel chiahung liao jongjiann shieh exploiting speculative value reuse using value prediction australian computer science communications v24 n3 p101108 januaryfebruary 2002 mikio takeuchi hideaki komatsu toshio nakatani new speculation technique optimize floatingpoint performance preserving bitbybit reproducibility proceedings 17th annual international conference supercomputing june 2326 2003 san francisco ca usa tarun nakra rajiv gupta mary lou soffa value prediction vliw machines acm sigarch computer architecture news v27 n2 p258269 may 1999 glenn reinman brad calder dean tullsen gary tyson todd austin classifying load store instructions memory renaming proceedings 13th international conference supercomputing p399407 june 2025 1999 rhodes greece huiyang zhou jill flanagan thomas conte detecting global stride locality value streams acm sigarch computer architecture news v31 n2 may freddy gabbay avi mendelson effect instruction fetch bandwidth value prediction acm sigarch computer architecture news v26 n3 p272281 june 1998 burrows u erlingson st leung vandevoorde c waldspurger k walker w e weihl efficient flexible value sampling acm sigops operating systems review v34 n5 p160167 dec 2000 burrows u erlingson st leung vandevoorde c waldspurger k walker w e weihl efficient flexible value sampling acm sigplan notices v35 n11 p160167 nov 2000 benchung cheng daniel connors wenmei w hwu compilerdirected early loadaddress generation proceedings 31st annual acmieee international symposium microarchitecture p138147 november 1998 dallas texas united states brad calder glenn reinman dean tullsen selective value prediction acm sigarch computer architecture news v27 n2 p6474 may 1999 martin burtscher amer diwan matthias hauswirth static load classification improving value predictability datacache misses acm sigplan notices v37 n5 may 2002 freddy gabbay avi mendelson using value prediction increase power speculative execution hardware acm transactions computer systems tocs v16 n3 p234270 aug 1998 pengsheng chen yuanshin hwang roy dzching ju jenq kuen lee interprocedural probabilistic pointer analysis ieee transactions parallel distributed systems v15 n10 p893907 october 2004
data parallel language compiler support data intensive applications processing analyzing large volumes data plays increasingly important role many domains scientific research highlevel language compiler support developing applications analyze process datasets however lacking farin paper present set language extensions prototype compiler supporting highlevel objectoriented programming data intensive reduction operations multidimensional data chosen dialect java dataparallel extensions specifying collection objects parallel loop reduction variables source highlevel language compiler analyzes parallel loops optimizes processing datasets use existing runtime system called active data repository adr show loop fission followed interprocedural static program slicing used compiler extract required information runtime system present design compilerruntime interface allows compiler effectively utilize existing runtime systema prototype compiler incorporating techniques developed using titanium frontend berkeley evaluated compiler comparing performance compiler generated code hand customized adr code three templates areas digital microscopy scientific simulations experimental results show performance compiler generated versions average 21 lower cases within factor two performance hand coded versions b introduction analysis processing large multidimensional scientic datasets ie data items associated points multidimensional attribute space important component science engineering examples datasets include raw processed sensor data satellites 27 output hydrodynamics chemical transport simulations 23 archives medical images1 datasets also large example medical imaging size single digitized composite slide image high power light microscope 7gb uncompressed single large hospital process thousands slides per day applications make use multidimensional datasets becoming increasingly important share several important characteristics input output often diskresident applications may use subset data available datasets access data items described range query namely multidimensional bounding box underlying multidimensional attribute space dataset data items whose associated coordinates fall within multidimensional box retrieved processing structures applications also share common characteristics however highlevel language support currently exists developing applications process datasets paper present solution towards allowing highlevel yet ecient programming data intensive reduction operations multidimensional datasets approach use data parallel language specify computations applied portion diskresident datasets solution based upon designing prototype compiler using titanium infrastructure incorporates loop ssion slicing based techniques utilizing existing runtime system called active data repository 8 9 10 chosen dialect java expressing class computations chosen java computations target easily expressed using notion objects methods objects number projects already underway expressing parallel computations java obtaining good performance scientic applications 4 25 36 chosen dialect java includes dataparallel extensions specifying collection objects parallel loop reduction variables however approach techniques developed intended language specic overall thesis dataparallel framework provide convenient interface large multidimensional datasets resident persistent storage research supported nsf grant acr9982087 nsf grant ccr 9808522 nsf career award aci9733520 conceptually compiler design two major new ideas first shown loop ssion followed interprocedural program slicing used extracting important information general objectoriented dataparallel loops technique used compilers use runtime system optimize locality communication second shown compiler runtime system use information eciently execute data intensive reduction computations compiler extensively uses existing runtime system adr optimizing resource usage execution data intensive applications adr integrates storage retrieval processing multidimensional datasets parallel machine number applications developed using adrs lowlevel api high performance demonstrated 9 developing applications style requires detailed knowledge design adr suitable application programmers comparison proposed dataparallel extensions java enable programming data intensive applications much higher level responsibility compiler utilize services adr memory management data retrieval scheduling processes prototype compiler implemented using titanium infrastructure berkeley 36 performed experiments using three dierent data intensive application templates two based upon virtual microscope application 16 third based water contamination studies 23 templates compared performance compiler generated versions hand customized versions experiments show performance compiler generated versions average 21 lower cases within factor two performance hand coded versions present analysis factors behind lower performance current compiler suggest optimizations performed compiler future rest paper organized follows section 2 describe charactestics class data intensive applications target background information runtime system provided section 3 chosen language extensions described section 4 present compiler processing loops slicing based analysis section 5 combined compiler runtime processing execution loops presented section 6 experimental results current prototype presented section 7 compare work existing related research eorts section 8 conclude section 9 2 data intensive applications section rst describe scientic domains involve applications process large datasets describe common characteristics applications target data intensive applications three scientic areas studied currently part project analysis microscopy data virtual microscope 16 application support need interactively view process digitized data arising tissue specimens virtual microscope provides realistic digital emulation high power light microscope raw data system captured digitally scanning collections full microscope slides high power basic level emulate usual behavior physical microscope including continuously moving stage changing magnication focus used manner virtual microscope support completely digital dynamic telepathology water contamination studies environmental scientists study water quality bays estuaries using long running hydrodynamics chemical transport simulations 23 chemical transport simulation models reactions transport contaminants using uid velocity data generated hydrodynamics simulation chemical transport simulation performed dierent spatial grid hydrodynamics simulation also often uses signicantly coarser time steps facilitate coupling two simulation need mapping uid velocity information hydrodynamics grid averaged multiple negrain time steps chemical transport grid computing smoothed uid velocities points chemical transport grid satellite data processing earth scientists study earth processing remotelysensed data continuously acquired satellitebased sensors since signicant amount earth science research devoted developing correlations sensor radiometry various properties surface earth 9 typical analysis processes satellite data ten days year generates one composite images area study generating composite image requires projection globe onto two dimensional grid pixel composite image computed selecting best sensor value maps associated grid point data intensive applications related scientic areas share many common characteristics access data items described range query namely multidimensional bounding box underlying multidimensional space dataset data items whose associated coordinates fall within multidimensional box retrieved basic computation consists 1 mapping coordinates retrieved input items corresponding output items 2 aggregating way retrieved input items mapped output data items computation particular output element reduction operation ie correctness output usually depend order input data items aggregated another common characteristic applications extremely high storage computational requirements example ten years global coverage satellite data resolution four kilometers satellite data processing application titan consists 14tb data 9 virtual microscope application one focal plane single slide requires 7gb uncompressed high power hospital johns hopkins produces hundreds thousands slides per year similarly computation one ten day composite titan query entire world takes 100 seconds per processor maryland sixteen node ibm sp2 application scientists typically demand realtime responses queries therefore ecient execution extremely important 3 overview runtime system compiler eort targets existing runtime infrastructure called active data repository adr 9 integrates storage retrieval processing multidimensional datasets parallel machine give brief overview runtime system section processing data intensive dataparallel loop carried adr two phases loop planning loop execution objective loop planning determine schedule eciently process range query based amount available resources parallel machine loop plan species parts nal output computed loop execution service manages resources system carries loop plan generated loop planning service primary feature loop execution service ability integrate data retrieval processing wide variety applications achieved pushing processing operations storage manager allowing processing operations access buer used hold data arriving disk result system avoids one levels copying would needed layered architecture storage manager processing belong dierent layers dataset adr partitioned set logical disk blocks achieve high bandwidth data retrieval size logical disk block multiple size physical disk block system chosen tradeo reducing disk seek time minimizing unnecessary data transfers disk block consists one objects unit io communication processing loop processor progresses following three phases 1 initialization output disk blocks possibly replicated processors allocated space memory initialized 2 local reduction input disk blocks local disks processor retrieved aggregated output disk blocks 3 global combine necessary results computed processor phase 2 combined across processors compute nal results output disk blocks adr runtime support developed set modular services implemented c adr allows customization application specic processing ie mapping aggregation functions leveraging commonalities applications provide support common operations memory management data retrieval scheduling processing across parallel machine customization adr currently achieved class inheritance customizable services adr provides base class virtual functions expected implemented derived classes adding applicationspecic entry modular service requires denition class derived adr base class service providing appropriate implementations virtual functions current examples data intensive applications implemented adr include titan 9 satellite data processing virtual microscope 16 visualization analysis microscopy data coupling multiple simulations water contamination studies 23 4 java extensions data intensive computing section describe dialect java chosen expressing data intensive computations though propose use dialect java source language compiler techniques developing largely independent java also applicable suitable extensions languages c c fortran 90 41 dataparallel constructs borrow two concepts objectoriented parallel systems like titanium 36 hpc 5 concurrent aggregates 11 interface reducinterface f object class implementing interface reduction variable public class vmpixel f char colors3 void initialize f aggregation function void accumvmpixel apixel int avgf f public class vmpixelout extends vmpixel implements reducinterface public class vmscope f static int static int ydimen static data declarations static static static new vmpixelvmslide public static void mainstring args f int lowendsubsamp foreachp outputdomain f main computational loop foreachp querybox f fig 1 example code domains rectdomains collections objects type rect domains stricter denition sense object belonging collection coordinate associated belongs prespecied rectilinear section domain foreach loop iterates objects domain rectdomain property order iterations uence result associated computations iterations performed parallel also extend semantics foreach include possibility updates reduction variables explain later introduce java interface called reducinterface object class implementing interface acts reduction variable 18 semantics reduction variable analogous used version 20 high performance fortran hpf2 18 hpc 5 reduction variable property updated inside foreach loop series operations associative commutative furthermore intermediate value reduction variable may used within loop except selfupdates 42 example code figure 1 outlines example code chosen extensions code shows essential computation virtual microscope application 16 large digital image stored disks image thought two dimensional array collection objects element collection denotes pixel image pixel comprised three characters denote color point image interactive user supplies two important pieces information rst bounding box within two dimensional box implies area within original image user interested scanning assume bounding box rectangular specied providing x coordinates two points rst 4 arguments provided user integers together specify points lowend hiend second information provided user subsampling factor integer denoted subsamp subsampling factor tells granularity user interested viewing image subsampling factor 1 means pixels original image must displayed subsampling factor n means n 2 pixels averaged compute output pixel computation kernel simple first querybox created using specied points lowend hiend pixel original image falls within querybox read used increment value corresponding output pixel several advantages associated specifying analysis processing multidimensional datasets fashion programs specify computations assuming single processor memory also assumes data available arrays object references persistent storage responsibility compiler runtime system locate individual elements arrays disks also responsibility compiler invoke runtime system optimizing resource usage 43 restrictions loops primary goal compiler analyze optimize performing compiletime transformations generating code adr runtime system foreach loops satisfy certain properties assume standard semantics parallel loops reductions languages like high performance fortran hpf 18 hpc 5 require java threads spawned within loop nests memory locations read written inside loop nests may touched another concurrent thread compiler also assume java exceptions raised loop nests iterations loop reordered without changing language semantics one potential way enabling use bound checking optimizations 25 5 compiler analysis section rst describe compiler processes given dataparallel data intensive loop canonical form describe interprocedural program slicing used extracting number functions passed runtime system 51 initial processing loop consider dataparallel loop dialect java presented section 4 memory locations modied loop elements collection objects temporary variables whose values used iterations loop subsequent computations memory locations accessed loop either elements collections values may replicated processors start execution loop purpose discussion collections objects whose elements modied loop referred left hand side lhs collections collections whose elements read loop considered right hand side rhs collections functions used access elements collections objects loop referred subscript functions denition 1 consider two lhs collections two rhs collections two collections called congruent subscript functions used access two collections loop identical layout partitioning two collections identical identical layout mean elements identical indices put together disk block collections identical partitioning mean disk blocks containing elements identical indices collections reside processor consider loop multiple distinct subscript functions used access rhs collections lhs collections subscript functions known compiletime tiling output managing disk accesses maintaining high reuse locality going dicult task runtime system particular current implementation adr support cases therefore perform loop ssion divide original loop set loops lhs collections new loop congruent rhs collections congruent describe loop ssion performed initially focus lhs collections updated dierent statements loop perform loop ssion lhs collections accessed new loop congruent since focusing loops loopcarried dependencies performing loop ssion straightforward example transformation shown figure 2 part focus new loop lhs collections congruent rhs collections may congruent two rhs accesses loop congruent three possibilities 1 two collections used calculating values elements dierent lhs collections case loop ssion performed trivially 2 two collections z used calculating values elements lhs collection lhs collection x however computed follows op op j case loop ssion performed element xfi updated using operation op values gi zhi dierent loops example transformation shown figure 2 part b 3 two collections z used calculating values elements lhs collection unlike case operations used identical example case case need introduce temporary collection objects copy collection z collection temporary collection accessed using subscript function example transformation shown figure 2 part c series loop ssion transformations original loop replaced series loops property loop lhs collections accessed subscript function rhs collections also accessed subscript function however subscript function accessing lhs collections may dierent one used access rhs collections foreach p box f foreach p box f foreach p box f b foreach p box f foreach p box f foreach p box f c foreach p box f foreach p box f foreach p box f fig 2 examples loop fission transformations 1 l r op om l r op fig 3 loop canonical form 511 discussion strategy performing loop ssion lhs collections accessed subscript function rhs collections accessed subscript function clearly best suited classes applications particularly stencil computations may result several accesses disk block however class data intensive reductions focused strategy works extremely well simplies later loop execution future incorporate techniques parallel database join operations loop execution alleviate need performing loop ssion cases 512 terminology loop ssion focus one individual loop time introduce notation loop used presenting solution terminology presented illustrated example loop figure 3 domain iterator iterates denoted r let n rhs collection objects read loop denoted similarly let lhs collections written loop denoted denote subscript function used accessing right hand side collections sr subscript function used accessing left hand side collections l int fig 4 slice subscript function left aggregation function right given point r range loop elements l r output collections updated using one values 1 scalar values program denote function used creating value used later updating element output collection operator used performing update op 52 slicing based interprocedural analysis primarily concerned extracting three sets functions range function r subscript functions sr l aggregation functions similar information often extracted various dataparallel fortran compilers one important dierence working objectoriented language java signicantly dicult ana lyze mainly objectoriented programming methodology frequently leads small procedures frequent procedure calls result analysis across multiple procedures may required order extract range subscript aggregation functions use technique interprocedural program slicing extracting three sets functions initially give background information program slicing give references show program slicing performed across procedure boundaries presence language features like polymorphism aliases exceptions 521 background program slicing basic denition program slice follows given slicing criterion x program point program x variable program slice subset statements programs statements executed input produce value variable x program point original program basic idea behind algorithm computing program slices follows starting statement p program trace statements p data control dependent add slice repeated statement already included slice statements added slice adr pt outpoint2 adr pt lowend2 int return outpoint void accumulateadr box current block adr box current tile adr box querybox f current blockintersectquerybox adr pt inputpt2 adr pt outputpt2 int projectinputpt outputpt current tile f outputoutputptaccumvscopeinputpt fig 5 compiler generated subscript aggregation functions slicing frequently used software development environments debugging program analysis merging two dierent versions code software maintenance testing number techniques presented accurate program slicing across procedure boundaries 32 since objectoriented languages frequently used developing production level software signicant attention paid towards developing slicing techniques presence objectoriented features like object references polymorphism recently java features like threads exceptions harrold et al tonnela et al particularly focused slicing presence polymorphism object references exceptions 17 28 slicing presence aliases reference types also addressed 3 522 extracting range function need determine rhs lhs collection objects loop also need provide range function r rhs lhs collection objects computed easily inspecting assignment statements inside loop functions called inside loop collection modied loop considered lhs collection collection touched loop considered rhs collection computing domain inspect foreach loop look domain loop iterates compute slice program using entry loop program point domain variable 523 extracting subscript functions subscript functions sr l particularly important runtime system determines size lhs collections written loop rhs disk blocks collection contributes lhs collections function l extracted using slicing follows consider statement loop modies lhs collection focus variable expression used access element lhs collection slicing criterion choose value variable expression beginning statement lhs collection modied function sr extracted similarly consider statement loop reads rhs collection slicing criterion use value expression used access collection beginning statement typically value iterator included slices suppose iterator p rst encountering p slice follow datadependencies p instead functions returned slice use iterator input parameter virtual microscope template presented figure 1 slice computed subscript function l shown left hand side figure 4 code generated compiler shown left hand side figure 5 original source code rhs collection accessed iterator therefore subscript function sr identity function function receives coordinates element rhs collection parameter iterpt runtime system returns coordinates corresponding lhs element titanium multidimensional points supported adr class named adr pt also practice command line parameters passed program extracted stored datastructure runtime system need explicitly read args array 524 extracting aggregation functions extracting aggregation function look statement loop lhs collection modied slicing criterion choose value element collection modied statement beginning statement virtual microscope template presented figure 1 one aggregation function slice aggregation function shown figure 4 actual code generated compiler shown figure 5 function accum accessed code obviously part slice shown generated function iterates elements disk block applies aggregation functions element element intersects range loop current tile function presented parameter current block disk block processed current tile portion lhs collection currently allocated memory querybox iteration range loop titanium rectangular domains supported runtime adr box details aggregation function explained presenting combined compilerruntime loop processing 6 combined compiler runtime processing section explain compiler runtime system work jointly towards performing data intensive computations 61 initial processing input system stores information rhs collections objects stored across disks note apply loop ssion rhs collections accessed loop identical layout partitioning compiler generates appropriate adr functions analyze metadata collections range function r subscript function sr compute list disk blocks accessed loop domain rhs collection accessed loop sr r note disk block included list necessary elements disk block accessed loop however initial planning phase focus list disk blocks assume model parallel data intensive computation set disks associated node parallel machine consistent systems like ibm sp cluster workstations let set denote list processors system information computed runtime system analyzing range function input subscript function metadata collections objects given input collection processor set disk blocks b contain data collection resident disk connected processor intersects sr r disk block b ijk belonging set b ij compute information db ijk denotes subset domain sr r resident disk block b clearly union domains covered selected disk blocks cover entire area interest formal terms 62 work partitioning one issues processing loop parallel work iteration parti tioning ie deciding iterations executed processor work distribution policy use iteration performed owner element read iteration policy opposite owner computes policy 19 commonly used distributed memory compilers owner lhs element works iteration rationale behind approach system communicate blocks rhs collections instead replicated elements lhs collections need communicated complete computation note assumptions nature loops placed requires replacing initial loop sequence canonical loops may also increase net communication processors however consider problem set applications target 63 allocating output buers strip mining distribution rhs collections decided performing processing decided partition iterations accordingly need allocate buers accumulate local contributions nal lhs objects use runtime analysis determine elements output collections updated iterations performed given processor runtime analysis similar one performed runtime libraries executing irregular applications distributed memory machines element updated one processor initially replicated processors updated several dierent strategies allocation buers studies context runtime system 9 selecting among dierent strategies compiler generated code topic future research memory requirements replicated output space typically higher available memory processor therefore need divide replicated output buer chunks allocated main memory processor issue strip mining tiling used improving cache performance far used simple strip mining strategy query runtime system determine available memory allocated given processor divide lhs space blocks size formally divide lhs domain l r set smaller domains called strips fs 1 g since lhs collection objects loop accessed subscript function strip mining done performing computations processor iterate set strips allocate strip n output collections compute local contributions strip allocating next strip facilitate compute set rhs disk blocks contribute strip lhs 64 mapping input output use subscript functions sr l computing set rhs disk blocks contribute strip lhs indicated apply function l 1 r db ijk obtain corresponding domain lhs region output domains disk block contribute towards denoted odb ijk db ijk rectangular domain subscript functions monotonic odb ijk rectangular domain easily computed applying subscript function two extreme corners case subscript function needs applied element db ijk resulting odb ijk domain rectangular domain formally compute sets l jl processor j output strip l 65 actual execution computation sets l il marks end loop planning phase runtime system using information actual computations performed processor structure computation shown figure 6 practice computation associated rhs disk block retrieval disk blocks overlapped using asynchronous io operations explain aggregation function generated compiler virtual microscope template presented figure 1 shown figure 5 right hand side accumulation function output compiler captures foreach element part loop execution model shown figure 6 output strip l execute processor allocate initialize strip l foreach read blocks b ijk disks foreach element e db ijk output pt intersects l evaluate functions global reduction nalize values l fig 6 loop execution processor runtime system computes sets l jl explained previously invokes aggregation function loop iterates disk block set current compiler generated code computes rectangular domain db ijk invocation aggregation function intersection current block query block resulting rectangular domain denoted box aggregation function iterates elements box conditional project achieves two goals first applies subscript functions determine lhs element outputpt corresponding rhs element inputpt second checks outputpt belongs current tile actual aggregation applied outputpt belongs current tile test represents signicant source ineciency compiler generated code tile strip currently processed represents rectangular rhs region subscript functions monotonic intersection box tile performed inner loop fact done hand customization adr virtual microscope 16 performing optimization automatically topic future research beyond scope current work 7 current implementation experimental results section describe features current compiler present experimental results comparing performance compiler generated customization three codes hand customized versions compiler implemented using publicly available titanium infrastructure berkeley 36 current compiler runtime system implement subset analysis processing techniques described paper two key limitations follows process codes rhs subscript function identity function also requires domain loop iterates rectangular domain subscript functions monotonic titanium language explicitly parallel dialect java numerical computing could use titanium frontend without performing modications titanium language includes point rectdomain foreach loop required purposes concept reducinterface part titanium language modications parser required purpose titanium also includes large number additional directives require signicantly dierent semantics foreach loops used three templates experiments vmscope1 identical code presented figure 1 models virtual microscope provides realistic digital emulation microscope allowing users specify rectangular window subsampling factor version vmscope1 averages colors neighboring pixels create pixel output image vmscope2 similar vmscope1 except one important dierence instead taking average pixels picks every subsamp th element along dimension create nal output image thus memory accesses copying involved template computations performed bess models computations associated water contamination studies bays estuaries computation performed application determines transport contaminants accesses large uid velocity datasets generated previous simulation virtual microscope averaging103050701 2 4 8 processors execution time compiled original fig 7 comparison compiler hand generated versions vmscope1 three templates represent data intensive applications two important domains digital microscopy scientic simulations computations data accesses associated computations relatively simple handled current prototype compiler moreover access hand coded adr customization three templates allowed us compare performance compiler generated versions hand coded versions whose performance reported previously published work 16 23 experiments performed using adr runtime system ported cluster dual processor 400 mhz intel pentium nodes connected gigabit ethernet node 256mb main memory gb internal disk experiments performed using 1 2 4 8 nodes cluster adr runtime systems current design assumes shared nothing architecture exploit multiple cpus node therefore one processor node used experiments results comparing performance compiler generated hand customized vmscope1 shown figure 7 microscope image 19 760 15 360 pixels used since pixel application takes 3 bytes total 910 mb required storage image query bounding box size 10 00010 000 subsampling factor 8 used time taken compiler generated version ranged 73 seconds 1 processor 13 seconds 8 processors speedup 2 4 8 processors 186 332 546 respectively time taken hand coded version ranged 68 seconds 1 processor 83 seconds 8 processors speedup 2 4 8 processors 203 409 82 respectively since code largely io memory bound slightly better linear speedup possible performance compiler generated code lower 7 10 25 38 1 2 4 8 processors respectively data see performance compiler generated code close hand coded one 1 processor case substantially lower 8 processor case carefully compared compiler generated hand coded versions understand performance factors two codes use dierent tiling strategies lhs collections hand coded version irregular strategy used ensures input disk block maps entirely single tile compiler version simple regular tiling used input disk block map multiple tiles shown figure 5 compiler generated code performs additional check iteration determine lhs element intersects tile currently processed comparison tiling strategy used hand coded version ensures check always returns true therefore need inserted code irregular tiling strategy irregular mapping required bounding box associated disk block actual coordinates allocated output tile mapping needs carried rhs disk block read memory time required performing mapping proportional number rhs disk blocks processed processor tile since output dataset actually quite small experiments number rhs disk blocks processed processor per tile decreases go larger congurations result time required extra processing reduces comparison percentage overhead associated extra checks iteration performed compiler generated version remains unchanged dierence explains compiler generated code slower hand coded one dierence performance increases go larger number processors virtual microscope subsampling103050 processors execution time compiled original fig 8 comparison compiler hand generated versions vmscope2 results comparing performance compiler generated hand coded vmscope2 shown figure 8 code executed dataset query used vmscope1 time taken compiler generated version ranged 44 seconds 1 processor 9 seconds 1 processor hand coded version took 47 seconds 1 processor nearly 5 seconds 8 processors speedup compiler generated version 203 331 488 2 4 8 processors respectively speedup hand coded version 238 498 100 2 4 8 processors respectively number important observations made first though query executed vmscope1 vmscope2 templates execution times lower vmscope2 clearly computations performed vmscope2 however factor less two dierence execution times shows codes memory io bound even vmscope1 computation time dominate speedups hand coded version vmscope2 higher clearly code io memory bound performance compiler generated version better 6 1 processor lower 10 2 processors 29 4 processors 48 8 processors dierence performance dierence tiling strategies used explained previously since template perform computations dierence conditionals extra processing disk block signicant eect overall performance 1 processor case additional processing required disk block becomes high compiler generated version slightly faster note hand coded version developed optimized execution parallel systems therefore highly tuned sequential case 8 processor case extra cost conditional iteration becomes dominant compiler generated version therefore compiler generated version almost factor 2 slower hand coded one bays estuaries simulation system2060100140 processors execution time compiled original fig 9 comparison compiler hand generated versions bess results comparing performance compiler generated hand coded version bess shown figure 9 dataset comprises grid 2113 elements 46080 timesteps timestep 4 4byte oating point numbers per grid element denoting simulated hydrodynamics parameters previously computed therefore memory requirements dataset 16 gb bess template experimented performed weighted averaging 4 values column specied number timesteps number timesteps used experiments 30000 execution times compiler generated version ranged 131 seconds 1 processor 11 seconds 8 processors speedup 2 4 8 processors 198 553 1175 respectively execution times hand coded version ranged 97 seconds 1 processor 9 seconds 8 processors speedup 2 4 8 processors 18 54 107 respectively compiler generated version slower factor 25 19 24 19 1 2 4 8 processors respectively discuss factors behind dierence performance compiler generated hand coded bess versions vmscope versions compiler generated bess performs checks intersecting tile pixel output application small result hand coded version explicitly assumes single output tile compiler generated version cannot make assumption still inserts conditionals amount computation associated iteration much higher application therefore percentage overhead extra test large vmscope templates second important dierence compiler generated hand coded versions averaging done compiler generated code value added rst divided total number values added comparison hand coded version performs summation values rst performs single division percentage overhead independent number processors used believe second factor dominant reason dierence performance two versions also explains percentage dierence performance remains unchanged number processors increased performance compiler generated code improved performing standard strength reduction optimization however compiler needs perform optimization interprocedurally topic future work average three templates 1 2 4 8 processor congu rations compiler generated versions 21 slower hand coded ones considering high programming eort involved managing optimizing disk accesses computations parallel machine believe 21 slowdown automatically generated code acceptable application developers also noted previous work area outofcore data intensive compilation focused evaluating eectiveness optimizations comparisons hand coded versions analysis performance dierences compiler generated hand coded versions pointed us number directions future research first need consider sophisticated tiling strategies avoid large performance penalties associated performing extra tests loop ex ecution second need consider advanced optimizations like interprocedural code motion interprocedural strength reduction improve performance compiler generated code 8 related work work providing highlevel support data intensive computing considered developing outofcore java compiler compiler optimizations improving io accesses considered several projects passion project northwestern university considered several dierent optimizations improving locality outofcore applications 6 20 optimizations also implemented part fortran compilation systems support outofcore applications 29 mowry et al shown compiler generate prefetching hints improving performance virtual memory system 26 projects concentrated relatively simple stencil computations written fortran besides use objectoriented language work signicantly dierent class applications focus techniques executions loops particularly targeted towards reduction operations whereas previous work concentrated stencil computations slicing based information extraction runtime system allows us handle applications require complex data distributions across processors disks limited information access patterns may known compiletime many researchers developed aggressive optimization techniques java targeted parallel scientic computations javar javab compilation systems targeting parallel computing using java 4 dataparallel extensions java considered least two projects titanium 36 hp java 7 loop transformations techniques removing redundant array bounds checking developed 12 25 eort also unique considering persistent storage complex distributions data processors disks use sophisticated runtime system optimizing resources objectoriented dataparallel compilation projects also considered data residing persistent storage 5 11 30 program slicing actively used many software engineering applications like program based testing regression testing debugging software maintenance last two decades 34 area parallel compi lation slicing used communication optimizations pugh rosser 31 transforming multiple levels indirection das saltz 15 aware previous work using program slicing extracting information runtime system several research projects focused parallelizing irregular applications computational uid dynamics codes irregular meshes sparse matrix computations research demonstrated developing runtime libraries compiler analysis place runtime calls irregular codes compiled ecient execution 2 21 24 35 project related eorts sense compiler also heavily uses runtime system however project also signicantly dierent language need handle aliases object references applications involve disks accesses persistent storage runtime system need interface works dierently several runtime support libraries le systems developed support ecient io parallel environment 13 14 22 33 also usually provide collective io interface processing nodes cooperate make single large io request work dierent two important ways first supporting much higher level programming involving compiler second target runtime system adr also diers systems several ways computation integral part adr framework collective io interfaces provided many parallel io systems data processing usually cannot begin entire collective io operation completes also data placement algorithms optimized range queries also integrated part adr framework 9 conclusions paper addressed problem expressing data intensive computations highlevel language compiling codes eciently manage data retrieval processing parallel machine developed dataparallel extensions java expressing important class applications using extensions programmers specify computations assuming single processor memory conceptually compiler design two major new ideas first shown loop ssion followed interprocedural program slicing used extracting important information general objectoriented dataparallel loops technique used compilers use runtime system optimize locality communication second shown compiler runtime system use information eciently execute data intensive reduction computations technique processing loops independent source language techniques implemented prototype compiler built using titanium frontend used three templates areas digital microscopy scientic simulations evaluating performance compiler compared performance compiler generated code performance codes developed customizing runtime system adr manually experiments shown performance compiler generated codes average 21 slower hand coded ones cases within factor 2 believe results establish approach eective considering high programming eort involved managing optimizing disk accesses computation parallel machine believe 21 slowdown automatically generated code acceptable application developers also noted previous work area outofcore data intensive compilation focused evaluating eect optimizations comparisons hand coded versions believe considering sophisticated tiling strategies optimizations like interprocedural code motion strength reduction performance compiler generated codes improved acknowledgments grateful chialin chang anurag acharya tahsin kurc alan sussman members adr team developing runtime system developing hand customized versions applications helping us ex periments many fruitful discussions course work r angelo de marzo interprocedural compilation irregular applications distributed memory machines prototype java restructing compiler distributed pc model compilation strategy outofcore data parallel programs customizable parallel database multidimensional data infrastructure building parallel database systems multidimensional data alan suss man concurrent aggregates ca vesta parallel inputoutput characteristics scalable parallel applications paul havlak virtual microscope high performance fortran forum compiling fortran mimd distributedmemory machines improving performance outofcore computations compiling global namespace parallel loops distributed execution coupling multiple simulations via high performance customizable database system exploiting spatial regularity irregular iterative applications automatic compilerinserted io prefetching outofcore applications nasa goddard distributed active archive center daac compiler support outof core arrays parallel machines objectoriented languages iteration space slicing application communication optimization speeding slicing survey program slicing techniques tr dynamic slicing presence unconstrained pointers compiling fortran mimd distributedmemory machines objectoriented languages speeding slicing model compilation strategy outofcore data parallel programs interprocedural compilation irregular applications distributed memory machines inputoutput characteristics scalable parallel applications index array flattening program transformation vesta parallel file system automatic compilerinserted io prefetching outofcore applications flow insensitive c pointers polymorphism analysis application slicing iteration space slicing application communication optimization reusedriven interprocedural slicing concurrent aggregates ca passion distributed memory compiler design sparse problems compiling global namespace parallel loops distributed execution titan improving performance outofcore computations infrastructure building parallel database systems multidimensional data exploiting spatial regularity irregular iterative applications compiler support outofcore arrays parallel machines
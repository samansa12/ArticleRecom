truby design system paper describes truby system designing vlsi circuits starting formal specifications described terms relational abstractions behaviour design process involves correctnesspreserving transformations based proved equivalences relations together addition constraints class implementable relations defined tool enables relations simulated translated circuit description vhdl design process illustrated derivation circuit 2dimensional convolution b introduction paper describes computerbased system known truby 12 designing vlsi circuits starting highlevel mathematical specification behaviour circuit described binary relation appropriate possibly complex domains values simple relations composed complex ones use variety combining forms higherorder functions basic relations combining forms generate algebra defines equivalences may take form equalities conditional equalities relational expressions terms circuits equivalence describes general correctness preserving transformation whole family circuits particular form design process equivalences exploited transform specification form one ruby expression implementation form another ruby expression calculationoriented style 4 9 13 truby based formalisation ruby originally introduced jones sheeran 3 language functions relations refer truby language purpose paper demonstrate general language used bridge gap purely mathematical specification implementable circuit design circuit 2dimensional convolution used illustrate features method particular step given mathematical specification initial ruby description small obvious method allows us derive generic circuits choice details postponed final actual synthesis truby system enables user perform desired transformations course design simulate behaviour resulting relation translate final ruby description relation vhdl description corresponding circuit subsequent synthesis highlevel synthesis tool transformational style design ensures correctness final circuit respect initial specification assuming equivalences used correct proofs correctness performed help separate theorem prover simple interface truby proof burdens passed prover proved equivalences passed back inclusion trubys database division system main trubysystem theorem prover vhdl translator followed divide conquer philosophy theorem proving tedious often needs specialists system designer use proved transformation rules computationally relatively cheap truby system leaving proofs specific rules conditions theorem prover certain level concretisaion reached efficient tools already exist synthesise circuits therefore chosen translate relational descriptions vhdl ruby work described paper based socalled pure ruby subset ruby introduced rossen 10 makes use observation large class relations useful describing vlsi circuits expressed terms four basic elements two relations two combining forms usually defined terms synchronous streams data shown figure 1 figure 1 basic elements pure ruby figure type sigt type streams values type usually represented function type z identify z time notation arb means related b r synonymous b 2 r relation spread f lifting streams pointwise relation r type ff fi whose characteristic function f type ff f b true r type spread f sigff sigfi type relations streams type ff streams type fi notational convenience stress idea describes lifting streams pointwise relation type ff fi type denoted ff sig thus spread f suitable f describes synchronously clocked combinational circuit relation socalled delay element describes basic sequential circuit f g backward relational composition f g describes serial composition circuit described f described g f type ff sig fl g type fl sig fi type ff sig fi finally f g relational product f g describes parallel composition f g f type sig sig type ff 1 theta ff 2 sig types relations describe types signals passing interface circuit environment however important note relational description specify direction data passes interface input output mixed domain range r ff fi b c f g figure 2 graphical interpretations feature ruby relations combinators interpretation terms circuit elements also natural graphical interpretation corresponding abstract floorplan circuits describe conventional graphical interpretation spread fact circuit whose internal details wish show labelled rectangular box components domain range drawn wire stubs whose number reflects types relations obvious manner simple type gives single stub pair type two components domain drawn left hand side components range right conventional graphical interpretation dshaped figure domain flat side range rounded side f g drawn range f plugged domain g f two circuits f g parallel unconnected conventions illustrated figure 2 details see 3 3 truby language truby circuits combinators defined terms four pure ruby elements using syntax style typed lambda calculus definitions circuits combinators types given figure 3 ff fi denote type variables thus stand type first five definitions nonparameterised stream relations correspond circuits defined using spread element applied function evaluates true z equals sum x pointwise relates two integers sum polymorphic identity relation dub pointwise relates value pair copies value reorg pointwise relates two ways grouping three values pairs describe combinational circuits except describe patterns wiring known wiring relations fifth sumspec describes simple sequential circuit adding machine accumulator register remaining definitions examples combinators always one parameters typically describing circuits combined applying combinator suitable arguments gives circuit thus fst r circuit described r r l combinator l written infix operator circuit r second component domain r connected first component range definition l elsewhere r 1 denotes inverse relation r graphical interpretations fst l shown figure 4 dialect ruby used truby system essentially given rossen 8 differs standard version ruby given jones sheeran 3 repetitive combinators wiring relations parameterised number repetitions reflected type system includes dependent product types 5 generalisation normal function types enable us explicitly express size repetive structures type system example combinator map maps relation elements list streams polymorphic dependent type nlistnt type lists exactly n elements type thus map function takes integer n relation type ff sig fi arguments int theta int sig int ff sig dub ff sig dub 4 reorg ff theta fi theta fl sig int theta control sig bool theta int loop4 fst snd alu snd dub fst sig fst 4 sig l ff theta fi sig sig sig l 4 fst r sig sig sig sig sig else fst apr n1 sig sig sig figure 3 examples circuit combinator definitions truby fst r r l map 3 r tri 3 r colf 3 r rdrf 3 r r r r r r r figure 4 graphical interpretation combinators returns relation whose type nlistnff sig nlistnfi dependent n socalled pi bound variable full description truby type system found 11 relation apr n used definition map pointwise relates nlist values single value n 1list single value appended right nlist 1 combinator mapf similar map second parameter function integers relations relation used depend position structure creates triangular circuit structure colf column structure relation parametrised position column finally rdrf called reduce right kind column structure name functional programming example used relation argument calculate sum list integers graphical interpretations repetitive combinators shown figure 4 note definitions given pointfree notation reflecting fact expressed terms elements pure ruby easy show equivalent expected definitions using data values example however defining circuits terms pure ruby elements offers several advantages greatly simplifies definition use general rewrite rules simplifies reasoning circuits theorem prover eases task translating language traditional vlsi specification language vhdl 4 transformational phase truby design design process truby involves three main activities reflecting overall design system 1 transformation 2 proof 3 translation vhdl section consider first phase involves transforming initial specification rewriting possibly addition typing timing constraints approach implementable design described ruby relation 1 note size argument n elsewhere written subscript improve readibility 41 rewriting rewriting essential feature calculational style design used ruby truby system allows user rewrite ruby expressions according predefined rewrite rules rewriting takes place interactive manner directed user using basic rewrite functions known tactics combined use higher order functions known tacticals style system often called transformation system distinguish conventional rewrite system truby implemented functional programming language standard ml sml offers interactive user environment tactics tacticals sml functions applied environment truby system rewrite rule expression form equality implication two equalities explicit typed universal quantification term variables cases implicit universal quantification types via use type variables apart restrictions forms rules may used practice however commonly used rules equalities relational expressions corresponding equivalences circuits used manipulate circuit description ruby another equivalent form rules manipulating integer boolean expressions could course also introduced manipulations performed automatically builtin expression simplifier based traditional rewriting normal form examples rules seen figure 5 first rules express simple facts combinators commutativity fst snd fstsndcomm fact inverse serial composition backward composition inverses inversecomp distributivity fst serial composition fstcompdist fourth rule maptricomm example conditional rule precondition r commute serial composition must fulfilled order tri n r map n commute similarly forkmap states r functional relation single copy domain side nway fork equivalent n copies range side fork finally rules retimecol used ruby synthesis express timing features inputoutput equivalence circuit systolic version circuit note since rules contain universal quantifications relations particular types essentially express general properties whole families circuits truby system directed rules used rewriting come three sources may explicit rewrite rule definitions implicit definitions derived circuit combinator definitions permit named circuit combinator replaced definition viceversa lemmata derived previous rewrite processes established equality two expressions say 0 truby correctness explicit rules proved use tool 7 based isabelle theorem prover 6 using axiomatisation ruby within zf set theory make life easier user conjectured rewrite rules however entered without proved rewriting finished unproved rewrite rules printed together instantiated conditions conditional rules form proof obligation user must transfer theorem prover order ensure soundness rewriting process fstsndcomm sig sig sig sig r fstcompdist 4 sig sig fst r sig sig r sig r retimecol sig col figure 5 rewrite rules truby 42 constraints transformation process truby system primarily involves rewriting expressions described however rewriting produce relations exactly equivalent original abstract specification relations often large restricted obtain implementable circuit trivial exam ple relation described defined type int theta int sig int implementation purposes want restrict integers values representable finite number bits mathematical point view means restricting relation subtype given int n1 int n subtype integers representable n bits truby describe subtyping adding relational constraints 13 expression initial specifi bint n int n nbit nbit n1bit int n1 int int int int n int n1 b id n1 int n c bits figure adding constraints relation cation depicted figure 6a narrow type adding relational constraints domain range case instantantions id n identity relation integers representable n bits defined id n bits n bits n bits n relates integer list n bits represent constrained relation shown figure 6b definition id n expanded giving bits shown figure 6c relations bits n manipulated original relation using general rewrite rules another style constraint add delay elements domain range relation since ruby relations relate streams data element stream corresponds specific time instant changes timing properties circuit simple example relation defined figure 3 describes purely combinational circuit adding n delay elements range side would give specification adder total delay n time units use general relational rewrite rules push delay elements combinational part thus obtaining description adder external timing properties different internal arrangement registers style manipulation illustrated detail convolution example following section note relational framework used describe manipulate type timing constraints interesting variation mix two methods example adding relational specification bitserial integer converter constraint domain side inverse range side obtain specification bitserial adder manipulate get implementable circuit finally specification constrained instantiation free type term variables free term variables typically used describe otherwise unspecified circuit elements give size regular structures generic manner instantiation obtain description specialised circuit particular circuit element particular dimensions general transformation process starts relational specification spec circuit suitably high level abstraction spec rewritten number equality rewrites order reach implementable description rewrite process relation narrowed adding relational constraints process illustrated series transformations primes denote added constraints original specification changed accordingly spec spec 000 reflecting addition constraints ensuring equality impl final constrained specification logical point view 15 constraints regarded assumptions implementation fulfills original specification constraints impl spec 43 example 2dimensional convolution example tranformation process present part design vlsi circuit 2dimensional discrete convolution mathematical definition known convolution kernel stream values new stream values c evaluated r r intuition behind stream represents sequence rows length w value c weighted sum corresponding value astream neighbours distance sigmar two dimensions using weights given matrix k commonly used image processing stream pixel values scanned rowwise sequence images k describes kind smoothing weighting function note summation j equal 1dimensional convolution th row k time offset w 1dimensional convolution defined r 431 formulating problem ruby first step design process formulate mathematical definitions ruby following style design used correlator 3 divide relation c combinational part relates cvalues given time 0 values time convenience let summation run 1 applying substitution new temporal part relates 0 values time original avalues 0 temporal part matrix 0 split parts easily specified directly ruby first given find relation relates b 1list 0 1 offset dependent position j 0 ruby specified stating 00 0 related tri 2r1 2 2r 1way fork 00 specified 000 00 3 fixed offset 000 specified b 4 assembling 13 get b 0 next find relation relating 2r 1list b 1 offset dependent position b 0 specified b 2 2r 1way fork b 00 specified b 3 another fixed offset b 000 specified b 000 4 assembling 13 get b 0 convenient rewrite two relations two 4 follows b 0 butterfly 2r1 5 b 0 butterfly 2r1 w combinator butterfly defined sig app n1n fst irt n1 r combinational part convolution relation easily expressed ruby terms combinator q type int int theta int sig int q relates x k ij x expresses convolution kernel function position within matrix k define c easy demonstrate arbitrary x 0 x related c ruby relation rdrf 2r1 q rdrf defined figure 3 combining temporal relations given definitions 5 6 find entire 2dimensional convolution relation cr 2 relates x given w r x q expressed terms onedimensional convolution relation cr 1 relates b 0 int theta int sig butterfly r rdrf 2r1 q int theta int sig int cr 2 fst fork butterfly r w cr 1 corresponds inner summation j specification graphical interpretation cr 2 shown left figure 7 interpretation cr right butterflies contain increasing numbers delay elements midline increasing numbers antidelay elements 1 midline follows definitions small butterflies use single delay elements corresponding time difference consecutive elements data stream large butterflies use groups w delay elements corresponding time difference consecutive lines data stream define relations truby convenient parameterise become combinators dependent r w q final definitions int theta int sig fst fork butterfly r rdrf 2r1 q int theta int sig fst fork butterfly r w definitions actual circuit 2dimensional convolution described relation conv2 r w q suitable values r w q figure 7 two dimensional convolution 432 transformation implementable relation unfortunately relation given describe physically implementable circuit assume implicitly done inputs appear domain relation x outputs range c antidelays 1 butterflies instead trying implement relation conv2 r w q stands implement retimed version formed adding constraint domain side delays input signals fst r w result antidelays cancelled delay elements constraint moved inwards original relation resulting circuit course produce outputs r units later original circuit best achieve physical world live use series rewrite rules manipulate relation obviously implementable form output truby system derivation shown annotated somewhat abbreviated form figure 8 concrete syntax produced truby prettyprinter free variables preceded sign repeated composition r n denoted rn relational inverse r 1 r xtb denotes expression variable x type body b derivation finishes relational expression fst fork 2r1 generic description convolution circuit expressed terms three free variables r w corresponding respectively kernel size convolution line size 2dimensional array points convoluted q gives kernel function obtain description particular concrete circuit use ruby systems facilities instantiating free variables particular values definition conv2g fst drdwrfst fork 2r1butterfly r dw 2 fstcompdist used right leftg fst drdwrfork 2r1butterfly r dw use rule forkmapg fst fork 2r1map 2r1 drdwrbutterfly r dw butterfly fst fork 2r1map 2r1 drtri 2r1 dw frule maptricomm rule fstcompdistg fst fork 2r1fst tri 2r1 dwfst map 2r1 dr fst fork 2r1fst tri 2r1 dw kintfst dr iintconv1 r q k definition conv1g fst fork 2r1fst tri 2r1 dw kintfst drfst fork 2r1butterfly r fnow use similar procedure remove remaining butterflyg fst fork 2r1fst tri 2r1 dw kintfst fork 2r1fst tri 2r1 using definition fst use tri n fst fork 2r1fst tri 2r1 dw kintfst fork 2r1snd d2r1 fst fork 2r1fst tri 2r1 dw kintfst fork 2r1snd d2r1 another constraint domain side snd w snd dw2r1fst fork 2r1fst tri 2r1 dw kintfst fork 2r1snd d2r1 frule fstsndcomm fst r fst fork 2r1tri 2r1 dwdw2r1 kintfst fork 2r1snd d2r1 fst fork 2r1 rdrf 2r1 kintsnd dwfst fork 2r1snd d2r1 fst fork 2r1 kintfst fork 2r1snd dwd2r1 gamman g fst fork 2r1 kintfst fork 2r1snd dw 2r1 figure 8 derivation 2dimensional convolution relation example might instantiate r 2 w 64 q acc 4 describes multiplyandadd circuit multiplication factor kernel element described q use factor weight accumulating weighted sum suitable reduction integer expressions would give us relational description fst fork 5 free variables graphical interpretation final version circuit shown figure 9 seen figure circuit semisystolic latchc z figure 9 semisystolic version two dimensional convolution 2 lefthand structure depicts entire circuit basic building element shown right corresponds relation snd q k p q instantiated described text middle structure depicts snd 3 59 delay elements 59 shown arrows figure indicate inputoutput partitioning determined causality analysis described delay element associated combinational element global distribution input stream combinational elements 44 selection extraction rewriting system truby includes facilities selection subterms target expression matching pattern free variables used restrict rewriting temporarily particular subterm importantly extraction part target expression implementation latter case remainder target expression gives context describing set implementation conditions must fulfilled extracted part work extraction many respects converse adding relational constraints specification context specifies sorts requirement firstly may give representation rules must obeyed interface extracted subterm secondly context contains delay elements may give timing requirements implementation subterm trivial example adder extracted part typically rewriting circuit inside dashed box figure 6c implementation conditions case express fact integers must represented n bits specified bits n 5 vlsi implementation relational approach describing vlsi circuits offers greater degree abstraction descriptions using functions alone since direction data flow specified however real circuits offer particular patterns data flow means interpretation relation may general 0 1 many different circuits case zero circuits say relation unimplementable widest class relations generally implementable believed causal relations defined hutton 2 generalise functional relations sense inputs restricted domain outputs range truby causality analysis performed end rewriting process user extracted part relation implemented cases fact context relation extracted nonimplementable example may specify timing requirements could implemented would correspond foreseeing future 51 causality analysis exactly relation causal elements tuple values relation partitioned two classes first class outputs functionally determined second class inputs partitioning functional dependency used tuples relation example previously defined relation causal sense three elements tuple values relation partitioned described fact three different ways 1 x inputs z output relation describes adder 2 x z inputs output relation describes subtractor 3 z inputs x output relation describes another subtractor note relation 1 also causal although functional essentially causality means relation viewed partitioning deterministic function inputs truby relation analysed first expanded using definitions component relations form expressed entirely terms four elements pure ruby relational inverse expanded relation analysed simple bottomup analysis heuristic combinational elements described spread relations causality determined analysing body spread must form body part ffl equality single variable lefthand side ffl conjunction body parts ffl conditional choice two body parts equality result analysis depends form righthand side single variable conclusions drawn equality implies wire abstract floorplan righthand side expression values taken inputs lefthand side taken output choices values condition taken inputs rules result conflicts causal partitioning found several possible causal partitionings case hand rules enable us choose unique one delay elements values domain inputs range outputs parallel composition preserves causality fact inversion serial compositions general require analysis determine whether inputoutput partitionings component relations compatible implementable unidirectional data flow components essentially checks made whether two outputs used assign new signal value wire whether wires assigned signal values whether loops containing purely combinational components additional analysis exploited order determine network circuit form netlist named wires active components present backtracking arbitrary choice partitioning several possibilities wrong one possible find complete causal partitioning entire circuit example let us consider analysis parts relation 2dimensional convolution central element relation given accp describes combinational multiplyandadd circuit kernel element p k using definition acc substituting p reduces spread body spread form equality single lefthand side thus causal partitioning make z output inputs case relation functional domain range general need since delay elements inputs domain side outputs range side serial composition snd compatible analysis accp range delay element corresponds component domain accp analysis proceeds similar manner leading final data flow pattern shown arrows figure 9 52 translation vhdl since causality analysis gives network circuit direction data flow along individual wires components actual translation vhdl comparatively simple translated top level ruby relation declared single design unit incorporating single entity name specified user rough terms combinational relation c wiring relation within expanded ruby relation translated one possibly conditional signal assignments outputs c assigned new values based inputs example gives rise single concurrent signal assignment form sig z sig sig names vhdl signals corresponding z respectively w constant equal value p circuit element question since operators available use operands integer boolean bit character types ruby one simple exception logical implication subset available vhdl direct style translation problemfree similar manner conditional ifthenelse expressions body spread directly translated conditional assignment statements possibly extra signal assignments evaluate single signal giving condition vhdl types signals involved derived ruby types used domain range c obvious way thus elementary types ruby type bit translated vhdl type rubybit bool rubybool int rubyint char rubychar vhdl definitions rubybit rubybool rubyint rubychar predefined package rubydef referred generated vhdl units composed types give rise groups signals generated possibly recursive flattening ruby type pair flattened two components list n components elementary types reached ruby relation refers elementary types predefined ones package declaration containing suitable type definitions generated translator example enumerated type etyp used definition vhdl enumerated type rubyetyp named elements generated free variables relational type noncombinational relations ruby relation translated instantiations one vhdl components example delay relation ruby type sig simple type translated instantiation component dff rubyt rubyt type corresponding composed types pairs lists two components appropriate simple type used standard definitions components standard simple ruby types available library components particular generated free relational variables assumed defined user final result translating fully instantiated 2dimensional convolution relation vhdl shown figure 10 figure show entire vhdl code course repetitive owing regular nature circuit illustrates style signal identifiers starting input output correspond generated code edit compiled 950201 115828 ruby relation fst fork 5 rdrf 5 kint fst fork 5snd d59 entity conv264 port end conv264 architecture ruby conv264 component dff rubyint port end component signal wire4546wire4548wire4550wire4552wire4554wire4556wire4558 wire19943wire20128wire20273wire20378wire20478wire20596 wire20746wire20928wire21142 rubyint begin input assignments output1 wire1983 calculations registers d3 dff rubyint port map wire20128wire20746clk d4 dff rubyint port map wire20273wire20596clk d5 dff rubyint port map wire20378wire20478clk d7 dff rubyint port map wire19730wire19732clk d319 dff rubyint port map wire4546wire4548clk d320 dff rubyint port map wire2540wire4546clk figure 10 vhdl translation instantiated 2dimensional convolution circuit external inputs outputs mentioned formal port clause entity names starting wire identify internal signals clock input generated underlying entities sequential assignments marked calculations describe combinational components marked registers describe component instantiations corresponding delay elements instantiations userdefined components follow separate section required correctness translation relies heavily two facts 1 simple mapping ruby types operators types operators available vhdl 2 relations considered translatable internally consistent causal partitioning found facts also imply vhdl code generated synthesised vlsi present use synopsys vhdl compiler 14 performing synthesis automatically 53 components system complete system illustrated figure 11 similar style analysis used generating vhdl code used controlling simulation behaviour extracted relation user must supply stream values inputs circuit required initial values latches simulation uses exactly assignments new values signals appear vhdl description obviously fully instantiated causal relations simulated system data flow proof burdens silicon equivalences proved parserprinter ruby expressions internal representation ruby terms system analysis dynamic behaviour figure 11 complete ruby design system 6 conclusion 19 6 conclusion paper presented truby design system outlined general design method vlsi circuits based transformation formal specifications using equality rewriting constraints extraction simple mathematical basis specification language terms functions relations enables us prove general transformation rules minimises step mathematical description problem initial specification system use system illustrated nontrivial example circuit 2dimensional convolution example shows truby used describe complex repetitive structures useful vlsi design demonstrates system used derive descriptions highly generic circuits concrete circuit descriptions obtained instantiation free parameters circuits described socalled causal relations implemented behaviour simulated truby system simple mapping truby vhdl relations used produce vhdl description final synthesis design system basically relies existence large database pre proved transformation rules however design process conjectured rules introduced time rewrite rules preconditions may used truby proofs conjectures preconditions postponed without loss formality system keeps track relevant proof burdens transferred later separate theorem prover belief divide ocnquer philosophy helps make use formal methods feasible practical designs acknowledgements work described paper partially supported danish technical research council authors would like thank lars rossen many interesting discussions constructing tools ruby ole sandum work design ruby vhdl translator r framework defining logics functions relations calculating programs circuit design ruby relations refinement circuit design generic theorem prover ruby proof system formal ruby ruby algebra ruby framework truby tool handling ruby expressions transformational rewriting ruby constraints abstraction verification tr
discrete event systems approach protocol conversion protocol mismatch occurs heterogeneous networks try communicate mismatches inevitable due proliferation multitude networking architectures hardware software one hand need global connectivity hand order circumvent problem solution protocol conversion proposed paper present systematic approach protocol conversion using theory supervisory control discrete event systems partially first addressed inan study problem designing converter given mismatched pair protocols using specifications specifications channel user services introduce notion converter languages use obtain necessary sufficient condition existence protocol converter present effective algorithm computing whenever exists b introduction growing need global communication networks computers however heterogeneity existing networks allow direct consistent communication results mismatch protocols mismatches inevitable due proliferation differing hardware software networking standards desired urgency towards global connectivity possible solution differing standards protocol mismatches would standardize networking protocols move may practical case take years agreed upon worldwide resulting connectivity problems present result alternative method protocol conversion proposed alternative measures developing protocol converters form solution available time everybody adheres global standard green 21 argues protocol conversion necessity cannot ignored citing reasons little late standardize architectures established base decnet arpanet ibm sna tcpip x25 users find difficult switch open global standard simply sheer effort involved well rendering obsolete many existing hardware software solutions numerous vendors different protocols architectures also tend serve different communities users need maintain contact external world still great importance figure consists sending end protocol p 0 receiving end protocol p 1 similarly protocol q composed q 0 q 1 protocol mismatch occurs sending end protocol p 0 p tries communicate receiving end protocol q 1 q similarly also q 0 tries communicate p 1 protocol mismatch protocol mismatch figure 1 protocol configuration practical solution protocol mismatch interpose translator converter two protocols traps messages sent one system translates messages sender system manner receiver system understand without loss consistency depicted figure 2 denotes one protocols q 1 mismatched protocols c denotes converter resulting protocol conversion system adhere user service specification defines properties protocol system needed users user figure 2 interposing protocol converter tanenbaum 28 provides classification converters depending layer protocol stack used repeaters used physical layer bridges used link layer routers gateways used network layer finally protocol converters used transport layer events occur user interface called external events remaining events called internal events let g denote composition p 0 q 1 k denote user service specification g system evolves external well internal events whereas k formal language defined external events composition g converter c denoted gkc implements service specification k certain safety progress properties hold safety captures notion nothing illegal happen ie event traces gkc correspond allowed k progress captures notion composition block occurrence external event whenever feasible specification k ie whenever specification block role converter c restrict behavior g gkc implements k however must limited control observation capabilities words certain events controllabletheir enablementdisablement controlled c remaining uncontrollable similarly certain events observabletheir occurrence sensed c remaining unobservable thus design protocol converters studied framework supervisory control discrete event systems pioneered ramadge wonham 23 subsequently extended researchers refer survey articles 24 29 book 12 motivation work presented problem protocol conversion studied researchers paper calvert lam 2 provides nice survey one first approaches protocol conversion bottomup approach taken okumura 20 lam 17 bottomup approaches heuristic nature may able determine converter even one exists topdown approach calvert lam 2 algorithmic nature however converter design state machine evolves set internal events implies set internal events treated set controllable well set observable events converter unrealistic since converter observe events occur interface ie input output events control output events general event sets different illustrated example topdown approach algorithmic approach also known quotient approach since c viewed quotient g k protocol conversion problem first treated inan supervisory control framework important application example 8 depth 9 theoretical foundation application based given 10 however work inan address safety constraint protocol conversion problem requires projected language supervised system equal given specification language additional progress constraint requires supervised system never block external event blocked specification also considered part protocol conversion problem work calvertlam 2 treat safety progress constraints work presented existence converter requires controllability observability conditions together extra safety progress conditions implying work presented also requires generalization conventional supervisory control rudiewonham 25 also applied supervisory control techniques deriving missing portion either sender receiver portion protocol assuming knowledge problem quite similar protocol conversion considers safety specification recent work kumarfabian 11 show progress constraint may expressed using type nonblocking property respect family marked languagesone external event nonblocking property differs conventional one used supervisory control 3 two ways first nonblocking respect family markings opposed single marking needed second type marking depends specific manner entire closedloop behavior opposed traces closedloop behavior marked openloop behavior paper derive converter using formal techniques supervisory control discrete event systems supervisory control framework provides necessary sufficient conditions existence supervisors present setting converters given plant present setting composition two mismatched protocols closedloop system present setting composition converter mismatched protocols meets desired specification present setting user service specification however since user service specification partial specification ie defined subset consisting external events opposed entire event set customary supervisory control framework supervisory control theory results cannot applied directly appropriate extensions obtained paper introduce notion converter languages show existence converter equivalent existence converter language contained language g set converter languages closed respect union supremal converter language exists provide effective algorithm computing test existence converter reduces test nonemptiness supremal converter language moreover generator supremal converter language serves choice converter converter exists supremal converter language empty case given service specification may minimally altered converter exists problem recently addressed takaitakaekodama 27 kumarfabian 11 illustrate work example two incompatible protocols namely alternating bit protocol nonsequenced protocol 28 two obviously incompatible alternating bit protocol labels data packets sequence numbers 0 1 nonsequenced protocol work labeled data packets abridged versions work presented first appeared 14 15 motivating example example assume converter collocated receiving end shown figure 3 sending end p 0 composition sender protocol p senders channel p c whereas receiving end q 1 consists receiver protocol q r qls tm del acc figure 3 typical protocol conversion system general q 1 also composition q r receivers channel mismatched protocol components example alternating bit protocol sender p alternating bit channel p c nonsequenced protocol receiver q r state machines along service specification presented section thus example events occurring various interfaces present example indicated figure 3 external event set consists accept event acc deliver event del lower respectively upper case letters used internal events occurring sender respectively receiver end event label negative respectively positive sign prefix represents transmit respectively receipt event protocol however sign convention channel opposite since receipt event channel transmit event adjoining protocol viceversa receipt events channel prefixed negative signs whereas transmit events channel prefixed positive sign since converter interposed channel receiver protocol fixes events occur converter interface thus instance di represents transmit event data packet label sender protocol receipt event data packet channel whereas represents transmit event acknowledgment receiver protocol receipt event acknowledgment converter events include timeout event tm channel loss event ls thus example event set sigma consists following subset sigma consisting events occur converter interface constitute set observable events whereas remaining events unobservable part observable events output events converter occurrence controlled converter output events constitute set controllable events events uncontrollable converter note set controllable events converter contained set observable events exploit property design converter also note set controllable events set observable events different set internal events distinction noted work calvert lam 2 alternating bit sender depicted figure 4 six states initial state state 0 position accept data user data transmitted label 0 next data accepted user acknowledgment correct label 0 received otherwise either wrong acknowledgment label 1 received sender times due loss data acknowledgment data retransmitted label 0 procedure repeated accept event except label used alternates 0 1 acc figure 4 alternating bit sender alternating bit channel shown figure 5 six states channel initially receives data packet events di may either lose event ls sending back initial state may successfully transmit events di sending state ls ls figure 5 alternating bit channel receives acknowledgment packet events ai acknowledgments may either get lost event ls may get successfully transmitted events ai sending channel back initial state either case nonsequenced receiver shown figure 6 simple state machine receiving data delivers user sends acknowledgment sender since labels present data packets labeled alternating bit sender cannot interpreted consistently nonsequenced receiver resulting protocol mismatch0d del acc del figure nonsequenced receiver service specification finally protocol system provide service loss free transmission lossy channel accomplished requiring accept deliver events alternate service specification depicted figure 6 weaker service specifications type order accepted delivered message sequences identical also considered however complex protocols needed offer service 3 notation preliminaries use sigma denote universe events sigma denotes set finite length event sequences called traces including zero length trace denoted ffl subset sigma ie collection traces called language language h notation prh called prefix closure h set prefixes traces h h said prefix closed given trace 2 sigma subset events projection denoted sigma trace obtained erasing events belonging sigma state machines 7 used representing untimed behavior discrete event systems protocol channel systems well representing qualitative logical specifications user service specifications formally state machine p quadruple denotes set states sigma denotes finite set events partial transition function x initial state triple x oe x 0 called transition p x 0 2 ffx oe said epsilontransition denotes set states reachable execution zero events sigma state x notation denotes set events sigma executable x transition function extended events traces ff obvious way generated language p set traces execute starting initial state ie p called deterministic state machine transition function partial function x completion deterministic state machine p denoted state machine obtained completing transition function p adding new state dump state x adding transitions state x p dump state events defined x p formally defined x otherwise note lp synchronous composition 6 state machines used represent concurrent operation component systems given two deterministic state machines p x composition p q denoted pkq x sigma ff x 0 defined undefined otherwise thus p q composed common events occur synchronously events occur asynchronously generated language composition given note sigma since events must occur synchronously also note although state set pkq x p theta xq many states remain unreachable pkq adopt convention writing pkq mean reachable trim component 7 supervisory control discrete events systems synchronous composition uncontrolled plant modeled state machine g supervisor modeled state machine identical event set plant used control mechanism certain sublanguage h lg represents desired behavior plant control objective design supervisor controlled plant behavior lgks equals h supervisor designed limited control observation capabilities sense cannot prevent occurrence certain uncontrollable events ii observe occurrence certain observable events letting sigma u sigma denote set uncontrollable events sigma denote set observable events following result supervisory control theory states necessary sufficient condition existence supervisor theorem 1 23 18 given plant g desired behavior h lg set uncontrollable events sigma u set observable events sigma exists supervisor compatible control observation capabilities prefix closure nonemptiness controllability prh sigma controllability condition requires extension prefix h uncontrollable event feasible plant also prefix h occurrence uncontrollable events cannot prevented pair traces called indistinguishable trace pair identical projection set observable events observability condition requires extensions pair indistinguishable prefixes h common feasible event either neither prefixes h identical control action must taken following indistinguishable pair traces note h controllable respectively observable prh controllable respectively observable tests controllability observability conditions known g finitely many states h regular language admits finite state machine representation fact g states h state machine representation n states controllability tested omn time whereas observability tested omn 2 case desired behavior h fails satisfy required conditions maximally permissive supervisor designed achieves maximal sublanguage h satisfying required conditions known controllability preserved union unique maximal controllable sublanguage called supremal controllable sublanguage given language exists 22 however observability preserved union maximal observable sublanguages unique 18 hence sometimes normal sublanguages instead observable sublanguages considered 18 normality requires traces g indistinguishable prefix h must prefixes h normality preserved union supremal normal sublanguage given language exists 18 1 13 tested omn 2 time 12 p 103 moreover normality implies observability converese holds presence controllability controllable events also observable theorem 2 9 proposition 42 given g h lg controllable observable controllable normal similar result also appeared 12 theorem 43 timed setting 19 proposition 4 4 existence computation converter paper interested solving slightly different supervisory control problem objective obtain supervisor refer converter context closedloop system implements given service specification defined subset external events given p x sigma ff x 0 set external events sigma e sigma service specification k sigma e p implements k following hold safety lp sigma progress safety requires generated trace p correspond prefix specifi cation ie illegal traces occur p since k partial specification defined external event set may exist one trace p correspond prefix k progress requires external event possible prefix k also possible eventually ie occurrence zero internal events following corresponding trace p note safety guarantees external event eventually possible following least one corresponding traces p remark 1 definition implements given equivalent given 2 stated differently simplicity example definition safety given 2 uses containment instead equality however containment replaced equality since reverse containment follows progress similarly definition progress given 2 uses state characterization instead language characterization 2 p represented nondeterministic state machine external events replacing transition internal event epsilontransition language based characterization progress possible state based characterization used case p state machine external internal events following theorem provide necessary sufficient condition existence converter given pair mismatched protocols given service specification first introduce notion converter languages described notation g used denote composition mismatched protocols k used denote service specification given pair mismatched protocols g service specification k sigma e set uncontrollable events sigma u set observable events sigma called converter language following hold controllability prh sigma safety prhsigma progress note h lg converter language prefix closure also converter language using result theorem 1 next show necessary sufficient condition existence converter existence nonempty converter language theorem 3 given pair mismatched protocols g service specification k sigma e set uncontrollable events sigma u set observable events sigma exists converter c compatible control observation capabilities gkc implements k exists nonempty converter language proof first prove necessity suppose exists converter c gkc implements k claim h lgkc required converter language since c control observation compatible necessity part theorem 1 follows h nonempty prefix closed controllable observable furthermore since gkc implements k follows definition 1 safety progress properties definition 2 thus h nonempty converter language order see sufficiency suppose exists nonempty converter language h lg prh nonempty controllable observable sufficiency theorem 1 follows exists c control observation compatible prh furthermore since h converter language follows definition 2 satisfies safety progress properties implies gkc implements k desired since set controllable events converter contained set observable events ie follows theorems 2 3 language converter language satisfies properties controllability normality safety progress fact used obtain following corollary states set converter languages closed union supremal one exists define following set converter sublanguages lg implement specification k convg k fh lg j h converter languageg e supremal converter language sup convg k exists proof first note since converter sublanguage convg k 6 let indexing set 2 h lg converter language claim 2 h also converter language ie satisfies conditions controllability normal ity safety progress first two properties follow fact controllability normality preserved union safety follows following series equalities used fact prefix closure projection operations commute arbitrary union h satisfies safety finally see progress pick 2 pr prk exists 2 also since h converter language satisfies progress exists following theorem provides concrete condition existence converter forms basis test developed paper also specifies choice prototype converter theorem 4 let g k sigma e sigma theorem 3 exists converter c gkc implements k sup convg k nonempty case c chosen generator sup convg k proof order see necessity suppose exists converter necessity part theorem 3 exists nonempty converter language h 2 convg implies sup convg k nonempty sufficiency follows sufficiency part theorem 3 since sup convg k converter language given nonempty finally let c generator sup convg k ie last equality follows fact sup convg k lg consequently satisfies safety progress properties definition 2 implies gkc implements k theorem 4 task checking existence converter well designing one exists reduces task computing supremal converter language verifying nonemptiness next present algorithm computing sup convg k assuming g finitely many states say k regular language admits finite state machine representation say states motivating example state machine representation k consists two states shown figure 6 computation supremal controllable sublanguage given 13 algorithm computation sup convg k two steps first step constructs sufficiently refined version state machine g 1 next step removes certain bad states refined state machine initially certain states correspond traces violate safety marked bad ie states reachable execution traces whose projection external event set prefixes k bad states sup convg k equals lg otherwise converter must designed restrict behavior g good states remain reachable correspond traces also satisfy progress controllability normality conditions progress requires set external events executed following execution zero internal events certain good state contain set external events executable corresponding point k good state fails satisfy progress marked bad controllability requires bad state reachable good state uncontrollable event since execution uncontrollable event cannot prevented system uncontrollably reach bad state good state order compute sup convg k exists uncontrollable transition good state bad one good state marked bad finally normality requires states corresponding set indistinguishable traces either good bad good state bad state reached execution pair indistinguishable traces good state marked bad algorithm terminates additional bad states marked sup convg k consists traces corresponding remaining good states nonempty set good states nonempty clear state machine representation g needs sufficiently refined states corresponding traces violating either conditions unambiguously identified first order deal safety progress controllability conditions refine machine g composing state machine obtained completing transition function motivating example state machine shown figure 7 dump state explicitly depicted note e expected given trace 2 sigma execution result dump state let g 1 skg since sigma e sigma last equality follows fact e notational simplicity let fy g theta x dump state denotes state given two state machines g said refined version g 2 exists function oe 2 sigma dump del acc del acc acc del figure 7 completion service specification set g 1 z transition function z initial state note given trace 2 execution leads state z x g 1 ssigma e 62 prk next order deal normality condition refine g 1 first obtain nondeterministic state machine g 2 generates traces indistinguishable traces g 1 since trace remains indistinguishable unobservable events either inserted erased following construction yields desired g algorithm 1 given g 1 skg add transitions g 1 obtain g 2 follows 1 z 2 z oe 2 2 transition z oe z 0 g 1 z 6 z 0 oe 2 add epsilon transition z ffl z 0 algorithm effect inserting respectively erasing unobservable events remark 2 note z reachable execution trace g 1 z also reachable execution traces indistinguishable g 2 trace indistinguishable z 0 reachable execution 0 g 1 z 0 also reachable execution g 2 since indistinguishable 0 fact set states reachable execution g 2 set states reachable g 1 execution traces g 1 indistinguishable next using powerset construction 7 obtain deterministic state machine g 3 language lg 2 finally construct machine g 4 g 1 kg 3 since show g 4 sufficiently refined version g first outline construction g 4 following algorithm algorithm 2 given g x sigma ff x 0 deterministic generator sigma e fi 0 1 obtain adding dump state completing transition function e 2 obtain g 1 skg lg 1 state set g 1 denoted z 3 obtain nondeterministic state machine g 2 adding transitions g 1 described algorithm 1 state set g 2 z 4 obtain g 3 determinizing g 1 using power set construction lg 3 state set g 3 2 z 5 obtain g 4 g 1 kg 3 lg 4 state set g 4 z theta 2 z clearly g 4 refined version g notational simplicity let g 4 r sigma ffi r 0 z state set g 4 note state r g 4 form z z 2 z denotes transition function g 4 initial state g 4 r following lemma list properties g 4 demonstrate sufficiently refined version g first define concept matching pair states definition 3 pair states r said matching lemma 1 following hold g 4 state machine constructed algorithm 2 1 2 consider 2 lg 4 ssigma e 2 prk 6 3 state g 4 z 2 z 4 consider matching pair states r proof first part follows construction proved order see second part consider execution ssigma e results state since assertion follows fact 6 order see third part let 2 lg 4 ffir z execution results state z g 1 state z g 3 since g 3 obtained determinizing state machine g 2 implies execution results state z g 2 recall g 2 nondeterministic since g 2 obtained adding transitions g 1 z one state hence z 2 z finally order see fourth part consider matching pair states r z 2 third part z 1 z consider 1 2 lg 4 execution 1 results state z 1 g 1 state z g 2 including states z 1 z 2 remark 2 concerning g 2 exists trace indistinguishable 1 ie 2 sigma execution results state z 2 g 1 trace exists z 2 cannot reached execution 1 finally since 2 indistinguishable 1 execution g 2 also results set states z execution 2 results state r z g 4 desired ready present algorithm iteratively marks bad states g 4 upon termination yields generator sup convg k notation r k b r used denote set bad states kth iteration algorithm 3 consider g 4 r sigma ffi r 0 obtained algorithm 2 1 initialization step 2 iteration step r k1 b r k r 3 termination step r k1 go step 2 algorithm initially sets iteration counter marks state r bad state first coordinate dump state ie trace ffir second part lemma 1 violates safety condition set bad states kth iteration denoted r k b kth iteration step good state b marked bad following hold exists uncontrollable event r bad state 2 lg 4 trace ffir violates controllability condition ii exists matching bad state r 0 2 r k b trace ffir fourth part lemma 1 exists trace 0 indistinguishable ffir violates normality condition iii set external events executable state contained set external events executable good states reached execution zero internal events r g 4 trace ffir violates progress condition algorithm terminates additional bad states marked kth iteration else iteration counter incremented one iteration step repeated note since g 4 finitely many states algorithm guaranteed terminate finite number iterations also since algorithm marks state bad state traces lead violate either safety progress controllability normality state machine obtained removal terminal set bad states transitions leading towards away g 4 generates language sup convg k hence obtain following result stating correctness algorithm theorem 5 given finite state machine g regular language k sigma e algorithm 3 terminates finite number steps state machine obtained removal states r b r g 4 generates sup convg k r b denotes set bad states termination algorithm number states g n number states state machine representation k computational complexity algorithm 3 since number states g 4 omn2 mn implies omn2 mn number iterations equally many computations iteration also algorithm polynomial complexity exists follows fact special case sigma converter design problem reduces standard supervisory control problem partial observation desired behavior constraint specified range languages known npcomplete problem 30 5 implementation issues example converters since computation sup convg k intractable computationally tractable heuristic approach converter design desirable propose two heuristics utilize design converter motivating example since computational intractability arises due presence partial observa tion one possibility first compute supremal sublanguage lg satisfying safety progress controllability next verify whether also normal done polynomial time case language also normal equals desired supremal converter language successful computing polynomial time next outline polynomial time computation supremal sublanguage lg satisfying safety progress controllability clearly language equals sup convg k events observable normality trivially holds note events observable g 2 equals g 1 ie transitions added algorithm 1 invoked g 4 also equals g 1 hence following modification algorithm 3 computes desired supremal sublanguage lg satisfying safety progress controllability algorithm 4 given g x sigma ff x 0 deterministic generator sigma e fi 0 1 initialization step 2 iteration step 3 termination step z k1 go step 2 using fact g 1 omn states computational complexity algorithm 4 determined om 2 n 2 algorithm computes supremal sublanguage lg satisfies safety progress controllability may violate normality test whether language also normal respect given set observable events performed ommn 2 case test normality fails work chomarcus iterative computation supremal controllable normal sublanguage 4 iterate supremal normal sublanguage computation computation supremal language meets safety progress controllability fixed point reached however result exponential computational complexity outlined following algorithm algorithm 5 given g k sigma e compute sup convg k follows 2 compute supremal sublanguage h k h k satisfying safety progress controllability using algorithm 4 h k normal sup convg go step 3 3 compute supremal normal sublanguage h k1 h k h k1 satisfies safety progress algorithm 6 given provides test safety progress sup convg replace g generator h k1 set go step 2 remark 4 note algorithm need check controllability h k1 step 3 since known supremal normal computation preserves controllability 5 proposition 39 also step 3 h k1 satisfy safety progress need compute supremal sublanguage satisfying safety progress use algorithm 4 although case controllability trivially holds ever need replace g generator h k1 since algorithm 4 computes supremal sublanguage lg satisfying safety progress controllability written cprogram algorithm 5 associated algorithm 4 utilizes finite state machine library originally developed supervisory control 26 using program algorithm 4 first computed supremal sublanguage lg satisfying controllability safety progress example state machine g composition alternating bit sender alternating bit channel nonsequenced receiver contains 66 states composition g three states contains 198 states initial iteration safety check disqualified 66 states next iteration performs controllability progress checks disqualified additional 34 states additional states disqualified next iteration controllability progress checks resulted test converter states test converter also passed normality test thus qualifying valid converter second possible heuristic guess test converter c verify correctness checking whether lgkc converter language show done polynomial time first note difficult guess converter simple possibility design system emulates missing portions mismatched protocols ie receiver protocol p r p sending protocol q q motivating example guess converter consider emulates functions alternating bit receiver nonsequenced sender order test whether lgkc converter language must check whether satisfies controllability normality safety progress polynomial time tests controllability normality found 12 pp 75 103 present polynomial time test safety progress notational simplicity let g 5 gkc let state set phi first refine g 5 composing notational simplicity let g 6 skg 5 let state set theta fy g theta phi note since sigma e sigma last equality follows fact e also given trace 2 lg 6 execution leads state satisfy safety state g 6 form oe also lg 5 satisfy progress set external events executed following execution zero internal events state contain set external events executable corresponding state following algorithm checking safety progress algorithm 6 consider composition mismatched protocols g test converter c deterministic generator prk 1 construct g 5 gkc denote state set phi 2 construct g 6 skg 5 denote state set theta 3 lgkc satisfies safety progress number states converter p computational complexity algorithm om omnp states equally many reachability computations need performed test converter motivating example shown figure 8 converter adopts figure 8 test converter following simple conversion strategy initially one data packets label arrive event d0 removes label forwards single data packet receiver event action taken point copies data packet arrive due sender timeout receiver transmits acknowledgment event converter attaches label 0 puts onto senders channel event a0 procedure repeated data packets different label arrive except difference label used however another data packet label arrives due sender timeout loss acknowledgment channel acknowledgment retransmitted verified lgkc lability normality ie converter language since lgkc obviously nonempty follows theorem 3 c indeed valid converter 6 conclusion paper studied problem designing protocol converters need interposed pair mismatched protocols approach systematic based recent theory supervisory control discrete event systems work presented provides new framework protocol converter designers one hand serves application supervisory control theorists hand basic concepts controllability observability normality computation supremal languages supervisory control safety progress protocol design play important role protocol conversion problem converter derive maximally permissive sense converter restrict behavior entire system however maximally permissive converter may minimal number states design minimal converters interesting problem future research r formulas calculating supremal controllable normal sublanguages formal methods protocol conversion dealing blocking supervisory control discrete event systems supremal languages class sublanguages arise supervisor synthesis problems partial observations supervisory control discrete event processes partial observation communicating sequential processes introduction automata theory supervisory control formal methods distributed systems supervisory control theory application gateway synthesis prob lem nondeterministic supervision partial observations supervisory control partial specification arising protocol conversion modeling control logical discrete event systems controllability normality discrete event dynamical systems design protocol converters discrete event systems approach protocol conversion using supervisory control techniques protocol conversion observability discreteevent systems supervisory control timed discrete event systems partial observation formal protocol conversion method protocol conversion supremal controllable sublanguage given language supervisory control class discrete event processes control discrete event systems supervisory control communicating processes software library discrete event systems finite state machine based applications extremal languages arising supervisory control service specifications computer networks logical aspects control discrete event systems survey tools techniques control discrete event dynamical systems tr ctr nina yevtushenko tiziano villa robert k brayton alex petrenko alberto l sangiovannivincentelli solution parallel language equations logic synthesis proceedings 2001 ieeeacm international conference computeraided design november 0408 2001 san jose california young moo lee kyu ho park protocol converter nonblocking protocols integration vlsi journal v33 n1 p7188 december 2002 khaled elfakih nina yevtushenko sergey buffalov gregor v bochmann progressive solutions parallel automata equation theoretical computer science v362 n1 p1732 11 october 2006 nina yevtushenko tiziano villa robert k brayton alex petrenko alberto l sangiovannivincentelli compositionally progressive solutions synchronous fsm equations discrete event dynamic systems v18 n1 p5189 march 2008
fast distributed approximation algorithms positive linear programming applications flow control study combinatorial optimization problems set distributed agents must achieve global objective using local information papadimitriou yannakakis proceedings 25th acm symposium theory computing 1993 pp 121129 initiated study problems framework distributed decisionmakers must generate feasible solutions positive linear programs information local constraints extend model allowing distributed decisionmakers perform local communication acquire information time explore tradeoff amount communication quality solution linear program decisionmakers obtainour main result distributed algorithm obtains 1 approximation optimal linear programming solution using polylogarithmic number rounds local communication algorithm offers significant improvement logarithmic approximation ratio previously obtained awerbuch azar proceedings 35th annual ieee symposium foundations computer science 1994 pp 240249 problem providing comparable running time results apply directly application network flow control application distributed routers must quickly choose allocate bandwidth connections using local information achieve global objectives sequential version algorithm faster considerably simpler best known approximation algorithms capable achieving 1 approximation ratio positive linear programming b introduction processors distributed environment must make decisions based local data thus fast distributed algorithms must often without global information system whole exactly computing many target functions distributed models quickly provably hard 15 however quite surprisingly interesting global optimization problems closely approximated based local information modest amount local communication work motivated application developing flow control policies must achieve global objective functions flow control mechanism routers network distribute available network bandwidth across connections work routing policies determine routes network connections must use transmit packets problem regulating rates connections may inject data along fixed routes problem flow control connectionoriented ratebased approach flow control standard routing available bit rate trac atm networks 9 expected become widely used packetswitched networks approach router network must make regulatory decisions based local information typically consists current transmission rates connections using router existing flow control policies try satisfy local objective functions maxmin fairness 7 1 11 however many practical scenarios global objective functions department computer science hebrew university jerusalem israel yairbcshujiacil department computer science boston university boston byerscsbuedu department computer science technion haifa israel dannycstechnionacil much work completed authors aliated international computer science institute berkeley california university california berkeley research supported part nsf operating grants ccr9304722 ncr9416101 grant usisrael binational science foundation work presented paper appeared preliminary form 6 10 bartal j w byers raz appropriate choice example commercial intranetwork users paying use network bandwidth possibly dierent rates administrator would want use flow control policy maximizes total revenue express flow control policy objective positive linear program linear program entries constraint matrix nonnegative complicating issue problem routers must generate feasible solutions linear program lp quickly based available information motivated application related applications papadimitriou yannakakis considered problem distributed decisionmakers assign values set variables linear program agents limited information 18 one scenario describe agent acting isolation must set value single primal variable knowing constraints aecting variable lp context flow control objective maximize total flow network corresponds setting connections know many connections share routers intend use edge capacities 1 safe algorithm sets connections flow reciprocal maximum number connections share edge connection hard see worstcase approximation ratio achieved safe algorithm maximum number connections share edge also prove safe algorithm achieves best possible worstcase ratio agents may communicate leaving open possibility much better ratios obtained agents interact extend model allow computation proceed sequence rounds agents communicate fixedsize message immediate neighbors agents neighbors share one constraints lp goal determine number rounds necessary achieve approximation ratio optimum lp solution although focus application flow control study could also performed range resource allocation problems including described 18 note similar models describing interaction connections routers theoretical practical evaluations flow control policies suggested 3 1 5 16 course centralized administrator complete information could solve problem exactly using one well known polynomialtime algorithms linear programming see example 14 recently much faster algorithms produce approximate solutions positive linear programs within factor optimal designed sequential algorithm plotkin shmoys tardos 19 repeatedly identifies globally minimum weight path pushes flow along path recently faster approximation algorithms considered several related flow binpacking problems 8 12 using principle repeatedly choosing good flow incrementally increasing rate flow technical diculty balance amount flow increase required approximation achieved number needed steps ie running time algorithms global operator choosing appropriate unsatisfied constraints used moreover general multicommodity flow problem cannot formulated positive linear problem unless number dual variables number constraints exponential cases one must use separation oracle since polynomially many flows handled positive linear programs however number constraints polynomially bounded thus one increase dual variables simultaneously approach taken algorithm luby fast approximation algorithms positive lps 3 nisan 17 algorithm fast sequential parallel implemen tation repeatedly performs global median selection algorithm values dual variables choose threshold increases values dual variables threshold although algorithms ecient implementations perform global operations make unsuitable fast distributed imple mentation since emulating global operations requires polynomial number distributed rounds interested much timeecient solutions previously known result distributed flow control algorithm global objective function algorithm awerbuch azar 3 gives logarithmic approximation ratio also runs polylogarithmic number rounds algorithm based fundamental results competitive analysis 2 4 deterministic algorithm present produces 1 solutions positive linear programs general flow control problem builds ideas used algorithms 3 17 19 algorithm closely related algorithm luby nisan eliminates need complex global selection operations global normalization step upon termination enabling fast implementation distributed setting simplifications carry serial parallel settings well dramatically simpler implementation saves 1 factor running time algorithm lubynisan finally parameterize algorithm quantify tradeo number rounds quality approximation practice run algorithm number phases guarantee constant number phases logarithmic factor approximation logarithmic number phases 1 rest paper organized follows begin presentation algorithm first easily understandable implementable serial algorithm approximately solving positive linear programming section 2 section 23 prove algorithm achieves 1 approximation ratio analyze running time formulate distributed model give explanation correspondence flow control policies positive linear programs section 3 section 32 present distributed implementation applicable flow control problem explain modifications analysis case 2 sequential approximation algorithms consider positive linear programs represented following standard form well known general arbitrary positive linear programming assume linear program lp presented algorithm normalized form ij either 0 satisfy 1 1 4 bartal j w byers raz sequential case one convert arbitrary lp standard form lp normalized form linear time simply dividing constraints setting amin 0 describe perform transformation eciently distributed setting section 3 r f outer loop phase min inner loop iteration od od j output fig 21 sequential positive lp approximation algorithm 21 overview results parameterized algorithm approximately solving positive linear program normalized form given figure 21 main theorem prove performance algorithm relates quality approximation running time follows theorem 21 0 1 0 r lnm algorithm produces feasible r approximation optimum primal linear programming solution runs nm ln r time following corollary clarifies tradeo running time quality approximation follows directly theorem 21 corollary 22 1 algorithm produces 1 optimum nm ln time 1 r lnm algorithm produces approximation optimum nm r time proof prove first claim corollary set theorem 21 prove second set choose 0 21 implies r 0 theorem 21 fast approximation algorithms positive lps 5 22 description algorithm sequential implementation algorithm presented figure 21 main body program bottom panel runs sequence phases number ultimately depends desired approximation ratio within phase values appropriate primal variables j increased monotonically threshold reached refer set increase operations across primal variables constituting inner loop main program iteration algorithm noting number iterations per phase may vary demonstrate time slot ending phase nonnegative settings primal variables j dual variables x primal dual feasible respectively satisfying constraints primal feasibility dual feasibility j 221 moving pairs feasible solutions since values primal variables increase monotonically algorithm crucial carefully select variables increase phase end algorithm uses exponential weight functions employed variety related contexts including 2 4 17 19 3 associate dual constraint measure associate primal constraint measure throughout algorithm values dual variables x tied values neighboring primal variables j exponential weighting function defined updateweights constant depends desired approximation ratio scaling factor initialized grows geometrically phase number reaches f termination condition establishing connection primal dual variables value j less 1 dual constraint ij x 1 violated satisfied sucient increase j relationship suggests following idea algorithm employ start pair dual primal feasible solutions scale dual feasible solution multiplicative factor making solution dual infeasible causing dual constraints violated move back dual feasible solution increasing primal variables j repeat process satisfactory approximation achieved hypothetical depiction intermediate primal dual feasible solutions end phase relative value optimal solution shown figure 22 maintain invariant values intermediate primal feasible solutions monotonically nondecreasing time guarantee provided intermediate dual feasible solutions linear programming feasibility ensures values intermediate primal feasible solutions necessarily smaller equal value program denoted opt similarly values intermediate dual feasible solutions necessarily larger 6 bartal j w byers raz equal value program upon termination prove final maximal primal feasible solution within desired case 1 factor minimal intermediate dual feasible solution linear programming duality implies final primal feasible solution gives desired approximation value program sequential implementation presented figure 21 bottleneck operation recompute j iteration takes onm time fact running time bottleneck operation precisely written oe e total number nonzero entries constraint matrix linear program multiplied total number iterations demonstrate polylogarithmic section 23 bound total sequential running time primal solutions value solution opt time dual solutions fig 22 intermediate primal dual feasible solutions 23 analysis algorithm section bound approximation ratio approximation algorithm present analysis sequential running time later extend results straightforward way distributed case first prove claim made earlier end phase primal dual solutions feasible definition algorithm values primal variables increase monotonically therefore value intermediate primal solutions also increase monotonically thus carry analysis approximation ratio remain prove value final primal feasible solution value minimal dual feasible solution 1 factor apart proof use following three facts follow initialization parameters given initializeparameters figure 21 fact 23 fast approximation algorithms positive lps 7 proof immediately follows definition fact 1 fact 24 r r proof definition definition also shorthand 1r suces show since r lnm olnm result follows directly fact 25 e proof substituting f multiplying e must show e r e r r e r r taking natural logarithm sides need show recall definitions r r therefore enough prove following since p clearly nonnegative q 1 show ln qp nonnegative need p substituting p using show final inequality follows fact x ln x completes proof 8 bartal j w byers raz 24 feasibility recall algorithm maintains invariant dual feasibility achieved prior increase fact 26 dual feasibility end phase j j 1 next prove j primal feasible throughout execution algorithm using claim 27 help perform induction proof convenient treat initial increase j 0 initialized value iteration 27 every iteration feasibility 1 throughout execution algorithm prove two claims simultaneously induction iterations algorithm proof let 0 first step prove claims hold iteration 0 since also implies claim 28 holds iteration 0 consider subsequent iteration let v denote change variable v iteration j j j rate increase iteration final inequality holds inductive hypothesis claim 28 completes proof claim 27 complete proof claim 28 consider two cases separately first consider values prior iteration proof 27 iteration 1 giving desired result next consider prior iteration fix fix j j fact 25 choice e hence j ij 1 definition increase rule algorithm never increase value primal variable fact primal variable j increases iteration therefore increase iteration remains smaller 1 induction hypothesis completing proof 25 proof 1 approximation ratio turn bound approximation ratio obtained algorithm stated first half theorem 21 29 0 1 0 r lnm algorithm produces feasible r approximation optimum primal linear programming solution use notation j denote aggregate change values course iteration similar notation variables begin following lemma fast approximation algorithms positive lps 9 lemma 210 every iteration proof 1 claim 27 1 follows using inequality e z prior given iteration let set indices primal variables active upcoming iteration ie variables j whose values increase iteration recall variable j may increased several times phase lemma follows following sequence inequalities final inequality holds definition stating proving next lemma require precise description notation consider change values dual variables x course phase proof let x denote sum x end current phase let x denote sum x end previous phase ie scaled let x denote change sum x course current phase define x minimum dual feasible solutions obtained end phase let yl primal feasible solution obtained end final phase fact 26 claim 28 respectively imply x dual feasible yl primal feasible conjunction lemma 211 implies approximation result stated claim 29 linear programming duality lemma 211 proof prove lemma two separate cases first easy case initial primal feasible solution close approximation optimum second repeatedly apply lemma 9 bound ratio x yl let x 0 denote value x initialization j bartal j w byers raz value x first phase similarly let xl denote value dual solution end final phase case xl r letting 1 denote value primal solution end first phase apply lemma 9 iterations comprising first phase giving since values primal feasible solutions increase monotonically throughout course algorithm lemma holds following sequence inequalities case ii xl r values x scaled factor following end phase earlier definitions imply x rewriting expression applying inequality e z using x x applying lemma 210 yields l initial value value last phase algorithm ie l f using bound repeatedly compare xl x 1 gives us since xl dual feasible optimal solution bounded 1 normalized form program xl also note assumption r lnm r use facts conjunction fact xl r using bound 21 observing get e r r r r r final inequality holds substituting using 1 therefore get yl concluding proof lemma case ii fast approximation algorithms positive lps 11 26 running time algorithm provided far following running time bounds slightly weaker stated theorem 21 weaker bounds presented since natural translation time bounds preceding analysis extends directly distributed algorithm present section 3 proving bounds provide simple improvement applies sequential case used give time bounds stated theorem 21 212 sequential algorithm runs r1nm r r time proof bound number phases measuring change increases 1 factor per phase definitions figure 21 using fact 24 final equality log 1f r r r r bound number iterations phase computing maximum number iterations needed increase j values 1 given j say j large j ln show j large j 1 therefore j longer participates phase let set ik k ln initially every iteration increases factor 1 therefore number iterations j participate j becomes large log 1 fact 25 using fact another application fact 24 bound number iterations phase r r r r note term r1 r cannot removed since r value satisfying 0 r lnm multiplying earlier bound number phases using fact iteration computed onm time completes proof claim 212 prove time bound stated second half theorem 21 need give sequential algorithm completes nm ln r time running 12 bartal j w byers raz time achieved algorithm performs exactly one iteration per phase sequential case accomplish increasing candidate j merely multiplicative factor 1 per iteration increasing amount causes j reach value 1 directly note procedure straightforward implement sequential case distributed case improvement causes phase terminate single iteration claims 27 28 still hold claims unaected achieve time bound stated theorem 21 3 distributed model consider following model spirit papadimitriou yannakakis 18 distributed agents generate approximate solutions positive linear programs standard form presented section 2 associate primal agent n primal variables j dual agent dual variables x agent responsible setting value associated variable j ij 0 say dual agent primal agent j neighbors distributed round computation agent may broadcast fixedsize message neighbors ie one round primal agent j may broadcast one message set dual neighbors dual agent may broadcast one message set primal neighbors fixed number rounds agents must choose feasible values variables minimize case primal approximation ratio opt opt value optimal solution lp study tradeo number rounds quality approximation ratio obtained application flow control network perflow queuing motivates following mapping model primal agents dual agents n connections transmits data along fixed path network connection corresponds primal agent paths traverse ordered subset routers comprise network routers correspond dual agents given time step connection j transmits given rate network thereby establishing value j primal variable new flow values stabilize router uses local load set value primal variable x based simple function sum values dual variables along path source uses control information compute new flow value 1 compute sum connection transmits fixedlength control message loops routers along path back source mentioned earlier simple natural model communication connections routers corresponds models previously suggested practical theoretical studies flow control 3 1 5 16 router capacity c may share among connections utilize connection accrues benefit b j every unit endtoend capacity receives therefore connections act primal agents routers act dual agents following positive linear program fast approximation algorithms positive lps 13 routerinitialize routerupdate send routerinitialize routerupdate j j end phase active connections call routerupdate od end phase od fig 31 distributed algorithm router clearly positive linear program converted standard form local operation synchronous model round takes time equal maximum roundtrip time experienced connection network however synchronization assumption subsequently relaxed changes algorithms propose final note message size use implementation bounded number bits polynomial log log 1 31 distributed approximation algorithm several additional complications must addressed definition description distributed algorithm provided figures 31 32 routers connections respectively since global operations cannot performed eciently connection router must able independently compute values parameters described serial implementation case parameters fixed value number nodes network parameters aect approximation ratio r assume values known advance connections routers assume n number connections globally known sequential case knowledge parameter required initialize variables j satisfy claims 27 28 distributed setting connection j instead computes local estimate n compute two distributed rounds used initialization satisfies claims 27 28 finally parameter used convert program normalized form may globally known case linear program cannot normalized eciently approximately solving programs distributed setting adds considerable complexity defer providing techniques section 32 connections routers communicate using messagepassing model described 14 bartal j w byers raz send ii j send read ii j defined figure 21 phase counter f iteration counter within phase od end phase od output j terminate fig 32 distributed algorithm connection j section 3 serial algorithm agents track time terms phases erations transmitting value variable using send primitive agents timestamp transmission current phase number p iteration like wise receiving value variable using read primitive agents specify phase number p iteration wait receive appropriate value simplicity assume control messages reliably flow path although practice retransmissions would likely necessary also strict alternation primal dual rounds eliminates possibility deadlock implementation messagepassing primitives enable control alternate connections routers local level say control globally synchronized fact instant time connections separate areas network might even working phase however case given router working single phase instant time therefore connections router currently working phase either actively working phase idle awaiting permission proceed phase 1 aside messagepassing technical obstacle converting centralized algorithm distributed algorithm condition ending phase centralized algorithm phase terminates min k k 1 since cannot hope track value global expression distributed model instead let connection j check whether j 1 locally independently condition satisfied connection j terminates phase incrementing phase number informing neighboring routers analysis feasibility bounds quality approximation identical centralized algorithm case value fast approximation algorithms positive lps 15 primal variable time corresponding connection completes phase satisfies conditions placed primal variables phase centralized implementation similar statement holds respect values dual variables time corresponding routers complete phase statements hold primal dual variable independently irrespective fact phase completion times may occur uniformly across network distributed running time following corollary claim 212 holds corollary 31 distributed algorithm runs r1 r rounds 32 distributed techniques convert special form recall convert program standard form normalized form dividing constraints amax thereby setting amin bounds values amax min known advance example connections routers bound min max values edge capacities benefit coecients estimated bounds may globally known moreover value impacts running time algorithm depends values entries matrix show solving problem standard form reduced solving problems special form similar form used luby nisan 17 value depends aect approximation ratio obtained significantly aect running time algorithm moreover transformation done distributively constant number rounds without global knowledge amax min precondition transforming lp z standard form lp z special form generate feasible solution z value c approximates value optimal solution z within factor c opt c precondition satisfied perform following transformation bounds value ij z 2 note value depends extent bound value lp relative values constraints could small c perform following transformation operation constraints c c otherwise transformed lp following properties 1 j primal feasible solution z otherwise primal feasible z j 2 j primal feasible z 1 primal feasible z 3 property 3 clearly true two properties require short proofs bartal j w byers raz proof property 1 take feasible solution j z let j specified fixed value 1 final inequality holds feasibility solution j solution feasible z value solution satisfies first inequality holds fact feasible j 1 second inequality holds bound number routers network final inequality holds definition proof property 2 take feasible solution j z let j specified fixed value c c c c final line holds bound optimal solution z c solution feasible generate approximate solution z performing transformation special form computing 1 using fast approximation algorithms positive lps 17 algorithm transform solution j using transformation described property 1 get primal feasible solution lp first inequality property 1 second based fact j 1 approximation value z denoted opt final inequality property 2 next need explain choose parameters c guarantee precondition c opt c recall j denotes set edges incident connection j denotes set connections incident edge ki l kl quantity locally computed one round router also let connection j define relatively easy show 1 first inequality holds primal feasibility solution connection j used evaluation minimum assigned flow second inequality holds dual feasibility solution router assigned weight x therefore set sequential implementation giving nm lnmr r running time 33 approximating distributed setting sequential case knowledge enough perform transformation special form connections routers may know value describe technique distributively subdivide lp subprograms based local estimates value subprogram bounded work special form recombine solutions way assign nonzero rates connections good estimates prove reduces sum rates small factor define sets g q integer clear connection belongs exactly p sets independently value q router assigns flow connections members g q iq minimal value g q nonempty eect means algorithm run network p successive times connections point view runs p successive algorithms using j approximation p trials rejected ie given flow routers final flow assigned connection j average flows given p independent trials prove procedure decrease sum rates additional 1 2 factor bartal j w byers raz define optx value modified lp flow assigned connections set x dicult show optg q bounded thus set g q special form modified lp connections g q satisfies precondition therefore lps use 21 turn bound approximation ratio consider particular q 0 p 1 let q unique integers interval defined g q q q dual feasible setting x g q iii l lg q implies opt g q q quality solution obtain therefore bounded byp putting everything together distributed algorithm assumes global knowledge approximation parameters r algorithm finds primal feasible r approximation optimal solution terminates r1 distributed rounds 4 discussion studied problem distributed decisionmakers local information generate feasible solutions positive linear programs results explore tradeo amount local communication agents may perform quality solution obtain measured approximation ratio provided algorithm obtains 1 approximation ratio polylogarithmic number distributed communication rounds proving nontrivial lower bounds running time needed obtain approximation remains open question challenging problem providing fast approximation algorithms general linear programs acknowledgments would like thank christos papadimitriou stimulating discussions useful insights formulative stages work also thank dick karp mike luby dorit hochbaum anonymous sicomp referees helpful comments earlier versions results presented paper fast approximation algorithms positive lps 19 r convergence complexity optimistic rate based flow control algorithms local optimization global objectives competitive distributed deadlock resolution resource allocation throughput competitive online routing converging approximated maxmin flow fairness logarithmic time achieving global objectives using local information applications flow control data networks potential function methods approximately solving linear programming prob lems theory practice ratebased flow control framework available bit rate atm service maximizing throughput reliable bulk network transmissions algorithm rate allocation packetswitching network feedback faster simpler algorithms multicommodity flow fractional packing problems distributive graph algorithms global solutions local data optimization flow control basic algorithm convergence parallel approximation algorithm positive linear programming linear programming without matrix fast approximation algorithms fractional packing covering problems tr
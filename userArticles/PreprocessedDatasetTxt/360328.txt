effect reconfigurable units superscalar processors paper describes onechip third generation reconfigurable processor architecture integrates reconfigurable functional unit rfu superscalar reduced instruction set computer risc processors pipeline architecture allows dynamic scheduling dynamic reconfiguration also provides support preloading configurations least recently used lru configuration managementto evaluate performance onechip architecture several offtheshelf software applications compiled executed simonechip architecture simulator onechip includes software environment programming system architecture compared similar one without dynamic scheduling without rfu onechip achieves performance improvement shows speedup range 216 32 different applications data sizes used results show dynamic scheduling helps performance average rfu always improve performance best execution rfu b introduction recently idea using reconfigurable resources along conventional processor led research area permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copies bear notice full citation first page copy otherwise republish post servers redistribute lists requires prior specific permission andor fee fpga 2001 february 1113 2001 monterey ca usa reconfigurable computing main goal take advantage capabilities features resources processor takes care generalpurpose computation reconfigurable hardware acts specialized coprocessor takes care specialized applica tions platforms specific properties applica tions parallelism regularity computation data granularity exploited creating custom oper ators pipelines interconnection pathways research done department electrical computer engineering university toronto reconfigurable processors namely onechip processor model developed first model tightly integrated reconfigurable logic resources memory fixedlogic processor core using reconfigurable units architecture execution time specialized applications reduced model mapped transmogrifier1 fieldprogrammable sys tem work done ralph wittig 22 followon model called onechip98 integrated memoryconsistent interface hardware implementation allows processor reconfigurable array operate concurrently also provides scheme specifying reconfigurable instructions suitable typical programming models model partially mapped transmogrifier2 fieldprogrammable system work done je jacob 11 onechips architecture extended superscalar processor allows multiple instructions issue simultaneously perform outoforder execution leads much better performance since processor reconfigurable logic execute several instructions parallel performance improvement architecture shows comes memory streaming applica tions applications read block data memory perform computation write back memory multimedia applications characteristic used evaluate architecture previous subsets onechip architecture 1 modeled implementing hardware purpose work properly determine feasibility architecture building full software model capable simulating execution real applications use term onechip refer latest version onechip architecture 11 related work general system combines generalpurpose processor reconfigurable logic known fieldprogrammable custom computing machine fccm research fccms done groups 2 5 7 14 16 18 19 reported speedup obtained combining two techniques however research groups focused aspects reconfigurable fabric compilation system much onechip work focused toward interface two technologies sult applications modified hand modification done compiler simulations model functionality latency reconfigurable fabric specifics fabric architecture work study eect combining reconfigurability advanced technique speedup processors superscalar pipeline focusing interplay use outoforder issue execution one exploit instructionlevel parallelism ap plications without incurring overheads involved reconfiguring specialized hardware previously performance reports groups done using application kernels dct fir filters small kerneloriented applications recently groups 2 18 23 reported performance using complete applications give meaningful results work focused architectures performance full applications 2 onechip architecture section give brief overview onechip architecture including recently added features processors main features proposed 22 11 mipslike risc architecture simple instruction encoding pipelining dynamic scheduling allows outoforder issue completion dynamic reconfiguration reconfigured runtime reconfigurable functional unit rfu integration programmable logic processors pipeline addition onechip extended include superscalar pipeline allows multiple instructions issue per cycle configuration preloading support allows loading configurations ahead time configuration compression support reduces configuration size lru configuration management support reduces number reconfigurations 21 processor pipeline original onechip pipeline described 11 based dlx risc processor described hennessy patterson 9 consists five stages instruction fetch instruction decode id execute ex memory access mem rfu figure 1 onechips pipeline fpga instruction buffer rfurs memory interface rbt controller storage context memory fpga storage context memory figure 2 rfu architecture writeback wb diagram pipeline shown figure 1 rfu integrated parallel ex mem stages performs computations ex stage direct access memory mem stage rfu contains structures memory interface instruction buer reconfiguration bits table rbt reservation stations onechip capable executing multiple instructions parallel ex stage consists multiple functional units dierent types integer units floating point units reconfigurable unit due flexibility reconfigurable unit implement custom instruction programmer compiler generate configuration reconfigurable unit internally pipelined parallelized dynamic scheduling rfu instructions implemented onechip data dependencies rfu cpu instructions handled using rfu reservation stations 22 rfu architecture rfu onechip contains one fpgas fpga controller shown figure 2 fpgas multiple contexts capable holding one configuration programmable logic 4 configurations stored context memory makes fpga capable rapidly switching among configura tions context fpgas configured independently others acts cache configurations one context may active given time instructions target rfu onechip forwarded fpga controller contains reservation stations reconfiguration bits table rbt fpga controller responsible programming fpgas context switching selecting configurations replaced necessary fpga controller also contains buer instructions memory interface rbt acts configuration manager keep track fpga configurations located memory interface fpga controller consists dma controller responsible transferring configurations memory context memory according values rbt also transfers data fpga operate local storage local storage may considered fpga data cache memory multiple fpgas rfu share fpga controller fpga context memory local storage onechip enhanced support configuration compression reduce overhead involved configuring fpga algorithm compressing configurations proposed hauck et al 8 feature modeled simulator results since internal architecture fpga fabric yet defined therefore actual size configuration bitstreams unknown futhermore benchmarks use one configuration eect overhead easily managed preloading configuration architecture also extended support configuration management although fpgas hold multiple configurations hardware limit number configurations hold onechip uses least recently used lru algorithm mechanism swapping configurations fpga lru implemented onechip using table configuration reference bits approach similar additionalreferencebits algorithm described silberschatz galvin 20 fixedwidth shift register used keep track loaded configurations history every context switch shift registers shifted 1 bit right highorder bit register 0 placed inactive configurations 1 active one shift register contains 00000000 means hasnt used long time contains 10101010 means used every context switch configuration history register value 01010000 used recently another value 00101010 later one used recently one value 00000100 therefore configuration selected replacement one smallest value history register notice overall behavior registers keep track location configurations queue recently used configuration come front last one one replaced simulator feature implemented time required benchmarks reconfiguration bits table rbt acts configuration manager keep track fpga configurations located information table includes address configuration flags keep track loaded active configurations rbt described 11 enhanced support algorithm configuration management 3 history configuration also stored table allow lru configuration management select configurations replaced table 1 memory consistency scheme hazard hazard number type actions taken 1 rfu rd 1 flush rfu source addresses cpu cache instruction issues cpu wr 2 prevent rfu reads pending cpu store instructions outstanding 2 cpu rd 3 invalidate rfu destination addresses cpu cache rfu instruction issues prevent cpu reads rfu destination addresses rfu writes destination block 3 rfu wr 5 prevent rfu writes pending cpu load instructions outstanding cpu rd 4 cpu wr 6 prevent cpu writes rfu source addresses rfu reads source block rfu rd 5 rfu wr 7 prevent rfu writes pending cpu store instructions outstanding 6 cpu wr 8 prevent cpu writes rfu destination addresses rfu writes destination block 7 rfu rd 9 prevent rfu reads locked rfu destination addresses 8 rfu wr 10 prevent rfu writes locked rfu source addresses rfu rd 9 rfu wr 11 prevent rfu writes locked rfu destination addresses 23 instruction specification onechip designed obtain speedup mainly memory streaming applications way vector coprocessors general rfu instructions take block data stored memory perform custom operation data store back memory previously onechip supported twooperand rfu instruction flexibility wider range applications extended support three operand rfu instruction twooperand instruction one specify opcode fpga function one source one destination register hold respective memory addresses block sizes instruction source destination block sizes dierent three operand instruction one block sizes replaced another source register allows rfu get source data two dierent memory locations need continuous instruction three blocks size onechip two configuration instructions one configure address instruction used assigning memory addresses rbt configuration instruction preload instruction used prefetching instructions fpga reducing configuration overhead compiler prefetching techniques previously published reconfigurable systems 6 21 24 memory controller onechip allows superscalar dynamic scheduling hence instructions dierent latencies may executed paral lel rfu onechip direct access memory also allowed execute parallel cpu data dependencies rfu cpu system act multiprocessor system providing speed however data dependencies exist potential memory inconsistency must prevented memory consistency scheme previously proposed onechip described 11 allows parallel execution one fpga cpu scheme extended support one fpga rfu nine possible hazards onechip may experience along actions taken prevent listed table 1 scheme preserves memory consistency cpu fpga two fpgas allowed execute concurrently onechip implements memory consistency scheme using block lock table blt blt structure contains four fields entry locks memory blocks prevent undesired accesses information stored table includes block address block size instruction tag srcdst flag 3 simonechip section describe implementation sim onechip simulator models architecture onechip functional executiondriven simulator derived simoutorder simplescalar tool set 1 model behaviour onechip needed already existing simulator capable outoforder execution easily cutomizable used basis add onechips features two existing architecture simulators 1 considered modification simplescalar chosen platform besides complete set tools annotations capability attractive feature since would allow addition new instructions simple manner 31 modifications simoutorder modifications done simoutorder model onechips reservation stations reconfiguration bits table block lock table reconfigurable unit overall functionality simoutorder preserved reservation stations simonechip implemented queue besides already existing scheduler queues basic functional unit bfu instructions memory mem instructions third scheduler queue implemented hold rfu instructions queue referred reconfigurable instructions queue recq dispatch stage detects instructions target rfu places recq future issuing rbt implemented linked list rbt models fgpa controller performing dynamic reconfiguration configuration management functions provided assigning configuration addresses loading configurations perform context switching blt implemented linked list entry holds fields two sources destination memory blocks rfu instruction ensures onechip memory consistency scheme modeling actions taken hazards presented keeping track memory locations currently blocked conflicting instructions properly stalled rfu included rest functional units resource pool functional unit resource configuration 32 pipeline description able adapt onechip simplescalar ar chitecture several modifications done original pipeline simonechips pipeline simoutorder consists six stages fetch dispatch issue execute writeback commit section describe modifications icache dcache fetch dispatch issue bfu writeback commit mem main memory rfu execute figure 3 simonechips pipeline done stage simoutorder places onechips structures included simonechips pipeline shown figure 3 fetch stage remained unmodified fetches instructions icache dispatch queue dispatch stage decodes instructions performs register renaming moves instructions dispatch queue reservation stations three scheduler queues register update unit ruu load store queue lsq reconfigurable instructions queue recq stage adds entries blt lock memory blocks rfu instructions dispatched issue stage identifies ready instructions scheduler queues ruu lsq recq allows proceed pipeline stage also checks blt keep memory consistency stalls corresponding instructions execute stage instructions executed corresponding functional units completed instructions scheduled event queue writeback events stage divided three parallel stages bfu stage mem stage rfu stage bfu stage operations require basic functional units integer floating point executed mem stage memory access operations executed access dcache rfu stage rfu instructions executed writeback stage remained unmodified moves completed operation results functional units ruu dependency chains completing instructions also scanned wake dependent instructions commit stage retires instructions inorder frees resources used instructions commits results completed instructions ruu register file stores lsq commit result data data cache stage clears blt entries remove memory locks corresponding rfu instruction committed blt accessed dispatch issue commit stages memory consistency scheme requires instructions entered blt removed program order pipeline issue execute writeback stages necessarily follow program order since outof order issue execution completion allowed hence memory block locks corresponding entries blt need entered rfu instruction dis patched since dispatching done program order like simonechip simulator oclibh fpgaconf ssgcc compiler source code c onechip binary oc gcc compiler simonechip source code simulation statistics figure 4 simonechips simulation process wise entries blt need removed rfu instructions commit since committing also performed program order actions memory consistency scheme taken issue stage issue stage allowed probe blt memory locks instructions conflict locked memory blocks prevented issuing point others allowed proceed provided dependencies 33 rfu instructions annotation instructions simplescalar useful creating new instructions attached opcode assembly files assembler translate append annotation field assembled instructions taking advantage feature new instructions created without need modify assembler onechips rfu instructions disguised already existing annotated instructions simulator recognize rfu instruction model corresponding operation without annotation instructions treated regular ones annotation become instructions target reconfigurable unit four instructions defined onechip ie two rfu operation instructions two configuration instructions created simonechip macros used translate c specification corresponding annotated assembly instruction 34 programming model currently programming model onechip use circuit libraries programming simonechip done c user may use existing configurations library configurations create custom ones configurations defined c several macros available accessing memory instruction fields complete simulation process shown figure 4 c program includes calls rfu instructions compiled simplescalar gcc compiler ssgcc along onechip library oclibh produce binary file executed simulator simonechip program configurations specified fpgaconf must previously compiled gcc along simulator source code produce simulator binaries ready simulator simulate execution binary produce corresponding statistics simonechips processor specification defined commandline arguments one specify processor core parameters fetch decode bandwidth internal queues sizes number execution units memory hierarchy branch predictor also modified 341 onechip library library defines following five macros oc configaddressfunc addr used specifying configuration address specified function associate function func address addr fpga configuration bits taken enter corresponding entry blt oc preloadfunc used preloading configuration associated specified function func available fpga context rec 2addrfunc src addr dst addr src size dst size twooperand reconfigurable instruction func fpga function number src addr dst addr source destination block addresses src size dst size source destination block sizes encoded rec 3addrfunc src1 addr src2 addr dst addr blk size threeoperand reconfigurable instruction func fpga function number src1 addr src2 addr dst addr source1 source2 destination block addresses blk size block size encoded reconfigurable instructions perform context switch activate function func execute corresponding operation associated also lock respective source destination blocks memory entering corresponding fields blt long function takes execute finished blt entries corresponding instruction cleared oc encodesizesize macro used encoding size memory blocks obtains encoded value table defined function log2 size 1 macro used encode block sizes reconfigurable instructions example b c defined unsigned char a16 b16 c16 activate function 2 perform operation arrays b source data array c destination data encoded size passed reconfigurable instruction log216 342 configuration definition behavior rfu modeled highlevel functional simulation given inputs function produces corresponding outputs without performing detailed microarchitecture simulation programmable logic configurations defined follows configuration address ie location configuration bits memory operation latency ie number cycles result ready use issue latency ie number cycles another operation issued resource expression describes reconfigurable function separation instruction latency operation issue latencies allows specification pipelined con figurations example assume one configuration takes 20 cycles complete one instruction configuration pipelined one instruction started every 4 cycles case operation latency 20 issue latency 4 hence configuration 20 executing instructions time throughput configuration implied 20 per instruction expression field semantics configuration specified c expression implements configuration defined expression must modify processor state aected instructions execution memory accesses defconf expression must done memory interface macros available memory reads writes accessing general purpose registers floating point miscellaneous registers accessing value rfu instruction operand field values creating block mask decoding block size configuration examples included 3 4 programming simonechip section present example port application uses rfu onechip get speedup application implemented 8tap fir filter consider c code file called firc 1 file firc 2 3 include stdioh 4 5 define taps 8 define maxinputs 1024 7 8 int 9 int inputsmaxinputs 10 11 void main 12 int j 13 int x 14 int ymaxinputs 15 inputs random numbers 17 23 fir filter kernel 24 25 j 27 28 x 30 inner loop fir filter kernel lines 2527 firc ported executed entirely onechip rfu need modifications c code file firocc reflects changes shown 1 file firocc 2 3 include stdioh 4 include oclibh 5 7 define maxinputs 1024 8 9 int 10 int inputsmaxinputs 12 void main 13 int j 14 int x 15 int ymaxinputs 17 occonfigaddress0 0x7fffc000 19 20 set inputs random numbers 21 27 fir filter kernel 28 29 rec3addr0 x coef yi ocencodesize8 30 x 33 printfnfir filter donen 34 first step including onechip library code shown line 4 firocc second step defining address configuration bitstream fir filter case using configuration 0 memory address 0x7fffc000 shown line 17 third step notice lines 2527 firc removed replaced 3operand rfu instruction line 29 firocc instruction using configuration 0 passing address two source memory blocks x coef pointers well address destination memory block iteration yi block size 8 passed using function oc encodesize previous three changes necessary furthermore want reduce configuration overhead would introduce preload instruction line 18 instruction tells processor configuration 0 used soon way time gets execute rfu instruc tion configuration already loaded time spent waiting configuration loaded instruction necessary configuration loaded fpga processor automatically load c code modified use rfu need define fpga configuration perform fir filter configurations defined fpgaconf fir filter definition used shown 1 configuration 3operand instruction 2 used fir filter program 3 4 defconf0x7fffc000 17 17 5 int ocindex indexing 7 unsigned int ocword storing words 8 unsigned int ocresult storing result 9 12 ocindex ocmaskoc3abs 13 ocindex 14 17 ocresult ocword 19 writewordocresult gproc3adr configuration equivalent inner loop fir filter kernel lines 2527 firc note configuration memory access done memory interface line 4 defines configuration address 0x7fffc000 operation issue latencies 17 lines 1113 define iteration loop fir fil ter line 15 reads word memory location defined address stored general purpose register contains one source address plus corresponding memory oset way line 16 reads word source block multiplies data previously read stored oc word variable line 17 simply accumulates multiplied values across loop iterations loop finished line 19 writes result memory location defined address stored general purpose register destination block address simulator generate statistics number instructions executed program speedup obtained simonechip verified 5 applications evaluate performance onechip architecture several benchmark applications compiled executed simonechip 51 experimental setup experiments four steps performed application step one identification parts application suitable implementation hard ware step two modeling hardware implementation identified parts code step three replacement identified code application corresponding hardware function call step four execution verification original ported versions application pipeline configuration used simulations default used simplescalar among relevant characteristics instruction fetch queue size 4 instructions instruction decode issue commit bandwidths 4 instructions per cycle 16entry register update unit ruu 8entry loadstore queue lsq number execution units available pipeline 4 integer alus 1 integer multiplierdivider 2 memory system ports available cpu 4 floatingpoint alus 1 floatingpoint multiplierdivider also case simonechip 1 reconfigurable functional unit rfu 8entry rbt 32entry blt used branch predictor cache configuration remained unmodified well 52 benchmark applications currently standard benchmark suite reconfigurable processors c lee et al13 university california los angeles proposed set benchmarks evaluating multimedia communication sys tems called mediabench since current reconfigurable processors available used mostly communications applications mediabench taken suite evaluating onechip applications used evaluation could ported simplescalar due complexity makefiles due missing libraries however rest applications provide good feedback architectures performance 53 profiles profiling execution application helps identify parts application take lot time execute hence candidates rewriting make execute faster profiling applications performed using gnus profiler gprof included gnus binutils 291 package profiling information identified specific functions application worth improving executing specialized hardware implemented onechip reconfigurable unit port application onechip piece code must long execution time perform memory accesses regular manner applications suitable vector processors general application sped vector processor also suitable onechip 54 analysis modifications four applications met requirements ported onechip 3 jpeg image compression adpcm audio coding pegwit data encryption mpeg2 video encoding encoder decoder one ported modifications applications done hand ie compiler technologies used rfu timing applications assume memory accesses dominate computational logic bottleneck memory bandwidth also assume one memory access perfomed one cycle latency operation obtained counting total number memory accesses performed opera tion timing approach may precise highly compute intensive operations case applications 6 results original modified versions eight chosen applications executed simulator application tested three dierent sizes data one small one medium one large four experiments done application first experiment executing original applications inorder issue verify many cycles one takes execute second experiment executed onechip version table 2 speedup application data size onechip inorder onechip outorder cd outorder original outorder onechip total jpeg encode small 137x 134x 229x 225x 308x medium 136x 133x 229x 224x 305x large 138x 135x 233x 229x 315x jpeg decode small 129x 120x 247x 229x 296x medium 129x 119x 252x 234x 301x large 125x 116x 253x 235x 293x adpcm encode small 2238x 1704x 154x 118x 2631x medium 2625x 1785x 162x 110x 2894x large 2992x 2057x 156x 107x 3202x large 2443x 1627x 161x 107x 2613x pegwit encrypt small 146x 143x 209x 206x 300x medium 133x 136x 220x 226x 300x large 116x 124x 248x 265x 307x pegwit decrypt small 140x 142x 208x 211x 295x medium 128x 132x 227x 235x 300x large 113x 118x 262x 272x 308x medium 507x 570x 207x 233x 1182x large 523x 591x 208x 236x 1233x mpeg2 encode small 116x 114x 190x 187x 216x large 128x 124x 187x 181x 232x application also inorder issue b third experiment executing original version applications outoforder issue c fourth last experiment executing onechip version outoforder issue way could verify speedup obtained using features reconfigurable unit outof order issue onechip pipeline output files verified correct data encoded decoded simulator speedup obtained experiments shown table 2 first column ab shows speedup obtained using reconfigurable unit second column cd shows speedup obtained introducing reconfigurable unit outoforder issue pipeline third column ac shows speedup obtained using outoforder issue fourth column bd shows speedup obtained introducing outoforder issue pipeline reconfigurable unit onechip fifth column ad shows total speedup obtained using reconfigurable unit outof order issue time analyzing simulation statistics note blt instruction stalls ie instructions stalled due memory locks applications except jpeg means either rfu fast enough keep program execution memory accesses performed proximity rfu instruction execution second one actual case important confuse blt stalls prevent data hazards stalls due unavailable resources structural hazards two consecutive rfu instructions reads writes likely structural hazard since one rfu trailing rfu instruction stalled rfu available considered blt stall case jpeg cpu reads writes performed proximity rfu instructions shown table 3 rfu instructions shows total dynamic table 3 jpeg rfu instructions application data size rfu instructions x instruction stalls stalls per rfu instruction rfu overlapping jpeg encode small 851 99531 11696 1104 large 18432 2156508 11700 1100 large 18432 2264375 12285 515 count rfu instructions program blt instruction stalls number cpu reads writes stalled rfu write executing type hazard present next column shows stalls per rfu instruction last one shows average rfu instruction overlap cpu execution note 128 operation latency jpeg see jpeg encoder overlap approximately 11 instructions jpeg decoder overlap approximately 5 instructions 61 discussion table 3 see approximate overlap 11 instructions jpeg decoder means rfu instruction issued 11 following instructions also allowed issue outoforder data dependencies even rfu issue operation latencies improved ie reduced new hardware technologies maximum improvement application observed configuration latency 11 cycles latency lower 11 improve performance 11 overlapping instructions still need executed rfu need wait observed jpeg decoder latency 5 cycles rest applications overlap improvement rfu latency reflected overall performance adpcm shows fairly large speedup onechip application perform data validation operations besides calling encoder kernel data simply read standard input encoded blocks 1000 bytes time written standard put behaviour application like kernel expected adpcm application speedup due amdahls law 9 states performance improvement gained using faster mode execution limited fraction time faster mode used adpcms performance clearly depends size data larger data less time application reads writes data time rfu executes instructions blt instruction stalls application pegwits performance also shows dependence data size however dierent behavior observed rfu outoforder issue features rfu shows better performance small data outoforder issue shows better performance improvement larger data overall speedup features greater input data larger decoder application makes number rfu instruction calls independent data size even data size call dierent latency every call encoder almost thing happens blt instruction stalls originated application mpeg2s performance also data size dependent case decoder larger data greater performance improvement applies rfu feature outoforder issue feature case encoder performance improvement shown larger frame sizes get larger higher performance improvement tests small medium input data dierent frame size almost number frames tests medium large data frame size dierent number frames application blt instruction stalls applications see outoforder issue produces big gain ac using rfu still adds speedup application speedup obtained dynamic scheduling ranges 160 253 speedup obtained rfu abranges 113 29 using time even technique limits potential gain produce overall speedup increased dynamic scheduling seems eective applications except ad pcm biggest gain comes using rfu leads us think kerneloriented applications better use rfu without complexity outof order issue applications better use dynamic scheduling possibly augmented rfu 7 conclusion future work work behavior onechip architecture model studied performance measured executing several otheshelf software applications software model system results obtained confirm performance improvement architecture dsptype applications work question arises whether additional hardware cost complex structure block lock table really necessary reconfigurable processors shown concept blt accomplish purpose maintaining memory consistency closely linking reconfigurable logic memory parallel execution desired cpu pfu however considering one four applications ie jpeg used research actually uses blt takes advantage conclude removing simply making cpu stall memory access occurs rfu executing degrade performance significantly types benchmarks studied jpeg average 11 overlapping instructions 86 configuration operation latency slot 128 rfu used approximately 20 time jpeg encoder performance improvement overlapping 172 small amount compared performance improvement dynamic schedul ing approximately 56 ie 229 speedup hence dynamic scheduling improves performance significantly used relatively short operation delay instructions opposed onechips rfu instructions large operation delays based four applications work appears number contexts need large achieve good performance improvement rfu applications one context used application considerable speedup obtained applications second context could provided increase improvement much first context based profiles could implement dierent routine second context way first one would frequently used another question arises work whether configurations small enough fit todays reconfigurable hardware even implemented hardware implementations dsp structures done groups 22 11 12 even shown outperform digital signal processors proven fit existing altera xilinx devices maximum 36000 logic gates todays fpgas 1 million system gates available estimate silicon area version onechip start area processor required much larger simple processor used previous version onechip similar processor mips r10000 processor core 15 4way superscalar processor supports outoforder execution includes 32kb instruction cache 32kb data cache using cmos 035m process die area approximately estimate fabrication technology approaches 013m process size processor core would approximately 41mm 2 onechip98 processor 10 includes small processor core insignificant area eightcontext fpga structure 85k gates logic 8 mbytes sram 018m process estimated take 550mm 2 scaling 013m brings 287mm 2 add 41mm 2 processor complete onechip device would quite manufacturable obviously would desirable add gates fpga logic process technology continues shrink would easy also conclude dynamic scheduling important achieve good performance produces big gain number applications kernel oriented applications gain obtained rfu bigger complete applications biggest gain obtained outoforder issue execution investigation necessary area compilers reconfigurable processors specifically compiler designed onechip architecture needed fully exploit better estimate advantages disadvantages architectures features developing compilation system allows automatic detection structures suitable onechip rfu well generating corresponding configuration replacing structure program allow investigation optimal number contexts rfu compiler able preload configurations reduce delays also make optimal use blt scheduling many instructions rfu delay slot also future work investigate architecture rfu work assumed optimal rfu work done type logic blocks interconnection resources used fpga simulator extended properly simulate fpga fabric configuration latency issues ye et al 23 modeled rfu execution latencies using simple instructionlevel transistorlevel models however architecture target finegrain instructions onechip targets coarsegrain instructions point becomes dicult make detailed comparison onechips performance current reconfigurable systems standard application benchmarks available reconfigurable processors however groups reported performance improvement results similar ones presented paper using mediabench spec benchmarks 2 23 although onechip shares certain similarities systems 2 19 target memorystreaming applications focus looplevel code optimizations standardized set benchmarks metrics reconfigurable processors needed properly evaluate dierences 8 acknowledgements would like akcnowlegde chameleon systems inc financially supporting onechip project jorge carrillo also supported uoft open fellowship would also like thank reviewers helpful comments 9 r simplescalar tool set garp architecture c compiler reconfigurable architecture compiler configuration prefetch single context reconfigurable coprocessors chimaera reconfigurable functional unit configuration compression xilinx xc6200 fpga computer architecture quantitative approach memory interfacing onechip reconfigurable processor memory interfacing instruction specification reconfigurable processors tool evaluating synthesizing multimedia communications systems morphosys parallel reconfigurable system quantitative analysis reconfigurable coprocessors multimedia applications rsim executiondriven simulator ilpbased sharedmemory multiprocessors uniprocessors napa adaptive processing architecture operating system concepts compiler directed approach hiding configuration latency chameleon processors onechip fpga processor reconfigurable logic tr highperformance microarchitecture hardwareprogrammable functional units mediabench configuration prefetch single context reconfigurable coprocessors computer architecture 2nd ed memory interfacing instruction specification reconfigurable processors chimaera garp architecture c compiler piperench morphosys parallel reconfigurable system compiler directed approach hiding configuration latency chameleon processors chimaera reconfigurable functional unit configuration compression xilinx xc6200 fpga napa adaptive processing architecture quantitative analysis reconfigurable coprocessors multimedia applications fpgabased structures online fft dct ctr hamid noori farhad mehdipour kazuaki murakami koji inoue maziar goudarzi interactive presentation generating executing multiexit custom instructions adaptive extensible processor proceedings conference design automation test europe april 1620 2007 nice france scott hauck thomas w fry matthew hosler jeffrey p kao chimaera reconfigurable functional unit ieee transactions large scale integration vlsi systems v12 n2 p206217 february 2004 paul beckett andrew jennings towards nanocomputer architecture australian computer science communications v24 n3 p141150 januaryfebruary 2002 nathan clark manjunath kudlur hyunchul park scott mahlke krisztian flautner applicationspecific processing generalpurpose core via transparent instruction set customization proceedings 37th annual ieeeacm international symposium microarchitecture p3040 december 0408 2004 portland oregon exploring design space lutbased transparent accelerators proceedings 2005 international conference compilers architectures synthesis embedded systems september 2427 2005 san francisco california usa shobana padmanabhan phillip jones david v schuehler scott j friedman praveen krishnamurthy huakai zhang roger chamberlain ron k cytron jason fritts john w lockwood extracting improving microarchitecture performance reconfigurable architectures international journal parallel programming v33 n2 p115136 june 2005 philip garcia katherine compton michael schulte emily blem wenyin fu overview reconfigurable hardware embedded systems eurasip journal embedded systems v2006 n1 p1313 january 2006
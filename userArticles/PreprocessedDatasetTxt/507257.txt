regular viewpoint paprocesses pa process algebra allowing nondeterminism sequential parallel compositions recursion suggest viewing paprocesses astrees usingtreeautomata techniques verification problems pa main result set iterated predecessors regular set paprocesses regular tree language similarly iterated successors furthermore corresponding tree automata built effectively polynomial time many immediate applications verification problems paprocesses among simple general modelchecking algorithm b introduction verication innite state processes active eld research today concurrencytheory community course always active petrinets com munity researchers involved process algebra modelchecking really became interested innite state processes proof bisimulation decidable normed bpaprocesses bbk87 prompted several researchers investigate decidability issues bpp bpa without normedness hypothesis see chm94 mol96 be97 partial survey bpa bpp pa bpa inondeterminism recursionj fragment process algebra bpp inondeterminism parallel composition recursionj fragment pa beh95 combines much less tractable years ago decidability results bpp bpa presented pa still beyond reach current techniques mayr showed decidability reachability pa processes may97c extended decidability modelchecking pa wrt ef fragment ctl may97b important breakthrough allowing mayr successfully attack powerful process algebras may97a decidability results pa presented researchers eg ku96 ku97 jkm98 eld asking new insights decidability proofs may97b following papers certainly trivial constructions quite complex hard check easy see directions results andor proofs could adapted generalized without much trouble probably complexity cannot avoided techniques currently available eld believe point important look new insights concepts techniques simplify eld rather trying extend already existing results contribution paper show treeautomata techniques greatly help dealing pa main results two regularity theorems stating post l resp pre l set congurations reachable resp allowing reach conguration l regular tree language l giving simple polynomialtime constructions associated automata many important consequences follow directly including simple algorithm modelchecking paprocesses work regularity post l pre l could obtained combination two main insights 1 treeautomata techniques proved powerful several elds see cksv97 useful processalgebraic community well pa simple termrewrite system special contextsensitive rewriting strategy unlike headrewriting presence sequential composition operator rr n0123456789 2 syntactic congruences used simplify notations simple process algebras help one get closer intended semantics processes break regularity behavior decidability results much simpler one introduces syntactic congruences later stage besides general approach plan paper start recalling basics treeautomata theory 1 introduce denition pa process algebra 2 explain sets pa processes seen tree languages 3 give simple proof showing post pre regular tree languages start listing applications verication problems move post l pre l l regular language 5 main technical results devote 6 important applications modelchecking end extension reachability modelchecking constraints 7 simple important techniques allowing deal pa processes modulo structural equivalence 8 related work several recent works eld use treeautomata describe behaviour systems use describe set congurations set reachable congurations pushdown automaton form regular word language proven bc64 extended cau92 applications modelchecking pushdown automata proposed fww97 bem97 decidability rstorder theory rewrite relation induced ground term rewrite system relies ground tree transducers dt90 note pa dened conditional ground rewrite system among applications develop regularity theorems several suggested mayrs work pa may97c may97b andor earlier work rpps ks97a ks97b regular tree languages tree automata recall basic facts tree automata regular tree languages details reader referred classical source eg cdg ranked alphabet nite set symbols f together arity function partitions f according arities set terms f call nite trees trees tree language f subset f nite bottomup tree automaton tuple hf q f ri f ranked alphabet nite set states f q subset nal states r nite set transition rules form fq arity jf symbol f 2 f tree automata rules also allow transition rules form transition rules dene rewrite relation terms built f q seeing states q nullary symbols works bottomup rst nullary symbols leaves inria regular viewpoint paprocesses 5 replaced states q quasileaf symbols immediately top leaves q replaced states q write rewritten number steps q 2 q say accepted rewritten nal state write la set terms accepted tree language coincide la regular tree language regular tree languages closed complementation union etc example let f given f ffg automaton accepting set occurs even number times given q g let gfga b rewrites follows gfga b 7gamma gfgq 0 hence 7gamma q 0 2 f 2 la replace r automaton accepting set even number gs along every path root leaf size tree automaton denoted jaj number states augmented size rules rule fq 2 paper shall never precise counting jqj number states automata notice xed f largest arity 2 jaj ojqj tree automaton deterministic transition rules distinct lefthand sides rule otherwise nondeterministic given nondeterministic tree automaton one use classical isubset constructionj build deterministic tree automaton accepting language construction involves potential exponential blowup size telling whether la empty nonnecessarily deterministic tree automaton done time ojaj telling whether given tree accepted given nonnecessarily deterministic done time polynomial jaj tree automaton completely specied also complete f 2 fn q q rule fq adding sink state obvious rules extended complete one accepting language 2 pa process algebra presentation pa explicitly refrain writing terms modulo simplication laws eg neutral laws 0 hence use isnil predicate see inspired chr93 viewpoint agreement earliest works general process algebras like ccs acp etc key condition results next section clearly prevent considering terms modulo structural congruence later stage demonstrate section 8 rr n0123456789 6 dlugiez phschnoebelen 21 syntax set action names set process variables set paterms given following abstract syntax given 2 epa write vart set process variables occurring subtermst set subterms includes guarded pa declaration nite set ng process rewrite rules note x need distinct write var delta set process variables occurring delta subterms delta union subtermst right lefthand side rule delta rule ix tj deltag deltax a2act delta x var set variables delta provides rewrite following assume xed var delta 22 semantics pa declaration delta denes labeled transition relation delta epa theta act theta epa always omit delta subscript confusion possible use standard notations abbreviations w inductively dened via following sos rules x predicate inductively dened ae true false otherwise isnil predicate syntactic test termination indeed lemma 21 following three properties equivalent 1 2 6 ie terminated 3 inria regular viewpoint paprocesses 7 proof 3 derivation used x induction prove obvious denition tree language shall use tree automata recognize sets terms epa possible epa f f given f kg course shall keep using usual inx notation terms built ij ikj begin one simplest languages epa proposition 31 singleton tree language ftg regular automaton ftg needs jtj states similarly immediate consequence lemma 21 corollary 32 l set terminated processes regular tree language automaton l needs one state 4 regularity reachability set post def denote set iterated predecessors resp set iterated successors also called reachability set notions take account sequences w 2 act action names allowing move 0 post indeed forget action names section 7 devoted pre ct post ct c act given two tree languages l l 0 epa let 41 regularity pre dene l t2epa innite family tree languages least solution following set recursive equations intuition quasiregular equations satised rr n0123456789 pre 1 observe equations dene l containing ly process variable allowing one step transition lemma 41 2 epa l proof sketch proof u induction length transition sequence u case analysis sos rule gave last transition induction structure proof u 2 l implies u xpoint induction followed case analysis summand equation used relies simple lemmas reachability 1 equations 1 easily transformed regular equations introducing new variables sets ftg denitions l tt 0 given l depends nite number l u fugs namely us subtermst subterms delta 1 corollary 42 2 epa set l regular tree language corresponding tree automaton ojdeltaj states entails theorem 43 2 epa pre pret pre regular tree languages 42 regularity post dene l 0 two innite families tree languages least solution following set recursive equations aim l 0 coincide section 51 shall see corollary 42 holds even delta innite var delta must nite inria regular viewpoint paprocesses 9 post resp post x x 2 easily turned regular equations given l 0 l 00 depends nite number l 0 u fugs corollary 44 2 epa sets l 0 l 00 regular tree languages corresponding tree automata ojdeltaj states pre easily show lemma 45 2 epa l 0 post l 00 hence corollary theorem 46 2 epa post postt post regular tree languages constructed eoeectively theorems 43 46 generalized sections 5 7 however found enlightening give simple proofs simplest variants regularity results already theorems 43 46 eoeective constructibility associated automata many applications 43 applications theorem 47 reachability problem iis reachable 0 j p proof combine cost membership testing nondeterministic tree automata regularity pre 0 regularity post dioeerent presentation pa delta may97c shows reachability problem npcomplete section 8 describe get result byproduct approach many problems solved simple application theorems 43 46 boundedness post innite rr n0123456789 covering aka controlstate reachability reach 0 resp occur inclusion states reachable 1 also reachable 2 question modulo regularity preserving operation eg projection liveness given delta live reachable states least one transition delta 0 red 5 regularity post l pre l regular language section prove regularity pre l post l regular language l notational simplicity given two states q q 0 automaton denote q k q 0 state q 00 q k q 0 possibly using rules 51 regularity pre ingredients pre assume al automaton recognizing l epa pre new automaton combining several ingredients ffl completely specied automaton accepting terminated processes see corollary 32 ffl al automaton accepting l ffl also use boolean record whether rewriting steps done states pre state pre 3tuple q q denotes set states relevant automaton transition rules pre transition rules pre dened follows type 0 rules form 0 7gamma q 7gamma q l type 1a rules form x 7gamma q q l true st exists u 7gamma q l type 1b rules form x 7gamma q 7gamma q l type 2 rules form q type 3a rules form q state inria regular viewpoint paprocesses 11 type 3b rules form q lemma 51 2 epa pre u 2 epa p 2 n p u u proof structural induction three cases 1 pre rules observe rules type 0 1a 1b exactly correspond lemma requires 2 required pre type 3 rule q 1 induction hypothesis entails 1 corresponding rewrite 1 2 pre pre used type 3b rule b used type 3a rule q 1 nal state therefore u 1 2 l terminated process hence 1 2 conversely assume 7gamma q l u rst case ind hyp entails 1 pre al pre use type 3b rule show pre u al l second case al nal state use type 3a rule show pre 3 case similar previous one actually simpler let nal states pre states q q l nal state al u u accepted al ioe pre accepts use assumption completely specied theorem 52 regularity 1 l regular subset epa pre l regular 2 furthermore automaton al recognizing l possible construct polynomial time automaton pre recognizing pre l al k states pre needs 4k states rr n0123456789 proof 1 immediate consequence lemma 51 observe result need niteness delta var delta must nite 2 building pre eoeectively requires eoeective way listing type 1a rules done computing product ax automaton post x al exists u 7gamma q l ioe language accepted nal states fq nal state ax g notempty gives us pairs q q l need type 1a rules observe need niteness delta build ax 52 regularity post ingredients post assume al automaton recognizing l epa post new automaton combining several ingredients automata al previous construction time need assume completely specied automata delta completely specied automaton recognizing subterms delta states q 2 subterms delta ensure delta taking transition rules belongs subterms delta addition automaton sink state q obvious transitions completely specied automaton ffl use boolean b record whether rewrite steps occurred states post states post 4uples q transition rules post transition rules type 0 rules form 0 7gamma q type 1 rules form x 7gamma q 7gamma q l type 2 rules form q rule delta x al 7gamma q l type 3 rules form type 4a rules form inria regular viewpoint paprocesses 13 type 4b rules form nal state lemma 53 2 epa post u 2 epa u p u al proof rst prove direction induction length k rewrite post distinguish four cases 1 used type 0 type 1 rule taking saties requirements 2 k 1 last rewrite step used type 2 rule rewrite form z true ind hyp u 0 p 0 st u existence type 2 rule entails taking requirements 3 k 1 last rewrite step used type 4 rule 1 2 type 4 rule applied top two rewrite sequences 7gamma q 2 ind hyp gives us last rule type 4a rule b taking requirements otherwise last rule type 4b rule q 1 nal state 1 entails 1 terminated process hence taking requirements 4 k 1 last rewrite step used type 3 rule case similar actually simpler previous one direction assume u p accompanying conditions ac proceed induction length transition sequence ie p followed structural induction u cases 1 acs ensure use type 0 rule show post 2 0 like previous case type 1 rule 3 0 sequence form x 1 acs read subterms delta take q 0 rr n0123456789 14 dlugiez phschnoebelen st l one q 0 must exist let b 0 false ioe ind hyp gives us post must type 2 rule q use show post 4 combination u 1 additionally 2 rewrites 7gamma q l u delta used al l u delta dene b according p ind hyp entails post two cases 1 2 l q 1 nal state post type 4b rule q 1 use 1 62 l type 4a rule use 5 similar previous case actually simpler let nal states post states q q l nal state al post accepts term ioe u u accepted al ioe belongs post l theorem 54 regularity 1 l regular subset epa post l regular 2 furthermore automaton al recognizing l possible construct polynomial time automaton post recognizing post l al k states pre needs okjdeltaj states proof obvious previous construction results relate pre resp post natural question ask relation j ie ft u j ug recognizable sense relevant notion recognizability related problem linked ground tree transducers gtts short details since shown relation induced ground rewrite system recognizable gtt tried extend result pa case rules ground rewrite rules simple left hand sides notion prex rewriting unfortunately prex rewriting entails stable contexts natural extensions gtt could handle conditional rules immediately able recognize recursively enumerable relation 6 modelchecking pa processes section show simple approach modelchecking problem solved may97b see one immediate application main regularity theorems inria regular viewpoint paprocesses 15 consider set p atomic propositions mod p denotes set pa processes p holds consider propositions p mod p regular treelanguage thus p could make alabeled step right nowj ithere least two occurences x inside tj ithere exactly one occurence x nonfrozen positionj logic ef following syntax semantics thus ex reads iit possible reach one step state st j ef reads iit possible reach via sequence steps state st j denition 61 modelchecking problem ef pa inputs given delta given epa given ef answer yes ioe dene mod def mod mod theorem 62 1 ef formula mod regular tree language 2 given treeautomata ap recognizing regular sets mod p tree automaton recognizing mod built eoeectively proof corollary 3 regularity theorems gives us decision procedure modelchecking problem build automaton mod check whether accepts estimate complexity approach term jj n alt dene n alt number alternation negations temporal connectives rr n0123456789 theorem 63 modelchecking automaton mod computed time2 jjjdeltaj2 ojjjdeltaj proof assume automata mod p size bounded constant construct automaton mod applying usual automatatheoretic constructions intersection union complementation regular tree languages invoking regularity theorems pre pre constructions polynomial except complementation polynomial constructions would 2 ojj size resulting automaton negations involving complementation cause nonelementary blowup negations pushed inward except cannot cross temporal connectives ef ex one exponential blowup determinization level alternation repeated n alt times yielding given bound number states hence overall complexity procedure described may97b nonelementary today known lower bound pspacehard observe computing representation mod general telling whether given belongs observe also results allow modelchecking approches based combinations forward backward methods theorem 62 relied standard backward approach 7 reachability constraints section consider reachability constraints let c act word language action names write c 0 reached constraint c extend notations write pre cl post obvious meaning observe even assume c regular problem telling whether c ie whether post ct empty undecidable pa algebra proved reduction intersection problem contextfree languages follows let sigma alphabet distinguished symbol use two copies every letter sigma fg contextfree languages dened bpa pa without k contextfree language l 1 resp l 2 sigma dene pa rules x 1 w w rules dont overlap introduce regular holds ioe undecidable inria regular viewpoint paprocesses 17 section give suoecient conditions c problem becomes decidable compute cconstrained pre regular tree language recall shue w k w 0 two nite words set words one obtain interleaving w w 0 arbitary way denition 71 ffl g nite seqdecomposition c ioe w w 0 2 act g nite paraldecomposition c ioe w w crucial point denition seqdecomposition c must apply possible ways splitting word c even applies decomposition ww 0 one c one c 0 contains observe formal dioeerence seqdecomposition paraldecomposition comes fact w k w 0 set shues w w 0 usually contains several elements denition 72 family cng languages act nite decomposition system ioe every c 2 c admits seqdecomposition paraldecomposition using c c c act admit nite decompositions even regular case consider ab assume nite paraldecomposition every k shue k b k c hence must must exist shue w 00 k b k 0 w 00 2 c possible hence k distinct contradicting niteness simple example nite decomposition system ie set singleton languages words shorter k paraldecomposition fwg ffw 1 gg w subwords 2 w w 0 corresponding remainder example shows decomposability composability pairs c appears decomposition member c generally linear weight function form w def n sets c k belong nite decomposition system assume c nite decomposition system shall show theorem 73 regularity regular l epa c 2 c pre cl post cl regular tree languages subword w w 0 obtained erasing letters w position rr n0123456789 ingredients post c build post c way post states contain new c 2 c component states post c states post c 5uples q transition rules post c transition rules type 0 rules form 0 7gamma q type 1 rules form x 7gamma q type 2 rules form q rule delta x al appears seqdecomposition c type 3 rules form appears paraldecomposition c 00 type 4a rules form type 4b rules form state st c c 0 appears seqdecomposition c 00 lemma 74 2 epa post c u 2 epa w 2 c u w u al proof post c post equipped new component proof follows exactly lines proof lemma 53 refer earlier proof explain deal new c components direction lemma 53 new observations 4 cases 1 take 2 k 1 last rewrite step used type 2 rule use fact w 3 k 1 last rewrite step used type 4 rule use fact cc 0 c 00 4 k 1 last rewrite step used type 3 rule use fact w 1 2 c entail exists least one shuing w w 1 w 2 st w 2 c 00 inria regular viewpoint paprocesses 19 direction lemma 53 new observations 5 cases 1 0 type 0 rules allow cs containing 2 3 0 sequence form x must c seqdecomposition c st 2 c 0 w type 2 rule c use 4 type 4a rule need otherwise pair c seq decomposition c st w pair gives us type 4b rule need 5 shue w 1 w 2 therefore paraldecomposition c st w pair gives us type 3 rule need let nal states post c q nal state al post c accepts term ioe 2 post ct set nal states easily adapted recognize post ingredients pre c construction pre additional c 2 c component states pre state pre 4tuple q nal states q nal state al c constraint satisfy transition rules pre transition rules pre dened follows type 0 rules form 0 7gamma q type 1a rules form x 7gamma q q l true c st exists u u 7gamma q l type 1b rules form x 7gamma q type 2 rules form appears paraldecomposition c 00 rr n0123456789 type 3a rules form nal state c c 0 appears seqdecomposition c 00 type 3b rules form lemma 75 2 epa pre c u 2 epa u u proof pre c pre equipped new component proof follows exactly lines proof lemma 53 refer earlier proof explain deal new c components 1 x conditions c component existence rules type 0 1a 1b agree statement lemma 2 pre type 3 rule c also ind hyp gives type 3b case w 1 2 c type 3a case use c either 1 rst case apply induction hypothesis c 1 c 0 containing 2 use type 3b rule second case must seqdecomposition c w use ind hyp type 3a rule 3 case similar previous one direction uses pair accouting w paraldecomposition c direction uses crucial fact whenever shuing w w 1 w 2 particular w c must contain 71 applications modelchecking results let us apply modelchecking method section 6 extended ef logic allow hci formulas decomposable c semantics given mod hci def inria regular viewpoint paprocesses 21 decomposability c quite general condition excludes undecidable situations would exist general regular case immediately includes extensions proposed may97b observe possible combine decomposable constraints already modelchecking algorithm c 2 c c decomposable deal hc directly ie without constructing nite decomposition system containing c c 0 obvious extend construction pre c pre cc 0 several c components dealt simultaneously also deal hc c 0 hcc 0 directly since pre c c 0 l pre cc 0 l pre cl pre c 0 l pre cpre c 0 l c c 0 l 8 structural equivalence pa terms section investigate congruence j induced pa terms following equations choice equations motivated fact several recent works pa extensions consider processes upto congruence techniques could deal variants useful explain denition pa compares denition used may97c may97b consider transition system terms epa terms mayr considers transition system seen equivalence classes modulo j epa terms write j set ft g transition relation used mayr coincides transition relation dened following speak ipaj j mean transition system one obtains jclasses terms states transitions given 4 approach general sense dene approach framework contrast one reasons modulo j right start one loses information required revert approach example reachability problem ido u j theorem 47 asks precise form u reachability problem solved may97c asks u modulo j framework stated igiven u 0 rr n0123456789 22 dlugiez phschnoebelen see framework impossible state problem course rst motivation framework allows two regularity theorems rest section devoted applications treeautomata approach problems paj aim exhaustivity rather simply want show framework allows solving stating problems framework variants 81 structural equivalence regularity associativitycommutativity axioms satised k call permutative axioms write p u 0 permutatively equivalent axioms dening 0 neutral element k call simplication axioms write u u simplication ie u obtained applying simplication axioms left right positions note wellfounded partial ordering write gamma1 simplication normal form written unique u one obtains simplifying much possible permutation allowed axioms classical rewriting extensively studied bn98 j coincide p permutative axioms commute simplication axioms lets us decompose questions j questions p questions start p lemma 81 set p ug regular tree language automaton p needs mm2 states proof sketch p nite set m2 elements exponential blowup cannot avoided simplication axioms nice property allow nitely many combinations behave better wrt regularity write l fu j lemma 82 regular l sets l l l regular tree languages automaton al recognizing l build automata size ojaj three languages polynomial time proof 1 l u l ioe u 2 l additional 0s simplied hence automaton accepting l obtained al adding new state q 0 subterms simplied also add rules 0 7gamma q 0 q 0 k q 0 7gamma q 0 inria regular viewpoint paprocesses 23 accepting subterms q al rules qq 0 7gamma q q 0 q 7gamma q simulating simplication 2 simplied simple way obtain automaton l synchronize automaton al accepting l complete automaton 0 recognizing terms built 0 k 0 two states q 0 q 60 two automata synchronized 7gamma q q 0 7gamma q a0 simulate simplication nullable terms additional rules namely whenever rule q add rule q add symmetric rule q 0 instead k routine induction length derivations shows 7gamma q q 0 ioe 9t 2 l 7gamma q 3 l simplest way see regularity note l note regular l l p l j necessarily regular gd89 however proposition 83 set j regular tree language automaton needs mm2 states proof combine 5 lemmas 81 82 82 structural equivalence behaviour seeing terms modulo j modify observable behaviour following standard result proposition 84 j bisimulation relation ie j 0 u proof standard tedious shall give proof sketch proof single equation l r denition j show set floe roeg instances equation bisimulation relation complete proof takes better part p 95 book mil89 equations dealt similarly noting isnil compatible j remains prove generated congruence bisimulation standard sos rules pa obey format ensuring behaviour term depends behaviour subterms syntax may dene new transition relation terms u u 0 amounts j 4 simplest way translate rr n0123456789 problems paj problems set terms adopt usual abbreviations proposition 85 w 2 act w proof induction length w using proposition 84 83 reachability modulo j easy prove decidability reachability problem modulo j post recall u j post regular treelanguages one build eoeectively hence decidable whether nonempty intersection gives us simple algorithm using exponential time size u j actually better result 3 theorem 86 reachability problem paj igiven u np proof npeasiness straightforward automata framework u 0 st note ju 00 j juj simple algorithm compute u guess nondeterministically permutation u 00 build automata 1 u 00 2 post automata polynomialsize remains checks whether 1 2 nonempty intersection know whether required u 0 exists corollary 87 reachability problem paj npcomplete proof nphardness reachability bpps proved esp97 proof idea reused framework reduce 3sat reachability paj consider instance p 3sat p variables n clauses every gammag dene following r ij note j r1 rules pick valuation v x r r3 rules use v list satised clauses r2 rules discard unnecessary elements finally applications possible eg first proved may97c inria regular viewpoint paprocesses 25 proposition 88 boundedness problem paj decidable polynomialtime proof j reach nite number states paj ioe reach nite number nonj terms pa permutative axioms allow nitely many variants given term post l contains nite number nonj processes ioe post l nite 84 modelchecking modulo j modelchecking problem solved may97b considers ef logic paj translated framework amounts interpret temporal connectives terms instead write mod j interpretation modulo j mod additionally consider atomic propositions p compatible j ie j u imply u modelchecking paj simple modelchecking pa lemma 89 efformula mod j proof structural induction using prop 85 closure wrt j hci case immediate corollary use exactly approach modelchecking pa without j conclusion paper showed treeautomata techniques powerful tool analysis pa process algebra main results two general regularity theorems numerous immediate applications including modelchecking pa extended ef logic treeautomata viewpoint many advantages gives simpler general proofs helps understand problems solved ptime others nptime etc quite versatile many variants pa attacked approach acknowledgments thank h comon r mayr numerous suggestions remarks questions work rr n0123456789 26 dlugiez phschnoebelen r decidability bisimulation equivalence processes generating contextfree languages innite results verifying innite state processes sequential parallel composition reachability analysis pushdown auto mata application modelchecking rewriting regular structure prex rewriting tree automata application decidable subsets ccs decidability decomposition process algebras applications tree automata rewriting theory ground rewrite systems decidable petri nets direct symbolic approach model checking pushdown systems extended abstract reachability problem ground trs extensions model recursiveparallel programs formal framework analysis recursive parallel programs combining petri nets paprocesses model checking paprocesses tableaux methods paprocesses communication concurrency tr decidability bisimulation equivalence processes generating contextfree languages process algebra regular structure prefix rewriting petri nets commutative contextfree grammars basic parallel processes tree languages rewriting efficient algorithms pre post interprocedural parallel flow graphs automatatheoretic approach branchingtime model checking communication concurrency formal framework analysis recursiveparallel programs combining petri nets paprocesses bisimulation equivanlence decidable normed process algebra decidable firstorder transition logics paprocesses deciding bisimulationlike equivalences finitestate processes reachability problem ground trs extensions reachability analysis pushdown automata parallelize sequential processes infinite results model checking paprocesses automatatheoretic approach interprocedural dataflow analysis regularity decidable normed pa processes polynomial time tableau methods paprocesses ctr ahmed bouajjani javier esparza tayssir touili generic approach static analysis concurrent programs procedures acm sigplan notices v38 n1 p6273 january vineet kahlon aarti gupta analysis interacting pushdown systems acm sigplan notices v42 n1 january 2007 anne labroue philippe schnoebelen automatatheoretic approach reachability analysis rpps systems nordic journal computing v9 n2 p118144 summer 2002 markus mllerolm precise interprocedural dependence analysis parallel programs theoretical computer science v311 n13 p325388 23 january 2004 antonn kuera philippe schnoebelen general approach comparing infinitestate systems finitestate specifications theoretical computer science v358 n2 p315333 7 august 2006 denis lugiez philippe schnoebelen decidable firstorder transition logics paprocesses information computation v203 n1 p75113 november 25 2005 kamal lodaya regular viewpoint processes algebra acta cybernetica v17 n4 p751763 january 2006
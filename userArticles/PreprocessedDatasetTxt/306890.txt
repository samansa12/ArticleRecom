dynamic reconfiguration support concurrent applications abstractthis paper describes development dynamically reconfigurable system support multiple applications running concurrently dynamically reconfigurable system allows hardware reconfiguration part reconfigurable hardware busy computing fpga resource manager rm developed allocate deallocate fpga resources preload fpga configuration files individual application different tasks require fpga resources represented flow graph made available rm enable efficient resource management preloading performance using rm support several applications summarized impact supporting concurrency preloading reducing application execution time demonstrated b introduction adaptive computing systems acs shown outperform generalpurpose systems applications abilities adapting hardware resources application requirements1 8 9 13 16 technology demonstrated special purpose applications tediously hand coded systems also tremendous promise accelerating conventional applications domain specific visual development environments khoros matlab wit web browsers netscape internet dynamically invoke submodules plugins image data processing programming device support possible submodules application may invoke usually feasible due large number submodules finite amount hardware sources however acs may support reconfiguration hardware resources programmable hardware busy computing system referred dynamically reconfigurable system dynamically reconfigurable system configure hardware demand support requirements interactive programs matlab web browsers one way implement dynamically reconfigurable acs incorporate large number srambased field programmable gate array fpga chips coprocessing board used conjunction traditional pro cessor however system need provide operating system like interface programmable hardware hide architectural details coproces sor manage reconfiguration hardware application execution fairly allocate fpga resources authors department computer science engineering wright state university dayton ohio 45435 usa among multiple processes fig 1 dynamic reconfiguration system paper describes system software development dynamically reconfigurable system support multiple applications running concurrently block diagram illustrating system shown fig 1 application consists program executed host machine flow graph representing portion application executed fpga resources host program responsible starting execution graph nodes resource manager rm information multiple flow graphs one applica tion rm allocates deallocates fpga resources new nodes may loaded system nodes executed addition speculative strategy adopted rm preloading fpga configuration files reduce hide reconfiguration overhead improve performance fpga architecture modular sense fpga resources consist number hardware units graph node uses integer number hardware units note multiple copies application executed time system following technical advantages ffl compared static reconfiguration schemes reconfigure hardware execution application system accommodate ap plications typically require fpga resources available usage fpga resources satisfied spread time particularly true loading fpga implementations based execution conditions system may also reduce computation time individual application since required fpga resources need loaded larger portion application computation mapped fpgas ffl compared dynamic reconfiguration schemes statically determine reuse fpga resources 1 2 system allocates fpga resources run time via rm relieves application developers management fpga resources due use rm speculative loading policy multiple applications may share fpga resources effectively much analogous virtual memory system rage project 3 similar emphasizes partial reconfiguration support preloading configurations section 2 paper describes development environment project section 3 shows design implementation rm several applications used testing rm applications testing procedure results summarized section 4 section 5 compares system similar software operating system section 6 concludes paper ii development environment hardware platform fig 2 g900 architecture reconfigurable computing platform used project 180 mhz pentiumpro personal computer hosting g900 fpga board pci bus based board manufactured giga operations corporation gigaops board modular design making suitable resource sharing among applications design consists eight computing modules xmods xmod contains two xc4020e fpga chips 2 mb dram fig 2 note maximum sixteen xmods configured one g900 board xmods connected together 128 wires called xbus among 128 wires 21 used support custom bus protocol called hbus defines pins timing signals used host specifically ppga fpga interface xbus also contains six 16bit busses provide interxmod connectivity two special purpose onboard fpgas part xmod ppga cpga ppga xilinx xc4013e2 controls communication host computer xmods fig 2 acting pci bus interface board cpga xilinx xc52105 implements clock generation runtime configuration power functions fpgas run clock rates 66mhz g900 board host interface currently limited 16mhz b design environment g900 board ships developers kit includes xlinkos gocolib xlinklib xl 11 17 ffl xlinkos permits host program execute hardware designs using standard c function calls map variables exist fpgas host programs address space memory mapped variables fpgas reconfigured configuration host program requires ffl two software libraries gocolib xlinklib provided developers kit gocolib provides lowlevel routines interact module fpgas monitor cpus ppga etc xlinklib contains higher level routines interacting board xlinklib gocolib need linked every xlinkos generated application ffl xl language allows specification fpga operations loosely based c syntax many keywords c provides control features available xilinx fpgas standard c operators plus clock operator used program sequencing xl statements two clock operators executed clock cycle microsoft nt used operating system design process begins three source files user must create 1 source code fpga design written either xl vhdl 2 file describing host fpga interface declares memory mapped variables functions host calls execute fpga designs 3 application program resides executes host computer must call functions initialize load execute user fpga designs xmods first two files input xl compiler produce xilinx netlist file netlist used xilinx tools automatically map design fpga bit file contains fpga configuration addition c header file generated included host program control executions fpga designs g900 board detailed description development environment given 12 iii design implementation provide dynamic reconfiguration capability support concurrent applications xmod rm set library functions designed implemented system diagrammed fig 3 xmod basic resource unit rm allocates deallocates reconfigurable computing resources ondemand speculatively set library functions provided application developers pass information application rm without worrying details interprocess communications details g900 board control section application scenario system first described detailed design presented along implementation status discussion design issues follows fig 3 overview resource manager application scenario following paragraphs describe scenario applications executing rm application development scenario application execution scenario proposed system given application development application first analyzed profiled determine computations assigned fpgas xmods computations mapped xmods creating designlnk file going development process described previous section generate designbit file downloaded xmods remaining parts application assigned host program also provides data controls execution computations xmod computations mapped xmods represented flow graph passed rm application starts executing application flow graph weighted graph node represents xmod computation weighted edges represent control flow host program computational granularity graph nodes may differ greatly node requires either fixed number xmods range numbers xmods exam ple node either simple integer addition requires one xmod complicated 2dimensional discrete cosine transform use one eight xmods depending desired performance example edge weighting shown fig 4 execution graph node next candidate node either node b c depending condition evaluated host program three weighted edges go node weight edge represents estimated probability destination node executed given node executed edge weights used rm preload fpga configuration files higher weights lead higher chance preloading zero weight indicates need preloading edge weights assumed constants application execution paper even though removing assumption may potentially lead better performance fig 4 flow chart example fundamental assumption flow graph computational granularity graph nodes may differ greatly may require portion available fpga resources therefore efficient execute graph node fpga system one time instead multiple nodes necessarily application executed concurrently new nodes may loaded system nodes executed application execution execution application rm runs background process host machine application provides flow graph corresponding fpga configuration files rm rm loads preloads fpga implementations host program execu tion preloading implements speculative strategy overlaps xmod reconfiguration computation xmods reconfiguration latency reduced completely hidden edges flow graph used preloading fpga configuration files edge missing flow graph influence correctness computation however influence execution performance assumed applications developed way executing one graph node time sufficient though necessary guarantee completion individual applications applications system able prevent deadlock set library functions developed simplify application development library functions support passing flow graph demand loading request node release request board release request xmod io capabilities library function called within application information passed retrieved rm interprocess socket communication initially application provides flow graph along complete pathnames fpga configuration files used node rm rm speculatively loads configuration files free xmods available reduce hide overhead associated reconfiguration fpgas runtime application needs computation mapped fpgas requests rm load required bit file xmod waits till rm responds number xmod assigned application bit file speculatively preloaded application wait loading configuration file gets xmod number assigned xmod immediately however node preloaded available application waits xmod becomes available loaded requested xmod allocated loaded application packs input data computation array sends g900 board input data written xmod application initiates computation completion computation function mapped fpga designed interrupt rm turn inform application results retrieved application computation complete node represented flow graph xmod released otherwise input execute result steps repeated application done computations mapped fpgas informs rm longer speculate nodes applications flow graph release xmods preloaded application b resource manager design rm implemented multithreaded applica tion overview design shown fig 3 main thread rm first thread created parent thread threads first initializes g900 board spawns loader interrupt handler scheduler threads also sets server socket incoming connection requests applications waits requests new application service thread created requesting application interacts application behalf rm main thread loops back listen new requests communication among different threads rm accomplished events mutexes shared variables shared memory application service thread establishes stream socket connection client application services 4its requests receives application flow graph puts shared memory notifies sched uler depending type request sent appli cation application service thread responds different ways six types requests sent application ffl load graph node request allocation xmods flow graph node load fpga configuration files one xmods xmods assigned preloaded configuration files node xmod numbers returned application immediately however xmods assigned application service thread places demand request xmods scheduler xmods get assigned loaded required files returns xmod numbers application ffl input data receiving input data array application service thread writes value memory mapped input variable specified offset within xmod ffl result data application thread retrieves result data memory mapped variables xmods returns data host program ffl execute function application service thread starts execution specific function xmods waits till interrupt handler indicates occurrence interrupt one assigned xmods acknowledges interrupts informs client application interrupts may indicate completion computation intermediate stage service thread waits next request application might reinitiation computation collection result data ffl release xmod service thread deallocates xmods associated specific flow graph node ffl release flow graph service thread discard applications flow graph inform scheduler application flow graph longer valid terminate application executes fpga function normally blocks function completed completion fpga function sends interrupt xmod interrupt handler thread rm thread checks xmods generated interrupt since one xmod could interrupting time informs corresponding application service thread interrupt interrupts acknowledged respective application service threads interrupt handler enables interrupts loops back wait till another interrupt occurs graph node application developer needs either implement interrupt request circuit fpgas let host program wait prespecified amount time function complete latter approach works function completion time known advance determined well formulated way scheduler thread allocates xmods either ondemand speculatively normally sits idle trig gered three different types events application service thread 1 request demand loading 2 deallocation xmods due release graph node 3 receiving new flow graph depending type event scheduling parameters availability resources scheduler either assigns xmod loader thread loading loops back wait another event occur scheduling policy accepts three parameters specified arguments rm invoking parameters determine aggressively scheduler speculatively preloads graph nodes defined follows ffl max speculate maximum number immediate successor nodes currently executing node flow graph speculatively loaded ffl threshold minimum edge weight probability speculative preloading successor node ffl free xmods minimum number xmods preloaded kept aside demand loading requests scheduling policy three sections based events trigger scheduler sections separately explained demand loading ffl node requested demand loading preloaded preloaded number assigned xmod returned requesting application service thread ffl requested node currently preloaded free xmod searched assigned loading free xmod available xmod assigned application service thread node searched assigned xmod assigned application service thread xmod preloaded speculatively loaded preempted assigned ffl xmods executing demand request queued demand queue requesting application service thread suspended woken demand request serviced xmod assigned ffl xmod assigned requesting application service thread bit file scheduled loading xmod number given application service thread waits till loading completed passing xmod number client application ffl irrespective type event triggering sched uler demand loading requests pending demand queue given highest pri ority new demand requests get queued end demand queue preloading new existing applications done free xmods available demand requests serviced ii arrival new application flow ffl number free xmods higher free xmods new application flow graph ar rives node 0 flow graph preloaded free xmod new flow graphs serviced speculating existing application flow graphs ffl threshold weight probability preloading considered preloading node 0 new graph assumption application always start execution flow graph node 0 iii releasing xmod ffl number free xmods higher free xmods one immediate successor node currently executing node flow graph speculated till max speculate limit reached currently executing node flow graph limit reached flow graph skipped ffl node speculatively loaded edge weight probability calculated fraction combined edge weights going edges current node higher threshold ffl node speculated detected executed xmod case loops checked configuration file still loaded xmod yes simply marked preloaded otherwise node loaded free xmod edge weight probability higher threshold ffl speculation flow graphs done circular fashion continues scheduler come back application flow graph started present scheduling cycle scheduling begins flow graph following last flow graph scheduled previous cycle fig 5 xmod state diagram order efficiently allocate xmod resources speculative loading environment rm maintains state xmod shown fig 5 xmod preloaded use yet may deallocated another request cannot satisfied xmod loaded ondemand cannot deallocated released since loading configuration bit file slow needs done serially g900 board actual loading bit files done loader thread allows scheduler provide faster response demand requests scheduling events scheduler queues bit files loaded two queues maintained shared memory demand queue speculation queue loader thread serially loads bit files queued scheduler assigned xmods bit files demand queue given priority bit files speculation queue completion loading application service thread waiting xmod signaled c design issues current design implementation rm supports multiple concurrent applications preloading several design issues complicate rm yet addressed issues described follows 1 direct xmod data access standard mechanism application load data xmods unload data xmods use library function requires copying data application rm applications frequent data access large quantities data efficient implementation allows individual applications access xmods directly without going rm available 2 intergraphnode constraints resources g900 board xmods may shared different flow graph nodes example x bus used interxmod commu nication graph node uses multiple xmods wires x bus resource requirements specified provided rm currently none test applications paper use x bus inter xmod communication current rm examine constraints 3 optimal resource allocation application flow graph node tradeoff resulting performance number xmods used expected graph nodes xmods lead linear speedup therefore range xmod numbers specified node corresponding performance figure number xmods specified rm may use information optimally allocate resources run time iv performance results two main applications used test system op eration mpeg2 encoder program application based npcomplete satisfiability problem synthesized flow graph four nodes node exhaustively solving satisfiability problem different logic formula two applications briefly described 1 mpeg2 encoder mpeg2 standard digital video audio com pression mpeg2 encoder available mpeg software simulation group source code format profiled visual c profiler 4 two timeconsuming functions full search dist1 functions handle motion estimation mpeg encoding algorithm part two functions handles forward matching backward matching mapped xmods implemented resulting flow graph application one graph node flow graph node use one eight xmods xmods use exactly fpga design detailed description design found 5 design first tested without using rm ie static reconfiguration results show even though xmods improve performance last xmods much benefits first xmods although supported yet performance figures future provided resource manager improve resource utilization overall performance 2 satisfiability satisfiability problem problem deciding formula conjunctive normal form satisfied truth assignment 15 example following 4variable formula conjunctive normal form satisfied x1true x2false x3false formula contains three clauses anded together historically satisfiability problem first decision problem shown npcomplete satisfiability problem convenient testing rm different formulae tested using fpga design simply initializing design different values allows control amount fpga computation time simple fpga design exhaustively solve problem shown fig 6 note fpga design intended accelerator even though design faster pentium host fpga designs meant accelerate satisfiability problem found 18 14 fig 6 satisfiability fpga design fpga design fig 6 implements deterministic solution satisfiability problem checking every truth assignment works follows formula conjunctive normal form contains n1 clauses represented two matrices binary values clause represented two binary vectors a1 a2 a1 bit indicates variable clause a2 bit indicates variable negated two matrices initialized host program truth assignment represented binary vector h stored counter starts zero truth assignment formula evaluated going clauses one one host interrupted either formula satisfied truth assignments exhausted formula satisfied host read truth assignment ie h value satisfies formula h value important verification system operation fpga design fits one fpga chip therefore one single xmod based fpga design application artificially synthesized application called multiple satisfiability contains four graph nodes flow graph graph node satisfiability evaluation formula four formula pseudorandomly produced used application formula fixed specific conditions used host program determine control flow known nodes get evaluated order computation correct setup purposely made test speculative loading performance note pretend four graph nodes use different fpga configuration files better represent real applications even though reality file used assumption execution new graph node requires reloading configuration file simulation results satisfiability problem different numbers nodes different node granularity mpeg encoder used examining system performance readings taken average three independent runs first timing system operations g900 board initialization bit file loading done quantify overheads using development system found board initialization takes 234 seconds loading configuration file takes seconds test application first run without using rm using rm find overheads using rm application use rm needs initialize g900 board map address space result applications cannot run concurrently without using rm rm used board initialized starts thus board initialization time counted test applications run using rm note application using rm flow graph generates interrupts indicate end fpga computation roblem high granularity nodes application four nodes satisfiability problem fpga computation times range 19 sec 4 sec developed node granularities much higher fpga configuration time 035 sec one four eight twelve copies application run sequentially without rm sequentially concurrently rm using speculative pre loading results obtained summarized fig 7 fig 7 high granularity satisfiability execution times single application took 141 sec complete without using rm 135 sec run resource manager ideally since board initialization time counted second case 234 sec less due overheads packingunpacking data communicating resource manager 06 sec less thus overhead time using rm 174 sec application application run four times sequentially without resource manager took 5606 sec complete versus 5427 sec resource manager four copies application used concurrently using rm took 1487 sec complete speeding execution factor 38 sequential execution without rm since loading bit files needs done sequentially even applications running concurrently 1487 sec total execution time approximately 56 sec 4 theta 4 theta 035 spent loading fpgas however fpga xmod g900 board loaded fpgas xmods executing thus pci bus shared fpga loading data load ingunloading fpgas results longer fpga configuration time depending dynamic condition board overlap loading execution fpgas concurrent execution different fpgas results reduced total time eight copies application run g900 board concurrently rm took 1817 sec complete compared 11126 sec sequential execution without rm 10887 sec rm since one fpga eight xmods g900 board used parallel speedup factor 61 achieved sequential execution without rm uses one fpga xmod time twelve copies application running concurrently using rm speedup factor 82 obtained since number applications number fpga resources applications need wait till fpgas become free demand queue obtaining fpga resources computation roblem low granularity nodes satisfiability problem used test1 initialized different formulae get four nodes computation times 8 msec 26 msec much lower 350 msec required loading fpga g900 board bit file means much application execution time would spent loading fpgas rather performing computation fpgas timings one four eight twelve copies application obtained test one results shown fig 8 fig 8 low granularity satisfiability execution times speedup obtained running four copies application concurrently rm 21 8 copies 231 12 copies 26 low speedup factor less parallelism application execution fpgas since time spent sequentially loading fpga configurations thus overhead communicating g900 board pci bus hardware constraints g900 results high fpga configuration time dictate minimum node granularity hiding latency obtaining impressive speedup applications running concurrently test similar tests 1 2 done two mpeg encoders mpeg encoder processes 27 frames images uses single xmod motion estimation part mpeg encoding performed xmod requires frequent larger amounts data transfer satisfiability problem image frame used reference frame whole image frame sent host xmod frames image block 16 theta 16 pixels sent previous block processed xmod fig 9 mpeg encoder timings timings obtained running encoders sequentially concurrently shown fig 9 single encoder run without using rm took 4535 sec process 27 frames whereas rm took 4485 sec due saving board initialization time two encoders run parallel using rm ran 14 times faster two encoders executing serially without rm required 9129 sec complete processing speed high due large amount data transfer taking place fpga board host concurrent use mpeg encoders useful image processing applications speculative p reloading verify effect speculative preloading fpgas based flow graphs given rm appli cations four copies satisfiability problem used test 1 running concurrently reevaluated effect varying different scheduling parameters total execution time applications also obtained since eight xmods g900 board preloading done free xmods number applications used testing limited four fig 10 flow graph satisfiability high granularity nodes flow graph used satisfiability problem test shown fig 10 edge weights arranged node 1 preloaded node 0 node 2 node 3 actual execution sequence application application execution times obtained function scheduling parameters max speculate free xmods threshold held constant function threshold max speculate free xmods kept constant zero results threshold constant execution times obtained function free xmods max speculate shown fig 11 threshold held constant 03 sults meant nodes flow graph shown fig 10 could get preloaded concluded fig 11 speculative preloading fpga configurations help hide configuration overhead results lower overall execution time lowest execution time obtained number speculated nodes highest however number free xmods demand loading increases overall execution time increases due reduced number speculated nodes fig 11 execution times four satisfiability problems wrt results free xmods constant results fig 12 free xmods held constant zero xmod kept aside demand loading requests threshold value 05 meant nodes 1 2 could preloaded threshold equal 06 node 1 could preloaded node 2 node 3 demand loaded different values execution time fig 12 confirmed reduced number speculated nodes overall execution time increases fig 12 execution times four satisfiability problems wrt threshold fig 13 timing diagram four high granularity satisfiability problems max fig 13 shows timing distribution single run four copies high granularity satisfiability problems running concurrently figure loading bit files execution nodes four applications overlapped expected results reduced execution time summary four high granularity satisfiability application aggressive preloading advantageous best performance obtained threshold 03 max speculate equal 2 free xmods 0 17 faster without speculative loading nodes roblem optimized f low graph study effect flow graph provided application accurately represent execution flow flow graph shown fig 10 modified flow graph shown fig 14 according edge weights node 2 gets preloaded node 0 node 1 gets preloaded depending upon threshold max speculate values node 1 node 3 gets preloaded node 2 even though execution complete node 3 executed flow graph indicates node 1 node 0 may executed node 3 fig 14 incorrect flow graph satisfiability fig 15 timing diagram four high granularity satisfiability problems max incorrect representation application execution flow graph could also due condition evaluation differing usual case results higher number preemption nodes thus increases overall execution time timing values obtained function max speculate shown fig 15 threshold value kept constant 03 meant successors node could get preloaded free xmods free xmods zero thus allowing much preloading possible seen fig 15 gains obtained speculative loading reduced considerably flow graph representation inaccurate however execution time still lower without speculation test ap plication responsibility application developer provide accurate flow graph possible unless dynamic conditions program predicted accurately case lower speedup factor using rm acceptable v comparison types resource management way fpga resources managed paper regard similar virtual memory system uses prepaging following two major differences ffl first prepaging used processes previously swapped applicable new processes preloading fpga configurations applied new processes availability application flow graphs given relatively coarse granularity graph nodes providing application flow graph arguably feasible application developer especially since fpga design process typically lengthy tedious ffl second paged virtual memory system truly modular pages treated fpga resources may really modular example x bus g900 used simultaneously support several groups interxmod communication long usage x bus pins disjoint among different groups result execution one application graph node xmods may prevent execution another graph node requirement shared resources application graph node indicated flow graph sent resource manager note supported current resource manager another example fpga chips board may different io capabilities since fpga resources mainly used computing instead data storage rm sense similar processor scheduler multiprocessing operating system however assumption data dependency conditionals application flow graph deterministic scheduling techniques summarized 6 cannot applied rm instead techniques one 7 based availability runtime profile compiletime applicable techniques used help produce application flow graphs always manually generated paper vi conclusions dynamic reconfiguration system support concurrent applications designed implemented tested pc g900 fpga board compared static reconfiguration schemes proposed system accommodate applications potentially reduce computation 9times individual applications compared dynamic reconfiguration schemes proposed system allocates fpga resources run time via resource manager rm relieves application developers management fpga resources rm preload fpga configurations utilizing knowledge application flow graphs simulation results show even though overhead associated using resource man ager concurrency supported system drastically speedup application execution programs matlab use libraries functions improve programmer productivity one advantage proposed dynamic reconfiguration system support library fpga functions say one 2d convolution one histogram equalization system need squeeze fpga functions used program hardware resources time environment would allow programmers enjoy performance benefits adaptive computing technology without worrying fpga design details would accelerate adoption technology future research necessary port rm fpga boards may modular g900 board case handling asymmetry hardware resource units challenging problem another issue dynamic reconfiguration design similar rm systems support partial reconfiguration virtual hardware manager developed rage project 3 probably integrated resource manager paper concurrent applications supported also fpga function density improved partial reconfiguration 10 several models dpga program execution presented one demand usage similar proposed system paper pursue model claimed although may seem rather futuristic scenario good reasons believing fields multimedia communications databases cryptography least characteristics applications likely demand sort highly flexible execution environment acknowledgments research supported darpa air force contract number f336159711148 ohio state investment fund ohio state research challenge grant xilinx inc donated fpga design tool fpga chips xmods r runtime reconfiguration method enhancing functional density srambased fpgas designing partially reconfigured system dynamic reconfiguration runtime system mpeg software simulation group httpwww accelerating mpeg2 encoder utilizing reconfigurable computing deterministic processor scheduling compiletime scheduling dynamic constructs dataflow program graphs realtime signal preprocessor tradeoff study using morrph industrial machine vision system reconfigurable processors resource manager configurable computing systems configurable computing solutions automatic target recognition dynamic circuit generation solving specific problem instances boolean satisfiability languages machines sequencing runtime reconfigured hardware software accelerating boolean satisfiability configurable hardware tr ctr klaus danne distributed arithmetic fpga design online scalable size performance proceedings 17th symposium integrated circuits system design september 0711 2004 pernambuco brazil ahmed el farag hatem elboghdadi samir shaheen improving utilization reconfigurable resources using twodimensional compaction journal supercomputing v42 n2 p235250 november 2007 jack jean xuejun liang brian drozd karen tomko yan wang automatic target recognition dynamic reconfiguration journal vlsi signal processing systems v25 n1 p3953 may 2000 christoph steiger herbert walder marco platzner operating systems reconfigurable embedded platforms online scheduling realtime tasks ieee transactions computers v53 n11 p13931407 november 2004 klaus danne marco platzner edf schedulability test periodic tasks reconfigurable hardware devices acm sigplan notices v41 n7 july 2006 david kearney mark jasiunas using simulated partial dynamic runtime reconfiguration share embedded fpga compute power resources across swarm unpiloted airborne vehicles eurasip journal embedded systems v2007 n1 p88 january 2007 katherine compton scott hauck reconfigurable computing survey systems software acm computing surveys csur v34 n2 p171210 june 2002
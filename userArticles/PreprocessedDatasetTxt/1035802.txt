keeping track latest gossip distributed system tackle natural problem distributed computing involving timestamps let ipiipiinf1infipiinf2inf ipiinfninf set computing agents processes synchronize time time exchange information others gossip problem following whenever set ipi ipi meets processes ipi must decide amongst latest information direct indirect agent ipi system propose algorithm solve problem finitestate local formally means algorithm implemented asynchronous automation b introduction aim paper tackle natural problem distributed computing involving timestamps let set computing agents processes synchronize time time exchange information others gossip problem following whenever set p p meets processes p must decide amongst latest information direct indirect agent p system easily accomplished agents decide timestamp every synchronization pass timestamps along exchange information require clocks synchronized example process use independent counter set p p meets processes p jointly agree new value counters exceeds maximum counter values currently held thus process p timestamps assigned synchronization events involving p form strictly increasing sequence albeit gaps successive time stamps problem deciding latest information p reduces checking largest timestamp scheme following drawback computation progresses counter values increase without bound agents time would taken passing large numbers opposed actual gossip propose algorithm using counters take values bounded finite set assign independent counter subset processes potentially synchronize counters updated corresponding sets processes meet update performed jointly processes meet since set counter values bounded timestamps reused general different synchronizations involving particular set processes acquire timestamp computation despite algorithm guarantees whenever set p p meets processes p decide correctly best information agent p system thus essence processes p may finite state machines yet manage keep track latest information agents algorithm induce additional communications formalize gossip problem solution terms asynchronous automata machines first introduced zielonka natural generalization finitestate automata modelling concurrent systems 30 asynchronous automaton consists set finitestate agents synchronize process input letter input alphabet sigma assigned subset processes jointly update state reading processes outside remain unchanged movein fact oblivious occurrence calling automata asynchronous misleading automata communicate syn chronously zielonka used term asynchronous emphasize different components network proceed independently processing input continue use rather inappropriate terminology historical reasons preview algorithm algorithm proceeds process maintain different levels information rest system primary level process p records latest information heard every process thus primary information process p regarding process q corresponds recent event performed q p aware either directly indirectly secondary information process consists knowledge primary information processes thus processes p q r ps secondary information would refer events form latest p knows q knows r similarly tertiary information process consists knowledge secondary information every process events identified labels assigned occurthe label event assigned jointly processes take part event event involving one process corresponds internal event labels best thought timestamps goal algorithm correctly compare update primary information processes participate synchronization constraint bounded number labels used timestamp events regardless length overall computation let p q processes synchronize prove ps primary information r recent therefore better qs primary information r event corresponding r recorded qs primary information also present ps secondary information words primary information p q compared checking equality labels within primary secondary informationwe maintain order labels feature crucial designing algorithm uses bounded number timestamps reusing label general destroy priori order set labels follows reuse timestamps provided maintain following invariant across system stage computation label present primary secondary information two different processes labels actually point event words two different instances timestamp never simultaneously present primary secondary information system invariant difficult maintain processes take part event assign timestamp general access primary secondary information processes across system way knowing precisely labels use across system event occurs turns tertiary information used resolve problem deciding timestamp reused prove timestamp previously assigned process p currently useie currently belongs primary secondary information process qonly also belongs tertiary information p follows labels tertiary information process reused since number events tertiary information process bounded processes system always work bounded set labels large enough permit event assigned fresh timestamp clash set timestamps currently use across system remarked earlier algorithm described asynchronous automaton process locally finitestate machine automaton construct solve gossip problem effectively presented space polynomial number processes system means automaton embedded distributed algorithms without sacrificing efficiency paper solve gossip problem systems multiparty synchroniza tion surpisingly problem appears easier restricted systems pairwise synchronization though systems pairwise synchronization perhaps representative real world systems chosen describe solution general setting important applications theoretical studies distributed systems based asynchronous automaton model 13 14 23 technique describe analyzing synchronizing systems also applicable general classes distributed systems instance adapt algorithm maintaining primary secondary tertiary information solve gossip problem well behaved classes messagepassing systems 21 paper organized follows next section introduce asynchronous automata formalize gossip problem terms automata define natural partial order events system section 2 introduce ideals frontiers play crucial role rest paper sections 3 4 describe maintain compare update local manner latest information processes next section puts ideas together formally describes gossip automaton solves problem set tackle section 6 briefly examines extensions basic gossip automaton possibilities optimizing construction also look applications gossip automaton logic theory asynchronous automata 13 14 23 27 concluding discussion place results perspective discuss similarities differences work gossiping bounded timestamps 1 2 3 5 let p finite set processes synchronize periodically let set possible synchronizations permitted system denoted c c element c 2 c nonempty subset p c occurs processes c share information local states update states synchrony model computation system sequence communicationsthat word u 2 c let u length convenient think u function abbreviates set fi otherwise convention empty word denoted events associate set events e u event e form addition convenient include initial event denoted 1mg initial event marks implicit synchronization processes start actual computation u empty word e usually write e e u denote implies process p participated c r figure 1 typical computation system synchronizing processes synchronization e initial event 0 define p 2 0 hold p 2 p p 2 e say e pevent ordering relations e word u imposes total order events e define however temporal order accurately reflect cause effect relationship events e clearly synchronizations disjoint sets processes performed independently particular two synchronizations occur consecutively u could also transposed without affecting outcome com putation record information causality independence define partial order v e begin observe process p orders events participates define p relation set pevents e totally ordered reflexive transitive closure p denote transitive closure v e v f say e f difficult see causality relation v accurately models cause effect relationship events e particular rearrangements letters u arise permuting adjacent independent synchronizations give rise isomorphic structures e v example let sg figure 1 shows events e corresponding word bacabba dashed box corresponds mythical event 0 insert beginning convenience figure arrows events denote relations p q r compute v thus example e 1 v e 4 since e 1 r e 3 q e 4 note 0 every event also p 2 p set pevents e totally ordered v since p contained v set events e denoted e represent synchronizations e known processes e e occurs latest information let e set events communication sequence c v maximum pevent e denoted last event e p taken part since pevents totally ordered v max p e welldefined let p latest information p q e corresponds v maximum qevent subset events max p e denote event latest pq e since qevents totally ordered v q 2 0 v latest pq e welldefined example continuing example figure 1 max e 6 latest pq latest ps hand latest processes events latest pq e latest p 0 q e q events thus always comparable respect v goal design scheme whereby process p maintains bounded amount information locally whenever set c p synchronizes processes c decide amongst heard recently every process system formally every q 2 p processes c able jointly compute events flatest pq eg p2c maximum respect v make precise notions bounded local information using asynchronous automata asynchronous automata distributed alphabet let p finite set processes distributed alphabet pair sigma sigma finite set actions assigns nonempty set processes 2 sigma state spaces process p associate finite set states denoted p state p called local state p p use p denote product q element p called p state pstate also called global state given denote projection onto p 0 asynchronous automaton asynchronous automaton sigma form local transition relation sets initial final global states intuitively local transition relation specifies processes meet may decide joint move outside change state occurs thus define global transition relation sp theta sigma theta sp p p gammaa called deterministic global transition relation function sp theta sigma sp set initial states 0 singleton notice function iff local transition relation 2 sigma function shall deal deterministic asynchronous automata paper runs given word run u function ae 0m sp ae0 2 0 2 1m aeigamma1 ui aei deterministic word u gives rise unique run denote ae u word u accepted run ae u aem 2 f la language recognized set words accepted paper look asynchronous automata language recognizers instead shall treat devices locally computing families functions locally computable functions let val set values sigmaindexed family functions set f contains function f letter 2 sigma f sigma locally computable find deterministic asynchronous automaton family local functions g word ae u unique run u words processes locally compute value f u applying function g unique astate reached automaton reading u problem involving latest information processes p formalized terms asynchronous automata given distribution function defined obvious wayfor c 2 sigma c c convenience henceforth shall drop distinction subset c 2 c corresponding letter c 2 sigma refer c thus use c denote set cstates c denote local transition function c sigma communication sequence c p q 2 p denote best c u q set processes c recent information q end uie best c u latest latest pq e u g member val function p nonempty subsets p goal show family functions flatestgossip valg c2sigma locally computable function fp 7 best c u pg p2p frontiers moment let us fix communication sequence corresponding set events e main source difficulty solving gossip problem fact processes p need compute global information communication sequence u process access local partial view u although partial views u correspond subsets e every subset e arises partial view subsets e correspond partial views u called ideals set events e called order ideal closed respect v ie e 2 f v e implies f 2 well shall always refer order ideals ideals 1 requirement ideal closed respect v guarantees observation represents consistentwhenever event e observed events computation necessarily precede e minimum possible partial view word u ideal f0g interpretation 0 event takes place actual computation begins lies every event e 0 2 every nonempty ideal shall assume every ideal consider nonempty clearly entire set e ideal e e 2 e easy see j ideals j j example let us look figure 1 f0 e 2 g ideal f0 e since e 1 v e 3 e g ideal e 5 whereas ideal form e e 2 e need generalize notion max p e maximum pevent e ideals e pviews ideal v maximum pevent denoted max p pview set ij set events p see p view denoted ij p also ideal particular ij example figure 1 let denote ideal f0 e 1 g hence ij g hand though g joint view ij ideal views ij p ij q seen two processes general incomparable events two views begin divergethe frontier play crucial role analysis frontiers let ideal p q r 2 p say event e rsentry respect q e 2 ij event known p q whose rsuccessor known q notice need always rsentry p respect q pqfrontier frontier pq defined follows frontier pq rsentry p respect qg 1 theory partial orders order ideals ideals distinct concepts ideals normally assumed subsets v closed directed shall however deal order ideals paper terminology cause confusion observe definition asymmetricin general frontier pq 6 frontier qp example figure 1 let denote ideal f0 e 1 g ij q ij g frontier rq psentry r respect q whereas e 3 qsentry hand frontier qr g e 3 rsentry well ssentry q respect r example demonstrates event e 2 frontier pq could simultaneously r sentry p several different processes r however difficult show process r one rsentry p respect q 3 primary secondary information word u processes p q 2 p already defined latest pq e latest information p q u extend definition arbitrary ideals primary information let ideal p q 2 p latest pq denotes qevent ij p latest pq latest qevent p knows primary information p primary p set flatest pq ig q2p precisely primary p indexed set eventseach event latest pq primary p represented triple p q e usual p p primary p primary p already remarked q 2 p set qevents ij p always nonempty since q 2 0 2 ij p since qevents totally ordered q hence v maximum qevent ij p welldefined notice latest pp compare primary events processes need maintain additional information turns sufficient process keep track processes primary information secondary information secondary information p secondary p indexed set q2p primary q latest pq words latest information p primary information q q 2 p secondary p secondary p event secondary p form latest qr latest pq q r 2 p latest revent q knows upto event latest pq abbreviate latest qr latest pq latest pqr represented events primary p triples form p q e secondary event latest pqr secondary p quadruple p q however often ignore fact primary p secondary p indexed sets events treat convenience sets events thus event e 2 shall write e 2 primary p mean exists process q 2 p p q e 2 primary p iie latest pq similarly e 2 secondary p indicate q r 2 p p q secondary p extend settheoretic operations well instance say e mean find secondary q notice primary event latest pq also secondary event latest ppq equivalently latest pqq following convention primary p secondary p treated sets events write primary p secondary p comparing primary information goal compare update primary information processes whenever meet need following observation regarding significance events lying frontiers ideal rsentry p respect q latest pr also r 0 2 latest qr 0 r secondary q proof since e rsentry f 2 ij q gamma ij p e r f suppose latest pr revents totally ordered r must e r transitive closure irreflexive relation r however e r f well means f 2 ij p well contradiction next must show latest qr 0 r r 0 2 p know path e path starts inside ij path never leaves ij p ij q v maximum pevent must v maximum pevent ij q latest qpr done path leave ij p ij q find event e 0 along path words e 0 r 0 sentry q respect p know earlier argument latest qr 0 must case e latest r 0 r e 0 latest r 0 r e e 00 6 e e latest pr contradiction latest r 0 r e latest qr 0 r done 2 observation frontier events immediately gives us way compare primary information using primary secondary information ideal latest pr latest qr secondary q proof definition latest qr primary q secondary q nothing prove e 6 f exists event e 0 e r e 0 r f e 2 ij know rsentry frontier pq previous lemma secondary q done 2 suppose p q synchronize action u point share primary secondary information event latest pr e u also present qs set secondary events secondary q e u p q know qs latest revent latest qr e u least recent latest pr e u synchronization latest qr e ua latest qr e u whereas p inherits information q ie latest pr latest qr e u way r 2 p p q locally update primary information r e ua clearly latest pq latest qp e new eventie g procedure generalizes arbitrary set p p synchronizes u processes p share primary secondary information compare information pairwise using lemma 2 q 2 decide latest information q process comes away best primary information p compared primary information updating secondary information straightforward clearly latest qr better latest pr every secondary event latest qrr 0 must also better corresponding event latest prr 0 secondary information locally updated words consistently update primary secondary information suffices correctly compare primary formation achieved lemma 2 synchronization involving p p notice processes p come away set primary secondary events preceding argument clear new event belongs primary hence secondary information processes synchronize event update procedure reveals event disappears secondary information processes never reappear secondary information later stage captured formally following proposition proposition 3 let u w 2 sigma w ua 2 sigma let e denote new event wie g ffl e 2 primary p primary p secondary p 4 locally updating primarysecondary information make lemma 2 effective must make assertions locally checkableeg latest pr processes p q must able decide e 2 secondary q recall e represented primary p triple form p e check e 2 secondary q q look quadruple form q r secondary q r p checked locally provided events e u labelled unambiguously u read clearly labelling event e pair ui impossible since general agent consistently supply processes correct value instead may naively assume events e u locally assigned distinct labelsin effect action processes together assign sequential timestamp new c e c c r figure 2 e 7 e 1 2 secondary p 7 r cannot see e 1 secondary frsg e 7 occurrence 2 manner processes p easily assign consistent local timestamps action let compute relations events problem approach need unbounded set timestamps since u could get arbitrarily large instead would like scheme uses finite set labels distinguish events means several different occurrences action eventually get label since update primary secondary information relies comparing labels must ensure reuse labels lead confusion however lemma 2 know compare primary information need look events currently primary secondary sets process sufficient labels assigned sets consistent across systemie label appears current primary secondary information different processes corresponding event actually notice need maintain global temporal order labels across system lemma 2 assures us compare events interest us suffices check equality labels assigned events suppose labelling u want extend consistent labelling uaie need assign label new aevent proposition 3 suffices use label distinct labels aevents currently secondary information e u since cardinality secondary p e u bounded new label must exist catch detect labels currently use unfortunately processes cannot directly see aevents belong secondary information entire system aevent e may part secondary information processes outside aie e 2 secondary p gammaa secondary example let 2 recall action 2 sigma use denote action subset processes synchronize action see page 7 sg figure 2 shows events e corresponding word cbadecc end word e latest pqs e however e secondary e secondary q secondary r secondary e viewed sets events e secondary r e either thus e 1 cevent belongs secondary secondary c e enable processes know aevents secondary p e u need maintain tertiary information tertiary information tertiary information p tertiary p dexed set q2p secondary q latest pq words latest information p secondary information q q 2 p p p tertiary p2p tertiary p event tertiary p form latest qrs latest pq q abbreviate latest qrs latest pq latest pqrs represent event latest pqrs quintuple p q e tertiary p however convenience work tertiary p though simply set events rather indexed set primary secondary information primary p secondary p clearly secondary p tertiary p since secondary event latest pqr also tertiary event latest ppqr equivalently latest pqqr lemma 4 let ideal p 2 p e 2 secondary p every q 2 e proof let e 2 secondary p q 2 e concretely let latest pp 0 p 00 know e 2 ij path e leading e max p passes e latest pp 0 suppose path never leaves ij latest qp means e 2 secondary p latest qp tertiary q done otherwise path e max p leave ij p ij q stage means f 2 frontier qp rsentry earlier argument know latest qr latest qrp 00 latest qqrp 00 hand q find rsentry f 2 frontier qp path e 0 max p r 2 p get latest qr latest qrp 0 p 00 shall use lemma following form corollary 5 let ideal p 2 p e pevent tertiary p primary process p keep track labels use system maintaining tertiary information pevent e initially belongs primary e hence secondary e tertiary e well recall event e also use e denote subset p meets e computation progresses e gradually recedes background disappears primary secondary sets system eventually e disappears tertiary p p sure e longer belongs primary p secondary p since tertiary p bounded set p knows finitely many labels use given time using sufficiently large finite set labels new event always assigned unambiguous label processes take part event 5 gossip automaton using analysis primary secondary tertiary information processes design deterministic asynchronous automaton keep track latest gossip ie consistently update primary information whenever set processes synchronizes processes automaton maintain information terms timestamps event e occurs assigned timestamp e processes take part e local state p defined three associative arrays prim p sec p ter p indexed p p theta p p theta p theta p respectively entry arrays pair form hp p subset p label drawn finite set lit sufficient l n 3 1 entries n number processes p reading word u entry hp arrays prim p sec p ter p corresponds timestamp e event e 2 e u shall show q values stored prim p q sec p q r ter p q fact timestamps events latest pq e u latest pqr e u latest pqrs e u respectively initial state global state process p entries prim p sec p ter p set hp 0 0 arbitrary fixed label l words processes jointly assign timestamp initial event 0 local transition functions modify local states processes follows aevent e occurs processes first choose timestamp e p 2 ha appear ter p recall l n 3 1 labels since n 3 labels ter p p always able find unused label l assign e general choose ha canonical way one possibility linearly order sets p l let p smallest process respect ordering p fix timestamp ha assigned e choose smallest label respect ordering l appear ter pa ii let g corresponding process fix process r 2 follows f2 value stored prim r r appears sec p r od iii p 2 update prim p sec p ter p phases ffl first update fprim p g p2a follows q 2 prim p q ha r 2 ffl next update fsec p g p2a follows q r 2 p q 2 sec p q r prim q r q r 2 p ffl finally update fter p g p2a follows q q verify arrays maintained process p gossip automaton always record timestamps primary secondary tertiary information p proposition 6 let u 2 sigma processes p 2 p values stored prim p sec p ter p reading u satisfy following properties ffl q 2 p prim p latest pq e u ffl q r 2 p sec p q latest pqr e u ffl q latest pqrs e u moreover processes primary q proof proof induction n length u base case u empty string know p 2 p entries prim p sec p ter p initially set timestamp assigned initial event 0 clearly values satisfy conditions specified statement proposition n suppose wa timestamp ha assigned new aevent e step transition appear ter p p 2 induction hypothesis values stored ter p reading w timestamps corresponding events tertiary guarantees event primary p timestamped ha iif event would tertiary information tertiary q every process q 2 result induction hypothesis label ha would ter q reading w every q 2 induction hypothesis also know two distinct events primary p secondary assigned timestamp since primary p primary timestamps assigned primary p also distinct words processes primary q verify updated values prim p sec p ter p p 2 timestamps corresponding events primary secondary tertiary information p u induction hypothesis p 2 values prim p sec p reading w timestamps assigned corresponding events primary p secondary p respectively induction hypothesis also know value stored prim p r reading w value stored sec q 0 reading w fact event latest pr event latest qss 0 follows 2 process r 2 identified step ii transition one processes best primary information r wby lemma 2 latest pr latest qr event latest pr appears secondary q e w equivalent checking timestamp latest pr stored prim p r appears sec q easy see p 2 updates made prim p sec p ter p step iii ensure q latest pq e u sec p q latest pqr e u latest pqrs e u 2 gossip automaton final states since need accept language instead define 2 sigma function g v checks arrays prim p sec p process p computes q 2 p set processes recent information q small technical point g must defined states v however combinations local states may meaningful easily assemble local states form astate inductive assertions hold result procedure comparing primary information breaks however since astates unreachable ignore problem simply assign default value g casesfor instance default value could function fp 7 ag p2p immediately yields result set establish theorem 7 let sigma distributed alphabet corresponding c fg family functions flatestgossip c2sigma locally computable size gossip automaton lemma 8 gossip automaton local state process p 2 p described using 3 log n bits proof local state p consists arrays prim p sec p ter p estimate many bits required store recall ideal event primary p also present secondary p similarly event secondary p also present tertiary p suffices store labels tertiary events array ter p fixing ordering p theta p theta p events stored list n 3 entries new event e assigned label form hp p set processes participated e 2 l already seen suffices 3 labels l result label 2 l written using olog n bits write p p need general n bits component label required guarantee secondary events system distinct labels since set l common across processes however really need use p label e ensure property fix linear order p suffices label e hp e among processes participating e p e smallest respect ordering p easy verify proposition 6 continues hold respect modified labels thus modify automaton processes label event pair pair written using olog n bits overall n 3 pairs array tertiary events whole state described using 3 log n bits 2 preceding lemma implies number local states process could exponential n number processes system general would mean require exponential amount space specify entire automaton though state described using polynomial number bits since transition table automaton would exponential number entries however case need exhaustively enumerate entire state space transition table completely describe automaton since states structured entities transition function presented algorithm manipulates data structured states gossip automaton fact effectively presented space polynomial n ability build gossip automaton efficiently fly crucial embedding distributed algorithms 6 extensions applications beyond tertiary information gossip automaton consistently labels primary secondary events words point distinct primary secondary events distinct timestamps lemma 2 sufficient correctly compare update primary information however may want keep track events older secondary events generalize definition secondary tertiary information inductively define kary information process p respect ideal natural number k case corresponds primary information k 1 kary information p kary p indexed set latest pq words latest information p k gamma1ary information q q 2 p difficult see argument lemma 4 extended yield following result proved formally 15 lemma 9 let ideal p 2 p e 2 kary p every q 2 e e 2 k1ary q together lemma 2 implies gossip automaton modified maintain consistent timestamps events upto depth k natural number k optimizing automaton concerned comparing updating primary information gossip automaton made concise achieve process maintains primary information directed graph reflects underlying v order primary events rather storing information simple array labels described turns processes compare update primary graphs without recourse secondary information secondary information required ensure new events get unused labels tertiary information dispensed altogether leads following result details found 15 gossip automaton modified local state process describable using 2 log n bits important note optimized automaton consistently labels primary events secondary events could get inconsistent labels becomes relevant come applications gossip automaton optimizations possible structure alphabet sigma synchronizations wellbehaved one example processes located vertices ddimensional hypercube ie synchronizations taking place along faces hypercube details found 15 applications building gossip automaton basic step tackling many problems theory asynchronous automata asynchronous automata play important role theory distributed systems close connection trace theory trace theory initiated mazurkiewicz 19 languagetheoretic approach study concurrent systems traditionally formal language theory models computations sequential systems strings abstract alphabet instead trace theory describes computations concurrent systems terms equivalence classes strings called traces strings trace equivalent upto permutation adjacent letters belong underlying independence relation alphabet thus different elements trace correspond different sequential observations concurrent computation deep theorem zielonka 30 shows asynchronous automata natural distributed machine model recognizing trace languages zielonkas original proof connection automata recognizable trace languages widely accepted difficult assimilate 23 show gossip automaton used provide structured proof zielonkas theorem overall construction present quite similar one described zielonkas original paper however feel separating clearly role played gossip automaton proof much easier digest new proofs zielonkas theorem exist 2 based asynchronous cellular automata 31 slightly differentand opinion less intuitivemachine model 13 determinization construction presented asynchronous automata using generalization classical subset construction finite automata construction allows us keep track global states currently valid stage computation nondeterministic asynchronous automaton key problem tackled determinization construction estimate amount information safely forgotten subset automaton without sacrificing global consistency turns sufficient process maintain histories upto level secondary events accomplished using gossip automaton presented assign consistent timestamps secondary events notice optimized gossip automaton 15 cannot used determinization construction since guarantees consistent timestamps upto primary events past years lot interest extending asynchronous automata process infinite inputs analogous buchi automata infinite strings gastin petit 7 defined buchi asynchronous automata operate infinite traces although known automata closed complementation algebraic reasons direct complementation construction provided far buchi asychronous cellular automata 24 safras determinization construction buchi automata 26 recently extended buchi asynchronous automata 14 provides natural procedure complementing automata gossip automaton plays crucial role construction automata infinite strings always closely linked logic 28 connection holds buchi asynchronous automata well recently thiagarajan 27 developed extension propositional lineartime temporal logic interpreted infinite traces rather infinite linear sequences logic appears quite expressive remaining decidable unlike several partialorder logics studied literature 18 decision procedure logic automatatheoretic style vardi wolper 29 except makes use buchi asychronous automata rather conventional buchi automata gossip automaton plays crucial role construction well fact original motivation constructing gossip automaton asynchronous communication paper dealt synchronous communication synchronous communication achieves coordination among independent agents periodically permitting subsets agents pool information together make decision another standard way agents exchange information messagepassing mode exchanging information usually referred asynchronous communica tion since may arbitrary delay time message sent time received synchronous communication easier handle theoretical standpoint well point view programming coincidence languages like ccs 20 csp 11 developed specifying communicating systems assume synchronous communication basic means exchanging information however agents widely separated space asynchronous communication generally practical way achieving coordination considerable body literature devoted distributed algorithms protocols asynchronous systems extended approach deal messagepassing systems communication medium reliable subject certain restrictions number unacknowledged messages present system given time 21 shows analysis based primary secondary tertiary information applicable much wider range distributed systems purely synchronous systems discussed paper discuss connections results work related areas studies gossiping networks traditionally focussed efficiently disseminating fixed piece information gossip one node nodes network 9 main aim find optimal sequence communications distribute data given network topology israeli li 12 introduced notion bounded timestamps argued fundamental solving many problems distributed systemsnotably creating called atomic registers17 results extended considerably simplified number others 3 5 6 8 however line work based shared memory model quite different spirit asynchronous automaton model though may possible formally translate results framework feel intuition underlying timestamping algorithms quite different general solutions timestamping problems seem depend heavily underlying model distributed system used difficult compare algorithms across models closely connected work bounded timestamping algorithms implemented using asynchronous cellular automata study recognizable trace languages 1 2 synchronization mechanism asynchronous cellular automata quite different asynchronous automata asynchronous cellular automata correspond closely shared memory systems systems communicate direct interprocess communication thus though overall goal constructions 1 2 closely related gossip problem studied two timestamping algorithms appear incomparable since based fundamentally different assumptions processes interact definition locally computable functions closely linked notion asynchronous mappings fundamental constructions used 2 would interesting formally characterize class locally computable functions develop methodology automatically synthesizing asynchronous automaton compute given locally computable function done asynchronous mappings 2 though algorithm implemented asynchronous automaton correctly computes latest gossip function locally input word words set communication sequences generated underlying system need regular algorithm also work sequences generated instance n communicating turing machines thus distributed algorithm needs keep track flow information processes incorporate gossip automaton background routine moreover since gossip automaton constructed efficiently fly embedding another algorithm involve significant computational overhead since algorithm add extra messages underlying computation automatically resilient failureseven processes stop functioning algorithm continue update primary information correctly parts system still active underlying computation inbuilt faulttolerance also present shared memory timestamping protocols 1 2 3 5 8 12 others asynchronous automaton move simultaneously performed participating processes strong atomicity assumption crucial algorithm notice label event uniquely fixed primary secondary tertiary information participating processes thus could implement multiway synchronization series synchronous communications processes exchange local information pairwise proceed independently deterministic nature algorithm guarantees process participates event locally choose timestamp new event since processes taking part event base choice timestamp identical shared information similarly process collected primary secondary tertiary information every participating process update local information unambiguously moreover also compute updated information every process took part event construction gossip automaton establishes nonobvious property systems synchronous communication suppose agent p 1 private variable agent modify agents fp track latest value x heard p 1 either directly indirectly along run system bounded timestamps suffice determining fp recent value x important example crash recovery system crashes p 1 fails come alive crash agents get together synthesize optimal lastknown state p 1 comparing information obvious parallels notion primary secondary tertiary information use paper concept levels knowledge events distributed system 10 25 would interesting formally work approach fits knowledgetheoretic techniques analyzing distributed systems far aware none work knowledge theory addressed synchronizing model consider establishing precise connection two approaches straightforward acknowledgments ps thiagarajan suggested gossip problem benefited greatly discussions reformulation gossip automaton terms ideals frontiers emerged work nils klarlund determinizing asynchronous automata suggestions great help cleaning pre sentation also thank robert de simone pointing subtle technical errors finally thank referees several useful comments r approximations trace asynchronous mappings asynchronous cellular automata combinatorial aspects timestamp systems combinatorics traces bounded concurrent timestamps constructible simple efficient bounded concurrent timestamping bounded concurrent timestamps comprehensible asynchronous cellular automata infinite traces concurrent time stamping made simple survey gossiping broadcasting communication networks knowledge common knowledge distributed environment communicating sequential processes bounded timestamps determinizing asynchronous automata determinizing buchi asynchronous automata optimizing gossip automaton distributed computing models methods share concurrent asynchronous wait free variables logical study distributed transition systems basic notions trace theory communication concurrency keeping track latest gossip messagepassing systems keeping track latest gossip bounded timestamps suffice complementation buchi asynchronous cellular automata distributed processes logic knowledge complexity trptl trace based extension linear time temporal logic automata infinite objects automata theoretic approach automatic program verifica tion notes finite asynchronous automata safe executions recognizable trace languages tr communicating sequential processes communication concurrency bounded concurrrent timestamp systems constructible knowledge common knowledge distributed environment combinatorics traces automata infinite objects distributed computing simple efficient bounded concurrent timestamping bounded concurrent timestamp systems comprehensible concurrent timestamping made simple combinatorial aspects timestamp systems asynchronous mappings asynchronous cellular automata logical study distributed transition systems approximation trace asynchronous automata ordering events distributed system share concurrent asynchronous waitfree varaibles preliminary version asynchronous cellular automata infinite traces complementation bmyampersanduumlchi asynchronous cellular automata determinizing asynchronous automata safe executions recognizable trace languages asynchronous automata keeping track latest gossip determinizing bmyampersanduumlchi asnchronous automata distributed processes logic knowledge basic notions trace theory ctr zielonka timestamps mazurkiewicz traces theoretical computer science v356 n1 p255262 5 may 2006 madhavan mukund k narayan kumar milind sohoni bounded timestamping messagepassing systems theoretical computer science v290 n1 p221239 1 january kamal lodaya regular viewpoint processes algebra acta cybernetica v17 n4 p751763 january 2006
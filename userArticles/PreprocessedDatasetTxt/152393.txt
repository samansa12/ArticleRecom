coordinating rulebased software processes esp esp language modeling rulebased software processes take place distributed software development environment based polis abstract coordination model relies multiple tuple spaces ie collections tuples la linda polis extends linda aiming specification coordination logically distributed systems esp extended shared prolog combines polis mechanisms deal concurrency distribution logicprogramming language prolog deal rules deduction combination coordination model logic language provides powerful framework experiments rulebased software process programming performed evaluated b introduction introduction theme software process modeling recently addressed several specific conferences see instance 12125 survey see 19 interest stems fact activities involved software development complicate expensive errorprone seems necessary completely specify development process order gain control improve quality software process program formally define activities carried development software project providing guidance agents involved controlling overall evolution project status 33 paper devote attention fact software process takes place necessarily within software development environment environment supports coordinates interactions project members allows use programming tools monitors evolution project documents show environment designed goal explicitly modeling coordinating process fact suggest natural way model software process consists introducing suitable abstract machine defining environment software process developed suitable programming language able control process evolution guiding principle order specify software process must clarify coordination model 13 used agents ie must make explicit communication mechanisms basis interaction protocols used participants software project identify coordination model abstract architecture environment supports execution process main contribution paper definition abstract paradigm modeling coordination activities take place inside software development environment paradigm called polispaces polis based multiple tuple spaces 23 polis allows software process designer model software process takes place inside multiuser distributed development environment modeling activities form software process approach similar used marvel 89 merlin 2434 activity takes place environment prescribed process governed rules respect systems put emphasis coordination mechanisms allow us combine rules govern software process declarative language allows express rules proposal includes three steps first define abstract coordination model coordination model set abstract mechanisms expressing controlling sets sequential activities 13 approach activity expressed sequential language interactions respect activities defined using coordination model coordination model polis based multiple tuple spaces ie collections tuples manipulated operations offered linda coordination language 22 second order able express rulebased software processes use logic programming take advantage inferential relational capabilities introduced elsewhere parallel logic language shared prolog 11 combines prolog lindalike tuple space use extension shared prolog better suited distributed program ming fact extended shared prolog esp short logic language combines features polis distributed programming declarative inferential capabilities prolog finally weshowhowesp used model software process takes place inside distributed software development environment idea software process explicitly defined rules form coordination protocols govern activities inside distributed environment rules specify goals duties constraints agents involved software process fulfill suggest environment imposes constraints supports coordination protocols among users controlling environment means governing software process concepts distributed development environment rulebased software process well interplay naturally modeled polis easily implemented esp fact show esp used design simple programming environments corresponding simple software processes power esp tested using oikos rulebased development environment able execute software process models written esp 24 oikos offers number standard services giving basic facilities like access databases private workspaces activation shells etc esp language used implement desired software process paper organized follows section 2 introduces polis model distributed programming section 3 describes extended shared prolog programming notation based polis section 4 shows esp used design simple software development environments processes section 5 summarizes main design principles underlying oikos finally section 6 contains comparisons related work model coordination intuitively multiuser software development environment seen like abstract town many places several agents distributed places cooperate producing documents either remain place sent another place town many activities performed simultaneously mostly independently however ruled laws policies constraints either physical eg available resources like space time abstract eg set laws prohibit behavior suggest software process designer set multiuser software development environment design polispace ie distributed system collection named tuple spaces concepts tuple tuple space borrowed linda polis extends linda allowing multiplicity tuple spaces precisely polis three concepts important tuples agents tuple spaces 21 tuples tuples sequences variables values linda values depend chosen sequential programming language used programming agents however polis number basic value types well lists values allowed example instance tuples paolo programmer program program1 module1 module2 module3 useful conventions tuple always parenthesized identifiers quoted begin capital letters denote variables identifiers denote atoms square brackets denote lists tuples denote simply data objects exist tuple space produced agent possibly future consumed agent scope variables inside tuples spans tuple belong means tuple inside tuple space completely independent tuples tuple produced agent tuple space remains agent consumes access tuple associative ie done contents particular access mechanism chosen degree freedom eg polis accommodate either mechanism based typed pattern matching linda mechanism based unification logic language 22 agents abstractly agents execution threads ie agent process executing program linda agent represented called active tuple important difference linda polis latter agent executes program contained tuple special kind called programtuple program written sequential programming language enriched set tuple space operations 221 tuple space operations agent use following tuple space operations interacting tuple space lives ffl associative test tuple contained agents tuple space associative consumption tuple agents tuple space asynchronous creation tuple space tuple operations borrowed linda two different flavors test consumption operationsthey either blocking notblocking two blocking operatorsone creation tuple one creation new tuple space blocking test operation linda written readtuple schemata nonblocking test operation written readptuple schemata blocking consumption operation written intuple schemata nonblocking consumption operation written inptuple schemata tuple schemata tuple containing formal arguments ie wild cards match actual argument inside tuple contained tuple space actually readp inp considered part standard definition linda maintain polis agents need maximum generality accessing tuple spaces successfailure semantics readpinp useful using logicbased control structures agent output either tuple tuple space ie creates new tuple space former operation written outtuple case local writing outtupletuplespace case outside writing latter one written tsctuplespace target output operations always tuple space specified using name name specified default tuple space agent used happens operation targets external tuple space exists polis consistent linda semantics nonblocking operation ie agent issue wait result error code never fails communications among tuple spaces supported meta tuple space undelivered tuples remains deposited whenever tuple space comes existence undelivered tuples pop tuple space agent needs certain message gone way must explicitly use protocol instance could send message agent sends back acknowledgment finally note agent test consume tuples representing agents useful build agents schedule agents tuple spaces cannot operands either testing consuming obvious semantics operations copy whole tuple space delete whole tuple space necessarily manipulate global state tuple space contrast asynchronous nature internal activities 222 programtuples linda program invoke arbitrary sequences tuple space operations polis agents follow instead fixed protocol invoking tuple operations syntactically program agent executes written inside programtuple heading heading tuple schemata test consume sequences tuple operations whereas loc eval sequential computation side effect tuple space agent belongs agent activated tuple space contains programtuple normal tuple matching heading programtuple latter consumed second component programtuple also called pattern executing pattern agent following actions ffl reads something tuple space using number test operations actually test operation polis broader semantics read linda number predefined tests tuple space allowed depending chosen type system tuple arguments useful predefined tests relational binary predicates var1 predicate check argument inside tuple variable thisplace1 predicate returning name tuple space agent located ffl deletes tuples using number consumption operations ffl executes local evaluation effect tuple space insofar operations tuple space allowed local computation expressed sequential programming language ffl outputs results number tuple spaces knows outputs consist tuples tuple spaces ffl end sequence agent dies terminating thread evaluation however specify everlasting agent inserting among outputs creation copy computing model underlying computation agent idea agents stateless reactive ie compute molecule tuples built inside tuple space molecule composed programtuple normal tuple matching first component programtuple tuples consumed specified consume section programtuple agent reacts environment burning molecule creates new entities specified create section semantics studied 17 example everlasting chemical reaction seen tuple space containing two table tennis players agent begins building molecule tuple ping consumes tuple produces tuple pong copy turn agent b reacts consumes tuple pong producing tuple ping copy b either forever something outside comes alter chemical solution instance suppose external agent sends new ping tuple tuple space soon new tuple noticed agent two agents longer serialized 2 remark programtuples tuples ie freely added removed tuple space thus providing indirect means manipulating agents example remote evaluation agent tuple space source needs sure output reached tuple space dest use following protocol ie agent sends message msg representative b destination tuple space tests presence message sends back ack message 2 223 non deterministic evaluation agent semantics outlined simple defined inputoutput relationship independent global environment ie tuple space agent reactive ie reacts tuple space sense set testing consuming operations contained program thought firing pattern activates computation local evaluation finally modifies tuple space actually semantics even simple since problems specifying interesting situations instance situations impossible give agent input needs start computation increase verbosity programs moreover mutual exclusion relationships boring specify must handled explicitly defining semaphore tuple set agents mutual exclusion define non deterministic agents simply putting tuple space set programtuples whose headings match example programtuples describing behavior agent either edit compile execute file following editfile new outnew compilefileobject outobject execfileresults outresultssuch set compared hoares csp guarded command object defined set methods logic predicate defined set clauses yet another extension polis respect linda offer nondeterministic operation non determinism useful specify complex tasks partitioned several alternative subtasks 23 tuple spaces tuple space named multiset passive active tuples syntactically write tuple spaces sequences tuples curly brackets example describe tuple space named workspace containing three tuples write follows difference respect linda polis tuple space two attributes name set invariants 231 names tuple spaces important feature polis tuple spaces name agents send tuples outside tuple space using name another tuple space tuple space names freely passed arguments tuples possible dynamically build complex communication flows name system tuple spaces degree freedom polis like choice sequential language local computations type system chosen tuples means polis offer specific name system programming language based polis choose name system tuple spaces names tuple spaces form flat structure eg pointers tuple spaces independent scoping rules simple tuple space names form global environment names structured tuple spaces structured well eg names paths unixlike style tuple spaces form tree similar unix filesystem name system used oikos see 5 232 invariants whereas agents ephemeral stateless tuple space seen object persistent state 41 tuple space passive entity mere repository tuples channel messages way controlling activities take place inside tuple space fact tuple space define one invariants ie constraints must hold tuple space life span whenever invariant violated tuple space stops activities terminates tuple space garbage collector could claim resources allocated tuple space invariants defined inside special programtuples heading substituted keyword invariant test section defines condition tuple space verified terminates tuple space loc eval sections used compute communicate results tuple spaces example following invariant invariant tuple validateddesign produced tuple space terminates communicating tuple startcoding tuple space named manager 2 invariant concept present linda polis useful specify intended semantics tuple space condition specified invariant verified result obtained passed tuple space 3 esp parallel language combines polis prolog could accommodate sequential language expressing local computations inside agents instance clinda considered instance polis sequential language c tuples built using c data types unique tuple space allowed linda constraints use tuple operations ie use program read order however note sequence linda operations split number subsequences subsequence begins readin operations terminates operations order explore effective usefulness polis design rulebased software processes environments introduced esp programming language combines polis prolog esp actually extension parallel logic language shared prolog 11 logic language uses blackboard model 31 organizing interprocess communication approximations shared prolog considered member linda family physically distributed programming languages 22 shared prolog gains expressive power respect linda exploiting unification backtracking agent accesses tuple space linda uses pattern matching backtracking allowed esp generalizes shared prolog multiple tuple spaces 31 theories esp program composed set modules called theories theory following syntactic structure theory namev heading eval rule 1 rule k theory interface prolog program theory implementation theory module identified name zero arguments v logic variables scope rules theory interface follows keyword eval includes number rules also called patterns separated symbol theory implementation prolog program follows keyword reader familiar prolog find good introduction terminology 37 example following theory includes one rule defines agent compiles file finds tuple space tuple compilefile result agent activation either success tuple sent blackboard test compilation fails failure message blackboard user theory compiler eval call compilerfile p rolog goal fcompiledfiletestg success fail freport errorfileuserg f ailure call compilerfile p rolog program special predicate invokes compiler fails compilation failsan esp theory including set rules similar csp guarded command one rules fire agent executing theory commits rule one rule fire one chosen non deterministically esp rules clauses include est section formally goal evaluated respect current contents tuple space consume section describes multiset tuples consumed loc eval section prolog goal evaluated respect prolog program finally operations make explicit fact side effects tuple space consumption creation operations put curly brackets test combination test consume sections guard guard satisfied ie test satisfied consume operations completed rule fired means tuples consumed really deleted prolog goal evaluated deal possibility failure prolog goal creation operations partitioned two sets separated keyword fail goal evaluation succeeds success produced else failure produced example following rule first line test section second line consume section rule states tuple spaces contains tuple filef contain tuple reservedf tuple check outpf found deleted produce tuple reservedfbyp tuple space tuple filef tuple space named value bound p filef reservedf fcheck outpfg freservedfbyp filefpgcommunications agents tuple spaces denoted simply adding address destination tuple space tuple send destination tuple space yet created tuple simply waits creation consistently extends linda semantics operations polis framework finally remarks prolog program follows keyword prolog builtins used except predicates alter program like assert retract guarantees agents stateless required polis semantics state information must stored tuple space 32 logic tuple spaces esp tuple space also called blackboard named multiset logic tuples logic tuple simply prolog term blackboards dynamically created agents simply using activation goal form tscnamefcontentsg activation goal specifies name tuple space possibly initial contents example goal creates three tuple spaces tuple space bb pm initially contains tuple develop change testunit ftscbb ccb tscbb pmfdevelop change testunitg tscbb ptgin general execution anesp program builds set tuple spaces set grows tuple space created shrinks tuple space terminates ie invariant fires example goal associates two invariants tuple space bb pm tuple space terminates either tuple end workid tuple abort workid found contents finvariantend workidbb pt invariantabort workidbb ptg33 evaluation logic agents esp tuple space seen programming construct encapsulates parallel evaluation logic agents logic agents represented active tuples tuple active matches heading theory agent executes rules read delete tuples tuple space result evaluation rule normally consists creation tuples tuple space notable feature esp control flow test consume operations ruled backtracking test consume operation either successful fails failure activates backtracking preceding operation example suppose following subset tuple space f deliverany spec1 spec2 impl2 g agent commits rule specx fdeliverx implxg fmodxg tuple deliverx consumed 2 resulting tuple space subset f spec1 spec2 mod2 ga formal semantics behavior given 11 34 esp implementation esp language evolved extension shared prolog currently two distributed implementations one stand alone 12 one based linda 18 first one implemented part c part prolog c layer implements socketbased meta tuple space supports number communication primitives usable prolog processes prolog process handle either several blackboards several agents linda based implementation meta tuple space clinda program remotely forks one worker new logical tuple space representative communicates via sockets prolog process handles one logic tuple space details concerning esp implementation see references 341 interaction user esp used parallel programming like linda typical parallel application program needs massive computation power search inside number distributed knowledge bases linda course much efficient esp easily used symbolic applications good example program coordinates several agents cooperating solve code according rules mastermind 14 benchmarks show current esp distributed implementation least efficient parallel implementations production systems 18 however real use intended esp design programs coordinate interact number users instance developed program coordinates four players intend play bridge network player connected different workstation program distributes cards players handles trick keeps score programs class developed simple distributed agenda coordinate committee meetings email system financial simulation users buy sell stocks number simulated stock markets distributed applications make large use interactive capabilities prolog possible launch even remotely special logic tuple spaces directly communicate terminal called shells user produce consume tuples within shell connected principle blackboard user access whole universe blackboards sending message tuples even active tuples open new shells blackboards practice interaction blackboard system constrained rules define shell example following theory defines shell enables user put commands tuple space tuple space contains tuple access granteduser commands syntactically correct test compile edit oe gammapsi l l l oe oe oe figure 1 polispace coordinating simple programming environment theory simple shelluser eval access granteduser read commandcommand ftuplecommand simple shelluserg fail fsimple shelluserg read commandcommand check legality command uses prolog io predicatesthis theory shows user inputs enter polispace io model used esp based prolog io builtin predicates process programming esp activity programming lindabased logic language explored elsewhere 161738 section show esp used language modeling simple software processes related development environments 41 tiny programming environment simple software process takes place programming environment including editor compiler specify naive software development process consists editing file compiling soon editing programmer terminated compilation gives errors object program invoked executed using test data fig1 depicts environment polispace order build esp program implements polispace need three theories one editing agent actually shell user one compiler agent one executing agent theories use predicates called envelopes 26 encapsulate external software tools envelopes useful introduce nondeclarative operators inside declarative framework able call standard unix tools via system predicates return logic result ie either success failure theory editoreditor tty eval call editoreditorttyfile fcompileuserfilecompileg call editoretf theory compiler eval call compilerfile fcompiledfiletestg fail fdo editfileuserg call compilerfile invoke envelope cc compilations fails errors theory testerdatafile eval test datadatafile fcompiledfileg runfiledatafileresult fail ftest errorfileg runfiledatafileresult invoke prologunix envelope object file minimal programming environment enforces simple editcompiletest programming model user interacts tuple space actions tuple spaces coordinated esp program 42 multiuser environment enforcing access protocol software project composed set modules developed team programmers software process designer design software development environment enforces following policy updated public version whole project stored within main database users access main database read mode coordination based reservedeposit access protocol main database guarantees mutual exclusion consistency main database always contains consistent updated version project modify contents module user must reserve module gain write access obviously time module reserved reserved module copied user database user modify reserved module edited user database users access read mode old public version user 1 db user 2 db user 3 db main database oe figure 2 polispace coordinating multiuser environment module stored main database changes module completed tested user deposit new version back main database updated version readily accessible users polispace realizing environment showed fig2 code theory user db manager handles users requests user database following theory user db managerdbmain eval fcheck infile dbmaing fcheck infileudbdbmaing fcheck outfiledbmaing fcheck outudbfiledbmaing since user issue blackboard either checkin checkout command rule command simply transmits tuple main database blackboard tuple space contains two agents guarantee consistency main database checkin manager checkout manager execute following theories theory checkout manager eval filef reservedf fcheck outpfg read request file f programmer p request granted filef file f exist fcheck outpfg ferrorno filefpg request granted reservedfbyop p 6 op file f reserved programmer op fcheck outpfg ferroris lockedfbyoppg request granted first rule reserves requested file rules handle different error situations theory checkin manager eval filef fcheck infpg create request file f programmer p ffilefg fcreatedfpg request granted filef reservedfbyfp fcheck infpg modify request file f programmer p call file servermodify f p fmodifiedfpg request granted filef reservedf fcheck infpg cannot create file f exist ferrorfile existsfpg request granted fcheck infpg file f reserved ferroris lockedfbyoppg request granted call file servermodify f p asks file system get new file f ps workspace first rule create new file second rule modifies file invoking envelope operating system service rules handle different error situations 43 software process program fragment october 1990 organizers sixth international software process workshop suggested software process problem workshop participants 27 problem specifies process natural language concerns development change testing defective software module process decomposed number phases designing coding testing management change authority ccb charge project programmers team pt coordinated project manager pm show software process designer could model part process esp start creating three blackboards one ccb one pm one pt following goal sets initial distributed environment process take place ftscbb ccb tscbb pmfdevelop change testunitg tscbb ptg blackboard bb pt specify termination condition using following invariants finvariantend workidbb ptinvariantabort workidbb ptg means blackboard bb pt terminate activities either tuple end workid tuple abort workid found following esp theory controls overall process viewpoint project manager pm theory develop change testunit eval fschedule assign tasksunitstart workunitidbb ptg fend workidbb ptg fcancel changeidg fabort workidbb ptg theory develop change testunit includes three rules first one describes activation process starts ccb issues authorization tuple specification changes target unit project manager responds stimulus starting schedule assign tasks phase defined another esp theory two rules state possible terminal conditions process theory schedule assign tasksunit eval fchangerequirementsunitid project plansplansg fproject plansnewplans mailassignmentsbb pt changerequirementsunitidbb ptg updateplansnewplans definition new scheduling tasks brevity give complete process program detailed solution problem found 3 44 discussion examples given section admittedly complex moreover features also offered existing well known tools instance something similar first example difficult make tool writing script sophisticated editor like gnu emacs whereas second example captures basic mechanisms tool like sccs however examples show esp distributed computations easy deal instance easy specify different allocation policies first example three agents editor compiler tester integrated unique blackboard allocated one workstation else put different blackboards aiming enforcing distribution protection moreover combining different software processes also difficult following goal sets environment combines program first example program second example ftscmaindbfcheckin managercheckout managerg tscuser1fuser db managermaindb editormodule1tty1g tscuser2fuser db managermaindb editormodule2tty2g tsccompilefcompilerg tsctestftesterdata1test datadata1 gg important chosen examples order show esp possible program control several levels coordination ffl overall structure software development environment defined set named tuple spaces devoted distinct activities ffl activities encompassing several tuple spaces defined communication flows tuples sent tuple space another ffl coordination agents inside tuple space defined multiset tuples active tuple space ffl concurrent interactions among different agents tuple space defined semantics tuple operations ffl tasks agent perform defined rules theory executes ffl actions agent perform task activated defined knowledge base theory executes believe software process programming difficult complex undertaking mainly different coordination levels taken account amalgamated harmonious assembly although esp based small number language mechanisms used program levels coordination declarative way fact esp keeps logic programming paradigm view computation proof search thus obtain free formal semantics local ie non related tuple space evaluations agents admittedly esp moves away pure logic programming rely different expressive framework fact esp enriches logic programming set coordination mechanisms agent tuple space creation intertuple space communications although esp powerful expressive language programming coordination goal managing definition evolution software process would impossible attack without support specialized environment apart definition execution esp programs environment allow integration software process tools needs offering repository services used building blocks complex software processes environment oikos oikos experimental rulebased software development environment supports process programs written esp 2 oikos provides number predefined facilities model rulebased software processes distributed system overall approach consists offering mechanisms easily composed using esp used model different software processes oikos software process esp program coordinates dynamic collection agents cooperating distributed environment modeled hierarchy blackboards hierarchy offers natural way structuring software process conceptually similar contractual hierarchy istar 20 istar nodes tree documents whereas oikos tuple spaces fact blackboard hierarchy used reflect decomposition software process subprocesses according topdown refinement strategy hierarchy really constraining communication flows among participants software process since blackboard names exchanged tuples agent put tuples blackboard provided knows name destination fore highly dynamic communication patterns set even connecting blackboards different levels hierarchy convenient give short description current system architecture interested reader find details 254 51 services oikos key concept oikos service predefined subsystem accepts requests clients conceptually service offers access shared resources according given set rules shared resources include software products tools process program etc formally service defined byanesp program specifies protocol interaction service ie tuples must put blackboard submit request number standard services oikos play role primitive operators data types play programming language discuss two oikos services database service dbs user interface service uis order store information documents software process oikos offers service dbs interfaces database management system currently dbs salad deductive database management system based logic language 15 dbs accepts scheme definition requests queries transaction requests also enforces access rights one first duties software process manager set project database defining scheme describing properties relations among different kinds documents oikos provides predefined schemes reusable documents related oikos eg containing service specifications related tools already available start documents actually stored files manipulated blackboard via identifiers necessary operate document tool eg editor document retrived underlying file system pre layout quit open bb pm interface history script enter clear expand precond edit hold refresh expand blackboard figure 3 esp user interface users accesses oikos shells managed user interface service uis user see contents blackboard window action must comply rules defined uis specification uis service several different shells coexist shell offers flexible way monitor software process since user activate blackboard looking tuple flow even saving tuples record evolution software process 30 fig3 shows user sees connected esp programming environment xwindows esp programming environment called expo 5 conceptually user opens window see contents blackboard also put remove tuples blackboard fig3 leftmost top window shows current contents blackboard number buttons allow manipulation window leftmost bottom window used edit shell patterns ie rules inserted evaluated fly user interested events happens blackboard typically tuples appear disappear rightmost top window shows history user actions rightmost bottom window shows name blackboard three buttons used manipulate windows expo ffomega ffomega ffomega ffomega upsilon figure 4 oikos architecture 52 oikos implementation oikos written mostly esp fig4 shows architecture oikos prototype implemented university pisa top local network sun worksta tions esp provides basic mechanisms physical distribution dynamic activation communicating processes three main layers oikos architecture shown fig4 expo programming environment written esp provides xwindowsbased user interface 5 collection separate processes implement distributed esp runtime system underlying operating system unix hierarchy blackboards represented nested boxes processes second layer depicted circles esp process local interpreter esp language many machines network eager interpret pieces esp program detailed exposition see 125 6 comparison related work first compare esp coordination languages compare rulebased process programming languages 61 comparing esp coordination languages esp language combines lindalike coordination prologlike computation extension prolog sense clinda extension c comparison linda main difference esp based multiple tuple spaces moreover gains expressiveness thanks magic logic programming however esp mere prologlinda dialect structure clauses structure ie test consumecomputeoutput makes esp similar parallel logic languages like flat concurrent prolog ghc 36 important difference respect languages esp tuple spaces state agents manipulate adding deleting tuples fcp ghc operate shared streams monotonic way ie add new data moreover esp true extension prolog whereas fcp ghc sequential component parallel logic languages based notion logical tuple space programming notation similar esp swarm 35 specification language based unity introduced studying programming logic underlying tuple space communications esp tightly related swarm logic programming many constructs programming large currently missing swarm linear objects lo 7 object oriented language based concept multiple tuple spaces communicate broadcasting apart many similarities esp lo studying unified semantic framework 6 respect rule based programming languages like instance production systems like ops5 esp rules merge cleanly two basic evaluation mechanisms forward backward chaining backward chaining used local computation prolog goals form parallel forward chaining used basic mechanism activating agents logic tuple space also similar blackboard 31 fact many esp implementation issues discussed way blackboard systems detailed discussion esp related implementation issues contained 1218 62 comparing esp rulebased process programming languages well known project inspired oikos rulebased software development environment marvel 89 marvel follows object oriented design paradigm relies upon special rulebased language derived production systems ai applications software process specified three sets specifications project rule set describes development process project type set specifies project data project tool set defines interface external tools example marvel rule 9 fcompile compiler compile fcontents fobject code ferror msg g fcompile status compiled fobject time fcompile marvel rules name include three sections precondition activity part postcondition precondition condition evaluated respect current status project database verified activity part executed usually invokes tool end tool activity postcondition specifies effects rule project database rule could easily translated esp follows compilecc g file object code error msg timecurrenttime fc filefilecompiled object filefile currenttimeg fail compilecompiler file object code error msg marvel puts emphasis designing interaction protocols used multiplicity users share project database esp importance put environments architecture design aiming formalizing coordination model underlying users activities key issue esp use blackboard model combination logic programming blackboard model problem solving well known artificial intelligence 31 whereas software engineering exploited projects instance agora 10 uses blackboard architecture interprocess communication among heterogeneous software components recent relevant example rebus blackboard curiously called whiteboard 40 rebus process program written appla 39 extension ada software process modeling rebus whiteboard used five ad hoc primitives manipulate contents whiteboard used coordinate activities number participants software process experience combination blackboard model logic programming provides powerful rulebased framework specify prototype distributed software development environments related software processes use logic programming techniques tools software engineering slowly gaining popularity instance darwin project 2829 develops prologbased framework support rulebased software engineering environments called law governed systems darwin law explicit statement rule must followed agents environment environments written esp considered lawgoverned systems whose laws stated parallel language use prolog software process programming suggested first time 32 without introducing concurrency mechanisms successful project rulebased environment centered upon prolog merlin 2434 merlin used model rulebased software processes using extension prolog forward chaining backward chaining computations possible merlin extends prolog imperative constructs like instance call insert remove operate clauses contained knowledge base example merlin rule documentmodule object name compiled callcompiler object name compile status removedocumentmodule object name compiled insertdocumentmodule object name compile status rule easily translated esp follows fdocumentmodule object name compiledg ublcs938 22 conclusions compilecompiler object name compile status fdocumentmodule object name compile statusg complex sequences including several insert remove commands arbitrary order could rephrased esp using chains rules currently merlin project take account concurrency distribution issues believe polis coordination model would natural way extend merlin features deal concurrency parallelism conclusions paper introduced polis coordination model useful designing distributed systems programming notation based combination polis prolog esp used language software process modeling esp used design implementation oikos rulebased software development environment distributed local network esp programming environment operational three years used implement distributed multiuser applications like referee coordinating four bridge players financial simulation stock exchanges simple email system software processes simulated fully enacted like instance software process defined section 43 future plans include development graphic specification language help development software processes successively modeled esp definition planning tools assisting users software process possibility changing software process program execution moreover feel polis whole coordination framework based multiple tuple spaces deserve deeply studied instance developing programming logic polis aimed developing specification language suitable distributed applications acknowledgments contribution given referees comments improvement paper invaluable author also grateful ncarriero dgelernter yale many discussions linda polis phd thesis supervisor umontanari suggestion studying associative coordination mechanisms last least author thanks members shared prolog oikos research groups pisa especially vambriola abrogi mdanelutto mgaspari cmontangero work partially supported cnr progetto finalizzato sistemi informatici e calcolo parallelo italian ministry university scientific research murst r acm ieee enacting software processes oikos software process specification oikos oikos age three expo framework fo process centered environments interaction abstract machines linear objects logical processes builtin inher itance modeling concurrency rulebased development envi ronments scaling rulebased software development environ ments multilanguage parallel programming heterogeneous chines concurrent language shared prolog extended shared prolog multiple tuple spaces logic language coordination languages significance static analysis parallel logic language based blackboard model ldl system prototype blackboard programming shared prolog parallel logic programming using linda model computation parallel programming logic languages survey process modeling integrated project support istar generative communication linda multiple tuple spaces linda step towards knowledgebased software process modeling multiuser distributed language based environ ments imposition protocols open distributed systems configuration management consensus application lawgoverned systems software process histories oikos blackboard systems blackboard model problem solving evolution blackboard architectures process programming prolog software processes software knowledgebased software development environment supporting cooperative work mixed programming metaphors shared dataspace model concurrency family concurrent logic languages art prolog language constructs managing change processcentered environments programming software requirementsspecification process concepts paradigms objectoriented programming tr generative communication linda blackboard model problem solving software processes software multilanguage parallel programming heterogeneous machines family concurrent logic programming languages process programming prolog blackboard programming shared prolog mixed programming metaphors shared dataspace model concurrency configuration management consensus application lawgoverned systems software process enactment oikos language constructs managing change processcentered environments concurrent language shared prolog imposition protocols open distributed systems coordination languages significance process modeling concepts paradigms objectoriented programming ldl system prototype modeling concurrency rulebased development environments software process technology scaling rulebased software development environments oikos age three parallel logic programming using linda model computation multiple tuple spaces linda
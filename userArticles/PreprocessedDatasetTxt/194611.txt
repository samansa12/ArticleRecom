tight bounds oblivious chaining chaining problem defined follows given values chaining problem appears subproblem many contexts known algorithms solve chaining problem crcw prams oalphan time alphan inverse ackermans function slowly growing function author studies class algorithms called oblivious algorithms problem simple oblivious chaining algorithm running oalphan time presented importantly optimality algorithm demonstrated showing matching lower bound oblivious algorithms using n processors first steps toward lower bound chaining algorithms also provided showing chaining algorithm runs two steps must use superlinear number processors proofs use prefix graphs weak superconcentrators interesting connection two demonstrated idea used obtain improved bounds size prefix graphs b introduction consider following problem called chaining given values 1 ig define output viewed pointers chain 1s linked list chaining problem natural problem consider context database retreival operations records satisfy particular predicate correspond input bits value 1 chaining 1s corresponds making linked list records future processing apart appears subproblem many contexts studied 16 17 parallel integer sorting 2 14 parallel merging integers drawn restricted domain 3 parallel subset compaction 18 1316 circuits computing threshold functions 15 examples easy solve problem time using one processor using processors fast parallel algorithms exist running times close constant reason simplicity open question theoretical interest 3 1617 whether constant time parallel algorithms exist berkman vishkin 4 independently ragde 16 given parallel algorithms solve chaining problem offn time using n processors ffn inverse ackermans function slowly growing function using algorithms similar chaining algorithm berkman vishkin 5 give algorithms achieving bounds problems lowestcommonancestor problem parenthesis matching problem study oblivious algorithms chaining problem informally oblivious algorithm one pattern memory access depends n size problem specific input class algorithms interest algorithms berkman vishkin ragde modified oblivious present simple oblivious algorithm chaining running offn time performance bounds previously known algorithms algorithm simple makes use previously known graph structures importantly show class oblivious algorithms optimal proving oblivious chaining algorithm using n processors time since known algorithms chaining made oblivious gives evidence superconstant lower bound chaining algorithms chandra fortune lipton 7 showed circuit bounded depth prefixcarry problem requires superlinear size implying superconstant lower bound depth circuits linear size essentially show circuit must structure special type graph called prefix graph prove upper lower bounds size prefix graphs bounded depth 6 7 demonstrate connection prefix graphs another family graphs called superconcentrators 11 using idea present simple proof improves lower bound 7 shows construction 6 optimal dolevdwork pippenger wigderson 11 showed lower bound weak superconcentrators bounded depth lower bound oblivious chaining algorithms obtained interpreting algorithms graphs using techniques 11 analyze properties worth noting chaining algorithms whose graphs weak superconcentrators hence lower bound 11 cannot used directly provide first steps towards proving lower bound algorithms showing chaining algorithm terminates 2 steps requires superlinear number processors time submission paper conjectured techniques developed paper would useful proving lower bound algorithms indeed case techniques used recently extended prove lower bound chaining algorithms 9 model computation used paper concurrentread concurrentwrite parallel random access machine crcw pram common model crcw pram processors simultaneously write memory cell must write value powerful priority model processor associated priority several processors simultaneously write memory cell highest priority processor succeeds shown priority model strictly stronger common model 1 show considering oblivious algorithms models equivalent common machine extra memory thus throughout paper algorithms described run common model lower bound proved priority model oblivious computation prams input algorithm chaining consists value n size problem n bits called input vector representing problem step processor computes based actions far memory address access contents write write step oblivious algorithm mean one address accessed fixed input vectors ie depends value n however whether processor performs action may depend input vector example fifth write step p 1 writes always writes c 15 may may write depending input vector definition oblivious algorithms coincides called semioblivious 10 convenient model computation oblivious algorithm graph given algorithm input size n directed graph g defined follows vertices g grouped levels suppose algorithm solves chaining problem k steps graph g consist 2k vertices numbered 0 2k even levels vertex cell memory accessed algorithm vertices form c 2j 0 j k called cell vertices cells odd levels vertex processor vertices form p 2j called processor vertices processors thus k levels processor vertices cell vertices edges g defined follows input vector step j input vector step j initially bit input vector assumed cell finally output value corresponding bit assumed cell shall refer vertices 0 x vertices 2k let p number processors used number cells accessed computation 2kp two kinds edges graph adjacent processor vertex others since processor vertex degree 4 former 4kp number cell accessed computation k cell vertices graph one even level thus total number cell vertices graph 2k 2 p since cell vertex adjacent two latter type edge 2k 2 p edges hence number edges graph certainly upperbounded 6k 2 p given input vector length n shall associate cell vertex content processor vertex state content associated c 2j content cell c step j j 1st readwrite step computation input state associated state processor p read step j 1th readwrite step computation time computation action processor dependent solely state processor starts fixed initial state partial input one b 2 f0 1 lambdag input vector denote set inputs consistent b partial input b cell vertex c 2j define content x 2 xb g similarly processor vertex state e x 2 xb g say cell processor vertex x j fixed partial input b j sb x j j 1 21 oblivious common simulation oblivious priority consider following problem called leftmostone problem given input 1g fich ragde wigderson 12 show leftmostone problem solved o1 time common using n processors n memory cells algorithm made oblivious shall use fact prove following lemma 21 consider oblivious algorithm runs priority pram p processors memory cells k steps oblivious algorithm solving problem common pram p processors memory cells ok steps proof suffices show one write step oblivious priority algorithm simulated oblivious common machine o1 steps suppose priority machine writes r cells denote set processors may write c fixed set note processors may choose write sufficient common machine find highest priority processor chooses write done solving leftmostone problem size j j using j j cells processors o1 time space bound follows fact henceforth shall refer priority algorithms lemma algorithms run common time bounds note general true one step priority algorithm simulated common algorithm o1 steps boppana 1 gives example problem solved o1 time priority logn loglog n time common 3 upper bounds ackermans function defined follows function f let f 1 ne k 1 functions k inverses kth level ackermans function ie k ng 1 behaves like log n 2 like log n define jg berkman vishkin 4 3 independently ragde 16 given algorithms solve chaining problem priority ck steps using ni k n processors c constant 2 algorithms one construct algorithm using processors takes offn time give simple oblivious algorithms solve problem 2k steps priority using ni k n processors though performance bounds feel algorithm easier understand prefix graph size n directed acyclic graph n vertices called input vertices n vertices 1 yn outdegree 0 called output vertices depth prefix graph length longest path input output prefix graphs following property directed path x j say prefix graph levelled vertices partitioned levels numbered 0 every edge level vertex level vertex 1 call edge level edge prefix graph contiguous vertex v inputs v reachable form x possible construct 6 levelled contiguous prefix graphs size n depth 2k 8i 1 2k number level edges ni k n restricteddomain prefixmaxima problem defined follows given input 1 ig show solve problem using prefix graph initially set value vertex propagate values tails heads vertices level select largest value propagated easy see value vertex reachable x j g thus value theorem 31 8k 1 oblivious priority pram algorithm using ni k n processors solves chaining problem 2k steps show oblivious priority pram algorithm simulate computation levelled contiguous prefix graph g label edges g follows let fx r j r 2 jg set input vertices reach vertex tail edge e label e j designate memory cell mv correspond vertex v g step allocate processor pe level edge g two edges f labele labelf pf higher priority pe allocation easy e edge v w pe reads value mv value 0 pe nothing otherwise writes value mw easy show value mw maxfa r j w reachable x r g solve chaining problem input 1 first 1 n simply solve restricteddomain prefixmaxima problem values mx input stated bounds follow bounds prefix graphs 2 31 weak superconcentrators prefix graphs 7 proved prefix graph depth 2k edges improve lower bound showing construction optimal weak superconcentrator directed acyclic graph n vertices vertices outdegree 0 property 8k exist vertex disjoint paths fx fy j1 jk g depth weak superconcentrator length longest directed path proved 11 weak superconcentrator depth edges theorem 32 prefix graph depth 2k requires omegagamma ni k n edges show every prefix graph weak superconcentrator let x input output vertices prefix graph g 8k exist paths x vertex disjoint 9p q 1 paths jp x q jq common vertex path x q contradiction 2 4 useful functions properties following 11 define trees k l l 1 k l leaves depth k edge labelled power 2 outdegree root l outdegree every vertex label edge coming vertex parent describe construct k l starting root edges vertices k l created certain order think vertices given depth arranged left right order creation rule governing labelling edges depth label first edge created 1 label jth edge created twice maximum product labels path starting j gamma 1th edge created ending leaf initially root vertex v depth less k number children v created far less label edge v parent less l v root create new child v label connecting edge per rule move new child number children created far equal label edge v parent move parent v v root already l children construction complete vertex depth k ie leaf simply move back parent recall definition ackermans function previous section appendix shown maximum product labels path k l root leaf sufficiently large let h set leaves labels edges path root h order following inequalities hold 1 6 similar inequalities proved 11 8 include proofs appendix shall prove others fact let v non leaf node tree k l let w next node right level let c labels edges v w parents respectively let e label edge v rightmost child v easily seen e 2 c e 2 c lemma 41 let c 1 c k labels path root leaf 1 jhj leaves tree left right lemma clearly holds path h 1 labels 1 assuming lemma holds path hm shall show holds path hm1 paths hm hm1 diverge level call level r c 1 c r common levels let c r1 c k r1 k remaining labels paths hm hm1 respectively note c r2 c k labels rightmost children fact c j1 2 c j 1 inductive hypothesis 8j 1 j1 since r1 c r1 c r c 2 r1 c r 2 j1 completes proof 2 lemma 42 function 0 k following holds let l positive integers let consider set paths root leaf property set vertices pass levels j k respectively 2 vertices j left right consider path leftmost leaf among set considered paths path passes v 1 let labels path c j log label edge vertex right v 1 least done assume c j log lemma 41 1 log since c 1 c k c j c k log label edge vertex right v 1 fact 3 2 2y log log 2 2 corollary 41 inequality 7 0 k 0 k proof v vertex level j k l let c 1 v c j v labels path root v order lemma 42 hand since labels successive edges level increase least factor two log edges level label exceeds 2 5 lower bound consider following facts theorem 31 shows obtain oblivious chaining algorithm whose graph defined section 2 prefix graph theorem 32 every prefix graph weak super concentrator lower bound weak superconcentrators known 11 given facts tempting conjecture graph every oblivious chaining algorithm prefix graph thereby directly obtain lower bound however chaining algorithms whose graphs weak su perconcentrators example consider algorithm first two steps processor p 1 reads x 1 x 2 without writing anywhere next two steps p 1 writes values x 1 x 2 cells z 1 z 2 respectively chaining problem solved input z processor ever reading cells x 1 x 2 graph computation paths x 1 must pass vertex hence never vertex disjoint thus graph weak superconcentrator simple example generalizes necessary therefore carefully analyze structure graph chaining algorithm prove priority algorithm solves chaining problem n processors suffices prove following theorem 51 n sufficiently large oblivious priority algorithm solves chaining problem size n k steps processors graph algorithm terminates k readwrite steps let input output vertices g let h set leaves k l defined previous section pick u random subset n picking element n independently probability ph consider partial input fix values input vertices g indicated b vertex v g let f v denote indegree v let v j denote set vertices level 2j 0 j k call vertex consider high degree vertex c 2j fixed b let p highest priority processor writes c 2j inputs consistent b ie setting variables p writes c step j state p affected input vertices reach p 2j gamma 1 modify b input vertex settings inputs consistent new b p fixed value c 2j c 2j fixed b since p override processor writes processor writes c 2j modify b setting 0 variables reach c c 2j call operation fixing vertex carry following two step procedure g j starting 1 going k gamma 1 fix highdegree vertices v j starting 1 going n set input vertices value reach lowdegree vertices value 1 except x claim end procedure undefined input vertices fixed except possibly one see suppose one input vertex undefined set 1 except leftmost undefined input vertex x let partial input c let x j first input vertex right x value 1 clearly x j exists set step b x reach lowdegree vertices however two inputs consistent c vertices reachable x low degree vertices different values since high degree vertices fixed hence state j remains fixed inputs error write eab expected number input bits set process argument eab ej u 1 obtain upper bound e ab note fixing highdegree vertices v thus variables affect contents v undefined variables reach v lowdegree vertices hence v enumber inputs set fix enumber undefined inputs reach v low degree vertices actually fix fix state highest priority processor p writes v processor writes fix v 0 vertex represents memory cell v previous time step number inputs fixed number inputs reach either two lowdegree vertices ie 2c j highdegree vertex v minimum two quantities ie v 1 expected number bits set sum expected number bits set fixing high degree vertex ie ea enumber bits set g thus ea upper bound eb expected number inputs set step b let j output vertex let reach j lowdegree vertices 2 u 6 jg j j processing j step b pi 2 u j 2 u since events 2 u j 2 u independent pi 2 u j 2 u hence e number inputs set processing j step b eb sum output vertices expectations eb clearly multiplying sides c k h summing h 2 h interchanging order summation get g let zv g notice v j disjoint union zv j w v j using observation rewriting get simplifying observe sum indegrees cell vertices bounded number edges number cell vertices bounded 2k 2 p ie separately bound terms lhs call ii iii respectively written sum two terms separating vertices degree greater k1 n others thus using inequalities 7b bound first term 7a c bound second find using 5 c simplify ii get term iii estimated using 4 c yielding rhs equation 1 estimated using 6 3 give rhs n k ngamma 2n thus rewriting equation 1 simplifying yields 6 nonoblivious lower bounds techniques used lower bounds oblivious algorithms may extend nonoblivious algorithms conjecture similar lower bounds algorithms able prove case 2 although following theorem may proved using computations similar used oblivious case use simpler computations hope illuminating associate graph gab nonoblivious algorithm partial input b g ab levels vertices 1 edges defined vector consistent b step j vector consistent b step j cell c note case edges cell vertices cell vertices v vertex gab define sb v theorem 61 priority pram algorithm solves chaining problem 2 steps requires8 nlog n 1 processors 2 number processors used suppose terminates 2 steps gab consists 5 levels numbered 04 vertices let e set edges level level gab easily seen partial input b j e b1 j p j e b2 j 2p level 2 vertex indegree ig j j z 0 consider highest priority processor p edge v state processor depends one input bit set input bit p writes v let b partial input defined clearly j sb v fixed manner fix vertices 0 let c partial input obtained procedure number bits set c 0 since fixing vertex 0 involves setting one bit level 2 vertices g ac fixed written less 0 processors 2 states different things written vertex two values processor may write case processor writes two values initially contained hence 8v j sc v processor reads vertex 2i 0 different values written number states processor bounded product twoie output vertices g ac suppose bits set c define l bits c l j c undefined may final value one l l j ml j1 since minimization shows r l j ml j1 e 2 e c4 edge p 3 c 4 let ge number different values p writes c inputs consistent c output vertex 4 let e set edges 4 number different values written 4 bounded number values different processors write via edges e plus number values case processor writes hence sc 4 e2ey processor p 3 total number diferent values write edges leading bounded c p 3 4i 0 summing quantity processors gives upper bound number diferent values written via edges e c4 thus equation 4 get j sc r l j ml j1 finally equation 3 get since r n 2i0log n2 yields conclusion open problems shown oblivious chaining n processors thetaffn time leaves open question whether o1 time nonoblivious algorithm exists recently chaudhuri radhakrishnan 9 settled question showing omegagamma ffn lower bound chaining algorithm using processors using randomization better performance may achieved situations raman 17 gave randomized algorithm runs o1 time number 1s input large conjecture arbitrary inputs constanttime chaining possible even using randomization acknowledgements grateful ravi boppana introducing work 6 11 many helpful discussions indebted jaikumar radhakrishnan simple proof upper bound innumerable insightful comments r optimal separations concurrent write parallel machines improved deterministic parallel integer sorting triplylogarithmic parallel algorithms recursive startree parallel data structure recursive startree parallel data structure unbounded fanin circuits associative functions lower bounds constant depth circuits prefix problems tight bounds chaining problem complexity parallel prefix problems small domains upper lower time bounds parallel random access machines without simultaneous writes superconcentrators generalizers generalized connectors limited depth simulations among concurrentwrite models parallel computation counting packing parallel integer sorting parallel hashing perfect hashing graph entropy circuit complexity parallel simplicity compaction chaining power collision randomized parallel algorithms chaining integer sorting subset selection parallel tr
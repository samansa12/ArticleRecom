planar strong connectivity helps parallel depthfirst search paper proves strongly connected planar directed graph size n depthfirst search tree rooted specified vertex computed olog5n time nlogn processors previously planar directed graphs may strongly connected best depthfirst search algorithm runs olog10n time n processors algorithms run parallel random access machine allows concurrent reads concurrent writes shared memory case write conflict permits arbitrary processor succeed b introduction depthfirst search one useful tools graph theory 32 4 depthfirst search problem following given graph distinguished vertex construct tree corresponds performing depthfirst search graph starting given vertex parallelization depthfirst search studied numerous authors reif showed lexicographic depthfirst search pcomplete even general undirected graphs 28 unordered depthfirst search smith gave first nc algorithm planar undirected graphs 30 processor complexity algorithm reduced linear yesha 15 independently jaja kosaraju 16 shannon 29 also achieved result aggarwal anderson gave randomized nc algorithm general undirected graphs 2 kao studied problem directed graphs found nc algorithm using n 4 processors planar directed graph size n 17 followed randomized nc algorithm aggarwal anderson kao general directed graphs 3 recently kao klein gave algorithm computes depthfirst search trees olog 10 n time using n processors planar directed graphs may strongly connected 19 paper shows strongly connected planar directed graph size n depthfirst search tree rooted specified vertex computed olog 5 n time using n log n processors algorithm runs parallel random access machine allows concurrent reads concurrent writes shared memory case write conflict permits arbitrary processor succeed algorithm paper kao klein use directed graph separators defined kao 17 follow framework randomized nc algorithm general directed graphs 3 algorithm paper achieves superior complexity exploiting topological properties strongly connected planar directed graphs strongly connected components key subgraphs created course algorithm regular structures major task algorithm recursively maintain utilize structures paper organized follows section 2 reviews basic definitions relevant facts planar directed graphs department computer science duke university durham nc 27706 supported part nsf grant ccr8909323 section 3 quotes previous results reports new results computing strongly connected components directed spanning trees section 4 discusses directed graph separators detailed discussion separations given appendix section 5 details papers depthfirst search algorithm strongly connected planar directed graphs 2 basics planar directed graphs planar directed graph one embedded plane edges intersect common end vertices start vertices 14 7 33 6 embedded planar directed graph one given planar embedding subtle technical reasons planar graph paper may multiple edges loop edges 21 strong graphs brevity strongly connected embedded planar directed graph least one vertex simply called strong graph goal paper efficiently compute depthfirst search spanning tree strong graph rooted specified vertex 22 faces boundaries orientations let g connected embedded planar directed graph vertices edges g deleted embedding plane plane divided disconnected regions exactly one regions infinite others finite region called face g infinite region called external face finite regions called internal faces let f face g boundary f denoted bf set edges vertices surrounding f g contains least two vertices connectivity bf arranged unique undirected cycle observer stay inside f walk around bf cycle called boundary cycle f may edgesimple let e boundary edge f orientation e respect f defined follows ffl case 1 f external face edge e positive negative respect f points counterclockwise resp clockwise direction boundary cycle f ffl case 2 f internal face edge e positive negative respect f points clockwise resp counterclockwise direction boundary cycle f 23 holes boundaries orientations let g connected embedded planar directed graph let h connected subgraph g vertices edges h removed embedding plane g plane divided disconnected regions exactly one regions infinite others finite region called hole h infinite region called external hole finite regions called internal holes let x hole h boundary x denoted bx set vertices edges surrounding x h contains least two vertices connectivity bx arranged unique undirected cycle observer stay inside x walk around bx exactly cycle called boundary cycle x may edgesimple let e boundary edge x orientation e respect x defined follows ffl case 1 x external hole h edge e positive negative respect x points counterclockwise resp clockwise direction boundary cycle x ffl case 2 x internal hole h edge e positive negative respect x points clockwise resp counterclockwise direction boundary cycle x 24 combinatorial embeddings data structures let g connected planar directed graph algorithmically planar embedding g encoded boundary external face clockwise cyclic order edges incident vertex encoding called combinatorial planar embedding g topologically planar embedding uniquely specified corresponding combinatorial embedding cyclic edge incidence combinatorial embedding encoded following data structure vertex doubly linked circular list consisting edges incident vertex clockwise order lists used efficiently trace boundary cycles faces g also used trace boundary cycles holes connected subgraph given connected planar directed graph size n combinatorial planar embedding computed ologn time using n log log n log n processors deterministic arbitrarycrcw pram 27 25 planar embeddings induced vertex contraction paper vertex contraction contracts connected vertex subsets connected embedded planar directed graph ensures planarity preserved technical reasons multiple edges created vertex contraction kept loop edges deleted let g connected embedded planar directed graph let h subgraph induced connected vertex subset g let g 0 graph constructed g contracting h vertex h 0 h consists one vertex g 0 g otherwise planar embedding g 0 specified follows ffl every vertex u 62 h clockwise cyclic order edges incident u g g 0 ffl edges around nonempty hole x h stay together around h 0 clockwise cyclic order around h 0 cyclic order around boundary cycle x negative direction x ffl uncontracted edges boundary external face g remain g 0 orientations respect external faces ffl h contains boundary vertex external face g h 0 boundary external face g 0 general planar embedding unique planar embedding fits construction suitable purposes paper lemma 21 given connected embedded planar directed graph size n planar embedding induced contracting disjoint family connected vertex subsets computed olog n time using n log n processors remark vertex contraction required delete multiple edges creates computing induced embedding may take linear space achieve olog n time n log n processors proof edges around new vertex g 0 collected processing doubly linked circular lists combinatorial embedding g computation takes olog n time n log n processors using optimal parallel algorithms list ranking 5 9 13 prefix computation 24 23 tree contraction 26 1 8 22 11 10 planar connectivity 12 3 strongly connected components directed spanning trees section quotes previous results reports new results computing strongly connected components directed spanning trees 31 directed spanning trees theorem 31 kao shannon 20 strong graph size n directed spanning tree rooted specified vertex computed olog 2 n time using n log n processors deterministic arbitrarycrcw pram 32 compactness strongly connected components let g connected embedded planar directed graph let h 1 h 2 two nonempty connected subgraphs g h 1 encloses h 2 h 2 internal hole h 1 compact strongly connected component g one encloses strongly connected component theorem 32 kao 18 let g connected embedded planar directed graph let n size g let ff number noncompact strongly connected components g strongly connected components g computed odlog using n log n processors deterministic arbitrary crcw pram 33 new results computing strongly connected components next three theorems discuss compute strongly connected components graph obtained deleting contracting subgraph embedded planar directed graph may connected strongly connected component compact compact connected component contains 331 deleting vertex subset strong graph let g directed graph let h subgraph vertex subset g let g gamma h subgraph obtained removing vertices h incident edges theorem 33 let g strong graph size n let h subgraph g number connected components h let ff 0 number noncompact strongly connected components g 0 following statements true 1 ff 0 fl 2 strongly connected components g 0 computed deterministically odlog 2 fl using n log n processors proof first statement obtained counting arguments based following facts ffl let w noncompact strongly connected component g 0 planarity strong connectivity g least one connected component h enclosed w g ffl let w 1 w 2 two noncompact strongly connected components g 0 planarity g connected component h enclosed g w 1 w 2 either w one encloses g ffl let w noncompact strongly connected component g 0 strong connectivity planarity g connected component h enclosed g w noncompact strongly connected component g 0 enclosed w g prove second statement first compute connected components g 0 takes ologn time using n log n processors 12 next compute strongly connected components connected components via theorem 32 second statement follows first statement theorem 332 deleting edeg subset strong graph theorem 34 let g strong graph size n let u vertex subset g let subset edges g incident u let g 0 graph obtained deleting g edges let number vertices u let ff 0 number noncompact strongly connected components g 0 following statements true 1 ff 0 2 2 strongly connected components g 0 computed deterministically odlog 2 2 using n log n processors proof second statement follows directly first statement theorem 32 thus suffices prove first statement follows let w noncompact strongly connected component g vertex absorbed w g either vertex w enclosed w g definition first statement obtained counting arguments based following facts ffl let w noncompact strongly connected component g 0 planarity strong connectivity g u 2 u absorbed w g ffl let w 1 w 2 two noncompact strongly connected components g 0 planarity g vertex u 2 u absorbed w 1 w 2 g either w one encloses g ffl let w noncompact strongly connected component g 0 strong connectivity planarity g vertex u absorbed g w one noncompact strongly connected g 0 enclosed w g 333 contracting connected vertex subsets acyclic graph theorem 35 let g acyclic connected embedded planar directed graph let h subgraph g let g 0 graph obtained g contracting connected component h vertex let n size g let fl number connected components h let ff 0 number noncompact strongly connected components g 0 following statements true 1 ff 0 fl 2 strongly connected components g 0 computed deterministically odlog 2 fl using n log n processors proof noncompact strongly connected component contains least two ver tices thus acyclicity g noncompact strongly connected component g 0 contains least one contracted connected component h therefore first statement true second statement follows theorem 32 4 directed graph separators intuitively separator graph subgraph whose removal disconnects graph small pieces 41 cycle separators kpath separators works parallel depthfirst search rely finding form graph separator algorithms planar undirected graphs employ undirected cycle separators 30 15 16 algorithm general undirected graphs uses path separators 2 procedure mergetwopaths input strong graph g twopath separator output path separator g begin 1 let largest index strongly connected component z g gamma fu heavy g remark 2 exist return 3 let p 0 path u remark p 0 q form twopath separator 4 let smallest index strongly connected component z g heavy g 5 exist return 6 let q 0 path v remark p 0 q 0 form twopath separator 7 compute directed path r z z u v remark z z strongly connected 8 let directed path formed p 0 r q 0 remark vertexsimple 9 return end fig 1 procedure merging twopath separator path separator notion directed graph separator originally introduced depthfirst search planar directed graphs 17 used general directed graphs 3 tailored strongly connected directed graph g ffl vertex subset called heavy g contains two thirds vertices g ffl separator g set vertices strongly connected component g gamma heavy g ffl cycle separator vertexsimple directed cycle whose vertices form separator single vertex considered cycle length zero thus removal vertex separates graph vertex cycle separator ffl positive integer k kpath separator set k vertexdisjoint vertex simple directed paths whose vertices form separator 1path separator simply called path separator kao showed every directed graph directed path separator directed cycle separator 17 results included appendix graph size n proofs yield sequential algorithm computes path separator optimal time algorithm computes cycle separator log n time aggarwal anderson kao improved sequential time computing directed cycle separator 3 also showed computing cycle separators computing depthfirst search trees ncequivalent 42 computing cycle separators strong graphs lemma 41 given strong graph size n twopath separator computed olog 2 n time using n log n processors proof let directed spanning tree given graph work lipton tarjan 25 exist two vertices x two tree paths root x root form separator twopath separator easily obtained tree paths kao teng toyama gave algorithm 21 computes x olog n using n log n processors thus lemma follows theorem 31 lemma 42 given strong graph size n path separator computed olog 3 n time using n log n processors proof let g given graph first use lemma 41 obtain twopath separator g use algorithm mergetwopaths fig 1 compute path separator proof correctness mergetwopaths similar theorem a2 appendix a3 complexity suffices show mergetwopaths runs olog 3 n time using n log n processors z z computed binary search theorem 33 olog 3 n time using n log n processors r 0 obtained computing divergent directed spanning tree rooted u subgraph induced z z uses theorem 31 takes olog 2 n time using n log n processors thus complexity mergetwopaths stated theorem 43 given strong graph size n cycle separator computed olog 3 n time using n log n processors proof proof similar lemma 42 theorem a2 5 parallel depthfirst search section 51 gives overview papers algorithm performing depthfirst search strong graph sections 52 56 discuss key techniques used algorithm section 58 details algorithm 51 overview let g strong graph let r vertex g goal construct depthfirst search spanning tree rooted r g tree recursively constructed using cycle separators first compute cycle separator g compute path separator starting r finding directed path r cycle separator path cycle separator form path separator appropriate edge cycle separator removed branch final depthfirst search tree ie remaining graph searched suppose search continued g 0 starting vertex r 0 end vertex edge pointing last vertex time search recurses subgraph b r 0 consists vertices reachable r 0 via directed paths g 0 graph b r 0 called dangling subgraph see x55 separator g every strongly connected component g 0 contains two thirds vertices g however b r 0 may contain several strongly connected components consequently b r 0 may still large small depth recursion avoid problem set directed paths removed g remaining directed graph small dangling subgraphs removed paths form subtree called partial depthfirst search tree final depthfirst search tree see x55 dangling subgraph strong graph special kind graph called bubble graph structures bubble graph exploited efficiently process dangling subgraphs see x52 strong graph fact special case bubble graph depthfirst search algorithm paper actually takes bubble graph input computes depthfirst search tree recusing bubble subgraphs see x57 52 bubble graphs strongly connected component directed graph sink component outgoing edges strongly connected component let b embedded planar directed graph b called bubble graph rooted vertex r following conditions hold ffl every vertex b reached r via directed paths ffl vertex r boundary vertex external face b every sink component b contains least one boundary vertex external face remark assumed bubble graph specified root brevity root explicitly mentioned unless risk ambiguity lemma 51 let b bubble graph rooted r let n size g following statements true 1 strongly connected components b computed olog 2 n time using n log n processors 2 directed spanning tree b rooted r computed olog 2 n time using n log n processors proof first statement follows theorem 32 fact bubble graph noncompact strongly connected components second statement shown follows let b 0 graph obtained b adding directed edge sink component b r via external face b directed spanning tree b 0 rooted r also one b complexity first statement lemma b 0 computed olog 2 n time using n log n processors b 0 strong graph desired directed spanning tree b 0 computed via theorem 32 olog 2 n time using n log n processors 53 heavy bubble graphs splitting components let k integer bubble graph called kheavy klight resp vertices let b kheavy bubble graph let w 1 w 2 two distinct strongly connected components w 2 called descendant component w 1 w 1 reach directed paths directed graph g vertex subset vertex h g let rhg set vertices reached h via directed paths g let w strongly connected component b let rwb set vertices b reached w via directed paths w called splitting component b rwb consists k vertices descendant component w satisfies condition depthfirst search algorithm paper find cycle separator splitting component b use separator break b bubble subgraphs smaller splitting components 54 computing splitting component via st graphs acyclic embedded planar directed graph called st graph unique source unique sink boundary external face theorem 52 given kheavy bubble graph size n splitting component computed olog 2 n time using n log n processors proof let b kheavy bubble graph splitting component b computed converting b st graph follows graph obtained adding vertex external face b directed edge pointing sink component b graph obtained b 1 contracting strongly connected component b vertex vertices b 2 assigned weights weight 0 vertex w contracted strongly connected component w b weight w number vertices w note b 2 st graph sink source contracted strongly connected component b contains specified root lemmas 511 21 b 2 computed olog 2 n time using n log n processors next cardinality rwb strongly connected component w b computed olog 2 n time n log n processors computation applies b 2 descendant counting algorithm tamassia vitter st graphs 31 cardinality rwb computed splitting component b identified straightforward manner ologn time using n log n 55 partial depthfirst search trees dangling subgraphs let b bubble graph partial depthfirst search tree b subtree depthfirst search tree b trees rooted specified root b let partial depthfirst search tree b let x vertices listed postorder traversal sequence depthfirst search ie sequence x marked right descendants marked x let vertices end vertices edges pointing x order arbitrary postorder used search starting x vertex may several different indices adjacent several x vertices dangling subgraph b denoted di j respect subgraph induced vertices reached ij vertex ij intended postorder traversal sequence vertices ie di jg nonempty di j directed edge x ij called dangling edge associated di j next two lemmas provides natural way extending complete depthfirst search tree recursing nonempty dangling subgraphs parallel lemma 53 let r specified root b let h connected subgraph b contains r let u vertex h adjacent h subgraph b induced ru bubble graph rooted u proof let b u subgraph b induced ru first definition b u vertex u reach every vertex b u via directed paths b u next r boundary vertex external face b connectivity h relationship r h u vertex u boundary vertex external face b u let w sink component b u following discussion shows w contains boundary vertex external face b u b bubble graph contains directed path w boundary vertex external face b two cases based whether q intersects h ffl case 1 q intersect h q lies b u w sink component b u path q lies w therefore w contains last vertex q boundary vertex external face b u ffl case 2 q intersects h let first vertex q h boundary vertex external face b adjacency h sgamma1 vertex sgamma1 boundary vertex external face b u furthermore w sink component b u vertex sgamma1 w lemma 54 letomega set dangling subgraphs b respect let l set associated dangling edges following statements true 1 nonempty di j bubble graph rooted ij hence ij chosen specified root di j 2 dangling subgraphs disjoint 3 depthfirst search tree b formed l depthfirst search tree dangling subgraph least two vertices proof first statement obtained recursively applying lemma 53 two statements straightforward 56 computing dangling subgraphs respect path section shows compute dangling subgraphs respect partial depthfirst search tree path computation based two bisection strategies using subroutines fig 2 fig 3 561 analyzing subroutine fig 2 next two lemmas analyze subroutine fig 2 lemma 55 let set end vertices edges b point proof proof two directions contains directed path q 1 p 1 note q 1 contains edge hand 1 strongly connected directed path q 2 p intersect one vertex q 2 contains outgoing edges edge let q directed path formed q 1 q 2 q goes p p becomes directed cycle 2 contains w q contains edge remains directed cycle 3 therefore contains vertexsimple directed path r 1 w z let r 2 directed path 1 corresponds r 1 intersects p one vertex x note x start vertex r 1 1 constructed adding incoming edges r edges removed 3 vertex x p 1 edges r 2 therefore z 2 ry lemma 56 let b bubble graph size n procedure fig 2 correctly computes output specified olog 2 n time using n log n processors proof second fourth output property procedure straight forward two properties shown subgraph b induced rx therefore lemma 53 b 1 bubble graph rooted x q obtained bubble graph contracting connected vertex subset bubble graph rooted x p ffl property 3 lemma 55 nonempty dangling subgraphs associated dangling edges b respect p exactly b 1 respect p 1 respect p 2 may may bubble graph b 1 contracted instead deleted contraction b 1 x q1 may add new edges b 2 procedure subonecomputedsg input bubble graph b rooted r vertexsimple directed path 2 output two graphs b 1 b 2 constructed b two paths bubble graphs rooted x dp2e x p respectively 2 p 1 p 2 vertexsimple directed paths respectively b 1 starting specified roots 3 nonempty dangling subgraphs associated dangling edges b respect p exactly b 1 respect p 1 b 2 respect p 2 4 total size b 1 b 2 size b begin 1 let 2 let p 1 subpath p formed x 3 let p 2 subpath p formed x 4 let set edges b point p 2 5 b strongly connected let else let 1 graph obtained b adding directed edge sink component r via external face b 6 let 2 graph obtained 1 contracting p vertex remark edges outgoing edges w 7 let 3 graph obtained 2 deleting edges 8 let w strongly connected component 3 contains super vertex w 9 let b 1 subgraph b induces w graph obtained b contracting x q1 end fig 2 first subroutine computing dangling subgraphs procedure subtwocomputedsg input bubble graph b rooted r k 2 edges outgoing r output two graphs b 1 b 2 constructed b following properties bubble graphs rooted r 2 nonempty dangling subgraphs associated dangling edges b respect r exactly b 1 b 2 respect r r considered path single vertex 3 outdegrees r b 1 b 2 dk2e bk2c respectively 4 total size b 1 b 2 size b begin 1 let 2 let k end vertices outgoing edges r b 3 let set edges r b 4 b strongly connected let else let 1 graph obtained b adding directed edge sink component r via external face b 5 let 2 graph obtained 1 contracting vertex w remark edges outgoing edges w 6 let 3 graph obtained 2 deleting edges 7 let w strongly connected component 3 contains super vertex w 8 let b 1 subgraph b induces w gamma without edges 9 let b 2 graph obtained b contracting r end fig 3 second subroutine computing dangling subgraphs x q1 however contraction creates new edges b 2 x q1 edges would point b 1 thus end vertices would included b 1 therefore contracting b 1 x q1 change nonempty dangling subgraphs associated dangling edges respect p 2 complexity steps 1 4 done olog n time using n log n processors step 5 done via lemma 511 olog 2 n time using n log n processors step 6 done via lemma 21 olog n time using n log n processors step 7 done olog n time using n log n processors 1 strong graph 2 remains strong graph edges adjacent w 2 theorem 34 w computed olog 2 n time using n log n processors step 9 done ologn time using n log n processors step 10 done via lemma 21 ologn time using n log n processors thus total complexity procedure fig 2 stated 562 analyzing subroutine fig 3 next lemma analyzes subroutine fig 3 lemma 57 let b bubble graph size n procedure fig 3 correctly computes output specified olog 2 n time using n log n processors proof proof similar lemmas 56 53 subtle point follows b 1 may contain dangling subgraphs b respect vertices empty therefore edges deleted b 1 without affecting nonempty dangling subgraphs deletion ensures outdegree r b 1 dk2e 563 computing dangling subgraphs next theorem uses procedures fig 2 fig 3 compute nonempty dangling subgraphs respect path theorem 58 let b bubble graph size n let p vertexsimple directed path b starting specified root nonempty dangling subgraphs associated dangling edges b respect p computed olog 3 n time using n log n processors proof computation divided two phases follows ffl first phase iteratively applies subonecomputedsg b p bisect p ologn iterations collection bubble subgraphs b obtained subgraph b 0 contains one vertex p ffl second phase iteratively applies subtwocomputedsg b 0 bisect outdegree root olog n iterations collection even smaller bubble subgraphs b obtained subgraph b 00 rooted vertex subgraph b 00 either exactly one outgoing edge consists b 00 consists corresponding dangling subgraph b empty otherwise b 00 gammafyg nonempty dangling subgraph b associated dangling edge outgoing edge b 00 correctness complexity computation follow directly lemmas 56 57 57 parallel depthfirst search bubble graphs fig 6 details papers algorithm performing depthfirst search bubble graph subroutines described fig 5 fig 4 lemma 59 let b bubble graph size n procedure fig 4 correctly computes output specified olog 3 n time using n log n processors procedure splitheavydsg input positive integer 2m3heavy bubble graph b vertices output 1 partial depthfirst search tree b either property ffl dangling subgraph b respect 2m3heavy ffl dangling subgraph 2m3heavy splitting component consists two thirds vertices splitting component b 2 set delta dangling subgraphs b respect 3 set k associated dangling edges begin 1 let r specified root b 2 let w splitting component b 3 let c directed cycle separator w 4 let p vertexsimple directed path b r c p c intersect one vertex u 5 let e edge c pointing u 6 let vertexsimple directed path formed p c without edge e 7 let delta set dangling subgraphs b respect 8 let k set associated dangling edges 9 return tuple delta k end fig 4 procedure splitting heavy dangling subgraph procedure computepartialtree input bubble graph b vertices output 1 partial depthfirst search tree b dangling subgraphs 2m3light 2 setomega dangling subgraphs b respect 3 set l associated dangling edges begin 1 2 b 0 2omega 2m3heavy begin 22 delete dangling edge b 0 l 23 add edge form larger tree 24 25 add form larger tree add delta omegagamma 27 add k l end 3 return tuple end fig 5 procedure computing partial depthfirst search tree procedure computedfstree input bubble graph b least two vertices output depthfirst search tree b begin 1 2 add l form larger tree 3 b 0 2omega least two vertices begin 31 32 add 0 form larger tree end 4 return end fig 6 procedure computing depthfirst search tree proof correctness procedure shown follows let 0 set vertices w assume dangling subgraph b 0 b respect 2m3heavy b vertices b 0 2m3 heavy dangling subgraph b respect splitting components strongly connected components w gamma 0 0 separator w output property procedure holds complexity procedure analyzed follows step 1 obvious step 2 done via theorem 52 step 3 done via theorem 43 step 4 done using lemma 512 steps 5 6 obvious steps 7 8 done via theorem 58 thus total complexity stated lemma 510 let b bubble graph size n procedure fig 5 correctly computes output specified olog 4 n time using n log n processors proof lemma follows directly lemma 59 fact output property splitheavydsg number iterations computepartialtree ologn theorem 511 let b bubble graph size n let r specified root b depthfirst search tree b rooted r computed olog 5 n time using n log n processors deterministic arbitrarycrcw pram proof computation done procedure fig 6 theorem follows directly lemmas 54 510 fact output property computepartialtree depth recursion computedfstree olog n 58 parallel depthfirst search strong graphs next theorem states main result paper theorem 512 let g strong graph size n let r vertex g depthfirst search spanning tree g rooted r computed olog 5 n time using n log n processors deterministic arbitrarycrcw pram proof external face g changed r boundary vertex face strong connectivity g bubble graph rooted r therefore theorem follows theorem 511 fact external face changed ologn time n log n processors using list ranking 5 9 13 prefix computation 24 23 acknowledgement author wishes thank subhrajit bhattacharya helpful discussions graphs cycle separators following discussion uses depthfirst search trees compute graph separators 17 a1 path cycle separators weighted graphs weighted graph one nonnegative vertex weights avoid triviality assume least one vertex positive weight let g weighted directed graph let h subgraph vertex subset g h subgraph obtained removing vertices h incident edges let wh total weight h set h called heavy g wh wg2 remark threshold heaviness different x41 23 separator g vertex subset strongly connected component g gamma heavy g cycle path separator vertexsimple directed cycle resp path vertices form separator technical uniformity vertex considered trivial cycle thus vertex forms separator cycle separator empty set considered trivial cycle trivial path thus empty set forms separator cycle separator well path separator a2 computing path separators depthfirst search trees next theorem applied weighted undirected graph substituting undirected edge pair directed edges theorem a1 every weighted directed graph path separator proof let g weighted directed graph without loss generality assume g strongly connected otherwise replace g maximumweight strongly connected component every path separator component also one g path separator p g constructed follows let depthfirst search spanning tree g rooted arbitrary vertex r let z vertices g corresponding depthfirst search postorder let p smallest index let p tree path r z p let g let p shown path separator follows draw g plane way postorder indices j j vertex z either right z j ancestor z j 4 vertex z p either ancestor right every vertex gl p greater postorder indices vertices gl also every vertex gr right z p postorder indices vertices gr greater p p consists z p ancestors therefore every vertex gr right every vertex gl depthfirst search edge points left right every strongly connected component g gamma p either entirely gl entirely gr thus weight strongly connected component g gamma p wgl wgr a3 computing cycle separators path separators next theorem also applied weighted undirected graph edge substitution note separator obtained theorem actually consists either vertex single vertex least three vertices thus degenerate undirected edge edge substitution undone theorem a2 every weighted directed graph cycle separator proof let g weighted directed graph let path separator g obtained theorem a1 p converted cycle separator follows let largest index strongly connected component z g gamma fu heavy g path u exist empty set trivial cycle separator otherwise continue conversion let let smallest index strongly connected component z heavy g u path u separator two cases based whether u trivial cycle separator otherwise u 62 z u 62 z z z heavy g strongly connected z z contains vertex z vertex simple directed path q u via z gamma z z via z gamma z u contains none u path q path u vertexsimple directed cycle least three vertices cycle separator path u separator r simple tree contraction algorithm random nc algorithm depth first search parallel depthfirst search general directed graphs design analysis computer algorithms deterministic parallel list ranking new york accelerated centroid decomposition technique optimal tree evaluation logarithmic time optimal tree contraction erew model optimal parallel algorithm dynamic expression evaluation applications optimal parallel algorithms planar graphs optimal linked list prefix algorithm local memory computer graph theory nearly optimal parallel algorithm constructing depth first spanning trees planar graphs parallel algorithms planar graphs related problems graphs cycle separators planar directed depthfirst search dnc towards overcoming transitiveclosure bottleneck efficient parallel algorithms planar digraphs log nwork nc algorithm depthfirst search undirected planar graphs optimal parallel evaluation treestructured computations raking power parallel prefix parallel prefix computation separator theorem planar graphs parallel tree contractions applications optimal parallel algorithm graph planarity linearprocessor algorithm depthfirst search planar graphs parallel algorithms depth first search parallel transitive closure point location planar struc tures graph theory tr
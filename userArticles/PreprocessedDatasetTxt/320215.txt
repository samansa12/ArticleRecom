randomized fully dynamic graph algorithms polylogarithmic time per operation paper solves longstanding open problem fully dynamic algorithms present first fully dynamic algorithms maintain connectivity bipartiteness approximate minimum spanning trees polylogarithmic time per edge insertion deletion algorithms designed using new dynamic technique combines novel graph decomposition randomization lasvegas type randomized algorithms use simple data structures small constant factorlet n denote number nodes graph sequence ohgrm0 operations m0 number edges initial graph expected time p updates op log3 n througout paper logarithms based 2 connectivity bipartiteness worstcase time one query olog nlog log n kedge witness problem removal k given edges disconnect graph expected time p updates op log3 n expected time q queries oqk log3 n given graph k different weights minimum spanning tree maintained sequence p updates expected time opk log3 n implies algorithm maintain 1 egrapproximation minimum spanning tree expected time op log3 n loguegr p updates weights edges 1 u b introduction many areas computer science graph algorithms play important role problems modeled graphs solved computing property graph underlying problem instance changes incrementally algorithms needed quickly compute property modified graph algorithms make use previous solutions thus solve problem faster recomputation scratch called fully dynamic graph algorithms precise fully dynamic graph algorithm data structure supports following three operations 1 insert edge e 2 delete edge e 3 test graph fulfills certain property e g two given vertices connected department computer science cornell university ithaca ny email mhrcscornelledu authors maiden name monika h rauch research supported nsf career award department computer science university victoria victoria bc email valcsruvicca research supported nserc grant 1 throughout paper logarithms base 2 previous work recent years lot work done fully dynamic algorithms see 1 3 4 6 7 8 10 11 13 16 17 19 connectivityrelated work undirected graphs also large body work restricted classes graphs insertionsonly algorithms currently best time bounds fully dynamic algorithms undirected nnode graphs n per update minimum spanning forest 3 n per update o1 per query connectivity 3 log n per update olog 2 n per query cycleequivalence removal given 2 edges disconnect graph 11 n per update o1 per query bipartiteness graph bipartite 3 lower bound cell probe model ofomegagamma32 n log log n amortized time per operation problems applies randomized algorithms 9 11 1 shown average update time variant connectivity bipartiteness algorithms log n edges used updates chosen uniformly given edge set thus dense graphs average performance nearly matches lower bound planar graphs fully dynamic algorithms minimum spanning forest connectivity given 5 close lower bound take time olog 2 n per deletion olog n per insertions query however constant factor algorithms quite large 5 thus following questions posed open questions 4 5 1 properties maintained dynamically polylogarithmic time general 2 constant factor fully dynamic algorithms small efficient implementation possible new results paper gives positive answer questions presents new technique designing fully dynamic algorithms polylogarithmic time per operation applies technique fully dynamic connectivity bipartiteness 1fflapproximate minimum spanning trees cycleequivalence problem resulting algorithms lasvegas type randomized algorithms use simple data structures small constant factor sequence omegagamma number edges initial graph following amortized expected update times worstcase query times achieved 1 connectivity update time olog 3 n query time olog n log log n 2 bipartiteness update time olog 3 n query time o1 3 minimum spanning tree graph k different weights update time ok log 3 n immediate consequence results achieve faster fully dynamic algorithms following problems 1 algorithm maintain 1fflapproximation minimum spanning tree expected time op log 3 n log uffl p updates weights edges 1 u 2 algorithm kedge witness problem removal given k edges disconnect graph update time olog 3 n amortized expected query time ok log 3 n note cycleequivalence equivalent 2edge witness problem 3 fully dynamic algorithm maintaining maximal spanning forest decomposition order k graph time ok log 3 n per update keeping k fully dynamic connectivity data structures maximal spanning forest decomposition order k decomposition graph k edgedisjoint spanning forests f f maximal spanning forest g maximal spanning forest decomposition interesting since f graph okn edges kedge connected components g 15 additionally use data structures present simple deterministic algorithms maintain minimum spanning trees connectivity fully dynamically amortized time per update minimum spanning tree algorithm log n improved log n using sparsification technique 4 amortized time per update connectivity algorithm log n even though algorithms improve running time best known algorithms interesting since present completely different approach previous algorithms use simple data structures additionally connectivity algorithm first fully dynamic algorithm use sparsification technique achieves running time less main idea new technique combination novel decomposition graph randomization edges graph partitioned olog n levels edges highlyconnected parts graph cuts dense lower levels loosely connected parts cuts sparse level spanning forest maintained graph whose edges levels tree edge deleted level sample edges level high probability either 1 find edge reconnecting two subtrees 2 cut defined deleted edge sparse level case 1 found replacement edge fast case 2 copy edges cut level recurse level 1 knowledge previous use randomization fully dynamic algorithms montecarlo type approximation algorithms minimum cuts 12 14 paper structured follows section 2 gives fully dynamic connectivity algorithm section 3 presents results kweight minimum spanning trees 1fflapproximate minimum spanning trees bipartiteness section 4 5 contain deterministic algorithms randomized connectivity algorithm 21 deletionsonly connectivity algorithm definitions notation let e jv use convention elements v referred vertices let l 1 edges g partitioned l levels l keep forest f tree edges f spanning forest v l spanning tree g edges e n f referred nontree edges spanning tree level tree f nontree edges incident vertices stored data structure described detail weight denoted wt number nontree edges incident spanning tree edges whose endpoints lie spanning tree counted twice size denoted st number vertices tree smaller another tree size greater others say level level 1 211 algorithm initially edges e 1 compute f 1 spanning tree g edge e deleted remove e graph containing e tree edge let level e 2 e call replacee let level tree containing edge e let 1 2 two subtrees resulted deletion e st 1 2 ffl sample sample c log 2 nontree edges e incident vertices 1 appropriate constant c edge endpoints 1 picked probability 2wt 1 edge one endpoint 1 picked probability 1wt 1 case 1 replacement edge found one sampled edges connects 1 2 add f j j ffl case 2 sampling unsuccessful none sampled edges connects 1 2 search edges incident 1 determine g choose one element add f j j remove elements e insert add one newly inserted edges f j j l 212 proof correctness first show edges contained il e ie replacee l called case 2 occurs edges inserted e l1 use fact argue replacement edge exists found number edges ever e lemma 21 smaller trees 1 level proof proof follows 6 tree split two trees endpoint edge contained smaller tree size tree contains endpoint halved thus course algorithm endpoint edge inci dent smaller tree log n times given level trees 1 level lemma 22 mc 0igamma1 proof show lemma induction clearly holds assume holds summed smaller trees 1 p log n edges added e corollary 21 p total number edges ever level implies total number edges e greater mc choosing c observing edges never moved higher level level less 2 log n edges gives following corollary corollary 23 contained e l following relationship useful running time analysis also evident corollary 24 p theorem 25 f spanning forest v proof initially true since compute f 1 spanning tree consider first time fails tree edge e deleted replacement edge exists found corollary 23 replacement edge lies let minimum level replacement edge exists let e e k claim k assume let fr sg replacement edge level since r connected path r f since e 2 f k e path hence sg replacement edge e thus k deletee called either replacement edge found sampling every edge incident 1 examined claim every replacement edge fr sg incident 1 suppose assumption path r ji f j path includes e either r 1 doesnt include e fr sg forms cycle f gamma e contradicting assumption fr sg replacement edge 213 euler tour data structure subsection present data structure use implement algorithm previous section efficiently encode arbitrary tree n vertices using sequence symbols generated follows root tree arbitrary vertex call et root et defined follows visit x child c x visit x edge visited twice every degreed vertex times except root visited times time vertex u encountered call occurrence vertex denote u new encodings trees resulting splits joins previously encoded trees easily generated let et sequence representing arbitrary tree procedures modifying encodings 1 delete edge fa bg let 1 2 two trees result 2 1 encountered two traversals fa bg thus et 2 given interval et splicing et sequence 2 change root r let occurrence splice first part sequence ending occurrence remove first occurrence r tack end sequence begins add new occurrence end 3 join two rooted trees 0 edge e let given occurrences create new occurrence splice sequence et immediately sequence et stored balanced search tree degree b height olog n log b one may insert interval splice interval time ob log n log b maintaining balance tree determine two elements tree one element precedes ordering time olog nb aside lists arrays data structures used connectivity algorithm trees represented sequences stored balanced bary search trees next describe data structures data structures two options storing nontree edges first simpler explained second shaves factor log log n update time reducing cost sampling described last subsection section spanning tree level l occurrence et stored node balanced binary search tree call etttree tree last level l et stored balanced log nary search trees note nontree edges level vertex arbitrarily choose one occurrence active occurrence u active occurrence vertex v keep unordered list nontree edges level incident v stored array node ettree contains number nontree edges number active occurrences stored subtree thus root et contains weight size addition storing g f using adjacency lists keep arrays lists ffl vertex level pointer vertexs active occurrence level ffl tree edge level k e 2 f k pointers four three endpoint leaf occurrences associated traversal f k ffl nontree edge pointers locations two lists nontree edge containing edge reverse pointers ffl level list containing pointer root etttree spanning trees level root pointer back list ffl level list tree edges e edge pointer back position list 214 implementation using data structures described following operations executed spanning tree level let spanning tree level ffl treex return pointer et spanning tree level contains vertex x ffl nontree edgest return list nontree edges stored et edge returned twice randomly select nontree edge e least one endpoint edge endpoints picked probability 2wt edge exactly one endpoint picked probability 1wt test exactly one endpoint return edge ffl insert treee join e two trees level contains endpoint e ffl delete treee remove e tree level contains ffl insert nontreee insert nontree edge e e ffl delete nontreee delete nontree edge e following running times achieved using binary search tree tree sampletest insert non tree delete non tree delete tree insert tree olog n nontree edgest om 0 log n 0 number moved edges last level l log nary tree used running time delete tree insert tree increased olog 2 n log log n running time tree reduced olog n log log n describe implementation details operations treexi follow pointer active occurrence x level traverse path et tree active occurrence root return pointer root nontree edgest traverse nodes et output every nonempty list nontree edges encountered node let level tree pick random number j 1 wt find j th nontree edge fu vg stored et treeu l 6 treev l return edge insert treeei determine active occurrences endpoints e level follow procedure 3 joining two rooted trees update pointers root new tree list tree edges level delete treeei let vg determine four occurrences associated traversal e tree level contains e delete e following procedure 1 update pointers roots new trees list tree edges necessary active occurrences u v insert nontreeei determine active occurrences endpoints e level add e list edges stored delete nontreee follow pointers two locations e lists nontree edges remove e using functions deletions algorithm implemented follows initialize data structures given graph g compute spanning forest g compute et forest select active occurrences set pointers described initially set trees levels insert nontree edges appropriate active occurrences level 1 compute number nontree edges subtree node answer query x connected test treex update data structure deletion edge efuvg e e delete treee e tree edge execute delete nontreee 2 repeat times case 1 replacement edge e 0 found delete nontreee 0 case 2 sampling unsuccessful edge fu vg 2 nontree treeu l 6 treev l add fu vg fedges exactly one endpoint 1 g g case 21 jsj wt 1 2c 0 log n select one e case 22 choose one edge e 0 2 remove every edge e 00 2 delete non treee 00 insert nontreee 00 case 23 215 analysis running time show amortized cost per deletion olog 3 n deletions cases replacement edge found olog n insert tree operations executed costing olog 2 n addition case 1 sampling successful cost sampletest olog n repeated olog 2 n times total olog 3 n case 2 sampling successful wt 1 refer executing nontree testing edge cost gathering testing nontree edges first operation costs olog n per nontree edge second olog n log log n per nontree edge total cost owt 1 log n three possible cases case 21 jsj wt 1 2c 0 log n wt 1 cost gathering testing delete operation otherwise probability subcase occurring total cost case owt 1 log n thus contributes expected cost olog n per operation case 22 23 jsj wt 1 2c 0 log n delete nontree insert nontree tree costs olog n total cost owt 1 log n case treeu treev reconnected note edges incident smaller tree 1 gathered tested thus course algorithm cost incurred cases level sum taken smaller trees 1 level lemma 21 p corollary 24 p giving total cost om log 2 n 22 fully dynamic connectivity algorithm 221 algorithm next also consider insertions edge fu vg inserted g add fu vg e l u v previously connected g ie treeu l 6 treev l add fu vg f l let number levels l d2 log ne rebuild data structure executed periodically rebuild level 1 done move edgesi operation moves tree nontree edges e j also j tree edges e j inserted f k rebuild level contains edges f ie spanning trees level j span connected components g insertion increment number insertions modular 2 d2 log ne since start algorithm let j greatest integer k 2 k ji edge inserted rebuild level l executed represent binary counter whose bits b b 0 significant bit rebuild level occurs time th bit flips 1 222 proof correctness proof correctness one deletionsonly case except must set value l d2 log ne alter argument shows edges contained define iperiod period beginning right rebuild levels j start algorithm ending right next rebuild level j 0 ie iperiod starts right flip 1 bit j start algorithm ends next flip note two types iperiods begins immediately rebuild level edges e moved e j flips 1 b begins immediately rebuild level ie edges moved e b flips 1 easy see i1period consists two parts one type iperiod followed one since flip 1 bit b j must followed flip b 1 second bit b j 0 flips 1 theorem 26 let number edges e iperiod proof proof analogous lemma 21 lemma 27 smaller trees 1 level searched two consecutive rebuilds levels bound note may restrict attention edges moved one i1period since e empty start i1 period thus edge e either passed e one i1period moved single rebuild level empty start i1period edge moved e rebuild level passed e igamma1 e e igamma1 type iperiod ie first part i1period inserted g type iperiod h igamma1 maximum number edges passed e igamma1 e single ie iperiod followed b iperiod b number edges inserted g single iperiod number edges inserted g iperiod 2 lgammaigamma1 bound h use lemma 27 bound p summed smaller trees 1 searched level proof lemma 22 bound h choosing substituting h b yields choosing log ne noting 1 n 2 induction proof shows implies l 2 edges never passed l1 corollary 28 log ne edges e contained e l 223 analysis running time analyze running time note analysis case 1 case 21 affected rebuilds however 1 bound cost incurred insertion ie cost operation move edges 2 case 22 23 argument om log n edges gathered tested using nontree edges tree level course algorithm must modified cost 1 ie cost executing move edgesi cost moving tree edge nontree edge cost updating f k analyze first part note move edge e costs olog n per edge number edges moved greater p thus cost incurred cost inserting one tree edge given level olog n per edge tree edge added level since tree edge never passed thus cost may charged edge total cost olog 2 n per edge analyze cost 2 inserted since start algorithm rebuilds occurred level lower analysis level deletionsonly argument holds costs incurred level bounded om log 2 nc number edges initial graph applying lemma 27 conclude cost gathering testing edges smaller trees 1 level iperiod o2a log n log l note since o1 edges e l given time since cost olog n per edge gathering testing total cost instance gathering testing level olog n use potential function argument charge cost 1 2 insertions new insertion contributes c 00 log 2 n tokens toward bank account level total thetalog 3 n tokens since iperiod occurs every n 2 2 insertions tokens contributed insertions pay 2 log 2 n2 cost gathering testing level iperiod 2 log n2 cost move edgesi incurred iperiod 23 improvements section present simple trick reduces cost testing nontree edges incident smaller tree 1 o1 per edge total cost gathering testing edges incident 1 o1 per edge 231 constant time gathering testing noted since nontree edges incident ettree available list time needed retrieve edges o1 per edge one also test nontree edge o1 time ie determine set nontree edges contain one endpoint running list three times edge list initialize entry n theta n array use entries count number times edge appears list traverse list add edge whose count one 232 constant query test time deletionsonly algorithms note determining whether two vertices j component ie treej speeded o1 deletionsonly algorithm component split replacee l called replacement edge found case label nodes smaller component 1 new label cost proportional size 1 course algorithm cost log n since node appears smaller component log n times label improvement affect asymptotic running time randomized connectivity algorithm dominated cost random sampling however used deterministic algorithms presented later paper randomized algorithms dynamic graph problems section show dynamic graph problems polylogarithmic expected update time reducing problems connectivity give alternative algorithm maintaining minimum spanning tree 31 kweight minimum spanning tree algorithm kweight minimum spanning tree problem maintain minimum spanning forest dynamic graph k different edgeweights given time e initial graph compute minimum spanning forest f g define sequence subgraphs g fedges weight rank ig f initially l k distinct edgeweights called extras spanning forests g maintained connectivity algorithm forests f also stored dynamic trees subgraphs ordered weight edgeset stored balanced binary tree insert edge fu vg g determine u v connected f find maximum cost edge e path u v f weight e greater weight fu vg replace e f fu vg u v previously connected add fu vg f otherwise add fu vg e j j rank weight fu vg fu vg edge weight g create new subgraph adding fu vg extra inserting ordering g update e reflect changes f delete edge fu vg g delete fu vg graphs containing update f fu vg f tree f divided two components find minimum u v connected g using binary search list subgraphs search path u v spanning forest g find edge crossing cut use binary let x midpoint path recurse portion path u x u x connected f else recurse path x v correctness edge fu vg inserted cost less cost maximum cost edge tree path u v minimum spanning forest f unchanged cost fu vg less cost maximum cost edge e 0 tree path u v replacing e 0 fu vg decreases cost minimum spanning tree maximum possible amount gives thus minimum spanning tree g fu vg analysis running time algorithm 1 determines f changed 2 updates data structures 1 insertion maximum cost edge tree path u v determined time olog n using dynamic tree data structure f deletion takes time olog 2 n log log n find minimum u v connected g since connectivity query level takes time olog n log log n midpoint tree path u v g determined time olog n using dynamic tree data structure spanning tree g algorithm recurses log n times determine replacement edge fu vg total olog 2 n 2 insertion deletion fu vg e rank weight fu vg takes amortized expected time olog 3 n f changes one additional insertion deletion executed every e j update constant number operations dynamic tree f spanning tree every e j costing olog n thus amortized expected update time ok log 3 n 32 fflapproximate minimum spanning tree algorithm given graph weights 1 u 1fflapproximation minimum spanning tree spanning tree whose weight within factor 1ffl weight optimal problem maintaining 1ffl approximation easily seen reducible kweight mst problem weight rank falls interval 1 yields algorithm amortized cost olog 3 n log uffl log log n 33 bipartiteness algorithm bipartite graph problem answer query g bipartite o1 time g dynamic graph reduce problem 2weight minimum spanning tree problem use fact graph g bipartite iff given spanning forest f g nontree edge forms even cycle f call edges even edges remaining edges odd also use fact edge e f replaced even edge set even edges preserved let c cut f induced removing e e replaced odd edge nontree edge e 0 crosses c parity e 0 changes replace edge odd replacement edge exists even replacement edge thus parity even edge never changed f stored dynamic tree algorithm generate spanning forest f initial graph g tree even nontree edges weight 0 odd edges weight 1 edges weight 1 graph bipartite edge inserted determine odd even using dynamic tree data structure f give weight 1 0 accordingly edge deleted tree edge replaced odd edge weight 0 replacements remove odd edge find next replacement remove etc replacements relabel replacement edges even add back g correctness edge inserted algorithm determines even odd edge deleted replace even edge possible affect parity remaining edges even replacement edge exists odd replacement edge parity every edge cut changes however since even edge exists cut suffices make odd edges even edges analysis running time even edge never becomes odd thus weight edge changes shows insertion edge causes edge added data structure weight 1 weight 0 deletion edge leads removal edge data structure thus amortized expected update time olog 3 n 4 deterministic minimum spanning tree algorithm section present fully dynamic deterministic minimum spanning tree algorithm amortized time log n per operation current number edges g note technique sparsification 4 applied top algorithm yield algorithm log n amortized time per operation 41 deletionsonly minimum spanning tree algorithm data structures use similar randomized connnectivity algo rithm instead random sampling always exhaustively search edges incident smaller components edges stored p levels according weight move levels deletionsonly data structure kept old edges newly inserted edges kept separate level periodically rebuild executed deletionsonly data structure revised include newly inserted edges e jv rank edges weight edges g partitioned l levels l e l contains edges rank j compute minimum spanning forest f g keep forest f tree edges f minimum spanning forest v note f n f 411 algorithm update data structure deletion edge efuvg e tree edge delete nontreee e tree edge e delete treee replaceu v else gather test nontree edges incident 1 case 1 replacement edge found let e 0 minimum weight replacement edge case 2 replacement edge found 412 implementation analysis running time use data structure randomized algorithm storing nontree edges e appropriate ettree level ettree stored binary tree nontree edges stored ntlists gathering testing edges incident 1 may done wt time see improvements section 231 tree edge deleted replacement edge sought total cost gathering testing nontree edges given level charged deletion replacement edge found level consider latter case first 1 becomes new component f cost gathering testing edges incident 1 owt 1 given level log n see lemma 21 levels total cost om log n cost gathering testing level replacement edge found greater cost gathering testing every edge level addition tree edge p insert tree operations executed per level total cost log n cost delete nontree olog n cost thus log n per edge deletion plus total cost om log n course algorithm 42 fully dynamic minimum spanning tree algorithm 421 algorithm partial rebuild data structure executed p number edges graph last rebuild initially rebuild edges referred old edges still g stored deletionsonly data structure described newly inserted edges stored separate set e l1 f l minimum spanning tree consisting old edges ie gv f minimum spanning tree gv e ie old new edges store f dynamic tree data structure e l keep list edges ordered rank rebuild number updates insertions deletions since last rebuild start algorithm reaches p reset current number edges graph insert edge e l1 appropriate e l redistribute old edges among l e contains edges rank j gamma 1 p edges old edges tree edge level moves level 0 add edge levels remove edge levels delete edge e g e old tree edge update deletionsonly data structure e belong f stop otherwise delete vg f find minimum cost edge e 0 exactly one endpoint 1 e l1 add f smallercost edge e 0 replacement edge deletions data structure existent insert edge e g add edge e l1 test replaces edge f use dynamic tree find heaviest edge path es endpoints path determine e lighter yes modify f accordingly 422 analysis running time cost edge insertion olog n since consists constant number operations dynamic tree data structure cost edge deletion may include cost updating dynamic tree data structure olog n cost testing edges e l1 log n cost updating deletionsonly data structure show bound latter cost involved deletionsonly data structure rebuilds given analysis section 412 p per deletion tree edge plus overall cost om 0 log n rebuilds log n per update operation bound next cost rebuild first discuss adding edges appropriate level discuss rebalancing size level determining appropriate level edge takes time olog n using binary search moving nontree edge e l1 e l costs olog n per edge total moving tree edge e l1 e requires insertion edge levels j costs per edge total om 0 log n edge e l never moved one level rebalancing ie either e costs olog n per tree nontree edge thus time rebuild om 0 log n cost rebuild amortized p occur p number edges currently graph operation occurs since cost algorithm per edge deletion insertion log n 5 deterministic connectivity algorithm minimum spanning tree algorithm easily converted algorithm connectivity running time section give alternative connectivity algorithm log n amortized update time without use sparsification data structure used similar used previously presented algorithms two important dif ferences previous algorithm edges partitioned levels level contains p edges levels added needed initially levels edges created new edges inserted highest level contains less p edges newly created empty highest level otherwise data structure whole never rebuilt new levels added one time edges level deleted level discarded use term level denote ith nonempty level previous algorithm edges move levels f defined keep forest f tree edges f spanning forest v f stored relaxed versions ettrees called rettrees unlike ettrees used previous algorithms rettrees following property edge level deleted replacement edge found level j j rettrees levels updated allows us keep larger number levels 51 rettree data structure let spanning tree level let ct tree created contracting every spanning tree level one node node ct called big node thus edges ct belong f retttree consists ettree sequence et ct list edges active occurrence vertex replaced ffl list nodesa vertices g contracted form following first vertices incident edges e vertices vertex v g nodesa keep 1 list edges f incident v 2 list nontree edges incident v 3 number nontree edges incident v 4 pointer ffl number edges incident vertices nodesa addition keep ordered list nonempty levels stored doubly linked list l nonempty level array whose jth entry pointer location vertex j nodeslist level contains j operations rettrees defined ettrees omission sampletest addition two operations defined ffl big nodeu return big node level contains vertex u operation assumes e deleted edge f whose endpoints still contained big node level 1 let 1 2 spanning trees level containing endpoints e 1 smaller two trees split two big nodes represent implement big nodeu follow pointer level vertex u nodeslist level contains u pointer big node containing u call big node dominated cost finding level l takes time olog n implement split big smaller two subtrees let vg traversing et ct 1 level determine set u vertices g 1 using big one node u determine big node represents nodes u remove node u nodesa create new node b add nodes u new ordered nodesb list update number edges incident nodes nodesa nodesb accordingly call split big node takes time proportional number vertices 1 plus olog n call big node implementation ettree operations need modified slightly running time olog n insert nontreet e delete nontreee endpoint e may moved beginning end nodeslist containing implementation treex nontree edgest insert treee delete treee unchanged except constant number calls big node 52 algorithm update data structure deletion edge efuvg e tree edge execute delete nontreee e tree edge level delete treee call replaceu v gather test nontree edges incident 1 case 1 replacement edge e 0 found delete nontreee 0 insert treee case 2 replacement edge found let j next lowest nonempty level split big nodee j replaceu v j update data structure insertion edge efuvg number edges levell p build data structure new level reset l new level u connected call insert nontreee treeu l else insert treee l 53 implementation analysis running time gather test nontree edges store nontree edges ntlists see section 231 gathering testing edges incident 1 may done time owt 1 number nontree edges incident 1 show amortized time per update operation log n since building data structure new level takes time occurs every p n insertions total time insertions charge n insertion next show total cost deletions om log n 0 number edges initial graph k total number update operations search replacement edge takes time owt 1 separately consider cost search last level search occurred either terminated successfully discontinued levels cost levels search occurred total cost searches deletions last level p per search om 0 log n total cost searching levels replacement edge found summed 1 created levels applying lemma 21 total cost om log n cost split big node charged nodes 1 total cost n log n per level since om n levels created whole course algorithms total cost split big node om log n thus cost update operations amortized updates log n 6 acknowledgements thankful david alberts comments presentation r average case analysis dynamic graph algo rithms main tenance minimum spanning forest dynamic planar graph improved sparsification sparsification technique speeding dynamic graph algorithms separator based sparsification dynamic planar graph algorithms online edgedeletion problem data structures online updating minimum spanning trees ambivalent data structures dynamic 2edgeconnectivity k smallest spanning trees lower bounds fully dynamic connectivity problems graphs fully dynamic algorithms 2edge connectivity fully dynamic cycleequivalence graphs approximating minimum cuts insertions sparse certificates dynamic biconnectivity graphs using randomized sparsification approximate minimum cuts linear time algorithms finding sparse kconnected spanning subgraph kconnected graph fully dynamic biconnectivity graphs improved data structures fully dynamic biconnectivity graphs data structure dynamic trees finding updating spanning trees shortest paths tr data structure dynamic trees amortized analysis algorithms set union backtracking maintenance minimum spanning forest dynamic plane graph fully dynamic algorithms 2edge connectivity complexity models incremental computation separator based sparsification ambivalent data structures dynamic 2edgeconnectivity iki smallest spanning trees sparsificationmyampersandmdasha technique speeding dynamic graph algorithms polylogarithmic deterministic fullydynamic algorithms connectivity minimum spanning tree 2edge biconnectivity sampling provide bound online edgedeletion problem improved data structures fully dynamic biconnectivity certificates fast algorithms biconnectivity fullydynamic graphs ctr mihai ptracu erik demaine lower bounds dynamic connectivity proceedings thirtysixth annual acm symposium theory computing june 1316 2004 chicago il usa david eppstein dynamic generators topologically embedded graphs proceedings fourteenth annual acmsiam symposium discrete algorithms january 1214 2003 baltimore maryland glencora borradaile philip klein n log n algorithm maximum stflow directed planar graph proceedings seventeenth annual acmsiam symposium discrete algorithm p524533 january 2226 2006 miami florida robert e tarjan renato f werneck selfadjusting top trees proceedings sixteenth annual acmsiam symposium discrete algorithms january 2325 2005 vancouver british columbia umut acar guy e blelloch robert harper jorge l vittes leung maverick woo dynamizing static algorithms applications dynamic trees history independence proceedings fifteenth annual acmsiam symposium discrete algorithms january 1114 2004 new orleans louisiana camil demetrescu giuseppe f italiano algorithmic techniques maintaining shortest routes dynamic networks electronic notes theoretical computer science entcs v171 n1 p315 april 2007 david r karger minimum cuts nearlinear time journal acm jacm v47 n1 p4676 jan 2000 timothy chan dynamic subgraph connectivity geometric applications proceedings thiryfourth annual acm symposium theory computing may 1921 2002 montreal quebec canada jacob holm kristian de lichtenberg mikkel thorup polylogarithmic deterministic fullydynamic algorithms connectivity minimum spanning tree 2edge biconnectivity journal acm jacm v48 n4 p723760 july 2001 mikkel thorup worstcase update times fullydynamic allpairs shortest paths proceedings thirtyseventh annual acm symposium theory computing may 2224 2005 baltimore md usa eran eyal dan halperin dynamic maintenance molecular surfaces conformational changes proceedings twentyfirst annual symposium computational geometry june 0608 2005 pisa italy camil demetrescu giuseppe f italiano fully dynamic pairs shortest paths real edge weights journal computer system sciences v72 n5 p813837 august 2006
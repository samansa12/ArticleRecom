achieving scalable locality time skewing microprocessor speed growing exponentially faster memory system speed recent past paper explores long term implications trend define scalable locality measures ability apply ever faster processors increasingly large problems scalable parallelism measures ability apply numerous processors larger problems provide algorithm called time skewing derives execution order storage mapping produce desired degree locality certain programs made exhibit scalable locality approach unusual derives transformation algorithms dataflow fundamental characteristic algorithm instead searching space transformations execution order array layout used programmer artifacts expression algorithm provide empirical results data sets using l2 cache main memory virtual memory b introduction widening gap processor speed main memory speed generated interest compiletime optimizations improve memory locality degree values reused still cache wl91 number techniques developed improve locality scientic programs programs use loops traverse large arrays data gj88 wl91 wol92 mct96 ros98 techniques generally successful achieving good performance modern architectures however possibility processors continue outpace memory systems raises question whether techniques scaled produce ever higher degrees locality say calculation exhibits scalable locality locality made grow least linearly problem size using cache memory grows less linearly problem size article show calculations cannot exhibit scalable locality others typically require tiling discuss use compiletime optimizations produce scalable locality identify class calculations existing techniques generally produce scalable locality give algorithm obtaining scalable locality subset class techniques make use valuebased dependence relations pw93 won95 pw98 provide information ow values individual array elements among iterations calculation initially ignore issues cache interference spatial locality return address issues later dene balance calculation compute balance ratio operations performed total number values involved calculation live start end ratio measures supported nsf grant ccr9808694 int int figure 1 threepoint stencil singleassignment form initialize c zero int int int figure 2 matrix multiplication degree values reused calculation thus plays role determining locality running code similar mccalpins denition machine balance ratio processors sustained oating point operation rate memory systems sustained rate transferring oating point numbers mcc95 cases limits total numbers operations performed values produced place absolute limits compute balance therefore locality could achieved code run isolation example entire array live end loop nest shown figure 1 balance nest approximately 3 n values live entry n live exit 3 n operations values produced written main memory values live come main memory must generate one unit memory trac one oating point value read written every three calculations performed codes matrix multiplication figure 2 balance grows problem size thus large matrices may principle achieve high cache hit rates note compute balance depends information values live example live end figure 1 balance code 3t raises hope achieve scalable locality store values main memory compute balance also depends scope calculation considering elements killed second loop nest follows code figure 1 nest produces n values balance two nests could higher balance figure 1 alone raises hope improving locality time keeping values cache two nests one way achieve locality proportional compute balance would require fully associative cache large enough hold intermediate values generated calculation denition scalable locality explicitly rules approach achieve scalable locality must divide calculation ordered sequence stripes executing calculation stripebystripe produces result b stripe balance proportional problem size c calculations stripe executed order number temporary values simultaneously live small value considered temporary lifetime contained within stripe live entry entire calculation uses within stripe small mean capture idea data cache without referring initialize c zero int int int int int figure 3 tiled matrix multiplication wl91 int int int figure 4 timestep three point stencil particular architecture particular wish avoid cache requirements grow linearly worse size problem cases simple stencil calculations discussed mw98 limit sizes functions machine balance cases tomcatv benchmark discussed section 4 cache requirement grows sublinearly problem size tomcatv grows square root size input well balance existing techniques produce scalable locality codes example tiling matrix multiplication produces scalable locality figure 3 shows resulting code tile size terminology jb kb loops enumerate 2 stripes executes n tiles size 2 balance 2ns 2 within stripe total number temporaries live simultaneously exceed one tile b one column tile c thus increasing match machine balance could achieve appropriate locality using cache size os 2 ignoring cache interference however calculations current techniques cannot produce scalable locality see next section remainder paper devoted discussion achieving scalable locality class calculations call timestep calculations section 2 denes class calculations shows produce scalable locality simple example via time skewing mw98 section 3 generalizes time skewing beyond limited class problems discussed mw98 section 4 presents empirical studies benchmark codes section 5 discusses techniques improving locality section 6 gives conclusions calculations time skewing say calculation timestep calculation consists entirely assignment statements surrounded structured ifs loops possibly loops loops break statements loopcarried value based ow dependences come previous iteration outer loop call time loop example three point stencil calculation figure 4 timestep calculation computes new value int int figure 5 three point inplace stencil wl91 curi values curi1i1 previous iteration ow values essentially shown figure 1 contrast value computed iteration inplace stencil shown figure 5 used iteration call loop nest timestep calculation values last time step live end time loop values live entry calculation read rst time step balance timestep calculation proportional number time steps thus may able achieve scalable locality calculations producing stripes combine several time steps techniques presented wolf lam wl91 wol92 used achieve scalable locality figure 5 cannot applied calculations several loop nests timestep calculation figure 4 mw98 describe time skewing transformation used achieve scalable locality figure 4 originally formulated transformation could applied timestep stencil calculations array element updated using combination elements neighbors stencil one statement performs calculation statements simply move values second assignment figure 4 allowed next section describe general form time skewing remainder section reviews original formulation time skewing applies figure 4 essential insight understanding time skewing applies fairly conventional combination skewing tiling set dependences represent ow values rather memory aliasing example figure 4 value produced iteration calculation used iterations t1 1 single loop nest dependence pattern algorithm wolf lam would skew inner loop respect time loop producing fully permutable nest would tile loop nest achieve appropriate degree locality perform skewing tiling rst expand cur array forward substitute value old resulting code ob values produced tile consumption next tile b tile size stripe n tiles produces values performing b operations b temporaries ob live simultaneously thus may hope achieve scalable locality unfortunately expanding cur array causes temporary placed unique memory location yield improvement memory locality improve locality must either recompress expanded array manner compatible new order execution perform skewing tiling original imperfect loop nest requires combination unimodular nonunimodular transformations approaches discussed detail mw98 code results rst iterations except borders tiles work single array small enough cache array reside entirely cache iterations allowing us ignore issues spatial locality cache interference furthermore technique lets us optimize code originally presented singleassignment like figure 1 however approach taxes code generation system use limits even singlestatement stencils causes extremely long compile times produces code great deal additional integer math overhead due loop structure sw98 3 general algorithm time skewing section present general algorithm time skewing timestep calculations using example code tomcatv program spec95 benchmark set shown figure 6 begin giving domain algorithm techniques coerce aberrant programs domain present algorithm 31 domain algorithm timestep calculation loopcarried data ow must come previous iteration time loop tomcatv loop note j loops second nest determine maximum nest carry reduction dependences won95 inhibit time skewing j loops fourth sixth nests two dimensional loops solve tridiagonal carry data ow rst appear prevent application time skewing however proceed algorithm treat column array single vector value attempt block dimension iteration space consequences cache requirements shall see may possible extend algorithm handle cases loop carries dependence one direction along vector investigated possibility case fourth nest carries information forward j dimension sixth carries backward along dimension rules skewing dimension algorithm restricted subset timestep calculations meet following criteria 311 ane control ow loop steps must known loop bounds conditions tested statements must ane functions outer loop indices set symbolic constants makes possible describe iteration spaces set ane constraints integer variables necessary use omega library kmp 95 represent transform spaces allow one exception rule however conditions controlling execution outer loop need ane conditions may occur due breaks loops simply complicated loop bounds handled way though present discussion terms break statements since occurs tomcatv 312 uniform loop depth restricted intraiteration data ow every statement within time loop must nested within number loops ow information within iteration time loop must connect identical indices loops surrounding denition use example consider value produced last statement rst nest nd residuals value produced iteration j stored ryij used iteration j fourth nest note reference ryij1 statement cause trouble already given skewing j dimension cases may able convert programs proper form simply reindexing iteration space example rst loop ran 1 n2 produced ryi1j could simply bump loop 1 calculation involves nests dierent depths add singleiteration loops around shallower statements third loop nest tomcatv rst solve tridiagonal set two dimensions add additional j loop 2 2 around loop perform reindexing working backwards values live end iteration time loop example rxmt rymt used later x find residuals iteration 2 2 2 2 determine maximum values rxm rym residuals solve tridiagonal systems aaddaa parallel lu decomposition add corrections iteration figure benchmark spec95 used iteration 1 tag loops containing writes produce values xed follow data ow dependences back source iterations example data ow iteration j write last nest comes iteration j sixth nest j n 1 fth nest adjust iteration spaces loops reach way x sixth nest simply xed fth j loop n1 n1 wrapped around since iteration n 1 reads value ever need adjust xed loop algorithm fails least one dimension follow data ow statements reached nest explored data ow arcs cross iterations time loop loops reached process dead may omitted 313 finite interiteration data ow dependence distances code generation system work must know factor skew means must able put known nonsymbolic upper lower bounds dierence inner loop indices timeloopcarried ow values example rst loop nest tomcatv reads xi1j produced iteration upper bound dierence dimension must least 1 cannot apply current algorithm code coupled dependences eg rst nest read xijj 32 time skewing consider calculation domain described calculation tomcatv certain dimensions within domain values used iteration time loop come within xed distance l iteration loop l previous time step therefore ow information interfere tiling rst skew loop factor l observation made figure 4 section 2 fact think j dimensions seven arrays single 7 n matrix value data ow tomcatv identical figure 4 therefore proceed skew tile loops described requires fuse various loop nests may size fortunately relatively straightforward code generation system kpr95 omega library simply need provide linear mapping old iteration spaces new library generate code traverse iteration spaces lexicographical order given g loops l 1 within domain e loops e produce iteration space l nn number nest original ordering b size tiles wish produce formulation given mw98 addition constant levels levels within domain tomcatv transform original set iteration spaces nn nn ranges 1 8 initialization rxm rym counts nest 0 loops resulting g outer loops traverse set stripes contains b g iterations run statement e loops g e inner loops constitute tile perform ob g e operations ob g e oating point values e total size matrix constitutes value produced e loops executing statements ob g 1 e values consumed next tile providing stripes ob balance long e grows less linearly size problem hope scalable locality tomcatv e set seven arrays size n problem involves arrays size n 2 cache requirement grow square root problem size end section 2 left question store values without either corrupting result calculation eg use original storage layout writing temporaries main memory sucient quantities inhibit scalable locality eg fully expanding arrays principle know e could apply layout algorithm given mw98 producing array temporaries entirely cache may even possible develop algorithm perform operation b e symbolic parameters however absence major improvements implementation code generation systems kpr95 sw98 method impractical instead simply expand array factor two use t2 subscript new dimension causes temporaries written main memory number proportional number nontemporary values created number operations performed inhibit scalable locality method also forces us contend cache interference simply ignore point though could presumably apply algorithms reducing interference code generate finally code may may traverse memory unit stride possible arrays transposed dimension corresponding innermost loop scans consecutive memory locations 321 break statements apply algorithm calculation involving break guarded nonane condition follows create array boolean values representing value condition iteration convert statement expression simply computes saves value end iteration outer loop steps blocks iterations original time loop scan array determine break occurred time step time block completed record number iteration break occurred roll back calculation beginning time block restart upper bound time loop set iteration break preserve data present end time block using two arrays values live ends time blocks one even blocks one odd blocks double total memory usage aect balance locality calculation except degree changes interference eects possible determine break aect correctness result avoid overhead scheme simply stopping calculation end time block break occurred unfortunately know way determine purpose break statement without input programmer possibly form machinereadable comments within program 4 empirical results reviewers time results tomcatv benchmark running virtual memory nal version also expect results one workstations sun ultra60 several sgi machines include larger set benchmarks based experiences stencil calculations expect machines show either small gain small loss performance getting peak performance require manually hoisting loopinvariant expressions getting better complier verify value time skewing compensating extremely high machine balance tested using virtual memory dell 200mhz pentium system running linux system 64 main memory 128k l2 cache 300m virtual memory paged swap partition scsi disk test designed test value time skewing system extremely high balance transformed tomcatv benchmark according algorithm given previous section except break statement break taken execution sample data also increased array sizes 513 513 1340 1340 ensure seven arrays could main memory seven arrays together use 96 megabytes original code required 9 minutes per time step completing run t8 4500 seconds run t12 6900 seconds time skewed code increased 192 allow suciently large block size code required 20 seconds per time step completing 192 iterations 3500 seconds thus long runs performance improved factor 30 loop nests produced time skewing transformation may complicated original loops transformed code may slower original small problems example original tomcatv data set used entire data set ts main memory tile size greater 2 exceeds size l2 cache case time skewed code slower factor two 5 related work current techniques improving locality gj88 wl91 wol92 mct96 based search groups references may refer cache line assuming value stored address used original unoptimized program apply sequence transformations try bring together references address however transformation systems powerful enough perform time skewing transformation limits system used wolf lam given section 27 wol92 mckinley carr tseng apply loop skewing grounds wolf lam nd useful practice thus transformation systems may limited bandwidth loops able transform example without time loop none inner loops tomcatv exhibits scalable locality thus limits locality produced transformation body time loop recent work pugh rosser ros98 uses iteration space slicing nd set calculations used production given element array ordering calculations terms nal array element produced achieve eect similar combination loop alignment fusion example produce version tomcatv time step performs single scan array rather dierent scans original code however system transforms body time loop without reordering iterations time loop thus limited nite balance calculation loop body work tolerating memory latency mlg92 complements work bandwidth issues optimizations hide latency cannot compensate inadequate memory bandwidth bandwidth optimizations eliminate problems latency however see reason latency hiding optimizations cannot used successfully combination time skewing 6 conclusions calculations matrix multiplication achieve scalable locality via wellunderstood transformations loop tiling means able obtain good performance calculations computers extremely high machine balance long increase tile size provide matching compute balance however current techniques locality optimization cannot general provide scalable locality timestep calculations time skewing transformation described used produce scalable locality many calculations though increases complexity loop bounds subscript expressions systems extremely high balance locality issues dominate time skewing provide signicant performance improvements example obtained speedup factor running tomcatv benchmark arrays required virtual memory r strategies cache local memory management global program transformation omega library interface guide code generation multiple mappings memory bandwidth machine balance current high performance computers improving data locality loop transformations design evaluation compiler algorithm prefetching time skewing valuebased approach optimizing memory locality exact method analysis valuebased array data dependences code generation memory mappings data locality optimizing algorithm improving locality parallelism nested loops tr ctr guohua jin john mellorcrummey experiences tuning smg98 semicoarsening multigrid benchmark based hypre library proceedings 16th international conference supercomputing june 2226 2002 new york new york usa armando solarlezama gilad arnold liviu tancau rastislav bodik vijay saraswat sanjit seshia sketching stencils acm sigplan notices v42 n6 june 2007 kristof beyls erik h dhollander intermediately executed code key find refactorings improve temporal data locality proceedings 3rd conference computing frontiers may 0305 2006 ischia italy michelle mills strout larry carter jeanne ferrante barbara kreaseck sparse tiling stationary iterative methods international journal high performance computing applications v18 n1 p95113 february 2004 chen ding maksim orlovich potential computation regrouping improving locality proceedings 2004 acmieee conference supercomputing p13 november 0612 2004 zhiyuan li yonghong song automatic tiling iterative stencil loops acm transactions programming languages systems toplas v26 n6 p9751028 november 2004 chen ding ken kennedy improving effective bandwidth compiler enhancement global cache reuse journal parallel distributed computing v64 n1 p108134 january 2004
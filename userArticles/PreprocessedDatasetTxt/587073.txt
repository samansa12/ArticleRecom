model exploration temporal logic query checking temporal logic query temporal logic formula placeholders given model solution query set assignments propositional formulas placeholders replacing placeholders assignments results temporal logic formula holds model query checking first introduced william chan citechan00 automated technique finding solutions temporal logic queries allows discovery temporal properties system may useful tool model exploration reverse engineeringthis paper describes implementation temporal logic query checker suggests applications tool ranging invariant computation test case generation illustrates using cruise control system b introduction temporal logic modelchecking 7 allows us decide whether property stated temporal logic ctl 6 holds statebased model typical temporal logic formulas agp p q hold every state system agp every state p holds always followed state q holds model checking originally proposed verification tech however also extremely valuable model understand permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copies bear notice full citation first page copy otherwise republish post servers redistribute lists requires prior specific permission andor fee sigsoft 2002fse10 november 1822 2002 charleston sc usa r r figure 1 simple state machine ing 2 rarely start study design complete specification available instead begin key properties attempt use modelchecker validate properties hold seldom fault properties design typically need modified design bug found properties strong incorrectly expressed thus process aimed building correct model system also discovering properties query checking proposed chan 2 speed design understanding discovering properties known priori temporal logic query expression containing symbol x referred placeholder may replaced propositional formula 1 yield ctl formula eg agx agx p solution query set strongest propositional formulas make query true example consider evaluating query agx ie invariants system model figure 1 p q r strongest invariant others eg p q r implied thus solution query turn interested finding strongest property holds states following q holds form query model figure 1 evaluates solving queries usually want restrict atomic propositions present answer example may care value r invariant computed model figure 1 phrase question agxp q thus explicitly restricting propositions interest p q answer get p q given fixed set n atomic propositions interest query checking problem defined solved taking propositional formulas set substituting placeholder verifying resulting temporal logic formula tab propositional formula formula built atomic propositions boolean operators ulating results returning strongest solutions 1 number n propositions interest provides way control complexity query checking practice terms computation terms understanding resulting answer paper 2 chan proposed number applications query checking mostly aimed giving feedback user model checking providing partial explanation property holds diagnostic information example instead checking invariant agab evaluate query agxa b suppose answer b holds model therefore inform user stronger property explain b invariant b also use query checking gather diagnostic information hold example false request always followed acknowledgment ask guarantee acknowledgment agx af ack work chan concentrated valid queries queries always yield single strongest solution queries mentioned far valid chan showed general expensive determine whether ctl query valid instead identified syntactic class ctl queries every formula class valid also implemented querychecker class queries top symbolic ctl modelchecker smv queries may also multiple strongest solutions suppose interested exploring successors initial state model figure 1 forming query exx ie holds next states starting initial state s0 get two incomparable solutions p q r p q r thus know state s0 least two successors different values p furthermore successors q r holds clearly queries might useful model exploration checking queries multiple solutions done using method bruns godefroid 1 extend chans work showing query checking problem single placeholder solved using alternating automata 17 fact queries specified temporal logics ctl however far solution remains purely theoretical implementation querychecker available range applications query checking expanded limit queries one placeholder partic ular queries two placeholders allow us ask questions pairs states eg dependencies current next state system paper describes three major contributions 1 enrich language queries include several place holders previous methods dealt one place holder referring framework placeholders need named eg x pre 2 describe temporal logic query checking tool built top existing multivalued modelchecker chek 4 5 implementation allows one compute solutions placeholders also gives witnesses paths model explain solutions computed 3 outline uses temporal logic query checking domains requiring witness computation depend rest paper organized follows section 2 give necessary background paper briefly summarizing modelchecking query checking multivalued ctl modelchecking section 3 defines reduction query checking problem multivalued modelchecking section 4 describes possible uses query checking model exploration illustrate example cruise control system 16 section read without material sections 2 3 conclude section 5 summary paper directions future work proofs theorems appear paper found 11 2 background section briefly outline ctl modelchecking describe query checking problem give overview multivalued modelchecking 21 modelchecking modelchecking 6 automatic technique verifying properties expressed propositional branchingtime temporal logic called computation tree logic ctl system represented kripke structure properties evaluated tree infinite computations produced unrolling kripke structure tuple s0 r finite set states s0 initial state set propositional variables r total transition relation 2 labeling function maps state onto set propositional variables hold ctl defined follows 1 constants true false ctl formulas 2 every atomic proposition ctl formula 3 ctl formulas ag boolean operators usual meaning temporal operators two components e quantify paths x f u g indicate next state eventually fu ture always globally respectively hence ax true state true next state paths eu true state exists path true every step becomes true formal semantics ctl given figure 2 figure use function true false indicate result checking formula state define set successors state familiar notation indicating property holds state kripke structure k k defined follows also say formula holds kripke structure k holds ks initial state figure 2 used conjunction disjunction place familiar universal existential true false figure 2 formal semantics ctl operators true false true false p p true b c figure 3 lattices set b represented using minimal elements quantification semantics ex ax alternatively expressed semantics eg eu follows finally remaining ctl operators given ax ex af atrue u ef etrue u ag ef example consider model figure 1 s0 initial state p q r properties agp q af q true model whereas axp 22 query checking fundamentals exposition follows presentation 1 lattice partial order l every finite subset b l least upper bound called join written b greatest lower bound called meet written b maximal minimal elements lattice respectively lattice distributive join distributes meet vice versa given set atomic propositions p let pf p set propositional formulas p example pf false p p set forms distributive lattice implication see figure 3a since p true p true lattice meets joins lattice correspond classical op erations respectively propositional formula solution query state substituting placeholder formula holds kripke structure k state query positive 2 1 solution 1 2 2 also solution example p q solution p words set solutions positive query set propositional formulas upward closed respect implication ordering propositional formula solution every weaker formula alternatively query positive placeholders occur even number negations 2 positive queries makes sense look strongest solutions solutions inferred notions formalized given ordered set l subset b l define example ordered set pf p shown figure subset b l upset p upset whereas p p true write ul set upsets l distributive lattice formed elements upf p ordered set inclusion shown figure 3b refer upset lattice finally note upset uniquely represented set minimal elements example sufficient represent set p p true false sufficient represent p p true false figure 3c shows lattice using minimal elements remainder paper say x solution query mean x pf p x set minimal solutions query x set solutions 23 multivalued modelchecking multivalued ctl modelchecking 5 generalization modelchecking problem let b refer classical algebra values true false classical logic instead using b multivalued modelchecking defined de morgan algebra finite distributive lattice operation preserves involution de morgan laws conjunction disjunction defined using meet join operations l respectively algebra get necessarily law noncontradiction excluded middle properties specified multiplevalued extension ctl called syntax ctl except l also ctl formula however semantics somewhat different modify labeling function kripke structure l atomic proposition means variable value state thus operations defined ctl counterparts see figure 2 interpreted lattice spectively fact rest paper often write place even algebra use different b complexity modelchecking ctl formula kripke structure algebra os h h height lattice l provided meets joins quantification operations take constant time 5 implemented symbolic modelchecker chek 4 receives kripke structure k ctl formula returns element algebra corresponding value k exact interpretation value depends domain example algebra b chek returns true holds k false classical modelchecking information multivalued modelchecking please consult 4 5 3 temporallogicquerychecker section describe computation querychecking solutions detail express querychecking problem one placeholder terms multiplevalued modelchecking framework described section 2 discuss deal queries containing multiple placeholders finally case nonpositive queries recall multivalued modelchecking extension modelchecking arbitrary de morgan algebra case algebra given upset lattice propositional formulas see figure 3 order reduce querychecking multivalued model checking need translate given query ctl formula element upset lattice corresponding value ctl formula set solutions query 31 intuition consider two simple examples temporal logic queries using model figure 1 first ask x meaning propositional true state solving query respect s0 notice formula pqr holds s0 formulas hold s0 implied thus strongest solution set solutions given p q r next look axx means single formula holds successor states solve query respect state s0 must first identify successors s0 solve query x finally take intersection results solution x two successors s0 s1 s2 p q r p q r respectively intersection solutions q r thus q r holds successors s0 solution axx implied notice computation corresponds meet upset lattice precisely matches ctl semantics ax figure 2 based observation show querychecking reduced multivalued modelchecking 32 reduction ctl translation defined topdown operators constants propositional variables translated onetoone mapped disjunction translation translation variable p mapped true mapped constant symbol forth model figure 1 show translate placeholder x consider computation xp q state s0 model figure 1 solution pq query obtained examining values p q s0 formalize using casestatement case p case p since cases disjoint yields syntactic evaluate xp q use fact p qs0 get illustrate idea consider complex query evaluated state s0 figure 1 set solutions subquery exxp q p q p q set solutions x p q get set solutions query intersect results get p p q theorem 1 let translation ctl queries ctl ctl query state model contains exactly solutions state stated section 23 multiplevalued modelchecking time complexity os h h height lattice thus estimate complexity querychecking need compute height upset lattice used reduction querychecking multivalued modelchecking placeholder restricted n atomic propositions p1 pn since 2 n propositional formulas n variables height upset lattice upf p1 pn 2 2 n 1 complexity querychecking os recall traditional modelchecking height modelchecking lattice 2 complexity os thus solving query worst case 2 2 n times slower checking equivalent modelchecking property however find practice running time querychecker much better worst case see section 44 33 complex queries one placeholder required express properties interest section give extension query checking allows multiple placeholders may depend different set propositional variables furthermore describe solve nonpositive queries 331 multiple placeholders query contains multiple placeholders transformed ctl formula substituting propositional formula placeholder thus given query n placeholders l lattice propositional formulas ith placeholder set possible substitutions given cross product lift implication order pointwise elements l thus forming lattice two placeholders set solutions query element upset lattice l show translate queries multiple placeholders ctl consider query x exx axy potential solution query element solve query first find solutions subformula combine results let b l1 set solutions x viewed query one placeholder however since two placeholders solution including intermediate ones must subset l query x depend placeholder therefore substitution ie element l2 acceptable results similarly set solutions exx c l2 axy l1 c l1 l2 combining results get thus set solutions query x x example let us compute solution query xp q exyp q state s0 model figure 1 know example section 32 one placeholder recall solution xp q exyp q element lattice lattice putting together yields thus query two minimal solutions p q p q p q p q 332 negation every query converted negationnormal form representation negation applied atomic propositions placeholders query positive placeholders nonnegated query put negationnormal form furthermore say occurrence placeholder query negative appears negated negationnormal form query positive otherwise section describe nonpositive queries solved transforming positive form querychecking postprocessing solution note solutionset negated placeholders depend maximal solutions 2 rather minimal ones consider two separate cases 1 occurrences placeholder either negative positive 2 given placeholder appears negative positive forms case 1 query converted positive form removing negations appear front placeholder solved described previous section finally ith placeholder occurred negative position ith formula solution negated yield correct result theorem 2 1 n solution query q query q identical q except ith placeholder appears negated 1 n solution q element solutionset x pf p maximal sketch proof giving example query single placeholder consider query agx obtain solution set agx choose one formula since ag holds model ag therefore solution set agx case 2 placeholder x appears positive negative forms first replace positive occurrence x negative occurrence x solve resulting query finally set solutions x given intersection solutions x x complexity using multivalued modelchecking query checking multiple placeholders remains determined height lattice show result two placeholders xp1 pn yq1 qm 2 2 n possible solutions x therefore 2 2 possible simultaneous solutions height powerset lattice solutions 1 complexity os result generalizes easily number placehold ers case single placeholder find practice query checking feasible worst case see section 44 4 applications experience section show two different techniques model exploration using temporal logic queries technique presented section 42 uses solutions querychecking problem essentially extension methodology proposed chan 2 technique presented section 43 completely new based fact addition computing solution query modelchecker also provide witness explaining examples section based experience exploring scr specification cruise control system 16 described section 41 please refer table 3 running time various queries used section 41 cruise control system ccs cruise control system ccs responsible keeping automobile traveling certain speed driver accelerates desired speed presses button steering wheel activate cruise control cruise control maintains cars speed remaining active one following events occurs 1 driver presses brake pedal brake 2 driver presses gas pedal accel 3 driver turns cruise control engine stops running running 5 driver turns ignition ignition 6 cars speed becomes uncontrollable toofast first three events listed occur driver reactivate cruise control system previously set speed pressing resume button scr method 12 used specify eventdriven systems system outputs called controlled variables computed terms inputs environment called monitored variables system state represent state scr uses notion mode classes sets states called modes partition monitored environments state space system changes state result events changes monitored variables example event ta b formalized b indicates becomes true next state b true current state prime variables refer values next state use simplified version ccs 3 10 monitored variables 4 controlled variables one throttle described system also one modeclass cc described table 1 row mode transition table specifies event activates transition mode left mode right system starts mode ignition false transitions mode inactive ignition becomes true table 2 shows event table throttle throttle assumes value taccel indicating throttle accelerating position 1 speed becomes slow system mode cruise shown first row table 2 2 system returns mode cruise indicated tinmode speed determined slow see second row table 42 applications queries without witnesses show temporal logic queries replace several questions ctl modelchecker help express reachability properties discover system invariants transition guards reachability analysis common task model exploration finding states reachable example ccs may want know whether modes modeclass cc reachable easily solved checking series ef properties example ef holds mode cruise reachable however queries provide concise representation solution single query ef xcc corresponds reachable modes ie values p ef example solutions include modes thus modes reachable similarly finding possible values throttle system mode cruise accomplished query ef complex analysis done combining ef queries ctl operators exam ple see queries rows 6 7 table 3 discovering invariants invariants concisely summarize complex relationships different entities model often useful identifying errors discover invariants simply need solve query agx placeholder restricted atomic propositions model unfortunately trivial models solution query big used effectively 2 however easy restrict attention different parts model example set invariants mode inactive respect variables ignition running solution query evaluates using multiple placeholders find invariants mode using single query example solution query agxcc yignition running corresponds invariants individual mode example solution running indicates ignition running remain true system mode cruise moreover query also help analyst determine invariants shared modes solution ignition see ignition stays true throughout mode inactive also invariant modes cruise override mode invariants ccs able discover using querychecking equivalent invariants discovered algorithms 14 15 notice strength invariants obtained querychecking depends variables placeholder restricted strongest invariant obtained restricting placeholder monitored variables system guard discovery finally illustrate queries used discover guards 18 suppose given kripke structure translation scr model ie events enable transitions modes explicitely represented reverseengineer mode transition table discovering guards kripke structure formally guard defined weakest propositional formula current pre next post states invariant holds guard pre postconditions respectively notice since define guard weakest solution guard directly correspond scr event later show scr events discovered combining guards mode invariants since guards defined pre poststates two placeholders required express query used discover making guard weakest solution query agpre axpost show query used discover event causes ccs switch mode cruise inactive case let furthermore practical reasons restrict pre post placeholders set toofast running brake solving query obtain two solutions toofast running post true toofast analyzing result obtain invariant mode cruise toofast running using invariant discovery technique presented section 42 notice first solution violates invariant making antecedent implication false however second solu tion follows axrunning toofast holds yielding guard toofast finally combining invariant mode cruise determine mode transition guarded two independent events frunning ttoofast indicated mode transition table 43 applications queries given existential ctl formula holds model modelchecker produce trace model showing formula holds trace called witness formula similarly given existential query querychecker produce set traces also refer witness showing minimal solutions satisfies query example consider query exxp model figure 1 two minimal solutions fore witness consists two traces one solution shown figure 4 trace s0 s2 corresponds solution p trace s0 s1 solution p traces comprising witness query start old mode event new mode tignition inactive inactive fignition ignition running cruise fignition inactive frunning ignition inactive ignition running ignition running initial mode ignition table 1 mode transition table mode class cc cruise control system modes events cruise tinmode tinmode tinmode finmode throttle table 2 event table controlled variable throttle figure 4 witness exxp model figure 1 initial state represented tree addition querychecker labels branch tree set solutions illustrated branch example figure 4 left branch labeled right p benefit treating witness tree rather set independent traces becomes possible prefer certain others example may prefer witness longest common prefix usually results minimizing total number traces comprising witness show witnesses used several software engineering activities guided simulation easiest way explore model simulate behavior providing inputs observing system behavior outputs however almost impossible use simulation guide exploration towards given objective wrong choice inputs beginning simulation result system evolving uninteresting behavior example let objective exploration ccs evolves different modes case guess set inputs results system evolving mode cruise set inputs yields transition mode inactive etc thus process exploring system using simulation usually slow error prone interesting alternative simple simulation guided simu lation guided simulation setting user provides set ob jectives needs choose different paths system cases objective cannot met single path moreover choice given together set objectives satisfies querychecking natural framework implementing guided simulations objective given query witness serves basis simulation example suppose want devise set simulations illustrate ccs evolves modes formalize objective query ef xcc explore witness moreover indicate prefer witnesses largest common prefix results single trace system going modes inactive cruise finally override trace corresponds simulation given sequence events tignition boff since objective achieved single trace simulation generated completely automatically requiring user input test case generation although primary goal modelchecking verify model temporal properties recently used generate test cases 10 9 13 18 proposed techniques based fact addition computing expected outputs modelchecker produce witnesses counter examples used construct test sequences properties used force modelchecker generate desired test sequences called trap properties 10 gargantini heitmeyer 10 proposed method uses scr specification system identify trap properties satisfying form branch coverage testing criterion technique uses mode transition condition tables generate test se query time explanation reachable modes values throttle reachable mode cruise 3 agefxcc 0787s modes globally reachable 4 efegxcc 0720s modes selfloops inactive xignition running 0267s invariants ignition running mode inactive 6 agxcc xignition running 0942s find mode invariants restricted ignition running modes follow 8 ef old cc exnewcc 1204s pairs modes follow 9 ef values toofast inactive change system exytoofast running goes modes cruise inactive table 3 summary queries used section 4 query time table 4 comparison modelchecking querychecking quences illustrate technique applicable mode transition tables tables analyzed similarly method 10 assures form branch coverage satisfying following two rules 1 mode mode transition table test event least 2 mode test every case mode change nochange least example two test sequences need generated mode one testing event tignition testing nochange case obtained using following trap properties alternatively two test sequences obtained witness single query ef sim ilarly set test sequences cover full mode transition table obtained witness query ef old cc exnewcc since traces comprising witness query generated time possible minimize number different test sequences guarantee full coverage mode transition table moreover whenever ef query one minimal solution querychecker produce minimal solution necessary witness soon new solution found therefore even cases complexity modelchecking precludes obtaining results trap properties querychecker produce solution trap properties soon possible although method suggested generates set test sequences cover every change every nochange mode system necessarily cover events ex ample change mode cruise mode inactive guarded two independent events ttoofast frunning however witness trap query contains single trace corresponding change covering one events first identify events covered test sequences witness query use method 10 generate additional test sequences events yet covered alternatively know variables comprising event given mode transition remedy problem using additional query current example events causing change mode cruise mode inactive depend variables toofast running cover events form query witness query corresponds two test sequences one testing change event ttoofast event frunning 44 running time theoretical complexity querychecking section 32 seems indicate querychecking feasible small models however experience see running times queries used section table 3 seems indicate otherwise address issue detail theoretically solving query single placeholder restricted two atomic propositions slower modelchecking equivalent formula factor analyze difference theoretical prediction actual running times verified several ctl formulas related queries summarized results table 4 ctl formulas checked using chek parametrized b query second row restricted two atomic propositions required encode enumerated type cc however running time query double corresponding ctl formula row 1 similar picture seen comparing ctl formula row 3 query row 4 table finally increasing number variables placeholder depends slow analysis significantly yet comparing queries rows 4 5 table see observed slowdown threefold although conducted comprehensive set experiments evaluate running time querychecker believe preliminary findings indicate querychecking fact feasible practice 5 conclusion section summarize paper suggest venues future work 51 summary discussion paper extended temporal logic querychecking chan 2 bruns godefroid 1 allow queries multiple placeholders shown applicability extension concrete example implemented querychecker multiple placeholders using multivalued modelchecker chek implementation allows us generate solutions temporal logic queries also provide witnesses explaining answers preliminary results show feasible analyze nontrivial systems using querychecking please send email xchekcstorontoedu copy tool building querychecker top modelchecker two advantages first allow querychecking systems fairness assumptions example compute invariants ccs assumption brake pressed infinitely often far know chans system implement fairness presentation paper used ctl temporal logic however since underlying framework chek based calculus easily extend query checker handle calculus queries also convinced temporal logic querychecking many applications addition ones explored par ticular see immediate applications variety test case generation domains hope practical querychecking impact modelchecking model exploration analysis finally note querychecking special case multivalued modelchecking multivalued modelchecking originally designed reasoning models containing inconsistencies disagreements 8 thus reasoning done algebras derived classical logic relation indicates true equal querychecking done lattices algebras different interpretation sets propositional formulas believe might yet useful interpretations algebras making chek ideal tool reasoning 52 future work paper considered queries placeholders restricted sets atomic propositions however experience found useful place restrictions placeholders example may want restrict solutions query ef xp q r cases p q true simultaneously computational point view framework supports however expressing queries requires extension query language methodology guide use currently exploring query language inspired sql query would expressed follows ef x x pf p q r x p q future plan conduct case studies better assess feasibility querychecking realistic systems also believe existence effective methodology crucial success querychecking practice use case studies guide us development methodology 6 acknowledgements gratefully acknowledge financial support provided nserc cito also thank members uoft formal methods reading group suggestions improving presentation work 7 r temporal logic querychecking temporallogic queries towards usability formal methods multivalued modelchecker modelchecking multivalued logics automatic verification finitestate concurrent systems using temporal logic specifications model checking framework multivalued reasoning inconsistent viewpoints test generation intelligent networks using model checking using model checking generate tests requirements specifications temporal logic query checking multivalued model checking automated consistency checking requirements specifications automatic test generation statecharts using model checking automatic generation state invariants requirements specifications algorithm strengthening state invariants generated requirements specifications example nrlscr software requirements automobile cruise control monitoring system automatatheoretic approach branchingtime model checking coverage based testcase generation using model checkers tr automatic verification finitestate concurrent systems using temporal logic specifications automated consistency checking requirements specifications automatic generation state invariants requirements specifications using model checking generate tests requirements specifications model checking automatatheoretic approach branchingtime model checking framework multivalued reasoning inconsistent viewpoints test generation intelligent networks using model checking modelchecking multivalued logics algorithm strengthening state invariants generated requirements specifications queries chichek temporal logic query checking ctr steve easterbrook marsha chechik benet devereux arie gurfinkel albert lai victor petrovykh anya tafliovich christopher thompsonwalsh chek model checker multivalued reasoning proceedings 25th international conference software engineering may 0310 2003 portland oregon dezhuang zhang rance cleaveland efficient temporallogic query checking presburger systems proceedings 20th ieeeacm international conference automated software engineering november 0711 2005 long beach ca usa
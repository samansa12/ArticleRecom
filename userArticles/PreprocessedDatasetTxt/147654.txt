programming verifying realtime systems means synchronous dataflow language lustre benefits using synchronous dataflow language programming critical realtime systems investigated benefits concern ergonomy since dataflow approach meets traditional description tools used domain ability support formal design verification methods shown using simple example language lustre associated verification tool lesar used design program specify critical properties verify properties language lustre uses already discussed several papers emphasis put program verification b introduction useless repeat realtime programs among errors dramatic consequences thus programs constitute domain special need rigorous design methods advocate language approach problem arguing programming language used direct influence quality software several points view language allow natural description problem solved particular close traditional tools used application field ii language formally sound order support formal verification methods iii language simple enough minimize risk misunderstanding program meanings main goals designing language lustre 11 18 meet criterion started traditional description tools used design process control systems higher level tools consist mathematical formalisms differential equations boolean lower level people often use dataflow nets blockdiagrams analog schemas switch gate networks two classes tools closely related instance work partially supported esprit basic research action spec contract merlin gerin differential equations finite difference equations boolean equations straightforwardly translated respectively analog schemas blockdiagrams gate networks least class high level tools also meets criterion ii since derived mathematical language authors eg 23 2 claimed declarative formalisms simpler cleaner usual imperative languages assignments sideeffects aliasing parameter passing mechanisms unnatural phenomena difficult understand manage agree claim therefore consider declarative formalisms constitute good basis designing programming language meeting criterion iii lustre synchronous dataflow language initially inspired lucid lucid lustre variable expression considered represent sequence values takes whole execution program lustre operators considered operate globally sequences synchronous nature language consists assuming variables expressions program take nth value respective sequences time concretely program intended cyclic behavior execution cycle consisting computing nth value variable expression basically program set equations write equation xe x variable e expression mean sequences values associated x e identical actual equation mathematical sense equivalently cycle program x e take value time synchrony real time capabilities language derived synchronous interpretation like synchronous languages 6 8 13 21 24 consider following logical notion time soon specify order simultaneity relations events occurring inside outside program express time constraints behavior program instance constraint like occurrence dangerous situation must followed emission alarm within delay 2 seconds expressed occurrence event dangerous situation must occurrence event alarm 2nd next occurrence event second example shows synchronous programming real physical time considered external event second privileged nature multiform time point view time may counted seconds well meters since conceptual difference two following requirements train must stop within 10 seconds train must stop within 100 meters synchronous language constraints expressed similar ways contrast languages like ada real time handled special statements lustre event modeled boolean variable whose value true whenever event occurs synchronous interpretation abstract point view consider program reaction time negligible respect reaction time environment advantages abstraction pointed 5 4 3 concerning semantics cleanness fact reconciles concurrency determinism particular 4 argues synchronous languages particularly wellsuited programming reactive kernels realtime systems complex systems generally require combination asynchronous synchronous modules claim therefore synchronous languages general purpose languages rather specialized tools design kernels one may wonder realism synchronous hypothesis since assumes machine instantly reacts input events fact assumes reaction time short enough accurately distinguish order incoming events practice checked measuring maximum reaction time program synchronous languages implemented particularly efficient measurable way following technique developed esterel 6 two versions lustre compilers written 11 20 use technique object code structured finite automaton transition corresponds reaction program 1 code corresponding transition linear loopfree maximal execution time accurately bounded given machine therefore validity synchrony hypothesis checked realtime issue synchronous approach design verification perform rely checking section 2 briefly present language whose use illustrated section 3 small example adapted actual subway device specification verification remainder paper devoted program verification said synchronous approach limits timing verification checking validity synchrony hypothesis kind verification mind similar standard verification transition systems nothing methods models like eg 16 26 taking account program execution time always assumed zero synchronous model moreover goal prove correctness program respect complete specifications rather express verify critical properties instance aircraft flight control system error speed computation slight conse quences whereas critical undercarriage locked landing claim critical properties usually simple verified means available automatic techniques main reason claim experience shows properties safety properties state given situation never occur given statement always hold contrast liveness properties state given situation eventually occur future 2 instance relevant question train eventually stop never crosses red light important remark proof techniques safety properties known much simpler liveness properties ffl safety properties checked program abstractions intuitively one simplify given program p abstract program p 0 behaviors p p 0 satisfies safety property p abstraction technique valuable experience shows considered critical properties seldom depend numerical compiling technique specific synchronous languages since asynchronous language non deterministic interleaving asynchronous actions would involve immediately combinatorial explosion automaton size matter fact liveness properties often introduced abstract response time constraints must taken fully account realtime system relations computations often logical dependencies events proof often handled finite state abstractions programs ffl safety properties checked program states rather execution paths approach propose verification problem amounts proving program never outputs value false finite state case verification done simple traversal state graph without keeping track path graph efficient methods 22 proposed traversal ffl safety properties modularly verified process composition operator one easily associate operator two processes p 1 p 2 respectively satisfying safety properties oe 1 oe 2 composition verification problem decomposed simpler ones ambition rather modest since restrict checking safety properties finite state abstractions programs hope getting efficient tools tackling many reallife cases view discussion propose method specifying checking simple safety properties lustre programs section 4 show take advantage declarative nature lustre express properties language shown 7 safety property program expressed invariance boolean lustre expression due fact lustre viewed executable temporal logic concerning ergonomics obvious advantage using full programming language instead temporal logic particular user define temporal operators 3 thus reducing complexity property expression moreover lustre provides means expressing assumptions program environ ment essential feature since interaction realtime program environment particularly important general properties realtime program intended hold assumptions behavior environment assumptions quite complex verification process deals three entities program property expressed invariant assumptions property intended hold also expressed invariant sections 5 6 illustrates proposed approach example verification sec tion 7 performed finite state abstraction program models behavior boolean variables verification tool called lesar available apply two verification techniques ffl former exhaustive enumeration states abstraction program similar standard model checking 12 27 ffl later symbolic construction set states satisfy property analogous symbolic model checking 10 14 15 techniques applied example introduced section 3 finally section 8 outlines method modular verification taking advantage fact program properties expressed language use proved properties subprogram verification full program technique reduce complexity verification 3 powerful mechanism macronotation offered specification languages 12 29 2 language lustre give detailed presentation language lustre found elsewhere 11 18 recall elements necessary understanding paper lustre program specifies relation input output variables variable expression intended function time time assimilated set natural numbers variables defined means equations one one equation variable input said equation xe e lustre expression specifies variable x always equal e expressions made variable identifiers constants considered constant functions usual arithmetic boolean conditional operators considered pointwisely applying func tions two specific operators previous operator followedby operator ffl e expression denoting function nen pree expression denoting function n nil nil undefined value two expressions type respectively denoting functions nen nfn e f expression denoting function n addition equations lustre program contain assertions form assert e e boolean expression means e assumed always true execution program instance assert noton expresses input events never occur time assertions introduced order express known properties environment optimization purposes play important role program verification lustre program structured nodes node subprogram specifying relation input output parameters relation expressed unordered set equations assertions possibly involving local variables declared node may functionally used expression basic operator instance following declaration defines node general usage returns true whenever boolean parameter raises false true node edgex bool returns edge bool let prex tel expression edgenot c true whenever variable c falling edge 3 example program let us introduce example adapted subway device end subway line special uturn section allows trains switch one track go back opposite direction see fig 1 uturn section composed three tracks b c switch assuming entering track exiting track c trains switching c must first wait connect b transit b wait connect c going back c considering several trains move along tracks switch safe device two kinds accidents may occur within section ffl several trains allowed access section together may collide ffl switch well positioned trains derail therefore clear controlling uturn section highly critical task automatic uturn section management system later called ums must drive switch manage train movements along section avoid accidents system typically reactive upon receipt information switch status train position inside section deliver positioning requests switch access grants trains four kinds events modeled following signals ffl ack ab ack bc indicate whether switch actually connects b b c none signals active trains must take switch ffl b c three sensors one track section active long train track observe ffl ab bc requests switch connect b b c ffl grant access grant exit grants trains move along section correspond traffic lights first one allow trains access section empty switch connects b second one allow trains exit b switch connects b c overview system environment given fig 2 let us implement ums lustre sequel assumed initially train section let us define equations switch positioning requests switch requested connect b time section empty connect b c time train arrived b requests remain active switch right position lustre directly get equations figure 1 subway uturn section ack ab ack b ums c grant access grant exit ab figure 2 ums system environment ackab emptysection ackbc onlyonb empty section states train section b states trains section b equations variables followings onb onc notona onc write equations defining movement grants mentioned access section granted empty switch connects b therefore get following equation emptysection ackab trains granted exit section switch connects b c trains section b get finally get whole lustre program ums system shown fig 3 simple example intends show lustre wellsuited programming systems equations written program straightforwardly deduced informal specifications uturn section fact equations written order encourages progressive translation specifications requirement expressed turn possibly involving introduction auxiliary variables notice introducing auxiliary variable like empty section naming expression influence program semantics increase readability node umson aon bon cack aback bc bool returns grant accessgrant exit abdo bc bool var empty section b bool let grant access empty section ack ab grant b ack bc ack ab empty section ack bc b empty section noton b c b b noton c tel figure 3 lustre program ums system expressing critical properties let us consider expression critical properties program many formalisms proposed inspired either temporal logics process algebras however order reduce users effort looking formalism close possible programming language propose express property invariance boolean lustre expression express property p program pi write boolean expression b p satisfied b always true execution pi shown elsewhere 7 lustre viewed subset linear temporal logic 25 safety property expressed way experience critical properties required realtime system almost always fall class matter fact nobody cares whether alarm eventually follows dangerous situation rather whether occurs within given delay let us show useful non trivial temporal operators expressed lustre nodes consider following property occurrence critical situation causes alarm must sustained within five seconds delay property relates three events occurrence critical situation alarm deadline general pattern property following one occurrence event must cause condition b true next occurrence event c however formulation directly translatable lustre refers happens future following occurrence lustre allows references past respect current instant first translate equivalent past time occurred past either b continuously true c occurred least since last occurrence let us define node taking three boolean input parameters b c returning boolean output x x always true property holds node alwaysfromtobac bool returns x bool let tel equation defining x uses four auxiliary nodes ffl nodes implies implements ordinary logical implication node impliesa b bool returns aimpliesb bool let b tel ffl node returns value false first time input true returns true ever node aftera bool returns aftera bool let tel ffl node always since two inputs returns true first input continuously true since last time second input true node alwayssinceba bool returns alwaysbsincea bool let else aftera b prealwaysbsincea else true tel ffl finally node since two inputs returns true first input least true since last time second input true node oncesinceca bool returns oncecsincea bool let else aftera c preoncecsincea else true tel nodes used example course operators could defined way see 19 5 critical properties example let us express lustre set safety properties required uturn management system mentioned system must always avoid occurrence two dangerous situations first one concerns train collisions check train may enter section one empty lustre property expressed invariance boolean variable collision defined follows equation defining grant access property obviously true assuming train enters section track c possible consider one train section time check train entering section track always leave track c derailment possible leads verify switch driven first clear switch positioning requests never active time simply expressed invariance following lustre expression switch also connect b instant train allowed enter section arrived track b leads following property similarly switch always connect b c instant train allowed leave section actually left notice property true train cannot leave section track finally global property prove expressed following lustre equation nocollision exclusivereq noderailab noderailbc 6 modeling environment next step verification process consist running verification tool check whether safety properties preserved ums however point important crucial task provide description environment system behaves actually environment obeys rules restrict possible behaviors instance uturn section trains assumed stop traffic lights red verification tool would certainly achieve checking system without aware information therefore necessary define assumptions behavior environment lustre done using assertion mechanism said lustre assertions express boolean expressions assumed always true let us describe way important features uturn section environment make following assumptions ffl switch cannot connect b b c assert notackab ackbc ffl given position switch remains stable unless requested move opposite position assert alwaysfromtoackabackabdobc alwaysfromtoackbcackbcdoab train movements inside section make following assumptions ffl initially train section assert emptysection true remember empty section true equal empty section initial instant true forever assertion restricts initial value empty section trains obey traffic lights train enters leaves section corresponding traffic light green instant therefore get using node edge defined section 2 assert true impliesedgenot emptysection pre grantaccess assert true impliesedgeonc pre grantexit ffl train leaves b train leaves b either c assert impliesedgenot onaonb assert impliesedgenot onb ona onc example experience show specifying environment behavior program requires important efforts work undoubtly adds complexity verification task however giving precise specification assumptions made environment behavior certainly useful task designing critical system moreover notice assumptions dynamically checked execution program compiler option produces corresponding code used also testing phase choosing valid testcases 7 program verification consider verification problem given program pi property p expressed boolean expression b must invariantly true assumptions expressed assertion build new program pi 0 putting together pi computation b assertion assert considering result b output pi 0 see fig 4 problem thus reduces proving boolean output pi 0 always true execution program permanently satisfies assertion assert assert ok figure 4 building verification program verification performed finite state abstraction program numerical computation deliberately ignored boolean expressions depending numerical variables eg comparisons considered non deterministic however assertions used restrict non determinism instance tests conditions xy yz xz appear program assertion impliesxy yz xz prevent prover consider absurd cases corresponding xyz xz consider purely boolean non deterministic program pi 00 approximates pi 0 sense behaviors execution trace pi 0 also execution trace pi 00 therefore output pi 00 always true output pi 0 notice property depends values numerical variables tool may fail proving since pi 00 contains boolean variables represents finite state machine verification problem decidable proving output always true amounts enumerate finite set states checking state belonging path starting initial state assertions always true input vector output evaluates true two verification engines implemented integrated verification tool called ffl first one explicitly enumerates reachable states done standard model check ers 12 27 main limitation approach obviously number states considered present version tool deals programs 1000000 states reasonable time less 1 hour ffl second engine proceeds symbolically starting boolean formula f 0 characterizing set states output true lustre formula expression property iteratively computes sequence f 1 characterizes set states belonging f necessarily leading one execution step f soon initial state doesnt satisfy f one conclude property satisfied since exists execution path leading state output false otherwise since state space finite sequence formulas converges finite number steps formula f characterizes set states possible reach state violating property tool performs computations formulas using binary decision diagrams bdds 9 compact canonical encoding boolean formulas approach sometimes called symbolic model checking 10 14 15 two approaches complementary cases enumerative method cheaper symbolic one conversely main limitation enumerative method number reachable states must considered whereas symbolic method limited complexity boolean formulas size bdds encoding complexity node ums verifon aon bon c ack aback bc bool returnsproperty bool var grant accessgrant exit bool abdo bc bool collisionexclusive req bool derail abno derail bc bool empty section b bool let empty section noton b c b b noton c assert notack ab ack bc assert always toack aback abdo bc always toack bcack bcdo ab assert empty section true assert true impliesedgenot empty section pre grant access assert true impliesedgeon c pre grant exit assert impliesedgenot aon b assert impliesedgenot b c grant accessgrant exitdo abdo umson aon bon cack aback bc exclusive bc derail always toack ab grant access b derail always toack bc grant exit empty section collision exclusive req derail ab derail bc tel figure 5 verification program boolean formula related number states characterizes formula true represent billions states program provided lesar dealing example listed fig 5 times sec sun4 needed proving properties separately globally using method gathered table property states enum symb collision 27 07 03 exclusive req 27 07 04 derail ab 37 10 05 derail property 54 12 13 course example simple results hardly meaningful however treated significant programs particular experience driven 17 deals real nuclear plant control system critical properties required system expressed safety properties verified using lesar spite fact example involves lot realvalued variables matter fact variables appeared properties means threshold comparisons handled using assertions 8 modular verification fact program properties expressed language together assertion mechanism provide also method modular verification informally given program pi compound n subprograms pi proved satisfy safety property p one prove pi satisfies safety property p proving combination p implies p formally note pi fact program pi satisfies safety property p jj denotes parallel composition done lustre following way let pi program using node pi 0 fig 6a assume pi 0 proved satisfy property p 0 expressed invariance b figure modular verification figure 7 full subway track boolean expression b proving pi satisfies property p one consider pi part environment pi replacing assertion b always true fig 6b formally note 2b property b always true course property p 0 must found intuition may weak allow proof p decomposition may drastically reduce complexity verification instance proved properties ums system could used verifying control whole subway track fig 7 informally let linear trackx lustre program controlling single track x umsxy controller ums input track x output track structure whole program would linear tracka jj ums ac jj linear trackc jj ums ca instead considering whole program one could try verify following hopefully simpler one bxy denotes boolean expression proved invariantly true program umsxy moreover approach extended 19 allow inductive verification regular networks identical processes modular verification also allows verification partially developed programs using approach slightly different way verify properties program pi writing subprogram pi 0 using specification pi 0 9 conclusion future work tried highlight advantages using synchronous dataflow language designing realtime program advantages twofold one hand language meets traditional tools used field hand since viewed executable temporal logic allows expression specifications smooth merging programs properties synchronous hypothesis relegates realtime problems evaluation program reaction time hypothesis program modeled standard transition systems consequence approach program verification quite standard even rather restricted since deals checking safety properties finite state program abstractions restrictions introduced order tackle reallife problems argued meet many practical cases notice contrast many verification tools deal models programs tools apply directly programs thus meeting g berrys wypiwye principle 4 prove execute manual transformation program verified code executed course programming verification rely synchronous hypothesis hypothesis must checked fine results valid however checking consists evaluating maximum execution time linear pieces code reactions therefore easy work pursued least two directions ffl restriction boolean abstractions strong limitation dealing properties bounded integers would certainly worthwhile particular integer variables often used lustre count delays tools aware delay 3 seconds shorter one 10 seconds recent works timed graph analysis 1 16 could adapted ffl lot work remains done around modular verification program synthesis approach proposed x8 specification subprogram must provided intuition would appealing synthesize automatically specification using verification tool assume program pi calling subprogram pi 0 required satisfy property p ie invariance boolean expression b first remove pi 0 pi considering unknown part pis environment resulting program satisfies p pi 0 nothing p otherwise symbolic verifier exhibits formula f characterizes set states program b false role pi 0 avoid states idea extract f specification pi 0 moreover since approach specifications programs one wonder possible synthesize pi 0 specification r model checking realtime systems lucid dataflow programming language synchronous approach reactive realtime systems real time programming special purpose general purpose languages synchronous programming reactive systems esterel synchronous programming language design verification safety properties esterel language symbolic model check ing 10 20 states beyond lustre declarative language programming synchronous systems automatic verification finitestate concurrent systems using temporal logic specifications language compositional specification verification finite state hardware controllers verification synchronous sequential machines based symbolic execution verifying temporal properties sequential machines without building state diagrams timing assumptions verification finite state concurrent systems verification de proprietes de programmes flots de donnees synchrones synchronous dataflow programming language lustre experience proving regular networks processes modular model checking generating efficient code dataflow pro grams visual approach complex systems limits possibilities automated protocols analysis semantics simple language parallel programming programming real time applications signal glory past automated verification timed transition systems specification verification concurrent systems cesar programming verifying critical systems means synchronous dataflow programming language lustre verification xesar sliding window protocol tr lucid dataflow programming language automatic verification finitestate concurrent systems using temporal logic specifications graphbased algorithms boolean function manipulation statecharts visual formalism complex systems lustre declarative language realtime programming synchronous programming reactive systems introduction esterel timing assumptions verification finitestate concurrent systems verification synchronous sequential machines based symbolic execution programming verifying critical systems means synchronous dataflow language lustre limits possibilities automated protocol analysis verification xesar sliding window protocol automated verification timed transition models specification verification concurrent systems cesar verifying temporal properties sequential machines without building state diagrams glory past ctr bruno dausbourg synthtiser iintention dun pilote pour dfinir de nouveaux quipements de bord proceedings 14th frenchspeaking conference humancomputer interaction confrence francophone sur linteraction hommemachine p145152 november 2629 2002 poitiers france paul amblard fabienne lagnier michel levy introduction formal processor verification logic level case study proceedings 2004 workshop computer architecture education held conjunction 31st international symposium computer architecture june 19 2004 munich germany vered gafni robots realtime systems architectural style acm sigsoft software engineering notes v24 n6 p5774 nov 1999 dominique lher philippe le parc lionel marc proving sequential function chart programs using timed automata theoretical computer science v267 n12 p141155 09262001 abdesselam lakehal ioannis parissis automated measure structural coverage lustre programs case study proceedings second international workshop automation software test p12 may 2026 2007 tarvo raudvere ingo sander axel jantsch synchronization algorithm local temporal refinements perfectly synchronous models nested feedback loops proceedings 17th great lakes symposium great lakes symposium vlsi march 1113 2007 stresalago maggiore italy aitameur g bel f boniol pairault v wiels robustness analysis avionics embedded systems acm sigplan notices v38 n7 july tarvo raudvere ingo sander ashish kumar singh axel jantsch verification design decisions forsyde proceedings 1st ieeeacmifip international conference hardwaresoftware codesign system synthesis october 0103 2003 newport beach ca usa ioannis parissis farid ouabdesselam specificationbased testing synchronous software acm sigsoft software engineering notes v21 n6 p127134 nov 1996 florence maraninchi yann rmond modeautomata new domainspecific construct development safe critical systems science computer programming v46 n3 p219254 march k altisen f maraninchi stauch aspectoriented programming reactive systems larissa proposal synchronous framework science computer programming v63 n3 p297320 15 december 2006 ralph jeffords constance l heitmeyer strategy efficiently verifying requirements acm sigsoft software engineering notes v28 n5 september axel poign matthew morley olivier maffes leszek holenderski reinhard budde synchronous approach designing reactive systems formal methods system design v12 n2 p163187 march 1 1998 hahnsang kim thierry turletti amar bouali epspectra formal toolkit developing dsp software applications theory practice logic programming v6 n4 p451481 july 2006 bruno dausbourg christel seguin guy durrieu pierre roch helping automated validation process user interfaces systems proceedings 20th international conference software engineering p219228 april 1925 1998 kyoto japan ludovic samper florence maraninchi laurent mounier louis mandel glonemo global accurate formal models analysis adhoc sensor networks proceedings first international conference integrated internet ad hoc sensor networks may 3031 2006 nice france mary sheeran gunnar stlmarck tutorial stlmarcks proof procedure propositionallogic formal methods system design v16 n1 p2358 jan 12000 angelo gargantini angelo morzenti automated deductive requirements analysis critical systems acm transactions software engineering methodology tosem v10 n3 p255307 july 2001 paul caspi alain girault daniel pilaud automatic distribution reactive systems asynchronous networks processors ieee transactions software engineering v25 n3 p416427 may 1999 u buy r h sloan automatic realtime analysis reactive systems parts toolset automated software engineering v8 n34 p227273 august 2001 alberto coenporisini carlo ghezzi richard kemmerer specification realtime systems using astral ieee transactions software engineering v23 n9 p572598 september 1997
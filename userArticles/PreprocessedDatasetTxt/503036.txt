checking inference via driving dag grammars abramov glck recently introduced technique called ura inverting first order functional programs given desired output value ura computes potentially infinite sequence substitutionsrestrictions corresponding relevant input values cases process terminatein present paper propose new program analysis inverting programs technique works computing finite grammar describing set input relate given output production grammar original program implicitly transformed using socalled driving steps whereas ura sound complete sometimes fails terminate technique always terminates complete sound example demonstrate derive type inference type checkingthe idea approximating functional programs grammars new instance second author developed technique using tree grammars approximate termination behaviour deforestation however present purposes necessary invent new type grammar extends tree grammars permitting notion sharing productions dag grammars seem independent interest b introduction programtransformation techniques collectively called supercompilation shown eectively handle problems partial evaluation deforestation cannot han dle apparent strength supercompilation stems driving object programs speculatively unfolding expressions containing variables based possible executions described program example driving consider haskelllike program convention main denition serves interface program possible execute program variables v vs main v vs drive program resulting process tree describing possible computations program program one possible process tree append cons v vs nil cons v append vs nil append vs nil let u append nil nil vsnil append cons x xs nil vscons x xs cons v u 1 general process tree constructed follows root process tree labelled righthand side main denition new leaves added tree repeatedly inspecting label leaf either 1 unfolding outermost call 2 instantiating variable hinders unfolding 3 generalising creating two disjoint labels whenever label leaf identical label ancestor renaming variables leaf unfolded 9 9 k new slightly ecient program easily extracted process tree namely main interest paper transform checker description input satisfy checker given program answers true false transform program description input checker answers true activity generally known program inversion description satisfying input yet another program however nontrivial task perform program inversion following example shows example 1 consider program checks whether two lists identical auxiliary functions isnil iscons needed allow pattern matching one argument time reason restriction associates every pattern match particular function denition result inverting program wrt true another program produces pairs identical lists however unreasonable assume produce program even though easy imagine program produces innite stream pairs lists identical spines elements come based type elements could enumerated enumeration clearly leads nontermination general case worse still imagined program per se give us good description input set merely get indication input set running observing everincreasing output instead inverting program one might perform computation backwards general method perform inverse computation proposed abramov gluck 1 namely universal resolving algorithm ura ura constructs process tree object program produces process tree potentially innite set constraints uninstantiated input variables xs ys example constraint describes set input values means substitutionrestriction pair produced constraints pairwise disjoint sense sets describe pairwise disjoint variables appear several times constraint indicating identical values example ura would produce something like xs 7 nil ys 7 nil xs 7 cons x1 nil ys 7 cons x1 nil xs 7 cons x1 cons x2 nil ys 7 cons x1 cons x2 nil 2 ura would never terminate merit ura sound complete terminates result precisely captures input set paper sacrice soundness develop approach always produces nite description satisfying input 12 overview section 2 present formalisation certain kind contextfree grammars namely dag grammars instance checker described grammar nil nil cons x cons grammar consists two productions formed acyclic directed graph also known dag rst says rewritten dag consisting two single nodes labelled nil second says rewritten complex dag two roots two productions viewed nite representation 2 dag grammars precisely express data control ow program something possible standard tree grammars section 4 present automatic method extract dag grammar program conceptually extraction works two steps first drive object program produce process tree second extract grammar process tree precursor driving program precise formulation semantics programming language present section 3 extracted dag grammars approximations input set section 6 consider various ways improve precision method application section 5 show given type checker term possible derive type scheme term 2 dag grammars denote fs0 set containing s0 g binary relation denote domain set deterministic binary relations ie partial functions denoted partial functions g denote set bijections denition 1 given set graph g consists label function lab 2 n connectedby relation means node kth successor node j js th predecessor relation satisfy properties label node successors predecessors numbered consecutively 0 formally order successors predecessors immaterial simply use binary relation write j whenever 9k 2 n k j following use subscripts like lab g g otherwise obvious graph refer denote transitive closure general superscript binary relation denote transitive closure superscript denote exive closure denition 2 graph g dag contains cycles ie 2 n dags natural talk roots leaves roots g g leaves g g j two dags e equivalent denoted e e transformed one another renumbering nodes set dags denoted ds example 2 two structures 3 depicts equivalence class dags fs nil cons xg sense structure describes family equivalent dags node set n left unspecied order successors predecessors however specied adopting convention heads tails arcs ordered left right concretisation right dag example leaves f3 4g roots f0g denition 3 given set dag grammar set nite dags set dag grammars denoted g example 3 two dags 3 comprise dag grammar fs x nil consg dag grammar describes dag language every dag generated number rewrites initial dag give formal denition rewrites languages example order example 4 dag rewritten dag grammar 3 nil nil cons x cons cons x nil cons cons x cons x cons cons symbol used maintain order otherwise unordered set roots nd formal denition graph grammar rewrites example hopefully illustrates rewrites work informally dag rewritten leaf node matches root node j dag graph grammar matches mean j label number predecessors matches number successors j result rewrite leaf root j dissolve predecessors become predecessors successors j right order illustrated below6 6k1 kn 6 6 6k1 kn denitions generalise notion rewriting several leaves need generality section 4 denition 4 denote p set nite sequences set sequences tuples denoted angles h denition 5 given dags e dene match ng lab maxmatch denition 6 given sets disjoint write case disjoint union dened undened otherwise given relation set 0 dene removal 0 ns 0 disjoint union two binary relations dened domains disjoint following carefully pay attention exact set nodes n particular dag comprises avoid node clashes rewrite graphs use fact given nite dag g 0 innitely many equivalent dags g denition 7 given dag grammar 2 g one steprewrite relation dened 9 hi ji 2 maxmatch g6 6 6 denition 8 given dag grammar initial dag dag language li set normal forms li grammar framework readily express sets input next step show dag grammar extracted program start dening semantics object language top semantics build machinery calculates desired grammars 3 object language object language rstorder functional language pattern matching operators term equality boolean denition 9 given set variables x function names f patternfunction names g constructors c including constants true false dene g usual require variable occurs lefthand side function denition leftlinear variables righthand side function definition subset lefthand side closed finally require patterns dened gfunction pairwise distinct modulo variable names non overlapping particular gfunction one catchall pattern concrete programs use haskelllike syntax including datatype denitions syntax viewed intermediate language obtained type checking rules terms like nil nil nil true denition 10 given term denote v variables collected left right term example 5 triple x denition 11 function 2 x regarded substitution usual way 2 write result substitution given program p writing say g c means p function denition identical variable naming give normalorder semantics object language dening smallstep relation takes redexes contracta separate redexes contexts following syntactic classes true figure 1 normalorder semantics denition 12 e 3 dt denote result replacing term ground term either value uniquely decomposed context redex ie decomposition property allows us dene semantics semantics imposes lefttoright evaluation except equality operator evaluates arguments two outermost constructors compared denition 13 given program p smallstep semantics p dened smallest relation rt closed terms dened fig 1 following use subscripts like p otherwise obvious program refer get full semantics language simply need close relation contexts semantics deterministic lemma 1 proof sketch induction case analysis syntactic structure terms term either cannot decomposed context redex uniquely decomposed case redex one smallstep derivation 4 explicitation previous section aloows us deal execution ground terms able drive program however need handle terms containing variables use following syntactic class combination previously dened ones describe terms cannot decomposed contexts redexes denition 14 variables letterm v let use letterms described previous section obtain uniquedecomposition property term either value uniquely decomposed context redex uniquely decomposed context speculative ie ds extra syntactic class enables us identify terms need driven ie instantiated supercompilation driving used obtain process tree object program process tree serves two orthogonal purposes keeps track data control ow essentially variable instantiations recursive calls provides convenient way monitor driving process perform generalisations needed ensure nite process tree generalisation needed replaced term let point making generalisation able treat t1 t2 independently exam ple might want revisit 1 introduction thorough introduction techniques see srensen gluck 13 approach program inversion called explicitation assume generalisations necessary ensure termination computed advance oline generalisation analysis specic assume terms replaced terms form let t1 t2 program interest respect data control ow program ow expressed dag grammars elaborate later section since thus eliminated need process tree keep things simple drive object program without constructing actual process tree construction process tree although important practice essence approach remark 1 note existence oline generalisation analysis essential explicitation process described following could incorporate wellknown nontermination detection perform necessary generalisations 1 incorporation would induce unnecessary clutter presentation concentrate description extract dag grammar driving birdseye view explicitation process single branch speculative execution works follows starting main term object program dag grammar gradually built driving term time speculative cf def 14 hinders normal reduction perform instantiation term dag gram mar reduction term proceed ects structure input variables fact driving step term results new production grammar every term meet driving program production meet term seen loop introduced grammar driving term stops term cannot driven compared output desired namely nonfalse output false result empty grammar otherwise accumulated grammar general parameterise explicitation process discrimination function h purpose fashion produce grammar every speculative execution program possible instantiation term gives rise slightly dierent term grammar nal grammar union grammars produced executions example instantiation dag grammar consider dags xs ys 6 6 6xs ys cons iscons ys x xs7 7 xs ys cons iscons ys x xs7 represents call arguments un known e represents body pattern match variable xs call iscons three arguments cf example 1 order arrows important since presented method preventing nontermination performing generalisations dangerous terms based certain quasiorders extensions method applied lan guage prove extended method indeed guarantee termination explicitation apply general framework proving termination program transformers presented second author 14 denes data ow view feg dag grammar rewritten 0 means feg shown formally denition 15 given dags e dag substitution fegd dened cf def 5 otherwise substitutions extended grammars obvious way construct dags terms use following shorthands denition 16 given term full explicitation process explained detail low formally summed following denition denition 17 given program p function h 2 explicitation p dag grammar eh p described fig 2 following explanation explicitation process carries number references hopefully guide understanding fig 2 explicitation starts main term program empty dag grammar empty set previously seen terms step inspect structure current term either stop add production make new step added seenbefore set seen production already present grammar return accumulated unchanged renaming seen captured bijection introduce recursion grammar adding production connects pre viously seen respecting number variables redex unfolded using standard semantics cf defs 12 13 production linking unfolding added process continues unfolding generalised term hinders unfolding t1 t2 dt 2 t1 processed independently fore production added grammar linked dt 2 t1 production dangling roots 2 namely x v t1 v t2 ect data ow approximated traces t1 tell us nothing output function h cf 4 unmatched roots allowed dag rewrites cf def 7 eh let ftg tthen c ac r x ac x c x true x false figure 2 explicitation driving supposed discriminate various output replaced function xyy discriminate always returns accumulated grammar pattern matching function process continued dened patterns pattern q substitute arguments matching body put back context turn receives instantiation fx 7 qg add grammar production ecting instantiation comparisons three cases rst simply makes sure variables left side com parison settled righthand side another variable two possibilities explored either comparison fail hence replace speculative false comparison succeed replace speculative true update grammar context ect sides must identical grammar equal variables coalesced means special symbol r needed maintain invariant inout degree terms correspond number distinct variables righthand side nary constructor either comparison fail succeed case propagate variable must particular outermost constructor children must tested equality children constructor boolean expression depends variable variable evaluate either true false information propagated branch terms cannot driven ie 2 v fed function h turn decides accumulated grammar example 6 let p program example 1 h dened 4 explicitation eh depicted fig 3 grammar produced fa b f jg derived grammars suboptimal productions intermediate sense directly unfolded inlined say grammar normalised contains intermediate productions easily normalise grammar denition 18 dag grammar normalised denoted b follows roots g leaves g example 7 normalise grammar example 6 almost get grammar promised introduction4 xs ys xs ys cons cons r xs ys particular grammar bookkeeping symbol r eliminated yet another normalisation process desired given object program contains necessary gen eralisations lemma surprising however incorporated standard online termination strategy explication process explained remark 1 following lemma would still hold lemma 2 explicitation produces nite grammar proof process tree program nite since program contains necessary generalisations thus nite number dags produced assuming h function total computable interestingly explicitation returns dag grammar contains solutions express completeness theorem need precise formulation set terms generated dag grammar given infor mally term extracted dag simply following edges left right collecting labels except label variable bookkeeping symbol r every variable given distinct name r treated indirection left term denition 19 given dag grammar label arity n set variables g term language n set tuples terms extracted underlying dag language 4 0 s5 fhi 0 0 relate possible executions program set terms generated explicitation eh xs ys fsame xs ysg eh fsame xs ys isnil ysg eh fsame xs ys isnil ysg eh iscons ys x xs fsame xs ysg eh fsame xs ys iscons ys x xsg fsame xs ys iscons ys x xsg fif xy xs ys falseg fif xy xs ys false false xs ys fif xy xs ys falseg fsame xs ys 6 6same xs ys nil 6 6isnil ys cons iscons ys x xs nil x xs7g 2 xs ysfalse x false xs ysfalse7 7 xs ysfalse r x true xs ys isnil ys xs ys cons iscons ys x xs7 7 75 26 6 6 6 6iscons ys x xs cons 6 6if false xs ys xs ys7 6 6if true xs ys xs ys7 figure 3 explicitation sameprogram theorem 1 given program p main holds 5 application type inference show type checking algorithm transformed type inference algorithm explicitation specif ically check calculus expression given type given environment using standard relation example consider expression meaning type xyzxzyz empty environment would expect answer something like perform explicitation expression type checker takes encoding proof tree p expression environment returns true p indeed valid proof type encoding 3 xyzxzyz becomes becomes empty want explicitate expression add denition main implementation type checker refer specialised typechecker data 3 abs int term 4 data 5 data proof infer premise type 6 data 7 intro proof 9 expchk var x z match z x 14 elimchk elim x z v w 3 implementation assumes primitive integer type int 19 arrowcheck v x z w match bind x z v 22 v x w match z v w match x arrowcheck ar x z v w 26 conclusion z 28 conclusion infer x 29 false x explicitation specialised typechecker gives term language consists single pair ar ar x ar z ar ar x ar x z rst element indeed encoding type 5 second proof tree left 6 improving soundness automatic method inversion turingcomplete programs make compromise respect com pleteness soundness termination made compromise result possibly unsound results explicitation program produce grammar generates many terms practical point view feel right compromise better obtain approximation obtaining answer moreover explicitation produce grammars precisely identies input set seen two examples previous sections indicates explicitation tight enough least practical problems however still remains identify exactly causes loss soundness general case method inherently imprecise three reasons generalisations cause terms split separate parts means letterms prevents instantiations left branch process tree aect right branch vice versa negative information taken account driving example driving speculative term x propagate fact x 6 right branch process tree although fact propagated left branch means substitution moreover dag grammars cannot represent negative information occur check performed speculative terms like situations n discovered obviously equality would never imply similarly symmetric property x x never implies x 6 x used either occur check counterpart easily incorporated rules respectively fig 2 interest ingly explicitation type checker specialised would sound checks incorporated negative information described handle propagate information another paper 11 incorporating negative information proposed paper would simple task incorporating negative information dag grammars however would destroy simplicity thus severely cripple usability hence generalisation inability dag grammars represent negative information true culprits one could therefore imagine variant explicitation algorithm lets call exp one incorporated extensions suggested improve soundness exp one target way generalisations carried position conjecture following roundabout relationship exp ura 1 described introduction given program p without generalisa tions exp terminates p whenever ura terminates p moreover result ura contains restrictions neg ative information resulting grammar exp sound 7 related work program inversion literature program inversion carried hand one exception romanenko 9 describes pseudo algorithm inverting small class programs written refal later paper romanenko 10 extends refal language nondeterministic construct akin seen logic programming facilitate exhaustive search also considers inverting program respect subset parameters socalled partial inversion would like extend method handle partial inversion writing unclear done fully automated program inversion method know one presented abramov gluck 1 method constructs process tree object pro gram solutions extracted leaves tree form substitutionrestriction pairs process trees perfect gluck klimov 3 sense information lost branch completeness every branching node divides information disjoint sets soundness unfortunately soundness together completeness implies nontermination small class programs method presented sacrices soundness termination common methods build upon ground breaking work turchin coworkers rst english paper contains examples program inversion driving seems 15 references see srensen gluck 4 grammars idea approximating functional programs grammars new instance jones 5 presents ow analysis nonstrict languages means tree gram mars based work second author developed technique using tree grammars approximate termination behaviour deforestation 12 tree grammars ever cannot capture precise data control ow denition branches tree grammar developed inde pendent renders impossible kind synchronisation need variable function calls dag grammars presented precisely capture data control ow single speculative computation trace synchronisation lost several alternative recursive productions exist grammar seems possible devise precise ow analysis based dag grammars could used along lines 12 indeed way use dag grammars trace data control ow turns striking similarities use sizechange graphs presented lee jones ben amram 7 sizechange graphs approximate data ow one function another capturing sizechanges parameters dagrewrite mechanism presented turns lot common faninfanout rewrites presented lamping 6 quest optimal reduction calculus faninfanouts represent complex way synchronising dierent parts graph whereas dag rewrites perform simple useonce synchroni sation rewriting mechanism also akin graph substitution hypergraph grammars see bauderon courcelle 2 noncategorytheory formulation except allow number leaves rewritten allow inner nodes rewritten strengthwise hypergraph grammars apparently equivalent attribute grammars present sure generative power dag grammars 8 conclusion future work developed method inverting given program respect given output result inversion nite dag grammar gives complete description input running dag grammar produces possibly innite set terms contain tuples terms result given output method seems particularly useful object program checker one returns either true false exemplied deriving type scheme type checker given term thus eectively synthesising type inference algorithm following line one could imagine program checks whether document valid xml inverting program would result dag grammar could compared speci cation valid xml means verifying program inverting program specialised particular doc ument would result document type denition one could even imagine inverting proofcarryingcode verier 8 respect particular program thus obtaining proof skeleton correctness code experiments kinds applications carried establish strength usability method 9 r graph expressions graph rewritings flow analysis lazy higherorder functional programs algorithm optimal lambda calculus reduction sizechange principle program termination compiling proofs generation inverse functions refal inversion metacomputation de tr algorithm optimal lambda calculus reduction inversion metacomputation convergence program transformers metric space trees sizechange principle program termination introduction supercompilation perfect supercompilation occams razor metacompuation roadmap metacomputation supercompilation semantic definitions refal automatic production compilers universal resolving algorithm grammarbased dataflow analysis stop deforestation compiling proofs ctr siaucheng khoo kun shi outputconstraint specialization proceedings asian symposium partial evaluation semanticsbased program manipulation p106116 september 1214 2002 aizu japan aaron tomb cormac flanagan automatic type inference via partial evaluation proceedings 7th acm sigplan international conference principles practice declarative programming p106116 july 1113 2005 lisbon portugal siaucheng khoo kun shi program adaptation via outputconstraint specialization higherorder symbolic computation v17 n12 p93128 marchjune 2004 morten heine srensen jens peter secher type inference configuration essence computation complexity analysis transformation springerverlag new york inc new york ny 2002 principles inverse computation universal resolving algorithm essence computation complexity analysis transformation springerverlag new york inc new york ny 2002
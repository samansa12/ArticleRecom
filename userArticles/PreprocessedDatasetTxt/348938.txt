simplifying failureinducing input given test case program fails part test case responsible particular failure show delta debugging algorithm generalizes simplifies failing input minimal test case produces failurein case study mozilla web browser crashed 95 user actions prototype implementation automatically simplified input 3 relevant user actions likewise simplified 896lines html single line caused failure case study required 139 automated test runs 35 minutes 500 mhz pc b introduction often people encounter bug spend lot time investigating changes input file make bug go away changes affect richard stallman using porting gnu cc mozilla engineers faced imminent doom july 1999 370 open bug reports stored bug data base ready simplified simplifying meant turning bug reports minimal test cases every part input would significant reproducing failure overwhelmed work engineers sent mozilla bugathon call volunteers would help process bug reports 5 bug reports simpli fied volunteer would rewarded invitation launch would earn tshirt signed grateful engineers 9 decomposing specific bug reports simple test cases trouble engineers mozilla netscapes open source web browser project 8 problem arises generally conflicting issues bug report must specific possible engineer recreate context program failed hand test case must simple possible minimal test case implies general context thus minimal test case allows short problem descriptions valuable problem insights also subsumes several current future bug reports striking thing test case simplification one far thought automate task several textbooks guides debugging available tell use binary search order isolate problembased assumption test carried manually automated test however also automate test case simplification describe paper delta debugging algorithm ddmin fed test case simplifies successive testing ddmin stops minimal test case reached removing single input entity would cause failure disappear general ddmin requires time 2 given input n en tities wellstructured input leads better performance best case single input entity causes failure ddmin requires logarithmic time find entity ddmin tailored languagespecific knowledge begin discussion problem basic ddmin algorithm using number reallife failures show ddmin algorithm detects failureinducing input test case isolated simplified close discussions related future work 2 configurations tests ian hickson stayed 540 simplified bugs first night bugathon mozilla bugathon call let us begin basic definitions first minimal test case mean every program smallest possible input induces welldefined behavior qualify failure typically empty input something close examples c compiler accepts empty translation unit empty c file smallest possible input given empty input www browser supposed produce defined error message given empty input file l e x typesetting system supposed produce error message noted smallest possible input necessarily smallest valid input even invalid input possible long program fail let us view failureinducing input c result applying number changes 1 2 n minimal possible input way gradual transition minimal possible input changes applied c changes applied deliberately give formal definition change general stand change circumstances influences execution program previous work instance modeled changes program code 15 paper search failureinducing circumstances program input hence change operation applied input important thing applying changes results failureinducing set c case studies presented paper always chosen changes lexical decomposition failureinducing input stands lexical entity present change applied change applied ex ample consider minimal possible input empty failureinducing input consisting n lines text change would add th line empty input applying changes results full set lines modeling changes lexical decomposition easiest approach model easily extend notions changes still treating changes given entities let us formally define tests test cases describe test case minimal possible input c configuration changes test case let set changes change set c c called test case 1 test case constructed applying changes minimal possible input possible input empty test case called minimal possible input impose constraints changes may com bined particular assume changes ordered worst case 2 n possible test cases n changes determine whether test case induces failure assume testing function according posix 10033 standard testing frameworks 5 distinguish three outcomes 1 definitions section adapted previous work 15 see section 8 discussion test succeeds pass written test produced failure intended capture test produced indeterminate results unresolved written 2 definition 3 test function test 8 4 determines test case c c whether given failure occurs 8 4 whether test unresolved practice test would construct test case applying given changes minimal possible input feed test case program return outcome let us model initial scenario minimal possible input works fine test case fails axiom 4 failing test case following holds failing test case goal simplify failing test case cthat minimize test case c minimal means subset c causes test fail formally definition 5 minimal test case test case c c minimal holds want minimizing test case c parts significant producing failurenothing removed without making failure disappear 3 minimality test cases simplified test case means simplest possible web page still reproduces bug remove characters file simplified test case longer see bug mozilla bugathon call one actually determine minimal test case comes bad news let test case c consisting c changes characters lines functions inserted minimal input relying test alone determine minimality requires testing 2 c 1 true subsets c obviously exponential complexity 3 determine however approximationfor stance test case every part still significant producing failure check whether removing several parts might make test case even smaller mally define property 1minimality nminimality defined lists untested unsupported outcomes relevance 3 precise axiom 4 tells us result test subsets need tested help much minimizing debugging algorithm minimizing delta debugging algorithm ddminc reduce subset reduce complement c otherwise done c c pairwise disjoint c c cn well recursion invariant thus precondition ddmin 2 figure 1 minimizing delta debugging algorithm definition 6 nminimal test case test case c c nminimal holds failing test case c composed c lines would thus 1minimal removing single line would cause failure disappear likewise would 3minimal removing combination three less lines would make work c cminimal c minimal sense definition 5 definition 6 gives first idea aiming ever given say 100000 line test case cannot simply remove individual line order minimize thus need effective algorithm reduce test case efficiently 4 minimizing algorithm proceed binary search throw away half input see output still wrong go back previous state discard half input brian kernighan rob pike practice programming humans order minimize test cases use binary search c contains one change c minimal definition otherwise partition c two subsets c 1 c 2 similar size test gives us three possible outcomes reduce c 1 test c 1 failsc 1 smaller test case reduce c 2 test c 2 failsc 2 smaller test case ignorance tests pass unresolvedneither c 1 c 2 qualify possible simplifications first two cases simply continue search failing subset illustrated table 1 line diagram shows configuration number stands included change dot stands excluded change change 7 minimal failing test caseand isolated steps given sufficient knowledge nature input certainly partition test case two subsets least one fails test knowledge insufficient present let us begin worst case splitting c subsets tests pass unresolvedignorance complete know c whole failing increase chances getting failing subset testing larger subsets c increase chances test failsthe difference c smaller hand smaller difference means slower progressionthe test case halved reduced smaller amount testing smaller subsets c get faster progression case test fails hand chances test fails smaller specific methods combined partitioning c larger number subsets testing small c well large complement c subset contains one change gives us best chance get failing test case disad vantage course subsets means testing happen let n number subsets c 1 c n testing c complement possible outcomes figure 1 reduce subset testing c fails c smaller test case continue reducing c subsets configuration test 7 table 1 quick minimization test cases configuration test testing c 1 c 2 increase granularity testing c 1 c 4 testing complements reduce test carried earlier step testing complements reduce increase granularity testing c 1 c 4 c 1 2 7 8 testing complements reduce 22 c 1 1 testing c 1 c 3 testing complements 26 table 2 minimizing test case increasing granularity reduction rule results classical divide conquer approach one identify smaller part test case failureinducing rule helps narrowing test case efficiently reduce complement testing c smaller test case continue reducing continue n 1 two subsets splitting subsets means subsets c identical subsets c cin words every subset c eventually gets tested continued two subsets say would work way would next subset c tested increase granularity otherwise test failed try 2n subsets 2n c hold try c subsets instead containing one change results twice many tests increases chances failure process repeated granularity longer increased next n would larger c case already tried removing every single change individually without failures resulting change set minimal example consider table 2 minimal test case consists changes 1 7 8 test case includes subset changes results unresolved test outcome test case includes none changes passes test begin partitioning total set changes two halves none passes test continue granularity increased 4 subsets step 36 testing complements set removing changes 3 4 continue splitting c 2 three subsets next three tests steps 911 already carried need repeated marked testing eliminated increase granularity 4 subsets test steps 1619 last complement eliminates change 2 changes 1 7 8 remain steps 2527 show none changes eliminated minimize test case total 19 different tests required close formal properties ddmin first ddmin eventually returns 1minimal test case proposition 7 ddmin minimizes c c ddminc 1 minimal sense definition 6 proof according ddmin definition figure 1 ddminc returns c n c test subsets c c c c c n test condition definition 6 applies c 1minimal worst case ddmin takes 3c proposition 8 ddmin complexity worst case number tests carried ddminc 3c worst case proof worst case divided two phases first every test inconsistent testing last complement results failure holds first phase every test inconsistent results reinvocation ddmin 2 doubled number subsets 1 number tests carried second phase worst case testing last complement c n fails ddmin 2 reinvoked ddmin 2 1 results c 1 calls ddmin two tests per call 2c overall number tests thus 4cc 2 practice however unlikely ncharacter input requires tests divide conquer rule ddmin takes care quickly narrowing failureinducing parts input proposition 9 ddmin complexity best case one failureinducing change c test cases include cause failure well number tests limited proof given conditions must always either c 1 c 2 whose test fail thus overall complexity binary search whether best case efficiency applies depends ability break input smaller chunks result determined better failing test outcomes consequently knowledge structure input better identify possibly failureinducing subsets better overall performance ddmin surprising thing however even knowledge input structure ddmin algorithm sufficient per formanceat least case studies examined illustrated following three sections 5 case study gcc gets fatal signal none us time study large program figure would work compiled correctly much less line compiled wrong richard stallman using porting gnu cc let us turn reallife input c program figure demonstrates particular nasty aspects language also causes gnu c compiler gcc crashat least using version 2952 intellinux optimization enabled crashing gcc grabs available memory stack processes may run resources die 4 latter prevented limiting stack memory available gcc effect remains 4 authors deny liability damage caused repeating experiment define size 20 double multdouble z int n int return zn void copydouble double int count int switch count case 0 case 7 case case 5 case 4 case 3 case 2 case 1 n 0 return multto 2 int mainint argc char argv double xsize ysize double px x return copyy x size figure 2 bugc program crashes gnu cc gcc internal compiler error program cc1 got fatal signal 11 gcc error message resulting core dump help gcc maintainers ordinary users must narrow failureinducing input bugcand minimize bugc order file bug report case gcc minimal test input empty input sake simplicity modeled change insertion single character means change c becomes th character bugc c becomes entire failureinducing input bugc partitioning c means partitioning input parts made exploit syntactic semantic knowledge c programs consequently expected large number input size tests executed tcmin log bugc figure 3 minimizing gcc input bugc test cases invalid c programs minimize bugc implemented ddmin algorithm figure 1 wynot prototype 5 test procedure would create appropriate subset bugc feed gcc return 8 iff gcc crashed 4 otherwise results wynot run shown figure 3 first two tests wynot already reduced input size 755 characters 377 188 characters respectivelythe test case contains mult function reducing mult ever takes time 731 tests 34 seconds 6 get test case minimized 77 characters left tdouble zint nint 0return zn test case 1minimalno single character removed without removing failure even every single superfluous whitespace removed function name shrunk mult single least know neither whitespace function name failureinducing figure 4 shows excerpt bugc test log character indicates omitted character regard minimized put see ddmin algorithm tries remove every single change character order minimize input even every test results syntactically invalid program tdouble zint nint j tdouble zint nint j tdouble zint nint j tdouble zint nint j tdouble zint nint j tdouble zint nint j tdouble zint nint j figure 4 excerpt bugc test log gcc users file minimal bug report gcc failure actually occur already know worked yesterday today 6 times measured linux pc 500 mhz pentium iii processor time given cpu user time wynot prototype measured unix kernel includes spawned child processes gcc run example100 1 options tests executed tcmin log gcc options figure 5 minimizing gcc options failure associated optimization could possible influence optimization way failure disappears gcc documentation lists 31 options used influence optimization linux shown table 3 turns applying options causes failure disappear fnodeferpop fstrictaliasing bugc means options list prevent failure use test case minimization order find preventing op tions time c stands gcc option table 3 since want find option prevents failure test outcome inverted test returns 4 gcc crashes 8 gcc works fine wynot run straightforward divide conquer search shown figure 5 7 tests less second single option ffastmath found prevents failure unfortunately ffastmath option bad candidate working around failure may alter semantics program remove ffastmath list options make another wynot run 7 tests turns option fforceaddr also prevents failure ffloatstore fnodefaultinline fnodeferpop fforcemem fforceaddr fomitframepointer fnoinline finlinefunctions fkeepinlinefunctions fkeepstaticconsts fnofunctioncse ffastmath fstrengthreduce fthreadjumps fcsefollowjumps fcseskipblocks freruncseafterloop frerunloopopt fgcse fexpensiveoptimizations fscheduleinsns ffunctionsections fdatasections fcallersaves funrollloops funrollallloops fmoveallmovables freduceallgivs fnopeephole fstrictaliasing table 3 gcc optimization options input size tests executed tcmin log flex t16 figure minimizing flex fuzz input options prevent failure running gcc remaining 29 options shows failure still seems identified failurepreventing options send gcc maintainers 1 minimal test case 2 failure occurs optimization 3 ffastmath fforceaddr prevent failure still cannot identify place gcc code causes problem hand identified many failure circumstances practice program maintainers easily enhance automated regression test suites failure circumstances automatically simplified failing test case 6 case study minimizing fuzz understand context problem occurs youre likely solve problem completely rather one aspect steve mcconnell code complete classical experiment 6 7 bart miller team examined robustness unix utilities services sending fuzz inputa large number random characters studies showed worst case 40 basic programs crashed went infinite loops fed fuzz input wanted know well ddmin algorithm performs minimizing fuzz input sequences examined subset unix utilities listed millers paper nroff format documents display troff format documents typesetter flex fast lexical analyzer generator crtplot graphics filter various plotters ul underlining filter units convert quantities set 16 different fuzz inputs differing size 10 3 10 6 characters content whether characters printable characters included whether nul characters included shown table 4 millers results still applyat least suns solaris 26 operating system test runs utilities crashed 42 times 431010001000000 5 input size tests executed tcmin log crtplot test t16 figure 7 minimizing crtplot fuzz input applied wynot tool 42 cases minimize failure inducing fuzz input table 5 shows resulting input sizes table 6 lists number tests required 7 depending crash cause programs could partitioned two groups first group programs shows obvious buffer overrun problems flex robust utility crashes sequences 2121 nonnewline nonnul characters ul crashes sequences 516 printable non newline characters 5 8 13 units crashes sequences 77 8bit characters figure 6 shows first 500 tests wynot run flex 16 494 tests remaining size 2122 characters already close final size however takes 10000 tests eliminate one character second group programs appears vulnerable random commands nroff troff crash malformed commands like dj0f 8 8bit input 302n troff crtplot crashes oneletter inputs wynot run crtplot 16 shown figure 7 takes 24 tests minimize fuzz input 10 6 characters single failureinducing character test runs entirely automated allows massive automated stochastic testing programs fed fuzz input order reveal defects soon failure detected input minimization generalize large fuzz input minimal bug report table 6 also includes repeated tests carried earlier steps average number actual nonrepeated tests 30 smaller 8 input shown c string notation test passed 4 8 table 4 test outcomes unix utilities subjected fuzz input name character range printable printable nul characters yes yes table 5 size minimized failureinducing fuzz input 7 case study mozilla cannot print youve cut away much html css javascript cutting away causes bug disappear youre done mozilla bugathon call last case study wanted simplify realworld mozilla test case thus contribute mozilla bugathon search bugzilla mozilla bug database shows us bug 24735 reported anantkyahoocom ok following operations cause mozilla crash consistently machine go bugzillamozillaorg select search bug print file setting bottom right margins 50 use file vartmpnetscapeps done printing exact thing file vartmpnetscapeps causes browser crash segfault case mozilla input consists two items sequence input eventsthat succession mouse motions pressed keys clicked buttonsand html code erroneous www page used xlab capturereplay tool 13 run mozilla capturing user actions logging file could easily reproduce error creating xlab log 711 recorded x events wynot tool would use xlab replay log feed mozilla recorded user actions thus automating mozilla execution first run wanted know whether actions bug report actually necessary thus subjected log test case minimization order find failureinducing minimum user actions 711 x events 95 related user actionsthat moving mouse pointer pressing releasing mouse button pressing releasing key keyboard 95 user actions subjected minimization results run shown figure 9 82 test runs 95 user actions left 1 press p key alt modifier key held invoke print dialog 2 press mouse button 1 print button without modifier arm print button 3 release mouse button 1 start printing user actions removed include moving mouse pointer selecting print file option altering default file name setting print margins 50 releasing p key clicking printall irrelevant producing failure 9 since user actions hardly generalized turn attention another input sourcethe failureinducing html code original search bug page length 39094 characters 896 lines order minimize html code chose hierarchical first run wanted minimize number lines c identified line later run wanted minimize failureinducing lines according single characters 9 relevant though mouse button pressed released table number required test runs101000 number lines tests executed tcmin log queryhtml figure 8 minimizing mozilla html input results lines run shown figure 8 57 test runs ddmin algorithm minimizes original 896 lines 1 line input html input causes mozilla crash printed gcc example section 5 actual failure inducing input small minimization 10 reveals attributes select tag relevant reproducing failure either single input already suffices reproducing failure overall obtain following selfcontained minimized bug report create html page containing load page print using altp print browser crashes segmentation fault long bug reports reproduced minimization procedure easily repeated automatically 5595 bugs listed bugzilla database 11 one needs html input sequence user actions observable failureand little time let computer simplify failureinducing input minimization done hand apologize 11 14 feb 2000 number xevents tests executed tcmin log mn events removed figure 9 minimizing mozilla user actions 8 related work two competing theories make exactly predictions one simpler better stated introduction unaware technique would automatically simplify test cases determine failure inducing input one important exception simplification test cases artificially produced 11 slutz describes stresstest databases generated sql state ments failure produced test cases simplifiedafter failing 1000line sql statement would taken seriously database vendor 3line statement would simplification realized simply undoing earlier production steps testing whether failure still occurred general delta debugging determines circumstances relevant producing failure case parts program put field automated debugging failureinducing circumstances almost exclusively understood failure inducing statements program execution significant method determine statements relevant failure program slicingeither static form obtained program analysis 14 12 dynamic form applied specific run program 1 3 strength analysis several potential failure causes eliminated due lack data control dependency suffice though check whether remaining potential causes relevant producing given failure experiment testing prove circumstance relevantby showing alteration circumstance makes failure disappear comes concrete failures program analysis testing complementary analysis disproves causality testing proves would nice see far systematic testing program analysis could work together whether delta debugging could used determine failureinducing statements well determining parts input relevant producing failure debugging could determine failurerelevant statements program critical slicing 2 related approach testbased like delta debugging additional data flow analysis used eliminate circumstantial positives ddmin algorithm presented paper alternative original delta debugging algorithm dd presented 15 like takes set changes minimizes according given test 15 changes affected program code obtained comparing two program versions main differences ddmin dd dd determines minimal difference failing nonfailing configuration ddmin minimizes difference failing empty configuration dd wellsuited failures induced large combination changes particular dd guarantee 1minimal subset suited minimizing test cases dd assumes monotony whenever holds every subset c well assumption found useful changes program code gave dd better performance tests produced determinate results recommend ddmin general replacement dd exploit monotony ddmin one make testc return 4 whenever superset c already passed test 9 future work get way groupsigned tshirt qualify stuffed animal well 12 mozilla bugathon call future work concentrate following topics domainspecific simplification methods knowledge input structure much enhance performance ddmin algorithm instance valid program inputs frequently described grammars would nice rely grammars order exclude syntactically invalid input right start also formal input descrip tion one could replace input smaller alternate input rather simply cutting away gcc example one could try replace arithmetic expressions constants program blocks noops html input could reduced according html structure rules optimization general abstract description ddmin algorithm leaves lot flexibility actual implementation thus provides hooks several domainspecific optimizations implementation choose partition c subsets c place knowledge structure input comes handy implementation choose subset test first subsets may likely cause failure others implementation choose whether handle multiple independent failureinducing inputs case several subsets c options include continue first failing subset continue smallest failing one simplify individual failing subset implementation currently goes first failing subset thus reports one subset reason economy wiser fix first failure checking similar failures program analysis far treated tested programs black boxes referring source code however several program analysis methods available help relating input specific failure simply tell us parts input related thus changed one run others simple dynamic slice failing test case tell us input actually influenced program input never combination inputcentered executioncentered debugging methods remains explored maximizing passing test cases right ddmin makes distinction passing unresolved tests several settings however distinction may use ful could minimize difference passing failing testnot minimizing failure inducing input also maximizing passing input expect twofolded approach pinpoints failure faster precisely failureinducing circumstances changing input program one means influence execution stated section 2 stand change circumstances influences execution program thus research whether delta debugging applicable failureinducing circumstances executed statements control predicates thread schedules 10 conclusion debugging still matter trial error henry lieberman debugging scandal shown ddmin algorithm simplifies failureinducing input based automated testing procedure method applied number settings finding failure inducing parts program invocation gcc options program input gcc fuzz mozilla input sequence user interactions mozilla user actions recommend automated test case simplification integrated part automated testing time test fails delta debugging could used simplify circumstances fail ure given sufficient testing resources reasonable choice changes influence program execution ddmin algorithm presented paper provides simplification straightforward easy implement practice testing debugging typically come pairs ever debugging research testing played minor role surprising retesting program changed circumstances common debugging approach delta debugging nothing automate process eventually expect several debugging tasks fact stated search minimization problems based automated testingand thus solved automatically details case studies listed paper found 4 information delta debugging including full wynot implementation available httpwwwfmiunipassaudestdd acknowledgements mirko streckenbach provided helpful insights unix internals tom truscott pointed us gcc error holger cleve jens krinke gregor snelting provided valuable comments earlier revisions paper special thanks go anonymous reviewers constructive comments 11 r dynamic program slicing critical slicing software fault localization minimierung fehlerverursachender eingaben empirical study reliability unix utilities fuzz revisted reexamination reliability unix utilities services mozilla web site mozilla web site gecko bugathon massive stochastic testing sql survey program slicing techniques programmers use slices debugging tr dynamic program slicing empirical study reliability unix utilities critical slicing software fault localization foundations software engineering yesterday program worked today efficient relevant slicing method debugging programmers use slices debugging massive stochastic testing sql ctr simon carter malcolm graham paul strooper zhiguo yuan mutation analysis verify feature matrices isolating errors simulation models proceedings twentysixth australasian conference computer science research practice information technology p2934 february 01 2003 adelaide australia zhang neelam gupta rajiv gupta locating faults automated predicate switching proceeding 28th international conference software engineering may 2028 2006 shanghai china zhang haifeng neelam gupta rajiv gupta experimental evaluation using dynamic slices fault location proceedings sixth international symposium automated analysisdriven debugging p3342 september 1921 2005 monterey california usa andy podgurski david leon patrick francis wes masri melinda minch jiayang sun bin wang automated support classifying software failure reports proceedings 25th international conference software engineering may 0310 2003 portland oregon kaihui chang v bertacco l markov simulationbased bug trace minimization bmcbased refinement proceedings 2005 ieeeacm international conference computeraided design p10451051 november 0610 2005 san jose ca zhang neelam gupta rajiv gupta study effectiveness dynamic slicing locating real faults empirical software engineering v12 n2 p143160 april 2007 zhang neelam gupta rajiv gupta pruning dynamic slices confidence acm sigplan notices v41 n6 june 2006 gregg rothermel sebastian elbaum alexey malishevsky praveen kallakuri brian davia impact test suite granularity costeffectiveness regression testing proceedings 24th international conference software engineering may 1925 2002 orlando florida zhang neelam gupta rajiv gupta locating faulty code multiple points slicing softwarepractice experience v37 n9 p935961 july 2007 testing malware detectors acm sigsoft software engineering notes v29 n4 july 2004 mark last menahem friedman abraham kandel data mining approach automated software testing proceedings ninth acm sigkdd international conference knowledge discovery data mining august 2427 2003 washington dc sebastian elbaum hui nee chin matthew b dwyer jonathan dokulil carving differential unit test cases system test cases proceedings 14th acm sigsoft international symposium foundations software engineering november 0511 2006 portland oregon usa gregg rothermel sebastian elbaum alexey g malishevsky praveen kallakuri xuemei qiu test suite composition costeffective regression testing acm transactions software engineering methodology tosem v13 n3 p277331 july 2004
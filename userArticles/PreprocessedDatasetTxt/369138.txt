slicing software model construction applying finitestate verification techniques eg model checking software requires program source code translated finitestate transition system safely models program behavior automatically checking transition system correctness property typically costly thus necessary reduce size transition system much possible fact often case much programs source code irrelevant verifying given correctness propertyin paper apply program slicing techniques remove automatically irrelevant code thus reduce size corresponding transition system models give simple extension classical slicing definition prove safety respect model checking linear temporal logic ltl formulae discuss slicing strategy fits general methodology deriving effective software models using abstractionbased program specialization b introduction modern software systems highly complex yet must extremely reliable correct recent years finitestate verification techniques including model checking tech niques received much attention software validation method techniques effective validating crucial properties concurrent software systems variety domains including network protocols 23 railway interlocking systems 5 industrial control systems 3 despite success high cost automatically checking given correctness property software system typically enormous state space casts doubt whether broad application finitestate verification software systems costeffective researchers agree best way attack stateexplosion problem construct finitestate transition system safely abstracts software semantics 7 10 26 transition system small enough make automatic checking tractable yet large supported part nsf darpa grants ccr 9633388 ccr9703094 ccr9708184 nasa award nag 21209 supported part nsf grant ccr9701418 nasa award nag 21209 enough capture information relevant property checked one primary difficulties determining parts program relevant property checked paper show slicing automatically throw away irrelevant portions software code hence safely reduce size transition systems approximates softwares behavior envision slicing one collection tools translating program source code models suitable verification previously illustrated techniques abstract interpretation partial evaluation integrated applied help automate construction abstract transition systems 11 20 21 applying techniques several realistic software systems 12 13 revealed interesting interaction slicing abstraction building people currently perform slicinglike operations manually determine portions code relevant verifying given property thus preprocessing software using slicing applying partialevaluation based abstraction techniques provide safe approximation relevant portions code ii enable scaling current manual techniques significantly larger complex systems iii reduce number components abstractions must selected help guide se lection iv reduce size program treated abstractionbased partial evaluation tools work part larger project engineering highassurance software systems building set tools implements transition system construction methodology ada java paper use simple flowchart language order formally investigate fundamental issues implemented prototype slicing system paper based scaling techniques refer reader project website httpwwwcisksuedusantosbandera extended version paper contains exam ples technical extensions proofs prototype applications abstraction techniques concurrent ada systems next section describe flowchart language use throughout paper present section 3 definition slicing language discuss specific finitestate verification technique ltl model checking approach constructing safely abstracted transition systems source code section 4 section 5 describes slicing applied prephase transition system construction section 6 sketches several methods deriving slicing criteria temporal logic specifications based shape commonlyused formula pat terns section 7 discusses related work slicing section 8 summarizes concludes description future work 2 flowchart language fcl 21 syntax take source language simple flowchart language fcl gomard jones 18 25 19 figure 1 presents fcl program computes power func tion input parameters program n variables referenced assigned throughout program variables result introduced time initial value variable 0 output program execution state memory return construct executed figure 2 presents syntax fcl fcl programs essentially lists basic blocks initial basic block executed specified immediately parameter list power program initial block specified line init basic block consists label followed pos sibly empty list assignments write delta empty list elided list nonempty block concludes jump transfers control block another one instead including boolean values nonzero value represents true zero represents false test conditionals presentation slicing need reason nodes statementlevel controlflow graph cfg ie graph separate node assignment jump given program p assume statement unique index within block nodes uniquely identified pair li l block label index value figure 1 statement indices given annotations brackets delta exam ple second assignment loop block unique identifier node number loop2 following definition introduces notions related statementlevel controlflow graphs ffl flow graph e consists set n statement nodes set e directed controlflow edges unique start node unique end node e ffl inverse g gamma1 flowgraph n e e flowgraph edges reversed startend states swapped ffl node n dominates node g written domn every path start node passes n note makes dominates relation reflexive postdominates node n g written postdomm n every path node end node e passes n equivalently domn g gamma1 ffl node n controldependent intuition follows definition 1 exists nontrivial path p n every node 0 ng postdominated n 2 postdominated n 33 write cdn set nodes n controldependent control dependence plays important role rest paper note node n controldependent must least two exit edges must two paths connect e one contains n example power program figure 1 loop1 loop2 loop3 controldependent test1 end1 since postdominates test1 ie paths test1 halt go extracting cfg fcl program p straight forward possible hitch programs satisfy unique end node property required definition example program may multiple returns work around problem assume extract cfg program p insert additional node labeled halt successors predecessors return nodes p 22 semantics semantics fcl program p expressed transitions program states ln oe l label block p n index statement block l oe store mapping variables values series transitions gives execution trace programs statementlevel control flow graph example figure 3 gives trace power program computing 5 2 formally trace finite nonempty sequence states written suffix starting ie 1 omit formal definition transition relation fcl programs since intuitively clear formalization found 19 20 slicing 31 program slices program slice consists parts program p potentially affect variable values flow program point interest 31 slicing criterion specifies program point n node ps cfg set variables v interest example slicing power program respect slicing criterion yields program figure 4 note assignments variables result declaration input parameter sliced away since affect value n line loop2 addition block init trivial removed eg postprocessing phase slicing program p yields program ps traces ps projections corresponding traces p example following trace ps projection trace 1 consider finite traces corresponding terminating executions extended version paper treats infinite executions best expressed using coinductive reasoning n init init result 1 1 loop result result 1 goto test 2 n n 1 2 goto test 3 end else loop end return 1 figure 1 fcl program compute n domains l 2 blocklabelsfcl 2 assignmentsfcl al 2 assignmentlistsfcl grammar al al j delta x figure 2 syntax flowchart language fcl figure 3 trace power program init init goto test 2 loop n n 1 2 goto test 3 end else loop end return 1 figure 4 slice power respect criterion figure 3 intuitively trace 2 projection trace 1 sequence program states 2 embedded sequence states 1 formalize let oe j v denote restriction domain oe variables v definition projection follows program projection function ptraces determined ffl set nodes ps cfg ffl function maps node set variables v defined induction length traces follows ae classical definition 31 32 slicing criterion one specifies exactly one point node interest cfg along set variables interest node case example slice power program applications may interested multiple program points generalize notion slicing criterion follows definition 3 slicing criterion slicing criterion c program p nonempty set pairs n node ps statement flowgraph v subset possibly empty variables p nodes required pairwise distinct note criterion c viewed function variablesfcl case write domainc denote nkg thus slicing criterion c determines projection function domainc c abbreviate c formalize notion program slice definition 4 program slice given program p associated cfg let c slicing criterion p program ps also called residual program slice p respect c p execution trace execution trace ps running initial state s0 example let execution traces power program figure 1 slice power program figure 4 respectively 32 computing slices given program p slicing criterion c definition 4 admits many programs ps slices p fact p trivial slice p weiser notes problem finding statement minimal slice p incomputable 32 give minor adaptation weisers algorithm computing conservative slices ie slices may contain statements necessary 2 321 initial approximation slice computing slice involves among things identifying assignments affect values variables given slicing criterion one computes information similar reaching definitions requires keeping track variables referenced variables defined node cfg definition 5 definitions references ffl let defn set variables defined ie assigned node n always singleton empty set ffl let refn set variables referenced node n figure 5 shows def ref sets power program figure 1 next node cfg compute set relevant variables relevant variables variables whose values must known compute values variables slicing criterion definition 6 initially relevant variables slicing criterion c n set variables v either 1 2 n immediate predecessor node c intuitively variable v relevant node n 1 line slicing criterion slicing v 2 immediately precedes node v used define variable x relevant ie value x depends v b v relevant killed definition line n figure 5 presents initial sets relevant variables sets power program figure 1 slicing criterion n relevant along paths leading node loop2 end block n dead variable thus longer relevant classical definition slicing require nodes mentioned slice criterion occur computed slice force nodes occur define set obligatory nodes nodes must occur slice even fail define variables eventually deemed relevant definition 7 obligatory nodes set oc obligatory nodes defined follows 2 algorithm give actually based tips corrected version weisers algorithm 31 fng fng ftest1g fng fng figure 5 results slicing algorithm power program slicing criteria initial slice set 0 c set nodes define variables relevant successor definition 8 initial slice set initial slice set 0 c defined follows figure 5 presents initial slice set 0 c power program figure 1 node loop2 node 0 c since node defines variable relevant successor note 0 c include conditionals since conditionals make definitions tell conditionals added intuitively conditional node n added 2 0 c oc controldependent n set conditionals b 0 c called branch set definition 9 branch set initial branch set b 0 c defined follows figure 5 presents controldependence information initial branch set b 0 c power program figure 1 explained section 21 loop1 loop2 loop3 controldependent test1 since loop2 0 oc controldependency dictates test1 included b 0 c 33 iterative construction keep iterating process add conditionals influence nodes already slice must add slice nodes needed compute expressions tests conditionals fixed point reached ffl relevant variables branch criterion relevant variables node n relevant previous iteration plus needed decide conditionals control definitions previous slice set finding nodes branch b equivalent slicing program criterion fb refbg ffl slice set slice set contains conditionals controlled nodes previous slice set nodes define relevant variables ffl branch set conditionals required control nodes current slice set obligatory nodes figure 5 presents sets r 1 c c result second iteration algorithm next iteration fixed point reached since n variable required compute conditional test test1 already relevant test1 iterations size r c n nodes n c increasing since r c n bounded number variables program c bounded number nodes cfg iteration eventually reaches fixed points r c n c 34 constructing residual program given rc c following definition informally summarizes residual program constructed intuition assignment c must appear residual program assignment c oc assignment must irrelevant variable since node must appear residual program assignment replaced skip goto return jumps must appear residual program however c relevant assignment obligatory node control dependent upon therefore doesnt matter take true branch false branch case simply jump point two branches merge definition 11 residual program construction given program slicing criterion c let rc oc sets constructed process residual program ps constructed follows ffl parameter x p x parameter ps l label initial block p ffl label initial block ps label initial block p ffl block b p form residual block bs follows assignment line identifier li assignment appears residual program identifier li otherwise assignment becomes skip identifier li residual program otherwise node left residual program jump j b j jump bs otherwise must li 2 c j jump bs otherwise jump bs goto l 0 identifier li l 0 label nearest postdominating block l 1 l 2 finally postprocessing removes blocks targets jumps ps become unreachable 4 finitestate verification noted introduction variety finitestate verification techniques used verify properties soft ware make presentation concrete consider single finitestate verification technique model checking specifications written linear temporal logic ltl ltl model checking used reason properties wide range real software systems used example validate properties programming framework provides parallel scheduling variety systems eg parallel implementations finiteelement computational fluid dynamics program flow analysis problems 16 15 41 linear temporal logic linear temporal logic 27 rich formalism specifying state action sequencing properties systems ltl specification describes intended behavior system possible executions syntax ltl includes primitive propositions p usual propositional connectives three temporal operators propositional connectives temporal operators specifying properties software systems one typically uses ltl formulas reason execution particular program points eg entering exiting procedure well values particular program variables capture essence fcl use following primitive propositions ffl intuitively li holds execution reaches node block labeled l ffl intuitively x rop c holds value variable x current node related c relational operator rop eg x0 rop formally semantics primitive proposition defined respect states ae true false otherwise ae true oex false otherwise semantics formula defined respect trace temporal operator 2 requires argument true current state onward 3 operator requires argument become true point future u operator requires first argument true point second argument becomes true formally 24 let exists simple specifications using logic eventually block l5 executed whenever block l2 executed block l3 always subsequently executed whenever block l5 executed x nonzero x always less 10 42 software model construction apply finitestate verification software system one must construct finitestate transition system safely abstracts software semantics transition system small enough make automatic checking tractable yet large enough capture information relevant property checked relevant information extracted appropriate abstract interpretation ai 9 approach 12 20 user declares program variable abstract domain used interpreting operations variable using process combines abstract interpretation partial evaluation call abstractionbased program specialization abps residual program created propagating abstract values specializing program point respect abstract values 20 21 residual program concrete constants replaced abstract constants residual program safely approximating finitestate program fixed number variables defined finite abstract domains program submitted toolset 8 14 generates input existing model checking tools smv 28 spin 23 approach applied verify correctness properties several software systems written ada 12 13 steps described users main task pick appropriate ais ie ais extract relevant infor mation throw away irrelevant information general idea behind methodology chosing ais start simple use ais throw information dataflow away incrementally refine ais based information specification verified program 1 start point ai initially variables modeled point ai ie domain single value operations return effect throws away information variables value 2 semantic features specification specification formula checked includes form propositions different semantic features program eg valuations specific program vari ables features must modeled precisely ai hope checking property example formula includes proposition x0 instead using point ai x one must use eg ai domain fzero pos g refer zeropos ai 3 select controlling variables addition variables mentioned explicitly specification must also use refined ais variables specification variables control dependent predicates controlling conditionals suggest semantic features modeled ai example specification variable x controldependent upon conditional use evenodd ai 4 select variables broadest impact confronted multiple controlling variables model select one appears often conditional illustrate methodology figure 6 presents fcl rendering ada process controls readers writers common resource 8 ada system server process runs concurrently client processes requests startread stopread entry points ren dezvouz points control process fcl code figure 6 requests given program parameter reqs list values subrange 14 figure 7 presents blocklevel controlflow graph fcl program assume interested reasoning invariance property key features mentioned explicitly specification values variable writerpresent execution startread block point ai provide enough precision determine states writerpresent value zero effective ai writerpresent must able distinguish zero values positive values choose zeropos ai point could generate abstracted model check property consider additional refinements model choose latter illustrating exam ple determine variables upon node startread1 nodes assignments writerpresent control dependent example three variables writerpresent activereaders req already modeling writerpresent req used model external choice interactions control program via input could choose bind activereaders refined ai point given conditional expressions involving variable activereaders0 activereaders0 might also choose zeropos ai thus errorflag abstracted using point ai point would generate abstracted model check property true result obtained sure property holds program even though finitestate system models two variables precision false result obtained must examine counterexample produced model checker may reveal true defect program may reveal infeasible path model latter case identify variables conditionals along counterexamples path candidates binding precise ais methodology essentially heuristic search find variables program influence execution behavior program relative propertys proposi tions variable determined potentially influ abstraction refined strengthen resulting system model absence determination variable modeled point abstraction essentially ignores effect may although future may determined influence case abstraction refined reducing models using slicing illustrated picking appropriate abstractions nontrivial could benefit greatly form automated assistance key aspects methodology picking abstractions included 1 picking initial set relevant variables v relevant statements ie cfg nodes n mentioned ltl specification init activereaders 0 2 raiseerror writerpresent 0 3 errorflag goto checkreqs 5 checkreqs end null reqs 1 return 1 end else nextreq nextreq reqs cdr reqs 2 goto attemptstartread 3 attemptstartread startread req1 writerpresent0 1 activereaders activereaders1 1 startread goto checkreqs 2 else attemptstopread attemptstopread stopread req2 activereaders0 1 activereaders activereaders1 1 stopread writerpresent1 2 else attemptstartwrite raiseerror else attemptstopwrite attemptstartwrite startwrite req3 activereaders0 1 writerpresent writerpresent0 goto checkreqs 2 startwrite else attemptstopwrite attemptstopwrite stopwrite req4 writerpresent1 1 writerpresent 0 1 stopwrite else checkreqs activereaders0 2 raiseerror else checkreqs figure readwrite control example fcl 2 identifying appropriate ais variables v 3 using control dependence information picking additional sets variables w indirectly influence v n 4 identifying appropriate ais variables w intuitively variables v w irrelevant abstracted point ai clearly item 1 automated simple pass ltl specification moreover information item 3 exactly information would produced slicing program p based criterion generated information 1 thus preprocessing program verified using slicing provides automated support methodology specifically slicing identify relevant variables require ais point ai ii eliminate irrelevant program variables consideration abstraction selection process present residual program ps yielded slicing iii reduce size software thus size transition system analyzed forms support needed items 2 4 approach given program p specification desire criterion extraction function extract extracts appropriate slicing criterion c slicing p respect c yield smaller residual program ps preserves reflects satisfaction b little irrelevant information possible following requirement expresses condition requirement 1 ltlpreserving extract given program p specification let ps result slicing p respect c p execution trace raiseerror init attemptstopwrite attemptstartwrite attemptstopread attemptstartread nextreq checkreqs stopwrite startwrite stopread startread figure 7 readwrite control flowchart execution trace ps running initial state s1 51 propositionbased slicing criterion consider technical points guide us defining appropriate extraction function stated want preserve satisfaction formula yet remove much irrelevant information original trace possible already discussed situation certain variables values eliminated states trace influence satifac tion formula important used purely syntactic information set variables mentioned reduce state space lets explain reduction general terms consider trace assume state transition influence statisfaction formally compressed trace transition compressed another view change action ff causes change igamma1 action ff 0 causes change i1 combined action ff 00 moves igamma1 i1 intuitively formula doesnt need know intermediate state example irrelevant transition might assignment irrelevant variable transition nodes li li 1 mentioned technical justification identifying compressible transitions using purely syntactic examination propositions formula answer lies fact temporal operators treating state transitions dont change satisfication primitive propositions formula influence satisfaction means justify many trace compressions reasoning single transitions satisfaction primitive propositions see property hold one includes temporal operators next state operator ffi formalize notions following definition gives notion proposition invariance respect particular transition definition 12 pstuttering transition let p primitive proposition let transition said p stuttering p set primitive propositions proposition transition said pstuttering following lemma states satisfaction formula containing primitive propositions p invariant respect expansion compression pstuttering steps lemma 1 let formula let p set primitive propositions appearing traces lemma fails one includes next state operator 23 following semantics example consider trace let p proposition l3 note stuttering p false states compressing transition obtain preserve satification formula ie 6j intuitively next state operator allows one count states thus attempt optimize compressing transitions setting problematic reason systems like spin 23 guarantee semantics ffi preserved eg partialorder reduction optimizations given formula p set propositions want define extraction function guarantees transitions pstuttering preserved residual program traces ffl variable propositions observe definitions variable x may cause variable change value ie cause transition non p stuttering suggests proposition x rop c given specification assignment x included residual program x considered relevant ffl proposition entering leaving cfg node li cause proposition change value ie cause transition nonp stuttering one might imagine need slice include statement li proposition mula however possible compression might remove intermediate nodes two occurences node li well similar situations preserve state changes associated entering exiting node therefore addition node li must ensure immediate successors immediate predecessors li included slice based arguments define extraction function follows propositionbased extraction given program p specification let v set program variables occurring let set nodes contain assignments variables v unioned set np nodes appearing node propositions together successors predecessors node np extract g 1 extraction function extract satisfies requirement 1 example yields following criterion first three lines criterion startread1 node mentioned formula along predecessor successor last three lines nodes writerpresent assigned value figure 8 presents resulting slice slice identical original program except variable errorflag block raiseerror disappear program thus slicing automatically detects abstracting methodology yielded previous section given specification errorflag irrelevant previous conditional jumps stopread stopwrite raiseerror replaced unconditional jumps checkreq case slicing algorithm detected nodes raiseerror block irrelevant conditional jumps replaced unconditional jumps node true false paths leading conditionals meet second example consider specification 3checkreqs1 checkreqs1 eventually executed case extract yields criterion c2 lines criterion checkreqs1 node mentioned formula along predecessor successors since variable propositions specification variables specified relevant criterion figure 9 presents resulting slice obvious residual program sufficient verifying reachability checkreq1 given specification variables eliminated except reqs appears test checkreqs1 even though strictly necessary verifying property conditional retained slicing algorithm since controldependent upon addition slicing criterion dictates node nextreq1 slice however since assignment node assign relevant variable assignment replaced skip finally jump checkreqs node nextreq3 residual program result chaining series trivial gotos postprocessing 6 future work previous criteria considered individual proposi tions many property specifications however describe states using multiple propositions state relationships states characterized different propositions section give informal suggestions structure complex specifications may exploited produce refined slicing criterion init activereaders 0 2 writerpresent 0 3 goto checkreqs 5 checkreqs end null reqs 1 return 1 end else nextreq nextreq reqs cdr reqs 2 goto attemptstartread 3 attemptstartread startread req1 writerpresent0 1 activereaders activereaders1 1 startread goto checkreqs 2 else attemptstopread attemptstopread stopread req2 activereaders0 1 activereaders activereaders1 1 stopread goto checkreqs 2 else attemptstartwrite attemptstartwrite startwrite req3 activereaders0 1 writerpresent writerpresent0 goto checkreqs 2 startwrite else attemptstopwrite attemptstopwrite stopwrite req4 writerpresent1 1 writerpresent 0 1 stopwrite else checkreqs goto checkreqs 2 figure 8 slice readwrite control program respect c1 init goto checkreqs 5 checkreqs end null reqs 1 return 1 end else nextreq nextreq reqs cdr reqs 2 goto checkreqs 3 figure 9 slice readwrite control program respect c2 included slice included slice figure 10 slicing abstracted programs consider simple conjunction propositions appearing eventuality specification rather slicing propositions separately use semantics refine slicing criterion property interested assignments x influence value l1 thus slicing criterion would extract xg approach generalizes setting program point proposition occurs positively number variable propositions conjuncts thus far considered slicing prelude abps application abps however reveal semantic information variable values statement syntax thereby making available use slicing figure illustrates sequence assignments x left abstracted sequence assignments middle resulting binding classic signs ai 1 x abps situation determine transitions values propositions related x eg syntactically consider response property 15 form proposition slicing criterion would based solely 1 2 conjunctions observe two facts structure formula exploited 1 within 2 implication thus need reason statements cause value 1 become true since false values guarantee entire formula true 2 since righthand side 3 need reason first statement sequence statements causes 2 become true right column figure 10 illustrates effect applying observation 1 eliminate assignments cause positive transition sliced program note proposition involving x appears 2 slicing criterion may expanded include additional statements addition program point 1 holds postdominated point 2 holds need considered purpose checking response since existence relationship implies response holds occurrence 1 observation 2 exploited using postdomination information program point 2 holds post dominated another point 2 holds need included slice one program point 2 holds required path 3 formula become true thus postdominated 2 nodes may eliminated refined slicing criteria defined requires use auxiliary information postdomination infor mation needs available prior slicing cost gathering information processing compute slicing criteria may nontrivial dominated high cost performing model checking sliced system cases cost reducing size system presented model checker offset reduced model check time discussed two refined criteria based structural properties formula checked similar refinements defined number classes specifications including precedence chain properties 15 refinements use essentially information described response properties precedence properties require dominator rather postdominator information note refined response criteria applicable property checked specific even slight variations structure formula may render sliced program unsafe recent survey property specification finitestate verification showed response precedence properties form described occur quite frequently practice 16 48 realworld specifications fell two categories reason believe effort define series special cases extracting criteria based formula structure justified despite apparent narrowness 7 related work program slicing developed technique simplifying programs debugging identifying parts programs execute parallel 32 since development concept slicing applied wide variety problems including program understanding de bugging differencing integration testing 31 applications crucial slice preserve exact execution semantics original program respect slicing criterion work interested preserving ability successfully model check properties correct weakening allows refinement slicing criteria based property checked slicing generalized software artifacts 30 including attribute grammars requirements models 22 formal specifications 4 cimitile et al 6 use z specifications define slicing criteria identifying reusable code legacy systems work use combination symbolic execution theorem proving process specifications derive slicing criteria con trast identify necessary conditions subformula commonly occurring patterns specifications use conditions guide safe refinement basic proposition slicing criteria work touches relationship program specialization slicing use slicing prelude specialization suggest abstractionbased specialization may reveal semantic features residual programs syntax could used refined slicing criteria reps turnidge 29 studied relationship different perspective show similar techniques equivalent slicing transformations achieved specialization vice versa slicing viewed statespace reduction technique number important theoretical practical differences reduction techniques appearing literature statespace reduction 17 preserve correctness respect specific class correctness properties contrast approach slicing based criteria extracted formulae yields compressed traces contain state changes relevant propositions contained temporal logic formula approach yields programs remain sound complete respect property checking sharp contrast many abstraction techniques developed literature eg7 sacrifice completeness tractability finally even though significant progress made developing algorithms data structures reduce model checking times obdds 2 techniques seen complement slicing slicing removes variables system influence behavior checked model checker run faster regardless particular implementation techniques employs 8 conclusion presented variation program slicing simple imperative language shown slicing criteria defined guarantee preservation model check semantics ltl specifications sliced program implemented prototype tool performs slicing experimented number examples based work scaling prototype handle significantly complex features programs including structured data treatment procedures multithreaded programs communicate shared data extensions nontrivial build solid base laid work reported paper acknowledgements thanks james corbett michael huth david schmidt several illuminating discussions thanks also hongjun zheng helpful comments earlier draft r abstract interpretation declarative languages symbolic model checking 10 20 states beyond process control design using spin model checking safety critical software spin application railway interlocking system reusable functions using specification driven program slicing case study model checking abstraction evaluating deadlock detection methods concurrent software abstract interpretation unified lattice model static analysis programs construction approximation fixpoints abstract interpretation reactive systems using partial evaluation enable verification concurrent software model checking generic container implementations translating ada programs model checking property specification patterns finitestate verification patterns property specifications finitestate verification using partial orders efficient verification deadlock freedom safety properties compiler generation partial evaluation introduction partial evaluation using simple flowchart language staging static analysis using abstractionbased program specialization specializing configurable systems finitestate verification reduction slicing hierarchical state machines model checker spin logic computer science modelling reasoning systems partial evaluation automatic program generation temporal logic reactive concurrent systems specification symbolic model checking program specialization via program slicing beyond traditional program slicing survey program slicing techniques program slicing supercompilers parallel vector computers tr adequacy program dependence graphs representing programs formal model program dependences implications software testing debugging maintenance temporal logic reactive concurrent systems partial evaluation automatic program generation incremental program testing using program dependence graphs static slicing presence goto statements model checking abstraction design patterns property preserving abstractions verification concurrent systems beyond traditional program slicing abstract interpretation reactive systems model checker spin reduction slicing hierarchical state machines filterbased model checking partial systems using partial evaluation enable verification concurrent software patterns property specifications finitestate verification logic computer science bandera abstract interpretation symbolic model checking evaluating deadlock detection methods concurrent software staging static analyses using abstractionbased program specialization semantics program slicing program integration program slicing hardware description languages slicing programs arbitrary controlflow formal study slicing multithreaded programs jvm concurrency primitives program specialization via program slicing program analysis model checking abstract interpretations using partial orders efficient verification deadlock freedom safety properties reusable functions using specification driven program slicing ctr heike wehrheim slicing techniques verification reuse theoretical computer science v343 n3 p509528 17 october 2005 matthew b dwyer john hatcliff roby joehanes shawn laubach corina psreanu hongjun zheng willem visser toolsupported program abstraction finitestate verification proceedings 23rd international conference software engineering p177187 may 1219 2001 toronto ontario canada james c corbett matthew b dwyer john hatcliff shawn laubach corina psreanu robby hongjun zheng bandera extracting finitestate models java source code proceedings 22nd international conference software engineering p439448 june 0411 2000 limerick ireland yunja choi nusmv spin experiences model checking flight guidance systems formal methods system design v30 n3 p199216 june 2007 marieke huisman kerry trentelman factorising temporal specifications proceedings 2005 australasian symposium theory computing p8796 january 01 2005 newcastle australia xianghua deng matthew b dwyer john hatcliff masaaki mizuno invariantbased specification synthesis verification synchronization concurrent programs proceedings 24th international conference software engineering may 1925 2002 orlando florida g j holzmann h smith automated verification method distributed systems software based model extraction ieee transactions software engineering v28 n4 p364377 april 2002 oksana tkachuk sreeranga p rajan application automated environment generation commercial software proceedings 2006 international symposium software testing analysis july 1720 2006 portland maine usa antonella santone gigliola vaglini local approach temporal model checking java bytecode journal computer system sciences v70 n2 p258281 march 2005 yunja choi sanjai rayadurgam mats pe heimdahl automatic abstraction model checking software systems interrelated numeric constraints acm sigsoft software engineering notes v26 n5 sept 2001 matthew b dwyer john hatcliff robby venkatesh prasad ranganath exploiting object escape locking information partialorder reductions concurrent objectoriented programs formal methods system design v25 n23 p199240 septembernovember 2004 ingo brckner bjrn metzler heike wehrheim optimizing slicing formal specifications deductive verification nordic journal computing v13 n1 p2245 june 2006 tool support verifying uml activity diagrams ieee transactions software engineering v30 n7 p437447 july 2004 radu iosif matthew b dwyer john hatcliff translating java multiple model checkers bandera backend formal methods system design v26 n2 p137180 march 2005 baowen xu ju qian xiaofang zhang zhongqiang wu lin chen brief survey program slicing acm sigsoft software engineering notes v30 n2 march 2005
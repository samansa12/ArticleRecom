optimistic distributed simulation based transitive dependency tracking traditional optimistic distributed simulation protocols logical process lp receiving straggler rolls back sends antimessages receiver antimessage may also roll back send antimessages single straggler may result large number antimessages multiple rollbacks lps authors protocol lp receiving straggler broadcasts rollback receiving announcement lps may roll back announce rollbacks lp rolls back response straggler antimessages used eliminates need output queues results simple memory management also eliminates problem cascading rollbacks echoing results faster simulation achieved scheme maintaining transitive dependency information cost incurred includes tagging message extra dependency information increased processing time upon receiving message also present similarities two areas distributed simulation distributed recovery show solutions one area applied area b introduction modify time warp algorithm quickly stop spread erroneous computation scheme require output queues antimessages results less memory overhead simple memory management algorithms also eliminates problem cascading rollbacks echoing 15 resulting faster simulation use aggressive cancellation protocol adaptation similar protocol problem distributed recovery 4 21 supported part nsf grants ccr9520540 ecs9414780 trw faculty assistantship award general motors fellowship ibm grant illustrate main concept behind scheme help figure 1 figure horizontal arrows show direction simulation time messages shown interprocess directed arrows circles represent states state transition caused acting message associated incoming arrow example state transition p1 s10 happened p1 acted m0 time warp scheme logical process lp p2 receives straggler ie message schedules event back state s20 sends antimessage corresponding message m2 receiving antimessage p1 rolls back state s10 sends antimessage corresponding m1 acts next message message queue happens m0 receiving antimessage m1 p0 rolls back s00 sends antimessage m0 receiving antimessage p1 rolls back s11 scheme transitive dependency information maintained states messages rolling back s20 due straggler p2 broadcasts s20 rolled back receiving announce ment p1 rolls back s10 finds s10 transitively dependent s20 p1 also finds m0 transitively dependent s20 discards similarly p0 rolls back s00 receiving broadcast see p1 able discard m0 faster compared previous scheme even p0 would likely receive broadcast faster receiving antimessage m1 sent p1 rolled back s10 therefore simulation proceed faster explained later use incarnation number distinguish two states timestamp one committed rolled back need lp receives straggler broadcast timestamp straggler every lp determine whether need roll back comparing local dependency information broadcast timestamp lps roll back response rollback announcement send announcement antimessages hence rolls back response strag gler problem multiple rollbacks avoided several schemes proposed minimize figure 1 distributed simulation spread erroneous computations survey schemes found 7 filter protocol prakash subramanian 17 closely related work maintain list assumptions message describe class straggler events could cause message canceled maintains one assumption per channel whereas protocol viewed maintaining one assumption per lp worst case filter tags message 2 integers whereas protocol tags integers n number lps sys tem since applications even ontagging may acceptable also describe techniques reduce overhead subset lps interact mostly time tag size messages bounded size subset paper organized follows section 2 describes basic model simulation section 3 introduces happen relation states simulation vector serves basis optimistic simulation protocol section 4 describes protocol gives correctness proof section 5 presents optimization techniques reduce overhead protocol section 6 compares distributed simulation distributed recovery 2 model simulation consider eventdriven optimistic simulation execution lp consists sequence states state transition caused execution event multiple events scheduled time execute events arbitrary order addition causing state transi tion executing event may also schedule new events lps local lp sending messages lp p1 acts message p 2 p1 becomes dependent p 2 dependency relation transitive arrival straggler causes lp roll back state rolled back transitively dependent rolled back state called orphan state message sent orphan state called orphan message correctness simulation orphan states must rolled back orphan messages must discarded example distributed simulation shown figure 2 numbers shown parentheses either virtual times states virtual times scheduled events carried messages solid lines indicate useful computations dashed lines indicate rolled back computations figure 2a s00 schedules event p1 time 5 sending message m0 p1 optimistically executes event resulting state transition s10 s11 schedules event p2 time 7 sending message m1 receives message m2 schedules event time 2 detected straggler execution arrival straggler shown figure 2b p1 rolls back restores s10 takes actions needed maintaining correctness simulation described later restarts state r10 broadcasts rollback announcement shown dotted arrows acts m2 acts m0 upon receiving rollback announcement p 1 p2 realizes dependent rolled back state also rolls back restores state s20 takes actions needed restarts state r20 finally orphan message m1 discarded p 2 3 dependency tracking ij refer lp numbers k refers incarnation refer states p refers logical process refers number associated lp belongs refers message e refers event 31 happen relation lamport defined happen relation events rollbackfree distributed computation 12 take rollbacks account extend relation 4 21 define states two states u u transitive closure relation defined following three conditions 1 immediately precedes u 2 state restored rollback u state p taken s12 2 s13 5 m2 2 b figure 2 using simulation vector distributed simulation prestraggler computation b poststraggler computation actions needed maintain correctness simulation despite rollbacks example figure 3 sender message u ceivers state event scheduled executed example figure 2a s10 s11 s00 s21 figure 2b s11 6 r10 saying happened u equivalent saying u transitively dependent protocol actions needed maintain correctness simulation include broadcasting rollback announcement incrementing incarnation number protocols actions may dif ferent example time warp actions include sending antimessages definition happen independent actions terms rollback announcements tokens used interchangeably tokens contribute happen relation u receives token u become transitively dependent due token 32 simulation vector vector clock vector size n n number processes system 16 vector entry timestamp usually counts number send receive events process context distributed simulation modify extend notion vector clock define simulation vector sv follows maintain dependency presence rollbacks extend entry contain timestamp incarnation number 19 timestamp th entry sv corresponds virtual time p timestamp j th entry corresponds virtual time latest state p j p depends incarnation number th entry equal number times p rolled back incarnation number j th entry equal highest incarnation number p j p depends let entry en tuple incarnation v timestamp define lexicographical ordering entries follows en simulation vectors used maintain transitive dependency information suppose p schedules event e p j time sending message p attaches current sv virtual time mean scheduled time event e neither orphan straggler kept incoming queue p j event corresponding executed p j updates sv ms sv taking componentwise lexicographical maximum virtual time denoted j th timestamp sv virtual time formal description sv protocol given figure 3 examples sv shown figure 2 sv state shown box near sv properties similar vector clock used detect transitive dependencies states following theorem shows relationship virtual time sv theorem 1 timestamp th entry p sv corresponds virtual time p incarnation timestamp var sv array 0n1 entry time executed send mdata mts msv execute message mdata mts msv event scheduled figure 3 formal description simulation vector protocol proof induction claim true initial state p executing message virtual time p correctly set rollback virtual time restored state remains unchanged let ssv denote sv p sp state define ordering two svs c follows p sv j th timestamp denotes maximum virtual time p j p depends timestamp greater p virtual time lemma 1 formalizes notion lemma 1 timestamp th entry sv state p highest value among timestamps sv proof induction lemma true initial state p assume state p j sent message p state u p executed resulting state w induction hypothesis ssvjts usvits highest timestamps svs maximum two timestamps greater timestamps wsv max operation execute message mts virtual time message less virtual time state sending message also less virtual time state u acting message otherwise would caused rollback theorem 1 mts less maximum ssvjts usvits hence setting wsvits mts preserves property routines change timestamps following two lemmas give relationship sv happen relation happens u ssv less equal usv proof induction consider two states u happens u applying one three rules definition happen case rule 1 state changed state u acting message update sv taking maximum routine execute message maintains property consider next action usvupts set mts since virtual time cannot less virtual time state executing operation also maintains property case rule 2 routine rollback update sv incrementing incarnation number preserves property case rule 3 similar rule 1 let state w change state u acting message sent state lemma 1 ms sv sp th timestamp less th timestamp also virtual time less sp th timestamp sv hence setting th timestamp virtual time taking max preserves property following lemma shows lps acquire timestamps becoming dependent lps property later used detect orphans lemma states j th timestamp state ws sv minus one impossible virtual time w must dependent state u p j virtual time u wsvjts proof induction initialize trivially satisfies property execute message let x state sends let state change state w acting induction hypothesis x satisfy lemma taking maximum let j th entry x se lected j xp x plays role u else induction hypothesis xsvjts hence either wsvjts 1 transitivity u happens w argument also applies case th entry comes case rollback let state restored let w state resulting taking actions needed correct simulation induction hypothesis satisfies lemma ssv wsv differ wp th entry states happened also happened w hence w satisfies lemma simulation vector set entry incarnation end table announcement receive else mts svits straggler receives broadcast rolls back block till lps acknowledge broadcast execute message messages lowest value mts act event scheduled receive tokenv rollbackj v save iet restore latest state discard states follow restore saved iet sviinc figure 4 protocol distributed simulation 4 protocol protocol distributed simulation shown figure 4 keep presentation correctness proof clear optimization techniques reducing overhead included protocol described next section besides simulation vector lp p also maintains incarnation end table iet j th component iet set entries form k ts ts timestamp straggler caused rollback k th incarnation p j states k th incarnation p j timestamp greater ts rolled back iet allows lp detect orphan messages p ready next event acts message lowest virtual time explained section 3 p updates sv internal state possibly schedules events lps sending messages upon receiving message p orphan case j p iet j th entry ms sv indicate dependent rolled back state p j p detects straggler virtual time broadcasts token containing current incarnation number k rolls back states virtual time greater increments incarnation number shown rollback thus token basically indicates states incarnation k virtual time greater orphans states dependent orphan states also orphans lp receives token containing virtual time p j rolls back states j th timestamp greater discards orphan messages input queue increments incarnation number broadcast token important property protocol works transitive dependencies maintained suppose state w p dependent rolled back state u p j state x dependent w must also dependent u x detected orphan state token p j arrives p xp without need additional token p argument detection orphan messages similar require lp block execution broadcasting token receives acknowledgments lps ensures token lower incarnation p j reaches lps become dependent higher incarnation greatly simplifies design dependency entry overwritten entry higher incarnation lexicographical maximum operation guaranteed future rollback occur due overwritten entry corresponding token must arrived blocked lp acknowledges received broadcasts 41 proof correctness suppose state u p j rolled back due arrival straggler simulation correct states dependent u also rolled back following theorem proves protocol correctly implements simulation theorem 2 state rolled back due either straggler token state rolled back due token dependent state rolled back due straggler proof routine rollback called two places receive message receive token states rolled back call receive message rolled back due straggler suppose p j receives strag gler let u one states p j rolled back due straggler call routine receive token state w satisfying condition c1 rolled back since virtual time u greater virtual time straggler lemma 2 state w dependent u satisfy condition c1 future state become dependent u message causing dependency discarded arrives token discarded first test routine receive message arrives token discarded first test routine receive token orphan states rolled back lemma 3 state w satisfying condition c1 thus rolled back exists state u rolled back due straggler u w means state unnecessarily rolled back 5 reducing overhead systems large number lps overhead sv delay due blocking substantial section describe several optimization techniques reducing overhead blocking 51 reducing blocking simplicity protocol description figure 4 increments incarnation number upon rollback due token although broadcast another token next argue protocol works even incarnation number incremented modification allows optimization reduce blocking use example figure 2b illustrate modification suppose p 2 executes event makes state transition r20 s22 virtual time 7 shown figure p2 increment incarnation number rolling back due token p 1 s22 0 7 3rd entry sv s21s 3rd entry figure 2a suppose 3rd entry state w another lp p3 0 7 p3 decide whether w dependent s21 rolled back s22 rolled back answer w dependent s21 also dependent s11 therefore orphan status identified 2nd entry without relying 3rd entry modification ensures every new incarnation token broadcast every lp iet entry allows following optimization technique reducing blocking suppose receives straggler broadcasts token instead requiring p block receives acknowl edgements allow p continue execution new incarnation one problem needs solved dependencies new incarnation may reach lp p j chain messages corresponding token p j dependency entry rolled back state old incarnation identified orphan token arrives overwriting old entry new entry via lexicographical maximum operation results undetected orphans hence incorrect simulation solution force p j block token acquiring dependency new incarnation conjecture blocking token receivers side would improvement original blocking token senders side number lps hence acknowledgements large 52 reducing size simulation vector global virtual timegvt virtual time given point simulation state virtual time less gvt ever rolled back minimum virtual times lps messages transit given instant several algorithms developed computing gvt 2 20 reduce size simulation vectors entry timestamp less gvt set null null entries need transmitted message affect correctness simulation 1 virtual time message must greater equal gvt timestamps less gvt never useful detecting stragglers 2 virtual time contained token must greater equal gvt timestamps less gvt never useful detecting orphans since sv entries initialized 1 see figure 3 must less gvt optimization allows simulation start small vectors particularly effective high locality message activities following 21 also use koptimistic pro tocol scheme lp allowed act message result k nonnull entries sv otherwise blocks ensures lp rolled back k lps sense optimistic protocols n optimistic pessimistic protocols 0optimistic another approach reducing size simulation vectors divide lps clusters several designs possible interaction inside cluster optimistic intercluster messages sent conservatively 18 independent svs used inside cluster involving lps clus ter intracluster execution sequential intercluster execution optimistic 1 svs used intercluster messages one entry per cluster similarly one devise scheme intercluster intracluster executions optimistic employ different simulation vectors generalized hierarchy clusters simulation vectors general however intercluster simulation vectors introduce false dependencies 14 may result unnecessary rollbacks tradeoff size simulation vectors unnecessary rollbacks affect correctness simulation 6 distributed simulation distributed recovery problem failure recovery distributed systems 6 similar problem distributed simulation upon failure process typically restores last checkpoint starts execution however process states lost upon failure may create orphans cause system state become inconsistent consistent system state one send message must recorded receive recorded 6 pessimistic logging 6 every message logged receiver acts process fails restores last checkpoint replays logged messages original der ensures prefailure state recreated process needs rolled back synchronization message logging message processing reduces speed computation optimistic logging 19 messages stored volatile memory buffer logged asynchronously stable storage since content volatile memory lost upon failure messages longer available replay failure thus process states lost failure states processes dependent lost states become orphan states optimistic logging protocol must roll back orphan states order bring system back consistent state many parallels issues distributed recovery distributed simulation survey different approaches distributed recovery found 6 table 1 list equivalent terms two domains references omitted terms widely used equivalence exact many cases approximate cases stragglers trigger rollbacks distributed simula tion failures trigger rollbacks distributed covery conservative simulation 7 ensures current state never need roll back similarly pessimistic logging 6 ensures current state always recoverable failure words although rollback occur rolled back states always reconstructed time warp optimistic approach 10 inspired seminal work optimistic message logging 19 optimistic protocol presented paper based optimistic recovery protocol presented 4 21 simulation scheme dickens reynolds 5 results optimistically processed event sent processes become definite 3 recovery scheme jalote 11 messages originating unstable state interval sent processes interval becomes stable 6 schemes confine loss computation either due straggler failure local process distributed simulation distributed recovery logical process recovery unit 19 virtual time state interval index sim vector paper trans dep vector 19 straggler failure antimessage rollback announcement fossil collection 10 garbage collection 6 global virtual time 2 global recovery line 6 conservative schemes pessimistic schemes optimistic schemes optimistic schemes causality error orphan detection cascading rollback 15 domino effect 6 echoing 15 livelock 6 conditional event 3 unstable state 6 event 3 stable state 6 table 1 parallel terms distributed simulation recovery conservative optimistic simulations combined 1 18 dividing lps clusters different schemes intercluster intracluster executions distributed recovery paper lowry et al 14 describes idea similar conservative time windows simulation literature list main differences two areas arrival straggler prevented occurrence failure cannot pessimistic logging cancel effect failure message logging replaying arrival straggler optimistic simulation cause loss information occurrence failure optimistic logging causes volatile message logs lost recovery protocols deal lost intransit message problem 6 present distributed simulation protocols incoming messages different channels processed arbitrary order event messages distributed simulation must executed order increasing timestamps due differences protocols presented one area may applicable area distributed recovery potentially benefit advances distributed simulation areas memory management 13 analytical modeling determine checkpoint frequency 8 checkpointing mechanisms 22 time constrained systems 9 simi larly research work coordinated checkpointing optimal checkpoint garbage collection dependency tracking 6 potentially applied distributed simulation r clustered time warp logic simulation global virtual time algorithms conditional event approach distributed simulation recover efficiently asynchronously optimism fails survey rollbackrecovery protocols messagepassing systems parallel discrete event simulation comparative analysis periodic state saving techniques time warp simulators time warp simulation time constrained systems virtual time fault tolerant processes memory management algorithms optimistic parallel simulation optimistic failure recovery large networks virtual time global states distributed systems efficient optimistic distributed simulation scheme based conditional knowledge local time warp approach parallel simulation optimistic recovery distributed systems algorithm minimally latent global virtual time distributed recovery koptimistic logging automatic incremental state saving tr optimistic recovery distributed systems virtual time rollback sometimes worksif filtered parallel discrete event simulation algorithm minimally latent global virtual time local time warp approach parallel simulation time warp simulation time constrained systems comparative analysis periodic state saving techniques time warp simulators time warp logic simulation automatic incremental state saving time clocks ordering events distributed system recover efficiently asynchronously optimism fails distributed recovery koptimistic logging ctr reuben pasquini vernon rego optimistic parallel simulation network workstations proceedings 31st conference winter simulation simulationa bridge future p16101617 december 0508 1999 phoenix arizona united states om p damani vijay k garg faulttolerant distributed simulation acm sigsim simulation digest v28 n1 p3845 july 1998
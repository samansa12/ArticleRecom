finding separator cuts planar graphs within twice optimal factor 2 approximation algorithm problem finding minimumcost bbalanced cut planar graphs presented b leq 1 3 assume vertex weights given unary case binary vertex weights pseudoapproximation algorithm presented problem considerable practical significance especially vlsi designthe natural algorithm problem accumulates sparsest cuts iteratively one main ideas give definition sparsity called netsparsity reflects precisely cost cuts accumulated algorithm however definition precise believe nphard compute minimumnetsparsity cut even planar graphs rest machinery built work definition still make computationally feasible toward end use several ideas works rao proceedings 28th annual ieee symposium foundations computer science 1987 pp 225237 proceedings 24th annual acm symposium theory computing 1992 pp 229240 park phillips proceedings 25th annual acm symposium theory computing 1993 pp 766775 b introduction given undirected graph edge costs vertex weights balance cut ratio weight vertices smaller side total weight graph cut balance least b called bbalanced cut 1 balanced cut given special name separator paper present factor 2 approximation algorithm finding minimumcost bbalanced cut planar graphs b 1 3 assuming vertex weights given unary also give examples show analysis tight case binary vertex weights use scaling give pseudoapproximation algorithm ff 2b finds 2ffbalanced cut cost within twice cost optimal bbalanced cut b 13 time polynomial n ff previous best approximation guarantee known bbalanced cuts planar graphs olog n due rao 8 9 general graphs approximation algorithms known problem breaking graph small sized pieces removal small set edges vertices attracted much attention since seminal work lipton tarjan 5 opens possibility divideandconquer strategy solution several problems graph small balanced cuts numerous applications see example 1 3 4 6 several maxplanckinstitut fur informatik im stadtwald 66123 saarbrucken germany department computer science engineering indian institute technology new delhi 110016 india z college computing georgia institute technology atlanta ga 30332 supported nsf grant ccr applications pertain planar graphs important one circuit partitioning vlsi design sparsity cut defined ratio cost cut weight smaller side cut minimum sparsity graph called sparsest cut rao 9 gave a2 approximation algorithm problem finding sparsest cut planar graphs recently park phillips 7 showed problem polynomial time solvable sparsest cut limits multicommodity flow way mincut limits maxflow leighton rao 3 derived approximate maxflow mincut theorem uniform multicommodity flow process gave olog napproximation algorithm finding sparsest cut general graphs finding removing cuts iteratively one show find planar general graphs b balanced cut within o1 factor olog n factor optimal b 0 balanced cut 3 8 9 3 instance using parkphillips algorithm sparsest cut planar graphs approach gives 1balanced cut within 71 times cost best 1balanced cut planar graphs notice however true approximation algorithms since best 1balanced cut may much higher cost best 1balanced cut iterative algorithm shortcomings due lead good true approximation algorithm illustrated via example section 3 one main ideas give definition sparsity called netsparsity overcomes shortcomings notion netcost definition netsparsity based reflects precisely cost cuts accumulated iteratively indeed precise directly useful computationally believe computing sparsest cut definition nphard even planar graphs rest machinery built work definition still make computationally feasible manage scrape narrowly planarity exploited several ways first cut planar graph corresponds set cycles dual secondly notion transfer function turns useful given planar graph weights faces notion used define function edges graph cycle evaluates sum weights faces enclosed cycle idea used past kasteleyn 2 computing number perfect matchings planar graph polynomial time kasteleyn defined function gf 2 park phillips 7 first defined function reals thereby demonstrating full power notion park phillips 7 shown problems finding sparsest cut minimum b balanced cut planar graphs weakly nphard ie problems nphard vertex weights given binary indeed algorithm give finding sparsest cut planar graphs pseudopolynomial time algorithm consequence algorithm follows p 6 np finding sparsest cuts planar graphs strongly nphard hand known bbalanced cut problem planar graphs strongly nphard pseudopolynomial time algorithm present paper gives pseudopolynomial approximation algorithm park phillips leave open question finding fully polynomial approximation scheme sparsest cuts planar graphs ie vertex weights given binary give algorithm using scaling technique preliminaries e connected undirected graph edge cost function c vertex weight function function define elements universe extends sets elements obvious manner value function set sum values elements set let w sum weights vertices g partition v defines cut g cut consists edges one end point set vertices said connected subgraph induced connected either connected cut called simple cut connected cut called bond given set vertices ae v define cost set costs sum costs edges cut weight set wts sum weights vertices included cut separator w wts wts 2w cost separator sum costs edges separator lemma 21 connected graph g exists minimumcost separator simple cut side connected connected component weight strictly less w 3 proof let minimumcost separator g consider connected components obtained removing edges separator clearly component weight strictly larger 2w 3 components weight strictly less wthen connected arrive contradiction follows first pick two components edge pick remaining one one arbitrary order till accumulate weight least w accumulated weight exceed 2wsince component weight wthus obtain separator cost strictly less cost separator contradiction hence least one component weight wand 2w two components components since switching side third component obtain cheaper separator one component weight wand 2wthen separator optimum iff component forms one side cut remaining components side thus bond side cut connected components side weight strictly less w 3 hence always exists minimumcost separator simple cut let opt denote set vertices side separator connected 3 overview algorithm let set vertices wts wts sparsity usually defined quotient cost weight set ie figure 1 graph vertex weights edge costs showing minimum sparsity increases natural approach finding good separators repeatedly find set minimum sparsity remove graph eventually reporting union removed vertices easy concoct bad examples approach ensuring picked vertices always come smaller side optimal separator thereby ensuring minimum sparsity available remaining graph keeps increasing illustrated figure 1 first cut picked sparsity 1 whereas last cut sparsity 1 approach two shortcomings removes vertices picked iteration deals remaining graph subsequent iterations assumes edges cuts found iteration picked permanently even though may needed final cut one main ideas give definition sparsity algorithm suffer either shortcomings two sets vertices define netcost respect netcost netweight respect netweight thus already picked set vertices netcost measures extra cost incurred netweight weight added picking set finally define net sparsity respect netsparsity netcost netweight algorithm picks cut accumulating sets vertices notion netcost gives precisely extra cost incurred iteration precise computing sparsest cut definition turns nphard even planar graphs although answer question believe yes indeed rest machinery built work definition still make computationally feasible manage scrape let us first show sufficient keep picking sets minimum netsparsity consider following example suppose sparse set weight wgamma ffl 2 set high sparsity weight ffl small ffl picked 1 might pick another set 3 sparsity almost 2 weight wgamma ffl hence cost incurred would arbitrarily high compared optimum get around difficulty ensuring iteration set vertices pick total weight accumulated strictly w 3 formally let igamma1 set vertices picked end i1 th iteration th iteration pick set minimality minimum netweight among sets satisfying conditions call set dot denote ffl thus end th iteration set vertices picked given augment partial solution iteration ever obtain complete solution separator th iteration besides augmenting partial solution igamma1 partial solution also augment complete solution ie pick set vertices b 3 finding set b 1 corresponds finding minimumcost separator avoid circularity argument restrict b smaller class sets bond w wtt call set b box denote 2 notice box set need bond count 2 cost rather netcost done simplify algorithm analysis example shows analysis algorithm tight also shows counting 2 netcost would led improvement approximation guarantee iteration obtain separator solution reported algorithm one minimum cost among separators algorithm call dotbox algorithm following algorithm dotbox algorithm 1 minsol 1 0 0 oe 2 wtt 21 22 find ffl 2 sets b respectively ffl set exit 23 minsol minminsol costt 24 end make two remarks regarding step 22 first conjecture finding ffl set nphard procedure find ffl sets may always succeed however prove fails set found current iteration gives separator within twice opt second iteration might case subset vertices satisfies weight criterion ffl since set takes total weight accumulated w3 case dotbox algorithm halts outputs best separator found far 4 analysis dotbox algorithm first prove properties netcost netweight useful analysis definition netcost netweight netcost netcost netweight following property also follows definitions property 41 let 1 two sets vertices necessarily disjoint netcost netcost netcost ts 1 netweight property 42 netcost netcost st proof figure 2 shows edges sets property immediate netcost respect may higher includes cost edges gamma gamma following property immediate figure 3 figure 2 computation netcost netcost st edge signifies edge counted positivenegative term netcost computation figure 3 computation netcost netcost 1 netcost 2 property 43 let 1 two disjoint sets vertices edges netcost netcost netcost 2 remark 41 positive real numbers b c min max let positive real numbers lemma 41 netsparsity ffls increasing ie proof since set i1 satisfies weight requirement ffl th iteration netsparsity property 41 netcost netcost netcost netweight using remark 41 gives us minnetsparsity first inequality must case maxnetsparsity lemma follows let k first iteration connected component opt meets weight requirement 2 lemma 42 proof since opt 6 igamma1 connected components opt completely contained igamma1 assumption none components satisfies weight requirement 2 hence components meets weight requirement ffl hence ffl picked iteration netsparsity components property 43 netcost opt sum netcosts components opt true netweight hence component opt minimum netsparsity netsparsity less opt lemma follows two lemmas imply netsparsity ffls picked increasing iteration k th netsparsity less netsparsity opt iteration lemma 43 proof establish inequality consider two processes 1 first process algorithm picks set vertices j j th step 1 2 second process picks vertices opt j th step 1 th step picks remaining vertices opt let p j set vertices picked second process first j steps opt j th step second process picks additional weight netweight p cost netcost p fact second process picks subset first process picks step 41 42 42 netcost netcost p netweight hence netsparsity claim follows since p j satisfies weight requirement ffl j picked ffl claim follows lemma 42 claims imply iteration 1 first process picks vertices lower netsparsity second process processes picking additional weight iteration fact alone would implied cost vertices picked first process less cost vertices picked second case true however fact iterations 1 i1 first process picks larger additional weight second process th iteration second process picks enough additional weight accumulated total weight strictly larger picked first process since wtopt w wtt netsparsity second process picks vertices th iteration maximum iterations 1 netsparsity first process picks vertices follows cost vertices picked first process strictly less cost vertices picked second ie consider separator found k th iteration ie cut solution formed picking ffls first k1 steps 2 k th step lemma 44 costt figure 4 tight example analysis vertex weights edge costs given proof connected component opt bond k th iteration exists connected component opt say opt j w wtt hence 2 k th step cost costopt j ie lemma 43 know costt hence since dotbox algorithm outputs best separator found theorem 45 cost separator found dotbox algorithm twice cost opt analysis dotbox algorithm tight run example figure 4 picks separator cost almost twice optimum example ffl ffl 3n ffl first iteration set c 2 set separator also one returned dotbox algorithm cost hence approximation ratio 2 5 structural properties solution computationally easier definition netcost section prove structural properties solution found dotbox algorithm allows us redefine netcost manner becomes computationally easier yet analysis previous section continues hold lemma 51 proof contradiction assume connected let connected component three cases w3 set satisfies weight requirement ffl i1 th iteration since edges vertices netcost respect negative hence netsparsity negative contradicting lemma 41 cut separator cost costt contradiction condition case implies wta w3 wta 2w3 contradiction since cut separator cost costopt thus must case wta 2w3 since argument implies connected component weight greater must one connected component lemma 52 proof contradiction assume connected let connected component rest also denote b corresponding sets vertices ffl th iteration netcost netcost disjoint set vertices edges property 43 netcost netcost netcost netweight thus either case one b smaller netsparsity contradicts assumption ffl else b netsparsity contradicts minimality requirement lemma 53 every iteration exists ffl satisfying 1 2 connected component igamma1 contained edge components igamma1 proof set together subset igamma1 also ffl th iteration form new ffl merging connected components edge connected since graph connected every remaining component igamma1 edge also connected thus bond follows definition edge components since every ffl iterations 1 conditions lemma 53 restrict search ffl th iteration sets satisfy conditions additional requirements connected component igamma1 contained edge components igamma1 graph obtained shrinking connected component igamma1 single vertex removing selfloops formed replacing set parallel edges one edge cost equal sum cost edges set finding ffl th iteration consider sets connected component igamma1 split across bond therefore need look subsets v correspond bonds g let subset vertices g trapped cost respect igamma1 denoted trappedcost igamma1 sum costs components igamma1 contained redefine netcost respect igamma1 netcost trappedcost note subset vertices g netcost new definition least large previous definition however crucial netcost ffl set remains unchanged lemma 53 edges components igamma1 therefore ffl new definition netcost also ffl previous definition analysis dotbox algorithm continues hold 6 onto planar graphs know complexity computing ffl sets suspect nphard even planar graphs yet implement dotbox algorithm planar graphs using properties cuts planar graphs showing iteration algorithm find ffl set fact separator found using 2 set found iteration within twice optimal proven theorem 71 61 associating cycles sets let g planar dual g fix embedding g proposition 61 onetoone correspondence bonds g simple cycles g proof let bond g since connected faces corresponding g adjacent edges g corresponding form simple cycle converse let c simple cycle g corresponds cut g let u v two vertices g side cut prove bond suffices show path u v g use edge embed g g r theta r consider two faces g corresponding vertices u v pick arbitrary point face instance points corresponding u v since c simple cycle g hence r theta r continuous curve r theta r connects two points without intersecting c considering faces g curve visits edges g curve intersects obtain path g connects vertices u v without using edge since finding ffl 2 need consider sets bond restrict simple cycles g furthermore two orientations simple cycle used distinguish two sides cut cycle corresponds notation adopt cycle c directed clockwise associate set faces g hence vertices g enclosed c side include infinite face said enclosed c side containing infinite face said outside c let g graph obtained g replacing undirected edge u v two directed edges u preceding discussion exists correspondence sets vertices g bond directed simple cycles g 62 transfer function associate cost function c edges g obvious manner edge g assigned cost corresponding dual edge g thus directed cycle c cc denotes sum costs edges along cycle would also like associate functions edges g set corresponding directed simple cycle c trappedcost achieve means transfer function notion transfer function introduced park phillips 7 viewed extension function given kasteleyn 2 function g defined edges g u notice function c defined symmetric r function vertices g transfer function corresponding f antisymmetric function f edges g sum values f takes edges clockwise anticlockwise simple cycle g equal negative sum values f takes vertices corresponding faces enclosed cycle transfer function exists every function defined vertices g computed efficiently follows following simple argument pick spanning tree g set f zero corresponding edges g add remaining edges g order edge added one face graph completed note edge e added edges face e completes assigned value f one two directed edges corresponding e used clockwise traversal face anticlockwise traversal since value f face known since f sum value negative value clockwise anticlockwise traversal face value f two directed edges corresponding e determined note function obtained manner antisymmetric together fact edges simple cycle g written gf 2 sum edges belonging faces contained cycle implies f desired property 7 finding ffl sets recall ffl th iteration bond graph g hence restrict search ffl th iteration directed simple cycles g 71 obtaining netweight netcost transfer functions let two functions defined vertices g follows vertices v obtained shrinking connected components igamma1 equal cost corresponding component igamma1 remaining vertices denote transfer functions corresponding functions relate values functions c directed simple cycle netcost netweight netsparsity set corresponding cycle let c directed simple cycle g ae v set corresponding c clockwise netweight trappedcost given values transfer functions c ie netweight trappedcost c anticlockwise values transfer functions w equal negative netweight trappedcost set enclosed c notation hence netweight trappedcost trappedcost recalling new definition netcost netcost trappedcost conclude c clockwise netsparsity anticlockwise c netsparsity hence simple directed cycle c know values transfer functions w easy determine netweight netsparsity corresponding set note orientation c determined sign w c since w implies c clockwise anticlockwise 72 approach finding ffl fixed value w c netsparsity igamma1 minimized suggests following approach finding ffl w range 0 w w compute mincyclew directed simple cycle minimum directed cycles c w find netsparsity set corresponding cycles set minimum netsparsity ffl iteration however implement weaker version procedure mincycle following 7 construct graph h whose vertices 2tuples kind v vertex g j integer gammanw nw edge g possible choices j edge u e shortest path v v w h gives shortest cycle among directed cycles g contain v w computation choices v find shortest cycle two questions arise 1 negative cycles essential computing shortest paths efficiently 2 cycle obtained g answer questions interestingly enough things still work first tackle second question theorem 71 first lemma 72 73 overcoming nonsimple cycles discuss get problem need better understanding structure nonsimple cycle c c simple cycle g arbitrarily collection edgedisjoint directed simple cycles c let cut g corresponding cycle c side cut smaller netweight let collection sets j one c j 2 c trappedcost gammatrappedcost trappedcost trappedcost figure 5 relationship netweight w c four cases value transfer functions w sum values cycles c j collection c also cycle c need relate netweight trappedcost j value transfer functions w might either clockwise anticlockwise j might either inside c j outside c j gives us total four different cases relationship netweight trappedcost figure 5 captured succinctly follows trappedcost gamma1g hence get decomposition rule relating value functions w nonsimple cycle c netweight trappedcost sets induced cycle trappedcost integer 74 key theorem let ffl th iteration directed simple cycle g corresponding let c directed cycle reported mincyclew c theorem 71 c simple separator found iteration cost 2 delta costopt ie proof since c directed cycle among cycles claim following c clockwise ie w c netcost c anticlockwise ie w c netcost substituting w c c decomposition rule get gammaz delta costt trappedcost netcost z x c clockwise x prove exists j 2 meets weight requirement 2 cost cost ie 1 w wtt netcost assume contradiction exists following observations costnetcost set j 2 immediate observation 71 netweight netcost implies netcost netcost observation 72 netweight netsparsity hence netcost two observations follows observation 73 sets j 2 nonnegative netcost ie netcost idea behind obtaining contradiction follows every integral choice z use equation 1 provide lower bound total netweight sets j 2 equation 2 provide upper bound total netcost sets j 2 use observations costnetcost sets j 2 argue way sets large total netweight little total netcost shall consider 3 cases depending upon whether z positivenegativezero equation 2 implies netcost trappedcost netcost equation 1 netweight netweight since netcost set nonnegative observation 73 set netcost netcost turn implies every set netweight strictly less w3 gamma wtt thus every set meets weight requirement ffl since netcost every set nonnegative remark 41 applied two inequalities implies either exists j 2 lower netsparsity every set netsparsity sum netweight sets equal netweight first setting leads contradiction since every set satisfies weight requirement ffl ffl iteration second setting turn contradicts minimality requirement denote collection sets j 2 yields netcost trappedcost trappedcost second inequality follows fact sets nonnegative netcost shall develop contradiction showing costs sets gamma left hand side inequality lower bound total netweight sets gamma obtained equation 1 follows netweight cheapest way picking sets netweight least zw gamma wtt netweight 72 set j netweight picked netsparsity least netsparsity hand observation 71 says could picking sets large netweight cost little costt netcost set netweight cost picking large sets could small netcost netcost netcost netweight netsparsity last inequality follows fact sparsityt turn consequence lemma 41 thus cheapest possible way picking sets pick sets netweight w gammawtt incurring cost little costt netcost set picked since need pick netweight least zw gamma wtt would pick least 2z gamma 1 sets cost incurred least netcost netcost last inequality follows fact z 1 hence however contradicts upper bound sum costs sets gamma derived beginning case denote collection sets j 2 equation 2 yields netcost trappedcost netcost total netweight sets bounded using equation 1 follows netweight netweight last inequality follows fact netweight nonnegative cheapest way picking sets netweight least gammazw gamma wtt observation 72 set j netweight less w picked netsparsity least netsparsity hand observation 71 says could picking set netweight large w gamma wtt igamma1 2 netcost strictly larger netcost netcost netcost netweight netsparsity cheapest possible way picking sets pick sets netweight w gammawtt 2 incur netcost strictly larger netcost set picked since need pick netweight least gammazw gamma wtt igamma1 pick least gamma2z sets since z gamma1 total netcost sets strictly larger netcost contradicting upper bound derived beginning case thus established exists set j 2 meets weight requirement 2 cost costt j corresponds directed simple cycle g procedure finding 2 returns set cost less cost set meets weight requirement 2 corresponds directed simple cycle g hence therefore last inequality follows lemma 43 fact k gamma 1 w range 0 w suffices find g directed cycle necessarily simple minimum among directed cycles c w shortest cycle simple discard cycle consider w purpose computing ffl process discard cycle theorem separator found iteration within twice optimum else obtain simple cycle c w set corresponding cycle ffl finally deal case negative cycles h negative cycle h corresponds cycle c g w lemma 72 c cycle g w separator found iteration cost 2 delta costopt proof proof lemma along lines theorem 71 decompose c collection c directed simple cycles c side cycle smaller netweight let collection sets j one c j 2 c using decomposition rule gammaz delta costt trappedcost contradiction assume every j 2 satisfies weight requirement 2 cost costt observation 73 every set j 2 nonnegative netcost hence equation 4 yields z trappedcost trappedcost implies z 0 lower bound total netweight sets gamma obtained using equation 3 netweight beyond point argument almost identical case z 0 proof theorem 71 contradicts assumption every set j 2 meets weight requirement 2 cost costt proof theorem 71 2 picked iteration cost costt hence cost separator output lemma 72 need compute shortest paths graph h negative cycles finding 2 sets use raos algorithm 8 9 find 2 set let weight function vertices g th iteration b bbalanced bond g weights vertices given w find 2 need find minimumcost simple cycle g corresponds bbalanced bond g rao 8 9 gives algorithm finding minimum cost bbalanced connected circuit g connected circuit g set cycles g connected acyclic set paths intuitively connected circuit viewed simple cycle pinched portions corresponding paths cost connected circuit defined cost closed walk goes pinched portion twice cycle connected circuit g defines simple cut g vertices corresponding faces included cycles connected circuit form one side cut connectedcircuit bbalanced cut corresponding bbalanced note cost cut defined connected circuit sum costs cycles hence definition cost connected circuit upper bound cost underlying cut two equal connected circuit simple cycle notice 2 really need find minimumcost bbalanced bond g cut bbalanced cost minimumcost bbalanced bond serve purpose hence use raos algorithm find 2 total time taken raos algorithm obtain optimal bbalanced connected circuit cut 2 w 9 running time clearly algorithm terminates n iterations running time iteration dominated time find ffl iteration computing ffl involves single source shortest path computations graph 2 w vertices 2 w edges edge lengths may negative requires 4 w 2 log nw using johnsons extension allpairs shortest path algorithm floyd warshall hence total running time dotbox algorithm 5 w 2 log nw polynomial w polynomially bounded theorem 91 dotbox algorithm finds edgeseparator planar graph cost within twice optimum runs time 5 w 2 log nw w sum weights vertices dealing binary weights size graph compute shortest paths hence running time dotbox algorithm depends sum vertex weights using scaling make algorithm strongly polynomial however resulting algorithm pseudoapproximation algorithm sense compares cut obtained optimal cut better balance finally use scaling ideas extend algorithm park phillips fully polynomial approximation scheme finding sparsest cuts planar graphs vertex weights given binary thereby settling open problem 101 bbalanced cut let us scale vertex weights sum weights ffn ff 1 done defining new weight function process obtaining new weights viewed two step process first scale weights constant factor ffn w truncate first step affect balance cut since vertex weights scaled factor however second step could affect balance cut thus cut balance b weight function wt might worse balance wt since vertices side smaller weight might weights truncated however total loss weight due truncations n 1 vertex balance would worst total weight stays ffn drop truncations loss weight smaller side 1ff fraction total weight thus balance cut wt might b gamma 1ff worse similarly cut balance b wt might worse balance wt easy show similar argument wt balance worse let opt denote cost optimum bbalanced cut weight assignment wt since cut might b gamma 1ffbalanced wt use dotbox algorithm find b gamma 1ff balanced cut cost within 2opt cut returned algorithm b gamma 1ff balanced wt might b gamma 2ffbalanced wt thus obtain b gamma 2ffbalanced cut cost within twice optimum bbalanced cut theorem 101 ff 2b dotbox algorithm weight scaling finds b gamma 2ff balanced cut planar graph cost within twice cost optimum bbalanced cut b 1 2 n 7 log nff time 102 sparsest cut assume vertex weights planar graph g given binary let 2 p least power 2 bounds weight vertex let w sum weights vertices construct edge costs g g vertex weights assigned follows let ff positive integer ff determines approximation guarantee described vertices weights range 2 assigned original weight weight assigned weight 0 ie deleted graph weight 2 i2 log nff2 assigned weight 2 i2 log nff2 sparsest cut computed graphs using algorithm park phillips purpose computation weights vertices g divided 2 notice leaves weights integral total weight vertices o2 ff n 3 running time 7 2 w log nw w total weight vertices graph computation takes time off2 ff n 5 log w log n polynomial size input fixed ff sparsity cuts obtained computed original graph sparsest one chosen let optimal sparsest cut g let lighter side let weight let q weight heaviest vertex pick smallest integer lemma 102 cut found g cost weight least therefore cut sparsity within factor 1 sparsity proof algorithm park phillips searches cheapest cut weight choices weight 0 half weight given graph outputs sparsest cuts first notice choice given weight g say indeed set vertices whose weights 2 i2 log nff2 g satisfies weight drops factor hand set vertices containing vertex weight 2 i2 log nff2 g weight exceeding g therefore cut found g target weight 0 satisfies conditions lemma given choice ffi 0 pick smallest positive integer ff 1 get following theorem 103 algorithm gives fully polynomial time approximation scheme minimumsparsity cut problem planar graphs ffi 0 algorithm finds cut sparsity within factor 1 ffi optimal 1 log n time open problems several open problems remain 1 problem finding cheapest bbalanced cut planar graphs strongly nphard pseudopolynomial time algorithm 2 complexity finding minimum netsparsity cut planar graphs assuming vertex weights given unary 3 complexity finding ffl sets planar graphs assuming vertex weights given unary 4 algorithm given paper extended submodular functions 5 extended classes graphs particular notion transfer function extended classes graphs r framework solving vlsi graph layout problems dimer statistics phase transitions approximate maxflow mincut theorem uniform multicommodity flow problems application approximation algorithms separator theorem planar graphs applications planar separator theorem finding minimumquotient cuts planar graphs finding near optimal separators planar graphs faster algorithms finding small edge cuts planar graphs tr ctr eyal amir robert krauthgamer satish rao constant factor approximation vertexcuts planar graphs proceedings thirtyfifth annual acm symposium theory computing june 0911 2003 san diego ca usa
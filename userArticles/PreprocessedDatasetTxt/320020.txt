updates view maintenance soft realtime database systems database system contains base data items record model physical real world environment better decision support base data items summarized correlated derive views base data views accessed application transactions generate ultimate actions taken system environment changes updates applied base data subsequently trigger view recomputations thus three types activities base data update view recomputation transaction execution realtime system two timing constrains need enforced require transactions meet deadlines transaction timeliness read fresh data data timeliness paper define concept absolute relative temporal consistency perspective transactions address important issue transaction scheduling among three types activities two timing requirements met also discuss realtime database system designed enforce different levels temporal consistency b introduction realtime database system rtdb often employed dynamic environment monitor status realworld objects discover occurrences interesting events 15 10 2 3 example program trading application monitors prices various stocks financial instruments currencies looking trading opportunities typical transaction might compare price german marks london price new york significant difference system rapidly perform trade state dynamic environment often modeled captured set base data items within system changes environment represented updates base data example financial database refreshes state stock market receiving ticker tape stream price quote updates stock exchange better support decision making large numbers base data items often summa application transactions items dynamic environment monitor updates recomputations data views base figure 1 real time database system rized views example views financial database include composite indices eg sp 500 dow jones industrial average sectoral subindices timeseries data eg 30day moving averages theoretical financial option prices etc better performance views materialized base data item updated reflect certain external activity related materialized views need updated recomputed well besides base item updates view recomputations application transactions executed generate ultimate actions taken system transactions read base data views make decisions instance application transactions may request purchase stock perform trend analysis signal alerts even trigger execution transactions application transactions may also read static data knowledge base capturing expert rules figure 1 shows relationships among various activities realtime database system notice updates base data recomputations derived data may also run transactions eg acid properties cases refer update transactions recomputation transactions use term transaction alone referring application transaction application transactions associated one two types timing requirements transaction timeliness data timeliness transaction timeliness refers fast system responds transaction request data timeliness refers fresh data read closely time data read transaction models environment stale data considered less useful due dynamic nature data satisfying two timeliness properties poses major challenge design scheduling algorithm database system timing requirements pose conflicting demands system resources keep data fresh updates base data applied promptly also whenever value base data item changes affected derived views recomputed accordingly computational load applying base updates performing recomputations extremely high causing critical delays transactions either enough cpu cycles delayed waiting fresh data consequently application transactions may high probability missing deadlines paper study intricate balance scheduling three types activities updates recomputations application transactions satisfy two timing requirements data transactions goals ffl define temporal correctness perspective transactions ffl investigate performance various transaction scheduling policies meeting two timing requirements transactions different correctness criteria ffl address design issues rtdb temporal correctness enforced make right decision application transactions need read fresh data faithfully reflects current state environment desirable situation data items read transaction fresh transaction commits requirement however could difficult meet simple example transaction whose execution time 1 second requires data item updated every 01 seconds transaction hold read lock data item extensive period time new updates acquire write lock installed data item stale throughout transactions execution transaction cannot committed without using outdated data stringent data timing requirement also hurts chances meeting transaction deadlines let us consider simple example suppose data update interval changed 01 seconds 2 seconds scenario even though possible transaction completes without reading stale data 50 chance new update data arrives transaction executing insist nostaleread system transaction aborted restarted delay suffered transactions due aborts restarts subsequent waste system resources cpu data locks serious problem definition data timeliness thus needs relaxed accommodate difficult situations eg allowing transactions read slightly outdated data probably within predefined tolerance level discuss number options relaxing data timing requirement paper given correctness criterion need suitable transaction scheduling policy enforce example simple way ensure data timeliness give updates recomputations higher priorities application transactions abort transaction engages data conflict update recomputation policy ensures transactions commit using old data however giving application transactions low priorities severely lower chances meeting deadlines especially true updates thus recomputations arrive high rate investigate transaction scheduled balance contrary requirements data transaction timeliness rest paper organized follows section 2 discuss related works section 3 discuss properties updates recomputations application transactions particular discuss implications properties design transaction scheduler concurrency controller section 4 proposes three temporal correctness criteria section 5 list options transaction scheduling concurrency control support different correctness criteria section 6 define simulation model evaluate performance scheduling policies results presented section 7 conclude paper section 8 related works 2 load balancing issues updates transactions realtime database system studied system model updates come high rate transactions must committed deadlines authors propose several heuristics examine effectiveness maintaining data freshness sacrificing transaction timeliness point ondemand strategy updates applied required transactions gives best overall performance 3 balancing problems derived data views 1 updates transactions studied noted recomputations often come bursts obeying principle update locality authors propose forced delay approach delays triggering recomputation short period recomputations view object batched single computation study shows batching significantly improves performance rtdb two studies reported 2 3 closely related former studies updates transactions latter studies recomputation transactions however consider case updates recomputations transactions present also studies report likely temporal consistency maintained different scheduling policies discuss enforce consistency constraints paper consider various scheduling policies enforcing temporal consistency rtdb updates recomputations transactions coexist 13 song liu discuss data temporal consistency realtime system executes periodic tasks model tasks either sensor writeonly transactions readonly transactions update readandwrite transactions transactions must read temporally consistent data absolutely relatively order deliver correct results since multiversion databases shown offer significant performance gain singleversion ones authors propose evaluate two multiversion concurrency control algorithms lockbased optimistic studies 1 paper use terms views derived items interchangeably multiversion locking concurrency control twophase locking used serialize readwrite operations update transactions timestamps used locate appropriate versions read readonly transactions multiversion optimistic concurrency control update goes three phases read phase validation phase possible phase read phase transaction reads writes recent versions data workspace without locking data ready commit transaction enters validation phase conflicting update transactions found immediately aborted restarted transaction passes validation phase enters write phase new version object transactions local workspace becomes permanent system readonly transactions read recent committed version data go one phase read phase use multiversion techniques algorithms serve common purpose eliminating conflicts readonly update transactions readonly transactions always read committed versions without contending resources write operations hence readonly transactions never restarted costs concurrency control restart significantly reduced 3 updates recomputations transactions section take closer look properties updates recomputations application transactions discuss properties affect design realtime database system particular discuss concept update locality high faninfanout recomputations timing requirements transactions properties common many realtime database systems programmed stock trading many realtime database applications managing data input streams applying corresponding database updates represents nontrivial load system example financial database program trading applications needs keep track three hundred thousand financial instruments handle us markets alone system needs process 500 updates per second 5 update usually affects single base data item plus number related views high volume updates special properties writeonly append warrant special treatment rtdb particular executed full transactional support update treated separate transaction number transactions large system handle recall financial database may need process 500 updates per second application transactions also adversely affected resource conflicts updates proposed 3 better approach apply update stream using single update process depending scheduling policy employed update process installs updates specific order could linear firstcomefirstserved manner ondemand upon application transactions requests base data item updated views depend base item updated recomputed well system load due view recomputations even higher required install updates update involves simple write operation recomputing view may require reading large number base data items high fanin 2 complex operations 3 also update trigger multiple recomputations updated base item used derive number views high fanout one way reduce load due updates recomputations avoid useless work update useful value writes read transaction updates done inplace update base item b needs executed transactions request b another update b arrives similarly recomputation view needs executed transactions read view view recomputed savings however realized successive updates recomputations data view occur closely time call property update locality 3 fortunately many applications deal derived data exhibit property locality occurs two forms time space updates exhibit time locality updates item occur bursts space locality refers phenomenon base item b affects derived item updated likely related set base items affecting updated soon example changes banks stock price may indicate certain event interest rate hike affecting bank stocks occurred thus likely banks stock prices change updates could trigger recomputation say finance sectoral index example update locality found real financial data reported 3 update locality implies recomputations derived data occur bursts recomputing affected derived data every single update probably wasteful derived data recomputed soon often application transaction chance read derived data useful work instead recomputing immediately better strategy defer recomputations certain amount time batch coalesce recomputation requests single computation call technique recomputation batching application transactions may read base data derived views one important design issue rtdb system whether guarantee consistency base data views achieve consistency recomputations derived data folded triggering updates unfortunately running updates recomputations coupled transactions desirable high performance realtime environment makes updates run longer blocking transactions need access data indeed 4 shows transaction response time much improved events actions case updates recomputations 2 example sp 500 index derived set 500 stocks summary stocks price onehour interval could involve hundreds data points 3 example computing theoretical value financial option price requires computing cumulative distributions decoupled separate transactions thus assume recomputations decoupled updates discuss consistency maintained section 5 besides consistency constraints application transactions associated deadlines assume firm realtime system missing transactions deadline makes transaction useless detrimental system arbitrage trading example better commit tardy transaction since shortlived price discrepancies trigger trading actions disappear quickly todays efficient markets occasional losses opportunity catastrophic system important performance metric thus fraction deadlines rtdbs meets section 5 study number scheduling policies section 7 evaluate performance meeting deadlines 4 temporal correctness one requirements rtdb system transactions read fresh consistent data temporal consistency refers well data maintained rtdb models actual state environment 11 13 6 7 8 14 temporal consistency consists two components absolute consistency external consistency relative consistency data item absolutely consistent timely reflects state external object data item models set data items relatively consistent values reflect states external objects time instant one option define absolute consistency opp staleness compare current time updates arrival time timestamp indication snapshot external object update representing data item considered stale difference last updates timestamp current time larger predefined maximum age value also called absolute validity interval call definition maximum age 2 notice even data object change value must still periodically updated else become stale thus makes sense applications data items continuously changing time another option optimistic assume data object always fresh unless update received system yet applied data refer definition unapplied update uu uu suitable discrete data objects change discrete point time continuously 12 example program trading stock prices updated trades made periodically context age less meaning since price quote could old still correct uu general since arrival times updates assumed known advance figure 2 illustrates two staleness models base data item updated associated views recomputed yet database relatively consistent clear absolutely consistent database must also rel uu update becomes stale committed becomes stale new update request received new update committed item fresh update committed maximum age reached time time item fresh item fresh figure 2 maximum age unapplied update uu atively consistent however converse true example relatively consistent database never installs updates remains relatively consistent even though data stale ideal system performs updates recomputations instantaneously would guarantee absolute relative consistency however argued improve per formance updates recomputations decoupled recomputations batched hence real system often relatively inconsistent state fortunately inconsistent data harm transactions read hence need extend concept temporal consistency perspective transactions formally define notion transaction temporal consistency start definition ideal system first based correctness consistency real systems measured definition 1 instantaneous system instantaneous system applies base data updates performs necessary recomputations soon update arrives taking zero time definition 2 absolute consistent system acs absolute consistent system application transaction commit time readset r given values objects r set values found instantaneous system time last definition state absolute consistent system data never stale inconsistent states transactions read stale inconsistent data clear transactions given lower execution priority comparing updates recomputations example update recomputations triggers conflicts transaction certain data item transaction aborted maintaining absolute consistent system may thus compromise transaction timeliness better chance meeting transactions deadlines need upgrade priorities transactions priority upgraded two ways respect accessibility data cpu former transactions aborted updates due data conflicts latter transactions always scheduled execute updates recomputations start time time time commit figure 3 figure illustrates differences acs weak acs rcs suppose transaction reads objects execution maximum staleness delta let j th version object acs set objects read must 12 set values found commit time weak acs object versions read 11 found time earlier start time rcs object versions available 11 found time earlier 0 definition 3 weak absolute consistent system weak acs weak absolute consistent system application transaction start time readset r given values objects r set values found instantaneous system weak acs similar acs transactions systems read relative consistent data major difference weak acs data transaction reads need fresh point transaction reads transaction commits acs implication transaction successfully readlocks set relatively consistent data needs aborted later updates due data conflicts transaction thus better chance finishing deadline relax requirement data freshness allowing transactions read slightly stale data although desirable respect usefulness information read transaction improve probability meeting transaction deadlines definition 4 relative consistent system rcs relative consistent system maximum staleness delta application transaction start time readset r given values objects r set values found instantaneous system time 1 1 essentially rcs allows updates recomputations withheld benefit expediting transaction execution data absolute consistency compromised relative consistency maintained note consider weak acs special case rcs zero delta figure 3 illustrates three correctness criteria namely acs weak acs rcs transaction scheduling consistency enforcement section discuss different policies schedule updates recomputations application transactions meet different levels temporal consistency requirements argued data timeliness best maintained updates recomputations given higher priorities application transactions call scheduling policy urt update first recomputation second transaction last hand ondemand od strategy 2 updates recomputations executed upon transactions requests better protect transaction timeliness therefore focus two scheduling policies compare performance different temporal consistency requirements later discuss urt od combined odh policy simple terms od h switches urt od depending whether application transactions running system show odh performs better urt od section 7 policies assume relative priorities among application transactions set using traditional earliestdeadlinefirst priority assignment start brief reminder characteristics three types activities updates assume updates arrive single stream urt policy one update process system executing updates fcfs manner od could multiple update activities running concurrently one arrival new update others triggered application transactions distinguish latters formers labeling ondemand updates odupdates short recomputations update arrives spawns recomputations urt assume recomputation batching employed reduce systems workload 3 batching triggered recomputation goes sleep short newly triggered instances recomputation ignored od recomputations executed upon transactions requests hence batching applied ensure temporal consistency however recomputation induced update may perform bookkeeping processing even though real recomputation process executed immedi ately distinguish recomputations triggered ondemand transactions bookkeeping recomputation activities labeling ondemand recomputations odrecoms short application transactions finally assume application transactions associated firm deadlines tardy transaction useless thus aborted system scheduling involves prioritizing three activities respect accesses cpu data assume data accesses controlled lock manager employing hp2pl protocol high priority two phase locking 1 hp2pl lock holder aborted conflicts lock requester higher priority holder cpu scheduling complicated due various batchingondemand policies employed discuss scheduling procedure activity four scenarios scenarios correspond use urtod policy acsrcs consider wacs special case rcs hence explicitly discuss section 51 policies ensuring absolute consistency defined last section ac system requires items read transaction fresh relatively consistent transactions commit time toughest consistency requirement data timeliness 511 urt ensuring absolute consistency urt represents simpliest case among four sce narios since update process recomputations higher priorities application transactions general transactions executed unless outstanding updates recomputations done exception occurs recomputation forceddelayed batching case view updated recomputation temporarily outdated ensure transactions read outdated view recomputation issue write lock view spawned goes sleep since transactions given lowest priorities hp2pl lock manager sufficient ensure transaction restarted thus cannot commit data item base data view transactions read set invalidated arrival new update recomputation 512 od idea ondemand defer work updates recomputations application transactions get bigger share cpu cycles implement od system needs ondemand manager odm keep track unapplied updates recom putations conceptually odm maintains set data items x base view unapplied updates recomputations exist call set unapplied set x odm associates unapplied updaterecomputation od bit signifying whether odupdateodrecom x currently executing five types activities od system namely update arrival recomputation arrival odupdate odrecom application transaction list procedure handling type event follows ffl update recomputation arrival newly arrived updates recomputations highest priorities system 4 updaterecomputation p baseview item x first sent od manager odm checks x unapplied set x added set p associated write lock x requested 5 newly arrived updates recomputations handled fcfs manner 5 write lock set ensure ac since running transaction read outdated x restarted due lock conflict otherwise od bit checked od bit odm simply associates p x essentially replacing old unapplied updaterecomputation p od bit means odupdateodrecom x currently executing od manager aborts running odupdateodrecom releases p execution case update arrival view based x corresponding recomputation spawned new arrival ffl application transaction read request transaction reads data item x read request first sent od manager odm checks x unapplied set od bit ie odupdateodrecom run transaction waits otherwise odm sets od bit releases od updateodrecom associated x odupdateodrecom inherits priority reading transaction ffl release odupdateodrecom odupdateodrecom executes usual update recomputation transaction finishes however od manager notified remove updated item unapplied set 52 policies ensuring relative consistency major difficulty acs application transaction easily restarted updaterecomputation conflicts transaction rcs ameliorates difficulty allowing transactions read slightly outdated relatively consistent data rcs thus meaningful maintain multiple versions data item version records data value valid within window time validity interval notational convenience use numeric subscript enumerate versions data item example x represents th version data item x define validity interval item version x vi stand lower time bound upper time bound validity interval respectively given set item versions define validity interval vi dg set values valid throughout entire interval vi also denote arrival time update u tsu finally recomputation application transaction define validity interval vi time interval values read must valid within vi rcs needs version manager vm handle multiple versions data items function version manager twofold first retrieves given item x validity interval value version x valid within note multiple updates x interval version manager would choice valid version defer discussion version selection issue later second vm keeps track validity intervals transactions data versions read vm responsible changing transactions validity interval validity interval data version read transaction changes discuss vi management shortly finally note since every write base item view generates new version locks need set item accesses discuss veryold versions pruned away keep multiversion database small end section 521 urt similar acs three types activities urt rcs ffl update arrival mentioned version data item rcs associated validity interval update u data item version x arrives validity interval vi set tsu 1 also utb previous version x igamma1 set tsu signifying previous version valid till arrival time new update version manager checks sees running transaction read version x igamma1 sets utbvi ffl recomputation arrival update u spawns recomputation r view item whose latest version v j system first sets utb v j tsu version v j longer valid tsu onward similar case update arrival vm updates validity interval running transaction read v j batching recomputation r put sleep recomputations ignored new version v j1 computed r wakes execution r use newest versions data read set validity interval r vi r new view version vi v j 1 equal intersection validity intervals data items read r ffl running application transaction given transaction whose start time tst first set validity interval tst reads data item x consults version manager vm would select version x vi version x relatively consistent data already read updated vi vm cannot find consistent version ie vi aborted note wider vi likely vm able find version x consistent already read hence study always pick version x whose validity interval biggest overlapping 522 od applying ondemand rcs requires od manager version manager odm vm serve similar purposes described previously following modifications 6 recall delta maximum staleness tolerable reference transactions start time multiple versions data maintained od manager keeps base item x unapplied set list unapplied updates x ffl acs single version database unapplied recomputation view item v recorded odm transaction reads v knows current database version v invalid however rcs multiversion database validity intervals data items already serve purpose identifying right version version found database system knows odrecom triggered therefore odm rcs maintain unapplied recomputations ffl acs od bit data item x set odupdateodrecom currently executing update x od bit used new updaterecomputation arrival immediately abort useless odupdateodrecom rcs since multiple versions data kept necessary abort old useful odupdateod recom hence od bits used different versions data item appear database well unapplied list version manager needs communicate od manager retrieve right version either database triggering appropriate od update unapplied lists summarize key procedures handling various activities odrcs system ffl update arrival newly arrived updates highest priorities system handled fcfs update u base item x sent od manager unapplied update associated validity interval validity interval u set tsu 1 previous unapplied update u 0 x odm utb set tsu otherwise latest version x database utb set tsu similarly view item v depends x latest version database open utb ie 1 utb updated tsu changes data items utbs may induce changes transactions validity intervals version manger responsible updating transactions vis ffl running application transaction transaction start time tst validity interval initialized tst reads base item x vm would select version x valid within vi version unapplied odupdate triggered od manager odupdate inherits priority reads view item v vm would select version v j valid within vi version database found odrecom r compute v triggered odrecom inherits priority validity interval processed system way application transaction 523 pruning multiversion database rc system requires multiversion database od manager keeps multiple versions updates unapplied lists remark necessary system keeps full history online one way prune away old versions maintain virtual clock vc system define vc minimum start times running transactions minus delta versions database unapplied lists whose utbs smaller virtual clock pruned versions valid respect transactions validity interval thus never chosen version manager virtual clock updated release commit application transaction 524 hybrid approach od updates recomputations performed upon transactions requests transaction load low odupdates odrecoms executed database thus stale consequently application transaction may materialize quite number items intends read ondemand may cause severe delay transactions execution thus missed deadline simple modification od execute updates recomputations system idling way similar urt switch od transactions arrive call hybrid strategy odh 6 simulation study performance scheduling policies simulate rtdb system characteristics described sections 1 3 5 section describes specifics simulation model proceed discuss details model would like remark purpose simulation experiments study performance specific rtdb system uses urt ondemand instead aimed identify performance characteristics scheduling policies meeting different temporal consistency require ments practice rtdb system complex application transactions generated users extremely varied ranging ones short computation ones thousands operations recomputations simple aggregate functions ones require complex computational analyses model complexity results obscured many intricate factors impair understanding basic tradeoffs scheduling policies instead chose relatively simple model captures essential features scheduling problem observations made comprehensible simulation model implemented necessary components described section 5 include hp2pl lock manager update installer disk manager buffer manager od manager ondemand policy version manager rcs transaction manager handles priority assignment transaction aborts restarts recomputation batching transaction scheduling simulate diskbased database base items n derived items views number views base item derives ie fanout uniformly distributed range f derived item derived random set base items average values fanout fanin f f respectively assume system caches database accesses cache hit rate p cache hit updates generated stream update bursts burst arrivals modeled poisson processes arrival rate u burst consists burst size updates value burst size picked uniformly range bs min bs max model locality update would probability p sim triggering set recomputations triggered previous update urt policy recomputations batched recomputation delayed fd seconds execution instances recomputation ignored application transactions generated another stream poisson processes arrival rate transaction consists number readwrite operations database object equal probability accessed operation transaction performs n op database operations transaction associated deadline given following formula ext expected execution time transaction 7 art arrival time slack slack factor simulation slack uniformly chosen range min max values simulation parameters chosen reasonable values typical financial application possible performed sensitivity analysis key parameter values simulator written csim simulation run generating one data processed 10000 update bursts table 1 shows parameter settings baseline experiment 8 7 calculated multiplying number operations amount io cpu time taken operation 8 chose relatively small database 3000 base items model hot items data items frequently updated cause recomputations practice database would many cold items well get updated occasionally trigger recomputations done experiments modeling cold items since results show similar conclusion simple model explicitly model cold items paper assume highend disk seagate st39103lc includes time perform data locking memory accesses cpu computation assume transactions perform complex data analysis performed financial expert system description parameter value update burst arrival rate sec u 12 burst size bsmin bsmax forced delay time sec fd 10 update similarity p sim 08 transaction arrival rate sec 20 operations per transaction n op 50 slack factor min number base items n b 3000 number derived items n 300 fanout f disk access time ms io 50 time per operation ms cpu 10 io cache hit rate p cache hit 07 maximum staleness sec delta 100 table 1 baseline settings 7 results section present selected results obtained simulation experiments compare performance various scheduling policies acs rcs based well meet transaction deadlines aid discussion use notation md b represent fraction missed deadlines miss rate scheduling policy applied b system example md ac means 10 transactions miss deadlines od used acs also graphs presented consistently use solid lines acs dotted lines rcs three scheduling policies urt od odh associated different linepoint symbols 71 absolute consistent system effect transaction arrival rate first experiment vary transaction arrival rate 05 5 compare performance three scheduling policies urt od odh absolute consistent system figure 4 shows result figure see large range 10 urt performs worst among three missing 14 26 deadlines three major factors account urts high miss rate first since transactions lowest priorities executions often blocked updates recomputations terms cpu data accesses causes severe delays thus high miss rates transactions call factor low priority second urt recomputation batching recomputation immediately executed arrival forced sleep short holds write lock derived item say v updates transaction requests item v experience extended delay transaction miss rate arrival rate application transactions urtacs odacs odhacs figure 4 miss rate vs acs5152502 04 06 08 1 12 14 16 transaction miss rate arrival rate update bursts urtacs odacs odhacs figure 5 miss rate vs u acs blocked sleeping recomputation call factor batching wait third acs transaction restarted update recomputation whenever data item transaction read gets new value restarted transaction loses slack risks missing deadline similarly recomputation restarted update engage data conflict restarting recomputations means adding extra high priority workload system urt intensifies low priority factor causes missed deadlines call restart factor transaction restart 9 experiment result observe average restart rate transactions due lock conflicts 2 3 recomputations 05 remark even though restart rate recomputations high effect could significant since recomputations general numerous long using ondemand approach transactions given fair share cpu cycles disk services hence od effectively eliminates low priority factor also recomputations executed ondemand hence batching wait exist results smaller miss rate baseline experiment figure 4 see md ac od smaller md ac urt 10 improvement 5 large good lower expected argued od removes two three adverse factors urt moreover interesting see transaction arrival rate small 10 reducing transaction workload ie reducing actually increases md ac od reason anomaly lowerthanexpected improvement pure od policy updates recomputations executed transaction requests hence small total number ondemand requests small many database items therefore stale transaction executes quite items reads outdated thus odupdatesodrecoms triggered transaction blocked waiting ondemand requests finish causes long response time thus high miss rate evidence figures 6 7 show numbers odupdates odrecoms per transaction respectively see many 12 updates 35 recomputations triggered 9 transaction recomputation restart would precise term however use shorter form save space od updates per transaction arrival rate application transactions odacs odhacs figure number odupdates per transaction od recomputations per transaction arrival rate application transactions odacs odhacs figure 7 number odrecoms per transaction blocking average transaction od policy call adverse factor od wait order improve ods performance database kept fresh ondemand requests issued one simple approach apply updates recomputations urt transactions present transaction arrives however datesrecomputations suspended system reverts ondemand call policy odh odh thus considered hybrid od urt figure 4 shows odh greatly improves performance od particular anomaly higher miss rate lower transaction arrival rate exhibited od vanishes odh improvement attributable small number ondemand requests figures 6 7 effect od wait thus relatively mild problem transaction restart however still exists odh applied acs effect update arrival rate another experiment vary update arrival rate figure 5 shows result see larger u causes missed deadlines scheduling policies updates implies higher update load recomputations directly intensifies effects low priority batching wait transaction restart also higher update rate causes data items become stale faster worsen effect od wait hence policies suffer among three md ac urt increases rapidly u since affected three factors contrary odh suffers least since mainly affected transaction restart effect slack next experiment tests sensitivity three policies transaction slack figure 8 shows miss rates versus maximum slack max figure see slack tight eg od rises sharply smax decreases recall od suffers transaction runs stale data case transaction wait od requests finish od wait thus important transaction given enough slack live wait words od sensitive amount slack transactions order improve ods performance key keep database fresh possible eg odh figure 8 see odh maintains small miss rate relatively unrattled even small slack situation transaction miss rate maximum slack urtacs odacs odhacs figure 8 miss rate vs max acs 72 relative consistent system previous discussion illustrates acs urt suffers three adverse factors namely low priority batching wait transaction restart three factors lead high md ac urt switching urt od eliminate low priority batching wait introduce od wait show hybrid approach odh greatly reduce effect od wait see figures 6 7 hence culprit left tackle transaction restart mentioned section 52 rcs uses multiversion database update recomputation creates new data item version thus cause writeread conflicts transactions transaction therefore never gets restarted data conflict updatesrecomputations cases transaction abort due data accesses occur urt version manager could find materialized data version consistent vi transaction requesting item experiment observe chances aborts small eg 01 transactions aborted baseline experiment urt ondemand strategies would perform aborts since data version materialized ondemand result rcs effectively eliminates problem transaction restart figure 9 shows miss rates three scheduling policies rcs dotted lines comparison miss rates acs solid lines also shown figure 10 magnifies part containing curves md ac odh md rc odh clarity figures see fewer deadlines missed rcs acs across board problem transaction restart eliminated rcs among three policies urt registers biggest improvement transaction reads derived item choose old materialized version thus never wait sleeping recomputation wake calculate new version item batching wait therefore exist rcs hence two three detrimental factors plague urt gone leading much smaller miss rate transaction miss rate arrival rate application transactions urtacs odacs odhacs urtrcs odrcs odhrcs figure 9 miss rate vs acs rcs13570 transaction miss rate arrival rate application transactions odhacs odhrcs figure 10 miss rate vs md ac odh md rc od updates per transaction arrival rate application transactions odrcs odhrcs figure 11 number odupdates per transaction od recomputations per transaction arrival rate application transactions odrcs odhrcs figure 12 number odrecoms per transaction rcs od see improvement achieved rcs big case urt although transaction restart eliminated problem od wait fixed figures 11 12 show numbers odupdates odrecoms per transaction respectively rcs compare curves figures 11 12 figures 6 7 see od average transaction triggers less number od requests two systems recall transaction would issue od request attempts read notyetmaterialized data item acs item one latest version transaction forced issue od request latest version yet updated hand rcs item multiple versions transaction avoid issuing od request find materialized version within transactions validity interval theory fewer od requests issued rcs acs unfortunately pure od policy actively perform updates recomputations hence data versions materialized transactions read effect od wait therefore get improved discussed effect od wait strongest transactions scarce figure 9 see md rc od much higher md rc urt small last subsection explained odh reduces transaction miss rate avoiding three four adverse factors faced urt od figure 10 shows performance odh improved rcs eliminating transaction restart essentially applying odh rcs system rid adverse factors discussed md rc odh close 0 except big transaction arrival rate high missed deadlines caused mainly cpu disk queueing delays figure 10 see improvement md rc odh md ac odh significant example half deadlines missed acs salvaged rcs percentage saved deadlines rcs even marked small conclusions paper defined temporal consistency perspective transactions absolute consistent system transaction cannot commit data reads become stale transactions commit time showed consistency constraint strict often results high transaction miss rate transactions allowed read slightly stale data however systems performance greatly improved use multiversion database defined relative consistent system one transaction reads relatively consistent data items items certain threshold delta older transactions start time argued relative consistent system higher potential meeting transaction deadlines studied three scheduling policies urt od odh system three types activities updates recomputations application transactions present discussed policies implemented realtime database system ensure absolute consistency relative consistency showed acs using urt easiest implement hp2pl lock manager simple static prioritydriven scheduler suffice system however could high transaction miss rate improve performance two techniques considered one perform updates recomputations ondemand relax temporal consistency constraint absolute relative implementing techniques add complexities implementation though example ondemand manager needed od version manager needed rcs showed pure ondemand strategy perform well system transactions arrive low rate tight deadlines improve pure od policy third technique combining benefit urt od studied resulting scheduling policy odh shown perform much better others carried extensive simulation study performance three scheduling policies acs rcs identified four major factors adversely affect performance policies factors low priority batching wait transaction restart od wait different policies coupled different consistency systems suffer different combinations factors table 2 summarizes result performance acs rcs urt od odh urt od odh low priority theta theta batching wait theta transaction restart theta theta theta od wait theta theta table 2 factors cause missed deadlines study showed odh applied rcs results smallest miss rate r scheduling realtime transactions performance eval uation applying update streams soft realtime database system database support efficiently maintaining derived data transaction boundaries active databases performance perspective multidatabase system tracking retrieval financial data predictability consistency realtime database systems ssp semanticsbased protocol realtime data access survey logical modeling temporal data maintaining temporal consistency pessimistic vs optimistic concurrency control scheduling transactions temporal constraints exploiting data semantics tr realtime databases realtime databases predictability consistency realtime database systems applying update streams soft realtime database system temporal realtime databases maintaining temporal consistency database support efficiently maintaining derived data scheduling realtime transactions multidatabase system tracking retrieval financial data scheduling transactions temporal constraints ctr kamyiu lam guo hui li teiwei kuo multiversion data model executing realtime transactions mobile environment proceedings 2nd acm international workshop data engineering wireless mobile access p9097 may 2001 santa barbara california united states ben kao kamyiu lam brad adelberg reynold cheng tony lee maintaining temporal consistency discrete objects soft realtime database systems ieee transactions computers v52 n3 p373389 march kamyiu lam teiwei kuo ben kao tony h lee reynold cheng evaluation concurrency control strategies mixed soft realtime database systems information systems v27 n2 p123149 april 2002
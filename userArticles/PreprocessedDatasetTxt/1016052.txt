parametric search made practical paper show sortingbased applications parametric search quicksort replace parallel sorting algorithms usually advocated simplicity quicksort may lead applications parametric search efficient theory practice well also argue coles optimization certain parametricsearch algorithms may unnecessary realistic assumptions input furthermore present generic flexible easytouse framework greatly simplifies implementation algorithms based parametric search use framework implement algorithm solves frchetdistance problem implementation based parametric search faster binarysearch approach often suggested practical replacement parametricsearch technique b introduction since late 1980s parametric search optimization technique developed megiddo late 1970s early 1980s 15 16 become important tool solving many geometric optimization queries efficiently main principle parametric search compute value l optimizes objective function f use algorithm solves corresponding decision problem decision problem stated follows given value l decide whether l l l l l l idea run generic version unknown value l generic algorithm uses concrete version determine outcome decision problem set concrete values one values l report l l explain technique detail section 2 usually applying concrete version expensive terms running time megiddo shows using parallel version p generic algorithm may reduce number times called considerably technique rather complicated requires design efficient parallel algorithm fortu nately generic algorithm necessarily solve problem concrete decision several cases sorting used instead 3 8 11 13 16 however existing parallel sorting algorithms good worstcase time bounds easily implemented cases hidden constants asymptotic running times enormous 2 cole 9 shows sortingbased parametric search optimized even optimization comes expense making technique even complicated already paper show quicksort used generic algorithm sortingbased parametric search instead parallel sorting algorithmsee section 3 coles optimization cannot applied case section 4 demonstrate certain assumptions seem reasonable practice coles optimization needed attain efficient algorithm two observations considerably simplify practical application sortingbased parametric search nevertheless implementing algorithms based parametric search remains challenging task one completely scratch therefore implemented objectoriented framework parametric search c takes care difficult parts technique using framework implementing algorithms use parametric search becomes substantially easier applications even becomes nearly trivial framework smallit consists eight classes four research supported dutch technology foundation stw project uif 5055 shame shape matching environ ment directly visible user four classes small number member functions interface easy use framework described section 5 based parametricsearch framework implemented quicksort bitonic sort way used generic algorithm sortingbased applications parametric search two sorting algorithms applied two problems first one problem finding intersection median function set monotone increasing linear functions xaxis problem used megiddo explain technique 16 used preliminary example many papers parametric search second one frechetdistance problem 3 give details applications section 6 experimental results presented section 7 indicate application parametric search indeed result algorithms efficient practice fact simple binarysearch approach often advocated practical replacement parametric search outperformed quicksortbased algorithm frechet distance problem preliminaries megiddos parametricsearch technique 16 works follows assume decision problem p l monotonous l ie p l 0 true p l true l l 0 task find l maximum value l p l true suppose algorithm solves decision problem p determine input value l whether l l l l l l also suppose flow control depends comparisons depends sign polynomial l megiddos idea run generically unknown input l may seem strange run algorithm unknown input outcome namely verification input equal l already known however get know actual value l byproduct running l generic execution maintain open interval l known lie initially whenever comparison resolved need determine sign polynomial p value l done without knowing value l running concrete version roots p determines location l among roots ie either gives us two consecutive roots r r i1 r l r i1 find one roots l latter case done abort execution generic algorithm otherwise since sign polynomial doesnt change two consecutive roots determine sign pl evaluating polynomial p value x 2 r determines outcome comparison updating r resume generic execution execution gets progressively smaller either run completion ending final interval find l prematurely abort execution many applications parametric search l one roots associated comparisons never run completion cases cases medianoflines example megiddo used explain technique 16 structure problem restricted final interval simple value l easily computed given denote running time number comparisons made c cost running parametric search described oc improved computing r really recall p l monotonous p l 0 true p l true l l 0 symmetrically p l 0 false p l false l l 0 means somehow batch k comparisons resolve associated roots follows find median lm roots using lineartime medianfinding algorithm compute l determines outcome decision problem half roots recursively deal remaining roots follows number roots associated comparison bounded constant resolve k batched comparisons binarysearch fashion ologk calls note able batch comparisons independent outcome one comparison batch depend outcome another comparison batch megiddo 16 therefore suggests replace generic algorithm parallel version p since operations one parallel step usually independent p uses p processors runs p parallel steps use binarysearch approach resolve comparisons parallel step total cost parametric search opt p p logp usually running time dominated second term note dont actually run p parallel architecture parallelism simulated irrelevant important point ability collect preferably large batches comparisons order reduce number calls concrete decision algorithm therefore weak model parallelism parallel comparison model valiant suffices model complexity algorithm determined comparisons made things like communication synchronization processes ignored cole 9 shows applications parametric search number calls decision process reduced logfactor thus improving running time opt p p logp explain idea comment section 4 one drawbacks parametric search mentioned agarwal sharir 1 requires design efficient parallel algorithm generic version decision problem always easy however instructive point generic algorithm necessarily solve problem concrete version required output generic algorithm changes combinatorially l quite cases sorting play role generic algorithm see instance spanning tree scheduling problems studied megiddo 16 slopeselection problem 11 frechetdistance problem 3 bottleneckdistance problem 13 problem finding minimum hausdorff distance rotation rotation two sets points lines polygons 8 several cases generic algorithm consists several steps sorting one 17 19 sortingbased parametric search several parallel sorting algorithms disposal first sorting algorithm sorts ologn parallel steps using processors sorting network ajtai et al 2 usually referred aksnetwork used parametric search leads running time onlogn log 2 n onlogn logn coles optimization 9 applied however many researchers commented algorithm rather complex constants hidden onotation large practical use often suggested use suboptimal parallel sorting algorithm instead valiants merge sort 21 runs olognloglogn parallel steps using processors less commonly known two sorting algorithms cole 10 time bounds aksnetwork also use processors one algorithms works crewpram model parallel computation constants running time small however meet conditions applying coles optimization 9 one works erew pram model complex first algorithm coles optimization applied fact parallelism requirement resolving roots binarysearch fashion suffices able collect roots associated independent comparisons small number batches paper show quicksort quite surprisingly meets requirements leads considerable simplification sortingbased parametric search yielding expected running time onlogn n see section 3 coles optimization cannot applied also show certain conditions seem unlikely practical situations expected running time parametric search opt logp even without coles optimization quicksortbased parametric search means expected running time onlognt logn conditions explain section 4 met parametricsearch always popular theoreticians practitioners parametric search applied right problems often leads asymptotic running times order magnitude better alternatives often advised using technique practice reason negative advice usually twofold firstly since parametric search complicated technique believed implementing must also complicated hard knowledge technique implemented twice first time toledo 20 applies medianoflinesproblem megiddo gave simple illustration parametric search 16 slope selection problem 11 second implementation know schwerdt et al 19 implement algorithm finding minimum diameter set moving points gupta et al 14 second reason parametric search hardly ever used practice generally assumed overhead involved ie hidden constants onotation large practical use partly presumed difficulties parametric search alternatives proposed many specific problems see instance agarwal sharir 1 chan 7 however parametric search currently still general method would like counterbalance advice avoiding parametric search realworld applications making observations considerably simplify sortingbased parametricsearch sections 3 4 providing framework takes care much difficulties parametric search whether sortingbased section 5 quicksortbased parametric search sortingbased parametric search always relied parallel sorting algorithms batching comparisons megiddo 16 suggests parallel sorting algorithms valiant 21 preparata 18 authors propose using aksnetwork 2 derive running times asymptotically faster cole 9 originally applies optimization technique aksnetwork later paper 10 gave two parallel sorting algorithms asymptotic time bounds aksnetwork much smaller constant factors hidden onotation paper show quicksort used generic algorithm sortingbased parametric search need use parallel version quicksort serial version suffices able batch comparisons complete description analysis quicksort see introductory textbook algorithms instance one cormen leiserson rivest 12 short quicksort sorts input array elements 1 less two elements return 2 otherwise choose a1 pivot element 3 partition two subarrays containing elements smaller pivot containing elements greater equal pivot element 4 recursively sort quicksort worstcase running time wn 2 fact input almost sorted running time indeed quadratic input size attain onlogn expected running time randomization employed either randomly permuting input choosing random element array pivot element step 2 quicksort simple wellknown practice usually outperforms sorting algorithms deterministic onlogn running time third step algorithm usually performed maintaining two pointers one initially points first element array moves toward higher elements element e found greater equal pivot element pointer initially points last element array moves toward lower elements element e j found less pivot element e comes e j array swapped process continues pointers pass observe step three algorithm comparisons elements array inde pendent compare elements pivot element implies use quicksort parametricsearch setting collect comparisons step three resolve binarysearch fashion megiddo suggested 16 comparisons third step resolved actual partitioning described previous paragraph make quicksortbased parametric search efficient would like collect comparisons recursive calls recursion level l single batch rather resolving o2 l separate batches trivial replace recursion iteration maintain list pointers subarrays initially list contains one array namely input array iterative step first collect comparisons subarrays ie subarray compare elements subarray pivot element subarray resolve binarysearch fashion next partition subarray described doubles size list subarrays list remove subarrays size 1 proceed next iteration employ randomization either randomly permuting input first step algorithm choosing random element subarray pivot element expected number iterations ologn iteration work total number calls algorithm solves p ologn iteration follows use quicksort generic algorithm sortingbased parametric search running time onlogn seems possible apply coles optimization 9we cannot partition subarray comparisons subarray resolvedand therefore cannot reduce running time onlognt logn however next section show certain conditions seem reasonable practice running time closer onlogn logn onlogn log 2 n evidently using quicksort generic algorithm sortingbased parametric search considerably simplifies implementation also since quicksort proved efficient practice expected lead faster algorithms complicated parallel algorithms larger constant factors running time used note batching comparisons prerequisite parametric search without batching quicksort serial sorting algorithms also used generic algorithm sortingbased parametric search cost much higher running time fact toledo20 gives implementation nonbatched quicksortbased parametricsearch algorithm apart version uses valiants parallel merge sort21 however observation quicksort used batch comparisons makes implementing optimized versions parametric search considerably easier 4 coles optimization revisited cole 9 shows cases running time parametric search reduced opt p logp opt p p logp optimization technique works follows instead resolving batch op roots ologp calls binarysearch fashion requires roots sorted first find median root r done linear time call r determines outcome decision problem half roots assume moment comparisons made generic algorithm depend one root single call outcome half comparisons depend roots batch known parallel processes depend comparisons resumed lead new comparisons associated roots roots joined first batch half number roots resolved far process repeats finding median root cole shows roots weighted according clever scheme weighted median finding algorithm used number calls reduced logfactor technique still works comparisons depend constant number roots rather single root drawbacks technique cannot generally applied imposes conditions parallel algorithm also makes generic algorithm complicated experiments see section 7 apply coles optimization resolved batch roots ologp steps megiddos original paper 16 noticed number calls decision process indeed growing input size yet much less expected attributed maintenance progressively smaller interval l known lie recall resolving batch roots either gives us value l namely l one roots end interval roots one batches processed far none roots batches lie inbetween r k r l resolve next batch roots disregard roots lie interval outcome decision process roots already known hence binary search roots intuitively since interval gets smaller rootsresolving step consider fewer fewer roots algorithm progresses let us assume moment roots uniformly distributed batches number batches processed algorithm 0 megiddos setting number parallel steps generic algorithm step 0 interval gives bounds l call ologp times resolve decision process roots binarysearch fashion beginning step 1 outcome p r roots r batches solved steps 0 1 known total number roots p furthermore interval maintain bound two consecutive roots r k r l set p roots since number roots call step p expected number roots step lie inside r 1i assumption roots uniformly distributed k call roots lie r k r l instead binary search expected total number calls summed steps 1 1i ologm follows expected running time parametric search opt p logp p since p number parallel steps generic algorithm usually smaller p number processors opt p logp quicksort get expected running time onlognt logn course cannot generally assume roots uniformly distributed batches may case step 1 roots step lie inside interval results previous steps means binary search roots however seems us many practical situations extreme situation unlikely occur expect practice distribution roots batches sufficiently uniform benefit maintaining bounds l use quicksort generic algorithm randomly permuting input preprocessing step may even help respect although still doesnt give guarantees however experiments quicksortbased parametricsearch solution frechetdistance problem show bulk invocations decision algorithm indeed done first 10 30 iterations see section 7 5 parametricsearch framework batching comparisons isnt always possible necessary applications parametric search applicable usually reduces number calls decision process order magnitude time also makes implementing algorithms based parametric search difficult disrupts normal flow control suppose example function f pseudoc code figure 1 1 void f 2 int j k 3 4 g1i g2j g3k call ref 5 jk 6 7 figure 1 original code assume want execute code parametricsearch setting comparisons made functions g1 g2 g3 mutually independent naturally would like batch similarly assume comparisons made h1 h2 h3 independent also want batch however latter three functions depend variable turn depends results three functions line 4 cannot collect resolve comparisons six functions lines 4 6 single batch instead starting execution g1 collect comparison suspend execution g2 g3 resolve comparisons collected far resume execution three functions next execute statement line 5 get another round starting functions collecting comparisons suspending execution resolving comparisons resuming execution time functions line 6 gets even cluttered want simulate parallelism ie order execution functions line 4 arbitrary well order execution functions line 6 parametricsearch framework takes care starting suspending resuming functions collecting resolving comparisons framework consists small hierarchy c classes user needs interact four classes number functions public interface classes small four classes named scheduler processbase comparisonbase root respectively idea functions need started suspended resumed turned objects userdefined class derived processbase call objects processes note however unrelated processes operating systems instead regular c objects similarly comparisons implemented user deriving comparisonbase let us give example transforming code collection classes see figure 2 code incomplete simplified shows important principles transformation straightforward functions perform independent comparisons three functions line 4 figure 1 correspond dynamically created objects creation independent objects done single member function lines 37 figure 2 similarly code lines 5 6 1 class procf public processbase 2 public 3 void memfun1 4 spawn new procg1i 5 spawn new procg2j 6 spawn new procg3k 7 8 9 void memfun2 11 spawn new proch1i 12 spawn new proch2i 13 spawn new proch3i 14 15 16 private member variables 17 int j k 18 figure 2 transformed code figure 1 translated lines 914 figure 2 finally local variables original code correspond member variables transformed code two member functions memfun1 memfun2 registered framework constructor procf shown processes procf processes creates also registered framework done automatically spawn function takes care linking child processes parent process processes created executed immediately scheduler decides process started time procf figure 2 scheduler tells execute first registered member function memfun1 result three new processes created executed immediately memfun1 finished procf suspended scheduler selects processes run including child processes procf child processes spawned procf finished commanded scheduler resume execution starting next registered member function memfun2 member functions procf deleted scheduler processes spawn processes comparisons objects userdefined class derived comparisonbase comparisons turn spawn objects class root scheduler takes care resolving roots binarysearch fashion signaling comparisons associated roots resolved outcome comparison determined starting suspending resuming terminating processes comparisons details found reference manual tutorial come software see cgal extension package section httpwwwcgalorg hope show means simple code examples brief explanation simplicity framework user needs knowledge inner workings framework simple transformation similar one code shown figure 1 code shown figure 2 naturally complicated constructs also translated instance iteration expressed member functions register framework finished task recursion expressed process spawn another process class generic algorithm run l unknown solution optimization problem certain cases replaced sorting simplify implementation parametric search even cases provide implementations two sorting algorithms first one bitonic sort parallel sorting network batcher 4 uses processors sort n input items olog 2 n parallel steps implementation bitonic sort uses parametricsearch framework simulate parallelism resolve comparisons batches second sorting algorithm quicksort also use framework collect resolve comparisons partitioning step prior actual partitioning see section 3 using framework sortingbased parametric search requires user implement following classes functions 1 class function computes items sorted input input may consist items 2 class derived comparisonbase computes roots associated comparison two items determine outcome comparison solution decision problem p known roots 3 class function solves decision problem furthermore user specify whether use bitonic sort quicksort decide number type used calculations parametricsearch framework two sorting algorithms design philosophy cgal 5 library algorithms computational geometry framework doesnt depend cgal two cooperate well consider important since goal use framework implementing algorithms solve geometric optimization problems fact plan make framework available cgal extension package 6 applications using framework two sorting algorithms implemented two algorithms apply sorting based parametricsearch first one solves medianoflines problem megiddo gave simple illustration parametric search 16 motivation implementing algorithm gives simple means testing framework time enables us easily explain framework tutorial second algorithm implemented one alt godau 3 computing frechet distance two polygonal curves discuss briefly illustrate framework used usual informal illustration frechet metric following suppose man walking dog keeping leash man walking polygonal curve p dog polygonal curve q allowed control speed may nonnegative value ie allowed stop cannot go back frechet distance p q minimal length leash necessary two following definitions alt godau 3 characterize frechet metric formally definitions v denotes arbitrary euclidean vector space curve continuous mapping f b v ab 2 ir b polygonal curve length n curve n p jii1j affine ie pi curves f f g denotes frechet distance defined ab range continuous increasing functions let p q polygonal curves n edges respectively alt godau first show solve case simple line segments lg f l called free space shown figure 3 cited alt godau 3 together p q l proven distance measure two points either polygonal curve euclidean intersection f l unit square ellipse f l l figure 3 p q l f l definition f l extended arbitrary polygonal curves p q n edges respectively f l fs lg figure 4 also cited alt godau shows example two polygonal curves 6 4 segments l figure 4 diagram polygonal chains p q given l algorithm decision problem based observation given two polygonal curves p q f pq l exactly curve within corresponding f l 00 mn monotone directions critical values decision process coordinates intersections ellipses boundaries squares diagram see figure 4 since number intersections constant square omn critical values depend l input parameter decision problem fact polynomials p l index ranges omn possibilities alt godau show l l either two critical values row two critical values column diagram value cases need considered ignore simplicity means sortingbased parametric search used find frechet distance p l adjacent polynomials sorting therefore sorting algorithm compare p p j otherwise order p p j cannot known comparison involves computation roots p one roots l first c class implement solves decision problem takes effort isnt overly complicated given l compute intersections ellipses boundaries squares diagram subsequent step determine path 00 mn within f l monotone directions see paper alt godau 3 details items sorted intersections ellipses boundaries squares diagram p q polynomials input parameter l decision process second class implement computes omn polynomials p q tell framework use class retrieve input sorting algorithm finally third class implement compares two polynomials derived comparisonbase two polynomials p p j compared computing roots p p j roots collected framework resolved binarysearch fashion outcome decision process roots p p j known framework tells comparison class determine outcome comparison p p j done evaluating p p j arbitrary value interval l known lie interval guaranteed contain roots p p j time framework tells comparison class determine outcome comparison three classes need implement solve optimization problem ie compute frechet distance p q test results implementation presented next section decision problem considers omn critical values solved omn time use quicksort generic sorting algorithm expected number calls decision process assumptions distribution roots olog 2 mn expected overhead sorting omnlogmn total expected running time omnlog 2 mn however distribution roots subsequent steps algorithm sufficiently random may expect running times closer omnlogmn showed section 4 7 experimental results tested algorithm computing frechet distance two polygonal curves n vertices f163264128g polygonal curves created generating 2n random points unit square computed frechet distance running sortingbased parametric search algorithm described previous section bitonic sort quicksort used generic sorting algo rithm first number type used long double means didnt get exact answer approximation also computed approximation binary search values representable long double often suggested alternative parametric search since long double 96 bits sys tem expected number calls decision process would also 96 reality found much higher number iterations explained fact distance two consecutive numbers representable long double much smaller around 0 around large positive negative values fact possible binary search bits long double rather implementing efficient binary search simply computed running time 96 iterations actual running time number iterations computation possible since overhead methods binary search negligible almost time spent decision process three algorithms run randomly generated input input size repetitions results presented table 1 running times binary search normalized 96 iterations described experiments done pc 667 mhz pentium iii processor 128 mb memory running linux nearly cases quicksort faster two methods one repetitions input size 32 however running time high 0511 seconds compared 0088 seconds secondhighest running time may due fact quicksort expectedcase performance onlogn worstcase performance 2 bitonic sort quicksort framework aborts sorting l found root number times actually happens listed table binary search method also stop encounter l however difference smallest highest number iterations less 2 percent also tested frechetdistance algorithms using ledareal 6 number type provides exact relational operators 6 closed addition subtraction multiplication division computation kth roots exact comparisons ledareal generally efficient times expensive especially two complicated expressions compared actually equal first trials polygonal curves less 10 vertices running times measured hours simplifying arithmetic expressions decision process reduced running times minutes polygonal curves 16 vertices still consider slow see lot possibilities optimizations specifically maintaining extra information data structure decision algorithm avoid comparison expressions know equal prioriand comparisons expensive verify assumption maintenance progressively smaller interval bounds l results fewer fewer invocations decision algorithm generic algorithm progresses sec tion 4 recorded number calls iteration quicksortbased frechetdistance algorithm randomly generated input size turned cases without early abort invocations decision algorithm done first 1030 iterations recall implemented iterative rather recursive version quicksort see section 3 input size method min avg max times aborted quicksort binary search 0013 0014 quicksort binary search 0061 0072 0084 quicksort 0122 0409 0518 26 binary search 0671 0685 0693 128128 bitonic sort 0663 6042 7469 29 quicksort 0729 1864 2407 29 binary search 2704 2769 2810 table 1 test results frechetdistance algorithms times seconds concluding remarks paper observed quicksort may used efficiently implement algorithms use sorting based parametric search also argued coles optimization 9 may needed certain conditions seem reasonable practice presented framework allows users implement various applications parametric search simple efficient way two sorting algorithms provide framework used generic algorithm sortingbased parametric search especially quicksort performs well quicksortbased implementation algorithm alt godau 3 gives better result simple binarysearch approach r efficient algorithms geometric optimization sorting clogn parallel steps computing frechet distance two polygonal curves sorting networks applications applications generic programming paradigm design cgal leda class real number geometric applications randomized optimization technique geometric pattern matching euclidean motion slowing sorting networks obtain faster sorting algorithms parallel merge sort optimaltime algorithm slope selection introduction algorithms improvements bottleneck matching related problems using geometry fast algorithms collision proximity problems involving moving geometric objects combinatorial optimization rational objective functions applying parallel computation algorithms design serial algorithms labeling points rectangles various shapes new parallelsorting schemes computing minimum diameter moving points exact implementation using parametric search extremal polygon containment problems issues parametric searching parallelism comparison problems tr slowing sorting networks obtain faster sorting algorithms sorting italicc log italicn parallel steps parallel merge sort optimaltime algorithm slope selection introduction algorithms fast algorithms collision proximity problems involving moving geometric objects geometric pattern matching euclidean motion computing minimum diameter moving points efficient algorithms geometric optimization applying parallel computation algorithms design serial algorithms applications generic programming paradigm design cgal
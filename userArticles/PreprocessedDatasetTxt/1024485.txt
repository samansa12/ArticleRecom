typing constraint logic programs present prescriptive type system parametric polymorphism subtyping constraint logic programs aim type system detect programming errors statically introduces type discipline constraint logic programs modules maintaining capabilities performing usual coercions constraint domains typing metaprogramming predicates thanks exibility subtyping property subject reduction expresses consistency prescriptive type system wrt execution model program welltyped derivations starting welltyped goal welltyped property proved wrt abstract execution model constraint programming proceeds accumulation constraints wrt enriched execution model type constraints substitutions describe implementation system type checking type inference report experimental results type checking isoprolog constraint libraries sicstus prolog prolog programs b introduction class clpx constraint logic programming languages introduced jaar lassez jaar lassez 1987 generalization innovative features introduced colmerauer prolog ii colmerauer 1984 colmerauer namely computing prolog structures herbrand terms inequality constraints coroutining inherited prolog tradition clpx programs untyped usually structure interest x however quite complex combination basic structures may include integer arithmetic real arithmetic booleans lists herbrand terms innite terms etc implicit coercions constraint domains like prolog iv colmerauer 1996 even early clpr system jaar lassez 1987 already combines herbrand terms arithmetic expressions nonsymmetrical way arithmetic expression may appear herbrand function symbol eg list way around framework many sorted logic jaar lassez 1987 adequate representing type system underlying combination forces herbrand function symbols francois fages emmanuel coquery unique type eg reals herbrand terms whereas herbrand functions used polymorphically eg f1 ff1 list constructor list list numbers 3 type system mycroftokeefe mycroft okeefe 1984 lakshman reddy 1991 hill topor 1992 adaptation logic programming rst type system parametric polymorphism introduced damas milner functional programming language ml system types rst order terms type variables inside types like list express type parameters programs dened data structure type list used polymorphically homogeneous list elements type type system prolog implemented systems godel hill lloyd 1994 mercury somogyi et al 1996 example exibility parametric polymorphism however far insucient handle properly coercions constraint domains eg booleans natural numbers lists herbrand terms support metaprogramming facilities logic programming metapredicates functorxfn callg setofxgl semantically ground type represents set expressions subtyping makes type systems expressive exible allows express inclusions among sets paper investigate use subtyping expressing coercions constraint domains typing metaprogramming predi cates idea allowing subtype relations like list term atom like functorx jl f n welltyped type declaration functor term atom int pred although rst argument list similarly type pred pred freeze term pred pred setof pred list pred absence subtype relation list 6 pred eect raise type error call predicate applied list hand subtype relation pred term makes coercions possible goals terms type systems subtyping logic programming languages proposed descriptive type systems ie purpose describe success set program require type predicate upper approximates denotation hand prescriptive type systems types syntactic objects dened user express intended use function predicate symbols programs note distinction descriptive prescriptive type systems orthogonal distinction type checking type inference possible approaches works considering prescriptive type systems logic programs subtyping beierle 1995 dietrich hagl 1988 hanus 1992 hill topor 1992 yardeni et al 1992 smolka 1988 systems however subtype relations parametric type constructors dierent arities like list term allowed thus cannot used type metaprogramming predicates designed purpose system typical meyer 1996 possesses ad hoc mechanism typing metapredicates makes quite dicult use objective propose simple type system allows uniform treatment prescriptive typing issues constraint logic programs prescriptive type system property subject reduction expresses typing constraint logic programs 3 consistency type system wrt execution model program well typed derivations starting welltyped goal welltyped wellknown result polymorphic type system without subtyping mycroft okeefe 1984 lakshman reddy 1991 hill topor 1992 subtypes added picture absence xed data ow logic programs makes obtention similar result problematical beierle beierle 1995 shows existence principal typings subtype relations basic types provides type inference algorithms however beierle also hanus hanus 1992 claim subject reduction systems propose general types kept runtime hanus 1992 yardeni et al 1992 modes introduced restrict data ow dietrich hagl 1988 smaus et al 2000 somogyi et al 1996 paper abstracting particular structures required clp scheme study prescriptive type system clp programs independent specic constraint domain x section 2 presents type system includes parametric polymorphism subtype relations type constructors dierent arities quite general type structure poset suprema show two subject reductions results one relative abstract execution model constraint programming proceeds accumulation constraints proof subject reduction holds independently computation domain assumption type predicates satises denitional genericity principle lakshman reddy 1991 second subject reduction result relative concrete execution model clp substitution steps show second form necessary keep runtime typing constraints variables inside welltyped programs queries section 3 describes type checking algorithm shows system subtype inequalities generated type checker leftlinear acyclic section 4 presents linear time algorithm solving leftlinear acyclic systems subtype inequalities describes cubic time algorithm pottier pottier 2000a solving general systems inequalities additional assumption types form lattice section 5 presents type inference algorithms inferring types variables predicates program clauses section 6 describes implementation available coquery 2000 solving subtype inequalities done interface wallace constrainthandling library pottier 2000b section 7 report experimental results use implementation type check isoprolog libraries sicstus prolog including constraint programming libraries prolog programs typed constraint logic programs section describe type system logic deriving type judgments clp programs 4 francois fages emmanuel coquery 21 types type system consider based structure partially ordered terms called poterms use representing types parametric polymorphism subtype polymorphism poterms generalize rstorder terms de nition subsumption order based function symbols comes addition instantiation preorder based variables poterms similar ordersorted feature terms terms aitkaci nasr 1986 smolka 1988 aitkaci et al 1997 nd convenient adopt term syntax matching position instead record syntax matching name denoting static types set types set terms formed denumerable set u type variables also called parameters denoted nite set constructors k symbol k 2 k arity 0 associated writing km basic types type constructors arity 0 assume k contains basic type pred type type form k distinct parameters set type variables type denoted v set ground types g set types containing variable write denote type obtained replacing occurrences write denote type strictly contains type subexpression size type dened number occurrences constructors parameters denoted size qualify kind subtyping allow intuitively type subtype type means term also term subtyping relation designed certain nice algebraic properties stated propositions assume order type constructors km k 2 k set fk 0 j k k 0 g maximum moreover assume pair km k 0 0 injective mapping associated kk whenever k k 0 k 00 assumptions mean move hierarchy type constructors arity decreases hierarchy needs lattice poset suprema order type constructors extended covariant subtyping order types denoted also dened least relation satisfying following rules par parameter 1 0 contravariant type constructors could dened subtyping rule similar rule constr ordering relation reversed arguments like eg 0 premise rule argument 0 contravariant type constructors considered paper therefore int f loat listint listf loat listf loat 6 typing constraint logic programs 5 streamoralias atomorlist stream atom lista character clause byte int float tflag streamcreationoption streamproperty teofactionortype teofaction ttype pred fig 1 part type structure isoprolog listint also listf loat 6 list subtyping order include instantiation preorder intuitively ground type represents set expressions subtyping order ground types corresponds set inclusion parametric types directly support interpretation parameters denote unkown types type structure given gure 21 represents part types used type checking isoprolog omitted types subtypes atom associated types types special values options type list parametric type used isoprolog parametric types used typing prolog libraries arrays assoc heaps etc type substitution idempotent mapping parameters types identity almost everywhere applications type substitutions dened obvious way proposition 21 type substitution proof structural induction proposition 22 size size proof 6 francois fages emmanuel coquery structural induction assumption k 2 k set fk 0 j k k 0 g maximum together arity decreasing assumption entail existence maximum supertype type proposition 23 type set f j g maximum denoted max proof structural induction means every connected component types root example structure like b c b c violates hypothesis b common supertype serving root connected component hand assumption assume implied existence least upper bound types upper bound supquasilattice hypothesis smolka 1989 proposition 24 types max proof structural induction note possibility forgetting type parameters subtype relations list term may provide solutions inequalities form list eg however proposition 25 inequality form solution inequality form solution proof type size size hence prop 22 6 solution second proposition prove contrapositive suppose solution say denition maximum prop 23 hence prop 24 rules subtyping 6 max therefore 62 v max since otherwise would contain max strict subexpression impossible 22 welltyped programs clp programs built denumerable set v variables nite set f function symbols given arity constants functions arity 0 nite set p program predicate constraint predicate symbols given arity containing equality constraint query q nite sequence typing constraint logic programs 7 constraints atoms program clause expression noted q atom formed program predicate q query type scheme expression form 8 set parameters types assume function symbol f 2 f declared type scheme form 8 arity f type similarly assume predicate symbol p 2 p declared type scheme form 8 pred n arity p declared type equality constraint symbol 8u u upred notational convenience quantiers type schemes resulting type pred predicates omitted type declarations declared type schemes indicated writing assuming fresh renaming parameters occurrence f p throughout paper assume k f p xed means declarations typed program syntactical details insignicant results variable typing mapping nite subset v written g type system denes welltyped terms atoms clauses relatively variable typing u typing rules given table 1 rules basically consist rules mycroft okeefe plus subsumption rule note sake simplicity constraints distinguished atoms system substitution atom type substitution head head renaming substitution clause query ua head table 1 type system object say term welltyped exist variable typing u 8 francois fages emmanuel coquery type u otherwise term illtyped likewise atoms etc program welltyped clauses welltyped distinction rules head atom expresses usual denitional genericity principle lakshman reddy 1991 states type dening occurrence predicate ie left clause must equivalent upto renaming assigned type predicate rule head used deriving type head clause thus allowed use substitutions variable renamings declared type predicate example predicate member typed polymorphically ie member listpred denition contain special facts like member1 1 would force type member int listintpred satisfying denitionalgenericity condition following proposition shows expression clause head welltyped variable typing u remains welltyped instance u proposition 26 variable typing u type judgement r head clause type subtitution u r u r proof induction height derivation tree u r 23 subject reduction wrt csld resolution subject reduction property evaluation rules transform welltyped expression another welltyped expression evaluation rule constraint logic programming csldresolution recall evaluation rule convenient distinguish query q constraint part c sequence denotes conjunction sequence atoms use notation make distinction given constraint domain x xes interpretation constraints query c 0 jb csldresolvent query cja renamed apart program clause constraint c theorem 21 subject reduction csld resolution let p welltyped clpx program q welltyped query ie u q query variable typing u q 0 csldresolvent q exists variable typing u 0 u 0 q 0 query proof let us assume without loss generality q 0 csldresolvent q program clause pt djb thus q welltyped u cjps query program well typing constraint logic programs 9 exists variable typing u 00 renamed apart u u 00 pt djb clause pred type declaration predicate p since u ps atom substitution let u proposition 26 u 00 djb query thus remains shown u hence proposition 26 u 00 therefore u conclude worth noting previous result would hold without denitional genericity condition expressed rule head example two constants pred dened non denitional generic clause pa query pb well typed resolvent illtyped b upper bound 24 subject reduction wrt substitutions csld reductions noted csld fact abstraction operational reductions may perform also substitution steps noted instead keeping equality constraints clp scheme constraints handled modulo logical equivalence jaar lassez 1987 clear diagram reductions however previous subject reduction result expresses consistency types wrt horizontal reduction steps wrt abstract execution model accumulates constraints may hold concrete operations constraint solving substitutions example subtype relations int term pred term type declarations pred intpred program px query true although query obtained substitution ptrue illtyped order establish subject reduction substitution steps consistent semantical equivalence programs one needs consider typed execution model type constraints variables checked runtime example int constraint true unsatisable query francois fages emmanuel coquery thus rejected compiletime checking satisability typed constraints denition 21 given constraint system domain x typed constraint system 2 x dened adding type constraints ie expressions form term type basic types interpreted distinguished subsets x type constructors mappings subsets x satisfying subtyping relation type declarations function predicate symbols type exists valuation variables free parameters 2 typed constraint system composed type constraints constraints x satisable exists valuation satises constraints system lemma 21 typed constraint system proof valuation x 2 denition 22 tclp clause resp query associated welltyped program resp query typed environment u clause resp query augmented type constraints u theorem 22 subject reduction substitutions let p tclp program associated welltyped clpx program q tclp query u q query variable typing u q 0 csld resolvent q variable typing u 0 associated type constraints q 0 query furthermore q 0 contains equality constraint query proof subject reduction csld resolution follows theorem 21 tclp programs special case welltyped clp programs furthermore one easily checks type constraints q 0 come type constraints q resolving tclp clause give exactly type environment u 0 constructed proof previous theorem thus u query let constraint resolvent q 0 let constraint part q 0 together lemma 21 therefore immediate typing rules replacing x derivation u 0 q 0 query completing derivation derivation get derivation u query eect type constraints tclp programs prevent derivation illtyped queries substitution steps addition queries true px rejected compiletime unsatisability constraints similarly tclp program clauses unsatisable typed constraints rejected compiletime typing constraint logic programs 11 note smaus et al 2000 another result subject reduction substitutions shown without addition type constraints restricted context moded logic programs 3 type checking system described rules table 1 nondeterministic since rule sub used anywhere typing derivation one obtain deterministic type checker directed syntax typed program simply replacing rule sub variants rules func atom head subtype relation premises leads following type system table 2 substitution atom type substitution head renaming substitution clause query ua head table 2 type system second form proposition 31 program well typed original system well typed new one proof clearly program typable new system typable original one one replace every occurrence func atom rules respectively following derivations francois fages emmanuel coquery head conversely program typable original system typable second one noted 2 proof induction typing derivation original system rules var query clause remain rule atom head similar rule func thus show property term u rst system u second system 0 let us consider three possible cases either proof terminates application var rule application func rule application sub rule rst case trivial rule var systems second case according func rule u induction hypothesis terms 1 n also type checked n second system 0 applying func rule 0 third case according sub rule u allows us deduce u induction hypothesis type checked u second system since 0 0 type checked construction substitution needed rules func atom head type checking done solving system subtype inequalities collected along derivation type judgement parameters type environment ie parameters types variables however scope substitutions act parameters renamed declarations function predicate symbols thus looking type substitutions restricted domain sake simplicity ever instead dealing formally domain type substitutions shall simply assume parameters type variables replaced new constants checking satisability subtype inequalities avoid unsound instantiations let collection subtype inequalities imposed types rules atom head derivation let us dene size system inequalities number symbols size system inequalities associated typed program onvd v size type declarations typing constraint logic programs 13 variables program n size program size type declarations function predicate symbols type system deterministic proposition 32 wellformed program typable system inequalities collected along derivation satisable worth noting system inequalities collected way type checking fact particular form denition 31 system inequalities leftlinear type variable one occurrence left system acyclic exists ranking function type variables r u n 2 r r proposition 33 system inequalities generated type checking algorithm acyclic leftlinear proof type variables types clp variables renamed con stants type variables occurring introduced rules atom head come renamed apart type declarations function predicate symbols thus associate type variable rank h dened height introduction node derivation tree ie maximal distance node leaves rule func atom head height h posts inequalities form rank variables h rank variables h 1 system thus acyclic type variables left parameters come result type function declaration eg nil list result type type variables result type distinct renamed apart hence variables occurring type left unique occurrence system system thus trivially leftlinear note allowed contravariant type constructors previous proposition would hold linear time algorithm solving acyclic leftlinear systems given next section 4 subtype inequalities satisability subtype inequalities ssi problem problem determining whether system subtype relations 1 n 1 ssi problem confused semiunication problem dened instantiation preordering intead subtype ordering 9 undecidability semiunication shown kfoury et al 1989 14 francois fages emmanuel coquery solution ie whether exists substitution 0 holds denition 41 solution inequality 0 substitution 0 maximal solution solution solution 0 exists substitution 8 2 v 0 ssi problem deeply studied functional programming com munity due lack results general case special instances ssi problem identied along several axes form types basic types constructor types covariant case paper contravariant structure types disjoint union lattices tiuryn 1992 quasi lattices smolka 1989 ncrown tiuryn 1992 posets suprema case partial orders frey 1997 form type constraints section show type constraints generated type checking algorithms solved linear time quite general structure types type constraints generated type inference algorithms solved cubic time additional assumption types form lattice 41 acyclic leftlinear case show satisability acyclic leftlinear subtype inequalities decided linear time admit maximal solutions general type structure posets suprema section present algorithm proceeds simplication subtype inequalities introduces equations parameter type say system solved form contains equations form dierent occurrence substitution associated system solved form trivially maximal solution show following simplication rules compute solved forms satisable acyclic leftlinear systems typing constraint logic programs 15 k k 0 62 v 62 v l l r 2 62 v max lemma 41 rules terminate steps n sum sizes terms lefthand side inequalities proof suces remark rule strictly decreases sum size terms lefthand sides inequalities triv varleft one decomp least one varright size one easily check rule preserves leftlinearity well acyclicity system moreover lemma 42 rule preserves satisability system well maximal solution one exists proof rules decomp triv preserve solutions denition subtyping order rule varleft replaces parameter upper bound system leftlinear computes maximal solution thus preserves maximal solution system one exists rule varright replaces parameter occurrence lefthand side inequality hence upper bound maximum type lower bound computes maximal solution thus preserves also maximal solution system one exists theorem 41 let acyclic leftlinear system let 0 normal form solved form case 0 maximal solution proof consider normal form 0 0 contains non variable pair 0 inequality irreducible decomp 0 solution hence unsatisable lemma 42 similarly 0 solution contains inequality prop 25 inequality 2 v max 6 prop 25 cases irreducibility acyclicity 0 contains inequality hence 0 contains equalities solved form substitution associated 0 maximal solution francois fages emmanuel coquery 42 general case absence subtype relations type constructors dierent arities checking consistency general subtype inequalities nite types shown frey frey 1997 pspacecomplete arbitrary poset generalization fuh mishras algorithm open problem whether technique used frey proving consistency arbitrary posets generalized case subtype relations type constructors dierent arities assume however subtyping relation lattice shown pottier pottier 2000a satisability subtype inequalities checked cubic time structure innite regular trees ie recursive types amadio cardelli 1993 note recursive types admit solutions equations form list namely type listlist present pottiers algorithm set simplication rules show acyclic systems solving subtype constraints innite types equivalent solving nite types assume structure type constructors k lattice types maintain previous assumption decreasing arities except nary type constructors also assume greatest lower bounds introduce new parameters similarly k 00 range kk 00 note loss generality assumption lattice type constructors always completed introducing glb lub constructors right number parameters consider systems subtype inequalities parameters types form types represented form introducing new parameters inequalities parameters type represent sake presentation assume initial system solved rst completed introducing new variables non empty subset v 0 adding inequalities variables 2 also assume system completed adding inequality variable given system set variables dene variable f2v0 j92s 2g similarly simplication rules following typing constraint logic programs 17 62 6 k k 0 g l k 00 6 k 0 6 f g k l k 00 k rule trans computes transitive closure inequalities parameters mainly responsible cubic time complexity rule clash checks consistency lower upper bounds parameters rule dec decomposes types three simple rules fact sucient checking satisability system pottier 2000a rules glb lub make explicit greatest least solution system computing greatest lower bound upper bounds parameters least upper bound lower bounds remark algorithm applied initial system containing unique inequality form 0 parameter algorithm maintains unique upper lower bounds parameter note lb resp ub lower resp upper bound system irreducible form proposition 41 rules terminate proof termination rule clash trivial rules let us consider complexity measure system couple integers e ordered lexicographic ordering e entropy system number v 2 n francois fages emmanuel coquery v number parameters system n number inequalities parameters temperature system sum height constructors right depth constructors left height resp depth constructor length longest path constructor resp k show rule increases temperature system rule either decreases e rule trans change decreases e 1 rule dec change decreases e least 1 rules glb either decreases k 00 6 k 0 decreases e otherwise similarly rule lub hence algorithm terminates theorem 42 pottier 2000a system inequalities satisable innite regular trees simplication rules generate false case identi cation parameters upper bound ub resp lower bound lb provides maximum resp minimum solution furthermore one show setting acyclic systems covariant constructor types solving subtype constraints innite types equivalent solving nite types theorem 43 acyclic system inequalities satisable nite types simplication rules generate false case identication parameters upper bound resp lower bound provides maximum resp proof sucient remark simplication rules preserve acyclicity system acyclic system identication parameters bounds creates nite solutions corollary 41 lattice structure without acyclic system inequalities satisable nite types simplication rules generate false parameters 5 type inference usual prescriptive type system type reconstruction algorithms used omit type declarations programs still check typability program possibility infer omitted types lakshman reddy 1991 describe algorithms inferring type variables predicates assuming type declarations function symbols 51 type inference variables types variables clp clauses queries inferred introducing unknowns type variable typing collecting subtype typing constraint logic programs 19 equalities along derivation type judgement like type checking algorithm easy check system subtype inequalities thus collected still acyclic unknown types clp variables appear left positions system however leftlinear clp variable one occurrence clause query second algorithm previous section thus used infer type variables clp clauses queries 52 type inference predicates types predicates inferred well assumption predicates used monomorphically inside mutually recursive denition lakshman reddy 1991 means inside group mutually recursive clauses occurrence even body clause predicate dened clauses must typed rule head instead rule atom reason restriction similar one done inferring type mutually recursive functions ml avoid solve semiunication problem ie given system types substitution exists substitution st proved undecidable kfoury et al 1989 note ssi obtained collecting subtype inequalities derivation typing judgements still acyclic unknown types predicates appear righthand sides inequalities second algorithm previous section thus used also infer type predicates clp programs assumption structure types lattice without one consequence acyclicity system however maximum type predicate always indeed type system predicate always typed maximally permissive general structure posets suprema unless unknown types predicates compared types belonging dierent connected components case predicate typable substitution unknown type root connected component always solution cases obviously informative type infer strategy infer two types predicates minimum type predicate heuristic type type inference algorithm proceeds follows firstly minimum type predicate obtained computing minimum solution ssi associated typing complete denition predicate minimum type ith argument predicate type unknown type associated ith argument predicate ssi minimum type lower bound possible typings predicate secondly heuristic type computed type parametric computed two steps francois fages emmanuel coquery first heuristic upper type computed predicate heuristic upper type ith argument predicate obtained collecting upper types fubx1 ubxn g variables fx 1 occur ith position predicate denining clauses greatest lower bound types variable arguments set identication creates cycle heuristic type computed inferring possibly parametric type ssi associated heuristic upper type candidates parametric types parameters bounded ssi associated heuristic upper type candidate checked iteratively replacing new constant identifying parameters new constant one bounds although tedious one easily check conditions imposed de nition heuristic type create sound typings heuristic types thus provide correct type declarations type checking program 6 implementation type system 61 wallace library solving subtype inequalities current implementation uses wallace library fpottier pottier 2000b solving subtype inequalities type inference type checking cases set type constructors k thus lattice described section 4 note type system require condition could arity decreasing order relation k required type inference algorithm element distinguished type term stands prolog terms type considered valid typing empty type note wallace library authorizes constrained type schemes like example oat expresses resulting type function type arguments sake simplicity consider constrained type schemes paper 62 type checker type checker rst reads prolog les deduces les containing type information load one le prolog le source plus one le module used usemodulesomemodule sicstus prolog system loads type les builds structure type constructors type checker impose give type clp variables clauses typing constraint logic programs 21 queries instead type variables inferred described section 5 environment u built type unknowns variables subtype inequality system collected applying rules type system step wallace used solve type constraints one diculty appears checking denitional genericity condition type error must raised denition predicate uses argument head clause term whose type subtype instance declared type 0 argument renaming wallace able make dierence subtype instance renaming type 0 following consideration allows us work around diculty subtype renaming 0 instances 0 0 0 must exist instance 0 0 checking denitional genericity thus replace parameter appearing declared type head predicate constructor appear program term 6 constructor 6 6 term rule atom applied using transformed type rule head applied well original type 63 type inference predicates described section 5 two types infered predicates minimum type lower bound possible typings predicate heuristic type may parametric type inference displayed user information print types used typing automatically program noninteractive manner choose heuristic bound since permissive type 7 experimental results 71 detection programming errors show small catalog kind programming errors detected type checker 711 inversion arguments predicate function error detected example variable occurs two positions incompatible types example 71 consider following clause arguments length predicate reversed 22 francois fages emmanuel coquery usual declarations pred pred rule atom variable l3 must types list int type hierarchy use type smaller list int subtype inequalities premise rule atom thus unsatisable type error raised note example motivates discard type would detected variables since empty type could always inferred type variable 712 misuse predicate function error detected term type appears argument predicate functor expects argument type 0 6 0 substitution example 72 consider following clause declarations int integer division pred try use oat 35 int expected rule atom apply kind error detected also inside call foreign predicates prolog interface c programming language example example 73 consider declaration predicate p dened c using sicstus c interface declaration interpreted type declaration pred call program p314 raises type error since argument f loat predicate expects int typing constraint logic programs 23 713 wrong predicate denition wrt declared type error detected two ways corresponding two preceding kinds errors two following examples predicate p declared type pred example 74 let p dened p term used argument p requires p accepts arguments type atomic list atomic list 6 int rule atom apply example 75 let p dened pred case infer type x must smaller list using rule atom x used length smaller int using rule head types common subtypes error raised 714 violation denitional genericity condition example 76 p1 pred although argument p list type listint instance renaming list int 6 error also detected variable head clause example 77 pred variable x must type f loat common subtype error raised francois fages emmanuel coquery 72 type checked programs test system rst tried 20 libraries sicstus prolog around predicates type checked implementation clpfd written completely prolog using lot metapredicates contains around 170 predi cates tests done using type declarations around 100 builtin iso prolog predicates builtin sicstus predicates type errors obtained libraries came overloading function symbols example function 2 used coding pairs well coding arithmetic operation numbers another example overloading comes options happens terms common two sets options types 1 2 case enough create subtype 1 2 tell common terms type also skip type checking particular declarations mode declarations used type system example 78 mode p q declarations typed another type structure mode declarations type structure one predicates since predicate clearly overloaded declarations 73 type inference predicates said section 63 infer interval types predicates bounds interval may oer interesting information example 79 appendhead tail list head rest appendtail list rest append list list minimum type listbottom listbottom listbottom pred heuristic infered type lista lista lista pred example 710 sumlist sum sum sumlisthead tail sum0 sum sum1 headsum0 sumlisttail sum1 sum minimum type listbottom bottom bottom pred heuristic infered type listfloat float float pred sometimes heuristic infers permissive type particular case overloaded arithmetic predicates expressions always typed float int typing constraint logic programs 25 example 711 length0 lengthtailr lengthtail l r l1 minimum type listbottom int pred heuristic infered type lista float pred heuristic may also infer type restrictive example 712 islist minimum type listbottom pred heuristic infered type lista pred typical example maximum type pred fact intended type examples clearly justify heuristic approach type inference predicates prescriptive type system finally interesting f latten predicate illustrates remarkable exibility type system example 713 pred pred 74 benchmarks following table sums evaluation results rst column indicates type checked prolog program les second column indicates number predicates dened le rst maximum number atoms clause complete connected component third column indicates time seconds type checking program type declarations function predicate symbols fourth column indicates cpu inferring types predicates type declarations function symbols last column indicates percentage predicates infered type exactly intended type last test le another implementation clpfd top prolog uses lot metaprogramming predicates 26 francois fages emmanuel coquery file predicates type checking type inference exact types assocpl bdbpl 101 2727 2356 4110 64 charsiopl 15 77 127 221 33 clpbpl 59 2077 2435 182732 na clpq 396 39160 35512 403437 na clpr 439 39160 30445 395841 na jasperpl listspl randompl 11 socketspl ugraphspl 87 1224 4821 27422 67 clpfdpl 163 2071 2435 5965 na table 3 benchmarks algorithm used solving systems subtype inequalities type checking type inference dierence computation times comes handling complete connected components denitions type infer ence whereas type checking clauses type checked one one particular clpr clpq large mutually recursive clauses library arrays low percentage exact matches infered type intended type simply due typing indices oat instead int errors libraries also due typing arithmetic expressions oat sometimes use equality predicate creates typing term arguments instead restrictive typing library clpfd nite domain variables typed type int similarly library clpr variables reals typed type oat one consequence type checker allows coercions nite domain variables real constraint variables make coercions work practice one modication clpr library necessary 8 conclusion typing constraint logic programs checking programming errors statically retaining exibility required preserving metaprogramming facilities typing constraint logic programs 27 logic programming usual coercions constraint programming challenge conducted design type system presented paper experiments libraries sicstus prolog shown type system simple exible enough accept large variety constraint logic programs main diculties located con icts overloading predicates functions ad hoc polymorphism could resolved considering disjunctive formula types demoen et al 1999 examples given also show type system useful enough detecting programming errors inversion arguments predicate unintended use predicate price pay exibility type system may regarded permissive intuitively illtyped queries may rejected type system analyzed defects terms subject reduction properties type system particular shown addition typing constraints variables welltyped programs queries suces state subject reduction wrt csld resolution substitution steps eect reject larger set clauses queries checking satisability constraints type constraints compiletime lattice assumption type structure due implementation wallace subtype constraints may regarded also demanding cases already relaxed assumption rejecting bottom element structure types nevertheless decidability subtype constraints general assumptions interesting open problem particular whether method frey frey 1997 extended cover subtype relations type constructors dierent arities required approach open question finally worth noting results presented limited logic programming languages relevant various constraint programming languages main diculty type check constraint variables express communication dierent constraint domains acknowledgment would like acknowledge fruitful discussions francois pottier didier remy jan smaus alexandre frey work also grateful referees peer reviews r login logical programming language builtin inheritance subtyping recursive types type inferencing polymorphic ordersorted logic programs equations inequalitions httppauillac polymorphic type system subtypes prolog pages 7993 ganzinger satisfying subtype inequalities polynomial space type inference subtypes logic programming type speci semantics typed logic programs pfenning typed prolog semantic reconstruction mycroftokeefe type system type checking type inferencing logic programs subtypes parametric polymorphism polymorphic type system prolog types logic programming using modes ensure subject reduction typed logic programs subtyping logic programming polymorphically ordersorted types logic programming polymorphically ordersorted types subtype inequalities pfenning tr ctr adam kiezun michael ernst frank tip robert fuhrer refactoring parameterizing java classes proceedings 29th international conference software engineering p437446 may 2026 2007 wodzimierz drabent jan mauszyski pawe pietrzak using parametric set constraints locating errors clp programs theory practice logic programming v2 n45 p549610 july 2002
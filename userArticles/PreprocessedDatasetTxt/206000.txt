tighter lower bounds exact complexity string matching paper considers exact number character comparisons needed find occurrences pattern length text length n using online general algorithms online algorithms lower bound 1frac94m1cdot n character comparisons obtained general algorithms lower bound 1frac2m3cdot n character comparisons obtained lower bounds complement online upper bound 1frac83m1cdot n comparisons obtained recently cole hariharan lower bounds obtained finding patterns interesting combinatorial properties also shown patterns offline algorithms efficient online algorithms b introduction classical string matching problem problem finding occurrences pattern text string matching among extensively studied problems computer science survey various algorithms devised found ah90 among efficient algorithms devised string matching algorithms gain information pattern text performing comparisons pattern text characters algorithms need prior knowledge possibly infinite alphabet pattern text drawn investigate exact comparison complexity string matching model obtain lower bounds number comparisons required worst case lower bounds allow algorithms preprocess pattern text lower bounds remain valid even algorithms know alphabet advance provided alphabet contains character appearing pattern two kinds comparison based algorithms studied online algorithm algorithm examines text characters window size sliding monotonically right furthermore window slide right matching pattern instances left window aligned window discovered general offline algorithm algorithm access pattern text unrestricted manner perhaps widely known linear time algorithms string matching knuthmorrispratt kmp77 boyermoore bm77 algorithms refer kmp bm algorithms respectively kmp algorithm makes comparisons bound tight exact complexity bm algorithm open question recently shown kmp77 bm algorithm makes 6n comparisons pattern occur text courant institute new york university new york 10012 first two authors supported part nsf grants ccr8902221 ccr8906949 ccr9202900 ccr8901484 z department computer science university warwick coventry cv4 7al england author supported part esprit bra programme ec contracts 3075 alcom 7141 alcom ii part work carried author visiting tel aviv university x department computer science tel aviv university tel aviv 69978 israel part work carried author visiting university warwick guibas odlyzko go80 reduced 4n assumption cole finally proved essentially tight bound 3n gamma nm comparisons bm algorithm whether pattern occurs text versions kmp bm algorithms considered preceding paragraph comparison based interesting note algorithms variants purely comparison based fall category algorithms considered paper failure function kmp algorithm kmp77 yields finite automata perform string matching reading character exactly however simulations automata require prior knowledge alphabet number comparisons needed simulate transition depends alphabet size transitions simulated unit time using text characters address array pointers allowed model standard bm algorithm bm77 uses two shift functions determine distance shift pattern mismatch occurs one shift functions occurrence shift gives rightmost position pattern unmatched text character occurs efficient implementation shift function alphabet dependent second shift function used bm algorithm comparison based analysis cole cole91 shows occurrence shift function improve worst case behaviour bm algorithm occurrence shift function important practice however ensures sublinear time various probabilistic settings see bgr90 study kmp bm algorithms behave practice reader referred hs91 apostolico crochemore ac89 gave simple variant kmp algorithm makes 3 comparisons apostolico giancarlo ag86 gave variant bm algorithm makes 2n gamma m1 comparisons crochemore et al showed recently remembering recently matched portion reduces upper bound bm 3n 2n comparisons recently galil giancarlo cgg90gg92 analyzed modified string matching algorithm designed colussi coll91 showed makes 4 comparisons fact gg92 give bound sharper form function period z pattern bound becomes n g galil giancarlo gg91 also shown online algorithm string matching must perform least 4 comparisons strings string aba example shown lower bound also applies general algorithms patterntext comparisons allowed algorithm galil giancarlo gg92 efficient relatively short pat terns may become inefficient longer patterns breslauer galil bg92 cole hariharan ch92 shown string matching problem becomes easier length pattern increases breslauer galil bg92 developed algorithm performs 1 logm character comparisons texts length n patterns length cole hariharan ch92 obtained algorithm performs 1 1 comparisons shall see essentially tight galil giancarlo gg91 showed online algorithm must perform least comparisons patterns odd length general algorithm must perform least 1 comparisons patterns length work improve lower bounds online offline algorithms also show certain patterns offline algorithms efficient tighter lower bounds string matching 3 online algorithms lower bounds apply model text text patterntext comparisons allowed suspect patterns texttext comparisons improve efficiency string matching algorithms improved lower bounds following online algorithms use patterntext comparisons lower bound 1 comparisons obtained 1 online algorithms allowed use patterntext texttext comparisons lower bound character comparisons obtained algorithms allowed use patterntext texttext comparisons lower bound 1 comparisons obtained 2 also get offline lower bound of3 delta character comparisons patterntext comparisons allowed online lower bounds presented come close online upper bound obtained cole hariharan ch92 worstcase comparison complexity string matching therefore almost exactly determined asymptotically form 1 algorithms 9 3 general algorithms 3 work builds work galil giancarlo gg91 point view however bit different galil giancarlo gg91 investigated number comparisons required function n text length pattern length interested number comparisons required function text length specific pattern sought next section explain detail rules string matching game comparison model setting section 3 describe adversary arguments lie heart lower bounds proofs offline lower bounds presented section 4 follow almost immediately arguments section 3 specific lower bound obtained every pattern lower bound depends first second periods pattern see next section offline lower bounds shown tight interesting family patterns exploiting additional restrictions placed online algorithms obtain sections 5 6 improved online lower bounds lower bound section 5 depends first second periods patterns additional periods complicated combinatorial structures used section 6 section 7 obtain online upper bounds strings form k ba match online offline lower bounds sections 4 5 finally section 8 exhibit pattern abaa offline algorithm actually online small lookahead performs better online algorithm preliminary version paper appeared chpz93 2 preliminaries algorithms consider allowed access text pattern queries form query algorithm supplied yes answer algorithm charged queries makes computations free charge algorithms may adaptively choose queries depending answers earlier queries algorithm model may viewed sequence decision trees similar comparison models used study comparison problems sorting searching selection string w let cw denote minimal constant exists string matching algorithm finds occurrences pattern w text length n using cw comparisons text pattern characters pairs text characters variant cw c w algorithm allowed compare pairs text characters obviously cw c w definition cw c w allow unrestricted offline algorithms random access characters text contrast define c k w c k w corresponding minimal constants algorithms access text sliding window size jwjk jwj denotes length w furthermore algorithm allowed slide window past text position already reported whether occurrence pattern starts text position algorithms using sliding window size jwj ie traditionally called online algorithms call algorithms use larger windows finite lookahead window algorithms clearly cw c k w c 0 w k 0 show section 8 w k c k w c 0 w specifically show c 4 abaa c 0 abaa means patterns algorithms use larger windows may efficient algorithms use smaller windows still open problem whether exists string w cw c k w every k 0 known whether exists strings optimal offline algorithm better finite lookahead algorithm clear however c k w nonincreasing k following lemma also easily established lemma 21 string w lim k1 c k proof let cn number comparisons required worst case find occurrences w text length n using unrestricted algorithm definition cw get cn cw every consider following algorithm lookahead k algorithm finds occurrences w window size k jwj using ck window slid k positions process repeated number comparisons performed algorithm text length n k w constant depending w k particular get w easy check lim k1 c k w cw therefore cw clear however lim k1 c k w cw required equality follows easy see 1 cw c 0 w c w c 0 w every string w kmp algorithm shows 1 c every w algorithm galil giancarlo gg92 shows 1 c 3 every w algorithm breslauer galil bg92 shows 1 c every string length fi nally algorithm cole hariharan ch92 shows 1 c every string w length algorithms kmp77gg92bg92ch92 mentioned online use patterntext comparisons galil giancarlo gg91 showed c m3 patterns odd length show infinitely many values exists strings length c 4m1 also show tighter lower bounds string matching 5 infinitely many values exists strings length c 7m27 shows algorithm cole hariharan far optimal show c w cw m3 patterns showing essentially lower bounds obtained gg91 online algorithms also hold general algorithms let w string length say z 1 z period w minimal period period exists since always period w let z 2 minimal period w divisible z 1 second period exist set z 1 call z 1 period w z 2 second period w periodicity properties play major role sequel well known see eg kmp77 z 1 z 2 periods w period w z 1 z 2 first second periods w gcdz 1 z 2 period w consequence 2 3 adversary arguments lower bounds derived using adversary fills text answering algorithms queries adversary always tiles text overlapping occurrences pattern every character text eventually becomes part occurrence algorithm must find consequently algorithm must establish identity text character achieve getting least one yes answer position adversary tries avoid giving yes answers whenever possible gives yes answer answer would either contradict previous answer prevent completely tiling text arguments section generalizations similar arguments galil giancarlo gg91 statement made least one yes answer must obtained algorithm text position covered occurrence pattern seems obvious indeed immediate patterntext comparisons allowed slightly complicated argument needed handle possibility texttext comparisons lemma 31 comparison based algorithm certain identity text characters text receiving least yes answers proof construct graph g one vertex text position one vertex k distinct symbols appear pattern w every edge g corresponds yes answer received algorithm yes answer given query edge added vertex corresponding tj vertex corresponding symbol wi yes answer given query edge added vertices corresponding ti tj stage algorithm graph g constructed far represents positive information known characters text text positions corresponding vertices components g contain pattern symbol vertex text positions identity character known since alphabet size unlimited character text position yet determined since component size p containing pattern symbol vertex least edges total numbers known text positions total number yes answers next describe scheme using adversary give algorithm relatively large number answers begin simple example 6 cole hariharan paterson zwick pattern string aba let 1 consider family text strings length n defined follows place positions 3j texts v positions 3j simplicity number positions 0 family may depicted schematically ba ab ba ab ba ab finding occurrences aba text string f equivalent determining index vector v 2 f0 1g r adversary force least one answer revealing bit v following definition generalises properties example definition 32 let w string family texts length n said rseparating w exist distinct indices r 1 every r every text v contains occurrence w starting position u 0 v occurrence w position u 1 v 2 answer query form wi tj either yes texts texts v yes text v v fixed 1g following lemma easily established proof omitted lemma 33 rseparating family answer texttext query either yes texts v v yes v v k1 1 yes v v k1 phi v yes v v k1 1g example given definition 32 texttext query whose answer yes v k1 1g situation may arise however patterns w contain two distinct characters ready prove lemma 34 f rseparating family w comparisonbased algorithm w exists text v 2 f algorithm receives least r answers able locate occurrences w v proof adversary maintains set e containing linear equations binary field gf2 variables v stage least one vector v 2 f0 1g r satisfies equations e vector v 2 f0 1g r satisfies equations e text v consistent answers given far adversary number equations e number answers given adversary beginning query made texts still possible adversary responds new query answer query texts v v solution e adversary responds common answer set e remains unchanged invariants remain satisfied otherwise adversary answers adds equation e following way answer current query texts f exist definition 32 lemma 33 either single equation e 1 tighter lower bounds string matching 7 two equations e 1 e 2 answer query yes v answer query according v yes e 1 satisfied e 1 equation obtained e 1 complementing free coefficient added e answer query according v yes e 1 e 2 satisfied least one e 1 e 2 independent equations e otherwise answer would surviving texts e 1 depend e equation e 1 added e otherwise e 2 added easy verify required invariants still satisfied algorithms task done unique solution e happens set e contains least r equations equation added result answer adversary therefore give algorithm least r answers lemmas 31 34 combined together give lower bound n every text v separating family f used lemma 34 every text position covered occurrence pattern w separating families constructed next section 4 offline lower bounds theorem 41 w string z 1 z 2 first second periods z1z2 proof assume without loss generality every v 2 f0 1g r construct text v length n every occurrences w start jz 1 either jz 1 jz 1 according whether v 1 easy verify rseparating family w u 0 construction depicted figure 1 note z 1 consider comparisonbased algorithm finds occurrences w string length n according lemma 34 gets least r answers least one text v0 v 0 2 f0 1g r also easy see every text v particular v0 completely covered occurrences w according lemma 31 must therefore get least n yes answers v0 total must make worst case least n z1z2 comparisons text length n example note string aba z 5 separating family used obtain lower bound may depicted ba ab aba ba ab aba ba ab family property every text family every position covered occurrence aba separating family aba given definition 32 property example note string abaa z therefore cabaa 8 7 section 8 shown bound tight 7 see theorem 71 c 0 4 provides example string offline algorithms efficient online algorithms theorem 42 w string z 1 z 2 first second periods 2z z2 8 cole hariharan paterson zwick fig 1 configuration used prove cw fig 2 configuration used show cw proof proof similar proof theorem 41 separating family every text almost completely tiled occurrences w may obtained time without using occurrences w common texts family assume 1 every v 2 f0 1g r construct text v length n occurrences w start jz 2 1 easy check rseparating family w time u 0 r construction depicted figure 2 note z periods w 2z every position text v except perhaps first last z positions covered occurrence w thus proof theorem 41 show algorithm must perform worst case least n1 example string aabaa z therefore caabaa 5 4 separating family used time ba ab aa ba ab aa ba ab theorem 43 c 3 proof upper bound follow theorem 71 lower bound tighter lower bounds string matching 9 follow theorem 42 condition jwj satisfied specialized argument needed case argument given assumes pattern text comparisons allowed seem extend simple manner case patterntext texttext comparisons allowed lower bound obtained using separating family aba given definition 32 complication arises however texts family completely covered occurrences aba assume 1 adversary starts putting text positions 3j set positions 3j either ab ba replying least one query concerning positions adversary answers queries algorithm following way queried text position already set adversary answer consistent setting returned query t3j position 3j k yet set adversary responds sets positions 3j either ab ba whichever consistent answer text positions form 3j eventually covered occurrences aba adversary therefore forces least one answer two yes answers pair positions form 3j necessarily covered occurrences aba however position 3j covered occurrence positions set ba positions 3j 1 3j 2 set ab algorithm must still query position 3j least case either verify rule occurrence aba starting position 3j gamma 1 completes proof nonperiodic string w ie string z 1 theorems give trivial lower bound cw 1 bound tight however many string matching algorithms see eg coll91gg91 ch92 perform n comparisons searching nonperiodic pattern text length n corollary theorem 42 get corollary 44 k 2 ca k ba proof easy check first second periods 1 claim follows immediately theorem 42 section 7 shown bounds given corollary 44 tight even matched using online algorithms corollary theorem 42 corollary 44 get corollary 45 every exists string wm k ba k length algorithm finds occurrences wm text length n must make least comparisons worst case know see last paragraph section 2 z 1 z 2 first second periods w z 1 2 z 2 z get z 2 jwj3 e corollary 45 therefore strongest result kind implied theorem 42 5 online lower bounds short section show lower z2 obtained offline algorithms 2z online algorithms even condition hold theorem 51 w string z 2 second period c 0 w z2 fig 3 configuration used prove c 0 w proof suppose online algorithm found occurrence w text window slid z 1 positions right place two copies w shifted z 1 z 2 positions w shown figure 3 denote copies w 0 w 00 since z period w two copies w 0 w 00 must disagree least one position end found occurrence w adversary extend found occurrence w either w 0 w 00 way force algorithm get least one answer algorithm makes query whose answer identical continuations adversary gives algorithm common answer stage algorithm make query distinguishes two noncompatible continuations matter query adversary answers adversary chooses continuation consistent answers questions accordingly algorithm finds chosen occurrence algorithm either made least z queries slide window z 1 positions made least z 2 1 queries slide window z 2 positions note verify occurrence pattern text algorithm must get least one yes answer character occurrence process repeated forcing algorithm make least 1 queries text length n next section obtain using complicated arguments better lower bounds online algorithms see corollaries 63 65 6 online lower bounds ii proof theorem 51 shown every nonperiodic pattern adversary force algorithm make least one mistake ie get least one answer occurrence pattern used tiling text show certain patterns adversary force algorithm make least two mistakes occurrence algorithm cole hariharan ch92 makes two mistakes occurrence adversary force algorithms make least three mistakes occurrence tiling theorem 61 let w string length let z periods w every 1 period w none multisets fwm contains character exactly zk ii addition none multisets fwm contains exactly zk proceeding proof theorem try clarify conditions appearing consider k copies w positioned array k numbered columns numbered copy th row shifted z positions right respect copy 0 th tighter lower bounds string matching 1112134511211213451121 set hw b set hw 12 9 11 12i fig 4 two simple setups theorem 61 applied row arrays depicted figure 4a string figure 4b string w z contains characters appearing column array corresponding w requirement clause column lies end copy 0 th row end copies character appears one rows easy check cases depicted figure 4 condition satisfied note requires three characters column either equal distinct check condition clause ii one needs look pairs columns compare pair characters appearing row number j equal pairs required satisfy j 6 k gamma 1 easily verified condition satisfied array w array w thus w 10 obtain c 5 w 12 infer c 6 proof proof statements simple extension proof theorem 51 suppose online algorithm found occurrence w text window slid z 1 positions right w place k copies w shifted z positions respectively reader may refer figure 3 imagining k instead two copies appear since none period w pair copies must disagree least one position end found occurrence w adversary extend found occurrence w one k copies way force algorithm get least two answers algorithm asks question whose answer k continuations adversary gives algorithm common answer stage algorithm make query answer yes according continuations according rest adversary answer query conditions ii imply least two continuations consistent answer adversary gives common answers queries distinguish remaining continuations stage algorithm make another query answers possible adversary answers least one continuation consistent replies given adversary adversary chooses one answers subsequent queries accordingly algorithm finds next occurrence w algorithm made least z slide window z positions henceforth say setup w string periods w none z period w string w 10 shortest string setup satisfying conditions theorem 61 obtained string w 12 shortest string setup satisfies condition condition ii theorem 61 obtained two last statements verified using computer search next show obtain setup satisfying conditions theorem 61 infinite sequence setups helps investigation asymptotic number comparisons required length pattern strings tends infinity infinite sequence obtained padding basic setup let u v strings padu v denotes string obtained placing copy v character u thus pad 121 general 1 theorem 62 hw z setup satisfying conditions theorem 61 w proof setup hw z satisfies conditions theorem 61 setup hw see note first indeed period w none 6 j period verify first condition theorem 61 note every column setup hw either column allzero column second condition verified similar way statement theorem follows theorem 61 applied fact 1 2 theorem 62 motivates search setups hw z satisfying conditions theorem 61 2jwj high possible best setup found following hw setup 2jwj 4 corollary theorem 62 obtain corollary 63 every exists string wm length online algorithm finds occurrences wm text length n must make least comparisons worst case using computer enumeration verified better setup possible pattern length 250 however better setups satisfy first condition theorem 61 obtained using four instead three overlaps let following lemma easily verified lemma 64 setups hu k satisfy first condition theorem 61 tighter lower bounds string matching 13 setup hu 1 20 29 32 34i example is1211213331211213331212112133312112112112133312112133312121121333121121as ju k get corollary corollary 65 every exists string wm length online algorithm uses patterntext comparisons find occurrences wm text length n must make least comparisons worst case corollary 65 asymptotically better corollary 63 best online bound obtained verified using computer search better setup four five overlaps obtained using strings length 250 believe hw z setup satisfying conditions theorem 61 8 jwj true result corollary 65 essentially best obtained using methods 7 online upper bounds next theorem exhibits interesting family strings theorem 51 tight theorem 71 every k 1 c 0 k ba proof lower bound corollary theorem 51 matching upper bound fairly straightforward case k needs care k describe algorithm works cases algorithm k ba algorithm described sequence steps text character compared aligned pattern character case mismatch occurrence pattern verified window shifted along next position pattern occurrence possible represent state algorithm step information string uxv u 2 f0 ag k v 2 ag x 2 f0 bg describing part current knowledge algorithm text characters window 0 information string indicates information available corresponding position b indicates character position known b b indicates character corresponding position known b state written specified form necessary window shift information string must consistent pattern algorithm makes b queries choose forget negative information represented b shall call 1st position window bposition others apositions aposition always queried bposition always queried b terms information strings algorithm simply described 0 information string query rightmost 0 ag query bposition 14 cole hariharan paterson zwick procedure repeated text string exhausted prove upper bound first establish following pair invariants invariants ii contain subword 1 invariant holds x become b information string form u0a following shift x 6 b invariant ii tests u made shifted u come v separated previous contents u x previous information string nearly comparisons associated text positions following way query made aposition associated corresponding text position bposition queried b result associated text position result b care needed since k result represented 0 u however case shift size 1 made invariant ii least one 0 shifted information string query associated text character corresponding one 0 remaining case bposition queried query associated text position note query shift 1 made resulting information string made step changes clearly accumulative shift least positions must occur two extra queries upper bound follows corollary get theorem 51 also tight members k ba family applied corollary 72 k 2 ca k ba maxfkg2 8 lookahead useful section present string matching algo rithm specifically tailored string abaa algorithm uses window size eight performance matches general lower bound obtained abaa using theorem 41 thus 8 4 abaa therefore string lookahead useful abaa algorithm presented sheds light intricacy optimal string matching algorithms description quite complicated optimal algorithms longer strings may even complicated descriptions algorithm string abaa algorithm requires window size 8 state algorithm given information string oe 2 8 k1 f0 b bg k oe represents information known text symbols prefix window describe algorithm specify state next query made amount shift next state corresponding two possible answers represent queries b queries single double underline respectively appropriate symbol information string example state p table 1 query made fourth position window certain information strings task finding pattern occurrences decomposes two logically disjoint tasks checking occurrences finite prefix checking remainder state represented tables pair states connective phi example state r table 1 seventh symbol found sufficient check separately occurrences within tighter lower bounds string matching 15 transitions state inf query match mismatch state shift state shift r a00a000 table main transition table abaa algorithm new state state inf query match mismatch worstcase cost a0aa g a00a00a phi b f 4 table secondary transition table abaa algorithm r u 45 fig 5 transition diagram abaa algorithm first five positions state f text string beginning sixth position state q table shows finite subproblem arises way next query made number queries required worst case resolve subproblem latter computed recursively following transitions table 2 p table 2 indicates full occurrence pattern found treatment current subproblem finished indicates treatment current subproblem ended without finding occurrence table 1 main part algorithm presented graph showing transitions states table 1 given figure 5 corresponding number comparisons make transition finish consequent subproblem resulting shift shown arrow verified worst case corresponds iterating cycle prs proves c 4 abaa 8 7 9 concluding remarks hardest string find perhaps disappointing answer aba mum dad know c 3 string w gg92 believe c established yet except jwj 8 ch92 would imply aba like strictly hardest strings find interesting note shown c 3 exact value caba known yet know 6 3 task computing exact value c 0 w three variants every given pattern w seems present hard constants c principle computed algorithmically since online algorithm finite number states representing current information finite number possible next queries among optimal online algorithms w next query depends information state finite though huge number different algorithms kind every w task finding cw c w may even harder know present whether cw c w always rational although would odd small gap still remains lower bounds upper bounds cole hariharan ch92 closing gap practical value think may reveal many interesting properties strings string matching algorithms acknowledgment authors thank anonymous referee suggestions improved paper r algorithms finding patterns strings boyermooregalil string searching strategies revisited optimal canonization substrings string analysis boyermoore type string searching algorithms efficient comparison based string matching fast string matching algorithm tight bounds complexity boyermoore algorithm correctness efficiency pattern matching algorithms tighter upper bounds comparison complexity string matching patterns hard find exact complexity string matching speeding two stringmatching algorithms exact complexity string matching lower bounds exact complexity string matching upper bounds new proof linearity boyermoore string searching algorithm fast pattern matching strings tr
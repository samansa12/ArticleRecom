cryptography quadratic function fields describe several cryptographic schemes quadratic function fields odd characteristic real imaginary representation field present diffiehellmanlike key exchange protocol well publickey cryptosystem signature scheme elgamal type several schemes improvements systems previously found literature others new systems based appropriate discrete logarithm problem imaginary setting discrete logarithm problem ideal class group field equivalently jacobian curve defining function field real case problem question task computing distances set reduced principal ideals monoid suitable operation currently best general algorithms solving discrete logarithm problems exponential subexponential fields high genus resulting possibly higher level security conventional discrete logarithm based schemes b introduction since introduction wellknown diffiehellman key exchange protocol 16 many cryptographic schemes based discrete logarithms variety groups even semigroups developed among signature scheme due elgamal 17 basis us digital signature standard 28 notable elgamal also presented discrete logarithm based publickey cryptosystem 17 finite group semigroup g fast operation sufficiently difficult discrete logarithm problem dlp lends use discrete logarithm based cryptography diffie hellman well elgamal used multiplicative group finite prime field buchmann et al based key exchange protocol discrete logarithms ideal class group imaginary quadratic number field 10 9 first example nongroup underlying discrete logarithm based system set r reduced principal ideals real quadratic number field admits structure first explored shanks 35 termed infrastructure key exchange protocol using elements r keys introduced 11 research supported nsf grant dms9631647 implemented 33 signature scheme using set briefly mentioned 8 ideas subsequently adapted real quadratic function fields finite fields set reduced principal ideals exhibits analogous infrastructure first discrete logarithm based system real quadratic function fields odd characteristic key exchange protocol 34 followed signature scheme 32 key exchange signature algorithm even characteristic 27 schemes real quadratic function fields number fields oblivious transfer protocol discussed 7 function field schemes faster simpler easier implement corresponding number field systems use finite field arithmetic thereby eliminating problem rational approximations underlying dlp currently solved exponential time whereas corresponding problem number fields subexponential algorithm known thus fields seem represent promising setting cryptography paper considers variety discrete logarithm based cryptographic schemes quadratic function fields odd characteristic present diffiehellmanlike key exchange protocols well elgamallike signature schemes public key systems real imaginary model field implementations hyperelliptic systems see 24 using ideal class group imaginary quadratic function field discussed real setting quadratic function field simplify key exchange algorithm 34 also improve signature schemes 32 27 shortening signatures finally provide rigorous meaningful complexity analysis systems 34 32 27 investigate security relationship relevant discrete logarithm problems fields considering function fields kc elliptic hyperelliptic curve c genus g finite field k odd characteristic write c form polynomial coefficients k imaginary case 2g2 real case simple convert imaginary representation real one example replacing dt dt gamma1 2g2 noting kt reverse possible dt root 2 k corresponding ramified rational prime divisor kkt replace dt dt 29 hence real setting general preliminary investigation 30 suggests arithmetic underlying cryptographic schemes approximately complexity shows roughly equal practical performance real imaginary model choice setting conducting cryptography real versus imaginary would depend performance issue well question difficult dlp either model currently best known general algorithms solving problem exponential cases next section summarize necessary basics quadratic function fields required algorithms complexities stated section 3 present cryptographic schemes section 4 analyze security section 5 quadratic function fields introduction function fields refer reader 39 quadratic function fields discussed considerable detail 6 let finite field odd characteristic q elements quadratic function field quadratic extension k rational function field kt k variable specifically polynomial coefficients k may assume squarefree k real quadratic function field degree degd even leading coefficient sgnd square k k imaginary quadratic function field otherwise k imaginary degd odd degd even sgnd square k latter case k real quadratic quadratic extension k henceforth exclude case elements k form ff kt conjugate ff g denotes genus k k elliptic function field hyperelliptic function field 1 imaginary k real extract fixed square root field k1t puisseux series k k k1t case every nonzero element ff 2 k representation 6 0 set denote kt ring polynomials coefficients k variable let kt integral closure kt k ktmodule rank 2 basis f1 dg integral oideal subset ff fi 2 2 ff ff 2 fractional oideal subset k da integral ideal nonzero 2 kt every fractional ideal osubmodule k orank 1 ie exists ff 2 k fff j 2 og principal ff generator write ff henceforth ideals fractional integral assumed nonzero term ideal always synonymous nonzero ideal every integral ideal ktmodule rank 2 ktbasis dg may assume q monic subtracting suitable multiple q p degp q p unique primitive primitive q monic degp pair q p standard representation see 30 36 37 also use term adapted basis said standard form practice require degree inequality degp insist q monic primitive ideal reduced degq g genus k hence every reduced ideal uniquely represented pair polynomials divides g small representation makes reduced ideals suitable computation set nonzero fractional ideals k multiplication defined follows b fractional ideals product ab consists finite sums products form fffi ff 2 fi 2 b multiplication infinite abelian group identity set p nonzero fractional principal ideals infinite subgroup finite index h 0 ideal class number k factor group ideal class group k note also set integral ideals submonoid two fractional ideals b equivalent lie coset c ie b 2 k element relative generator respect b write b every equivalence class ideals contains least one finitely many reduced ideals k imaginary class unique reduced representative 6 however k real many reduced representatives ideal class fact many oq g reduced ideals imaginary case base cryptographic schemes arithmetic ideal class group c k ideal class represented reduced representative product two reduced ideals generally reduced however one compute reduced representative class product ideal quickly thus set reduced ideals monoid following operation given two reduced ideals b let b reduced ideal class ab underlying discrete logarithm problem dlp class group c given reduced ideals g g unfortunately approach fails real quadratic setting due fact many reduced representatives ideal class restrict finite subset r p reduced principal ideals exactly define distance ffi reduced principal ideal degree generator minimal nonnegative degree n 2 n0 call reduced principal ideal n minimal r monoid following operation given two reduced principal ideals b let b ideal b underlying dlp following given reduced principal ideals g reduced principal ideal xffig find x mod r r maximal distance regulator k see problem polynomially equivalent problem finding distance reduced principal ideal imaginary real case require efficient algorithms following tasks ffl given two reduced ideals standard form compute standard representation product ideal ffl given product ideal compute reduced representative class real setting need solve additional problem ffl given n 2 n compute reduced principal ideal n algorithms real imaginary models composition operation implementation complexity previously studied considerable detail imaginary setting refer reader 12 29 30 real case discussed 36 34 32 30 detailed complexity analysis explicit constants found 30 make paper somewhat selfcontained restate composition procedures sketch proofs correctness performance algorithms pertaining imaginary setting prefix name analogously algorithms apply real case begin letter r use complexity model 30 complexity estimates stated terms elementary field operations quadratic complexity multiplication inversion field elements assume standard complexity estimates polynomial arithmetic described example pp 109f 13 particular multiplication two polynomials respective degrees n n requires omn field operations division remainder uses onm field operations computation extended gcds takes om 2 field operations see also 30 last result first algorithm computes product two primitive ideals valid real imaginary setting output standard form algorithm mult ideal multiplication real imaginary case input q p two reduced ideals ideals principal real case primitive ideal standard form principal real case ab imaginary case need output algorithm 1 gcdq 2 else 3 q c proposition 31 parameters c computed algorithm mult satisfy algorithm performs og 2 field operations proof correctness algorithm proved section ii2 36 real case follows 12 imaginary case degree bounds follow fact b reduced standard form complexity result see proposition 5 30 2 henceforth need treat imaginary real settings separately begin imaginary situation first describe composition operation computes unique reduced representative class product ideal ab b two reduced ideals procedure uses two different types reduction steps first step used beginning reduction process produce reduced ideal second step computationally efficient first step used subsequently reduced ideal obtained algorithm iredstep1 initial reduction step imaginary case primitive ideal standard form ideal equivalent standard form algorithm q gamma p 2 q gammap algorithm iredstep2 subsequent reduction step imaginary case input output q 2 ideal equivalent standard form algorithm q gammap observe reduction steps degq algorithm icomposition ideal composition imaginary case input q p two reduced ideals standard form reduced ideal equivalent ab standard form algorithm 1 2 degq c g 21 22 23 degq c g 231 proposition 32 ideal c computed algorithm icomposition reduced ideal equivalent ab standard form furthermore algorithm performs og 2 field operations proof correctness algorithm see 12 theorem 1 30 complexity procedure cryptographic schemes require algorithm exponentiation reduced ideals method based standard repated squaring multiplying technique used ordinary exponentiation see example algorithm 123 p 9 13 algorithm iexp exponentiation imaginary case input q p n q p reduced ideal standard form n 2 n 0 reduced ideal equivalent n standard form algorithm 1 11 else 12 compute binary representation 13 14 1 l 142 b proposition 33 ideal computed algorithm iexp reduced ideal equivalent n algorithm performs omaxf1 g 2 log ng field operations proceed real setting brevity set dc ie polynomial part fixed square root defined section 2 imaginary model two reduction steps first one applied immediately ideal multiplication second efficient one subsequent use output ideal standard form even input ideal recall reduced principal ideals form finite set g reduction steps also used move ideal r 2 r next reduced principal ideal r i1 1 applying reduction r yields r 1 movement r periodic fq represents basis reduced ideal r reduction steps produce reduced representation next ideal r i1 degp fact p agree two highest coefficients 36 real setting reduced ideals produced algorithms reduced form user prefers ideals standard form easily convert reduced representation q p standard representation replacing p p mod q degp algorithm rredstep1 initial reduction step real case primitive principal ideal primitive principal ideal p algorithm 1 2 p gamma algorithm rredstep2 subsequent reduction step real case input output q 2 primitive principal ideal p algorithm 1 2 p gamma reduction steps degq ideal reduced case degq 2 input ideal reduced output ideal also reduced reduced representation particular degq let 1 sequence primitive principal ideals i1 obtained applying one reduction steps 2 n 0 associate ideal k set conjugate since ff ff hence 2 next algorithm shows obtain primitive principal ideal reduced one input ideal reduced simply apply reduction steps obtain reduced ideal q p ie degq g since reduction step reduces degree q least 2 must eventually happen algorithm rreduce ideal reduction real case input q p q p primitive principal ideal reduced principal ideal reduced form ffl degree relative generator b respect algorithm 1 2 degq b g 21 q q 22 23 degq b g 231 232 ffl 24 proposition 34 ideal b computed algorithm rreduce reduced principal ideal reduced form ffl degree relative generator b respect proof proof b reduced principal ideal reduced form see 36 suppose reduction steps algorithm generate ideals minimal degq g i1 first reduced ideal sequence end loop ff end algorithm correct 31 2 sequence reduced principal ideals r i1 obtained applying reduction step r 2 n relative distance r r 1 relative distance ffi i1 nonnegative function set r reduced principal ideals strictly increases since dega reduced representation r 31 implies particular r generator minimal degree r case ffi simply called distance r denoted ffi r hence general reduction steps starting r yield r regulator k r reduced principal ideal k unique reduced principal ideal r ideal b reduced principal ideal point computation b require knowledge ffi ffi b oftentimes need advance reduced principal ideal certain specified length r example multiply two reduced principal ideals b using mult reduce result using rreduce still need perform reduction steps actually reach ideal b next five algorithms give output reduced principal ideal together error ffl distance input difference distances input output ideals error always integer gammag 0 note however ideal distances never used algorithm radvance advancement r real case input q p reduced principal ideal reduced form k 2 n 0 reduced principal ideal reduced form algorithm 1 2 ffi k 21 22 ffi k 221 222 23 ffl proposition 35 quantities b ffl computed algorithm radvance respectively reduced principal ideal ffi ak value ffi b agammak furthermore algorithm performs og delta maxfk gg field operations proof step value ffi relative distance ideal basis q 32 final ideal b maximal distance ffi b k thus reduced principal ideal degrees p q bounded g 1 step 21 requires og 2 field operations since 32 reduction step advances value ffi least 1 loop step 22 executed k times provided k 0 reduction step step 221 performs og dega operations 32 sum degrees values offib ok total number operations performed step 2 ogk 2 note one could slightly improve algorithm radvance replacing reduction step step 221 call rredstep2 adding appropriate inputs algorithm avoided order keep description algorithm simpler transparent algorithm rcomposition ideal composition real case input q p two reduced principal ideals reduced form algorithm 1 2 3 proposition 36 algorithm rcomposition computes reduced principal ideal b quantity b furthermore algorithm performs og 2 field operations proof let c ideal generated step 2 computes ideal ffi c b correct value ffl since 0 see 36 step 3 performs 2g reduction steps 32 fact according 30 algorithm performs 21g 2 og field operations 2 complexity results proofs propositions 32 36 show composition real imaginary model perform essentially speed computer implementation authors 30 confirms true performance composition operations practice using repeated applications algorithm rproduct combination radvance adapt binary exponentiation technique mentioned earlier compute reduced principal ideal reduced ideal nffia algorithm rexp exponentiation real case input q p n q p reduced principal ideal reduced form n 2 n 0 reduced principal ideal nffia reduced form algorithm 1 ffl 0 2 21 else 22 compute binary representation 23 24 1 l 241 242 243 b 2431 2432 proposition 37 ideal computed algorithm rexp reduced principal ideal nffia fur thermore algorithm performs omaxf1 g 2 log ng field operations proof first observe 1 reduced representation reduced principal ideal nffia assume n 0 set show end ith iteration loop b reduced principal ideal ffi ffl correct consider 1st iteration loop step 241 produces reduced principal ideal b 2ffib 242 generates reduced principal ideal b correct suppose b reduced principal ideal b finally step 2432 generates reduced principal ideal b i1 gammag ffi ffl 0 values ffi ffl throughout algorithm radvance call advances distance og hence complexity result follows propositions 36 35 2 using previous algorithm generate reduced principal ideal nonnegative integer k make use fact r reduced form r distance g first compute reduced principal ideal using rexp base ideal r 2 exponent n apply reduction steps reach reduced principal ideal algorithm rbelow generates ideal specific distance real case output q reduced principal ideal k algorithm 1 n 2 q p 3 q proposition 38 algorithm rbelow computes reduced principal ideal r k quantity k furthermore algorithm performs og 2 log field operations proof 4 cryptographic schemes present three cryptographic schemes real imaginary quadratic function fields namely key exchange protocol publickey system signature scheme system uses exponentiation method corresponding composition operation field k chosen q g large details choice field given next section simplicity specify generating polynomial monic begin imaginary case schemes require following precomputation iprecomputation precomputation imaginary case 1 generate odd prime power q 2 generate random squarefree monic polynomial 2 f q odd degree 3 generate random ideal 4 publicize q q p key exchange protocol imaginary case precomputation alice bob jointly obtain q q p performing iprecomputation protocol 1 alice 11 secretly generates integer 0 q bg2c 12 computes q p iexpq 13 transmits q p bob 2 bob 21 secretly generates integer b 22 computes q 23 transmits q b p b alice 3 alice computes q 4 bob computes q parties computed unique reduced ideal equivalent r ab standard form use polynomials q previously agreed upon portion thereof key since b reduced standard form parties transmit approximately 2g log q bits information publickey cryptosystem imaginary case key generation participants jointly obtain q q p performing iprecomputation participant 1 secretly generates integer 0 q bg2c 2 computes q p iexpq 3 makes q p public key secret key encryption encrypt message sender secret key 1 looks recipients public 2 computes q 3 repeat 31 generates bit string x 2 n obtained concatenating coefficients f q polynomial 32 removes first block 33 sends ciphertext phi x bitwise exclusive orof x encrypted decryption decrypt ciphertext c recipient secret key r 1 looks senders public key q 2 computes q 3 repeat 31 generates bit string x 2 n obtained concatenating coefficients f q polynomial 32 removes first block c c x c 33 computes c phi x c decrypted 4 concatenates blocks obtain plaintext q parties compute reduced ideal q thus polynomial q k bit string x since degq k g block c ciphertext approximately log q bits long next scheme requires collisionresistant oneway hash function hash takes input message polynomials q p reduced ideal standard form produces positive integer values exceeding q bg2c inputs hash function also thought bit strings concatenate q p idea using hash function described first presented 27 used signature scheme based real quadratic function field characteristic 2 signature scheme imaginary case precomputation participants jointly 1 obtain q q p performing iprecomputation 2 agree cryptographically secure hash function hash n theta f q g theta f q f q denotes set polynomials f q degree participant 1 secretly generates integer 0 q bg2c 2 computes q p iexpq 3 makes q p public key secret key signature generation sign message signer secret key 1 secretly generates integer r 2 computes q r 3 computes 4 computes r gamma 5 sends signature q along message signature verification verify signature q message verifier 2 computes q 3 looks senders public key q p 4 computes q 5 computes q r 6 accepts signature q r 0 show verification procedure correct first observe p reduced ideal p reduced representative ideal class inverse class group c ideal class clear reduced standard form multiplying using algorithm mult gives result ideal 1 0 q forge signature adversary needs generate reduced ideal integer q p necessary use hash function prevent following attack suppose replaced message block adversary simply pick random positive integer compute reduced ideal q r p r equivalent forged signature q would always accepted verifier hash function forces signer generate reduced ideal q r p r computing rather making possible choose first generate fitting reduced ideal q r p r transmission signature requires approximately 3g log q bits information signatures somewhat shortened imposing smaller upper bound continue cryptographic schemes real setting schemes require participant generate reduced principal ideal together distance easiest way achieve generate random nonnegative integer desired size compute q p schemes also require precomputation dc done using puisseux diagram see 23 common precomputation schemes rprecomputation precomputation real case 1 generate odd prime power q 2 generate random squarefree monic polynomial 2 f q even degree 3 compute b dc 4 publicize q protocol given slight improvement versions given 34 27 eliminates need including reduced ideal set public parameters key exchange protocol real case precomputation alice bob jointly obtain q performing rprecomputation protocol 1 alice 11 secretly generates reduced principal ideal q p distance 12 transmits q p bob 2 bob 21 secretly generates reduced principal ideal 22 transmits q b p b alice 3 alice computes q 4 bob computes q parties compute reduced principal ideal q affib use q k p k previously agreed upon portion thereof key imaginary case parties transfer approximately 2g log q bits information public key cryptosystem real case key generation participants jointly obtain q performing rprecomputation participant 1 secretly generates reduced principal ideal q p distance 2 makes q p public key ffi secret key encryption encrypt message sender secret key ffi 1 looks recipients public 2 computes q 3 repeat 31 generates bit string x 2 n obtained concatenating coefficients f q polynomial 32 removes first block 33 sends ciphertext phi x exclusive orof x encrypted decryption decrypt ciphertext c recipient secret key ffi r 1 looks senders public key q 2 computes q 3 repeat 31 generates bit string x 2 n obtained concatenating coefficients f q polynomial 32 removes first block c c x c 33 computes c phi x c decrypted 4 concatenates blocks obtain plaintext parties compute reduced principal ideal q thus polynomial q k bit string x block c ciphertext approximately g log q bits long next scheme improvement signature scheme 27 generates shorter signatures use cryptographically secure hash function similar one used corresponding scheme imaginary fields signature scheme 32 failed take consideration precomputation participants jointly 1 obtain q performing rprecomputation 2 agree cryptographically secure hash function hash n theta f q g theta f q g participant 1 generates reduced principal ideal q p distance 2 makes q p public key ffi secret key signature generation sign message signer secret key ffi 1 secretly generates reduced principal ideal r distance 2 computes 3 computes 4 sends signature q along message signature verification verify signature q message verifier 2 computes q 3 looks senders public key q p 4 computes q 5 0 51 computes q 52 computes q r 53 accepts signature q r else 54 computes q 56 accepts signature q b 0 check verification procedure write first 0 r 0 reduced principal ideal assume 0 0 reduced principal ideal forge signature q r p r opponent must generate reduced principal ideal integer following properties 0 r reduced principal ideal smffia 0 b reduced principal ideal similarities two cases best seen follows let ffi step 2 verification procedure 0 write must r distance 2g gammag must b distance within g r transmission signature requires 3g log q bits information signatures 27 3g log q 4g log q bits long signatures could shortened imposing tighter bounds ffi discuss possible attacks cryptographic schemes explore size underlying sets need ensure class group c imaginary setting set r reduced principal ideals real setting sufficiently large order c simply ideal class number h 0 consider real case let regulator field size r determined size r elliptic case even h order jacobian j curve c defining function field k ae h 0 imaginary case rh 0 real case see 40 wellknown see example theorem v115 p 166 39 l polynomial kjk algebraic integer absolute value p q hasseweil theorem see theorem v21 p 169 39 follows means imaginary field approximately q g ideal classes c analyzing size r real case slightly complicated ensure large regulator need make h 0 small possible strong heuristic argument 34 also section 341 pp 107111 37 analogous cohenlenstra heuristic real quadratic number fields 14 15 shows probability order odd part ideal class group exceeds x 12x olog xx 2 fact elliptic case strong numerical evidence ideal class groups behave according heuristic 19 20 proved sufficiently large q probability h time easy find real fields whose ideal class number odd example result zhang 41 suffices choose irreducible k product two odddegree irreducibles kt hence choices h 0 small high probability close q g reduced principal ideals k hence foil exhaustive search attack ensure q g sufficiently large considerations good choices q g discussed point within considerations users take advantage following tradeoff small q large g complexity analysis section 3 results good performance terms field operations field arithmetic dominate computation times g small q large field arithmetic fast number field operations performed algorithms increase thus one could select q g way optimize performance ensuring sufficient level security systems explore possibility breaking schemes begin imaginary model relevant problem underlying three schemes dlp class group c k given two ideals g g x x 2 f0 find discrete logarithm x obvious schemes polynomialtime reduction algorithm solving dlp algorithm breaking system since way compromising schemes known focus attention difficulty dlp c ideal class group c isomorphic jacobian j dlps c j polynomially equivalent first observe certain cases dlp jacobian elliptic hyperelliptic curve reducible dlp finite field case using hyperelliptic function fields represents advantage using finite fields implementation discrete logarithm based cryptosystems exactly curve c supersingular 25 largest prime divisor h 0 divide small k dlp f q k feasible 18 currently unknown whether reductions possible situations cited 4 probabilistic algorithm computing discrete logarithms j case q prime given technique subexponential complexity expc log q g log log q g c 0 constant small compared g algorithm may generalizable odd prime powers q seems infeasible practice sufficiently large parameters one could foil attack based method choosing q large genus g small general technique analogous pohlighellman 31 used compute discrete logarithms c complexity method essentially order p p p largest prime factor h 0 attack requires h 0 known technique described 24 used compute h 0 generating coefficients l polynomial lt method works particularly well small g another algorithm computing among quantities h 0 given 3 polynomial size q exponential g hence might feasible determine h 0 particularly small g pohlighellman attack infeasible unless h 0 smooth ie small prime factors real setting two problems relevant possible attacks cryptoschemes distance problem dp r requires computation distance reduced principal ideal dlp r problem finding x mod r given reduced principal ideals g reduced principal ideal xffig problems equally difficult hence problem breaking schemes polynomialtime reducible either problem proposition 51 polynomialtime reduction dlp dp vice versa proof suppose first solve instance dlp let r reduced principal ideal wish find ffi r let ffi g let r 0 ideal suppose call radvanceq r sequence reduced principal ideals store memory 3g 1 52 hence g using use dlp algorithm determine ideal r distance reduced principal ideal r yffi 2 discrete logarithm 2 dlp procedure one give correct answer might give wrong meaningless answer answer us check one candidates correct one using following simple technique l candidate ffi r compute q assume know compute distances let g reduced principal ideals reduced principal ideal xffig x 2 n 0 task find x mod r first compute bounds uniquely determine integer x ffi g g case clearly three systems broken fast algorithm dlp dp difficulty dlp already discussed 34 briefly repeat arguments shown 37 38 simple bijection set f0 multiples p except p maps r 1 onto 0 r onto ip 2 p point certain elliptic curve f q consequently polynomialtime reduction dlp r dlp group points elliptic curve given two points p q curve also polynomialtime reduction opposite direction dlp elliptic real function fields characteristic equal 3 polynomially equivalent dlp elliptic curves finite field since best known algorithm computing discrete logarithms elliptic curve finite field f q complexity order p q provided curve supersingular require point exponential time compute discrete logarithms set reduced principal ideals elliptic function field hyperelliptic real fields equivalence type discussed best known general algorithms computing discrete logarithms regulator r field complexity oq 2ggamma15 see theorem 2233 p 78 37 log q 2g small compared g discrete logarithms including regulator computed probabilisticly subexponential time expc log q g log log q g c 0 constant 26 theorem 632 p 203 37 algorithm appear feasible practice nevertheless safe one might wish choose q large relative g computations 34 show elliptic case performed best computationally 50 digit prime q call rexp 50 digit exponent required 376 seconds silicon graphics challenge workstation optimization implementation undoubtedly produce faster running times pohlighellmanlike technique computing discrete logarithms real quadratic function field characteristic 2 described considerable detail 27 easily adapted work real fields odd characteristic algorithm requires knowledge regulator r usual running time essentially square root largest prime factor r method pose threat cryptographic schemes time q g sufficiently large 100 decimal digits seems sufficient current computer technology r smooth thus parameters chosen care fastest currently known methods breaking schemes exponential contrast systems based discrete logarithms finite fields dlp subexponential 2 well corresponding systems quadratic number fields real imaginary relevant dlps also solved subexponential time 22 1 thus systems might well secure real key exchange protocol also significantly faster corresponding scheme real quadratic number fields 11 33 see computations 34 although data available systems would perform relative elliptic curve systems 5 unfortunately instances information needs transmitted original diffiehellman elgamal systems let l size underlying set ie original diffiehellman elgamal schemes finite field f p l g g schemes diffiehellman keys require log l bits transmission whereas keys twice long similarly elgamal signatures size 2 log l signatures 3 log l bits long however mentioned made shorter say 2 log l bits well reduce upper bound parameters q g2 q g4 even smaller quantities consider schemes secure r ein algorithmus zur berechnung der klassenzahl und des regulators reellquadratischer ord nungen subexponential algorithm discrete logarithms finite fields counting rational points curves abelian varieties finite fields subexponential algorithm discrete logarithms rational subgroup jacobians large genus hyperelliptic curves finite fields quadratische korper im gebiete der hoheren kongruenzen cryptographic protocols based realquadratic afields ex tended abstract cryptographic protocols based discrete logarithms realquadratic orders computing jacobian hyperelliptic curve course computational algebraic number theory heuristics class groups heuristics class groups number fields new directions cryptography publickey cryptosystem signature scheme based discrete logarithms remark concerning mdivisibility discrete logarithm divisor class group curves special case cohenlenstra heuristics function fields class group frequencies real quadratic function fields degree 4 case rigorous subexponential algorithm computation class group theorie der algebraischen funktionen einer veranderlichen reducing elliptic curve logarithms logarithms finite field computing discrete logarithms real quadratic congruence function fields large genus discrete logarithm based cryptosystems quadratic function fields characteristic 2 national institute standards technology real imaginary quadratic representations hyperelliptic function fields comparing real imaginary arithmetics divisor class groups hyperelliptic curves improved algorithm computing logarithms gf p cryptographic significance cryptography real quadratic congruence function fields key exchange protocol using real quadratic fields infrastructure real quadratic field applications baby stepgiant stepverfahren reellquadratischen kongruenzfunktionenkorpern mit charakteristik ungleich 2 algorithmen reellquadratischen kongruenzfunktionenkorpern equivalences elliptic curves real quadratic congruence function fields algebraic function fields codes artins theorie der quadratischen kongruenzfunktionenkorper und ihre anwendung auf die berechnung der einheiten und klassengruppen ambiguous classes 2rank class groups quadratic function fields tr keyexchange system based imaginary quadratic fields hyperelliptic cryptosystems key exchange system based real quadratic fields remark concerning italicmitalicdivisibility discrete logarithm divisor class group curves course computational algebraic number theory keyexchange real quadratic congruence function fields discrete logarithm based cryptosystems quadratic function fields characteristic 2 computing discrete logarithms real quadratic congruence function fields large genus real imaginary quadratic representations hyperelliptic function fields class group frequencies real quadratic function fields cryptographic protocols based discrete logarithms realquadratic orders cryptographic protocols based realquadratic afields subexponential algorithm discrete logarithms rational subgroup jacobians large genus hyperelliptic curves finite fields counting rational points curves abelian varieties finite fields comparing real imaginary arithmetics divisor class groups hyperelliptic curves ctr ian f blake theo garefalakis complexity discrete logarithm diffiehellman problems journal complexity v20 n23 p148170 apriljune 2004
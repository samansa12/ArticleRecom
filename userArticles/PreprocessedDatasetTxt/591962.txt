searching global search algorithm report case study assess use advanced knowledgebased software design technique programmers participated techniques development use kids approach algorithm design construct two global search algorithms route baggage transportation net construction second algorithm involves extending kids knowledge base experience case study leads us integrate approach spiral prototyping models software engineering discuss ways deal incomplete design knowledge b introduction advanced techniques support software construction widely accepted practitioners successfully used software engineers involved development get onsite training inventors experience gained knowledgebased methods integrated practical software engineering process report experience made application approach algorithm design underlying kestrel interactive development system kids 14 construction control software simplified baggage transportation system airport paper use term kids approach denote concepts implemented system kids approach applied number case studies kestrel institute par ticular used design transportation scheduling algorithm impressive performance 15 16 wished find able use method based available publi use implemented system kids case study cations produce satisfactory results reasonable effort second goal work study knowledgebased approach integrated overall software engineering process case study chose nontrivial abstraction practically relevant problem make experience transferable realistic applications following elaborate two issues process model found useful support application kids approach merits shortcomings encountered explored alternative solutions transportation scheduling problem integrated spiral prototyping models software engineering 2 kids approach developed first formal specification prototype implementation parallel prototype served validate specification improve understanding problem domain kids approach global search algorithms constructed specializing global search theories abstractly describe shape search tree set algorithm case study wished explore two alternative search ideas found theory suitable first one literature second one could realized documented design knowledge lead us develop new global search theory needs slightly modified specialization procedure section 2 introduce baggage transportation problem section 3 provides brief review global search theory kids approach present integration process model section 4 design two transportation schedulers described section 5 optimizations sketched section 6 also discuss resulting algo rithms summarize experience approach section 7 baggage transportation scheduling wish develop controller transportation baggage airport pieces baggage transported checkin counters gates gates gates gates baggage delivery points controller must schedule baggage network way piece arrives destination due time simplify problem consider online scheduling continuous flow baggage fed system checkin counters schedule baggage checkedin particular point time 21 domain model model transportation net directed graph shown figure 1 checkin counters baggage delivery counters gates switches represented nodes classify three kinds input nodes transportation nodes output nodes checkin counters correspond input nodes switches transportation nodes baggage delivery counters output nodes since gates serve load unload airplanes represent input output node edges graph model conveyor belts capacity belt maximum amount baggage total weight carry time velocity time takes carry piece start node gate g2 gate g1 gate g3 gate g4 delivery d1 delivery d2 checkin c1 checkin c2 ceckin c3 checkin c4 checkin c5 figure 1 transportation network piece baggage described weight source destination nodes due time source destination input output nodes respectively weight due time positive natural numbers due times specified relative beginning transportation process 22 problem specification task assign piece baggage route network leading source destination node due time keep things sim ple require acyclic network without depots function transport plan g graph acyclicg returns domqfeasible pathg b sndqbg figure 2 problem specification transportation nodes thus way resolve scheduling conflicts arise capacities conveyor belts exceeded delay baggage source nodes route therefore pair delay path network plan maps pieces baggage routes attempting find plan particular set baggage makes sense exists feasible path piece path p network g leading source destination nodes piece baggage b feasible pathg b p pathg p 1 note require punctual schedule exist wish find plan every case punctual without delaying baggage input nodes possible thus define cost function based criteria baggage delivered time baggage delayed input nodes cost baggage time delays 1 yes yes 3 example imagine suitcase b 1 gate another one b 2 c 4 figure 1 weight 1 checked flight starting gate g 2 let transportation time belt one time unit capacity also one unit avoid exceeding capacity belt leading g 2 solution delay b 1 one time unit gives us transportation plan set problem specification shown figure 2 acyclic graph g set baggage bs feasible paths graph interested plans q baggage scheduled domq total amount baggage belt time exceed capacity capacity bounded assigned paths feasi ble set select plan p minimal cost 3 design global search algorithms basic idea algorithm design kids approach 12 14 represent design knowledge design theories theory logical characterization problems solved algorithmic paradigm like divide conquer global search algorithm design consists showing given problem instance design theory following briefly summarize global search algorithms developed kids approach full account refer reader 13 14 31 design theory problem specification quadruple hd r oi input domain r output range function f synthesize predicate bool describes admissible inputs describes inputoutput behavior f hence f r solution p design theory extends problem specification additional functions states properties functions sufficient formulate schematic algorithm correctly solves problem global search theory figure 3 describes search optimal solution respect cost function c basic idea split search spaces containing candidate solutions smaller ones solutions directly extractable r type search space descriptors defines legal descriptors input x r 0 split describe search tree solutions z ox z root r 0 x initial search space descendent relation nodes given split direct subspace r input x solutions obtainable looking single node r search tree described extractz r axiom gs3 satisfiesz r describes solutions z contained search space r found finite effort must exist finite path search tree r search space z extracted split defined since wish find globally optimal solution gs2 requires feasible solutions contained sorts dr operations r satisfies r theta extract axioms gsc total ordering c function ix returns function returns figure 3 global search theory algorithm schema initial search space axioms gs0 gs1 ensure considered search spaces legal program shown bottom figure 3 provides schematic algorithm consistent global search theory function f computes optimal solution z given input x initiating global search initial search space x actual search algorithm implemented f gs minimizes solutions directly extractable input search space r ones found recursive search spaces obtained splitting r necessary filters provide basis optimize code gained instantiating algorithm schema necessary filter phi used prune branches search tree cannot contain solutions satisfies implication r 2 32 algorithm design find global search algorithm given problem specification find search space description r operations extract global search axioms ful filled kids approach done referring knowledge search strategies concrete data structures formalized library general global search theories 2 examples theories enumerate sequences finite set enumerate mappings finite sets global search theory given problem constructed specializing theory library problem theory specializes problem theory constructively verifying existential quantifier 3 gives us systematic way find global search theory problem hand way structure search tree expressed adapted b gives us algorithm b instance algorithm schema figure 3 general algorithm inefficient high potential optimization exploited deriving necessary filters program transformation data structure refinement 4 process model presentation application domain theory problem specification section 2 describes final result specification effort develop domain theory one major tasks complex time consuming one kids approach much complexity stems two requirements demand domain theory must make precise informal usually incomplete sometimes inconsistent ideas nature context problem must also formulated aid impede subsequent design process consequence unlikely satisfying domain theory built scratch observation led us integrate kids approach prototyping spiral models software engineering 2 one cycle development sketched figure 4 three phases first concerned establishing enhancing domain theory second produces code third phase code theory tested validated found useful build first draft domain theory parallel prototype early phase shaded gray figure 4 domain theory rich enough apply algorithm design knowledge design theories building prototype enables us get deeper understanding problem used appendix 13 code prototype validation test domain theory algorithm design optimization specification validation theory validation domain application test figure 4 process model essential properties application area helps us build complete domain theory avoid deadend developments way domain model expressed data structures used properties stated much influence ease algorithm design carried thus seems one cycle design figure 4 may practice require several rounds refining domain theory formalized notions smoothly fit design theory wish use one example baggage transportation case study way modeled delays routes cf section 22 early version domain theory described repetitions input nodes paths occurrence input node denoting delay one time unit forced us introduce predicates characterize legal routes could use acyclic graph model decided reformulate theory make delays explicit theory became much elegant design much easier process theory refinement perpetuates derive filters optimize code validation test phases also serve us validate code respect properties captured design knowledge put disposal kids approach 5 two ways find transportation plans looking sort transportation plans nat theta seqvertex suggests two strategies search solutions scheduling problem 1 domain extension start initially empty map successively extend assigning possibly delayed feasible paths baggage 2 image modification start map assigns source nodes delay bag successively modify assigned routes extending paths increasing delays strategies enumerate feasible transportation plans kids approach search strategies provided library general global search ories algorithm design proceeds specializing one problem hand first condition 3 rb ra suggests match output domains problem specification ones library theories find candidates specialize began algorithm design transportation problem initial idea use image modification strategy general global search theory documented kids library 13 models image modification instead found theory describes domain extension motivated us explore approaches 51 domain extension global search theory gs finite mappings enumerates maps finite set u finite set f 7 gs finite mappings r 7 mapff fi 7 hu v iju 7 hu v r 7 setff theta setff theta mapff fi 7 hu v satisfies 7 extract 7 search space described partition u two sets map v completed map u v assigning elements v elements split performs one assignments picks arbitrary elements b v respectively extends 7 b find instantiations type variables gs finite mappings unifying output domain one transport plan ff 7 baggage route specialize gs finite mappings transport plan constructively verify 3 theories ie must find expressions bs u v prove dommfeasible pathg b sndmb predicate map defined comparing right hand side definition definition 1 feasible paths suggests use sets u 7 bs specialize gs finite mappings use upper bound mdg bs delays makes set routes finite thus ensures termination algorithm discuss termination section 7 since feasible paths baggage bs cf precondition transport plan figure 2 assign mdg bs sum times needed traverse feasible path piece baggage applying substitution ff fi u v gs finite mappings gives us global search theory transport plan r 7 setbaggage theta setbaggage theta plan 7hg satisfies 7 extract 7 resulting search strategy assigns complete routes one piece baggage another without optimization split assigns arbitrary routes pieces baggage complete plan extracted tested whether assigned routes feasible obvious way prevent infeasible assignments first place develop necessary filter instantiation 2 fact capacity bounded monotonic domain extensions gives us 52 image modification global search theory documented 11 13 14 supports searching maps image modification developed new theory purpose abstracting concrete scheduling problem image modification strategy sketched follows images given map initial sched ule increased along various degrees freedom given range type map suitable successor relation elements range type used describe direction increase images map idea formalized gs parallel mappings 3 f 7 gs parallel mappings 7 mapff fi theta setfi theta fi r 7 mapff fi 7hmsi 7hmsi n r 7 mapff fi theta setfi theta fi satisfies 7 n hmsi8x 2 dommmx nx extract 7 n inputs map successor relation search enumerates maps domain images extended along ie reflexive transitive closure domain must finite must nondense ensure gs3 holds relation antireflexive ensure progress search note search spaces sort r contain map built far also relation necessary describe satisfies solution contained search space 521 data type driven specialization captured search idea gs parallel mappings want specialize theory transportation planning problem turns corresponding instance 3 help much systematically finding cannot refer structure 3 x notation hx yi 2s range type fi gs parallel mappings still desirable develop global search theory specific structure range type transport schedules newly developed theory sufficiently abstract applicable broad range problems solve dilemma propose specialize gs parallel mappings two steps first step determines suitable successor relation second step finds substitution determine first find substitutions type variables ff fi transportation problem get ff 7 baggage analyze range type nat theta seqvertex find canonical successor relation elements based basic types composed know usual successor function natural numbers canonical way extend sequences append element analogy lexicographical orderings pairs construct successor relation extending either element pair thus define hn substitute 5 3 simplification get capacity section 51 easily determine substitution get map assigns b bs nondelayed path consisting source node b like algorithm section 51 one working image modification high potential optimization development proceeds filter construction optimization 6 optimization results algorithms resulting instantiation scheme figure 3 inefficient optimization absolutely necessary efficiency resulting code heavily depends adequate choice filters program transformations important optimizations resulting algorithm introduction priority queue search spaces simplifications often used predicates capacity bounded also eliminated common subexpressions introduced analysis transportation net respect input baggage eliminate vertices lie feasible paths ordering search spaces used priority queue encodes heuristic determine node search tree consider next used one based cost total delay length paths plan test runs algorithms show despite optimizations performance still poor also reveal algorithm based image modification factor two faster one based domain extension size theories programs summarized table 1 document lines library specifications 490 domain theory 240 algorithm theory 350 implementation 920 table 1 size theories programs specifications written specification language spectrum 3 use existing library basic spectrum specifications natural numbers sets sequences directed graphs others based modules domain theory comprises 240 lines algorithms extend domain theory 110 lines schedulers implemented functional language opal 10 translation specifications executable code optimization produces 920 lines code opal program code wellstructured highly reusable implementations share code facilitates exploring alternatives case study required effort approximately 9 person months spent one third time learn kids approach approximately 75 remaining time devoted building domain theory exists number approaches algorithm design program synthesis eg 1 4 8 9 chosen kids approach case study provides design steps reflect significant design decisions programmers described precisely logical theories way good reference points software engineers wish learn use however use kids system wanted full control design process adapt needs necessary transportation scheduling case study relates research design transportation schedulers kestrel 15 16 study schedulers assign trips resources like planes ships trucks meet movement requirements setting trips fully occupy resources interval time ie load resource cannot extended trip furthermore trip changes availability source destination one trip becomes source next one baggage transportation ever load resources continually change baggage flows net source destination points resource remain fixed time another difference lies focus work several years highly specialized theory transportation scheduling developed kestrel aim produce extremely efficient schedulers recently even led refinement abstract global search theory 16 purpose case study contrast study far kids approach documented literature support programmers particular experience approach design algorithms nontrivial problem process model steps designing global search algorithm specializing theory deriving fil ters applying optimizing program transforma tions provide clear separation concerns design specialization determines basic structure search necessary filters exploit properties application domain final program transformations data type refinements eliminate redundancies code fuse filters basic search structure gain efficiency tasks corresponds one cycle process model introduced section 4 thus model helps programmers focus activities particular task avoid introducing certain design ideas wrong time development early attempts design algorithm section 52 tried introduce optimizations early trying generate delayed routes necessary totally messed design first phase development sufficiently complete application domain theory avail able complex part process found prototyping useful understand problem domain techniques guide theory development remain established domain theory hand kids approach well suited construct prototypes little time supports exploring alternative designs termination global search theory used issue termination constructed algorithms addressed lead us somewhat unnatural introduction upper bound mdg bs delays cf section 5 termination global search algorithms spoiled two ways may branches search tree infinite length may nodes infinitely many children 14 wellfounded ordering introduced abstract global search theory prevent infinite chains splitoperations kreitz 7 formalized global search nuprl type theory 4 prevents infinite branchings search tree using finite sets malization introduces wffilters prune infinite branches proposes provide collection wf filters theory methodological reasons require termination global search theories theories used section 5 enumerate infinite number maps still would appreciate systematic way relieves programmers dealing termination onthefly dealing incomplete design knowledge seen section 52 unlikely knowledge expressed design theories fails support particular design idea although aware systematic support constructing new theories kids still worthwhile stick approach develop new design theory describes desired search strategy abstract way 5 decided construct problem specific algorithm theory section 52 one step manually verify abstract global search theory decision mainly due lack experience increased complexity task considerably led less efficient algorithm seems unlikely find practically com plete knowledge bases software construction sys tems systems designed ease routine extension knowledge bases 6 generic system architecture based notion strategies proposed strategy modules clearly defined interface system kernel new ones integrated system routine way system specware 17 development kestrel also seems allow modularized easily extendible knowledge base constructing new global search theory nontrivial task deserves support approach shall applied routinely starting point may observation search strategies often seem derive structure output domain r acknowledgement would like thank david basin maritta heisel burkhart wolff fruitful discussions klaus didrich maritta provided comments draft paper r artificial intelligence spiral model software development enhancement requirement design specification language spectrum implementing mathematics nuprl proof development system eine fallstudie zur entwicklung korrek ter software steuerung einer gepackforderanlage tool support formal software development generic ar chitecture deriving programs develop programs automating software design deductive approach program synthesis programming language opal kestrel interactive development system algorithm theories design tactics structure design global search al gorithms kids semiautomatic program development system transformational approach transportation scheduling synthesis highperformance transportation schedulers specware formal support composing software tr
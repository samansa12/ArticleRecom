methodological view constraint solving constraints effective tool define sets data means logical formulae goal survey notion constraint system give examples constraint systems operating various domains natural rational real numbers finite domains term domains classify different methods used solving constraints syntactic methods based transformations semantic methods based adequate representations constraints hybrid methods combining transformations enumerations concepts methods illustrated via examples also discuss applications constraints various fields programming operations research theorem proving b introduction constraints allow define sets data means logical formulae example set even numbers given extension set f0 2 described comprehension formula fy stating exists natural number x twice x formula subformula x constraint n domain interpretation constraints become successful computer science operation research several reasons listed convenient notation constraints provide compact simple familiar representation possibly infinite sets first reason success expressivity second reason proceeds pragmatic argument constraints allow express manipulate large sets data could reasonably handled given extension describing infinite set even numbers extension means give procedure enumerate set outputing value 2n upon input n defining set multiples 3 done manner intersection two sets computed enumerating al ternatively outputing common values 6 12 deadly risk course intersection empty contrast procedural style constraints declarative allow state properties independently actual computation mechanism called solving example set triples specified 9z z n domain interpretation intersection two sets simply expressed accumulating constraints resulting 9x z constraints indeed targetted specifying settheoretic properties efficiency declarative languages often considered inefficient third important reason constraints useful reconcile declarativeness efficiency constraint solved given domain interpretation hence efficient algorithms chosen purpose practice fetched library declarative languages would use instead general purpose solving algorithm called search example standard prolog implementation would solve system linear equations rationals using sld resolution language allowing rational constraints call gaussian elimination therefore much efficient easy combination yet fourth reason success constraints easily combined computation models example combining logic programming constraints achieved replacing unification component logic programming language constraint solving algo rithms combination logic programming computation produces new constraints consumed constraint solving algorithms turn produces new inputs logic programming computation ability efficiently compute sets constraints evolve along computation last major property constraints called incrementality constraints play key role since work alan colmerauer 6 abstract formulation joxan jaffar jeanlouis lassez 26 introduction finite domain constraints chip 16 far explained major aspect constraints directly related title paper general infinitely many ways represent set data means constraints example set even numbers could defined set nonodd natural numbers z constraint course complicated equivalent complicated mean definite answer question unless formula interested defines empty set indeed methodological view constraint solving 3 major problem avoid useless computations efficiently checking constraints emptiness summarize constraint system comes three parts 1 syntax logical formulae expressed cases firstorder language fragment thereof closed conjunction operator common existential fragment free universal quantifier positive fragment negation disjunction allowed constraints without logical connectives called atomic typical example consists conjunctions linear equations rational numbers 2 structure formulae interpreted composed domain values one hand hand operations relations interpreting symbols syntax example domain values set rational numbers usual operations solution constraint assigns free variables values domain way formula evaluates true example one solution x 27 36 3 constraint solving algorithm takes input constraint c returns output particular representation set solutions important particular case algorithm allows decide whether c least one solution called constraint satisfaction general algorithm often needed called constraint entailment decides whether set solutions constraint c included set solutions constraint c 0 gaussian elimination one algorithm used solve linear equations rational numbers describe later detail constraints finite domains pop many application areas constraints nphard makes impossible deal large application problems consequence practice sometimes favors incomplete algorithms may sometimes fail detect given constraint solution hand constraint solving algorithm must always sound pretend solution far examples deal numbers indeed constraints numbers booleans many industrial applications operations research hardware verification also applications computer science domain made expressions called terms context typical example problem solving equations terms called unification heart logic programming call symbolic constraints terms symbolic constraints used years computer science order ffl represent sets formulae constrained formula pair oe j c stands set instances oe solutions c consider arithmetic expressions built addition multiplication found 4 h comon dincbas jp jouannaud c kirchner programming languages subset expressions sums two different expressions expressed formula 9xy x 6 means x stand two syntactically different expres sions example shows expressive power constraints since set cannot defined finite automata operating trees ones used later article ffl avoid useless processing identical subterms sharing used interpreters compilers name environment binding variables example may large expression structure used implementations logic programming languages example infinite list zeros represented constraint interpreted domain lists natural numbers ffl express search strategies automated deduction allowing prune search space need complex combined constraints involving several domains interpretation arises many situations example integers often used describe parameterized families terms indicating repetition given subexpression constraints operating terms made two compo nents integer constraint symbolic constraint another example work detail sequel provided bibliographic data bases querying data base titles containing given word expressed entailment problem language combining feature constraints expressing record definitions word constraints expressing search given word goal paper describe different methods constraint solving algorithms based distinguish among complete syntactic methods commit particular representation problem domain set solutions complete semantic methods rely particular representation problem domain well set solutions hybrid methods combine incomplete syntactic semantic steps together nondeterministic steps based partial enumeration set solutions three methods described respectively sections 2 3 4 applications areas considered section 5 2 syntactic transformations 21 general setting syntactic methods based simple principle repeatedly transform constraint equivalent one socalled solved form obtained computations seen rewriting process however insist fact transformation rules applied formulas methodological view constraint solving 5 opposed coding rules simply match subformulas given patterns replace simpler formulas see techniques fall category next two sections assume twice age age since im 48 38 old expressed following constraint rational numbers transformation proceeds expect choosing variable say x replacing within equations yielding new equivalent system set solutions system simplified according elementary rational number theory resulting proceed eliminating together existential quantifier solved form hence solutions eg figure 1 age figure concepts developping example solving linear constraints rationals technique attributed gauss celebrated german mathematician 19th century actually use different problem obtained using inequalities instead equalities problem reduced first adding socalled slack variables express difference two sides equation example constraint x equivalent constraint 9z x course another formula transformation linear programming comes difficult problem linear function must optimized respect set solutions constraint form example described figure 2 general principles dantzigs simplex algorithm 14 although exponential often prefered recent polynomial algorithms interior point methods 32 two main reasons performs quasi linearly average efficient incremental version examples show ingredients transformation method constraint logical formula rule transforms constraint equivalent one 6 h comon dincbas jp jouannaud c kirchner vincent mongeardmugneret wine maker burgundy bought 20 acres good soil vosne romanee planted red pinot two options cannot changed chosen bringing manure friends farm investment per acreyear equal 1000 rise 3000 uses chemical fertilizer one acre first kind produce 1000 bottles year sold 25 dollars second produce 50 sold 20 investment next 5 years limited 200000 many acres fertilized chemicals many manure order maximize profit let us take x 1 number acres cultivated manure x 2 number acres cultivated chemicals z 1 number noncultivated acres z 2 unused slack variables variables positive process repeats following steps choose one distinct variable per equa tion ii solve system respect choosen variables iii replace lefthand side variables profit function choice variables step must ensure righthand side constants equations obtained step ii positive constant profit function obtained step iii decreased pivoting x 1 x 2 yields profit function clearly maximized taking z since coefficients negative yields profit 255000 1 figure 2 good vosne romanee methodological view constraint solving 7 equivalence proof relying algebraic property constraint domain rule comes conditions application supposed ensure termination overall transformation process rules necessarily deterministic may happen several rules applied constraint may happen two distinct instances rule applied time example solving systems linear equations step may choose eliminate unsolved variable keeping termination property nondeterminacy quite different eg nondeterminism prlog programs dont care nondeterminism commit choice without taking care possible transformations actual implementation consider addition strategy restores determinism instance case linear equation solving strategy specify ordering pivoting variables distinction strategy rules important allows reuse set rules termination proof together distinct strategies yield efficient implementations depending particular properties constraints example ordering variables eliminated may depend form system finally particular set constraints called solved forms specified solved forms supposed additional properties example case system linear equations solved form system equations every left member variable occurring anywhere else strategies designed way complete ie every irreducible constraint solved form formalizing approach following steps necessary 1 choose set solved forms set formulae solution syntactically equal formula standing empty set 2 design set transformation rules show following properties correctness applying rule set arbitrary input constraint results new constraint set solutions proving correctness usually manageable since breaks elementary correctness proof transformation rule given arbitrary constraint every sequence transformation originating results irreducible constraint finite number steps property may hard prove 3 design strategy yields deterministic set rules following property c completeness enough rules constraint solved form least one rule applies therefore 8 h comon dincbas jp jouannaud c kirchner algorithm never fails detect given constraint solution property usually simple prove easy enforce part conceptual simplicity important advantage approach provide systematic guide constraints solving applies method yields algorithm inherently incremental since new constraints always added using conjunction solved form yielding new constraint equivalent conjunction starting constraint new one 22 unification extensions approach described previous section indeed successfully used variety problems starting j herbrand 24 interested solving equations terms automated deduction purposes classical abstract formulation well known unification algorithm rediscovered late 70s martelli montanari 37 formulated operational point view presentation unification transformation rules given figure 3 inspired 6 28 general approach applied systematic way since beginning eighties two different directions show power reformulate existing constraint solving algorithm generalize unification algorithm number directions let us mention generalizations equational unification consists solving equations terms function symbols considered satisfy certain equational axioms problem using decompose rule longer complete example head symbol f rule commutative ie order two arguments irrelevant equation splited two possibilities either although still correct particular case check rule correct general many investigations equational unification motivated practical need building equational knowledge resolution inference rule theorem provers case example commutativity associativity occurs many useful algebraic structures distributivity unification modulo distributivity shown recently decidable 45 automated deduction application area techniques eventually used let us mention among many theory arising context library search related axiomatization cartesian closed categories theory originating type inference records object oriented functionnal languages theory boolean rings study motivated harware verification problems roughly speaking unification constraints formulae quantifier negation appear quantifiers occur course naturally expression various problems hence general constraints arise many applications arbitrary firstorder constraints built upon equality predicate interpreted terms called equational constraints 7 example method building methodological view constraint solving 9 unification transformation rules parameterized vocabulary used building expressions called terms use f g arbitrary function sym bols x variables arbitrary terms conjunctions equations terms called unification constraints solved forms chosen assignements terms variables constraints form variables x occurs exactly see 28 choices obtain solved form arbitrary unification constraint several transformation rules needed among two im portant decomposition simplifies equation whose left right hand side terms rooted function symbol elimination propagates necessary value variable rest unification constraint whole set transformation rules unification following delete decompose conflict check x occurs nonvariable term eliminate x replaced x occur occurs p x variable variable rules conjunction supposed associative commuta tive allowing us single equation constraint example use unification constraint fx ga transformed follows solved form associated assignment called general unifier starting unification constraint assigment solution constraint indeed obtained general unifier appropriate specialization figure 3 unification constraints counter examples theorem proving uses equational constraints quantifiers negations 4 jouannaud kounalis method inductive theorem proving 30 uses equational constraints universal quantifiers negation see 7 equational constraints also appear learning examples counterexamples described lassez marriott 35 equational constraints reduced solved form shown independenlty comon maher 11 36 solved forms purely existential hence quantifier elimination rules become necessary although still limited amount negations solved forms also negation elimination rules indeed important problem area whether negations could always eliminated equivalent negation solved form existed positive answer given tajine 48 important problem applications compilation patternmatching def initions also inductive inference examples counterexamples course operators may satisfy certain axioms associativity commutativity important applications unfortunately undecidable know whether arbitrary equational constraint solutions particular case 52 true well algebraic structures 23 constraint systems important predicates practice term orderings example surface naturally mechanizing deduction since allow reducing search space eliminating inferences satisfy certain ordering conditions see 9 31 41 12 among others term ordering constraint solving membership predicates important typed languages interpreted set membership see eg 10 constraint solving set predicates used defining computing partial interpretations logic programs see 23 problem becomes difficult general undecidable operators additionally satisfy certain equational axioms firstorder terms used lack possibility bind possibly functional variables higherorder logic functional program ming unfortunately even unification constraints become undecidable set ting however semidecidable turns huets semi decision procedure 25 used proof development systems important decidable subcase called pattern unification 39 used language prolog powerful extension ordinary prolog function symbols fixed number arguments sometimes convenient represent term record using numeric keys retrieving subterms f1 expressions used quite time natural language processing 44 generally knowledge representation name features also used together subtyping mechanims area programming languages data bases model inheritance figure 4 describes possible syntax feature constraints suggests unification rules may adapted case area feature constraints active last 10 years resulted complete methodological view constraint solving 11 constraint solver firstorder features one hand 3 53 many prototype implementations featurebased languages hand 2 46 refer 53 information feature constraints finally let us note efforts symbolic constraint solving surveyed 28 7 see also 29 42 recent works 3 semantic methods semantic methods opposed syntactic ones operate directly constraint syntax instead use another representation constraint solutions constraint solving relies use specific data structure 31 automata techniques typical example use automata idea goes back buchi early sixties consists associating formula defining constraint automaton recognizing solutions constraint see eg 49 8 automaton simple finite transition system reads string input symbols sequentially upon reading moves one state another depending current state word recognized automaton ends distinguished final state automaton associated atomic constraint construction proceeds replacing logical operations constraints set operations automata conjunction yields intersection disjunction yields union negation yields complement existential quantification yields projection logical operations constraints correspond set operations solution sets instance solutions conjunction two constraints c 1 c 2 intersection set solutions c 1 c 2 respectively since automata closed set operations automaton associated 1 2 accept solutions c 1 c 2 respectively projection explained little bit automata recognize tuples many elements number free variables constraint projection consists forgetting one components tuple keeping control automaton automaton associated constraint c satisfaction problem c equivalent emptiness decision problem c least solution iff accepts least one word tree graph automaton representation set solutions cleaned corresponds reduce solved form reused computations method incremental precise far objects automata working depends representation constraints domain values words trees graphs idea case class automata possess several closure properties emptiness decidable several automata 12 h comon dincbas jp jouannaud c kirchner features constructed three given sets set sorts also called basic types set k keys also called features set x sort variables set f feature expressions terms follows syntax given form following example feature term personage meant represent set persons whose age natural number x purpose feature constraints conjunctions equalities feature terms example one specify constraint set persons blue eyes married person age unlike ordinary trees feature terms may arbitrary number subterms sort name still feature terms unification looks pretty much like ordinary unification let us give decomposition conflicting rules decompose xkey keyconflict key 1 key 2 different sortconflict 0 different sort names rules x stand constants variables appropriate categories example x may sort person variable x example use constraint xage decompose confines x describe set x persons age figure 4 feature constraints methodological view constraint solving read 0 know number written base 2 even hence enter final state marked double circle whatever read number even stay final state figure 5 automaton accepting even numbers designed literature solving particular kind constraint let us mention classical finite state automata words finite tree automata automata equality disequality constraints tree automata free variables tree matching automata possess appropriate closure properties set operations see eg 8 details efficiency automata techniques follow directly efficiency operations automata emptiness decision get idea computational complexity let us recall classical word automata union computed constant time intersection quadratic time projection linear time complement linear time deterministic automata exponential time nondeterministic ones emptiness decision linear behaviour found automata classes determinization complement usually expensive steps let us give examples constraint solving using automata presburger arithmetic consists firstorder formulae atomic formulae built using constants 0 addition multiplication constant interpretation domain set natural numbers instance defines set even numbers assume natural numbers written base two right left example number thirteen written 1011 formula associated word automaton example 9x associated automaton figure 5 general construction might bit complicated formulae may case nuples numbers encoded words f0 1g n example pair thirteen four represented word1011 reading right left lower word find thirteen base 2 reading right left upper word find four height stack numbers number free variables convention possible build automaton accepting pairs numbers satisfy set triples x z numbers 14 h comon dincbas jp jouannaud c kirchner possible transitions labeled pairs identical symbols figure 6 automaton formula 1the two states correspond carry final state carry nonfinal state initially enter without carry since reading triples1 1 stay final state transition by1 0 state carry transitions built way figure 7 automaton formula z see figure 7 combining two automata intersection projection last operation simply forgets component tuples get back automaton figure 5 automata techniques used large variety constraints really used actual software either high computational complexity relatively recent discovery simple example use tree automata membership constraints express typing properties formulae consist combinations atomic formulae 2 recognized methodological view constraint solving 15 finite tree automaton example might want restrict integers values given variable x take assuming function int express typing condition using constraint x 2 int int interpreted set trees recognized state int specified automaton include real value et constraints used eg constraint concurrent logic programming language oz 47 developed dfki saarbrucken typing constraints also inferred compile time logic programming language taking advantage structure program 19 automata techniques devoted particular piece program yields efficient execution firstorder theory typing also called membership constraints proved decidable h comon c delor 10 related typing constraints set constraints introduced mishra 84 40 area program analysis set constraints combinations formulae set expressions using eg intersection union complement application function symbol etc interpreted possibly infinite subsets set terms contribution french school area demonstrate kind tree automata tree automata free adequate representation solutions constraint solving 15 22 21 51 set constraints also used part constraint logic programming language techniques tree automata solve 34 5 32 algebraic representations besides automata techniques complete constraints methods extensively use representation constraints first example equational unification already introduced section 2 consider case associative commutative function symbols alternative syntactic methods already described associate semiring 2 equational axioms reduce unification constraints solving equations semiring let us also mention old semantic algorithm lowenheim boolean ring unification rediscovered martin nipkow 38 another example importance concerns linear diophantine equations consist linear polynoms integer coefficients used particular another constraint solving problem uses semantic methods solving equations terms presence associative commutative function symbols typical example diophantine equations system ae searching positive integer solutions seen already solved means automata however particular situation specific methods efficient idea contejean devie 13 represent solutions vectors real space dimension n number r theta theta theta theta theta theta gammapsi figure 8 vectors equations 2 example constraint solving algorithm consists starting origin repeat addition one default vectors reach back origin default vectors computed equation system values two left members equations vector basis example default vectors represented figure 8 first step addition default vectors current vector v considered scalar product delta v negative process shown always terminating complete sense every solution system combination solutions obtained way example figure 9 shows solution 4210 reached algorithm 4 number times added default vector ae 1 2 number times added default vector number times added default vector ae 3 0 number times added default vector ae 4 semantic methods proposed linear diophantine equations solving see eg 1 18 17 43 50 4 hybrid methods seen previous sections solving constraint consist finding canonical representation canonical sense unsatisfiable constraints unique representation corresponds call complete constraint solvers completeness really required many sit uations consider instance applications constraints automated deduction logic programming constraints allow represent efficient way sets methodological view constraint solving 17 r theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta thetaffi gammagammapsi gammapsi theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta thetaffi gammapsi figure 9 computation solution 4210 system formulas inferences take constrained formulas premisses yield constrained formulas conclusion long proof completed soon contradiction found empty clause logic programming matter deduction process whether constraint formula satisfiable course checking satisfiability may yield huge number junk formulas hand checking satisfiability quite expensive time constraint logic programming languages constraint automated deduction systems solve constraints eagerly tradeoff time efficiency space efficiency usually constraint simplifications performed eagerly complete constraint solving performed empty clause generated generally proof obtained typical example incomplete solver checks step computa tion relaxed version set constraints idea quite common operations research name relaxation comes practice rather checking conjunction large number n elementary constraints possibility check possible combinations conjunctions two elementary constraints technique known local consistency since local consistency imply existence solutions technique usually used combination enumeration procedure operating locally consistent constraints order restore completeness whole constraint solving process enumeration taken broad sense relations well values may enumerated hybrid method therefore constraint solving technique comes two parts one syntactic constraint solving technique incomplete general syntactic semantic technique completes first part constraint solving first simplification performed eagerly second part constraint solving performed necessary hybrid methods actually used applications constraints automated deduction logic programming soon constraint solving expensive logic programming typical example finite domain constraints automated deduction case ordering constraints 20 combination mechanisms also seen instance scheme let us consider constraints detail 41 finite domains finite domain constraints described figure 10 together constraint solving method based local consistency checking techniques root success constraint programming environments like chip ilog solver solving combinatorial problems practice efficiency hybrid methods finite domains heavily depends enumeration procedure various heuristics used although work pretty well firstfail principle variables domainsplitting values context finite domains constraints best strategy applicable types problems finite domain constraints defined figure 10 allow easily specify solve complex problems areas like planning scheduling packing placement end new predicates like 6 logical connectives like negation disjunction introduced price efficiency problems particular predicates lowlevel allow modelling problems easy natural way alternative first explored chip cumulative constraint introduce called global constraints reach expressivity means highlevel abstractions cumulative constraint generalises disjunctive constraints order model finite capacity scheduling problems may several copies given kind resource resources shared second goal global constraints take advantage interactions among different constraints runtime order reach better pruning search tree instead using values bound propagation previous method global constraints take account structural properties methodological view constraint solving 19 consider structure fd whose domain set n natural numbers hence variables range n setting finite domain constraints existential positive formulae built five predicates interpreted n infinitely many membership predicates 2 b one finite interval b n precise syntax given following grammar x denotes variable ranging n b natural numbers atomic constraint x 2 b interpreted empty set b atomic constraints x 2 identified solving finite domain constraints npcomplete important practice therefore favored use practically efficient technique constraint propagation described form set transformation rules atomic ordering equality constraint c variables whose domains defined membership constraints x new restrictions domains resulting new membership constraints call reduced domain rdx j c variable x j c smallest interval 0 n constraint obtained substituting x j c satisfiable fd forward checking x 2 look ahead x 2 eliminate ag falsity enumerate x 2 ag x 2 rules applies using forward checking rule easy since x variable c solved modifies original domain x allows eliminate c several uses look ahead rule whose principle lift constraint variables domain example constraint cx 1 dx 2 e entails relation ca 1 db 2 e therefore choose b 0 2 largest natural number cm db consider constraint continued figure 11 figure 10 finite domains 12 20 h comon dincbas jp jouannaud c kirchner continued figure 10 enumerate obtain first must understood nondeterministic needs applying enumerate get solution 5 see crucial role enumerations case enumerating largest values would speed process popular schema domain splitting similar binary search figure 11 finite domains 22 constraints order deduce propagate information usually done via semantic representation constraints based graphs simple arithmetic logic knowledge used former methods deeper finite mathematics graph theory operations research knowledge required used latter global constraints like diffn generalization disequality constraint ndimensional objects recently introduced chip permitted solve quite difficult placement problems 42 ordering constraints symbolic constraints also may use enumerations form domain splitting rule since herbrand domain usually infinite case ordering constraints conjunctions atomic constraints form studied comon 9 jouannaud okada 31 nieuwenhuis 41 context simplification rules obtained expressing recursive definition ordering terms set transformation rules operating atomic constraints enumeration rules linearize constraint considering possible orderings componebts saturate system developed nieuwenhuis ganzinger 20 implements constraints solving mechanism form lazy enumeration rule 43 combination techniques another kind hybrid method arises application uses complex constraints operating several computational domains supposed syntax constraint solving method problems called combina methodological view constraint solving 21 tion problems case constraint syntax course built different pieces coming different constraints involved combination course desirable modularly derive constraint solving algorithm combination algorithms already known elementary constraints turns problem thoroughly investigated unification case since actually main difficulty associative commutative unification associative commutative function symbols problem seen combination several unification algorithms one symbols querying bibliographic data base articles satisfying certain constraints interesting practical example application kind techniques assume item data base records information particular article au thors title affiliation etc bibtex format item represented called feature term whole finite data base becomes big conjunction phi feature terms note easy augment data base adding new element conjunction querying data base particular entry example papers containing word unification title expressed entailment problem form phi entails oe oe represents query problem feature terms homogeneous since contain subexpressions strings certain vocabulary involves solving associative pattern matching constraints see figure 12 solving constraint heterogeneous domain starts variable abstraction consisting purifying constraints goal get conjunction constraint systems homogeneous constraint solving algorithm applied pure parts still interactions homogenous parts considered done enumeration procedure roughly guesses shared variables dependencies 5 application contexts constraints natural way specify mathematical problems number potential applications ideas presented paper numerical constraints used operations research robotics generally area applied mathematics physics mechanical engineering symbolic constraints arise naturally computer science applications like type verification inference abstract interpretations logic programming deduction artificial intelligence concentrate briefly two main applications tools presented paper constraints deduction constraints computations use constraints deduction recently developed new promising field research constraint logic programming specific instance constraints particular importance theorem proving two main reasons constraints allow possibly exponentially reduce number formulae resulting single deduction step packing constrained formula example automated deduction techniques require solving equations terms possibly involving associative commutative operators subgoals given logical deduction equation simple x 22 h comon dincbas jp jouannaud c kirchner use syntax features defined figure 4 sorts types elements set farticle person identity university addressg augmented builtin types listof string nat using set keys clear context syntax basic types authors adr postalcode name first last implicit recall constant sorts feature term consider query title authors letters x z u denote variables appropriate types solutions query values x z u constraint entailed data base expression course entailment problem cause enumeration elementary formulas data base corresponding various bibliographical data allowing resolve entailment problem bibliographical datum turn assume bibliographical data base one end paper thus contains following entry title efficient unification algorithm authors last last order make variables match appropriate information constraint first split homogeneous pieces pieces given domain three domains feature terms strings natural numbers therefore obtain new constraint title unification algorithm authors authors personname last personname last turn decomposed using appropriate string matching algorithm figure 12 bibliographic search methodological view constraint solving 23 30 billions incomparable solutions course realistic engage current computers number deductions remedy keeping equation constraint deductions initiated 33 constraints allow also record information computation component deduced formulae hence permit formulate inference rules reason information efficiently pruning search space constraint solving techniques found first key application within constraint logic programming framework especially solving combinatorial search problems 26 examples problems occurring different economical areas mention project management production scheduling crew assignment tour planning etc problems nphard general also hard model therefore hard program constraint logic programming brings ideal solution problem supporting different types constraint systems symbolic numeric allowing use powerful constraint solving algorithms combined domainoriented heuristic search several successful industrial applications developed areas described volume overview constraint logic programming found 27 also described applications circuit design symbolic ver ification test pattern generation logic synthesis diagnosis decision problems management option trading analysis portfolio management acknowledgments work partly supported vincent mongeardmugneret 21700 vosne ro manee france fax 3380623575 esprit bra ccl thank carlos castro comments earlier version paper notes 1 vincent mongeardmugneret actually prefers supreme quality big profit hence uses manure recommand clos vougeot grand cru 88 89 90 extremely good years feel free use 3rd authors recommandation 2 semiring structure properties ring except might inverse addition n theta 0 1 typical example semiring r general solutions systems linear diophantine equations inequations complete recursive feature theory method simultaneous search refutations models equational constraint solving notes rational spaces disunification survey tree automata techniques applications solving symbolic ordering constraints equational formulae membership constraints equational problems disunification ordering constraints trees efficient algorithm solving systems diophantine equations linear programming extensions rewriting tree automata constraint logic programming language chip outils pour la deduction automatique dans les theories associatives commutatives fast method finding basis nonnegative solutions linear diophantine equation logic programs types logic programs saturate system solving systems set constraints negated subset relationships solving systems set constraints using tree automata based program analysis recherches sur la theorie de la demonstration resolution constraint logic programming constraint logic programming survey solving equations abstract algebras rulebased survey unification first international conference constraints computational logics automatic proofs induction theories without constructors satisfiability systems ordinal notations subterm property decidable new polynomialtime algorithm linear programming deduction symbolic con straints set constraints logic programming explicit representation terms defined counter examples complete axiomatizations algebras finite efficient unification algorithm boolean unification logic programming language lambdaabstraction towards theory types prolog simple lpo constraint solving methods constraint programming basics trends minimal solutions linear diophantine systems complete logical calculus record structures representing linguistic information oz programming model foundation higherorder concurrent constraint programming negation elimination syntactic equational formulas decidable automata infinite objects solving linear diophantine equations using geometric structure solution space automates et contraintes ensemblistes new method undecidability proofs first order theories feature trees arbitrary structures tr
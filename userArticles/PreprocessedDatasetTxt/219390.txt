weakly hard problems weak completeness phenomenon investigated complexity class rm e rm dtime2rm linear according standard terminology language h leqrm pmhard e set rm pmh consisting languages leqrm pmh contains entire class e language c leqrm pmcomplete e leqrm pmhard e also element e generalizing language h weakly leqrm pmhard e set rm pmh measure 0 e language c weakly leqrm pmcomplete e weakly leqrm pmhard e also element e main result paper construction language weakly leqrm pmcomplete leqrm pmcomplete e existence languages implies previously known strong lower bounds complexity weakly leqrm pmhard problems e given work lutz mayordomo juedes indeed general corresponding bounds leqrm pmhard problems e proof result introduces new diagonalization method called martingale diagonalization using method one simultaneously develops infinite family polynomial time computable martingales betting strategies corresponding family languages defeat martingales prevent winning much money also pursuing another agenda martingale diagonalization may useful variety applications b introduction practice date proving decision problem ie language h f0 1g computationally intractable usually amounts proving every member complexity class linear larger class efficiently reducible h see 25 survey arguments example problems involving existence winning strategies certain twoperson combinatorial games known intractable polynomial time manyone hard fact logarithmic space manyone briefly language h polynomial time manyone hard abbreviated p hard e every language 2 e polynomial time manyone reducible h abbreviated p h language c p c p hard e language h p hard e clearly intractable sense h decidable polynomial time wellknown diagonalization argument 3 shows language must case b p follows p fact languages p hard e known much stronger intractability properties three examples follow meyer 15 shown every p hard language h e dense means real number 0 sufficiently large n h contains least 2 strings x 2 f0 1g n schoning 23 huynh 6 shown every p hard language h e hard approximate sense every language 2 p symmetric difference 4 h dense note immediately implies result c orponen schoning 16 shown every p hard language h e dense polynomial complexity core k condition defined precisely section 2 means roughly k dense every turing machine consistent h performs badly either running polynomially many steps failing decide finitely many inputs x 2 k fact proofs results b c overall structure proof p hard language h e p case intractable language exhibited diagonalization intractability b together fact b p h shown imply appropriate intractability property h time appears likely interesting intractable problems p hard e larger classes insofar true results b c fail interesting cases lutz 9 proposed remedy limitation weakening requirement h p e results specific given language h p span h also called lower p span h 7 set pm f0 1g consisting languages polynomial time manyone reducible h language h p pm h contains complexity class e lutz 9 proposed consideration weaker hypotheses stating pm h contains nonnegligible subset e expression nonnegligible subset e assigned two useful meanings one terms resourcebounded category 9 terms resourcebounded measure 10 8 caution resourcebounded measure incorrectly formulated 9 present paper refers corrected formulation terms martingales presented 10 8 discussed briefly section 3 resourcebounded category complexitytheoretic generalization classical baire category 17 led extension result b 9 work since 9 focused instead resourcebounded measure resourcebounded measure generalization classical lebesgue measure 2 18 17 lebesgue measure special case special cases provide internal measures various complexity classes paper concerns special case measure complexity class e par ticular resourcebounded measure defines precisely means set x languages measure 0 e condition written x j e 0 means intuitively negligibly small subset e intuition justified technically 10 section 3 set languages measure 1 e written complement latter case said contain almost every language e emphasized every set x languages measure measurable e particular expression x j e 6 0 means x measure 0 e necessarily imply x measure e generalizing notion p hardness e say language h weakly p e 6 0 ie pm h measure 0 e similarly say language c weakly p complete hard e since e measure 0 e 10 clear every p hard language e weakly p hard e hence every p complete language e weakly p e following extensions results b c known shown every weakly p hard language language e ff 1 dense method 11 extends straightforward matter show every weakly p hard language h e every language 2 p symmetric difference a4h dense shown every weakly p hard language h e dense exponential complexity core k condition defined section 2 implies immediately k dense polynomial complexity core h extend strong intractability results b c p hard languages e weakly p hard languages extends class problems wellunderstood lower bound techniques applied unless every weakly p hard language e hard e surprisingly although hardness appears weaker hypothesis p hardness proven date present paper remedies situation fact main theorem section 4 says exist languages weakly p p complete e follows results indeed extend class problems strong intractability results proven main theorem proven means new diagonalization method called martingale diagonalization method involves simultaneous construction mutual recursion infinite sequence polynomial time computable martingales betting strategies ii corresponding sequence languages defeat martingales prevent winning much money also pursuing another agenda interplay two constructions ensures sequence languages ii used construct language weakly p complete complete e martingale diagonalization may turn useful variety applications proof main theorem also makes essential use recent theorem juedes lutz 7 gives nontrivial upper bound complexities p hard languages e section 2 presents basic notation definitions section 3 provides definitions basic properties feasible polynomial time computable mar tingales uses define measure e proves new result rigid enumeration theorem result provides uniform enumeration feasible martingales crucial martingale diagonalization method section 4 devoted entirely main theorem proof section 5 briefly discusses directions future work particular emphasis search natural problems weakly p hard e preliminaries languages synonymously decision problems paper sets binary strings ie sets f0 1g standard enumeration f0 1g infinite sequence strings appear first order length lexicographic der symbol denotes empty string expression jwj denotes length string w 2 f0 1g convenient write standard enumeration form n 2 n n n th string counting 0 standard enumeration f0 1g thus jnj denotes length n th string f0 1g boolean value condition ae 1 true false language f0 1g identified characteristic sequence infinite binary sequence expression denotes string consisting first n bits paper uses standard pairing function gamma onto defined k n 2 n pairing function induces pairing function gamma onto defined obvious way ie hk ni hk ni th string standard enumeration f0 1g note jhk nij 2jkj noted section 1 language f0 1g dense real sufficiently large n contains least 2 strings x 2 f0 1g n given function n complexity class dtimetn consists every language f0 1g x 2 computable deterministic turing machine otjxj steps similarly complexity class consists every function f f0 1g f0 1g fx computable otjxj steps complexity classes particular interest paper language polynomial time manyone reducible language b b function f 2 pf x 2 f0 1g x 2 fx 2 b complexity cores first introduced lynch 13 studied ex tensively rest section specifies notions complexity cores mentioned section 1 given deterministic turing machine input x 2 f0 1g accepts x rejects x case mx 2 f0 1g timem x denotes number steps used computation mx machine consistent language 1g n time bound let k f0 1g k dtimetncomplexity core every c 2 n every machine consistent fast set finite intersection k definition timem x mx 2 f0 1g x 2 f thus f set strings decides efficiently note every subset dtimetncomplexity core dtimetncomplexity core note also every dtimetncomplexity core dtimesncomplexity core 1 k polynomial complexity core k dtimen k complexity core k 2 n 2 k exponential complexity core real number ffl 0 k dtime2 n ffl complexity core intuitively pcomplexity core set infeasible instances exponential complexity core set extremely hard instances 3 feasible martingales section presents basic properties martingales betting strate gies computable polynomial time martingales used develop fragment resourcebounded measure sufficient understanding notion weakly hard problems section also proves rigid enumeration theorem crucial martingale diagonalization method used prove main theorem section 4 martingale function f0 1g 0 1 property w 2 f0 1g martingale succeeds language f0 1g lim sup recall 0n gamma 1 string consisting first n bits characteristic sequence finally martingale define set succeeds ag intuitively martingale betting strategy given language starts capital amount money bets membership nonmembership successive strings 0 enumeration f0 1g prior betting string n strategy capital dw betting string n strategy capital dwb condition 31 ensures betting fair strategy succeeds capital unbounded betting progresses example 31 following recursion let 1g see figure 1 easily checked martingale succeeds language primeg language example 32 following recursion let see figure 2 obvious martingale succeeds every finite language fact easily checked 1 contains exactly every language quantity log 3 unbounded denotes number 0s string w martingales used extensively schnorr 19 20 21 22 investigation random pseudorandom sequences lutz 10 8 used martingales computable polynomial time characterize sets measure 0 e since martingales realvalued computations must employ finite approximations real numbers purpose let gamman figure 1 martingale example 31 set nonnegative dyadic rationals nonnegative rational numbers finite binary expansions definition 1 computation martingale function b f0 1g fi fi fi b r 2 n w 2 f0 1g satisfying r jwj b r 2 strong computation martingale computation b satisfies 32 r 2 n w 2 f0 1g figure 2 martingale example 32 3 computation b martingale rigid following two properties r 2 n function b r martingale b r 2 n w 2 f0 1g r jwj r1 w 4 pcomputation martingale computation b r w computable time polynomial r 5 pmartingale martingale pcomputation martingale considered feasible pmartingale ie pcomputation intuitively one might prefer insist feasible martingales strong pcomputations thereby avoiding ad hoc condition r jwj hand technical arguments paper useful rigid pcomputations reasons explained fortunately following lemma shows three conditions equivalent lemma 33 rigid computation lemma martingale following three conditions equivalent 1 pcomputation 2 strong pcomputation 3 rigid pcomputation proof trivial 3 implies 1 see 1 implies 2 let b pcomputation function e defined e r rjwj w easily seen strong pcomputation 2 holds see 2 implies 3 let b strong pcomputation define function e following recursion assume r 2r2 r 2r2 wbgamma b 2r2 wb suffices show e rigid pcomputation first shown induction w holds r 2 n w 2 f0 1g immediately facts e r 2r2 b pcomputation induction step assume 33 holds b 2 f0 1g e 2r2 wbgamma dwb 2r2 wbgamma dwb 2r2 wbgamma dwb 2r2 wbfi fi fi fi fi last inequality holds induction hypothesis fact b strong pcomputation confirms 33 holds r 2 n w 2 f0 1g let r 2 n w 2 f0 1g r jwj 33 shows e computation fact since b pcomputation easily checked e pcomputation fact e rigid follows following two observations r 2 n function e r clearly martingale clause ii definition e b r 2 n w 2 f0 1g 34 r1 w thus 3 holds 2 note proof construct pcomputation strong rigid fact seems reasonable conjecture exists pmartingale pcomputation strong rigid note function b rigid computation martingale satisfies predicates j kr1 w j r w1 r 2 n w 2 f0 1g next theorem exploits fact give useful enumeration pmartingales following definition specifies useful properties enumeration definition rigid enumeration consists sequence sequence b following properties enumeration pmartingales ii k 2 n b k rigid pcomputation k iii algorithm given k r 2 n w 2 f0 1g computes kr w 2 steps following theorem main result section theorem 34 rigid enumeration theorem exists rigid enumeration pmartingales proof fix function e g n 2 theta f0 1g following properties write e enumeration functions f fr w computable time polynomial r ii algorithm given k r 2 n w 2 f0 1g computes e kr w 2 steps existence efficient universal function wellknown 3 4 proof devoted two claims respective proofs first claims following claim 1 function b following properties write b g kr k 2 n b k rigid pcomputation martingale g k b k 2 n e k already rigid pcomputation martingale k c constant c 2 n k r 2 n w 2 f0 1g kr w computable 2 steps assume moment claim 1 true define functions b kr form kr w second claim following 2 sequences constitute rigid enumeration pmartingales prove claim 2 still assuming claim 1 first note k 2 n w 2 f0 1g ae form part claim 1 immediately implies k pmartingale conversely assume 0 f0 1g 0 1 pmartingale rigid computation lemma clause specification e g j 2 n e g j rigid pcomputation 0 choose k 2 n j part b claim 1 e k rigid pcomputation 0 shows 0 enumeration pmartingales b k rigid pcomputation k required compute b kr w satisfies prove claim 2 hence theorem remains prove claim 1 prove claim 1 values b kr w first specified k r 2 n define following predicates predicates useful regard k r 2 n w 2 f0 1g parameters f b variables ff krw f b recursion r w follows let k r 2 n 1g kr otherwise e g g kr w otherwise condition ii choice e g function b defined recursion easily seen satisfy condition c claim 1 see b satisfies condition claim 1 let k 2 n arbitrary routine induction r shows fi krw e holds r 2 n w 2 f0 1g follows easily b kr martingale routine induction w shows ff krw e g holds r 2 n w 2 f0 1g follows b g k rigid pcomputation martingale g k defined kr w thus b satisfies condition claim 1 finally see b g satisfies condition b claim 1 fix k 2 n assume e g k rigid computation martingale g k routine induction r w shows b k ff fi predicates hold throughout induction otherwise cases never invoked definition b k completes proof claim 1 proof rigid enumeration theorem 2 rest section briefly develops aspects measure e used paper key ideas following definition definition 1 set x languages pmeasure 0 written pmartingale x 1 2 set x languages measure 0 e written x j e 0 3 set x languages measure 1 e written x j e 1 complement x case x said contain almost every language e 4 expression x j e 6 0 indicates x measure e note assert x j e nonzero value thus set x languages measure 0 e feasible martingale succeeds every element x following fact obvious useful proposition 35 every set x languages satisfies implications probability pra 2 x computed according random experiment language f0 1g chosen probabilistically using independent toss fair coin decide whether string x 2 f0 1g righthand implication proposition 35 makes clear p measure 0 sets negligibly small significant complexity theory x measure 0 e negligibly small subset e intuition technically justified 10 shown finite subsets e measure 0 e sets measure 0 e closed subset finite unions certain countable unions called punions importantly following shown theorem 36 10 e j e 6 0 combined abovementioned closure properties result special case general measure conservation theorem 10 ensures nontrivial sense negligibly small subset e whenever x measure 0 e 4 weak completeness e standard terminology language h p hard complexity class c set pm contains c language c p complete c c 2 c c hard c following definition generalizes notions complexity class language h weakly p e 6 0 ie set pm h measure 0 e language c weakly hard e theorem 36 every p hard language e weakly p hard e whence every p comlete language e weakly p complete e following result says converse hold ie e weak completeness proper generalization p completeness theorem 41 main theorem language c weakly complete p complete e rest section devoted proving main theorem recent theorem juedes lutz gives necessary condition language p hard e condition based idea meyer 15 plays important role present proof key ideas developed following definitions definition collision set function f f0 1g f0 1g function f f0 1g f0 1g onetoone almost everywhere c f finite manyone reduction computable function f f0 1g f0 1g x 2 f0 1g fx 2 fa implies x 2 dtimet reduction manyone reduction f f 2 dtimeft n incompressible reductions every dtimet reduction onetoone almost everywhere intuitively f dtimet reduction c f large f many questions x 2 fewer questions f x 2 fa incompressible dtimet reductions complex sense little compression occur following result used theorem 42 juedes lutz 7 language p hard e incompressible dtime2 4n reductions since almost every language almost every language e incompressible dtime2 4n reductions 7 theorem 42 says p languages unusually simple least one respect largest part proof main theorem construction language h following two properties hard e ii h incompressible dtime2 4n reductions theorem 42 language h cannot p hard e padding argument gives main theorem language h constructed diagonalization establishing property construction uses fixed rigid enumeration pmartingales rigid enumeration exists theorem 34 establishing property ii construction uses fixed function f universal dtimef2 4n sense existence efficient universal function wellknown 3 4 addition pairing function h mentioned section 2 construction h uses ordering n 2 defined 1 j k n 2 n easy check n isomorphic n k n 2 n 2 let j 2 n 2 number predecessors k n n 2 two important properties using ordering define modified collision set c function also k 2 n define k th slice c set lemma 43 2 n function f onetoone almost everywhere set c finite proof fix define equivalence relation j f0 1g collision set c f modified collision set c consist one elements nonsingleton equivalence classes j follows immediately c f c either finite infinite overview construction informally intuitively language h constructed deciding boolean values hk ni 2 h successive k n ordering n 2 convenient regard h consisting separate strands h figure 3 construction exploits ordering ensure h h k 2 e ultimate objective h k ensure specially constructed martingale e k succeed h k k finitely many values chosen according ultimate objective exceptions occur values chosen order destroy various functions f order ensure functions manyone reductions h figure 3 strands h specially constructed martingales form e k taken rigid enumeration pmartingales given theorem 34 martingales ik defined since e k succeed h k k also succeed h k since k arbitrary h k 2 pm h e follows pm pmeasure 0 ie pm h measure 0 e thus h weakly hard e hand since e k succeed h k none martingales ik succeeds h k moreover matters arranged every manyone reduction f h c succeeds h k else f eventually destroyed value follows h incompressible dtime2 4n reductions whence h p hard e theorem 42 precise details follow construction language h f0 1g defined languages h defined along auxiliary martingales e delta following recursion 1 k 2 n w 2 f0 1g define e ik w functions ik computed follows assume w 2 1g ik b k c k n 2 c ik j least pair n 2 f hj clear ik hence e k martingale k r 2 n w 2 f0 1g approximation kr ik w e k w also used easy check k r 2 n w 2 f0 1g satisfying r 2 construction languages h delta operation destroy f k n often performed instances known k n 2 c operation performed setting j least pair n 2 f hj note single performance operation ensures f manyone reduction h sets destroyed j mg also used construction emphasized index appears kn operation destroy f j explicitly performed j k n particular j one f destroyed j even though many 0 f thus kn finite set jd kn j k n note k n finite k n 2 n f constant infinitely many values defined according following two cases begin begin kn1 wb kn w0 kn w1 k n k destroy f kn k n else end figure 4 computation proof lemma 44 case 1 k n k destroy f kn k n case 2 k n k set kn w1 b e kn w0 completes construction languages h martingales e following lemmas used prove main theorem k 2 n h k 2 e proof assume first k n 2 n 2 values known stored pairs j k n set kn consider computation exhibited figure 4 estimate time required computation recall properties note following computation w requires n delta k steps ii computation b kn1 wb requires 3 steps iii condition k n 2 c tested steps iv iii computation ik wb requires steps v ii iv entire computation kn wb ie forloop figure 4 requires 2 o1jkj1jnj 2n22 o1jkj1jnj steps vi iii condition k n 2 c tested 2 o1jkj1jnj steps thus testing condition k n k computing k n condition true requires steps follows easily ifthenelse figure 4 requires 2 o1jkj1jnj steps v vi computation described figure 4 requires 2 o1jkj1jnj steps compute given set kn values condition hk ni 2 h decided computing storing successive values according ordering n 2 using computation figure 4 updating jn stage requires 1 steps since proves h 2 e 2 also fixed k lemma 45 2 n exist infinitely many k 2 n slice c ik nonempty f manyone reduction h proof fix assume set infinite k 2 let n ik every k 2 least one following four conditions must hold fact real numbers b c least one c b must hold clear condition holds finitely many k k condition iii holds construction h ensures f kn k destroyed k n k since f j destroyed construction h follows condition iii holds finitely many k since infinite implies condition ii condition iv holds fix number k condition ii holds 2 kn k manyone reduction h condition iv holds f destroyed k n k f manyone reduction h thus case f manyone reduction h 2 lemma 46 manyone reduction h c ik infinite ik succeeds h k proof assume manyone reduction h c ik infinite consider successive values clause definition ik says r clauses b c ensure r n1 2 f0 r g fact since f reduction h clause c never causes r n1 0 thus recurrence ik since c ik infinite implies r succeeds h k 2 lemma 47 k 2 n e k succeed h k proof fix k 2 n consider manner values decided finitely many values n case 1 holds occurrence case 1 involves new value k n k n k thus exists n 0 2 n case 2 holds n n 0 n 2 n let nbit prefix h k n 0 case 2 ensures e km wm1 km wm km wm 1 2 gammam e e follows n n 0 e thus e e n 2 n hence e k succeed h k 2 lemma 48 h weakly p hard e proof let k 2 n clear h k 2 pm h 1 k k follows lemmas 44 47 whence pm arbitrary implies e 6 0 ie pm h j e 6 0 thus h weakly p lemma 49 h p hard e proof theorem 42 suffices show h incompressible reductions fix 2 n f manyone reduction h suffices show f onetoone almost everywhere note following two things k 2 n slice c ik finite lemmas 47 46 ii lemma 45 finitely many k 2 n c taken together ii imply c finite follows lemma 43 f onetoone almost everywhere 2 lemmas 44 48 49 language h p hard e simple padding argument suffices prove main theorem proof main theorem let h defined lemma 44 polynomial qn n h 2 dtime2 qn let easy check c 2 e pm follows lemmas 48 49 c weakly p complete p 5 conclusion important problem suggested work find natural examples languages weakly p complete p e noted section 1 languages would provably strongly intractable reasonable hope study natural examples would yield new insights nature intractability especially intriguing consider possibility sat natural npcomplete problems may weakly p complete e ie np may measure 0 e hypothesis sat weakly p complete e implies may sense stronger p 6 np hypothesis example recent work shown sat weakly complete e np contains pbiimmune languages 14 every hard language np dense 11 every p complete language np dense exponential complexity core 7 language complete p complete np 12 investigation consequences reasonableness hypothesis indicated routine modify proof main theorem construct languages weakly p complete p complete larger classes e 2 espace interesting perhaps harder question concerns alternate versions main theorem p replaced reducibilities homer kurtz royer 5 proven language 1gammatt hard e p hard e follows immediately language c given main theorem weakly p p 1gammatt complete e main theorem holds p replaced p 1gammatt beyond little known new techniques may required determine whether main theorem holds p replaced p acknowledgments thank jim royer tom linton several useful suggestions earlier draft paper r isomorphism density np complete sets measure theory computational complexity algorithms observations randomness hard prob lems complexity distribution hard problems preparation category measure complexity classes almost everywhere high nonuniform complexity density hard languages separating completeness notions np small reducibility complex sparse sets almost every set exponential time pbiimmune reported density complexity polynomial cores intractable sets measure category real analysis klassifikation der zufallsgesetze nach komplexitat und ordnung unified approach definition random sequences lecture notes mathematics 218 process complexity effective random tests complete sets closeness complexity classes provably difficult combinatorial games classifying computational complexity problems tr ctr stephen fenner jack h lutz elvira mayordomo patrick reardon weakly useful sequences information computation v197 n12 p4154 february 25 2005march 15 2005 olivier powell note measuring p theoretical computer science v320 n23 p229246 june 14 2004 klaus ambosspies wolfgang merkle jan reimann sebastiaan terwijn almost complete sets theoretical computer science v306 n13 p177194 5 september
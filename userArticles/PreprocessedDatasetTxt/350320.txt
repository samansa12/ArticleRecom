comparison three rounding algorithms ieee floatingpoint multiplication abstracta new ieee compliant floatingpoint rounding algorithm computing rounded product carrysave representation product presented new rounding algorithm compared rounding algorithms yu zyner 26 quach et al 17 rounding algorithm logical description block diagram given correctness proven latency analyzed conclude new rounding algorithm fastest rounding algorithm provided injection depends rounding mode sign added reduction partial products carrysave encoded digit string double precision format latency new rounding algorithm 12 logic levels compared 14 logic levels algorithm quach et al 16 logic levels algorithm yu zyner b introduction every modern microprocessor includes oatingpoint multiplier complies ieee 754 standard 13 latency fp multiplier critical oatingpoint performance since large portion fp instructions consists fp multiplications example oberman reports fp multiplications account 37 percent fp instructions benchmark applications 17 lot research devoted optimizing latency adding partial products produce product eg 1 2 6 9 15 16 18 19 20 21 26 28 29 30 recently work rounding product according ieee 754 standard published 4 7 10 22 23 24 25 31 33 34 assuming multiplier outputs carrysave encoded digit string representing exact product following natural question arises fastest method compute rounded product given exact product represented carrysave encoded digit string consider compare three rounding algorithms algorithm quach et al 23 denote qtf algorithm b algorithm yu zyner 31 denote yz algorithm c new algorithm based injection based rounding 10 denote es algorithm provide block diagrams rounding algorithms optimized speed measure latency algorithms logic levels enable technology independent comparisons main building blocks algorithms similar consist compound adder computation sticky carry bits thus costs three algorithms similar interesting question nding fastest algorithm focus double precision multiplication signicand represented 53 bits algorithms assume signicands normalized namely range 1 2 therefore product range 1 4 consider cases deal denormal special values since supporting denormal values obtained using extended exponent range 14 25 32 computation special values done parallel 12 three algorithms share following techniques 1 product represented carrysave encoded digit string 106 digits case double precision partitioned lower part upper part upper part added compound adder computes binary representations sum sum ulp ulp denotes unit last position sum denotes sum upper part carrybit roundbit stickybit computed lower part 2 rounding decision computed two paths nonover ow path works assumption exact product range 1 2 ow path works assumption product range 2 4 although sum upper part denoted sum equal exact product signicant bit sum controls selection two paths main dierences three rounding algorithms outlined follows 1 rounding decision qtf es algorithms simplify rounding decision early addition value value called prediction qtf algorithm injection es algorithm qtf algorithm prediction depends rounding mode carrysave digit positioned 53 digits right radix point es algorithm injection depends rounding mode assume added partial products thus product already includes injection rounding decision yz algorithm based customary rounding tables 2 position carrysave encoded product partitioned lower part upper part diers three algorithms yz algorithm lower upper parts separated buer three carrysave digits positions 51 53 position digit denotes many digits right radix point two algorithms upper part consists positions lower part consists position 53 104 latencies proposed designs implement algorithms terms logic levels following latency es algorithm 12 logic levels latency qtf algorithm 14 logic levels latency yz algorithm 16 note modied adapted qtf yz algorithms minimum latency supporting four rounding modes ieee 754 standard error prone task therefore provide correctness proofs three algorithms formalize clarify tricky aspects point view yz algorithm easiest prove qtf algorithm intricate especially rounding decision logic paper organized follows section 2 preliminary issues described notation conventions use regarding ieee rounding general setting section 3 straightforward rounding algorithm reviewed algorithm described provide outline task rounding exact product computed attempt parallelize task rounding therefore long latency sections 46 rounding algorithm described proven analyzed section 7 discuss latencies algorithms increase precision increased section 8 summary conclusion given due space limitations sections omitted found full version 11 preliminaries notation let x x binary string denote binary string x z1 x z 1 1 x z 2 also sometimes refer x xi since deal fractions index binary encoded bit strings x x associated weight 2 value encoded xz denoted jxz ieee rounding ieee7541985 standard denes four rounding modes round toward 0 round toward 1 round toward 1 round nearest even based sign number rounding modes round toward 1 round toward 1 reduced rounding modes rz round zero ri round innity 23 thus leaving three rounding modes ri rz rne round nearest even furthermore quach et al 23 suggested implement rne round nearest denoted rnu rounding mode rnu dened follows x two successive representable r rnu reason rne implemented rnu r rnu x 6 r rne x least signicant bit lsb binary encoding 2 1 therefore obtaining r rne x r rnu x accomplished pulling lsb sake clarity dene rounding zero rz signicands range 1 4 double precision note denition excludes postnormalization shift takes place number binade 2 4 denition 1 let x 2 1 4 r rz x dened r rz x div 2 integer q satises general setting paper consider double precision multiplier assume signicands prenormalized namely values two signicands range 1 2 signicand represented binary string bits positions 0 52 exact product two signicands range 1 4 encoded binary string bits positions note weight bit position 1 2 sake simplicity ignore exponent signbit paths floating point multipliers perform computation two phases rst phase addition tree reduces partial products carrysave encoded digit string represents exact product second phase binary string representing rounded product computed carrysave encoded string paper discusses implementations second phase 3 naive ieee rounding section review simple slow ieee compliant algorithm rounding multiplication 5 31 description input consists two binary strings sum carry 106 bits indexed 1 104 sum binary numbers represented sum carry equals exact product exact 2 1 4 rounding computed follows computation exponent string omitted 1 reduce rounding mode one three rounding modes based one sign product 2 21compression sum carry strings added obtain single binary string namely note since exact product range 1 4 signicant bit x position 1 3 normalization jxj 2 jx jxj implemented conditional shift one position right note x 0 indexed 0 4 compute sticky stickybit equals 5 compute rounding decision rounding decision rd 2 f0 1g based rounding mode bits stickybit note rounding mode stage already incorporates sign 6 increment compute binary string represents sum 7 postnormalize jy signicand string rounded product given 0 32 delay analysis latency steps 1 3 5 naive rounding procedure least logarithmic length binary strings sum carry steps require constant delay every pipeline stage accommodate one logarithmic depth circuit implementation naive rounding procedure requires least 3 pipeline stages 4 es rounding algorithm section review injection based rounding 10 present implementation double precision requires assumptions specied sec 45 12 logic levels 41 injection based rounding rounding injection reduces rounding modes ri rnu rz 10 reduction based adding injection depends rounding mode follows eect adding injection summarized following equation mode 2 frzrnurig figure 1 depicts reduction rnu ri rz injection assuming number rounded range 1 2 exact product denoted exact range 2 4 injection must xed order make reduction rz correct correction amount denoted inj correct dened therefore x range 2 4 eect adding injection correction amount summarized following equation mode 2 frzrnurig assumption injection added multiplier adder array therefore completes description injection based rounding numbers range 1 4 42 rounding algorithm section present new es algorithm rounding oatingpoint multiplication based injection based rounding figure 2 depicts block diagram es rounding algorithm rounding algorithm works assumption sum carrystrings already include injection injection correction proceeds follows 1 sum carrystrings divided high part low part high part consists positions low part consists positions 53 104 2 low part input box computes carry round stickybits dened follows 52 104 binary string satises 3 higher part input line half adders produces output x sum note bit lx position 52 carry generated position 2 exact product less 4 even adding injection 4 input compound adder outputs sum incremented sum jy 5 increment decision box receives roundbit r carrybit c52 lsb lx msb 0 1 rounding modes rn ri output signal inc indicates whether 0 1 selected 6 signicant bits 0 1 1 1 indicate whether 0 1 range 2 4 depending bits 0 1 normalized follows shif righty shif righty 7 rounded result except least signicant bit selected z0 z1 according increment decision inc follows 8 case rounding mode rne least signicant bit needs corrected since rne rnu always result least signicant bit correction least signicant bit computed two parallel paths one path working assumption rounded result ows ie greater equal 2 path working assumption rounded result ow path computes correction lsb noover ow assumption implemented box called x l novf inputs x l novf box round bit r sticky bit signal rne indicating whether rounding mode round nearest even output denoted notpd equals zero lsb pulled path computes correction lsb ow assumption implemented box called x l ovf inputs x l ovf box lx bit carrybit c52 round bit r sticky bit signal rne output denoted notpd equals zero lsb pulled note pull signals inactive rounding mode rne 9 least signicant bit rounded result xing lsb case discrepancy rne rnu equals one three values rounded result ow lsb equals lx c52 b rounded result ows increment decision increment c rounded result ows increment decision increment lsb xing lsb implemented combining using andgates pulldown signals corresponding candidates lsb signals outputs 3 andgates denoted l 0 inc l 0 ninc linc sake clarity introduce signal lninc equals linc 10 lsb rounded result equals lninc ow occurred increment took place lsb rounded result equals linc ow occurred increment took place lsb rounded result equals l 0 ninc ow occurred increment took place lsb rounded result equals l 0 inc ow occurred increment took place according 4 cases lsb rounded result selected depending ow signals increment decision 43 details section describe functionality three boxes gure 2 fully described yet fix l novf box belongs path assumes product range 1 2 recall might discrepancy rne rnu tie occurs namely exact product equals midpoint two successive representable numbers let exact denote value exact product fix l novf generates signal notpd satises exact 2 1 occurs rne tie occurs two possibilities rnu rne agree yield rounded result lsb equal zero pulling lsb case required causes damage b rnu rne disagree lsb rnu result must pulled without addition injection tie occurs injection 2 53 already included tie occurs therefore notpd signal dened fix l ovf box belongs path assumes product range 2 4 fix l ovf generates signal notpd satises exact 2 2 occurs rne dierence notpd notpd notpd used assumption product greater equal 2 without addition injection tie occurs case ow lx injection 2 53 already included tie occurs lx therefore notpd signal dened increment decision increment decision box two paths depending whether ow occurs path working assumption ow occurs ie 0 produces increment decision lx 2 path working assumption ow occurs ie 0 needs take account correction injection denoted inj correct produces increment decision lx 2 therefore inc signal dened 44 correctness proof tricky part algorithm correctness inc signal long bit 0 1 indicates correctly whether exact product greater equal 2 equations 1 2 imply inc signal correct one also consider cases 0 1 fails indicate correctly binade exact product namely 0 exact product greater equal 2 b 0 exact product without injection less 2 source errors due fact jy always equal 53 mostsignicant bits exact product recall lower part product corresponding positions 53 104 registers sum carry well lx eect value 0 1 however injection might eect 0 1 since addedin multiplier array depending multiplier array implemented wallace tree etc following claim shows mismatches occur rounded product equals 2 moreover cases paths one working assumption ow occurs one working assumption ow occurs yield result 2 therefore correct rounding obtained even 0 1 fails indicate correctly binade exact product exact denote exact product let sum carry satisfy jsumj exact injection correct rounding exact computed follows r mode r rz exact r rz exact proof consider two main cases 0 suppose 0 exact 2 claim follows eq 1 exact 2 exact reason possible contribution lx 2 52 2 f0 2 52 g therefore exact correction injection satises 0 inj correct 2 52 therefore exact according eq 2 case r mode however case r rz exact rounding zero maps intervals 2 b suppose 0 exact 2 claim follows eq 2 exact 2 since injection 2 0 2 52 follows exact proof follows proof case 2 proves 0 1 used controlling selection right rounded result following claim proves implementation computation r mode exact correct note claim deal xing lsb obtain rne rnu r rz exact 2 0 r rz exact exact tail 2 0 2 52 implies r rz exact inc signal case equals 1 addition lx c52 generates carry position 51 inc 0 simple addition takes place r rz exact inc 1 two cases rst case increment cause ow simple addition takes place ow caused since 53 bits output bit l x c52 discarded completes proof rst part lemma suppose 0 therefore exact implies r rz exact lemma follows 2 45 delay analysis section present delay analysis rounding algorithm depicted fig 3 analysis based following assumptions 1 consider carry lookahead adder let dcla denote delay 53bit adder measured logic levels assume msb sum delay dcla 1 logic levels assumption easy satisfy carry lookahead adder brent kung used 3 otherwise satisfying assumption may require arranging parallelprex network msb ready one logic level earlier 2 compound adder implemented delay sum dcla delay incremented sum dcla 1 obtained oring carrygenerate carrypropagate signals 27 lemma 1 3 consider box carry round sticky bits computed according rst assumption since widths box compound adder similar delay carry bit dcla 1 logic levels delay round bit dcla logic levels delay sticky bit estimated dcla 2 logic levels based fast sticky bit computation presented 31 4 assume delay associated buering fanout 53 one logic level figure 3 depicts block diagram injection based rounding algorithm annotated timing estimates assigned dcla value 8 logic levels implies sticky bit valid 6 logic levels carrybit c52 valid 7 logic levels roundbit valid 8 logic levels similarly sum 0 valid 9 logic levels msb 0 1 valid 8 logic levels incremented sum 1 valid 10 logic levels msb 1 1 valid 9 logic levels figure 4 depicts implementations fix l novf fix l ovf increment decision boxes annotated timing estimates timing estimates used fig 3 obtain estimated delay 12 logic levels rounded product 5 yz rounding algorithm section review analyze rounding algorithm yu zyner reported implemented ultrasparc risc microprocessor 31 refer algorithm yz rounding algorithm 51 description figure 5 depicts block diagram yz rounding algorithm description diers description 31 two ways 1 31 sum output 3bit adder three bits believe mistake sum four bits denote sum z50 53 2 sum incremented sum 31 fed 4 1mux selects one either shifted right propose normalize sum incremented sum selection takes place early normalization helps reduce delay rounding circuit cost two shifters rather one algorithm described 1 sum carrystrings divided high part low part high parts consist positions low parts consist positions 54 104 2 low part input box computes carry sticky bits dened follows 53 104 binary string satises 3 higher part input line half adders produces output x sum note carry generated position 2 exact product less 4 4 high part x sum divided two parts positions fed compound adder outputs sum incremented sum jy added carry bit c53 produce sum z50 53 5 processing z50 53 split two paths one working assumption rounded product ow ie less 2 path working assumption rounded product ow noover ow path computes rounding decision rd52 round dec novf box rounding decision rd52 added z50 52 novf box produce sum claim 3 prove 3 bit addition produce carry bit position 49 sum z novf 50 52 two roles positions result bits positions 51 52 ow occurs position 50 used detect carry generated position 50 ow occurs bit z novf 50 decides whether upper incremented sum 10 50 selected noover ow case ow path computes rounding decision rd 0 51 round dec ovf box rounding decision rd 0 51 added z50 51 ovf box produce sum claim 3 prove 2 bit addition produce carry bit position 49 sum z ovf 50 51 two roles position 51 serves result bit position 52 ow occurs position 50 used decide whether increment take place upper part 6 decision path chosen made select decision box first ow signal ovf computed follows ow signal ovf determines whether z ovf 50 z novf 50 chosen carrybit eects position 50 therefore determines increment decision inc z ovf 50 z novf 50 7 two least signicand bits rounded product computed follows ow occurs therefore lower mux selects bits result51 52 ow occurs 51 bit result51 depends whether increment takes place 050 inc 0 note inc z ovf 50 ovf 1 since signal z ovf 50 ready earlier inc use z ovf 50 control selection 150 z ovf 050 z ovf selection 150 050 done sel multiplexer fig 5 8 signicant bits 0 1 0 1 indicate whether 0 1 range 2 4 depending bits 0 1 normalized follows shif righty shif righty 9 rounded result except least signicant bit selected z0 z1 according increment decision inc signal follows 52 correctness section provide proof adding rounding decision generate carrybit position 49 claim applies noover ow path ow path denote sum output 3bit adder depicted fig 5 let rd52 denote rounding decision noover ow path let rd 0 51 denote rounding decision ow path proof partial compression 8 caused halfadder line implies jx sum follows fact x sum x carry cannot equal one adding c53 increases range 2 4 yielding contribution rd 0 51 2 2 range 0 416 therefore eq 13 follows contribution rd52 2 3 range 0 216 therefore eq 14 follows 2 53 delay analysis figure 6 depicts yz rounding algorithm annotated timing estimates use assumptions delays signals used sec 45 argue least 16 logic levels required path sum incremented sum computed lie critical path critical path consists carrybit computation 3bit adder round dec novf box novf box select decision box driver upper mux considered following optimizations minimize delay lower bound required number logic levels 1 3bit adder implemented conditional sum adder late carryin bit c53 selects sum incremented sum fast implementation bits x carry x sum valid one logic level carrybit c53 valid 7 logic levels 2 rounding decision boxes implemented cascading two levels multiplexers controlled z52 53 noover ow path z51 52 ow path ow path z53 combined stickybit hence rounding decision required 3 logic levels noover ow path 2 logic levels required 3 addition rounding decision bit required one logic level using conditional sum adder 4 inc signal valid 3 logic levels due need compute signal ovf two logic levels see eq 11 one selection according eq 12 5 inc signal passes driver due large fanout driver incurs delay one logic level controls upper mux output result 16 logic levels 6 qtf rounding algorithm quach et al 23 presented methods ieee compliant rounding technique generalization rounding algorithm santoro et al 24 section present rounding algorithm based method quach et al aiming minimum delay apart reducing rounding modes rzrnu ri key idea used methods quach et al santoro et al inject prediction bit based rounding mode values sum53 carry53 injection prediction bit reduces number possibilities rounded result section deviate quach et al 23 following points 1 presentation paper quach et al separated according rounding mode since investigating rounding algorithms support rounding modes integrated rounding modes one algorithm 2 quach et al suggest several options choice prediction logic rnu one possibility suggested modes rz ri since prediction logic lies critical path chose simplify prediction logic much possible dening pred 3 quach et al separate rounding decision compound adder use 3way compound adder computes sum sum 2 correct sum selected control logic interested faster design therefore break 3way adder halfadder line 2way compound adder mux control logic uses output 2way compound adder lsb case ow generated control logic well increment decision 61 description figure 7 depicts block diagram rounding algorithm suggest based quach et al 23 many similarities rounding algorithm based injection rounding rounding algorithm based quach et al point dierences new notations input compound adder high part sum carry pass two lines halfadders rst line makes room prediction bit second pass enables separating bit lx 0 position 52 fact part 3way compound adder increment decision two paths one ow noover ow msb 0 1 selects path outputs increment decision inc addition increment decision computes lsb xing rne case ow occur 62 details section describe details increment decision box lsbx rne box increment decision box outputs increment decision box increment decision inc bit l equals lsb rounded product xing case ow occurs increment decision partitioned two paths one case ow occurs computes signal inc ovf path case ow occurs computes signal incnovf following equations dene signals inc ovf inc novf inc inc r pred pred inc r pred pred output inc equals inc novf inc ovf bit according bit 0 1 inc novf 0 inc ovf 0 bit l equals lsb rounded product xing case ow occurs dened r lx 0 c52 rnu pred ri note case ri complicated due possibility pred 6 c52 pred c52 pred 6 c52 eect wrong prediction reversed pred c52 lsbx rne lsbx rne box outputs two signals notpd used pulldown lsb tie occurs ow occurs notpd 0 used pulldown lsb tie ow occur signals dened follows contrast injection based rounding injection prediction contained lx 0 r sbit computation rne ow occurs tie occurs 0 case lsb pulled rne therefore ow occurs tie occurs case lsb pulled rne therefore 63 correctness section prove correctness selection signal inc proof divided two parts rst part assume 0 exact product range 2 4 second part prove even 0 1 signals ow incorrectly selection signal inc still correct correctly whether exact product range 2 4 inc signal signals correctly whether increment required rounding proof consider separately cases ow ow case consider three possible rounding modes question address whether rounding decision conjunction compression lower part carrysave representation produces carry position 51 inc signal 1 carry generated position 51 suppose ow occurs namely 0 1 rounding mode rz truncation takes place therefore carry position 51 generated 2 2 rounding mode rnu rounding decision increment position 52 roundbit equals 1 increment generates carry position 52 hence carry generated position 51 2 3 rounding mode ri rounding decision increment position 52 one needs take account prediction already added product consider two subcases pred contributions pred c52 cancel therefore c52 ignored rounding decision generates carry position 51 r b c52 6 pred implies therefore rounding decision without prediction would increment position 52 pred 1 increment already took place additional carry generated position 51 suppose ow occurs namely 0 1 rounding mode rz since truncation takes place case identical case ow 2 rounding mode rnu rounding decision determined bit position 52 therefore two cases either carry generated position 51 since lx 0 carry generated position 51 rounding decision combining cases implies carry generated position 51 3 rounding mode ri consider two cases pred may ignore c52 prediction since contributions cancel case rounding decision increment l x pred consider two subcases lx eect prediction restricted changing lx 0 0 1 therefore rounding decision based r since rounding decision increment b lx eect prediction generate carry position 51 second halfadder line change lx 0 1 0 means without prediction lx 0 would equal 1 implies rounding decision would increment since increment already took place additional increment requiredthe selection inc ovf inc novf controlled 0 1 although 0 1 might signal correctly case ow following claim shows 0 1 signal ow correctly choices equal hence inc signal correct signal ow correctly namely 0 exact 2 0 exact 2 inc inc novf proof proof divided two cases 1 0 exact 2 case occur pred therefore restricted rounding mode ri since pred 2 52 follows lx implies case inc ovf inc novf required 2 0 exact 2 discrepancy occur therefore smaller 2 multiple 2 52 follows implies lx 1 consider three rounding modes rz inc inc novf ri excluding possibility case rnu since claim follows64 delay analysis figure 8 depicts rounding algorithm based quach et al 23 delay annotation delay assumptions used similar used two previous rounding algorithms rounding algorithm depicted fig 8 uses prediction logic lies critical path delay prediction logic two logic levels following quach et al fig 8 depicts nonoptimized processing order post normalization shift takes place round selection increment decision box assumed organized follows bits c52 r 0 1 valid 6 7 8 10 logic levels respectively minimize delay implement rounding equations 4 levels multiplexers results selected conditionally signals arrive thus total delay 15 logic levels obtained performing postnormalization round selection takes place one logic level saved obtain total delay 14 logic levels 7 higher precisions rounding algorithms scale higher precisions used one see parts presented rounding algorithms depend length signicands halfadders compound adder sticky round carrybit computation selection multiplexers drivers amplifying signals control wide multiplexers precision increased widths upper lower parts carry save strings grow still stay almost equal implies assumptions relative delay carrybit computation compound adder need changed moreover expected precision grows gap delay computing carrybit stickybit grows stickybit computation lie critical path implies rst order estimate ignoring additional delay due increased fanout interconnection length delays rounding algorithms precision p stated follows 1 delay injection based rounding algorithm 4 logic levels plus delay sum computation pbit compound adder dcla p 2 delay yz rounding algorithm 8 3 delay rounding algorithm based quach et al23 optimization postnormalization takes place selection 6 levels 8 summary conclusions new ieee compliant oatingpoint rounding algorithm computing rounded product carrysave representation product presented new rounding algorithm compared two previous rounding algorithms make comparison relevant possible considered optimizations previous algorithms improve delay rounding algorithm logical description block diagram given correctness proven latency analyzed conclusion new es rounding algorithm fastest rounding algorithm provided injection added reduction partial products carrysave encoded digit string es algorithm rounded product computed 12 logic levels double precision ie signicands 53 bits long precision independent terms critical path consists compound adder 4 additional logic levels injection added reduction partial products carrysave encoded digit string extra step adding injection required step amounts carrysave addition latency associated fulladder namely 2 logic levels thus injection added late latency es rounding algorithm 14 logic levels addition injection reduction partial products accomplished without slowdown small slowdown justication partial products usually obtained booth recoding selecting eg 51 multiplexer hence valid much later injection b delay adding partial products increase strictly monotonically function number partial products delay incurred adding injection depends length signicands organization adder tree two rounding algorithms require injection double precision latency qtf rounding algorithm 14 logic levels critical path consists compound adder 6 additional logic levels yz rounding algorithm ranks slowest rounding algorithm latency 16 logic levels critical path consists compound adder 8 additional logic levels r area performance optimized cmos multipliers fast multiplication algorithms implementation regular layout parallel adders method rounding using redundant coded multiply result schemes parallel multipliers method apparatus rounding highspeed multipliers recoders partial compression rounding fast multiplier bitproduct matrix reduction using bit ordering parity generation dual mode ieee multiplier comparison three rounding algorithms ieee oating point multiplication parallel method apparatus detecting completing oating point operations involving special operands ieee standard binary oatingpoint arithmetic multistep gradual rounding design strategies optimal multiplier circuits design issues high performance floating point arithmetic units snap project design oating point arithmetic units method speed optimized partial product reduction generation fast parallel multipliers using algorithmic approach reducing number counters needed integer multiplication generation high speed cmos multiplier accumulators floating point multiplier performing ieee rounding addition parallel fast ieee rounding rounding algorithms ieee multipliers half latency ieee compliant oatingpoint multiplication reducedarea scheme carryselect adders fast multiplication algorithm vlsi implementation suggestion parallel multipliers new design technique column compression multipliers oating point multiplier method apparatus partially suporting subnormal operands oating point multiplication shared rounding hardware multiplier divisionsquare root unit using conditional sum adder circuitry rounding oating point multiplier 9l 13l 13l 14l 15l 14l 13l 16l 16l 9l 8l 10l tr ctr petermichael seidel guy even delayoptimized implementation ieee floatingpoint addition ieee transactions computers v53 n2 p97113 february 2004 ahmet akkas michael j schulte dualmode floatingpoint multiplier architectures parallel operations journal systems architecture euromicro journal v52 n10 p549562 october 2006 nhon quach naofumi takagi michael j flynn systematic ieee rounding method highspeed floatingpoint multipliers ieee transactions large scale integration vlsi systems v12 n5 p511521 may 2004
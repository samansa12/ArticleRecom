circuit retiming applied decomposed software pipelining abstractthis paper elaborates new view software pipelining called decomposed software pipelining introduced gasperoni schwiegelshohn wang eisenbeis jourdan su approach decouple problem resource constraints dependence constraints resource constraints management amounts scheduling acyclic graph subject resource constraints efficiency bound known resulting bound loop scheduling acyclic graph obtained cutting particular edges cyclic dependence graph paper cut edges different way using circuit retiming algorithms minimize longest dependence path acyclic graph number edges acyclic graph technique improve efficiency bound given gasperoni schwiegelshohn algorithm reduce constraints remain acyclic problem believe framework interest brings new insight software problem establishing deep link circuit retiming problem b introduction oftware pipelining instructionlevel loop scheduling technique achieving high performance processors superscalar vliw long instruction word architectures main problem cope data dependences resource constraints make problem npcomplete general software pipelining problem motivated great amount research since pioneering work rau glaeser 1 several authors proposed various heuristics 2 3 4 5 6 various frameworks extended survey software pipelining provided 7 recently novel approach software pipelining called decomposed software pipelining proposed simultaneously gasperoni schwiegelshohn 8 wang eisenbeis jourdan su 9 idea decompose npcomplete software pipelining problem two subproblems loop scheduling problem ignoring resource constraints acyclic graph scheduling prob lem efficient techniques list scheduling example well known although splitting problem two subproblems clearly optimal strat egy wang eisenbeis jourdan su demonstrated experimental evaluation loops livermore benchmark kernels approach py calland supported grant region rhonealpes darte robert supported cnrsens lyoninria project remap authors laboratoire lip ura cnrs 1398 ecole normale superieure de lyon f69364 lyon cedex 07 email pierreyvescallandalaindarteyvesrobertenslyonfr promising respect time efficiency space efficiency approaches technique preprocess loop data dependence graph may include cycles cutting dependence edges preprocessing modified graph becomes acyclic classical scheduling techniques applied generate pattern kernel software pipelining loop however way edges cut adhoc cases general framework given explains edges could andor cut main contribution paper establish preprocessing data dependence graph deep link circuit retiming problem paper organized follows section ii described precisely software pipelining model section iii recall main idea decomposed software pipelining illustrate novel technique gasperoni schwiegelshohn algorithm show decomposed software pipelining reformulated terms retiming algorithms exactly tools needed perform desired edges cut demonstrate interest framework addressing two optimization problems ffl section iv show cut edges length longest path acyclic graph minimized technique improve performance bound given gasperoni schwiegelshohn algorithm ffl section v show cut maximal number edges minimize number constraints remaining processing acyclic graph criteria taken account neither gasperoni schwiegelshohn algorithm wang eisenbeis jourdan su algorithm finally discuss extensions section vi summarize results give perspectives section vii ii simplified model software pipelining problem first present assumptions discussing motivations problem formulation paper consider loop composed several operations executed large number times finegrain architecture assume resource constraints dependence constraints compared general frameworks make following simplifying hypotheses ieee transactions parallel distributed systems vol xx month 1996 resources architecture consists p identical non pipelined resources constraint cy cle resource cannot used dependences dependences operations captured doubly weighted graph ffi v set vertices g one vertex per operation loop e set edges g edge e e de nonnegative integer called dependence distance vertex u v ffiu nonnegative integer called delay ffi model fact edge operation v iteration issued least ffiu cycles start operation u iteration assume sum dependence distances along cycle positive hypotheses given gasperoni schwiegelshohn non pipelined case discussing limitations simplified model let us illustrate notion operations iterations delays dependence distance following example work example throughout paper enddo loop 6 operations b c e f n iterations operation executed n times n parameter unknown value possibly large associated graph g given figure 1 delays depicted square boxes example delay operation f 10 times greater delay operation dependence distances express fact computations must executed specified order preserve semantics loop example operation iteration k writes ak hence must precede computation b iteration reads value constraint captured label equal 2 associated edge b dependence graph figure 1 f 121414fig 1 example dependence graph g software pipelining problem find schedule oe assigns issue time oeu operation instance operation u iteration k edge graph gives rise constraint scheduling valid schedules schedules satisfying dependence constraints expressed equation 1 resource constraints regular structure software pipelining problem usually search cyclic modulo scheduling oe aim finding nonnegative integer called initiation interval oe constants c u oeu input loop supposed execute many iterations n large focus asymptotic behavior oe initiation interval natural performance estimator oe 1 measures oes throughput note reduced dependence graph g acyclic target machine enough processors zero type schedule infinite throughput variant consists searching nonnegative rational ab let oeu rational constants c u amounts unroll input loop factor b come back variant section vi note also rational cyclic schedules dominant case unlimited resources 4 b limitations model compared sophisticated models general programs may handled programs conditionals accurate architecture description given framework simple may seem unrealistic partly agree would like raise following arguments delays many frameworks delay defined edges vertices model chose latter two reasons first want compare technique gasperoni schwiegelshohn algorithm uses delays vertices second use graph retiming techniques also commonly defined delays vertices ever point retiming general model possible technically complex see example 10 section 9 resources architecture model non pipelined identical resources simple main reason restricted hypothesis want demonstrate theoretical point view technique allows derive efficiency bound gasperoni schwiegelshohn algorithm practical point view technique still used even sophisticated resource models indeed retiming technique use independent architecture model seen preloop transfor mation resource constraints taken account second phase algorithm additional features architecture considered scheduling acyclic graph obtained retiming particular technique easily integrated regardless architecture details compiler instruction scheduler extensions model decomposed software pipelining still recent approach software pipelining thus studied first theoretical point view restricted models also case paper whole problem yet well understood enough py calland darte robert circuit retiming applied decomposed software pipelining 3 allow general architecture features taken account however believe new view problem particular use retiming controlling structure acyclic graph lead future accurate heuristics sophisticated architecture models iii going cyclic scheduling acyclic scheduling going details gasperoni schwiegelshohn heuristic gs short recall properties cyclic schedules main idea decomposed software pipelining make rest presentation clearer properties cyclic scheduling consider dependence graph cyclic schedule oe oeu satisfies dependence constraints resource constraints cyclic schedule periodic period computation scheme reproduced every units time pre cisely instance u assigned begin time instance begin time therefore need study slice clock cycles know behavior whole cyclic schedule steady state let us observe slice eg slice sk clock cycle k clock cycle k enough steady state reached figure 2 depicts steady state schedule graph figure 1 initiation interval time resources ak fk initiation interval fig 2 successive slices schedule graph g boxes grey represent operation initiated slice sk perform euclidean division c u c means one one instance operation u initiated within slice sk instance issued r u clock cycles beginning slice quantities r u q u similar row column numbers introduced 9 schedule valid resource constraints dependence constraints satisfied dependence constraints separated two types depending either two dependent operation instances initiated slice sk type 1 initiated two different slices type 2 course partial dependence graph induced type 1 constraints acyclic type 1 dependences impose partial order operations according order appear within slice figure 2 arrows represent pendences dependences depicted fig type 2 dependences main idea gasperoni schwiegelshohn algorithm gs generally decomposed software pipelining following assume valid cyclic schedule period 0 given number p 0 pro cessors want deduce valid schedule smaller number p processors way building new schedule keep slice structure ie keep operation instances within given slice course might need increase slice length cope reduction resources words stretch rectangle size 0 theta p 0 build rectangle size theta p using idea type 2 dependences still satisfied choose large enough type 1 dependences taken account internal reorganization slice see figure 3 since corresponding partial dependence graph acyclic brought back standard acyclic scheduling problem many theoretical results known particular simple list scheduling technique provides performance bound shorter longest path graph accurate performance bound time resources ak fk time ak fig 3 two different allocations slice graph g p main principle settled remain several open questions 1 choose initial scheduling 0 2 choose reference slice reason priori choose slice beginning clock cycle congruent 0 modulus 0 3 decide edge type 1 hence considered acyclic problem three questions course linked together intu itively seems important try minimize ffl length longest path acyclic graph small possible tightly linked performance bound obtained list scheduling ffl number edges acyclic graph reduce dependence constraints acyclic scheduling problem 4 ieee transactions parallel distributed systems vol xx month 1996 give precise formulation questions give solution beforehand review choices gs b heuristic gasperoni schwiegelshohn section explain full details gs heuristic 8 main idea outlined previous section choice gs initial scheduling consider optimal cyclic scheduling infinite number processors constraints b1 optimal schedule unlimited resources consider cyclic scheduling problem without resource constraints let nonnegative integer define g edgeweighted graph g 0 ffl vertices g 0 v new vertex ffl edges g 0 edge ver tices ffl weight edges g 0 following wellknown result lemma 1 valid initiation interval g 0 cycle positive weight furthermore g 0 cycle positive weight ts u denotes length longest path g 0 u oeu valid cyclic schedule lemma 1 two important consequences ffl first given integer easy determine valid initiation interval yes build corresponding cyclic schedule applying bellmanford algorithm 11 ffl optimal initiation interval 1 smallest nonnegative integer g 0 positive cy cle therefore maxfd c cycle gg otherwise furthermore binary search combined bellmanford algorithm computes 1 polynomial time b2 algorithm gs p resources said case p identical processors algorithm consists conversion dependence graph g acyclic graph g g obtained deleting edges g initial scheduling gs takes optimal scheduling unlimited resources reference slice gs takes slice starting clock cycle congruent 0 modulus 1 ie slice clock cycle k1 clock cycle k amounts decomposing ts u words r consider edge reference slice operation instance operation instance v performed within reference slice namely v started end operation u k gamma q u hence operation instance one depends upon completion words k gamma q two operations dependence edge e initiated slice edge e safely considered type 2 edge thus deleted g way edges cut gs heuristic 1 led following algorithm algorithm 1 algorithm gs 1 compute optimal cyclic schedule oe 1 unlimited resources 2 let edge g e deleted g provides acyclic graph g 3 consider acyclic graph g vertices weighted ffi edges represent task dependences perform list scheduling oe p processors b let makespan ie total execution time schedule g 4 ts u valid cyclic schedule correctness algorithm gs found 8 also deduced correctness algorithm cdr see section ivb1 b3 performances algorithm gs gs gives upper bound initiation interval obtained algorithm 1 let opt optimal smallest initiation interval p processors following inequality established phi length longest path g moreover owing strategy cutting edges phi 8 implies leads opt opt gs first guaranteed algorithm see equation 2 bound directly depends upon phi length longest path g example go back example assume processors graph g graph figure 1 figure 4a depict graph g 0 12 different values ts u given circles figure schedule oe 1 u already represented figure 2 4 processors needed 1 however best way determine type 2 edges see section iiic py calland darte robert circuit retiming applied decomposed software pipelining 5 figure 4b shows acyclic graph g obtained cutting edges r finally figure 4c shows possible schedule operations provided list scheduling initiation interval solution f ak time resources b c fig 4 graph g 0b acyclic graph ga corresponding list scheduling allocation c cutting edges retiming let us summarize algorithm gs follows first compute values ts u g 0 1 provide optimal scheduling without resource constraints oe 1 take reference slice starting clock cycle 0 finally delete g edges necessarily correspond dependences different slices edges removed algorithm gs however edges correspond dependences different slices q u within reference slice scheduled computation instances therefore computation v depends upon performed slice iff wise performed subsequent slice case let us check mathematically arbitrary slice consider valid cyclic scheduling oeu 6 0 let c 0 given edge dependence constraint satisfied thus r u r finally dividing get furthermore q v dependence constraints directly writes r u thus ae therefore condition cutting edges corresponding dependences different slices ie called furthermore edge cut gs also cut new rule led modified version gs call mgs since cut edges mgs gs acyclic graph mg obtained mgs contains subset edges acyclic graph g see figure 5 illustrate fact ak time resources b fig 5 acyclic graph provided algorithm mgs b corresponding list scheduling allocation actually need neither initial ordering reference slice longer need determine function define acyclic graph mg follows edge mg iff qv clearly mg acyclic assume cycle sum quantities qv qu cycle get contradiction finally given mg list schedule dag whose vertices weighted initial ffi function function q called retiming context synchronous vlsi circuits 10 given graph q performs transformation g new graph g q q defined follows edge e q transformation interpreted follows de represents number registers edge e retiming q amounts suppress qu registers edge leaving u add qv registers edge entering v retiming said valid edge e e q e 0 least one register per edge g q see equation 3 edges q edges register note assumed sum de cycle g positive using vlsi terminology say g synchronous ready formulate problem recall goal answer following two questions ffl cut edges obtain acyclic graph g whose longest path minimal length ffl cut many edges possible number dependence constraints satisfied list scheduling g minimized 6 ieee transactions parallel distributed systems vol xx month 1996 using new formulation state objectives precisely terms retiming objective 1 find retiming q minimizes longest path mg ie terms retiming minimizes clock period phi retimed graph objective 2 find retiming q number edges mg minimal ie distribute registers leave edges register possible section iv show achieve first objective several possible solutions section v show select best one respect second objective state final algorithm improve upon gs two reasons first better bound second cut edges hence freedom list scheduling iv minimizing longest path acyclic graph wellknown retiming algorithms used minimize clock period vlsi circuit ie maximal weight terms delay path register first recall algorithms due leiserson saxe 10 show applied decomposed software pipelining retiming algorithms first need definitions denote u p path p g u v dp e2p de sum dependences edges p ffip v2p ffiv sum delays vertices p define delta follows delta computed solving allpairs shortestpath algorithm g edge u e weighted pair de gammaffiu finally let path g dp phig length longest path null weight g called clock period g vlsi terminology theorem 1 theorem 7 10 let synchronous circuit let arbitrary positive real number let q function v integers q legal retiming g phig q 1 every edge u e 2 deltau v theorem 1 provides basic tool establish following algorithm algorithm 2 determines retiming clock period retimed graph minimized algorithm 2 algorithm opt1 10 1 compute delta see algorithm wd 10 2 sort elements range delta 3 binary search among elements deltau v minimum achievable clock period test whether potential clock period feasible apply bellmanford algorithm determine whether conditions theorem 1 satisfied 4 minimum achievable clock period found step 3 use values qv found bellmanford algorithm optimal retiming algorithm runs ojv j 3 log jv j efficient algorithm whose complexity ojv jjej log jv j significant improvement sparse graphs runs previous algorithm except step 3 bellmanford algorithm replaced following algorithm algorithm 3 algorithm feas 10 given synchronous desired clock period algorithm produces retiming q g g q synchronous circuit clock period phi retiming exists 1 vertex set qv 0 2 repeat following compute graph g q existing values q b vertex v 2 v compute delta 0 v maximum sum ffip vertex delays along zeroweight directed path p g leading v done ojej c vertex v delta 0 v set qv 3 run algorithm used step 2b compute phi phi feasible retiming exists otherwise q desired retiming b new scheduling algorithm algorithm cdr give new algorithm prove resource dependence constraints met algorithm 4 algorithm cdr let dependence graph 1 find retiming q minimizes length phi longest path null weight g q use algorithm 2 improved algorithm step 3 2 delete edges positive weight equivalently keep edges edges register way obtain acyclic graph g 3 perform list scheduling oe g compute 4 define cyclic schedule oe note complexity algorithm cdr determined step 1 whose complexity ojv jjej logjv j comparison complexity algorithm gs ojv jjej logjv jffi max difference comes fact phi opt searched among jv j 2 values deltau v whereas 1 searched among values 0 algorithms similar complexities py calland darte robert circuit retiming applied decomposed software pipelining 7 b1 correctness algorithm cdr theorem 2 schedule oe obtained algorithm cdr meets dependence resource constraints proof resource constraints obviously met list scheduling definition ensures slices overlap show dependence constraints satisfied e need verify oe u oe one hand suppose e deleted ie e 2 g equivalent say weight e retiming equal zero qv since oe schedule g oe u thus inequality 4 satisfied hand e deleted definition oe u thus inequality 4 satisfied b2 performances algorithm cdr use technique 8 order show algorithm also guaranteed give upper bound initiation interval smaller bound given algorithm gs theorem 3 let g dependence graph phi opt minimum achievable clock period g initiation interval schedule generated algorithm cdr p processors available opt best possible initiation interval case opt phi opt opt proof construction phi opt length longest path g thus proof technique 8 ie list scheduling technique prove leads desired inequality show bound obtained algorithm cdr theorem 3 always better bound algorithm gs see equation 2 consequence following lemma lemma 2 1 phi opt proof let us apply algorithm cdr unlimited resources define retiming q define graph g deleting g edges e q e 0 define schedule g unlimited resources oe p path g leading ug makespan oe phi opt construction finally get schedule g defining tion smallest initiation interval consider optimal cyclic schedule oe unlimited resources oeu defined section iii b1 let proved section iiic q defines valid retiming g ie edges g deleting g edges e q e 0 algorithm mgs let p path g summing construction phig q length longest path g thus phig q finally phi opt phig q hence result theorem 4 performance upper bound given algorithm cdr better performance upper bound given algorithm gs proof easily derived fact phi opt shown lemma 2 note bound worst case upper bound initiation interval prove however cdr always better gs example apply algorithm cdr key example assume available processors phi 14 retiming q achieves clock period obtained two steps algorithm 3 q figures 6a 6b 6c show successive retimed graphs figure 6d shows corresponding acyclic graph g finally figure 6e shows possible schedule operations provided list scheduling technique whose initiation interval better found algorithm mgs see figure 5b algorithm gs see figure 4c b3 link 1 phi opt shown lemma 2 1 phi opt close ever retiming derived schedule initiation interval 1 permit define acyclic graph longest path phi opt words looking 1 right approach minimizing period graph section investigate deeply fact recalling another formulation retiming problem given leiserson saxe 10 lemma 3 lemma 9 10 let synchronous circuit let c positive real number 8 ieee transactions parallel distributed systems vol xx month 1996 f f f b c ak bk ck time resources e fig 6 initial dependence graph g b c successive steps retiming used cdr corresponding acyclic graph corresponding list scheduling allocation exists retiming q g phig q exists assignment real value sv integer value qv vertex v 2 v following conditions satisfied gammasv gammaffiv every vertex sv every vertex qu gamma letting every vertex u inequalities 5 equivalent qu gamma last system permits better understand techniques developed previously optimal schedule unlimited resources seen lemma 2 schedule oeu system 6 except second inequality rv necessarily rv case proof algorithm cdr unlimited resources construc tion retiming phig q system 6 satisfied smallest value therefore technique leads better cyclic schedule unlimited resources slices overlap second inequality always possible find 1 way algorithms cdr gs p resources schedule obtained satisfies system 6 makespan oe cdr q retiming achieves optimal period whereas gs q retiming defined 1 1 c cdr fourth inequality satisfied exactly edges however gs oe required satisfy fourth inequality edges necessary actually edges ru ffiu rv note algorithms additional conditions imposed resource constraints appear system 6 v minimizing number edges acyclic graph purpose section find retimed graph minimum number null weight edges among retimed graphs whose longest path best possible length phi opt removing edges non null weight give acyclic graph matches objectives stated end section iiic example consider step 1 algorithm cdr use retiming algorithm leiserson saxe 10 final retiming minimize length phi longest path null weight necessarily minimize number null weight edges see key example figure 6 c 14 apply yet another retiming obtain graph figure 7a 0 f c bk time resources fig 7 final retimed graph b corresponding acyclic graph corresponding list scheduling allocation length longest path null weight still 14 total number null weight edges smaller implies corresponding acyclic graph g see figure contains fewer edges acyclic graph figure 6d therefore likely produce smaller initiation interval 2 case example find initiation interval equal 19 see figure 7c turns 19 best possible integer initiation list scheduling graph subset another graph always produce smaller execution time intuition shows practical cases fewer constraints freedom py calland darte robert circuit retiming applied decomposed software pipelining 9 interval processors sum operation delays 37 37 recall retiming q phig q integral solution following system see formulation theorem 1 deltau v phi opt among retimings want select one particular retiming q number null weight edges g q minimized done follows lemma 4 let synchronous circuit retiming q phig q number null weight edges g q minimized found polynomial time solving following integer linear program min deltau v phi opt proof consider optimal integer solution q v system 8 q defines retiming g phig q since system 7 satisfied indeed qv gamma qudeve note constrained one equation 1 two cases ffl weight e g q null ie possibility ffl weight e g q positive ie qvgammaqude 1 recall q integers case minimal value v 0 therefore given retiming q e2e minimal equal number null weight edges g q remains show optimal integer solution found polynomial time system 8 matrix form minfcx j ax bg c c transpose jv jthetajejincidence matrix g c 0 transpose incidence matrix graph whose edges pairs u v deltau v phi opt jej theta jej identity matrix incidence matrix c totally unimodular see 12 page 274 easy see also totally unimodular therefore solving ilp problem 8 npcomplete system 8 considered lp problem integral optimum solution corollary 191a 12 integral solution found polynomial time theorem 162 12 let us summarize refinement incorporated software pipelining heuristic first compute phi opt minimum achievable clock period g solve system 8 obtain retiming q define g acyclic graph whose edges null weight longest path g minimized number edges g minimized finally schedule g algorithm cdr call heuristic modified cdr simply mcdr remark solving system 8 expensive although polynomial optimization permits reducing complexity precompute strongly connected components g g solve problem separately component g retiming minimizes number null weight edges g q built adding suitable constants retiming q edges link different components positive weights future work try find pure graphtheoretic approach resolution system 8 practical complexity software pipelining heuristic decreased vi load balancing restricted far initiation intervals integer values mentioned section ii searching rational initiation intervals might give better results price increase complexity searching b achieved unrolling original loop nest factor b thereby processing extended dependence graph many vertices edges section propose simple heuristic alleviate potential load imbalance processors need unroll graph remember principle four previously described heuristics gs mgs cdr mcdr first acyclic graph g built g g scheduled list scheduling technique defines schedule oe inside slice length initiation interval finally slices concatenated slice initiated completion previous one main weakness principle slices overlap since schedule slice defined assoonaspossible asap list scheduling usually happens many processors idle last time steps slice idea remedy problem try fill holes schedule tasks next slice instead scheduling next slice schedule oe schedule aslate aspossible alap holes may appear first time steps slice two successive slices processors permuted computational load nearly equally balanced concatenating slices course dependences slices must taken account precise formulation heuristic found 13 illustrate key example example figure 7c shows possible allocation instance g provided asap list scheduling figure 8a shows allocation provided alap list scheduling figure 8b concatenation two instances initiation interval obtain equal 37 two instances ie better initiation interval obtained algorithm figure 7c cannot improved two processors always busy 2 time resources bk b bk ak dk ck fk fig 8 alap scheduling b concatenation two instances another possibility schedule acyclic manner two slices instead one retiming chosen equivalent unroll loop retiming performed case first slice processed second slice allocated way taking account dependence constraints coming acyclic graph plus dependences two slices words retiming seen preloop transformation consists changing structure subgraph induced loop independent edges retiming done software pipelining algorithm still applied vii conclusion paper presented new heuristic software pipelining problem built upon results gasperoni schwiegelshohn made clear link software pipelining retiming case identical non pipelined resources new heuristic guaranteed better bound 8 unfortunately cannot extend guarantee case many different resources list scheduling guaranteed case point cdr heuristic reasonable complexity similar classical software pipelining algo rithms mcdr work aimed deriving algorithmic implementation require use integer linear programming even though particular instance ilp invoked mcdr polynomial finally note edgecutting heuristics lead cyclic schedules slices overlap construction final loadbalancing technique first step overcome limitation would interesting derive methods sophisticated loop unrolling synthesize resourceconstrained schedules slices overlap acknowledgments authors would like thank anonymous referees careful reading fruitful comments r scheduling techniques easily schedulable horizontal architecture high performance scientific computing software pipelining effective scheduling technique vliw machines perfect pipelining new loop optimization technique cyclic scheduling parallel proces sors overview finegrain scheduling resource con straints framework resourceconstrained rateoptimal software pipelining software pipelining generating close optimum loop schedules parallel processors decomposed software pipelining retiming synchronous circuitry introduction algorithms theory linear integer program ming new guaranteed heuristic software pipelining problem tr ctr hansaem yun jihong kim soomook moon time optimal software pipelining loops control flows international journal parallel programming v31 n5 p339391 october dongming peng mi lu exploring interiteration parallelism within ratebalanced multirate multidimensional dsp algorithms ieee transactions large scale integration vlsi systems v13 n1 p106125 january 2005 timothy w oneil edwin hm sha combining extended retiming unfolding rateoptimal graph transformation journal vlsi signal processing systems v39 n3 p273293 march 2005 timothy w oneil edwin hm sha combining extended retiming unfolding rateoptimal graph transformation journal vlsi signal processing systems v39 n3 p273293 march 2005 alain darte guillaume huard loop shifting loop compaction international journal parallel programming v28 n5 p499534 oct 2000 greg snider performanceconstrained pipelining software loops onto reconfigurable hardware proceedings 2002 acmsigda tenth international symposium fieldprogrammable gate arrays february 2426 2002 monterey california usa karam chatha ranga vemuri hardwaresoftware partitioning pipelined scheduling transformative applications ieee transactions large scale integration vlsi systems v10 n3 p193208 june 2002 r govindarajan guang r gao palash desai minimizing buffer requirements rateoptimal schedule regular dataflow networks journal vlsi signal processing systems v31 n3 p207229 july 2002
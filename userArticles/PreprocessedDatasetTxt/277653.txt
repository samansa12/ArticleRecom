complete removal redundant expressions partial redundancy elimination pre important component global optimizers generalizes removal common subexpressions loopinvariant computations existing pre implementations based code motion fail completely remove redundancies fact observed 73 loopinvariant statements cannot eliminated loops code motion alone dynamic terms traditional pre eliminates half redundancies strictly partial achieve complete pre control flow restructuring must applied however resulting code duplication may cause code size explosionthis paper focuses achieving complete pre incurring acceptable code growth first present algorithm complete removal partial redundancies based integration code motion control flow restructuring contrast existing complete techniques resort restructuring merely remove obstacles code motion rather carry actual optimizationguiding optimization profile enables additional code growth reduction selecting duplications whose cost justified sufficient executiontime gains paper develops two methods determining optimization benefit restructuring program region one based pathprofiles dataflow frequency analysis furthermore abstraction underlying new pre algorithm enables simple formulation speculative code motion guaranteed positive dynamic improvements finally show balance three transformations code motion restructuring speculation achieve nearcomplete pre little code growthwe also present algorithms efficiently computing dynamic benefits particular using eliminationstyle dataflow framework derive demanddriven frequency analyzer whose cost controlled permitting bounded degree conservative imprecision solution b introduction partial redundancy elimination pre widely used effective optimization aimed removing program statements redundant due recomputing previously produced values 27 pre attractive targeting statements redundant along execution paths subsumes generalizes two important valuereuse techniques global common subexpression elimination loopinvariant code motion consequently pre serves unified valuereuse optimizer pre algorithms employ code motion 11 12 14 15 16 17 25 27 program transformation reorders instructions without changing shape control flow graph unfortunately codemotion alone fails remove routine redundancies practice one half computations strictly partially redundant redundant along paths left unoptimized due codemotion obstacles theory even optimal codemotion algorithm 25 breaks loop invariants whileloops unless supported explicit dountil conversion recently steffen demonstrated control flow restructuring remove program redundant computations including conditional branches 31 propertyoriented expansion algorithm poe complete causes unnecessary code duplication first step towards complete pre affordable code growth paper presents new pre algorithm based integration code motion control flow restructuring allows complete removal redundant expressions minimizing code duplication prior work systematically treated combining two trans formations control code duplication restricting scope codemotion preventing cmp region localizes adverse effects control flow desired value reuse whereas poe algorithm applied expression elimination denoted poepre uses restructuring carry entire transformation apply economical codemotion transformation full extent resorting restructuring merely enable necessary code motion resulting code growth provably greater poepre spec95 found three times smaller second answer overriding question complete feasible pre algorithm allowed move theory practice considering profile information using dynamic amount eliminated computations measure optimization benefit develop profileguided pre algorithm limits code growth cost else r cd else p break en en duplicated make ab fully redundant duplicated allow code motion ab en en code motion en duplicated complete optimization cd duplicated partial optimization cd r r cd cd cd cd ab r cd u ab cd r cd cd r cd cd ab ab r cd ab ab optimization cd source program b poepre ab c optimization ab e tradeoff variant r figure 1 complete pre integration code motion control flow restructuring sacrificing valuereuse opportunities infrequent require significant duplication third describe speculative code motion used instead restructuring guarantee speculative pre profitable finally demonstrate nearcomplete pre little code growth achieved integrating three pre transformations pure code motion restructuring speculative code motion algorithms paper rely specific way notion cmp region used reduce code duplication program analysis cost thus make pre optimization usable increasing effectiveness power costsensitive restruc turing also improving efficiency implementa tion develop compiletime techniques determining impact restructuring program region dynamic amount eliminated computations runtime benefit corresponds cumulative execution frequency control flow paths permit value reuse restructuring describe benefit obtained either using edge profiles pathprofiles 7 dataflow frequency analysis 28 another contribution reduce cost frequency analysis presenting frequency analyzer derived new demanddriven dataflow analysis framework based interval analysis framework enables formulation analyzers whose time complexity independent lattice size requirement frequency analysis whose lattice infiniteheight due requirement existing demand frameworks unable produce frequency analyzer 18 23 30 furthermore introduce notion approximate dataflow frequency information conservatively underestimates meetoverallpaths solution keeping imprecision within given degree approximation permits analyzer avoid exploring program paths guaranteed provide insignificant contribution frequency wise overall solution besides pre demanddriven approximate frequency analysis applicable interprocedural branch correlation analysis 10 dynamic optimizations 5 let us illustrate pre algorithms loop figure 1a assume statement loop defines variables although computations ab cd loopinvariant removing loop code motion possible consider first optimization ab computation cannot moved loop would executed path en opex execute b original program could slow program create spurious excep tions pre disallows unsafe code motion 25 desired optimization possible cfg restructured poepre algorithm 31 would produce program figure 1b created duplicating node value ab available subset incoming paths b fully opti mized scope restructuring unnecessarily large complete optimization compre produces program figure 1c code duplication applied merely enable necessary code motion example move loop sufficient separate offending path eno pex encapsulated cmp region highlighted figure opportunities value reuse remain resulting optimization complete restructuring may generate irreducible programs figure 1c also present restructuring transformation maintains reducibility hoisting loop invariant loop prevented shape control flow experiments show problem removing loop invariant code li sufficiently solved complete li prevented 73 loopinvariant expressions cases simple transformation may help example optimized peeling one loop iteration performing traditional li 1 producing progra figure 1b whileloops li often enabled economical dountil conversion example presented allow transformation loop exit postdominate loop entry effect restructuring pre always able perform smallest necessary dountil conversion arbitrary loop next optimize computation cd figure 1c optimization performs complete pre c duplicating shaded cmp region subsequently performing code motion figure 1d resulting program may cause much code growth depending sizes duplicated basic blocks assume size block outweighs runtime gains eliminating upper c case select smaller set nodes duplicate shown figure 1e block q duplicated optimization longer complete however optimization cost measured code growth justified corresponding runtime gain section 32 speculative code motion used reduce code duplication summary paper makes following contributions ffl present approach integrating two widely used code transformation techniques code motion code restructuring result algorithm pre complete ie exploits opportunities value reuse minimizes code growth necessary achieve code motion ffl show restricting algorithm code motion produces traditional codemotion pre 17 25 ffl profileguided techniques limiting code growth integration selective duplication speculative code motion developed ffl develop demanddriven frequency analyzer based new elimination dataflow analysis framework ffl notion approximate dataflow information defined used improve analyzer efficiency ffl experiments compare power codemotion pre speculative pre complete pre section 2 presents complete pre algorithm section 3 describes profileguided versions algorithm section 4 presents experiments section 5 develops demanddriven frequency analyzer paper concludes discussion related work complete pre section develop algorithm complete removal partial redundancies compre based integration code motion control flow restructuring code motion primary transformation behind compre reduce code growth restructuring used enable hoisting regions prevent necessary code motion smallest set motionblocking nodes identified solving problems availability anticipabil ity expressive lattice also show control flow restructuring disabled compre becomes equivalent optimal codemotion pre algorithm 25 expression partially redundant value computed incoming control flow path previous expression codemotion pre eliminates redundancy hoisting redundant computation along paths reaches edge reused value available along either paths paths former case computation removed latter inserted make original computation fully redundant unfortunately code motion may blocked edges reached nodes prevent desired code motion characterized following set conditions 1 hoisting expression e across node n necessary optimization candidate follows n computation e downstream n path b valuereuse opportunity e node n computation e precedes n path 2 hoisting e across n disabled c path going n compute e source program path would impaired computation e three conditions characterizable via solutions dataflow problems anticipability availability defined follows path start node node n expression e available n along p iff e computed p without subsequent redefinition operands let r path n end node expression e anticipated n along r iff e computed r operands defined availability e entry n wrt incoming paths defined avail n must available along paths may anticipability antic defined analogously given refined valuereuse definition code motion necessary b defined hold mutually hence avail n e 6 code motion disabled condition c holds must avail n e 6 must node n prevents necessary code motion e motion necessary disabled time way conjunction get code motionpreventing condition avail n predicate prevented characterizes smallest set nodes must removed code motion enabled code motion prevented cmp region b cmp region diluted via code duplication c complete pre ab code motion becomes possible code motion anticno anticmust availno availmust r ab r ab ab ab r availmay anticmay anticmay anticmay anticmay availno availmust availno availmust anticmay figure 2 removing obstacles code motion via restructuring motion preventing region denoted cmp e set nodes prevent hoisting computation e cmp e fn j antic n avail n mayg enable code motion compre removes obstacles presented cmp region duplicating entire region illustrated figure 2 central idea factor mayavailability holds entire region must noavailability hold respectively region copy alternative view separate within region paths must noavailability achieve observe region entry edge mayavailable b solution availability within region depends solely solutions entry edges expression neither computed killed within region hence desired factoring carried attaching region copy subset either must entry edges shown figure 2c cmp duplicated condition prevented false node enabling code motion compre algorithm shown figure 3 following three steps 1 compute anticipability availability problems use lattice flow functions distributive least common element operator defined using partial order v shown distributivity property implies dataflow facts approximated control flow merge points intuitively l powerset lattice fno mustg facts may hold along individual path partial order v must may 2 remove cmp regions via control flow restructuring given expression e cmp region identified examining dataflow solutions locally node line 2 figure 3 duplicates cmp node line 3 adjusts control flow edges new copy region hosts must solution restructuring necessitates updating dataflow solutions within cmp region lines 412 antic solution altered previously computed avail solution invalidated paths flowing region eliminated region entry edges discon nected expression e avail becomes either must entire region expressions solution may become conservatively imprecise words splitting may path mustno paths e might also split may path expression therefore line 6 resets initial guess lines 1012 recompute solution within cmp 3 optimize program code motion transformation carried replacing original computation e temporary variable te temporary initialized computation inserted noavailable edge sinks either maymust availability path original computation insertion edge must also mustanticipated verify hoisting original computation edge theorem 1 completeness compre optimal minimizes number computations path proof first original computation replaced temporary second computation inserted value available along incoming path hence additional computations removed within domain morel renviose code motion transformation pre accomplished hoisting optimization candidates statements 27 compre achieves minimum code growth 1 follows fact cmp restructuring program node removed merged node without destroying value reuse shown following observations prior step 2 node n may belong cmp regions multiple offending expressions duplication n restructuring viewed partitioning control flow paths going n resulting copy n path partition contain must noavailable path offending expression 1 outside domain code growth reduction possible moving instructions cmp duplication step 1 dataflow analysis anticipability availability ffl input control flow graph node contains single assignment x e ffl compn e node n computes expression e ffl transpn e node n assign variable e ffl boundary conditions expression e antic end e avail start e ffl initial guess set vectors number candidate expressions solve iteratively antic n e must compn e antic n e otherwise antic n e antic e avail n e avail e avail n e f e n avail n e must compn e transpn e x otherwise step 2 remove cmp regions control flow restructuring ffl modify g cmp nodes exists expression e 1 expression e duplicate cmpe nodes create copy cmp n must copy node n hosting must attach new nodes perform restructuring must must must update dataflow solutions within cmp copy 4 node n 2 cmpe 5 antic n must antic n antic n must antic n 6 avail n must avail n avail n must 7 avail n must e avail n must e must 8 avail n e avail n e 9 end reanalyze availability inside cmp copies expression e 0 yet processed 12 end 13 end step 3 optimize code motion insertn e antic must avail n avail replacen e compn e figure 3 compre algorithm complete pre following properties step 2 verified 1 number path partitions node copies created given node independent order expressions considered line 1 2 node copy reachable start node 3 two copies n expression e remerging two copies incoming paths prevent code motion e across resulting node compare compre restructuringonly pre consider poepre version steffens complete algorithm 31 includes minimization duplicated nodes restricted expressions eliminated case compre elimination carried using temporary step 3 theorem 2 compre create new nodes poepre proof outline proof based showing poepreoptimized program minimization less nodes program cmp restructuring shown given original node n two copies n created cmp restructuring two distinct copies n created poepre minimization cannot merge without destroying value reuse opportunity fact poepre expressed form com pre nonstrictly larger region computation e poepre duplicates fnjantic n e 2 fmust mayg avail n superset cmp e algorithm complexity dataflow analysis step 1 lines 1012 requires ons steps n flow graph size number expressions restructuring step 2 however may cause n grow exponentially node may need split multiple expressions practice constantfactor codegrowth budget likely defined asymptotic program size change therefore running time step 2 dominates entire algorithm ons 2 21 optimal codemotion pre besides supporting complete pre notion cmp region also facilitates efficient formulation codemotion pre called cmpre section show complete algorithm naturally constrained prohibiting restructuring modification results optimization optimal motiononly pre 17 25 comparison compre constrained cmpre algorithm bypasses cmp removal last step trans formation unchanged figure 3 first step data flow analysis modified goal prevent hoisting across node n motion would subsequently blocked cmp region path flowing node n first anticipability computed compre second availability modified include detection cmp nodes cmp node found instead propagating forward mayavailability solution adjusted adjustment masks value reuse opportunities cannot exploited without restructuring result masking code motion prevented entering paths cross cmp region see predicate insert step 3 figure 3 modified flow function avail problem fol lows third line detects cmp node noavailability extended mean value might available along path value reuse blocked cmp region along path must compn e transpn e x otherwise given maximal fixed point solution redefined avail cmpre performs unchanged transformation phase figure 3 step 3 easy show resulting optimization complete immutable shape control flow graph proof analogous theorem 1 original computations removed computation inserted optimization opportunity blocked cmp exists besides exploiting opportunities pre algorithm guarantee live ranges inserted temporary variables minimal order moderate register pres sure live range minimal insertion point specified predicate insert cannot delayed moved direction control flow theorem 3 shortest live ranges given cmp restructured original control flow graph compre cmpre optimal minimizes live range lengths inserted temporary variables proof initialization point insert cannot delayed either would become partially redundant destroying completeness temporary variable used immediate successor existing pre algorithms find liverange optimal placement two stages first computations hoisted high possible maximizing removal redundancies later placement corrected computation delayability 25 formulation specifies optimal placement directly never hoist paths blocking cmp subsequently encountered however note redefinition f e n longer monotone given antic n must x1 v x2 f e must although direct approach solving system equations may produce conservatively imprecise solution desired maximal fixed point easily obtained using bitvector genkill operations follows first compute antic figure 3 second solve wellknown availability property denoted av holds expression computed along incoming paths must finally compute av characterizes somepaths availability also encapsulates cmp detection av avail 6 pair solutions directly mapped desired solution avail gen kill sets 1 problem given value initial guess false meet operator bitwise must antic 6 must condition avail 6 must antic 6 must detects cmp node less strict definition 2 equivalent purpose safe kill single loop copied reducibility entry node en en ab cd r cd cd source program cd ab r cd reducible compre ab figure 4 reducible restructuring see figure 1c reuse hoisting less strict condition beneficial computing testing must requires one bit per expression two bits required may con sequently substitute antic 6 must defined analogously av result obtain implementation complexity algorithms 17 25 three dataflow problems must solved requiring one bit solution per expression conclusion cmp region convenient abstraction terminating hoisting would unnecessarily extend live ranges also provides intuitive way explaining shortestliverange solution without applying corrective step based delayability 25 furthermore cmpbased motiononly solution implemented efficiently existing shortestliverange algorithms 22 reducible restructuring duplicating cmp region may destroy reducibility control flow graph figure 1c example compre resulted loop two distinct entry nodes even though poepre preserves reducibility loop figure 1b like restructuringbased optimizations 4 10 31 also plagued introducing irreducibility one way deal problem perform optimizations presuppose singleentry loops prior pre however many algorithms scheduling follow pre rely reducibility compre reducible graph obtained additional code duplication effective algorithm normalizing irreducible programs given 24 suppress unnecessary invocation algorithm employ simple test whether irreducibility may created region duplication test based upon examining cmp entry exit edges rather entire program assuming start reducible graph restructuring make loop l irreducible multiple cmp exit edges sink l least one region entry outside l ie dominated ls header node region duplicated target nodes region exit edges may become multiple loop entry nodes consider loop figure 4a two three exits cmp fall loop restructuring become loop entries shown figure 1c rather applying global algorithm like 24 straightforward approach make affected loop reducible peel part body goal extend replication scope region exits sink onto single loop node become new loop entry node closest common postdominator within loop offending region exits original loop entry figure 4a highlights node cd whose duplication cmp restructuring restore reducibility loop postdominator offending exits node q becomes new loop header 3 profileguided pre cmp region smallest set nodes whose duplication enables desired code motion size often prohibitive practice section relying profile estimate optimization benefit complete pre made practical avoiding unprofitable code replication first extend compre inhibiting restructuring response code duplication cost expected dynamic benefit resulting profileguided algorithm duplicates cmp region incurred code growth justified corresponding runtime gain eliminating redundancies second notion cmp region combined profiling formulate speculative codemotion pre guaranteed positive dynamic effect despite impairing certain paths third algorithm integrates restructuring speculation selects profitable subgraph cmp profitably balancing cost benefit given profile np hard empirically small number hot program paths promises efficient algorithm 4 19 finally support profile guiding show estimate runtime gain thwarted cmp region obtained using edge profiles frequency analysis 28 path profiles 7 31 selective restructuring model profitability duplicating cmp region r costbenefit threshold predicate r holds region optimization benefit exceeds constant multiple region size metric benefit dynamic amount computations whose elimination enabled r duplicated denoted remr true region r algorithm equivalent complete com pre r false region algorithm reduces codemotiononly cmpre obviously predicate determines suboptimal tradeoff exploiting pre opportunities limiting code growth particular explicitly consider instruction cache size increase register pressure due introduced temporary variables chosen form order avoid modeling complex interactions among compiler stages implementation supplemented code growth budget example 6 code allowed grow 20 first present algorithm computing optimization benefit remr method based fact step 1 compute anticipability availability unchanged step 2 partial restructuring remove profitable cmp regions 1 computation e 2 disconnected subregion r cmpe build largest connected subregion 3 select node r collect connected cmp nodes determine optimization benefit remr 4 carry frequency analysis avail r profitable duplicate lines 212 fig 6 end 7 end 8 recompute avail solution using f e n section 21 step 3 optimize code motion unchanged figure 5 pgpre profileguided version compre cmp scope localizes entire benefit thwarted region compute benefit suffices examine paths within region consider expression e cmp region e region exit edge e value antic e either must otherwise would cmp e let exitmust r set must exit edges dynamic benefit derived observation time edge executed outgoing path contains exactly one computation e eliminated r duplicated ii value e available exit edge let exa execution frequency edge pavail n probability value e available n executed region dupli cated expected benefit connected exit edge exapavail n corresponds number computations removed paths starting benefit duplicating region r thus sum exit edge benefits anm2exits must r exapavailout n probability p computed edge profile using frequency analysis 28 frequency domain probability dataflow fact occurring rather mere boolean meetoverallpaths existence computed incorporating execution probabilities control flow edges dataflow system frequency analyzer cannot exploit bitvector parallelism instead computes dataflow solutions floating point numbers desirable reduce cost calculating probabili ties cmp region lends effectively restricting scope program needs analyzed region entry edges either must noavailable probability e available edges 1 0 respectively therefore probability p exit edge influenced paths within region result sufficient perform frequency analysis expression e cmp e using entry edges precise boundary condition cmp dataflow equation system section 5 reduce cost frequency analysis demanddriven approach algorithm pgpre duplicates profitable cmp regions given figure 5 structured complete counterpart compre dataflow analysis proceed eliminate cmp regions separately expression compre sufficient treat nodes single cmp together selective duplication benefits dividing cmp disconnected subregions exist intuitively hoisting particular expression may prevented multiple groups nodes different part procedure therefore line 3 groups nodes connected subregion frequency analysis determines benefit group line 4 profitable regions eliminated motionblocking effect cmp regions remaining program must captured needed apply cmpre algorithm section 21 improved control flow graph blocked hoisting avoided recomputing availability line using redefined flow function f e n section 21 asserts noavailability whenever cmp detected 32 speculative codemotion pre codemotion pre hoisting computation e blocked whenever e would need placed control flow path p compute e original program speculative code motion prevented executing e along path p could raise spurious exceptions e eg flow wrong address b outweigh dynamic benefit removing original computation e former restriction relaxed instruction cannot except leading safe speculation new processor generations support controlspeculative instructions suppress raising exception generated value eventually used allowing unsafe speculation 26 latter problem solved 20 aggressive codemotion pre navigated path profiles developed goal allow speculative hoisting paths dynamic impairment would outweigh benefit eliminating computation original position next utilize cmp region determine profitability speculative code motion ii positions speculative insertion points minimize live ranges temporary variables figure 6 illustrates principle speculative pre 20 instead duplicating cmp region hoist expression noavailable entry edges makes exits fully available enabling complete removal original computations along must exits example moved noavailable region entry edge e2 hoisting speculative ab executed path going e2 e3 previously contain expression benefit computed follows dynamic amount computations decreased execution frequency exe4 mustanticipable exit edge following computation removed increased frequency exe2 noavailable entry edge computation inserted since speculation always associated cmp region able obtain simple precise profitability test speculative pre expression profitable total execution frequency mustanticipable exit edges exceeds noavailaible entry edges note benefit calculated locally examining entryexit edges paths within region necessary selective restructuring hence speculative benefit independent branch correlation edge profiles precise path profiles case speculativemotion pre far temporary live ranges concerned insertion entry edges results shortestliverange solution theorem 3 still holds code motion availmust availno anticmust speculative anticno removal insertion optimization benefit ab ab figure speculative codemotion pre 33 partial restructuring partial speculation section 31 edge profiles frequency analysis used estimate benefit rem duplicating region alternative use path profiles 3 7 convenient establishing costbenefit optimization tradeoffs 4 19 20 arrive value region benefit path profile sufficient sum frequencies must must paths paths cross region entry edge mustavailable exit edge must anticipated precisely paths along value reuse exists blocked region exponential number profiled acyclic paths 54 procedures execute 50 distinct paths spec95 19 number drops 13 lowfrequency paths accounting 5 total frequency removed since afford approximate disregarding infrequent paths summing individual path frequencies constitutes feasible algorithm many cmp regions furthermore encapsulate branch correlation path profiles compute benefit precisely frequency analysis based correlationinsensitive edge profiles moreover notion individual cmp paths leads better profileguided pre algorithm considering cmp region indivisible duplication unit overly conserva tive may profitable restructure entire region region may contain paths mustmust paths frequently executed inexpensive dupli cate goal find largest subset frequencywise region paths together pass threshold test r similarly speculative hoisting entry edges may fail profitability test instead seek find subset entry edges maximizes speculative benefit section show partial restructuring speculation carried combined partial speculation selects speculative insertion subset region entries selection entries influences subset r region exits able exploit value reuse r consists must exits become mustavailable due insertions rationale behind treating entries separately entries may enable little value reuse hence speculated note entry edges points speculative insertion needs considered insertions inside region would partially redundant insertions outside region would extend liveranges partial speculation optimal difference total frequencies r maximal nonnegative pointed 22 cd r source program b speculation made profitable cd rt nopath peeled profitable profitable speculation1001000901000 100 figure 7 integrating speculation restructuring problem solved maximum network flow problem interesting observation determine optimal partial speculation edge profiles inferior path profiles b frequency analysis required therefore exploit power path profiles partial restructuring rather speculative code motion alone must used becomes intuitive realize without control flow restructuring one restricted consider individual edge path expression insertion removal compare cmpbased partial speculation speculative pre 20 show efficiently compute benefit defining cmp region apply edge profiles precision path profiles acyclic code achieve preci sion cyclic code precise presence loopcarried reuse task partial restructuring localize subgraph cmp small size contains many hot mustmust paths duplicating subregion effectively peeling hot paths structions figure 1e presumably hot path node q separated problem finding optimal subregion one whose benefit maximized passes r predicate smaller constant budget nphard however empirically small number hot paths promises efficient exhaustivesearch algorithm integrating partial speculation restructuring offers additional opportunities improving costbenefit ra tio longer restricted peeling hot mustmust paths andor selecting noentries speculation high frequency entry prevents speculation peel hot noavailable path emanating thereby reducing entry edge frequency allowing speculation cost code duplication figure 7a shows example program annotated edge profile peeling hot mustmust paths highlighted cmp cd would duplicate blocks except try speculation eliminate redundancy cmp exit edge frequency exy computation must inserted noentries b c b lowfrequency 10 c 100 hence speculation dis advantageous exy assume exit branch q strongly biased path c qx frequency 100 edge c executed execution always follow x peel noavailable path shown b effectively moving speculation point c path peeling frequency c becomes 0 speculation profitable exy 4 experiments performed experiments using hp labs vliw backend compiler elcor fed spec95 benchmarks previously compiled edgeprofiled inlined spec95int impact compiler table 1 shows program sizes total number nodes expres sions node corresponds one intermediate state ment memory requirements indicated column space gives largest nodesexpressions product among procedures running time rather inefficient implementation behaved quadratically number procedure nodes procedure 1000 nodes time 5 seconds pa8000 typically complete pre ran faster subsequent dead code elimination experiment 1 disabling effects cmp regions column labeled optimizable gives percentage expressions reuse value along path 139 static expressions partially redundant computations next column preventedcmp reports percentage optimizable expressions whose complete optimization code motion prevented cmp region codemotion pre fail fully optimize 305 optimizable expressions comparison column preventedpoe reports expressions require restructuring poepre experiment 2 loop invariant expressions next determined percentage loop invariant li expressions removed invariant loops code motion column loop invar shows percentage optimizable expressions pass test loopinvariance following column gives percentage li expressions cmp region average 725 li computations cannot hoisted enclosing invariant loops without restructuring experiment 3 eliminated computations column global cse reports dynamic amount computations removed global common subexpression elimination corresponds full redundancies column complete pre gives dynamic amount partially redundant statements fact strictly partial redundancies contribute 17 difference complete pre global cse may due style impact intermediate code eg multiple virtual registers variable expect powerful redundancy analysis perform better figure 8 plots dynamic amount strictly partial redundancies removed various pre tech niques codemotion pre yields half benefit complete pre furthermore speculation results nearcomplete pre benchmarks even without special hardware support ie safe speculation speculation carried cmp whole note graph accounts dynamic impairment caused speculation benchmark program size e1 cm prevented e2 loop inv e3 dynamic e4 code growth spec95int spec95fp procedures nodes k expressions space optimizable preventedcmp preventedpoe loop invar invarprevent global complete compre increase poepre increase 099go 372 1536 373 58 102 296 454 71 834 95 117 499 902 126gcc 1661 9172 1582 380 80 342 450 25 698 37 46 339 367 129compress 130li 357 374 84 20 118 224 344 104 699 68 80 215 351 132ijpeg 472 818 228 12 139 241 453 51 781 43 51 488 1047 134perl 276 1350 255 404 96 395 518 119 935 48 68 312 500 147vortex 923 3259 657 58 166 295 361 63 816 111 130 357 554 avg spec95int 5421 2167 420 122 121 291 434 82 750 74 91 333 565 103su2cor 37 106 39 25 153 298 538 145 437 128 130 421 1420 104hydro2d 43 85 24 04 168 217 427 59 417 19 60 439 1417 145fpppp 37 136 67 196 146 522 577 430 919 71 77 24 182 146wave5 110 333 123 53 124 348 478 49 662 71 78 366 1076 avg spec95fp 392 114 44 47 162 324 498 153 692 83 100 943 3130 avg spec95 3266 1287 259 90 139 305 461 113 725 78 95 595 1664 table 1 experience pre based control flow restructuring go compress li ijpeg perl vortex avgint tomcatv swim su2cor hydro2d fpppp wave5 avgfp avg103050 dynamic computations eliminated codemotion pre safe speculative pre unsafe speculative pre complete pre figure 8 benefit various pre algorithms dynamic op count decrease due strictly partial redundancies algorithm also completely removes full redundancies measurements indicate ideal pre algorithm integrate speculation restructuring using restructuring speculation would waste large portion benefit provide almost complete pre small code growth experiment 4 code growth finally compare code growth incurred compre poepre make experiment feasible limited procedure size 3000 nodes made comparison procedures exceed limit either algorithm overall compre created three times less code growth poepre 5 demanddriven frequency analysis amenable bitvector representation frequency analysis 28 expensive component profileguided opti mizers shown compre allows restricting scope frequency analysis within cmp region without loss accuracy however large cmp regions cost may remain high path profiles cannot used efficient substitute numerous hot paths fall region one method reduce cost frequency analysis computing demand subset data flow solution needed optimization section develop demanddriven frequency analyzer reduces dataflow analysis time examining nodes contribute solution option ally b terminating analysis prematurely solution determined desired precision besides pre analyzer suitable optimizations acceptable running time must maintained restricting analysis scope runtime optimizations 5 interprocedural branch removal 10 frequency analysis computes probability dataflow fact occur execution therefore probability lattice infinite chain real numbers existing demanddriven analysis frameworks built iterative approaches permit lattices finite size 18 finite height 23 30 hence cannot derive frequency analyzer overcome limitation designing demanddriven analyzer based upon elimination dataflow methods 29 whose time complexity independent lattice shape developed demanddriven analysis framework motivated allencocke interval elimination solver 2 next using framework demanddriven algorithm general frequency dataflow analysis derived 8 present frequency solver specialized problem availability definitions assume forward dataflow problem specified equation system vector n solution node n variable n denotes fact associated expression e equation system induces dependence graph eg whose nodes variables x e n edges represent flow functions edge exists value x e n computed x predn graph eg called exploded graph 23 data flow problems underlying compre separable hence x e depends x e valuebased pre 9 constant propagation 30 branch correlation analysis 10 edges e may exist complicating analysis analyzer presented handles general exploded graphs requirements demanddriven analyzer grew four specific design requirements 1 demanddriven rather computing xn node n determine desired x e n ie solution expression e node n analysis speedup obtained requiring nodes transitively contributing value x e n visited examined guarantee worstcase behavior solutions eg nodes desired solvers time complexity exceed exhaustive allencocke method 2 n number eg nodes 2 latticeindependent amount work per node depend lattice size eg shape 3 online analysis possible even eg completely known prior analysis save time memory algorithm constructs eg analysis progresses central idea ondemand construction determine flow function f e target variable x e n known contribute desired solution furthermore solver must produce solution even eg irreducible happen even underlying cfg reducible 4 informed course frequency analysis contribution weight examined node desired solution must known information used develop version analyzer approximates frequency disregarding lowcontribution nodes goal restricting analysis scope exhaustive interval dataflow analysis 2 computes xn n follows first loop headers identified partition graph hierarchic acyclic subregions called intervals second forward substitution equations performed within interval express node solution terms loop header substitution proceeds interval order reverse postorder node visited third mutual equation dependences across loop backedges reduced loop breaking rule l second third step remove cyclic dependences innermost loops eg repeated nesting levels processed solutions expressed terms start node propagated previously reduced equations final propagation phase 2 demanddriven interval analysis substitutes equations reduces intervals desired x e n transitively dependent find relevant equations backsubstitute equations flow functions righthand side x e n along eg edges edges added exploded graph online whenever new eg node visited first computing flow function node inserting predecessors graph 2 define eg interval set nodes dominated sink backedge irreducible eg backedge loop edge sinking onto loop entry node eg shape known prior analysis online identification eg intervals relies structure underlying control flow graph cfg node eg node x cfg loop entry x may eg loop entry conservatively assume interval head within interval backsubstitutions performed reversed interval order order provides latticeindependence equation needs substituted per interval reduction reductions find interval order incomplete eg observe within eg interval order consistent reverse postorder cfg node numbering loopbreak cyclic dependencies along interval back edge loop reduced continue preceding interval recursively invoking reductions nested loops process achieves demand analysis relevant intervals desired solution obtained x e n expressed exclusively using constant terms point also identified eg subgraph contributes x e n removed cyclic dependences forward substitution subgraph yield solutions subgraph nodes cached case later desired worstcase running time step corresponds propagation phase 2 caching 18 30 framework instance calculates probability expression e available exit node n execution x e denote probability edge taken given sink node executed relate edge probability sink rather source exhaustive analysis 28 demand solver proceeds backward direction frequency flow function returns probability 1 node computes expression e 0 kills ex pression otherwise sum probabilities predecessors weighted edge execution probabilities returned predicates comp transp defined figure 3 10 compn e transpn e 00 transpn e pm nx e otherwise demand frequency analyzer shown figure 9 two data structures used sol accumulates constant terms desired probability x e rhs current righthand side x e n backsubstitutions variables sol rhs organized stack top used currently analyzed interval algorithm treats rhs symbolic expression working set pending nodes yet unsubstituted variables precise example value rhs may 025 m04 k weights contributions nodes k desired probability x e n e never available available k probability 05 available node n probability 025 004 formally contribution weight node represents probability path node n without computation kill expression e executed first rhs set 10 n line 1 flow functions backsubstituted rhs postorder line 3 substitutions repeated variables replaced constants line 2 accumulated sol substituted node x computes expression e weight rhsx added solution x removed rhs assignment rhsx 00 line 6 simple case x loop entry node line 12 contribution c added predecessors contribution weighted edge probability p x loop entry node line 8 continuing loop predecessor selfdependences x found call reduce loop procedure reduce loop mimics main loop lines 1 pushes new entries stacks initiate reduction new interval also marks loop entry node stop backsubstitution collected cyclic dependences along cyclic paths backedge edge x result reduce loop returned solrhs pair r constant r set unresolved vari ables eg 01 eg reducible set r contains x value 03 weight xs selfdependence removed loop breaking rule derived frequency analysis sum infinite geometric sequence lines 1011 algorithm terminates stack visited line 14 specifies order forward substitution performed cache results also shown figure 9 execution trace demanddriven analysis computes probability expression computed nodes f h killed available node c paths availability holds highlighted approximate dataflow analysis often necessary sacrifice precision analysis speed define notion approximate data flow information allows analyzer predetermined degree conservative imprecision example given 5 imprecision level 005 analyzer may output available 07 maximal fixed point solution available 075 intention permitting underestimation reduce analysis cost analyzer certain contribution node incoming paths overall solution less imprecision level avoid analyzing paths assume node conservative dataflow fact algorithm figure 9 designed informed naturally extends approximate analysis knowing precise contribution weight node analysis progresses whenever sum weights rhs highest interval level falls ffl whilecondition line 2 terminate guarantee desired pre cision alternative scenario attractive however lowweight node selected line 3 throw away keep disregarding nodes total weights exceed ffl essence approach performs analysis along hot paths 4 online region formation 21 idea terminating analysis could find precise solution first applied implementation interprocedural branch elimination 10 stopping visiting thousand nodes resulted two magnitudes analysis speedup optimization opportunities still discovered however without approximate frequency analyzer developed paper unable determine benefit restructuring b select profitable subset nodes duplicate c get bound amount opportunities lost due early termination algorithm complexity arbitrary exploded graph reduce loop may recursively invoked node hence node may visited ne times number eg nodes n number cfg nodes number optimized expressions caching results node processed one invocation algorithm figure 9 yielding worstcase time complexity 2 real programs loop nesting level bound small con stant expected complexity ns 2 although existing demanddriven dataflow algorithms 18 23 30 particular viewed like operate principle backsubstituting flow functions righthand side target variable focus specifying profitable order substitutions unlike rely instead finding fixed point eratively approach fails infiniteheight lattices cfg loops keep always iterating towards better approximation solution note breaking control flow cycle inserting widening operator 13 appear resolve problem widening local adjustment primarily intended approximate solution therefore frequency analysis many iterations would required achieve acceptable approximation instead fixing equation system locally global approach structurally identifying intervals reducing cyclic dependences seems necessary shown identify intervals perform substitutions interval order demand even exploded graph known prior analysis believe existing demand methods extended operate structural manner enabling application loopbreaking rules would make methods reminiscent elimination algorithms 29 6 conclusion related work focus paper improve program transformations constitute valuereuse optimizations commonly known partial redundancy elimination pre long history pre research implementation three distinct transformations identified seminal paper morel renviose 27 derivations 11 14 15 16 17 25 employ pure nonspeculative code motion second complete pre steffen 31 based control flow restructuring third navigated path profile information gupta et al apply speculative code motion order avoid codemotion obstacles controlled impairment paths 20 work defined codemotionpreventing cmp region cfg subgraph localizing adverse effects control flow desired value reuse notion cmp applied enhance integrate three existing pre transformations following ways 1 code motion restructuring integrated remove redundancies minimal code growth cost compre 2 morel renvioses original method expressed restricted motiononly case complete algorithm cmpre 3 develop algorithm whose power adjusts contin input node n expression e output sol probability e available exit n stack reals names sol rhs refer always top stack stack sets unsubstituted nodes n weights rhs n postorder numbering cfg nodes rhs empty 3 select rhs node x smallest postdfsx 5 end procedure substitutenode x x visited determine flow function x computes kills e adjust sol remove x rhs compx e transpx e 7 else transpn e rhs x 00 return backedge edge meets loopentry edge 8 backedge x exists assume one backedge per node substitute x occurs rhs 9 r reduce loopy x apply loop breaking rule sum infinite geom sequence substitute acyclic predecessors nonbackedge node z 2 predx end x fully substituted 14 rhs x 00 visitedpushx substitute function reduce loopnode u node v rhs contains unmarked nodes 17 select rhs unmarked node x lowest postdfsx 19 end reduce loop f postdfs h g 9 reduce loope b 14 rhs 0391 7 sol 02818 unchanged final probability 7 rhs 00 figure 9 demanddriven frequency analysis availability computations trace execution ually motiononly complete pre response program profile pgpre 4 demonstrate speculation navigated precisely edge profiles alone 5 path profiles used integrate three transformations balance power level cmp paths pre significantly improved effective program transformations presented paper large orthogonal potential lies detecting redundancies techniques used powerful analysis uncover value reuse traditional pre analysis 9 11 however using code motion fail completely exploit additional reuse opportunities thus transformations presented applicable styles pre well example elimination loads ammons larus 4 developed constant propagation optimization based restructuring namely peeling hot paths analysistransformation framework restructuring used exploit optimization opportunities previously detected analysis case also improve analysis precision eliminating control flow merges hot paths even though pre cannot benefit hot path separation distributive dataflow analysis preserves reuse opportunities across merges complicated analysis eg redundancy array bound checks would improved approach analysis algorithm recombines separated paths present useful opportunities likely path recombination integrated code motion presented paper reduce code growth global view identified four main issues pathsensitive program optimizations 8 solving nondistributive problems without conservative approximation eg nonlinear constant propagation b collecting distinct opportunities eg variable different constant along path c exploiting distinct opportunities eg enabling folding pathdependent constants structuring directing analysis effort towards hot paths approach ammons larus four issues attacked uniformly separation hot paths subsequent individual analysis recombination approach reserve restructuring actual transforma tion implies different overall strategy solve nondistributive problems precisely along paths customizing dataflow name space 9 b collect distinct opportunities demanddriven analysis branch elimination 10 form constant propa gation c exploit profitable opportunities economical transformations avoid infrequent program regions using approximation frequency analysis last three presented paper acknowledgments indebted elcor impact compiler teams providing experimental infrastructure sadun anik benchung cheng brian dietrich john gyllenhaal scott mahlke provided invaluable help implementation experiments comments glenn mons evelyn duesterwald jim larus mooly sagiv bernhard steffen anonymous reviewers helped improve presentation paper research partially supported nsf pyi award ccr9157371 nsf grant ccr9402226 grant hewlettpackard university pittsburgh r compilers principles program data flow analysis procedure exploiting hardware performance counters flow context sensitive profiling improving dataflow analysis path profiles aggressive inlining efficient path profiling effective partial redundancy elimination new algorithm partial redundancy elimination based ssa form abstract intrepretation unified lattice model static analysis programs construction approximation fixpoints analyze large programs efficiently infor matively practical adaptation global optimization algorithm morel renvoise global optimization suppression partial redundancies variation knoop practical framework demanddriven interprocedural data flow analysis path profile guided partial redundancy elimination using speculation partial redundancy elimination based costbenefit analysis demand interprocedural dataflow analysis controlled node split ting optimal code motion theory practice sentinel scheduling vliw superscalar processors global optimization supression partial redundancies data flow frequency analysis elimination algorithms data flow analysis precise interprocedural dataflow analysis applications constant propagation property oriented expansion tr compilers principles techniques tools elimination algorithms data flow analysis analyze large programs efficiently informatively variation knoop rumyampersandumlthing steffens italiclazy code motionitalic sentinel scheduling effective partial redundancy elimination optimal code motion solution problem morel renvoises myampersandldquoglobal optimization suppression partial redundanciesmyampersandrdquo practical adaption global optimization algorithm morel renvoise demand interprocedural dataflow analysis regionbased compilation fast effective dynamic compilation data flow frequency analysis precise interprocedural dataflow analysis applications constant propagation efficient path profiling exploiting hardware performance counters flow context sensitive profiling aggressive inlining interprocedural conditional branch elimination new algorithm partial redundancy elimination based ssa form resourcesensitive profiledirected data flow analysis code optimization pathsensitive valueflow analysis practical framework demanddriven interprocedural data flow analysis improving dataflow analysis path profiles global optimization suppression partial redundancies program data flow analysis procedure abstract interpretation propertyoriented expansion controlled node splitting path profile guided partial redundancy elimination using speculation ctr daniel connors wenmei w hwu compilerdirected dynamic computation reuse rationale initial results proceedings 32nd annual acmieee international symposium microarchitecture p158169 november 1618 1999 haifa israel jin lin tong chen weichung hsu penchung yew roy dzching ju tinfook ngai sun chan compiler framework speculative optimizations acm transactions architecture code optimization taco v1 n3 p247271 september 2004 zhang rajiv gupta whole execution traces proceedings 37th annual ieeeacm international symposium microarchitecture p105116 december 0408 2004 portland oregon bernhard scholz nigel horspool jens knoop optimizing space time usage speculative partial redundancy elimination acm sigplan notices v39 n7 july 2004 rei odaira kei hiraki sentinel pre hoisting beyond exception dependency dynamic deoptimization proceedings international symposium code generation optimization p328338 march 2023 2005 timothy heil james e smith relational profiling enabling threadlevel parallelism virtual machines proceedings 33rd annual acmieee international symposium microarchitecture p281290 december 2000 monterey california united states david gregg andrew beatty kevin casey brain davis andy nisbet case virtual register machines science computer programming v57 n3 p319338 september 2005 dhananjay dhamdhere epathpre partial redundancy elimination made easy acm sigplan notices v37 n8 august 2002 eduard mehofer bernhard scholz probabilistic data flow system twoedge profiling acm sigplan notices v35 n7 p6572 july 2000 jin lin tong chen weichung hsu penchung yew roy dzching ju tinfook ngai sun chan compiler framework speculative analysis optimizations acm sigplan notices v38 n5 may spyridon triantafyllis matthew j bridges easwaran raman guilherme ottoni david august framework unrestricted wholeprogram optimization acm sigplan notices v41 n6 june 2006 max hailperin costoptimal code motion acm transactions programming languages systems toplas v20 n6 p12971322 nov 1998 ran shaham elliot k kolodner mooly sagiv heap profiling spaceefficient java acm sigplan notices v36 n5 p104113 may 2001 reinhard von hanxleden ken kennedy balanced code placement framework acm transactions programming languages systems toplas v22 n5 p816860 sept 2000 jingling xue qiong cai lifetime optimal algorithm speculative pre acm transactions architecture code optimization taco v3 n2 p115155 june 2006 zhang rajiv gupta whole execution traces applications acm transactions architecture code optimization taco v2 n3 p301334 september 2005 uday p khedker dhananjay dhamdhere bidirectional data flow analysis myths reality acm sigplan notices v34 n6 june 1999 keith cooper li xu efficient static analysis algorithm detect redundant memory operations acm sigplan notices v38 n2 supplement p97107 february keith cooper l taylor simpson christopher vick operator strength reduction acm transactions programming languages systems toplas v23 n5 p603625 september 2001 eliminating array bounds checks demand acm sigplan notices v35 n5 p321333 may 2000 litong song krishna kavi gain unfolding loops acm sigplan notices v39 n2 february 2004 glenn ammons james r larus improving dataflow analysis path profiles acm sigplan notices v33 n5 p7284 may 1998 phung hua nguyen jingling xue strength reduction loopinvariant types proceedings 27th australasian conference computer science p213222 january 01 2004 dunedin new zealand youtao zhang rajiv gupta timestamped whole program path representation applications acm sigplan notices v36 n5 p180190 may 2001 k v seshu kumar value reuse optimization reuse evaluated math library function calls compiler generated cache acm sigplan notices v38 n8 august sriraman tallam xiangyu zhang rajiv gupta extending path profiling across loop backedges procedure boundaries proceedings international symposium code generation optimization feedbackdirected runtime optimization p251 march 2024 2004 palo alto california qiong cai jingling xue optimal efficient speculationbased partial redundancy elimination proceedings international symposium code generation optimization feedbackdirected runtime optimization march 2326 2003 san francisco california mary lou soffa loadreuse analysis design evaluation acm sigplan notices v34 n5 p6476 may 1999 matthew arnold michael hind barbara g ryder online feedbackdirected optimization java acm sigplan notices v37 n11 november 2002 glenn ammons james r larus improving dataflow analysis path profiles acm sigplan notices v39 n4 april 2004 motohiro kawahito hideaki komatsu toshio nakatani partial redundancy elimination access expressions speculative code motion softwarepractice experience v34 n11 p10651090 september 2004
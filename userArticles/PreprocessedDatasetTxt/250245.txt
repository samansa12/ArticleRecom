recent developments highlevel synthesis survey recent developments high level synthesis technology vlsi design need higherlevel design automation tools discussed first describe basic techniques various subtasks highlevel synthesis techniques proposed past years since 1994 various subtasks highlevel synthesis surveyed also survey new synthesis objectives including testability power efficiency reliability b introduction large scale integrated circuits vlsi technology provides densities multiple million gates random logic per chip chips complexity difficult impossible design using traditional captureandsimulate design methodology furthermore vlsi technology also reached maturity level well understood longer provides competitive edge instead time market usually equally important area speed industry started looking product development cycle comprehensively reduce design time gain competitive edge time tomarket race automation entire design process conceptualization silicon describeandsynthesize design methodology become necessary 20 complexities chips increase need design automation higher levels abstraction functionality easier understand tradeoff influ ential several advantages automating part design process moving automation higher levels first automation assures much shorter design cycle second allows exploration different design styles since different designs generated evaluated quickly finally synthesis algorithms well understood design automation tools may outperform average human designers meeting design constraints requirements synthesis translation process behavioral description structural descrip tion similar compilation high level language program c pascal assembly program component structural description turn defined lower level behavioral description synthesis sometimes called design refinement adds additional level detail provides information needed next level synthesis manufacturing design detailed design must satisfy design constraints supplied along original behavioral description generated previous synthesis step define high level synthesis hls translation process behavioral description registertransfer level rtl structural description high level synthesis hot research topic past fifteen years comprehensive discussions specific research approaches hls found 6 20 63 96 concentrate development past three years rest paper organized follows section 2 describes design flow vlsi hls used section 3 outlines tasks basic techniques section 4 several new target architectures hls surveyed advance algorithmic techniques described section 5 section 6 survey new objective functions recent hls systems trying optimize section 7 describes applications hls finally section 8 speculates future directions hls design flow using hls behavioral description used starting point hls specifies behavior terms operations assignment statements control control constructs hardware description language hdl eg vhdl 37 verilog 90 hdl differs software programming language eg c pascal capability expressing timing concurrency hardware output high level synthesizer consists two parts datapath structure registertransfer level rtl specification finite state machine control datapath rtl level datapath composed three types components functional unitseg alus multipliers shifters storage unitseg registers memory interconnection unitseg busses multiplexors finite state machine specifies every set microoperations datapath perform every control step first step hls behavioral description compiled internal repre sentation process usually includes series compilerlike optimizations code motion dead code elimination constant propagation common subexpression elimination loop unrolling addition may also apply hardwarespecific transformations syntactic variances minimization retiming taking advantage associativity commutativity properties certain operations controldata flow graph cdfg commonly used internal representation capture behavior controlflow graph cfg portion cdfg captures sequencing conditional branching looping constructs behavioral description dataflow graph dfg portion captures datamanipulation activity described set assignment statements opera tions following three steps form core transforming behavior structure scheduling allocation binding scheduling assigns operations behavioral description control steps control step usually corresponds cycle system clock basic time unit synchronous digital system allocation chooses functional units storage elements component library may several alternatives among synthesizer must select one best matches design constraints maximizes optimization objective binding assigns operations functional units variables storage elements data transfers wires buses data correctly moved around according scheduling three tasks closely interdependent one another example optimal scheduling operations control steps without explicit performance cost information component allocation impossible similarly optimal allocation components cannot performed without exact information operation concurrency furthermore exists performancecost tradeoff applying tasks example area efficient design consists minimum number slow components larger number control steps required execute desired function hand allocating components allows exploiting parallel executions operations higher performance achieved expense higher area cost adjusting constraint parameters design space explored one primary application hls helping designers exploring design space hence evaluating multiple implementation alternatives quickly 3 basic techniques given cdfg perform scheduling allocation binding get datapath byproduct tasks specification behavior controlling finite state machine section survey basic techniques scheduling allocation binding 31 scheduling scheduling assigns operations behavioral description control steps within control step separate functional unit required execute operation assigned step thus total number functional units required control step directly corresponds number operations scheduled operations scheduled control step functional units necessary results fewer control steps design implementation hand fewer operations scheduled control step fewer functional units sufficient control steps needed thus scheduling important task hls largely determines tradeoff design cost performance two classes scheduling problems timeconstrained scheduling resourceconstrained scheduling timeconstrained scheduling minimizes hardware cost operations scheduled fixed number control steps hand resourceconstrained scheduling minimizes number control steps needed executing operations given fixed amount hardware integer linear programming ilp formulations resourceconstrained scheduling timeconstrained scheduling 36 proposed however execution time algorithm grows exponentially number variables number inequalities practice ilp approach applicable small problems nevertheless ilp approach made problems better understood since ilp method impractical large designs heuristic methods run efficiently expense design optimality developed heuristic scheduling algorithms usually uses two techniques constructive approach iterative refinement many approaches constructive scheduling differ selection criteria used choose next operation scheduled simplest constructive approach soon possible asap scheduling first operations sorted list according topological order operations taken list one time placed earliest possible control step simple approach late possible alap scheduling alap value operation defines latest control step operation possibly scheduled approach given time constraint terms number control steps algorithm determines latest possible control step operation must begin execution critical paths within flow graph found taking intersection asap alap schedules operations appear control steps schedules critical paths asap alap scheduling priority given operations critical path operations may mistakenly delayed resources limits imposed scheduling list scheduling overcomes problem using global criterion selecting next operation scheduled one example global priority function mobility 70 defined difference asap asap values operation example urgency 22 defined minimum number control steps bottom operation scheduled timing constraint violated list scheduling list ready operations ordered according priority function processed state forcedirected scheduling fds 72 another example uses global selection criteria choose next operation scheduling fds algorithm relies asap alap scheduling algorithms determine range control steps every operation distribution graphs created represent probabilistic number operations performed control step type operation control step main goal fds algorithm reduce total number functional units used implementation design algorithm achieves objective uniformly distributing operations type available states call algorithms similar fds constructive construct solution without performing backtracking decision schedule operation control step made basis partially scheduled dfg take account future scheduling operations control step due lack lookahead scheme lack compromises early late decisions resulting solution may optimal cope weakness iteratively rescheduling operations given schedule one example approach proposed 73 based paradigm originally proposed graphbisection problem kernighan lin kl 41 approach initial schedule obtained using scheduling algorithm new schedules obtained rescheduling sequence operations maximally reduces scheduling cost improvement attainable process halts preceding discussions blocks straight line code considered ever addition blocks straight line code realistic design description usually contains conditional loop constructs many approaches 43 99 proposed schedule conditional constructs example 99 conditional vector used identify mutually exclusive operations operation scheduled different control steps different execution instances another approach pathbased fast possible afap scheduling 5 first extracts possible execution paths given behavior schedules independently schedules different paths combined resolving conflicts among execution paths loop constructs different approaches pipelining 71 loop folding 23 proposed 32 allocation binding scheduling datapath constructed two steps unit allocation unit binding researchers call unit allocation unit binding collectively datapath allocation unit allocation determines number types rt components used design since real rt component library may contain multiple types functional units different characteristics eg functionality size delay power dissipation unit allocation needs determine number types different functional storage units component library unit binding maps operations variables data transfers scheduled cdfg functional storage interconnection units respectively ensuring design behavior operates correctly selected set components unit binding consists three interdependent tasks functionalunit binding storage binding interconnection binding functionalunit binding involves mapping operations behavioral description set selected functional units storage binding maps data carriers eg constants variables data structures like arrays behavioral description onto storage elements eg roms registers memory units datapath interconnection binding maps every data transfer behavior set interconnection units data routing three approaches solve allocation problem constructive approaches progressively construct design traversing cdfg decomposition approach es decompose allocation problem constituent parts solve separately iterative methods try combine interleave solution allocation subproblems constructive approach starts empty datapath builds datapath gradually adding functional storage interconnection units necessary example emucs 33 mabal 46 use global criterion based functional storage interconnection costs determine next element assign assign although constructive algorithms simple solutions find far optimal order improve quality results researchers proposed decomposition approach allocation process divided sequence independent tasks task transformed welldefined graphtheoretical problem solved proven technique following describe allocation techniques based three graphtheoretical methods clique partitioning leftedge algorithm weighted bipartite matching algorithm tseng siewiorek 92 divided allocation problem three tasks storage functionalunit interconnection allocation solved independently mapping task well known problem graph cliquepartitioning graph formulation operations values interconnections represented nodes edge two nodes indicates two nodes share hardware thus allocation problem storage allocation solved finding minimal number cliques graph finding minimal number cliques graph nphard problem 92 heuristic approach taken although cliquepartitioning method applied storage allocation minimize storage requirements totally ignores interdependence storage interconnection allocation paulin knight 72 extend previous method augmenting graph edges weights reflect impact interconnection complexity due register sharing among variables kurdahi parker apply leftedge algorithm 45 solve registerallocation problem unlike cliquepartitioning problem npcomplete leftedge algorithm polynomial time complexity moreover algorithm allocates minimum number registers however cannot take account impact register allocation interconnection cost weighted version cliquepartitioning algorithm register functionalunit allocation problems also transformed weighted bipartitematching algorithm 30 approach bipartite graph first created contains two disjoint subsets eg one subset registers one variables one subset operations one functional units edge connects two nodes different subsets represents node one subset assigned node subset eg variable variable subset assigned register register subset thus problem matching variable register equivalent classic jobassignment problem 30 polynomial time maximum weight matching algorithm employed solve problem matching algorithm like leftedge algorithm allocates minimum number registers also takes partially consideration impact register allocation interconnection allocation since associate weights edges given datapath synthesized constructive decomposition methods improvement may achieved reallocation iterative refinement approach straightforward approach could simple assignment exchange using pairwise exchange simulated annealing method addition sophisticated branchandbound method applied reallocating group different types entities datapath refinement 91 41 multiport memory multiport memory support multiple read andor write accesses simultaneously using multiport memory gives hls flexibility binding variables storages tradition ally variables grouped registers registers register filesmemory modules synthesizing interconnection memory modules functional units kim proposed placing emphasis interconnection try minimize interconnection first group variables form memory modules later lee hwang 52 proposed taking multiport memory account early scheduling defined multiport access variable mav control step let scheduling algorithm equalizes mavs across control steps order achieve better utilization memory 42 distributed storage traditional hls systems targeted towards centralized storage units every operation must access input operands write output operands storage units regular iterative algorithms architecture may optimal aloqeely chen 3 proposed sequencerbased datapath architecture sequencer stack queue connecting one functional unit another letting variables intelligently stay flow sequencers datapath future use high quality datapath synthesized many signal processing matrix computation algorithms furthermore less traffic needed functional units central storage units resulting simple interconnection complexity similar concept called data routing proposed hls code generation 48 43 partitioned bus ewering 16 proposed parameterized architecture called partitioned busses busses partitioned segments functional unit storage unit connected one segment data transfers occur within segment intersegment transfers made possible switches segments since loading bus light synthesized circuit fast scheduling allocation done amount intersegment data transfer minimized quite significant advance hls algorithms heuristics various methods proposed transforming cdfg highquality circuit easier synthesize several groups extended ilp formulation general scheduling problem capability handling large designs problems besides scheduling algorithms originally developed problems employed hls several groups proposed various neural network models various hls tasks solution techniques getting powerful longer necessary divide synthesis problem multiple subtasks notable development performing tasks together single task order achieve better quality design 51 behavioral transformation transformations applied design representation various stages hls compilation input behavioral description controldata flow graph several compilerlike optimizations performed remove extraneous syntactic constructs redundancies flowgraph transformations used convert parts representation one style eg control flow another eg data flow change degree parallelism hardwarespecific transformations use properties registertransfer rt logic components perform optimizations eg replacing dataflow graph segment increments variable increment operation since flowgraph representation typically comes imperative language de scription several standard compiler optimization techniques constant folding redundant operator elimination performed representation 2 arrayed variables another rich source compiler level optimizations hls 24 68 since arrays behavioral representation get mapped memories reduction number array accesses decreases overhead resulting accessing memory structures 42 certain compiler transformations specific hdl used describing design example vhdl used design description several approaches proposed 4 identify specific syntactic constructs replace attributes signals nets indicate functions furthermore order reduce syntactic variation descriptions semantic chaiyakul et al 8 proposed transformation technique using assignment decision diagrams add minimize syntactic variance description graph capturing behavior restructured tree height reduction one commonly used flowgraph transformations improve parallelism design tree height reduction uses commutativity distributivity properties language operators decrease height long expression chain exposes potential parallelism within complicated dataflow graph 31 67 pipelining another frequently applied transformation hls 71 commonly used transformations include loop folding 23 88 software pipelining 26 77 retiming hardwarespecific transformations logic rt system levels applied intermediate representation general local transformations use properties hardware different design levels optimize intermediate representation example logic level apply local boolean optimization techniques 13 intermediate representation rt level use pattern matching detect replace portions flow graph simpler flowgraph segments pattern matching transformations based rt semantics hardware components corresponding flowgraph operators 85 system level transformations used divide parts flow graph separate processes run concurrently pipelined fashion 98 52 advance ilp formulation achatz 1 proposed extension ilp formulation handle multifunctional units well units different execution times different instances operation type wang grainger 97 showed number constraints original ilp formulation reduced without reducing explored design space therefore computation efficient formulation applicable larger sized problems chaudhuri et al 10 performed indepth formal analysis structure assign ment timing resource constraints evaluated structure scheduling polytope described constraints showed exploit structure welldesigned ilp formulation also proposed improve wellstructured formulation adding new valid inequalities oscar system 50 01 integer programming model proposed solving scheduling allocation binding together gebotys 21 proposed integer programming model synthesis multichip architecture model simultaneously deals partitioning scheduling allocation search space reduced using polyhedral theory wilson et al 95 generalized ilp approach integrated solution scheduling allocation binding datapath synthesis module may execute arbitrary combination operations possibly using different number control steps different type operations operations may bounded variety modules possibly requiring different number control steps depending module chosen 53 new approaches ly et al 49 proposed idea behavioral templates scheduling template locks number operations relative schedule respect one another eases handling timing constraints sequential operation modeling prechaining certain operations hierarchical scheduling many neural net based scheduling algorithms proposed ansa 93 threephase neural network scheduler kawaguchi tokada 40 combined simulated annealing neural networks scheduling problem genetic algorithms also find application high level synthesis dhodhi et al 12 proposed problemspace genetic algorithmpsga datapath synthesis performs concurrent scheduling allocation objective minimizing cost function hardware resource total execution time heijligers et al 32s genetic algorithm uses encoding technique capable allocating supplementary resources scheduling also paid attention runtime efficiency means carefullydesigned analyzing methods ly mowchenko 56 proposed adapting simulated evolution high level synthesis simulated evolution successfully applied cad areas including routing par titioning placement sebased synthesis explores design space repeatedly ripping parts design probabilistic manner reconstructing using applicationspecific heuristics combines rapid design iterations probabilistic hill climbing achieve effective design space exploration objects subject ripping reconstruction operationtostep assignments various binding insyn 87 combines allocation scheduling functional storage interconnect units single phase uses concept register state free busy undecided optimizing registers partial schedule lifetimes data values yet available alleviates bus contention using reusable data values broadcast selectively slowing noncritical operations insyn trade distinct resource sets concurrently ie trade functional unit registers vice versa estimation tools utilized resource allocation design space pruning evaluation synthesized results 6 advance objective function 61 accurate estimation traditional hls systems characterize synthesis results based crude estimation area estimated sum area functional units storage units intercon nects timing estimated assuming wiring delay insignificant moving deep submicron era wiring area timing longer ignorable many estimation methods proposed moreover interaction hls layout rim jain 84 proposed performance estimation tool given data flow graph set resources resource delay clock cycle tool computes lowerbound completion time nonpipelined resourceconstrained scheduling problems chaudhuri walker 9 proposed algorithm computing lower bounds number functional units type required schedule data flow graph specified number control steps bounds found relaxing either precedence constraints integraty constraints scheduling problem bounding method used estimate fu area generate resource constraints reducing search space conjunction exact formulation design space exploration mecha et al 57 proposed high level area estimation method targeted towards standard cell implementation emphasized predicting interconnection area fang wong 17 proposed simultaneously performing functional unit binding floorplanning munch et al 66 proposed analytical approach capture placement binding problems single mixed ilp model targeted towards linear bitslice architecture model capable minimizing overall interconnect structure datapath 62 hls testability testability high level enhanced minimizing number selfloops self adjacent registers main concern tradeoff testability improvement area overhead since multiplexors buses behave switches help reducing test costs gupta breuer 27 proposed taking advantages multiplexors buses reduce area overhead test generation costs analyzed locations switches selection partial scan registers also utilized switches setup paths transporting test data flottes et al 18 proposed method improve testability incorporating test constraints register allocation interconnect network generation analyze testability design behavioral level presence loops control constructs dhodhi et al 14 proposed problemspace genetic algorithm psga performing simultaneously scheduling allocation testable functional units registers area performance testability constraints mujumdar et al 65 proposed twostage approach binding testability first used binder test cost generate nearly loopfree design used loopbreaking method identify selfloops design eliminate loops alternating register module binding et al 75 proposed methods transforming behavioral description synthesis new description requires less area overhead partial scan cost proposed twostage objective function estimating area testability well evaluating effects transformation used randomized branchandbound steepest decent algorithm search best sequence transformations testability improved via better controller design hsu rudnick patel 34 propose controllability measure high level circuit description high level synthesis fortestability technique improve circuit testability enhancing controllability control flow 63 hls low power due low power requirement many portable applications notebook mobile phone well packaging cost consideration low power design technology becoming important every aspect vlsi design great deal research effort spent circuit logic design low power 74 active research past years hls low power low power hls high level power estimation techniques needed raghunathan et al 79 propose techniques estimating switching activity power consumption registertransfer level take account presence glitching activity various data path control signals rabaey et al 80 propose approach high level design guidance low power using properties given algorithms architectures several relevant properties operation coun ratio critical path available time spatial locality regularity identified significant emphasis placed exploiting regularity spatial locality optimization interconnect power scheduling assignment allocation techniques 61 exploit regularity common computation patterns algorithm reduce fanins fanouts interconnection wires resulting reduced bus capacitance simplified bus structure raghunathan jha 81 proposed datapath allocation method low power also take account controllers effect datapath power dissipation goodby et al 25 proposed achieving low power via pipelining module selection musoll cortadella 64 proposed scheduling resourcebinding algorithm reducing activity function units minimizing transitions input operands kumar et al 38 measure activities operations carriers behavioral specification simulating dfg usersupplied profiling stimuli select module set schedule minimize switching activity martin knight 58 applied several low power techniques behavioral synthesis including lowering supply voltage disabling clock idle components architectural tradeoff 64 hls reliability many critical applications faulttolerance important desirable system capable selfrecovery presence transient faults selfrecovering microar chitecture intermediate results compared regular intervals correct saved registers checkpoints hand detecting fault rolls back checkpoint retries orailoglu karri 69 proposed selfrecovering microarchitecture synthesis system proposed algorithm selection good checkpoints low overhead meeting constraint number clock cycles retry period selftesting carried concurrently normal operations using otherwise idle functional units singh knight 86 proposed method test hardware elements used generates circuit cycle test vectors idle hardware produce signature builtin self testing achieved reduced testtime overhead hotcarrier reliability issue also dealt high level synthesis karnik et al 39 proposed iterative redesign method improve longterm reliability given high level circuit used macromodels standard circuit elements developed using reliability simulation tool reliability improvement due capacitance reduction 65 controller issues traditionally control unit specification generated datapath synthesis com pleted recently authors observed exists tradeoff controller datapath rao kurdahi 82 proposed hierarchical approach control logic overhead taken account level hierarchy datapath fully synthesized approach suitable behavior consisting regular algo rithm huang wolf 35 studied datapath allocation affects controller delay proposed allocation approach considers controllers effect critical path delay therefore able minimize system clock length allocation 7 applications hls years hls successfully applied designs several narrow applicationspecific domains example many hls systems cathedral 55 hyper 11 phideo 54 provide design environment targeted towards digital signal processing dsp applications various levels throughput requirements contrast computational intensive dsp designs many hls systems 7 callas 53 olympus 62 targeted toward controldominated circuit designs addition hls system mimolahoneywell 101 targeted toward instruction set processor design system architects workbench cmu 89 used designs automotive applications 19 high level synthesis tool even finds use education 83 datapath synthesizer capable exploiting design space students able try different architectural decisions evaluate effectiveness recently hls used embedded system design environment typical embedded system consists offtheshelf instruction set processors memory asics application partitioned two interacting parts software instruction set processor hardware asics several approaches 15 29 developed tackle hardwaresoftware codesign problems hls tool definitely needed quickly give cost performance figures synthesized asic advent fieldprogrammable hardware field programmable gate arrays field programmable interconnect components fpics many designs implemented fpgas fast turnaround important fpga asicbased implementation using hls provides unmatchable fast turnaround time taking advantage reprogrammability fpgas fpics hardware emulation provides fast means design verification currently hardware emulators take inputs logiclevel structural description hls extensive verification performed earlier design process example 100 hls scheme used automatic mapping behavioral description onto asic emulation board custom computer hardware resources configured according characteristics application programs hls essential converting algorithm code segment fpgafpic programming bitstream 8 future directions although seen many applications hls today still indispensable layout logic synthesis high level synthesis move mainstream design practice area efficiency performance level must competitive traditional approaches possible approach embed domain knowledge synthesizer instance many dsporiented hls systems developed unfortunately approach one serious drawback domainspecific tool smaller customer base since hls development difficult complicate task small customer base may able support healthy growth deep submicron era wiring delay dominate gate delay therefore wiring delay must taken account early design process possible work dealing interaction logic synthesis layout surveyed work simultaneous allocation floorplanning future shall see interaction high level synthesis layout every step hls take layout account rapid increasing integration level must prepare deal com plicate systemonachip issues impractical design multimillion gate chips scratch therefore essential make good use existing designs successful hls tool provide smooth mechanism user reuse wide variety components also pay attention design verification although hls indeed effective reducing time synthesis quite significant portion design time spent simulation validation hls provide help date since verification higher level efficient lower level correctnesspreserving hls design flow significantly save validation time therefore give designer incentive use hls tools r extended 01 lp formulation scheduling problem high level synthesis compilers principles sequencerbased datapath synthesis regular iterative algorithms optimizer hardware synthesis pathbased scheduling synthesis high level vlsi synthesis ibm high level synthesis system high level transformation minimizing syntactic variances computing lower bounds functional units scheduling analyzing exploiting structure constraints ilp approach scheduling problem hyper interactive synthesis environment high performance real time applications datapath synthesis using problemspace genetic algorithm new look logic synthesis high level synthesis data paths easy testability hardwaresoftware codesign embedded controllers based hardware extraction automatic high level synthesis partitioned busses simultaneous functionalunit binding floorplan ning high level synthesis easy testabil ity industrial extensions university high level synthesis tools making work real world high level synthesis introduction chip system design optimization approach synthesis multichip architec tures applicability subset ada algorithmic hardware description language graphbased hardware compilation loop winding data flow approach functional pipelining address generation array access based modulus counter microarchitecture synthesis performance constrained lowpower vlsi designs efficient microcode compiler application specific dsp processors partial scan design registertransfer level circuits partitioning functional models synchronous digital systems system level synthesis using reprogrammable components data path allocation based bipartite weighted matching treeheight minimization pipelined architectures high level synthesis scheduling allocation using genetic algorithms method automatic data path synthesis enhancing highlevel controlflow improved testability datapath allocation affects controller delay formal approach scheduling problem high level synthesis standard vhdl language reference manual profiledriven behavioral synthesis lowpower vlsi systems highlevel hot carrier reliabilitydriven synthesis using macromodels operation scheduling annealed neural network efficient heuristic procedure partitioning graph integrating program transformations memorybased synthesis image video algorithms scheduling algorithm conditional resource sharing hierarchical reduction approach new approach multiport memory allocation problem datapath synthesis real program register allocation data path tradeoff using mabal chop constraintdriven system level par titioner data routing paradigm efficient datapath synthesis code generation scheduling using behavioral tem plates oscaroptimum simultaneous schedul ing allocation resource binding based integer programming architectural partitioning system level partitioner scheduling algorithm multiport memory minimization datapath synthesis siemens high level synthesis system callas phideo silicon compiler high speed algorithms architectural synthesis medium high throughput signal processing new cathedral environment applying simulated evolution high level synthe sis method area estimation data path high level synthesis powerprofiler optimizing asics power consumption behavioral level using bottomup design techniques synthesis digital hardware abstract behavioral descriptions incorporating bottomup design hardware synthesis exploiting regularity lowpower design olympus synthesis system digital design synthesis approach digital system design scheduling resource binding low power incorporating testability considerations high level synthesis optimum simultaneous placement binding bitslice architectures incremental tree height reduction high level syn thesis flow graph representation coactive scheduling checkpoint determination high level synthesis selfrecovering microarchitectures design tools intelligent silicon compilation sehwa software package synthesis pipelined behavioral specifications forcedirected scheduling behavioral synthesis asics fast near optimal scheduling automatic data path synthesis power minimization ic design principles applications synthesisfortestability using transformations optimizing resource utilization using transformation rephasing transformation technique manipulation timing constraints estimating power dissipation vlsi signal processing chip pfa technique registertransfer level estimation techniques switching activity power consumption design guidance power dimension behavioral synthesis low power controller datapath tradeoffs hierarchical rtlevel synthesis using hyper teach datapath design techniques asic design course lowerbound performance estimation high level synthesis scheduling problem optimizations high level synthesis concurrent testing high level synthesis insyn integrated scheduling dsp applications transformationbased method loop folding algorithmic registertransfer level synthesis system architects workbench verilog hardware description language data path construction refinement automatic synthesis data path digital sys tems ansa new neural net based scheduling algorithm high level synthesis specification partitioning system design ilp solution optimum scheduling module register allocation operation binding datapath synthesis survey high level synthesis reduction number equations ilp formulation scheduling problem high level synthesis behavioral transformations algorithmic level ic design resource sharing control synthesis method conditional branches high level synthesis rapidprototype environment mechantronic systems mds mimola design method tr compilers principles techniques tools optimizations high level synthesis real program register allocation data path allocation based bipartite weighted matching data path tradeoffs using mabal industrial extensions university high level synthesis tools fast near optimal scheduling automatic data path synthesis incremental tree height reduction high level synthesis highlevel synthesis specification partitioning system design highlevel synthesis rapidprototype environment mechatronic systems highlevel transformations minimizing syntactic variances integrating program transformations memorybased synthesis image video algorithms simultaneous functionalunit binding floorplanning analyzing exploiting structure constraints ilp approach scheduling problem sequencerbased data path synthesis regular iterative algorithms incorporating testability considerations highlevel synthesis oscar powerprofiler scheduling using behavioral templates rephasing partial scan design registertransfer level circuits new approach multiport memory allocation problem data path synthesis scheduling resource binding low power highlevel synthesis scheduling allocation using genetic algorithms scheduling algorithm multiport memory minimization datapath synthesis synthesisfortestability using transformations power minimization ic design computing lower bounds functional units scheduling registertransfer level estimation techniques switching activity power consumption exploiting regularity lowpower design enhancing highlevel controlflow improved testability data routing concurrent testing highlevel synthesis controller datapath tradeoffs hierarchical rtlevel synthesis datapath allocation affects controller delay verilog hardware description language 4th ed using bottomup design techniques synthesis digital hardware abstract behavioral descriptions flow graph representation synthesis approach digital system design highlevel vlsi synthesis algorithmic registertransfer level synthesis optimizer hardware synthesis olympus synthesis system profiledriven behavioral synthesis lowpower vlsi systems behavioral synthesis low power microarchitectural synthesis performanceconstrained lowpower vlsi designs highlevel synthesis easy testability method automatic data path synthesis new look logic synthesis address generation array access based modulus counters phideo ctr davide bruni alessandro bogliolo luca benini statistical design space exploration applicationspecific unit synthesis proceedings 38th conference design automation p641646 june 2001 las vegas nevada united states yoichi yuyama masao aramoto kazutoshi kobayashi hidetoshi onodera soc architecture design methodology using unifunctional heterogeneous processor array proceedings 2004 conference asia south pacific design automation electronic design solution fair p737742 january 2730 2004 yokohama japan gang wang wenrui gong brian derenzi ryan kastner design space exploration using time resource duality ant colony optimization proceedings 43rd annual conference design automation july 2428 2006 san francisco ca usa hashem hashemi najafabadi procedure obtaining behavioral description control logic nonlinear pipeline proceedings 2004 conference asia south pacific design automation electronic design solution fair p8691 january 2730 2004 yokohama japan g economakos p oikonomakos panagopoulos poulakis g papakonstantinou behavioral synthesis systemc proceedings conference design automation test europe p2125 march 2001 munich germany j ramanujam sandeep deshpande jinpyo hong mahmut kandemir heuristic clock selection highlevel synthesis proceedings 2002 conference asia south pacific design automationvlsi design p414 january 0711 2002 narasimhan j ramanujam fast approach computing exact solutions resourceconstrained scheduling problem acm transactions design automation electronic systems todaes v6 n4 p490500 october 2001 apostolos kountouris christophe wolinski hierarchical conditional dependency graphs unifying design representation codesis highlevel synthesis system proceedings 13th international symposium system synthesis september 2022 2000 madrid spain g economakos g papakonstantinou p tsanakas agenda attribute grammar driven enviornment design automation digital systems proceedings conference design automation test europe p933934 february 2326 1998 le palais des congrs de paris france c zawada n l seed p ivey continuous high coverage selftesting dynamically reconfigurable systems parallel computing v28 n78 p11551178 august 2002 apostolos kountouris christophe wolinski efficient scheduling conditional behaviors highlevel synthesis acm transactions design automation electronic systems todaes v7 n3 p380412 july 2002 alexander g dean software thread integration embedded system display applications acm transactions embedded computing systems tecs v5 n1 p116151 february 2006
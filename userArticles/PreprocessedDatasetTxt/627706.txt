timeconstrained query processing casedb abstractcasedb realtime singleuser relational prototype dbms permits specification strict time constraints relational algebra queries given time constrained nonaggregate relational algebra query fragment chain relation involved query casedb initially obtains response modified version query uses iterative query evaluation technique successively improve evaluate modified version query casedb controls risk overspending time quota step using risk control technique b introduction realtime database strict realtime timing constraints responding queries timeconstrained query form evaluate query q time units multiuser realtime dbms resources ie cpu data shared issue meeting time constraint evaluating query becomes complicated due cpu scheduling transaction management concurrency control comparison singleuser dbms satisfaction timeconstraint deal resource sharing transaction management nevertheless problem evaluating timeconstrained query singleuser dbms far trivial also solution useful multiuser dbms forcing timeconstrained query fixed cpu utilization time important parameter multiuser realtime dbmss transaction scheduling casedb realtime single user relational prototype dbms uses relational algebra ra query language earlier papers 10 11 12 presented query approximation techniques aggregate relational algebra queries result query estimated using statistical estimators sampling techniques paper present query modification technique processing nonaggregate realtime relational algebra queries singleuser dbms issue timeconstraint satisfaction equivalent controlling evaluation time query precisely two points observe 1 query evaluation time ra query unknown prior evaluation estimated certain probabilistic confidence example consider following query select set tuples research supported national science foundation grants iri8811057 iri9009897 iri9008632 preliminary version paper appeared proceedings 1992 ieee de conference department computer engineering science case western reserve university cleveland oh 44106 z department computer science southern illinois university carbondale il 62901 relation satisfies boolean formula f query number tuples satisfying f may vary significantly different relations whether selection completed within given time quota cannot known priori general evaluation time query changes different relations also selectivities 1 ra operators query 2 given time constraint query may small query evaluation time consuming probability able evaluate query within time units referred risk overspending rest paper may extremely high example probability join two diskresident relations 1000 blocks performed 10 seconds likely almost zero thus risk overspending time quota 10 seconds join almost one one come various approaches approximating modifying timeconstrained ra query approach used casedb follows 1 relations database fragmented semantically meaningful subsets fragments 2 query addition time quota user specifies maximum risk overspending taken dbms evaluating either query one modified versions concept risk overspending given query introduced 13 3 evaluate timeconstrained query dbms modifies original query replacing relations fragments query modification technique fragments selected risk overspending time quota evaluating modified query closest less risk specified user fragment selection problem 4 time left evaluating modified query step 3 performed iteratively higher risks overspending processes carried time quota completely used iterative query evaluation exception 15 16 realtime database literature deals multiuser environment transaction management maximizing number transactions complete within deadlines smith liu 15 vrbsky liu 16 give methodology finding approximate answers relational algebra queries approach amount time used increases accuracy approximate result improved approach contain risk control mechanism way obtain improve approximate result different rest paper organized follows section 2 query modification technique described algorithm example sections 31 32 discuss two different formulations fragment selection problem show problems npcomplete heuristic solution presented section 33 fragment selection problem implemented casedb section 4 present 1 selectivity ra operation expression e denoted sel e ratio number output tuples e product number tuples operand relations e transformations used query modification technique section 5 report experimental results performance analysis section 6 concludes query modification technique technique timeconstrained query modified replacing relations fragments user database administrator identifies relations would probably used timeconstrained query processing divides relation three types strata required strongly preferred preferred strata figure 21 shows relation fragmentation chain relation furnaces user prefers query evaluated furnaces strongly prefers query evaluated one two fragments criticalstatusfurnaces highpriorityandcriticalstatusfurnaces absolutely requires query evaluated fragment highpriorityandcriticalstatusanddangerousenvironmentfurnaces fragments required preferred strongly preferred strata called required strongly preferred preferred fragments example 21 casedb ra query keyword parameter specifies time constraint time quota keyword parameter r specifies risk overspending consider database relation furnaces fnumber fname priority status environment contains information furnaces relation temperatures fnumber temperature time date maintains recorded temperatures furnaces assume user specified relation fragmentation chains shown figures 21a 21b consider query list furnace names temperatures 10 seconds risk 05 less specified ra first revises query q q 1 furnaces replaced highpriorityandcritical statusanddangerousenvironmentfurnaces temperatures replaced last 3daytemperatures ie required fragments q 1 evaluated assume evaluation q 1 took 2 seconds casedb finds risks evaluating query different combinations fragments two chains time 8 seconds assume among risks risk comes closest less 05 048 query list last day temperatures highpriorityandcriticalstatusfurnaces casedb evaluates q 2 assume evaluation q seconds remaining 2 seconds casedb chooses larger fragments two chains using high risk overspending eg 095 repeats query evaluation reason choosing high risks later iterations reduce number additional iterations thus control overhead iterations average number iterations always upper bounded 4 casedb keeps evaluating modified versions q time bigger fragments time quota runs casedb returns last completed response user together modified query response figure 22 presents outline nonaggregate realtime query evaluation algorithm used casedb please note major random variables introduce error query evaluation time thus cause multiple query evaluation steps selectivities ra operators query end query evaluation step better information operator selectivities used revise selectivity estimations please note algorithm figure 22 transformation modified query q q 0 q 0 uses previous steps response first revision query q obtained replacing relation required fragment evaluation revised query constitutes first query evaluation step casedb spends remaining time iteratively improving query additional steps clearly step 2 onwards dbms may save time instead evaluating current steps query base relations revise current steps query previous steps output used current steps output b add new tuples output due larger fragments utilized current step point b course true general monotone 2 queries figure 21 relation fragmentation chains motivations approach listed 1 compromise sizes operand relations query risk overspending expected case possible exception set difference operator ra relations replaced subsets ie fragments query evaluation time hence risk overspending get smaller query monotone adding tuples input relations make lose output tuples otherwise nonmonotone ra queries unions intersections projections joins monotone however inclusion set difference operator makes ra query nonmonotone 2 specifying fragments relations much risk willing take overspending query user guides dbms choosing modified query 3 modified query semantically meaningful represents best query dbms answer given risk given time constraint algorithm timeconstrainedadhocandnonaggregatequeryevaluationq fi input q arbitrary relational algebra query given amount clock time quota fi upper bound risk overspending used step 2 output revised query qs response produced within clock time units begin set timer interrupt units true begin step1 begin replacerequiredfragmentsqqs ffor r q select required fragment f replace r f q obtain qsg executeqs fstandard relational algebra query executiong else begin step2 fi 0 else step fdecides risk taken step 3 g previous fi 0 timeleftqs fsolves fragment selection problem risk fi 0 obtain revised query qsg q previous qs goto end fif relation could obtained constraints satisfied given queryq evaluatedg transformqs q 0 ftransform qs q 0 q 0 uses previous step responseg endif currenttime starttime previous qs endwhile 3 timer interrupt occurs interrupt service routine returns control statement loop therefore loop next line infinite loop endreturnqsresponsetoqs figure 22 query evaluation algorithm realtime nonaggregate queries casedb 3 fragment selection problem complexity heuristics section formally define fragment selection problem using two different risk factor formulations prove formulations lead npcomplete problems briefly describe heuristic approach used casedb r let r denote fragments relation fragmentation lattice r ie rg consider q input relations r query evaluation step q let us say choose fragment f r relation r call resulting list fragments fff 1 fragment list q describe two different risk factor formulations 31 risk factor ff 11 gave risk factor ff approach sampling evaluating estimate aggregate queries revise approach fragment selection nonaggregate queries assume th query evaluation step let f ng fragment list q selected step first characterize probability exceeding time quota q evaluated fragments f risk ff overspending f let amount time left random variable representing actual amount time spent th step mean variance simply sel denote selectivity operator op th step sele simply sel denotes set sel op operator op e ie sel 2 sel let costq timecost formula query th step clearly equality satisfied since sel hence unknown step ends use expected version equation ie xi denotes expected value function assuming given fragment list f approximations sel b time cost formula costq query q derived solve using equation 32 risk overspending step denoted ff defined p denotes probability risk ff number ff obtained actual amount time spent step less equal therefore use equality less equal probability known obtained equation 32 use equation 33 solve ff hence ff thus risk ff overspending q evaluated using fragments fragment list f computed state fragment selection problem discuss complexity fragment selection problem fsp ff ff given risk overspending step let x denote set f f j jf j fragment list 0 ff ff j prechosen small constant g choose fragment lists x list f risk ff ff gamma ff minimum 2fsp particular case fsp relation r j two fragments r j theorem 1 2fsp ff npcomplete proof see appendix thus complexity finding f ff among possible fragment lists high however monotone queries several fragment lists eliminated consideration example consider two fragment lists f 1 f 2 risks ff 1 ff 2 respectively assume fragment f 1 contains corresponding fragment f 2 clearly q monotone ff 2 ff 1 ff 2 evaluated found ff ff 2 need compute ff 1 eliminate f 1 consideration nevertheless fragment selection problem still remains npcomplete theorem 2 fsp ff npcomplete fsp ff denotes fragment selection problem monotone queries proof see appendix addition discussed section 5 use stratified relation fragmentation lattices defined maintained priori number eligible fragment lists consider significantly reduced tightly controlled essentially many fragments fragment set relation r stratify fragments fragment selection problem consider fragments single stratum various ways approximate sel op sel 14 2 3 earlier work 11 10 approximated sel op sampling evaluating count estimators overhead approximating sel op reduced zero disk accesses sample fragment f also preretrieved stored along please note selectivity operator op 1 q uses operand output another operator op 2 q dependent selectivity op 2 selectivities independent precise selectivity estimations covariances selectivities need estimated unfortunately covariance formulas usually quite complicated 9 moreover complexity changes sampling method used equation 33 assumed approximation function fragments used variances among selectivities sel replaced sample selectivity variances obtained sel op approximations 32 risk factor fi op discuss another risk factor computation approach also adapted revised 11 fragment selection problem previous section control risk ff overspending whole query q approach pursue casedb define risk fi op overspending operator op q approach computationally simpler ffrisk approach advantage use separate risk factors different operators example join operator q large operand relations high variance selectivity may want take small risk overspending operator hand take large risk overspending selection operator small operand relation regardless variance selectivity approach follows assume step given fragment list f know selectivities sel op varsel op operator op q instead using sel query time cost formula costq use sel sel words probability actual selectivity sel op fragment list f greater sel thereby resulting overspending op executionthe risk fi op selectivity sel derived using equation sel mean sel v arsel variance sel fi op proper value chosen system based distribution sel controlling risk fi op approximate v arsel equation 34 using variance corresponding sample selectivity simple random sampling cluster sampling 9 gives formulas variance sample selectivity let us state fragment selection approach uses fi approach fragment selection problem fsp denote set sel let x denote set prechosen small constant g choose fragment lists x list f fi gamma costq among fragment lists x 2fsp fi particular case fsp fi relation two fragments fragment list theorem proof similar proofs theorems 1 2 omitted thus problem finding f fi op risk also npcomplete similar complexity finding f ff riskexcept expected value function costq ff risk approach much complex ff risk approach similar complexity reduction techniques used control time spent fragmentation selection problem 33 heuristic approach fi risk factor casedb implemented firisk factor heuristic approach locate f fi constant approach consider following properties heuristics selectivity ii types operators involved time costs subqueries r involved iv file organization type v positions input relations parse tree query use selectivity selectivity operator high slight increase fragment size relation involved operator would drastically increase output thereby increasing time cost might overspend allocated time would like increase fragment size input relation whose associated operator high selectivity ready take large risk use types operators determine monotonicity property subquery involved relations operators fragment size increased decreased may observe priori increase decrease output size hence time cost relations reverse true increase decrease fragment size decreases increases output size would like increase fragment size relations increase time cost maximize available time larger figure 31 parse tree r timecost subqueries involving base relations expected smaller variance hence timecost query involving operators would smaller variance type operator subquery plays part timecost subquery file organization relation involved subquery also plays role determining timecost subquery example case selection operator indexed file whose index attribute used selection formula timecost much less evaluating selection operator nonindexed file justify use position relation parse tree query use following example assume following query qr whose parse tree shown figure 31 increase size r 1 r 2 variance output size also increase since output size query random variable dependent output size r heuristic procedure proceeds follows given iteration system fits one following scenario choose relation depending scenario increase fragment size relation compute risk taken risk acceptable query evaluated chosen fragment time insufficient 4 risk taken small 5 increase fragment size relation ffl associated operator high selectivity 6 ffl lower parse tree ie away root 7 ffl involved expensive operator ie timecost higher order eg 2 4 available time less time taken evaluate query required fragment 5 risk less 01 7 relation level 3 greater increase fragment sizes relation ffl associated operator whose selectivity low ffl closer root parse tree ffl involved inexpensive operators time insufficient risk taken high similar scenario 1 increase fragment size relation involved expensive operator lower parse tree available time less instead increase fragment size relation associated operator whose selectivity high ready take larger risk scenario 3 available time sufficient risk taken small contrast scenario 2 increase fragment sizes relation lower parse tree involved expensive operators involved operators whose selectivity low time sufficient risk taken high algorithm selectfragmentsq fi availabletime qm modified query previous iteration fi risk taken next step availabletime time available next iteration modified query used present iteration begin heuristicchooseq r fi availabletime fchoose relation r using heuristicg estimatedtime availabletime r empty begin estimatedtime 0 fchooses fragment f j r relation r fragment used previous iterationg previous qm replacefragmentq previous f j r f r qm replaces fragment f r f j r query qmg subquery subq r 1 op r 2 subq op r 1 qm sizes r 1 r 2 known available estimated begin sel switch op case opoe fop selection operationg estimatedtime fr 0 output relation r 1 input relationg case op fop projection operationg estimatedtime case union operationg estimatedtime fr 0 output relation r 1 r 2 input relationsg case intersection operationg estimatedtime case op 1 fop natural join operationg estimatedtime case difference operationg estimatedtime endfor fif selected fragment entire relation choose another relation help heuristicsg heuristicchooseq previous r fi availabletime endwhile estimatedtime availabletime qmq previous fif estimated time within available time discard new fragment use previously found fragment could evaluated within available timeg figure 32 algorithm selecting fragment scenario increase fragment size relation lower parse tree involved operators high selectivities involved expensive operators 34 algorithms selecting fragment algorithm selectfragments given figure 32 outlines method used selecting fragment fragment selection problem using heuristic approach suggested section 33 algorithm procedures selectcost projectcost unioncost intersectioncost joincost return time estimation corresponding operators specified section 43 algorithm heuristicchoose shown figure 33 specifies process choosing relation based four scenarios algorithm heuristicchooseqrfitimeleft arbitrary query risk taken present iteration available current iteration involved q taken evaluate query required fragment begin switch cond begin case basetime fi 1 case basetime fi 1 case basetime fi 1 case basetime fi 1 endcase figure 33 algorithm choosing relation based heuristics algorithm lesstimelowrisk chooses relation based scenario 1 available time insufficient risk overspending small algorithm used three functions namely levelr returns level relation parse tree operatorvaluer returns value associated operator operates r directly value depends time complexity operator selectivityr returns selectivity r algorithm lesstimelowriskqselectedrelation arbitrary query relation involved q begin every relation r q begin ifselectedrelationempty entire relation used processing previous iteration else else else endfor figure 34 algorithm choosing relation modify given scenario similar lesstimelowrisk procedure algorithms lesstimehighrisk moretimehighrisk choosing relation based scenarios 23 4 respectively algorithm choosefragment chooses fragment fragment set relation casedb use linear search find right fragment given relation following algorithm choosefragment implemented casedb algorithm choosefragmentf j r f r r fragment currently used relation choosing fragment new fragment chosen relation r f j oe f begin figure 35 algorithm choosing fragment given fragment set algorithm calculateselplus implements computation sel operator p casedb arbitrary query sel estimated selectivity previous i1 iterations risk taken step assumed larger selectivity operator op value chosen p sel total number points point space op given number tuples relations involved operation number points point space op step j number points included previous i1 iterations begin sel sel returnsel end figure 36 algorithm calculating sel iterative query evaluation transformations illustrate iterative query evaluation transformations example example 41 consider query q 2 example 21 assume evaluations q 1 q 2 took 8 seconds still 2 seconds left time quota third step using risk 095 dbms chooses evaluate transform q 0 3 equivalent query q 3 uses q 2 follows fnametemperature criticalstatusfurnaces make two observations first two union operators right hand side equation 41 union two disjoint sets therefore need duplicate tuple elimination leads fast implementation second implementation relation fragmentation chains furnaces temperatures actually maintainphysical files f 0 gammag node thus evaluating f 3 g 0 respectively already stored database available leads fast implementation q 3 2 consider singleoperator query input relation r casedb evaluates q using fragments f r f ae f example 42 consider relation r relation fragmentation chain r assume already evaluated still time left time quota let f 2 next fragment chosen evaluate qf 2 terms qf 1 turn used evaluating qf evaluation qf i1 terms qf done almost always 8 follows algebraic manipula tions qf i1 converted qf q 0 words uses f f 0 evaluationtwo relations strictly smaller f i1 call f 0 i1 complement fragment f i1 iithe union operation q 0 q union two disjoint sets let us denote union two disjoint sets call disjoint union let r two relations r please note disjoint union implemented fast since unlike union require duplicate tuple elimination normally implemented sorting databasesan expensive task therefore whenever possible use disjoint union union illustrate example example 43 let qr r relation fragmentation chains f respectively assume previous iteration qf evaluated current chosen evaluate q ie qf j1 evaluated transform relation fragmentation chains r contain g 0 j1 computed stored database already query session starts 2 8 exceptions discussed 4 41 transformations singleoperator queries generalize approach singleoperator queries assume qf evaluated qf k evaluated let f ik denote f 0 k g jm denote g 0 ra operator evaluate transformed form list singleoperator query q transformations projection 42 transformations multipleoperator queries consider ra query multiple operators parse tree eg ra query parse tree shown figure 31 query evaluation step internal nodes parse tree associated output relation instances obtained evaluating operator node approach store use whenever possible last instances relations monotone queries approach quite efficient 421 monotone queries assume ra expression set difference operators ie monotone query let output relations internal node parse tree obtained two consecutive query evaluation steps summarize query transformations node parse tree let e e arbitrary ra expressions possibly relations evaluated th step give e respectively th step give e i1 respectively relation fragmentation chains relations involved e e compute e 0 clearly e e unary operator case 2 f correspond qf jm section 41 respectively use exactly transformations given section 41 evaluating e i1 e i1 e i1 example e available transformation 422 nonmonotone queries whenever set difference operator appears parse tree ie nonmonotone query may two consecutive output relations set difference operator results complicated transformations use computation thus making iterative evaluation costly note rs consecutive evaluations f 1 g 1 f 2 g 1 f 3 g 1 etc create monotonously increasing output relations approach casedb subexpression e query evaluate e afterwards evaluate e e new fragments e e approach guarantees consecutive output relations set difference operator case compute use transformation 43 timecosts transformations given operator choose transformation comparing cost formulas transformations operator briefly present cost formulas please note chosen cost formula operator also used algorithm selectfragments estimate iteration time hence choose fragments use sequential files sorted key store fragments relation notation jf j denotes number records f jjf jj denotes number blocks used storing f jjf jj used computing disk access cost since tuples readstored blocks fromto disk two ways maintaining intermediate results obtained iterative evaluation step either main memory evaluation disk since use iterative evaluation method process fragments relation intermediate results repeatedly used iterative step therefore keep intermediate results main memory final results obtained iterative step kept disk follows give timecosts transformations union set difference one transformation give time costs transformation 1 smallest expected number disk accesses 2 smallest expected number comparisons since query evaluated iterative fashion compute costs tranformations certain iteration step among four equivalent transformations union listed section 41 transformation u3 qf smallest time cost constants among three equivalent transformations union listed section 41 transformation d3 qf smallest time costs constants transformation constants constants using algorithm selectionf ik condition costs transformation constants projection using algorithm projectionf ik attributes costs transformation constants 5 experimental results 51 implementation casedb implementation query modification technique carried eram relational prototype dbms 8 eram built top unix 43bsd operating system sun 360 workstations written c programming language casedb consists five basic modules namely file management module performs functions reading writing tuples relation maintenance module creates retrieves updates destroys relations algebra module executes algebra operations help file management module command interpreter module supports relationally complete query language relation maintenance commands lattice maintenance module executes commands create update delete lattices ie simplest case fragmentation chains details casedb implementation 7 information relations associated fragment chains stored two different dictionaries basic structure dictionaries divided pages 9 end page pointer next available space page pointer next page page number information casedb complement fragments discussed section stored two reasons choice ffl query modification technique uses complement fragment transformations discussed section entire fragment less amount space required 52 creation input relations relation used experiment first second attribute c 1 c 2 integer type third attribute c 3 character type first attribute unique random integer key relation second attribute key relation used determine selectivity operator distribution attributes uniform relation involved experiment contains 5000 tuples tuple size 100 bytes number tuples required fragment always 100 9 page 1024 bytes number tuples complement fragments vary 100 200 relations indexed unless specified otherwise 53 factors affecting casedb factors affect performance casedb discussed risk probabilistic risk overspending plays important role selection fragment list ie solving fragment selection problem casedb depending risk given user sel giving different time estimates different risk values leads selection larger fragment risk higher smaller fragment risk lower b complement fragment size timecost costq function size input fragments since using complement fragments iterative query evaluation steps size complement fragment affects fragment selection process c selectivity selectivity operator p affects selection fragment relations involved p selectivity p p either union intersection difference projection selection defined ratio number output tuples total number input tuples p natural join operator selectivity p defined ratio number output tuples product input tuples expected time evaluation function selectivity thus change selectivity alters expected time time available time increases input tuples used leading evaluation original query 54 single operator queries section present results single operator queries see factors presented earlier section affect performance casedb casedb normally uses risk given user second iteration third succeeding iterations casedb computes higher risk value number iterations reduced however order see actual effect risk given user fi experiments used risk fi iterations excluding first iteration following tables column risk denotes risk overspending given user column selp denotes sel selectivity used timecost formula second iteration explained previous sections given query timequota risk overspending casedb evaluates query substituting relations query corresponding required fragments time left first iteration casedb iterates time available small overspending time occurs column itr denotes total number iterations query gone including iteration available time overspent column ptu percentage tuples used last iteration overspending occur pts denotes percentage tuples selected used last iteration note pts includes tuples used iteration overspending might occurred ptu pts columns value overspending occur ie casedb terminated process could select fragment could used next iteration evaluation iteration could completed within available time given risk finally ovsp represents amount time overspent seconds 541 selection operation tuples complement fragment risk 100 150 200 selp itr ptu pts ovsp selp itr ptu pts ovsp selp itr ptu pts ovsp 3 sel 1 54 time10sec table effect risk single selection operation selection query following form select rel c2 500 risk5 time10sec used experiments rel relation name c2 second attribute relation varying selection formula eg c2 500 obtained different selectivities selection operator distribution c2 relation fragment chain uniform using uniform distribution given us consistent value selectivity used calculation sel query modification technique following equations used compute sel equations seen increase risk overspending fi fi value decreases thereby reducing sel since timecost function sel timecost decreases risk increases leads selection larger fragments increase risk table 51 seen number tuples selected processing increases linearly risk except risk almost 1 999 risk fi almost 1 sel tends zero shown selp column leads selection large number tuples input tuples used time figure effect time single selection operation1500250035000 input tuples used 2nd iteration risk5 time10sec 100 tuplesfragcomp figure effect selectivity single selection operation selection operator increase complement fragment size number tuples selected increases linearly risk 07 percentage tuples selected 19 205 23 complement fragment sizes 100 150 200 respectively table 51 increase attributed cost disjoint unions example use 1000 tuples tuples used first iteration second iteration 10 expected time used selection fragments function sel need unions lattice complement fragment size 100 5 disjoint unions lattice complement fragment size 200 though disjoint union expensive operator increase total time required processing iteration available time increases number input tuples selected processing also increases linearly figure 51 since comparing expected time available time expected time less equal available time use fragment selected available time increases larger fragment selected expected time would within available time selectivity i1 th iteration used compute sel turn used compute expected time time cost th query evaluation step hence selectivity iteration affect selection fragment next iteration increase selectivity i1 th iteration increases sel turn increases expected time th query evaluation step therefore increase selectivity size fragment used following iteration decreases linearly figure 52 542 natural join operation tuples complement fragment risk 100 150 200 selp itr ptu pts ovsp selp itr ptu pts ovsp selp itr ptu pts ovsp 3 sel 1 0008 time20sec table effect risk single natural join operation experiments conducted natural join operator second attribute relations used join attribute join attribute values relations uniformly distributed test effect risk natural join operator complement fragment size 150 risks 001 3 5 7 999 percentage tuples selected 305 335 35 35 36 respectively data seen total number tuples selected processing linearly increases risk unlike selection operator digression linear increase risk approaches 1 increase number tuples selected processing show deviation linear increase linear increase attributed small values natural join selectivity risk fi tends 1 sel small actual selectivity small value change expected time drastically selectivity operator increased complement fragment size available time risk remains number fragments selected processing increases even small increase selectivity larger fragment selected example change 008 selectivity 001 009 difference 200 tuples 543 projection operation projection operator relation projected second attribute distribution second attribute relation fragments uniform2000400060008000 input tuples used time 200tuplescompfrag risk5 sel001 figure effect time single natural join operation900110013001500 input tuples used 2nd iteration selectivity join operator first iteration time10sec risk5 tuplesfragcomp150 figure effect selectivity single natural join operation tuples complement fragment risk 100 150 200 selp itr ptu pts ovsp selp itr ptu pts ovsp selp itr ptu pts ovsp 3 sel 1 087 time10sec table effect risk single projection input tuples used time figure effect time single project operation5001500250035000 input tuples used 2nd iteration selectivity first iteration figure effect selectivity single project operation table 53 see complement fragment size 100 risk 7 999 percentage tuples selected processing 32 34 respectively though percentage tuples selected risk 999 higher percentage tuples selected risk 7 overspending available time risk 7 noted overspending risk 7 occurs third iteration total number iterations risk 999 2 ie number tuples selected second iteration case 999 risk higher number tuples used second iteration risk 7 deduced number iterations reduced higher number tuples processed risk fi increases number iterations reduced using two results casedb designed use higher risk value third succeeding iterations irrespective risk given user case projection operator increase available time number tuples selected processing linearly increases selectivity operator changes unlike join operator slope curve small figure 56 544 intersection operation intersection operation considered special case join operation returns relatively low number output tuples tuples complement fragment risk 100 150 200 selp itr ptu pts ovsp selp itr ptu pts ovsp selp itr ptu pts ovsp 3 sel 1 4 time20sec table effect risk single intersection operation table 54 seen effect risk changes number tuples selected minimal ie variation number tuples selected respect increase risk value 2 12 14 complement fragment size 100 stated beginning section first attribute relations used experiments key relation relations indexed unless specified otherwise relations indexed disjoint union indexed relations resulting indexed relation expensive union operation time cost formula made time reading writing tuples disjoint union processing data since cost disjoint union equal cost union effect risk used writing processing cost tuples reduced figure 57 shows effect time number tuples selected intersection operator increase time number tuples selected processing increases linearly input tuples selected time figure effect time single intersection operation 545 union operation tuples complement fragment risk 100 150 200 selp itr ptu pts ovsp selp itr ptu pts ovsp selp itr ptu pts ovsp 3 sel 1 6 time20sec table effect risk single union operation effects risk time variations tested union operation like intersection operator cost disjoint union high table 55 shows effect risk different complement fragment sizes complement fragment size 200 risks 3 999 number tuples selected processing 14 16 respectively 2 increase number tuples input tuples used time figure effect time single union operation figure 58 shows linear increase number tuples selected processing increase available time difference operator tuples complement fragment risk 100 150 200 selp itr ptu pts ovsp selp itr ptu pts ovsp selp itr ptu pts ovsp sel 1 1 time20sec table effect risk single difference operation experiments similar union intersection operator conducted difference operator transformation difference operator iterative query evaluation complicated union difference operator one note due nonmonotonicity difference operator might delete certain tuples output previous iteration figure 59 shows effect time single difference operation available time increases input tuples choosen processing input tuples used time figure effect time single difference operation table 56 shows effect risk well complement fragment size difference operator consider percentage tuples selected risk 7 complement fragment sizes 100 150 200 13 155 18 respectively seen increase fragment size percentage tuples selected risk time increased larger complement fragments number disjoint unions reduced thereby reducing expected time higher number tuples selected 56 multioperator queries queries contain monotone operators union intersection join selection projection used experiments experiments mainly designed test effect risk variations multioperator queries relations used experiments contained 5000 tuples 200 tuples per complement fragment base fragment containing 100 tuples table 57 table 58 seen increase risk value number input tuples selected evaluation increases also note overspending available time quota happen overspending occurs total time overspent usually large due complex nature timecost formula especially number operators query increases since number tuples intermediate results depends selectivity operators small discrepancy estimated value either overestimate underestimate timecost resulting either overspending risk itr ptu pts ovsp itr ptu pts ovsp 3 200 tuplescompfrag time30sec table performance casedb case multioperator queries risk itr ptu pts ovsp itr ptu pts ovsp itr ptu pts ovsp 3 200 tuplescompfrag time100sec table performance casedb case multioperator queries underspending time quota incorporation difference nonmonotone operator query leads complicated transformation iterative query evaluation current version casedb monotonicity property preserved transformation including new tuples minuend difference operator second succeeding iterations solution efficiently processing nonmonotone multioperator query subject another report 6 conclusion future work paper discuss nonaggregate query processing techniques casedb realtime dbms present results experiments conducted casedb analyze complexity risk control methods propose implement evaluate heuristic solution controlling risk overspending difference operator multioperator query preserve monotonicity property thereby making transformations evaluations simpler achieved including new tuples minuend difference operator first iteration using risk factor user indirectly specifies aggressive wants getting query evaluated large input relations fragments possible within time quota given risk high dbms becomes bold chooses larger input relations hand risk low dbms chooses small input relations make sure query overspent another way looking risk factors query hints dbms given hint level aggressiveness choosing fragments please note use risk control approach second query evaluation step making sure possibly lowerquality query response obtained first query evaluation step also note third step use high risk fourth step rarely executed thereby controlling overhead introduced due iterative query evaluation risk factor approach essentially query modification technique priori runtime protocols user dbms evaluates query modified versions within qiven time quota riskbased approach introduces new paradigm realtime system dbms users addition time constraints asked specify risk factor guides dbms deciding aggressive evaluating query second step note approach choice relation fragments completely semanticsbased hence change basis application therefore provide guidance paper selection fragments however discussed experimental part sizes complement fragments influence performance empirically evaluated paper study timeconstrained queries make following choices timing constraints always satisfied b query evaluated 4 query evaluation iterations steps minimizes overhead due iterations c use risk factor approach second step attempt use risk close possible lower end userspecified risk choices ac experimental results section paper reports performance approach terms number parameters total number iterations ii number tuples used iii percentage tuples used last iteration overspending occur iv amount time overspent v amount time wasted etc one certainly use abovelisted parameters performance metric choose risk factors order desired values abovelisted parameters realtime databases transactions complete given values usually values assigned transaction reduces time transaction passes time deadline viewing query readonly transaction value assigned completed query sum values accumulated completed transactions serves performance metric comparison approach valuebased models notion controlled revisionrescaling queries perhaps valuebased approach extended adding query modification way assigning varying values modified versions query approach would require guidance user clear one would judge value modified query also dbms would need additional guidance perhaps terms values modify query riskbased approach also used processing realtime transactions transaction specifies optional required parts subtransactions dbms modify transactions downsizing make sure transactions complete within deadlines currently investigating approach appendix proof theorem 1 2fsp ff 2 np since nondeterministic algorithm needs guess fragment list f check polynomial time ff ff ff gamma ff transformation first define 01 knapsack problem consider finite set u set z positive integers u 2 u associate size su 2 z value vu 2 z let b k two positive integers u 0 u 01 knapsack problem proven npcomplete remains npcomplete even suvu u 2 u 5 follows assume give transformation 01 knapsack problem 2fsp ff construct set relations r j fragment list r j r j ff ff follows 1 set contains relations r number elements un g 2 r j g 3 ff j bn u2u su 4 ff j transformation takes polynomial time prove exists set u 0 exists fragment list assume fragment list f exists construct u 0 follows f j f f property k assume exist f ff ff ff gamma ff possible f consider corresponding constructed follows f j f f 1 f satisfy condition ff ff since ff 2 f satisfy constraint ff gamma ff since since onetoone onto function inverse set possible f possible subsets u 0 u conclude exist u 0 k proof theorem 2 reduction 01 knapsack problem 2fsp ff 11 exactly reduction 01 knapsack problem 2fsp ff transformation transformation 01 knapsack 2fsp ff note monotone queries check fragment lists show fragment lists checked correspond u 0 need checked also given fragment list f construct corresponding u 0 follows f j f f add consider three fragment lists f 1 f 2 f 3 risks ff respectively q monotone 1 ff ff 2 evaluate ff 3 ff ff 2 u2u 0su since f 2 f 3 u2u 0su means need check 3 2 ff 2 ff ff gamma ff 2 need evaluate ff 1 ff 2 ff ff gamma ff means need check u 0 1 conclude 2fsp ff npcomplete qed r generalization framework query modification estimating record selectivities estimation use selectivities database performance evaluation automated query modification databases computers intractabilitya guide theory npcompleteness set query optimization distributed database systems casedb system processing realtime nonaggregate relational algebra queries implementation extended relational database management system relational aggreate query processing techniques realtime databases statistical estimators relational alegbra expressions processing aggregate relational queries hard time constraints statistical estimators aggregate relational algebra queries processing timeconstrained aggregate queries casedb statistical profile estimation database systems monotonically improving approximate answers relational algebra queries objectoriented query processor produces monotonically improving approximate answers tr ctr sungkil lee gltekin zsoyolu distributed processing timeconstrained queries casedb proceedings fifth international conference information knowledge management p279287 november 1216 1996 rockville maryland united states kyoungdon kang sang h son john stankovic managing deadline miss ratio sensor data freshness realtime databases ieee transactions knowledge data engineering v16 n10 p12001216 october 2004 kyoungdon kang sang h son john stankovic differentiated realtime data services ecommerce applications electronic commerce research v3 n12 p113142 januaryapril amirijoo j hansson h son gunnarsson experimental evaluation linear timeinvariant models feedback performance control realtime systems realtime systems v35 n3 p209238 april 2007 nevzat hurkan balkir gultekin ozsoyoglu z meral ozsoyoglu graphical query language visual query processing ieee transactions knowledge data engineering v14 n5 p955978 september 2002 gultekin ozsoyoglu richard thomas snodgrass temporal realtime databases survey ieee transactions knowledge data engineering v7 n4 p513532 august 1995
value profiling variables invariant constant compiletime allows compiler perform optimizations including constant folding code specialization partial evaluation variables cannot labeled constants may exhibit semiinvariant behavior semiinvariant variable one cannot identified constant compiletime high degree invariant behavior runtime runtime information available identify variables semiinvariant could benefit invariantbased compiler optimizations paper examine invariance found profiling instruction values show many instructions semiinvariant values even across different inputs also investigate ability estimate invariance instructions program profiling load instructions addition propose new type profiling called convergent profiling estimating invariance loads convergent profiling used reduce profiling time needed generate accurate value profile value profile used automatically guide code generation dynamic compilation adaptive execution code specialization partial evaluation compiler optimizations b introduction many compiler optimization techniques depend upon analysis determine variables invariant havior variables invariant runtime behav ior cannot labeled compiletime fully benefit optimizations paper examines using profile feedback information identify variables semiinvariant behavior semiinvariant variable one cannot identified constant compiletime high degree invariant behavior runtime occurs variable one n n small possible values account variables values runtime value profiling approach identify semiinvariant variables goal value profiling different value pre diction value prediction used predict next result value write register instruction shown provide predictable results using previously cached values predict next value variable using hardware buffer 5 9 10 approach shown work well hardware value predictor since values produced instruction high degree temporal locality research semiinvariance variables different previous hardware predication stud ies compiler optimizations concerned invariance variable top n values variable popular range values variable lifetime program although temporal relationship values provide useful information value profiling techniques presented paper keep track top n values instruction number occurrences values information used automatically guide compilation optimization next section examine motivation paper related work section 3 describes method value profiling section 4 describes methodology used gather results paper section 5 examines semiinvariant behavior instruction types parame ters loads shows high degree invariance several types instructions order reduce time generate value profile optimization x6 investigates ability estimate invariance nonload instructions value profiling load instructions propagating invariance section 7 examines new type profiler called convergent profiler use value profiling goal convergent profiler reduce amount time takes gather detailed profile information value profiling found data profiled invariance instructions often reaches steady state point profiling turned sampled less often reduces profiling time still creating accurate value profile conclude summarizing paper x8 motivation related work paper originally motivated result found examining input values long latency instruc tions divide dec alpha 21064 processor take cycles execute divide intel pentium processor take 46 cycles therefore would beneficial special case divide instructions optimizable numerators denominators profiling hydro2d spec92 benchmark suite found 64 executed divide instructions either 0 numerator 1 denominator conditioning divide instructions numerator denominator either 0 1 based profiling information able reduce execution time hydro2d 15 running dec alpha 21064 processor applying optimization handful video games eg fury3 pitfall intel pentium processor able reduce number cycles executed estimated 5 1 programs results show value profiling effective reducing execution time long latency instructions recent publications value prediction hardware provided motivation research value profiling 5 9 10 recent paper lipasti et al 9 showed average 49 instructions wrote value last time 61 executed instructions produced value one last 4 values produced instruction using 16k value prediction table results show high degree temporal locality values produced instructions necessarily equal structions degree invariance needed certain compiler optimizations 21 uses value profiling value profiling benefit several areas research including dynamic compilation adaptive execution performing compiler optimizations specialize program certain values providing hints value prediction hardware estimation static calculation using detailed pipeline architecture model pentium processor estimation takes consideration data dependent resource conflict stalls 211 dynamic compilation adaptive execution code specialization dynamic compilation adaptive execution emerging directions compiler research provide improved execution performance delaying part compilation process runtime techniques range filling compiler generated specialized templates runtime fully adaptive code generation techniques effective compiler must determine sections code concentrate adaptive execution existing techniques dynamic compilation adaptive execution require user identify runtime invariants using user guided annotations 1 3 4 7 8 one goals value profiling provide automated approach identifying semiinvariant variables use guide dynamic compilation adaptive execution staging analysis proposed lee leone 8 knoblock ruf 7 effective means determining computations performed early compiler optimizations performed late postponed compiler dynamic code generation approach requires programmers provide hints staging analysis determine arguments semiinvariant behavior addition autrey wolfe started investigate form staging analysis automatic identification semiinvariant variables 2 consel noel 3 use partial evaluation techniques automatically generate templates runtime code generation although approach still requires user annotate arguments toplevel procedures global variables data structures runtime con stants auslander etal 1 proposed dynamic compilation system uses unique form binding time analysis generate templates code sequences identified semiinvariant approach currently uses user defined annotations indicate variables semiinvariant annotations needed drive techniques require identification semiinvariant variables value profiling used automate process automate process approaches use current techniques generating runtime code identify code regions could potentially benefit runtime code generation value profiling used determine code regions variables semi invariant behavior code regions identified profitable value profiling would candidates dynamic compilation adaptive execution approaches used dynamic compilation determine optimizable code regions also applied static optimization regions benefit code specialization variable instruction value across multiple inputs case code could duplicated creating specialized version optimized treat variable constant execution specialized code would conditioned value value profiling used determine potential variables instructions value across multiple inputs order guide code specialization 212 hardwarebased optimizations predicting recent values seen instructions future value shown good predictability using tagless hardware buffers 9 10 results show value profiling used classify invariance instructions form value profiling could potentially used improve hardware value prediction instructions shown variant kept value prediction buffer reducing number conflicts aliasing effects resulting accurate prediction using smaller tables instructions shown high invariance value profiler could even given sticky replacement policy memory disambiguation buffer 6 mdb architecture allows load dependent instructions hoisted loop checking store addresses inside loop conflict load store inside loop address load dependent instructions reexecuted similar hardware mechanism used take advantage values checking store address also value architecture value load hoisted loop changes load dependent instructions reexecuted value profiling used identify semiinvariant load instructions 3 value profiling section discuss straight forward approach value profiling study concentrates profiling instruction level finding invariance written register values instructions value profiling information level directly mapped back corresponding variables compiler optimization two types information needed value profiling used compiler optimizations 1 invariant instructions value lifetime program 2 top n result values instruction determining invariance instructions resulting value calculated many different ways value prediction results presented lipasti et al 9 10 used tagless table store cache recently used values predict next result value instruction keeping track number correct predictions equates number times instructions destination register void instructionprofilecollect stats reg cur value f total executed cur value last value f num times profiled else f lfu insert tnv tablelast value num times profiled last figure 1 simple value profiler keeping track n frequent occurring values along recent value mrv1 metric assigned value recent value one recent values call recent history depth recent values kept mrv metric provides indication temporal reuse values instruction equate exactly invariance instruction invariance invm mean percent time instruction spends executing frequent values example instruction may write register values x following repetitive pattern xy xyxyxy pattern would result mrv1 stores recent value 0 instruction invariance inv1 50 inv2 100 another example 1000 different values result instruction 100 times row switching next value case mrv1 metric would determine variable used recent value 99 time instruction 01 invariance inv1 mrv differs invariance state associated value indicating number times value occurred therefore replacement policy uses least recently used cannot tell value common found mrv metric times good prediction invariance times examples described 31 value profiler value profiling information required compiler optimization ranges needing know invariance instruction also know top n values popular range values figure 1 shows simple profiler keep track information pseudocode value profiler keeps top n value tnv table register written instruction therefore tnv table every register profiled tnv table stores value number occurrences pairs entry least frequently used lfu replacement policy inserting value table entry already exists occurrence count incremented number recent profiled occurrences value found least frequently used entry replaced 32 replacement policy top n value table chose use lru replacement policy since replacing least recently used value take consideration number occurrences value instead use lfu replacement policy tnv table straight forward lfu replacement policy tnv table lead situations invariant value cannot make way tnv table example tnv table already contains n entries profiled using least frequently used replacement policy sequence xy xyxyxy x table make x battle get tnv table neither succeed tnv table made forgiving either adding temp tnv table store current values specified time period later merged final tnv table clearing bottom entries tnv table every often paper use approach clearing bottom half tnv table profiling instruction specified clearinterval instruction profiled clearinterval bottom half table cleared clearinterval counter reset made number times sampled clear interval dependent upon frequency middle entry tnv table middle entry lfu entry top half table clearinterval needs larger frequency count entry otherwise new value could never work way top half table profiling set clearinterval twice frequency middle entry time table cleared minimum clearinterval 2000 times 4 evaluation methodology perform evaluation collected information spec95 programs programs compiled dec alpha axp21164 processor using dec c fortran compilers compiled spec benchmark suite osf1 v40 operating system using full compiler optimization o4 ifo table 1 shows two data sets used gathering results program number instructions executed millions used atom 11 instrument programs gather value profiles atom instrumentation tool interface allows elements program executable instructions basic blocks proce dures queried manipulated particular atom data set 1 data set 2 program name exe name exe compress ref 93 short 9 gcc 1cpdecl 1041 1stmt 337 ijpeg specmun 34716 vigo 39483 li ref wo puzzle 18089 puzzle 28243 perl primes 17262 scrabble 28243 vortex ref 90882 train 3189 applu ref 46189 train 265 apsi ref 29284 train 1461 fpppp ref 122187 train 234 hydro2d ref 42785 train 4447 mgrid ref 69167 train 9271 su2cor ref 33928 train 10744 tomcatv ref 27832 train 4729 turb3d ref 81333 train 8160 wave5 ref 29521 train 1943 table 1 data sets used gathering results pro gram number instructions executed millions data set allows instrumentation program navigate basic blocks program executable collect information registers used opcodes branch conditions perform controlflow dataflow analysis 5 invariance instructions section examines invariance predictability values instruction types procedure parameters loads reporting invariance results ignored instructions need executed correct execution program included reasonable number loads programs loads ignored since inserted program code alignment prefetching dec alpha 21164 processor results used two sizes tnv table profiling breakdown invariance different instruction types table 2 used tnv table size 50 results used tnv table size 10 instruction register 51 metrics describe metrics using throughout paper instruction said invariancem x calculated taking number times top values instruction occurred profiling found final tnv table profiling dividing number times instruction executed profiled order examine invariance instruction look inv1 inv5 inv1 frequency count program ild fld lda st imul fmul fdiv iarth farth cmp shft cmov fops compress 4427 0 li perl 7024 54 vortex hydro2d 76 su2cor 37 turb3d 54 avg table 2 breakdown invariance instruction types categories include integer loads ild floating point loads load address calculations lda stores st integer multiplication imul floating point multiplication floating point division fdiv integer arithmetic iarth floating point arithmetic cmp shift shft conditional moves cmov floating point operations fops first number shown percent invariance top value inv1 class type number parenthesis dynamic execution frequency type results shown instruction types write register eg branches frequently occurring value final tnv table divided number times instruction profiled inv5 number occurrences top 5 values final tnv table added together divided number times instruction profiled examining difference invariance two profiles either two data sets normal convergent profile examine difference invariance difference top values encountered instructions executed profiles diff1 diff5 used show weighted difference invariance two profiles top value tnv table top 5 values difference invariance calculated instruction instruction basis included weighted average based first input instructions executed profiles metric same1 shows percent instructions profiled first profile top value second profile calculate same1 instruction top value tnv table first profile compared top value second profile number times value occurred tnv table first profile added sum counter counter divided total number times instructions profiled based first input two metrics find1 find5 calculated similar manner show percent time top 1 element top 5 elements first profile instruction appear top 5 values instruction second profile calculating results same1 find1 find5 look instructions whose invariance first profile greater 30 reason looking instructions inv1 invariance larger 30 ignore instructions random invari ance variant instructions high likelihood top values two profiles different interested instructions therefore arbitrarily chose 30 since large enough avoid variant instructions looking top 5 values results two numbers shown first number percent match values found two profiles second number parenthesis percent profiled instructions match corresponds 30 invariance filter therefore number parenthesis percent instructions profiled invariance greater 30 comparing two different data sets overlap represents percent instructions weighted execu tion profiled first data set also profiled second data set 52 breakdown instruction type invariance table 2 shows percent invariance program broken 14 different disjoint instruction categories using data set 1 first number represents average percent invariance top value inv1 given instruction type number next parenthesis percent executed instructions class data set 1 data set 2 comparing params data set 1 data set 2 procedure calls params params invariance top values program instr 30 50 70 90 inv1 inv5 inv1 inv5 lap diff1 diff5 same1 find1 find5 compress gcc 123 54 48 34 17 31 43 31 43 li 245 perl 123 54 hydro2d mgrid su2cor average 053 73 67 61 44 54 69 54 70 table 3 invariance parameter values procedure calls instr percent executed instructions procedure calls next four columns show percent procedure calls least one parameter inv1 invariance greater 30 50 70 90 rest metrics terms parameters described detail x51 type accounts executing program store instructions invariance reported invariance value stored results show integer programs integer loads ild calculation load addresses lda integer arithmetic instructions high degree invariance frequently executed floating point instructions invariance found types different one program next programs mgrid swim tomcatv show low invariance hydro2d invariant instructions 53 invariance parameters specializing procedures based procedure parameters potentially beneficial form specialization especially code written modular fashion general purpose use used specialized manner given run application table 3 shows predictability parameters instr shows percent instructions executed procedure calls data set 1 next four columns show percent procedure calls least one parameter inv1 invariance greater 30 50 70 90 first five columns show results terms proce dures remaining columns show results terms parameter invariance values remaining metrics described detail x51 results show invariance parameters predictable different input sets table also shows average top value 44 parameters executed passed procedures data set 1 value 84 time parameter passed procedure second data set 54 invariance loads graphs figure 2 show invariance loads terms percent dynamically executed loads program left graph shows percent invariance calculated top value inv1 final 10 entry tnv table instruction right graph shows percent invariance top 5 values inv5 invariance shown nonaccumulative xaxis weighted frequency execution therefore interested optimizing instructions inv1 invariance greater 50 li would account around 40 executed loads figure shows programs compress vortex m88ksim perl 100 inv1 invariance around 50 executed loads m88ksim perl 100 inv5 invariance almost 80 loads interesting note graphs bimodal nature load invariance many programs loads either completely invariant variant table 4 shows value invariance loads invariance inv1 inv5 shown table data set 1 average invariance shown figure 2 mrv1 percentage time recent value next value encountered load diff mi weighted difference mrv1 inv1 percentages instruction instruction basis rest metrics described x51 results show mrv1 metric 10 difference invariance average difference percent executed loads percent invariance compress gcc go ijpeg li perl vortex applu apsi hydro2d mgrid su2cor turb3d percent executed loads percent invariance inv5 figure 2 invariance loads graph left shows percent invariance top value inv1 tnv table graph right shows percent invariance top 5 values inv5 tnv table percent invariance shown yaxis xaxis percent executed load instructions graph formed sorting instructions invariance putting instructions 100 buckets filling buckets based loads execution frequency average invariance weighted execution frequency bucket graphed comparing data set 1 data set 2 data set 1 data set 2 invariance top values program mrv1 inv1 inv5 diff mi mrv1 inv1 inv5 diff mi overlap diff1 diff5 same1 find1 find5 compress go ijpeg 26 28 47 19 26 li 37 perl vortex 28 hydro2d su2cor turb3d 36 38 48 8 40 42 52 8 average 38 table 4 invariance load values using tnv table size 10 mrv1 average percent time current value load last value load diff mi difference mrv1 inv1 calculated instruction instruction rest metrics described detail x51 large programs difference invariance instructions data sets small results show 27 loads executed data sets using 30 invariance filter top invariant value 90 time invariance inputs similar certain percentage 24 values clearing interval table size parameters used affect top values found tnv table invariance profiling loads 10 entry tnv table clearing bottom half table turned average results showed 1 difference invariance top value different 8 time tnv table using 30 filter examining different table sizes clearing tnv table size 4 average 1 difference invariance tnv table size 10 top value found different 2 time using table size 50 load profile average 0 difference invariance top value different 4 time compared entry tnv table examining loads invariance 30 6 estimating invariance instructions loads really unknown quantity dealing programs execution value invariance loads known reasonable believe invariance values many instructions estimated invariance value propagation would significantly reduce profiling time needed generate value profile instructions investigate used load value profiles previous section propagated load invariance program using data flow control flow analysis deriving invariance nonload instructions write register achieved reasonable results using simple interprocedural analysis algorithm estimation algorithm first builds procedure call graph procedure contains basic block control flow graph propagate invariance basic block regmap associated contains invariance registers processing basic block basic block processed regmaps predecessors control flow graph merged together used regmap basic block regmap updated processing instruction basic block derive regmap basic block calculate invariance instructions within basic block developed set simple heuristics default heuristic used instructions two input registers set def register invariance invariance first use register times invariance second use register one two input registers undefined invariance def register left undefined regmap instructions one input register eg mov invariance def register assigned invariance use heuristics used propagate invariance included loop depth induction variables stack pointer special instructions eg cmov brevity go table 5 shows invariance using estimation algorithm nonload instructions write register second column table shows percent executed instructions results apply third column prof shows overall invariance inv1 instructions using profile used form table 2 fourth column overall estimated invariance instruc tions fifth column weighted difference invariance inv1 real profile estimation instruction instruction basis next 7 columns show percent executed instructions average invariance threshold 10 30 50 60 70 90 column contains three numbers first number percent instructions executed invariance threshold second number percent invariant instructions estimation also classified invariant threshold last number column shows percent instructions normalized invariant instructions found threshold estimation thought invariant threshold therefore last number column normalized percent instructions estimated results show estimated propagation 8 difference average invariance real profile terms actually classifying variables invariant threshold estimation finds 83 instructions invariance 60 estimation estimates invariant instructions threshold 7 estimated invariance typically lower real profile several reasons first default heuristic multiplies invariance two uses together arrive invariance def times estimation correct although lot time provides conservative estimation invariance written register another reason times two uses instruction variant resulting computation invariant particularly true logical instructions eg shift arithmetic instructions 7 convergent value profiling amount time user wait profile generated vary depending gains achievable using value profiling level detail required inv1 instructions found invariance threshold program instrs prof est diff1 10 30 50 60 70 80 90 compress 50 go ijpeg 71 li mgrid su2cor turb3d 56 average 53 29 24 8 20 75 5 17 76 table 5 invariance found instructions computed propagating invariance load value profile instrs shows percent instructions nonload register writing instructions results table apply prof est percent invariance found real profile estimated profile diff1 percent difference profile estimation last 7 columns show percent executed instructions average invariance threshold 10 30 50 60 70 80 90 percentage estimation profile found percent estimated value profiler determines impact time profile problem straight forward profiler shown figure 1 could run hundreds times slower original application especially instructions profiled one solution propose paper use somewhat intelligent profiler realizes data invari ance top n values profiled converging steady state profiling turned instruction instruction basis examining value invariance instructions noticed instructions converge first percent execution steady state steady state reached point profiling instruction keeping track percent change invariance one classify instructions either converged changing convergent profiler stops profiling instructions classified converged based convergence criteria convergence criteria tested given time period convergenceinterval profiling instruction model behavior profiling code conditioned boolean test profiling turned instruction profiling turned normal profiling occurs given convergence interval convergence criteria tested profiling condition set false profile converged instruction profiling turned periodically execution counter checked see given retry time period elapsed profiling turned retry time period set number total executed backoff backoff either constant random number used periodically turn profiling back see invariance changing paper examine performance two heuristics convergence criteria value profiling first heuristic concentrates instructions increasing invariance instructions whose invariance changing interested instructions increasing final invariance decreasing final invariance compiler optimization pur poses therefore continue profile instructions whose final invariance increasing choose stop profiling instructions whose invariance decreas ing percent invariance convergence test greater percent invariance previous inter val invariance increasing profiling contin ues otherwise profiling stopped calculating invariance total frequency top half tnv table examined results use convergence interval testing criteria 2000 instruction executions second heuristic examined convergence cri teria continue profiling change invariance current convergence interval greater invincrease bound lower invdecrease bound percent invariance changing bounds profiling continues otherwise profiling stops invariance converged within bounds convergent profile comparing full load profile convergent convergence invariance invariance top values program prof conv inc backoff inv1 inv5 diff1 diff5 same1 find1 find5 compress li table convergent profiler profiling continues invariance increasing otherwise turned prof percent time executable profiled conv inc percent time convergent criteria decided invariance converged still increasing backoff percent time spent profiling turning profiling back 71 performance convergent profiler table 6 shows performance convergent profiler stops profiling first instance change invariance decreases second column percent instructions profiled shows percentage time profiling turned programs execution third column conv shows percent time profiling converged convergence criteria tested next column inc percent time convergence test decided invariance increasing fifth column back shows percent time spent profiling turning profiling back using retry time period rest metrics described x51 compare results profiling loads programs complete execution convergent profile results results show average convergent profiling spent 2 time profiling profiling turned 98 time programs time converge 1 less gcc outlier taking 24 execution converge reason gcc executes 60000 static load instructions inputs many loads execute long therefore loads fully profiled since execution time fit within time interval sampling convergence 2000 invocations results show convergent pro filers invariance differed 10 full profile able find top value full length profile top 5 values convergent profile 98 time table 7 shows performance convergent pro filer using upper lower change invariance convergence back invariance program prof conv inc dec diff1 diff5 compress gcc li perl 0 43 38 19 19 3 0 average 4 22 28 50 57 3 0 table 7 convergent profiler profiling continues long change invariance either inv increase invdecrease bound new column dec shows percent time invariance decreasing testing convergence bounds determining convergence new column dec shows percent time test convergence decided continue profiling invariance decreas ing results use invincrease threshold 2 invdecrease threshold 4 invariance increasing 2 decreasing 4 profiling turned results show heuristic spends time profiling 4 average lower difference invariance 3 comparison first heuristic 10 terms values new heuristic increased matching top values 1 therefore advantage using second heuristic obtain accurate invariance table 7 shows lot time spent profiling decrease invariance reason variant instruction start looking invariant couple values first take awhile overall invariance instruction reach final variant behavior results also show time profiling 57 spent profiling turned back using first convergence criteria 24 one problem instruction profiled long time takes awhile overall invariance change invariance instruction converges profiling awhile changes new steady state take lot profiling bring overall invariance around new steady state one possible solution monitor happening dump current profile information start new tnv table instruction would converge faster new steady state examining sampling techniques approaches convergent profiling part future research summary paper explored invariant behavior values loads parameters register defining instructions invariant behavior identified value profiler could used automatically guide compiler optimizations dynamic code generation showed value profiling effective means finding invariant semiinvariant instructions results show invariance found instructions using value profiling predictable even different input sets addition examined two techniques reducing profiling time generate value profile first technique used load value profile estimate invariance nonload instructions 8 invariance difference real profile second approach proposed reducing profiling time idea creating convergent profiler identifies profiling information reaches steady state converged convergent profiler used loads profiled 2 programs execution average recorded invariance within 10 full length profiler found top values 98 time idea convergent profiling proposed paper potentially used decreasing profiling time needed types detailed profilers view value profiling important part future compiler research especially areas dynamic compilation adaptive execution identifying invariant semiinvariant instructions compile time es sential complementary approach trying identify semiinvariant variables use dataflow staging analysis try prove variables value change often hold values lifetime program type analysis used combination value profiling identify optimizable code regions acknowledgments would like thank jim larus todd austin florin baboescu barbara kreaseck dean tullsen anonymous reviewers providing useful comments work funded part uc micro grant 97018 dec external research grant us004097 generous equipment software grant digital equipment corporation r initial results glacial variable analy sis general approach runtime specialization application c speculative execution based value prediction dynamic memory disambiguation using memory conflict buffer data specialization optimizing ml runtime code generation exceeding dataflow limit via value prediction value locality load value prediction atom system building customized program analysis tools tr atom dynamic memory disambiguation using memory conflict buffer optimizing ml runtime code generation fast effective dynamic compilation data specialization value locality load value prediction c language highlevel efficient machineindependent dynamic code generation general approach runtime specialization application c exceeding dataflow limit via value prediction initial results glacial variable analysis ctr dean tullsen john seng storageless value prediction using prior register values acm sigarch computer architecture news v27 n2 p270279 may 1999 characterization value locality java programs workload characterization emerging computer applications kluwer academic publishers norwell 2001 daniel connors wenmei w hwu compilerdirected dynamic computation reuse rationale initial results proceedings 32nd annual acmieee international symposium microarchitecture p158169 november 1618 1999 haifa israel tarun nakra rajiv gupta mary lou soffa value prediction vliw machines acm sigarch computer architecture news v27 n2 p258269 may 1999 brian grant matthai philipose markus mock craig chambers susan j eggers evaluation staged runtime optimizations dyc acm sigplan notices v34 n5 p293304 may 1999 chiahung liao jongjiann shieh exploiting speculative value reuse using value prediction australian computer science communications v24 n3 p101108 januaryfebruary 2002 glenn reinman brad calder dean tullsen gary tyson todd austin classifying load store instructions memory renaming proceedings 13th international conference supercomputing p399407 june 2025 1999 rhodes greece youfeng wu efficient discovery regular stride patterns irregular programs use compiler prefetching acm sigplan notices v37 n5 may 2002 kevin lepak mikko h lipasti value locality store instructions acm sigarch computer architecture news v28 n2 p182191 may 2000 yonghua ding zhiyuan li compiler scheme reusing intermediate computation results proceedings international symposium code generation optimization feedbackdirected runtime optimization p279 march 2024 2004 palo alto california brian grant markus mock matthai philipose craig chambers susan j eggers benefits costs dycs runtime optimizations acm transactions programming languages systems toplas v22 n5 p932972 sept 2000 daniel connors hillery c hunter benchung cheng wenmei w hwu hardware support dynamic activation compilerdirected computation reuse acm sigops operating systems review v34 n5 p222233 dec 2000 lee lin michael ernst improving adaptability multimode systems via program steering acm sigsoft software engineering notes v29 n4 july 2004 youfeng wu dongyuan chen jesse fang better exploration regionlevel value locality integrated computation reuse value prediction acm sigarch computer architecture news v29 n2 p98108 may 2001 kevin lepak gordon b bell mikko h lipasti silent stores store value locality ieee transactions computers v50 n11 p11741190 november 2001 jun yang rajiv gupta energy efficient frequent value data cache design proceedings 35th annual acmieee international symposium microarchitecture november 1822 2002 istanbul turkey jun yang rajiv gupta frequent value locality applications acm transactions embedded computing systems tecs v1 n1 p79105 november 2002 daniel connors hillery c hunter benchung cheng wenmei w hwu hardware support dynamic activation compilerdirected computation reuse acm sigplan notices v35 n11 p222233 nov 2000 avinash sodani gurindar sohi empirical analysis instruction repetition acm sigops operating systems review v32 n5 p3545 dec 1998 markus mock craig chambers susan j eggers calpa tool automating selective dynamic compilation proceedings 33rd annual acmieee international symposium microarchitecture p291302 december 2000 monterey california united states lian li jingling xue tracebased binary compilation framework energyaware computing acm sigplan notices v39 n7 july 2004 sebastian elbaum madeline hardojo empirical study profiling strategies released software impact testing activities acm sigsoft software engineering notes v29 n4 july 2004 kameswari v garigipati cindy norris evaluating use profiling regionbased register allocator proceedings 2002 acm symposium applied computing march 1114 2002 madrid spain vijay sundaresan daryl maier pramod ramarao mark stoodley experiences multithreading dynamic class loading java justintime compiler proceedings international symposium code generation optimization p8797 march 2629 2006 burrows u erlingson st leung vandevoorde c waldspurger k walker w e weihl efficient flexible value sampling acm sigplan notices v35 n11 p160167 nov 2000 brad calder glenn reinman dean tullsen selective value prediction acm sigarch computer architecture news v27 n2 p6474 may 1999 burrows u erlingson st leung vandevoorde c waldspurger k walker w e weihl efficient flexible value sampling acm sigops operating systems review v34 n5 p160167 dec 2000 sebastian elbaum madeline diep profiling deployed software assessing strategies testing opportunities ieee transactions software engineering v31 n4 p312327 april 2005 matthew c merten andrew r trick christopher n george john c gyllenhaal wenmei w hwu hardwaredriven profiling scheme identifying program hot spots support runtime optimization acm sigarch computer architecture news v27 n2 p136147 may 1999 chaoying fu matthew jennings sergei larin thomas conte value speculation scheduling high performance processors acm sigops operating systems review v32 n5 p262271 dec 1998 k v seshu kumar value reuse optimization reuse evaluated math library function calls compiler generated cache acm sigplan notices v38 n8 august ann gordonross frank vahid frequent loop detection using efficient nonintrusive onchip hardware proceedings international conference compilers architecture synthesis embedded systems october 30november 01 2003 san jose california usa zhang rajiv gupta whole execution traces proceedings 37th annual ieeeacm international symposium microarchitecture p105116 december 0408 2004 portland oregon abhinav das jiwei lu howard chen jinpyo kim penchung yew weichung hsu dongyuan chen performance runtime optimization blast proceedings international symposium code generation optimization p8696 march 2023 2005 shashidhar mysore banit agrawal timothy sherwood nisheeth shrivastava subhash suri profiling adaptive ranges proceedings international symposium code generation optimization p147158 march 2629 2006 roman lysecky susan cotterell frank vahid fast onchip profiler memory proceedings 39th conference design automation june 1014 2002 new orleans louisiana usa martin burtscher benjamin g zorn hybrid loadvalue predictors ieee transactions computers v51 n7 p759774 july 2002 ramon canal antonio gonzlez james e smith softwarecontrolled operandgating proceedings international symposium code generation optimization feedbackdirected runtime optimization p125 march 2024 2004 palo alto california kevin lepak mikko h lipasti silent stores free proceedings 33rd annual acmieee international symposium microarchitecture p2231 december 2000 monterey california united states craig chambers staged compilation acm sigplan notices v37 n3 march 2002 zhang rajiv gupta whole execution traces applications acm transactions architecture code optimization taco v2 n3 p301334 september 2005 lixin su mikko h lipasti dynamic class hierarchy mutation proceedings international symposium code generation optimization p98110 march 2629 2006 jeremy w nimmer michael ernst automatic generation program specifications acm sigsoft software engineering notes v27 n4 july 2002 michael ernst jake cockrell william g griswold david notkin dynamically discovering likely program invariants support program evolution ieee transactions software engineering v27 n2 p99123 february 2001 benchung cheng daniel connors wenmei w hwu compilerdirected early loadaddress generation proceedings 31st annual acmieee international symposium microarchitecture p138147 november 1998 dallas texas united states toshio suganuma toshiaki yasue motohiro kawahito hideaki komatsu toshio nakatani dynamic optimization framework java justintime compiler acm sigplan notices v36 n11 p180195 11012001 toshio suganuma toshiaki yasue motohiro kawahito hideaki komatsu toshio nakatani design evaluation dynamic optimizations java justintime compiler acm transactions programming languages systems toplas v27 n4 p732785 july 2005 matthew arnold barbara g ryder framework reducing cost instrumented code acm sigplan notices v36 n5 p168179 may 2001 matthew arnold stephen fink david grove michael hind peter f sweeney adaptive optimization jalapeo jvm acm sigplan notices v35 n10 p4765 oct 2000 chaoying fu jill bodine thomas conte modeling value speculation optimal edge selection problem ieee transactions computers v52 n3 p277292 march brian grant matthai philipose markus mock craig chambers susan j eggers retrospective evaluation staged runtime optimizations dyc acm sigplan notices v39 n4 april 2004
implementing temporal integrity constraints using active dbms abstractthe paper proposes general architecture implementing temporal integrity constraints compiling set active dbms rules modularity design allows easy adaptation different environments differences specification languages target rule systems easily accommodated advantages architecture demonstrated particular temporal constraint compiler compiler allows automatic translation integrity constraints formulated past temporal logic rules active dbms current version compiler two active dbms supported starburst ingres compilation set constraints checked safe evaluation property result set sql statements includes necessary rules needed enforcing original constraints rules optimized reduce space overhead introduced integrity checking mechanism need additional runtime constraint monitor rules activated updates database violate constraints automatically rejected ie corresponding transaction aborted addition straightforward implementation approach offers clean separation application programs integrity checking code b introduction ince introduction databases notions data consistency integrity constraints playing important role database application design process integrity constraints usually divided two categories static referring static snapshot database temporal referring sequence snap shots ordered time temporal constraints allow imposing restrictions transactions database like salary employee cannot decrease student drops readmitted propose general architecture temporal integrity constraint compiler based compilation temporal specification ie set temporal constraints set first order logic fol definitions fol serves convenient intermediate language fol definitions converted set active rules enforce specified constraints without need additional runtime constraint monitor arrangement allows easy modification system incorporate different queryconstraint languages uniform way addition show architecture accommodate number different optimization techniques im manuscript received oct 3 1994 j chomicki toman currently department computing information science kansas state university man hattan ks 66506 email fchomickidavidgcisksuedu ieeecs log number k95048 plementation instantiates general architecture fixing constraint language past temporal logic pasttl current implementation produces code starburst 6 ingres 20 active dbms implementation allows user specify constraints declaratively instead embedding integrity checks application programs advantages declarative specification clear designer concentrate constraints enforced instead enforce leads also much compact understandable application programs moreover application programs integrity constraints specification form independent modules allows building modular applications one modules specifies integrity constraints pursue approach taken 1 3 proposed language specifying temporal integrity constraints pasttl formulas truth formula state n depends finite history temporal database ie past time n approach detects violations constraints namely situations constraints true state n gamma 1 true state n also develop spaceoptimization techniques proposed architecture optimizations introduced two different levels first optimization deals specification language pasttl second intermediate language fol performing optimizations need keep mind ffl dealing temporal constraints means optimizations need explicitly handle progression time ffl final goal compilation produce set active rules particular means formulas converted appropriate dml eg sql optimization techniques preserve convertibility chosen language cf sections v vi far work integrity constraints mainly focused efficient detection constraint violations general integrity constraints included 5 difficult enforce efficiently thus generalpurpose integrity enforcement subsystems currently present experimental database systems commercial dbmss usually enforce simplest constraints eg constraints primary foreign keys 5 static constraints studied many papers eg 9 usually formulated fol dealing temporal constraints choice temporal logic seems natural solution implementation ieee transactions knowledge temporal constraints ralg2sql rule generator transformation algebraic ordering information fol2sql magic set transformation rules active fig 1 structure system restricted language past fragment temporal logic temporal logic temporal operators referring solely past constraint checking done using spaceefficient encoding database history 1 utilization active rules important advantage compared methods integrity enforcement need standalone temporal integrity mon itor use separate monitor would improve efficiency would evaluate essentially set queries database rules however would duplicate transition datastructures maintained already active dbms several recent proposals general constraint management subsystems especially 7 10 13 first paper 7 develops sqlbased constraint specification language shows several techniques converting specification triggers starburst sys tem system allow fully automatic translation logic formulas starburst rules also static constraints covered approach second approach 10 closer work temporal logic chosen constraint specification language comparing language future fragment approach quantifiers logic formulas restricted pattern also checking formulas safe evaluation property solely user responsibility whereas method accepts arbitrary pasttl formulas long safely converted relational alge bra unsafe formulas rejected system another approach found 13 temporal language chosen approach uses nonstandard freeze quantifiers instead firstorder ones expressive power constraint language depends underlying query language detailed comparison approach related work see 3 paper organized follows section ii describe overall structure system section iii introduce syntax semantics specification language section iv transformation constraints rule language active dbms shown general schema generating active rules instantiated use starburst ingres active dbms suitability respective rule languages briefly discussed compiler uses fol sql translator described section v one steps use modification approach 4 section vi develops spacesaving optimizations minimize overhead connected constraint enforcement mechanism paper concluded discussion possibilities future extensions system ii system architecture general architecture consists following basic building blocks 19 ffl temporal constraint language fol compiler ffl fol dml compiler ffl rule generator system extends architecture providing number optimization modules overall structure system shown figure 1 ffl first step algebraic transformation original formula performed unless additional information supplied conservative transformations performed ffl tl2fol module converts pasttl formulas set fol formulas also produces information needed translating fol formulas active rules partial ordering information ffl variant magic set transformation 18 applied fol formulas produced tl2fol pass transformation may also modify ordering information ie incomparable elements may become comparable ffl fol2sql module responsible converting fol relational algebra sql consists two submodules fol2ralg converts fol formula relational algebra normal form ranf 4 expression expression combined magic conditions produced magic set transformation also converted relational algebra normal form using modified fol2ralg algorithm cf algorithm 36 output chomicki toman implementing temporal integrity constraints using active dbms 3 two modules put back together end ralg2sql module generates final sql statements ffl rule generator module combines information provided tl2fol module sql statements produced fol2sql module creates active rules arrangement allows easy modification future easily adopt different rule system changing rule generatorthis feature demonstrated implementation supports two conceptually different rule systems different dml changing ralg2sql subsystem possibly rule generator different specification language also introduction additional optimization techniques easily embedded current system fol serves convenient intermediate language iii specification language section gives brief overview syntax semantics pasttl language used system standard notation temporal formulas used full description temporal logic see 8 15 pasttl language defined smallest set formulas built using following rules atoms relations r database constants variables xaey ae 2 f 6 g x variables constants b b 9xa since b 5a b pasttl formulas semantics truth value closed formula defined respect underlying history database state database time follows 9xa interpreted standard fol formulas appropriate state 5a true 0 true igamma1 since b true b true k true j constraints specified closed formulas pasttl must satisfied every state history database following text use following standard ab breviations 8xa 9xa 3a true since 1a 3a example 3 using pasttl constraint salary employee cannot decrease expressed constraint student drops readmitted truth pasttl constraints determined respect history database constraint c 2 true current moment element x x relation admitted ie current state database also x relation dropout past ie past states database constraint specification consists definition database schema including types attributes followed list constraints constraint specified identifier name followed closed pasttl formula iv temporal information management first show convert given pasttl formula single fol formula set inductively defined auxiliary atoms definitions later converted auxiliary relations active rules section vi introduce optimization techniques help cut space overhead introduced tl2fol pass compiler pasttl fol naive approach checking past temporal constraints evaluate formula respect whole history practice acceptable every past state database would stored avoid problem provide spaceefficient encoding history 1 3 using number auxiliary atoms implemented materialized views obtain atom definitions convert every pasttl formula set fol formulas definition 4 tl2fol let f formula pasttl 1 temporal subformula ff replaced auxiliary atom r ff introduction atom results creating auxiliary relation r ff target code arity r ff equal number free variables ff type attribute type corresponding variable ff 2 auxiliary atoms r ff temporal subformula ff defined following table ff auxiliary atom definition ff false since b r 0 ff false superscripts 0 denote appropriate temporal state database formula evaluated 3 remaining formula ie substitutions made defines toplevel fol translation original pasttl constraint superscripts n symbolic references database states specific numbers note always last two consecutive states referenced frameworkthe definition induction length database history evaluation incremental transition new state simply computes new interpretation auxiliary atoms current terpretation rest paper use r ff denote formula defines new interpretation auxiliary atom r ff generated auxiliary atoms ordered following partial ordering definition 5 ordering r ff oe r fi ff subformula fi toplevel constraint always top element ordering example using approach constraint employee hired left expressed pasttl converted follows get one toplevel fol formula per pasttl constraint one inductive definition auxiliary atom per temporal subformula original formula example two temporal subfor mulas one free variable first order translation looks follows name fo translation r ff 2 oe c note auxiliary atom definitions refer states n n gamma 1 toplevel constraint c refers state n allows us check toplevel constraints every state particular initial 0th state database auxiliary atoms false ie corresponding auxiliary relations empty definition end transformation obtain one fol formula representing toplevel constraint several formulas defining inductively truth value auxiliary atoms r ff generated original pasttl formula ordering oe evaluation ie rematerialization auxiliary relations r ff toplevel constraint information used active rules generated next phase compilation process b maintenance auxiliary relations conversion temporal constraint fol generates set auxiliary atom definitions auxiliary atoms represented auxiliary relations resulting code contents auxiliary relations kept date agreement definition 4 achieved automatically using active dbms rule system specified constraint sql statement represents toplevel constraint list sql statements defining next state auxiliary relation supplied one one fol2sql module subformula ordering oe defined used input rule generator rule generator composes pieces set active dbms rules ideal case syntax used rules shown figure 2 case simply create rules sql statements follows translation fol formula sql including optional optimization steps constraint c create rules follows toplevel constraint c one rule constraint translation toplevel fol formula created tl2fol phase create rule c commit rollback work rule triggered transaction attempts commit ie actual committing necessary case temporal constraints even null transaction possibly violate constraints note cannot happen static constraints used example 7 consider constraint 9xpx 5px constraint violated arbitrary element x relation p two consecutive states clearly p empty null transaction violate constraint auxiliary atoms let r ff formula defining r n ff auxiliary atom r ff whole definition r ff r 0 ff false r n create auxiliary relation ie table atom r ff create table r ff listofattributes statement also defines 0th statethe table empty corresponds r 0 ff false proper transition next state r ff achieved automatically following rule use second part inductive definition r ff namely r n create rule r ff commit update r ff r ff precedes c fr fi jr ff oe r fi g rule also triggered transaction tries com mit execution rule updates auxiliary relation r ff guarantees consistency auxiliary tables proper order triggering rules defined subformula ordering oe reflected precedes clause rules body rules corresponding subformulas processed prior rule evaluating sql statement need access tables referenced atoms may refer ngamma1st state database previous state database ie old contents rela tions stored databasethis would require maintain two copies almost data instead transition tables used restore previous state database note transition information relation r maintained dbms anyway order allow aborting transaction access information provided system maintained transition tables insertedr deletedr oldupdatedr newupdatedr state n gamma 1 relation r restored chomicki toman implementing temporal integrity constraints using active dbms 5 create rule rulename sql predicate sql action precedes rulename follows rulename fig 2 ideal rule syntax commit rule system checks guard rule guard true evaluates condition condition satisfied executes actions specified clause evaluation order rules controlled precedes follows clauses part rule mandatory moreover tables specified clause system provides appropriate transition tables inserted deleted oldupdated newupdated 6 r example 8 finish example 6 system generates following code rule toplevel constraint create rule c commit 9xr ff 1 rollback work two rules maintain auxiliary tables r ff 1 r ff 2 create rule ff 1 commit update r ff 1 precedes c create rule ff 2 commit update r ff 2 emp precedes c problems sql actual dml rule languages usually allow express rules needed enforce constraints di rectly implementors rule generator faced two main obstacles ffl problems data manipulation language ffl problems rule system used overhead introduced restrictions dmls rule systems languages summarized figure 3 c1 view rematerialization new state auxiliary relation r ff computed sql equivalent fol formula r ff need replace whole contents table representing r ff r ff may referenced r ff done analysis views materialized notice next state auxiliary relations r ff defined one following formulas first case solved following sql code delete r ff insert r ff apply idea second case need reformulate assignment statement 2 equivalent sql insert delete operations follows delete r ff x r insert r x list attributes r ff easy see two operations equivalent original assign ment disadvantage solution compile right side assignment single formula must produce two separate sql statements example 9 continuing example update operations auxiliary tables r ff 1 r ff 2 replaced insert r ff 1 delete r ff 2 insert r ff respectively note first update simplified removing delete operation due structure definition generated subformula rooted connective 3 c2 restrictions rule languages syntax semantics active rule systems varies greatly among active dbms implementation currently supports two major approaches rule systems setoriented rule systems representative system starburst active dbms rule language starburst close ideal rule syntax cf figure 2 however restrictions rule syntax makes direct application rule templates previous section possible especially ffl references transition tables allowed inside rules body transition information table associated particular rule available ffl rule connected exactly one table means rule triggered associated table accessed moreover triggering defined terms net effect transaction tablecommitting may able trigger rule even associated table accessed ie updated empty net outcome slightly compromise claim constraints 6 ieee transactions knowledge number starburst ingres rules ct c4t3b c4t4b auxiliary tables 3t2b1 3t2b1 virtual views 0 0 u database procedures 0 0 c3t3b1 cnumber constraints tnumber temporal connectives bnumber base tables unumber embedded disjunctions fig 3 size code generated various systems enforcement mechanism independent appli cation safe side application update auxiliary commit table introduced purpose actual committing avoided allowing rule triggered attempt commit thus rule must associated commit table constraint violated null transaction safe associate rules individual tables workaround problems follows table including auxiliary tables r ff use two additional auxiliary transition tables add sub holding tuples inserted deleted table respectively create table add listofattributes create table sub listofattributes view old allows access previous state table rules follows create view old select minus select add union select sub also need add rules keep information date constraint checking phase use one rule extracts transition information two rules needed cleanup auxiliary tables constraint checking finished evaluation rules synchronized remaining rules using precedes follows clauses create rule old inserteddeletedupdated insert sub select deleted union distinct select oldupdated insert add select inserted union distinct select newupdated precedes list rules using old create rule del add add inserted delete add follows c create rule del sub sub inserted delete sub follows c rules tables used merely extract transition information end transactionduring execution transaction transition information managed dbms fixed simple changes syntax rule language note also tables add sub cleared end constraint checking phase thus always empty transaction ultimately commits allows store temporary storage may improve efficiency system constraints vi olated whole transaction aborted transition tables emptied system automatically example 10 constraint example 6 similarly ideal case one rule created enforce toplevel constraint create rule c commit inserted 9xr ff 1 rollback work two rules created maintain auxiliary relations note rules connected additional auxiliary table commit needed case null transactions see example 7 create rule ff 1 commit inserted insert r ff 1 precedes c create rule ff 2 commit inserted delete r ff 2 insert r ff 2 precedes addition system generates rules maintain contents auxiliary transition tables tupleoriented rule systems case tupleoriented systems like ingres access previous state database relations provided using transition information similarly starburst case however transition information maintained additional rules auxiliary transition tables 1 also starbursts capability order individual rules compiled explicit sequence ingres statements code produced rule generator looks follows 1 every table database auxiliary rela tions pair additional auxiliary transition tables looks similar add sub tables introduced case starburst rules however starburst case tables used overcome syntactic restrictions rule system transition information maintained dbms case ingres tables essential mimick starbursts internal capabilities chomicki toman implementing temporal integrity constraints using active dbms 7 storing transition information needed create table add attributes create table sub attributes contents tables maintained using ingres rules triggered insertion deletion update operations table rules maintain contents transition relations duration whole transaction effectively duplicates transition information managed dbms case aborted transactions however assuming small changes base relations every transaction size duplicated information significant compared size whole database ingres rule language rules connected single database procedure rules come pairs corresponding database procedures create procedure tinserted attributes insert add values attributes create procedure tdeleted attributes insert sub values attributes create rule tins insert execute procedure tinserted newattribs create rule tdel delete execute procedure tdeleted oldattribs create rule tupdateins update execute procedure tinserted newattribs create rule tupdatedel update execute procedure tdeleted oldattribs end constraint checking transition tables cleaned using following rule create procedure delete add delete sub create rule tdoclean delete commit execute procedure tcleanup 2 actual code produced translation temporal constraint ie definitions auxiliary relations together toplevel constraint used body single main rule avoid need synchronization rules create procedure c declare n integer begin update r ff n update r ff 1 select true exists create rule c go insert commit execute procedure c main r ff n oe c thus update operations executed body rule correct order 3 rules generated constraints synchronized cleanup rules using following master procedure using additional auxiliary table commit create table commit integer create procedure docommit begin insert commit values 1 delete commit commit else rollback application use execute docommit statement place commit statement example 11 constraint example 6 produces following ingres procedurerule pair create procedure c declare n integer begin delete r ff 2 insert r ff insert r ff 1 select true exists create rule c go insert commit execute procedure c main code comes rules maintain contents auxiliary transition tables note separate rules individual auxiliary relations generated temporal subformulas original constraint v compilation fol formulas next issue needs addressed compile fol formulas specify toplevel constraint auxiliary relations relational algebra eventually sql done two steps first formula converted relational algebra normal form sql conversion fol formulas relational algebra based ideas presented 4 definitions carefully converted functions take advantage structure formulas working reduces number passes needed traverse input formula two leads efficient bottomup execution conversion relational algebra sql usually paid attention seems easy task turns straightforward various restrictions sql language many fig 4 bottomup computation gen con properties workarounds invented get system run ning presented version produces standard sql ie accepted commercial dbmss starburst variant system take advantage extensions sql present system sql92 standard 5 contains extensions unfortunately available dbms like ingres first order logic relational algebra normal form whole conversion consists two phases first fol formula checked safe evaluation property join anomaly detection simultaneously simplified normal form enf formulas pass phase guaranteed equivalent safe reformulation relational algebra second step simplified formula converted relational algebra normal form ranf step removes join anomalies a1 join anomaly detection set variable fg set distinct tags g stands gen c con f gen con using terminology 4 l set fi nite disjunctions atoms base relations define sets theta l annotated free variables fol formula following inductive definition operations u sets annotated free variables defined figure 4 use following notation rest paper underscore abbreviation fresh existentially quantified variable eg 9z abbreviated decision given formula f evaluable ie safe convert formula equivalent relational algebra expression based fv set follows definition 13 fol formula f called evaluable 1 f 2 subformulas 9xa f called allowed second condition replaced x f evaluable property key distinguishing formulas safely converted see 4 detailed discussion conversion formulas meet criterion may lead join anomalies unsafe reformulations original formula formulas must rejected specification language temporal constraints pasttl evaluable property extended pasttl formulas follows definition 14 pasttl formula evaluable fol translation evaluable ie toplevel constraint evaluable definitions auxiliary views evaluable well a2 conversion allowed simplified formula step done simultaneously detection evaluable property traversing term representing given formula construct sets fv together equivalent simplified formula defined follows definition 15 formula f simplified 1 conjunctions polyadic representation 2 2 disjunctions polyadic representation 3 connective may occur root formula inside conjunction 4 disjunction inside negation 5 conjunction negative formulas inside negation form 9xa b 7 subformulas form 9xa b meet requirements definition 15 convert conjunctions disjunctions given formula finite nesting binary connective replaced single polyadic connective operating list arguments chomicki toman implementing temporal integrity constraints using active dbms 9 following polyadic representation 3 gamma note separation positive negative conjuncts required definition 15 helpful enforcing requirements definition especially dealing negation use following algorithm traverse input formula determine satisfies evaluable property reject formulas simultaneously build equivalent simplified formula starting atoms using rules creating complex formulas use constructor fol connective constructors designed preserve simplified property algorithm 16 let f fol formula casesf atom ffl b atraverseatraverseb b otraverseatraverseb 9xa extraversea constructors n defined figure 5 definition constructor e complex definition 17 let simplified formula building simplified formula corresponding 9xa first check form case perform following transformation oex otherwise distinguish following cases depending variable bound quantifier 1 x free drop quantifier 2 evaluable reject 3 x c g 2 fv evaluable perform transformation obtain equivalent allowed mula transformation described 4 defined follows 9xa gamma g third component x c g element fv athis finite disjunction atoms denotes sequence existential quantifiers binding free variables g x r agfalse atoms occur g replaced false note right side transformation g r built using n e functions order preserve simplified property 3 following sections use following notation lists ffl empty list ab concatenation lists identify single elements one element lists 4 x allowed simply add quantifier remove x fv according rules building fv fv 0 sets note besides transforming formula simplified formula also compute fv fv 0 sets annotated variables figure 4 done simultaneously simplification process rules computing fv fv 0 sets match exactly structure formula fv set used detect evaluable property see definitions 17 19 lemma 18 algorithm 16 converts input formula equivalent simplified x subformulas 9xa f rejects formula evaluable induction structure input mula constructors n e preserves simplified property formulas constructed formula also simplified algorithm together definition 17 gives recipe conversion fol formula simplified formula order convert simplified formula relational algebra need perform one transformation definition 19 formula f allgen property f property easy check moreover theorem 20 let f simplified formula built atoms using n e constructors f allgen property f allowed easy see conditions definition satisfied moreover variables bound 9 satisfy requirement second part definition 9 quantifiers constructed using e using transformation able separate evaluable formulas ie formulas able eventually convert sql nonevaluable formulas convert allowed formulas rules build simplified formula guarantee free variables obtained formula range restricted a3 conversion ranf convert formula relational algebra need one conversion proper evaluation formula need propagate allgen property definition 19 subformulas formula follows remember evaluation relational algebra bottomup definition 21 subformula 0 called generating form b simplified allowed formula ranf generating subformulas allgen property lemma 22 let f allowed simplified formula converted equivalent formula f 0 ranf inductive rules applied f recursively according toplevel connective atom ranf definition ffl l n fig 5 rules bottomup construction simplified formula tables define rewrite rules allow construction complex simplified formulas first line column defines patterns ie left side rules body table defines results rewriting see algorithm 16 9xa definition e constructor variables free fv also free fv 9xa thus allgena holds assumption l let allgenl hold let x free l assume l 2 l x definition fv set formula contradiction thus allgenl implies know allgenp n guarantee members p n share property use following transformations propagate allgen property elements p also elements n follows positive conjuncts definition simplified formula know elements p either atoms unions definition fv allgen property holds atom let l element p allgenl hold variables fx g sumption whole conjunction allgen property must exist p 0 ae p k distribute p 0 l follows note distribution law guarantees equivalence original resulting formulas l offending union p 00 formulas constructed using e n preserve simplified structure formula transformation repeated elements p allgen property 4 note may end one element p moreover ffl polyadic conjunction p ffl converted single atom negative conjuncts element n n represents subformula form n meet ranf requirements need enforce allgenn using b j 4 yes might problem worst case end exponential expansion formula aab find n subset p 0 p may empty following transformation propagate allgen property n case reduce depth term one subformulas apply rules recursively term representing given simplified formula finite depth proof immediately gives us algorithm correctly converts given simplified allowed formula ranf formula b relational algebra normal form sql transformations original formula level logic finished following section conversion ranf sql statements described transformation done two steps first logic formula translated relational algebra operations relational algebra term rewritten sql b1 conversion relational algebra conversion ranf prepared everything next stepthe conversion logic formula relational algebra step make changes structure formula goal convert 1 nested existential quantifiers projection 2 disjunction set union 5 3 conjunction product theta selection oe e generalized set difference gamma difficult part also convert variable bindings set equalities columns cartesian product constants remember weve using polyadic conjunction except root formula negations hidden inside conjunctions thus dont special rule converting negation 5 need watch attribute order subformulas union done projection operator used permuting attributes necessary chomicki toman implementing temporal integrity constraints using active dbms 11 b2 relational algebra sql prepared convert relational algebra expressions previous step actual sql queries conversion due limitations sql language straightforward generally believed need carry following transformations 1 standard sql sql89 handle nested occurrences negation union inside select clauses 6 need remove subterms assigning virtual view relational algebra subterm form oe f lw w l n finite lists relations joined 2 closed fol formulas also handled immediately sql allow empty projection 0ary relations solution use single attribute auxiliary relation truet always contain one tuple true relation joined rest clause attribute selected eg 3 using formulas pasttl need access current last states database information kept conversions atoms annotated state need evaluated must convert information proper names tables views case old vi optimization translation described far produces set active rules sufficient enforce given set temporal con straints however auxiliary relations introduced translation pasttl formula fol eventually active rules increase amount data stored database section general optimization techniques allow cut overhead devel oped note optimizations used auxiliary relations used direct querying database contents irrelevant evaluating standard first order queries current state database hand information stored sufficient answering general temporal queries thus restrictions contents changes definitions affect database user think tables invisible user also deal space optimization optimization running time queries left query optimizer underlying dbms 6 starburst systems conforming sql92 standard handle nested queries directly explore two methods limiting amount data stored auxiliary relations contextbased optimization limit number tuples stored auxiliary relation analysis contexts relation used technique similar magic set transformation 16 17 18 however context temporal formulas need careful time less case information passed sideways must agree flow time cant predict future advantage method universal applicability ie dont need statistical information database algebraic optimization option use techniques based algebraic transformations used pasttl formula converted set fol formulas ie auxiliary relations introduced case laws allow move temporal connectives first order ones used transformations allow move places auxiliary relations introduced parse tree original pasttl formula careful choice transformations significantly reduce amount tuples stored relations unfortunately choice often requires obtaining additional information database like average sizes relations involved average size joins etc using optimization techniques need keep mind resulting formulas need converted relational algebra later sql thus need careful introduce constructs expressible sql especially formulas recursionfree safe reformulations 4 magic set transformation main idea transformation based following observation auxiliary relations r ff used finitely many known contexts easily determined traversing original formula analysis contexts allows restrict contents auxiliary relations relevant tuples technique general applicable auxiliary relations 7 application ie limited auxiliary relations introduced tl2fol conversion note classical application magic set transformation set horn rules 18 works completely different setting magic sets used pass partial information intended outcome bottomup evaluation rules case setting different information future states temporal database except constant relations show exploit definitions auxiliary relations create restricting conditions similar fashion also use different mechanism computing sideways information passing strategy sips 17 7 ie relations defined formula relations strategy based adornments literals atoms adornments provide conservative guidelines computing sips resulting rules evaluable rangerestricted take optimistic approach computing sips first step compute information passed sideways form formula without concerned properties approximate obtained formula regain properties necessary converting sql method also allows pass arbitrarily complex conditions eg conditions constrain one vari able like x sideways example 23 let x formula reference auxiliary relation r ff clearly tuples r ff satisfy condition affect outcome evaluation x thus assuming r ff used single place r ff rematerialized restrict tuples stored condition holds note condition timeinvariant restricting condition induced context r ff used called magic condition r ff previous example context x induced magic condition x 10 condition computed context r ff used overall magic condition auxiliary relation determined disjunction ie union conditions definition 24 magic condition let formula subformula let 0 another formula fv 0 called magic condition compute magic conditions occurrence r ff following algorithm used note need determine magic conditions leaves tree corresponding formula whereas magic information root formula passed algorithm upper level magic condition root toplevel constraint true notation let r ff auxiliary relation r ff formula defining r ff denote r ff magic condition single occurrence r ff formula magic condition restricting contents r ff ie overall magic condition respect occurrences r ff following algorithm collects information passed sideways particular leaf given mula note together formula algorithm takes another argumentthe magic condition root formula ie restricting condition already computed root given formula passed towards leaves formula algorithm 25 magic let oe fol formula case oe semantic equivalence formulas atom r ff r ff 9x atom skip correctness algorithm proved using following lemma theorem lemma 26 let bp formula atom p leaf let another formula abp j abp induction structure b theorem 27 let formula magic condition magic computes magic condition auxiliary relations leaves input sufficient prove proof induction structure corresponding structure r ff computing magic conditions contexts r ff need careful algorithm 25 computes magic condition every leaf input formula however ffl information passed sideways agree flow time ie information passed future ffl information relevantthe magic condition actually restrict contents auxiliary relation ffl transformation preserve evaluable prop erty necessary transformed formula converted relational algebra eventually sql thus often need replace computed magic condition weaker formula satisfies restric tions following theorem shows soundness replacement theorem 28 let formula subformula let 0 00 formulas set free variables induction structure prove use assumption j 0 obtain desired result theorem 28 applied magic conditions follows corollary 29 approximation let formula subformula find appropriate weaker magic condition following definition used definition 30 let fol formula let subformula called positive negative scope even odd number negations define approximation ae true positive false negative chomicki toman implementing temporal integrity constraints using active dbms 13 note safe ie timeindependent approximation used long oe approx approx oe positive negative lemma 31 let fol formula subformula let 1 2 two formulas set free variables 1 oe 2 positive negative induction structure one occurrence obviously cases oe approx fact together corollary 29 used modify original magic formula way evaluable relevant agrees flow time ff occurrence r ff formula magic condition r ff r ff agrees flow time leaves p r ff n n states database respective atoms evaluated means leaves must least old occurrence r ff unfortunately agreement sideways information passing flow time guaranteed example 33 let x ax n r ff x magic condition computed algorithm 25 r ff x ax n r ff x rematerialized time contents ax time n known reference future thus magic condition needs safely approximated order account possible values ax time n case safe approximation true first step agreement flow time achieved definition 34 flow time let r ff magic condition computed algorithm 25 definition r ff let approxm r ff condition obtained replacing leaves r ff using table figure 6 rows occurrences r ff columns leaves r ff note difference first second rows table references future replaced approximations also superscripts denoting time evaluation particular leaf modified match occurrence r ff magic condition associated thus occurrence r ff state first row table leaves labeled current wirth respect occurrence r ff label changed n leaves labeled n future similarly sequential rematerialization auxiliary relations need modify leaves case ff fi ie r fi rematerialized r ff thus actual state r fi index n gamma 1 agrees flow time respect r ff proof induction structure follows immediately lemma 31 corollary 29 order rematerialization auxiliary relations important information passed new state auxiliary relation updated yet also two auxiliary relations incomparable oe need pick going rematerialized first ie smaller oe rule system active database evaluates rules sequentially thus pick linear ordering rematerialization auxiliary relations long contains oe solves problem flow time obtained magic condition may still relevant note magic condition r ff produced algorithm always form subformulas original formula leads following definition definition 35 let r ff magic condition r ff computed algorithm 25 let r ff form subformulas conjunct called relevant r ff 1 fv 2 fv relevant r ff let r set relevant define relevantm r ff magic condition r ff used lemma 31 corollary 29 approximate subformulas original magic condition finally make sure magic condition evaluated ie evaluable property situation similar detecting evaluable property constraints difference arises nonevaluable subformula detected former case formula rejected case magic conditions always pick weaker condition evaluable note weakest conditiontrue always evaluable algorithm 36 let eval function defined algorithm 16 e constructor redefined follows let simplified formula see definition 15 form oex otherwise distinguish following cases depending variable bound quantifier 1 x free drop quantifier 2 formula evaluable replace approxa definition approx proceed case 1 note form approximate conjuncts contain x among free variables 3 x c g 2 fv formula evaluable perform transformation obtain allowed formula original definition e 4 x allowed simply add quantifier remove x fv according rules building fv fv 0 sets similarly cases approx relevant show evalm r ff magic condition r ff evaluable 14 ieee transactions knowledge r ff fig 6 dependencies flow time note input formula agrees flow time resulting formula agrees flow time well relevant eval transformations obviously preserve property application three steps evaluable magic condition agrees flow time obtained process repeated occurrence auxiliary relation individual magic conditions glued together considering occurrences r ff need distinguish two cases order apply algorithm 25 1 r ff occurs leaf parent formula ie toplevel constraint c r fi ff oe fi 2 r ff occurs leaf definition note r ff cannot occur leaf r fi fi oe ff definition 5 first case solution easy r ff leaf compute partial magic condition using algorithm 25 ie magic r fi case toplevel constraint second case intricate trying compute magic condition r ff clear condition used magic r ff magic condition r ff computed yet moreover simply use magic conditions derived parent formulas illustrated following example example 37 assume constraint 9xax3bx firstorder translation consists toplevel constraint auxiliary atom defined dropped subscript 3bx r assume try restrict contents auxiliary relation ax let p restriction r time rematerialization p n x time n dont look future following table shows example transformation acceptable fg r result constraint evaluation state n different r truecorrect result p falseincorrect result hand timeindependent relation transformation would valid simply use constant true previous example shows stronger condition used general also setting choice true would produce true magic condition occurrence r ff definition 38 timeinvariant condition let inv formula timedependent leaves 9 replaced approximations lemma 39 let r ff auxiliary relation let 0 r ff set occurrences r ff formulas r fi ff oe fi magic r ff computes magic condition r ff r ff timeinvariant condition r ff respect occurrences parent formulas using lemma 26 prove claim induction time base case trivial r 0 ff false definition 4 induction step follows directly lemma 26 example 40 consider constraint expresses employee salary less equal 0 case toplevel constraint would auxiliary relation r would defined clearly condition 0 pushed body rs definition magic conditions occurrences auxiliary relation r ff defined overall magic condition defined follows definition 41 overall magic condition let r ff auxiliary relation defined r ff let set occurrences r ff overall magic condition defined i2i magic condition every occurrence r ff follows observation i2i corollary 29 note evaluability overall magic condition guaranteed distribute 9 leaf formula ie atom timedependent extension change time current version two references auxiliary relation general handle arbitrary number references chomicki toman implementing temporal integrity constraints using active dbms 15 rewrite rule condition fig 7 algebraic transformations ext denotes set tuples satisfy relation r ff disjunction r ff thus variables free variables appear formula successful conversion sql also requires magic transformation produces set nonrecursive view definitions proved using techniques presented 17 magic conditions r ff r ff used auxiliary relations rematerialized restrict contents b algebraic transformations magic set transformation reduces amount data stored auxiliary relations transformation applied original pasttl formula converted set first order formulas influence choice auxiliary relations introduced conversion simplest case considered section iv auxiliary relations introduced places subformulas original formula rooted temporal connective necessary original formula transformed equivalent formula temporal connectives suitable places example 42 let 9x3p x auxiliary relation r 3p xy arity 2 hand auxiliary relation r 0 induced temporal subformula formula 0 39xp x arity 1 moreover clear r 0 x r thus amount stored data reduced clearly 0 equivalent transformations summarized figure 7 vii future work generality modular structure proposed compiler architecture allows easy adaptation different environments modifications usually confined single module compiler query languages introduce constructs constraint specification language capture bigger class temporal constraints example realtime constraints 2 repeated activities periodic sets etc new optimization techniques far considered spacesaving optimization techniques introduce optimizations speed evaluation given constraints note space saving techniques also help towards efficient execution deal smaller amounts data area several options 1 write specialized routines query optimiza tion transformation ranf unique optimization transformation may help reduce size final formula note cant avoid exponential explosion general 2 optimize process rematerialization auxiliary relations shown 11 12 pass easily added existing system 3 partial ordering rematerialization auxiliary relations linearized compilation linearization may yield better magic optimization ones similarly ranf case study impact different linearizations resulting code different rule systems despite problems described section ivc starburst rule system extremely well suited purposes provides setoriented rules allows specify rule priorities addition rules triggered transaction defines flow time model features utilized implementation also shown architecture also utilize tuplebased rule systems 20 essentially simulate setoriented system explicitly additional rules table mentioned constraints specification maintain also explicit transition tables performance analysis measuring performance constraint enforcement system quite complex problem clearly cost evaluating constraints running set queries end every transaction time overhead maintaining auxiliary relations space overhead however timespace overhead depends directly transactions run database length transactions amount changes database play significant role analysis moreover benchmarking method choose reference system results compared clear reference system bethere several candidates database without constraint enforcement constraint enforcement respect whole history database etc plan develop benchmarking method suitable comparing overhead performance temporal constraint enforcement systems viii conclusion seen language past temporal logic suitable specifying constraints temporal databases straightforward declarative way also shown specification translated active dbms rules guarantee enforcement constraints underlying database need additional runtime constraint monitor moreover translation process formulas checked safe evaluation property formulas meet requirement rejected system also several optimization steps performed cut overhead connected constraint checking approach expands range active database system applications without requiring changes active dbms ix acknowledgments grateful jennifer widom encouraging us use starburst supplying system thanks also go inderpal singh mumick discussions sending us phd thesis research partially supported nsf grant iri9110581 early version results paper appeared 19 ingres trademark ingres corporation r efficient checking temporal integrity constraints using bounded history encoding safety translation relational calculus queries international organization standardization iso implementing setoriented production rules extension starburst deriving production rules constraint maintenance temporal logic logic databases deductive approach deriving integrity maintaining triggers transition graphs efficiently updating materialized views maintaining views incrementally temporal triggers active databases rules temporal logic reactive concurrent systems query optimization deductive relational databases magic sets strange ways implement logic programs implementing temporal integrity constraints using active dbms ingressql reference manual unix vms operating systems tr ctr wes cowley dimitris plexousakis temporal integrity constraints indeterminacy proceedings 26th international conference large data bases p441450 september 1014 2000 avigdor gal opher etzion multiagent update process database temporal data dependencies schema versioning ieee transactions knowledge data engineering v10 n1 p2137 january 1998 leopoldo bertossi marcelo arenas cristian ferretti scdbr automated reasoner specifications database updates journal intelligent information systems v10 n3 p253280 june 1 1998 jan chomicki david toman michael h bhlen querying atsql databases temporal logic acm transactions database systems tods v26 n2 p145178 june 2001 vittorio brusoni luca console paolo terenziani barbara pernici qualitative quantitative temporal constraints relational databases theory architecture applications ieee transactions knowledge data engineering v11 n6 p948894 november 1999 jan chomicki efficient checking temporal integrity constraints using bounded history encoding acm transactions database systems tods v20 n2 p149186 june 1995 trker michael gertz semantic integrity support sql1999 commercial objectrelational database management systems vldb journal international journal large data bases v10 n4 p241269 december 2001
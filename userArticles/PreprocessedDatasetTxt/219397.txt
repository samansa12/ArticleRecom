adaptive pattern matching pattern matching important operation used many applications functional programming rewriting rulebased expert systems preprocessing patterns dfalike automaton rapidly select matching patterns single scan relevant portions input term automaton typically based lefttoright traversal patterns adapting traversal order suit set input patterns possible considerably reduce space matching time requirements automaton design adaptive automata focus paper first formalize notion adaptive traversal present several strategies synthesizing adaptive traversal orders aimed reducing space matching time complexity worst case however space requirements exponential size patterns show establishing exponential lower bounds space independent traversal order used discuss orthogonal approach space minimization based direct construction optimal dag automata finally work brings forth impact typing pattern matching particular show several important problems eg lazy pattern matching ml computationally hard presence type disciplines whereas solved efficiently untyped setting b introduction pattern matching fundamental operation number important applications functional equational programming term rewriting theorem proving applica tions patterns partially ordered assigning priorities instance languages ml 5 haskell 6 pattern occurring earlier text higher priority following applications impose priorities also handled special case matching priorities typical approach pattern matching preprocess patterns dfalike automaton rapidly select patterns match input term 1 main advantage matching automaton pattern matches identified single scan ie backtracking portions input term relevant matching purposes done time independent number patterns fig 1 shows matching automaton constructed basis lefttoright traversal patterns automaton represented tables compiled case statements state automaton corresponds prefix input term seen reaching state annotated set patterns possibly match instance state 4 corresponds inspected prefix fb x x denotes subterm yet examined state annotated pattern set f1 2 3g since cannot rule match three patterns basis prefix fb x research partially supported nsf grants ccr880573491021599110055 nys st grant rdg 90173 research completed suny stony brook matches root input term identified nonlinearity considered since even applications allow patterns failures associated symbol mismatches observed 3 gammapsi r gammapsi gammapsi r f2g f1g f3g f1g f gammapsi r r gammapsi f3g figure 1 lefttoright left adaptive automata right fx b fb fx textual order priority x denote variables pattern matching automata extensively studied well decade augustsson 1 wadler 14 describe pattern matching techniques based lefttoright traversal drawback methods may reexamine symbols potentially several times worst case may end testing pattern separately input term drawback overcome methods christian graf schnoebelen based lefttoright traversals variants thereof however space requirements become exponential size patterns one way improve space matching time engineer traversal order suit set patterns application domain refer traversals adaptive traversals automata based traversals adaptive automata traversal orders longer fixed apriori adaptive automaton must specify traversal order instance adaptive automaton shown fig 1 state labelled next argument position inspected state adaptive traversal two main advantages fixedorder traversal leftto right ffl resulting automaton smaller eg adaptive automaton fig 1 8 states compared 11 lefttoright automaton reduction factor even become exponential ffl pattern matching requires lesser time adaptive traversals fixedorder traversals furthermore fixedorder traversals cannot use priority information avoid inspection symbols irrelevant determining highest priority matches instance adaptive automaton announces match pattern 1 examining last two arguments f whereas lefttoright automaton needs inspect three arguments observe examining unnecessary runs counter goals lazy evaluation context functional programs design adaptive automata focus paper process study several important problems remained open even context automata based fixedorder traversals problems include lower upper bounds space complexity construction optimal dag automata impact typing pattern matching 11 summary results first formalize concept adaptive traversal special case namely fixed traversal orders present algorithm constructing adaptive automata ffl section 3 examine space matching time complexity show space requirements automata quite large establishing first known tight exponential lower bounds size results quite difficult obtain since proofs must independent traversal order ffl section 4 present several techniques synthesize traversal orders improve space matching time first develop important concept representative set forms basis several optimization techniques aimed avoiding inspection unnecessary symbols present quadratictime algorithm computing representative sets untyped systems whereas show computing sets np complete typed systems ffl present several powerful strategies synthesizing traversal orders intricate example show sometimes increase space matching time therefore present another strategy based selecting indices overcomes drawback huet levy 7 established importance index design optimal automata stronglysequential patterns results extend applicability indices even patterns stronglysequential ffl section 4 synthesize traversal st given traversal lefttoright inspecting index positions whenever possible using st place affect termination properties functional program programmer continue assume whereas implementation benefit significant improvements space time using ffl section 5 describe orthogonal approach space minimization based dag represen tation tightly characterizing equivalence states directly build optimal dag automaton important problem remained open 4 even lefttoright traversals ffl section 6 focus important problem index computation prioritized systems laville 9 puel suarez 11 extended huetlevys 7 index computation algorithm deal priorities however algorithms require exponential time worst case contrast present first polynomialtime algorithm index computation untyped systems furthermore also show problem conp complete typed systems therefore present powerful heuristics significantly speed process typed systems ffl work clearly brings forth impact typing pattern matching shown several important problems context pattern matching unlikely efficient algorithms typed systems whereas given polynomial time algorithms untyped systems clearly demonstrates typing makes algorithms inherently complex rather serve optimization aids pruning search space index computation suggested 9 finally implications results discussed section 7 proof details omitted main paper found appendix preliminaries section introduce notations used rest paper also present generic algorithm adaptive automata construction forms basis results presented later sections assume familiarity basic concept term use roott denote symbol appearing root term notion position used refer subterms term follows position either empty string reaches root pi p position integer reaches ith argument root subterm reached p use tp refer subterm reached p tp denote term obtained replacing subterm tp substitution maps variables terms instance tfi term obtained substituting fix every variable x instance u say u call u prefix fringe u set variable positions u use x z denote variables denote unnamed variable b c f denote nonvariables say two terms unify iff possess common instance denotes least instance ordering given topdown traversal inspects nodes term successively characterized selection function inspected prefix u chooses next position visit match set l u prefix u set patterns unify u let p denote set fringe positions u wherein least one pattern l u nonvariable adaptive fixed traversals adaptive traversal topdown traversal wherein position next visited function prefix u given set patterns l fixed traversal order p simply function p pattern say pattern l 2 l matches iff l 6 l 0 l 0 priority higher l l l say pattern match among patterns equal priority may announce match term instance one patterns ambiguous unambiguous systems set patterns l said ambiguous whenever one pattern match given term otherwise l unambiguous typed systems typed systems set allowable input terms constrained type discipline instance constraint may take form arguments function f must drawn set ft fg case terms ft allowable untyped systems untyped systems type discipline hence allowable input terms include term alphabet sigma 0 superset alphabet sigma used patterns pattern match tp nonvariable intuitively index position must examined determine pattern match eg fringe position u every pattern l u nonvariable index 21 generic algorithm build adaptive automata state v automaton remembers prefix u inspected reaching v start state suppose p next position inspected v v transitions symbols c present p l 2 l u also transition v 6 taken seeing symbol different edges generic algorithm construct adaptive automaton given observe priorities implicitly handled definition match procedure buildv u 1 let denote patterns match u 2 6 oe matchsetv state v announces match patterns 3 else 4 select function choose next position inspect 5 position inspect recorded pos field 6 symbol 9l 2 l u nonvariable c 7 create new node v c edge v v c labelled c 8 9 9l 2 l u variable p ancestor p 10 create new node v 6 edge v v 6 labelled 6 11 buildv build similar previously known algorithms christian 3 huetlevy 7 main difference build generic whereas others prespecified select function build invoked call builds start state automaton takes two parameters v specifies state automaton u specifies prefix examined reaching jm r j omega omega ae gammapsi phi 12c c 24 22 cb 124 23 21 l 3 l 1 e e e l 4 l 3 l 2 l 1 figure 2 adaptive automaton constructed build patterns shown topright priorities bottomright pos field l u shown state states labelled denote identical subtrees state v invocation build constructs subautomaton rooted v lines 6 7 8 create transitions based symbol could appear p pattern l u line 8 build recursively invoked prefix extended include symbols seen transitions created line 7 pattern l u variable p transition 6 created line 10 build recursively invoked line 11 fig 2 shows set patterns along priorities corresponding automaton constructed build automaton 25 states since states labelled identical subtrees 4 states observe positions interest recall sum sizes patterns position integer sequence encoded integer omit details encoding found implementations equals 10 using encoding symbol specified position accessed without extra overhead compared fixedtraversal orders finally observe automata generated build tree structure also representation used previous pattern matching methods popularity trees stems simplicity fact readily support case statement representation 3 space matching time complexity examine upper lower bounds independent traversal order space matching time complexity adaptive tree automata several classes patterns fig 3 summarizes results observe contribution depth automata whose upper bound space insignificant compared exponential lower bound major contribution comes breadth automata furthermore even patterns without variables ie ground terms hard reduce number states 2 whereas reducing breadth therefore rest paper use breadth measure size automaton present details lower bound proofs proofs upper bounds established along lines 4 12 space bounds given section independent 2 size pattern number nonvariable symbols class patterns lower bound upper bound lower bound upper bound space space time time unambiguous priority unambiguous priority omegagamma n ambiguous figure 3 space matching time complexity adaptive automata n jl j denote respectively number patterns sum sizes 2 average size size ith pattern6 6 6 4 b b b figure 4 example matrix b b b b figure 5 matrices representing l u states reached transitions b traversal order established using flat patterns root symbol f arbitrarily large arity shown purposes buiding either smallest size automaton one matching shortest possible time flat patterns equivalent set patterns common prefix u whose fringe size equals arity f every symbol common prefix inspected path final state follows theorem 4 section 43 automaton inspects symbols first larger automaton 31 unambiguous unprioritized patterns consider set n nonoverlapping patterns alphabet ff bg variables since flat patterns root symbol f need specify arguments therefore n patterns represented matrix n rows ith row lists arguments f ith pattern column one occurrence one occurrence b rest pair patterns l l 0 least one column wherein l l 0 different nonvariables system unambiguous fig 4 shows matrix represents four patterns fa size smallest automaton n patterns pick position ie column discriminate column contains one nonvariable positive transition ie transition b left l u without reduction problem size instance fig 4 choose column 7 inspection left problem building automaton match basis first six positions pattern words left matrix obtained fig 4 deleting last column hence problem still instance s4 hand column contains two nonvariables based symbol seen column partition n patterns two sets consisting patterns sets must discriminated hence two instances sn gamma 1 eg example inspecting position 2 results pattern sets f1 2 4g f2 3 4g shown fig 5 hence whose solution 32 unambiguous prioritized patterns derive lower bound size automaton unambiguous prioritized set patterns consider following set flat patterns textual order priority using set patterns constructed obtain lower bound space omegagamma n follows denote sn size automaton patterns form shown smallest size automaton obtained first inspecting cs first column second column shown position examined automaton thus obtained index follows lemma 4 see section 43 automaton larger automaton consider first states automaton state 6 branch leads subautomaton matching patterns therefore whose solution n noting average size patterns lower bound n 33 ambiguous patterns consider set patterns used section 32 assume priority among patterns observe automata set patterns must report matches since priority relationship among patterns used automaton prioritized system considered previous section reaching final state v simply announce match pattern highest priority among matchsetv hence automaton cannot smaller patterns priority thus arrive lower bound omegagamma n ambiguous unprioritized patterns lower bound holds even priorities allowed since automata unprioritized patterns used matching prioritized patterns manner mentioned 34 matching time one possible measure matching time average roottoleaf path length automaton measure exhibit following anomaly suppose automaton property path automaton 0 corresponding paths shorter length clearly better matching time may reflected average roottoleaf path lengths reason may several paths 0 correspond single path suppose one path p length 2 another path q length 7 also assume two paths 0 corresponding p length 3 one corresponding q length 7 note although path shorter equal length corresponding path 0 average path length 45 whereas average path length 0 43 good measure suffer anomaly average mean matching times patterns mean matching time pattern l average path length paths lead matching state l quantity 45 whereas 5 0 based measure upper lower bounds matching time given fig 3 bounds established construction used obtain space bounds synthesizing traversal orders observe build specify selection function present several techniques used combination derive selection functions improving space matching time 41 representative sets suppose v state reached seeing prefix u observe may patterns l u match announced descendant v instance consider patterns fig 2 prefix although l observe match l 4 declared 3rd argument f b case declare match higher priority pattern l 1 inspecting position behalf pattern l 4 wasteful eg inspection position 1 u useless since irrelevant declaring match l 1 avoid inspecting positions identify representative set l u minimal set consisting patterns match announced descendant v example g representative sets form core several optimizations discussed later lavilles notion accessible patterns 9 representative set contribution definition yields simple algorithm computing set definition accessible patterns yield algorithm 9 uses notion compatible patterns corresponds match set l u place accessible patterns observe also use l u place l u following optimizations may make optimizations less effective instance algorithm directly building optimal dag automata see section 5 fail identify equivalent states l u used place l u compute l u note pattern l following property need present match l identified term descendant v also identify match another pattern equal higher priority term precise definition property arrive l u repeatedly deleting patterns l however definition immediately lend decision procedure since refers infinite number instances u although set terms considered restricted finite set still lead efficient procedure since theorem 1 computing l u np complete typed systems proof therem uses reduction similar used proof theorem 9 see section 62 omit proof details untyped systems efficient method developed considering l u instances specifically theorem 2 l u computed ons time untyped systems deleting l proof first need show two characterizations l deleted equivalent easy see l satisfying second characterization also satisfy first one show l satisfies first characterization also satisfies second let l 1 l k patterns instance v l u hence l u also instance one l 1 l k consider term obtained l u instantiating variable 6 term cannot instance l unless l l u observe l serve role l 0 second characterization thus two characterizations equivalent easily seen computing l u using simpler characterization done ons time note definition l l 0 equal priority l one retained l u discarded choice affect structure automaton current state determine whether match announced l l 0 final state except choice among patterns second definition specifies l u uniquely finally note unambiguous systems l 42 greedy strategies resort greedy strategies implementing function select since dynamic programming approach take exponential time subautomata exponential size begin listing several strategies choose p 1 number distinct nonvariables p pattern l u minimized 2 number distinct nonvariables p pattern l u maximized 3 number patterns nonvariables p maximized 4 let l 1 l r match sets children v maxjl 1 j jl r j minimized 5 sigma r improving space rationale strategies follows strategy 1 locally minimizes breadth strategy 2 attempts distinguish quickly among patterns contain potentially exponential blowup since patterns variable p duplicated among children v strategy 3 minimizes number strategy 5 carries one step minimizing number duplications strategy 4 attempts minimize size largest subautomaton rooted child v since determines size automaton case blowups improving time strategy 3 also 5 minimizes number patterns inspection symbol p unnecessary strategies 2 4 observe worst case time spent matching v proportional sum sizes patterns l u quickly discriminating among patterns quantity rapidly reduced greedy strategies suffer drawback theorem 3 greedy strategies exist pattern sets automata smaller size matching time obtained making choice different given greedy strategy proof strategies 234 5 consider following set patterns equal priorities inspecting root strategies choose one positions 23 4 shown enumerating possible matching automata patterns smallest breadth number states matching time obtainable choice 20 47 425 respectively figures reduced 15 45 4 respectively choosing position 1 construction example quite intricate key idea make pattern sets f1 4 5 6g f2 4 5 6g f3 4 5 6g stronglysequential 3 whereas set containing two first three patterns one last three 3 stronglysequential systems prefix u must index 43 selecting indices propose important strategy suffer drawbacks strategies key idea select p index u show strategy yields automaton smaller size smaller matching time obtainable choice importance index known context stronglysequential systems result demonstrates applicability patterns stronglysequential specifically given subautomata rooted v selects position p construct another subautomata 0 selects index q show size matching time 0 greater construction proceeds series steps interchange order positions q another position seen immediately preceding following theorem stated without proof makes construction precise theorem 4 p q v suppose posw q every child w v order inspection p q interchanged without increasing size matching time automaton repeating interchange obtain 0 quite interesting note repetition interchange steps permitted restrictive conditions sufficient globally rearrange traversal order get 0 although theorem asserts size matching time 0 larger fig 6 shows strictly smaller 0 remark interchange steps size sometimes reduced byas much exponential factor time using arbitrary traversal orders determined compile time appropriate functional programming since termination properties program depend traversal order therefore programmer must made aware traversal order apriori given constraint show possible internally change traversal order way affect termination properties time realize advantages adaptive traversal 4 given prefix u suppose traversal order selects p next position visited said monotonic iff prefix u variable traversal selects p unless u 0 p corresponds variable position 8l 2 l u 0 traversals possess monotonicity property include known traversal orders depthfirst breadthfirst well variations without lefttoright bias particular includes fixedtraversal orders mentioned earlier lefttoright righttoleft also includes traversals used implementations stronglysequential systems given monotonic traversal obtain another traversal st inspecting indices whenever possible without affecting termination properties specifically let st denote traversal uses following strategy pick position inspect prefix u ffl u indices arbitrarily select one ffl otherwise select position fringe u first visited theorem 6 size matching time never become worse st used place path automaton using st examines subset positions examined corresponding path minimizing space using dags previous section discussed synthesizing traversal orders order improve space time discuss orthogonal approach minimize space based sharing equivalent states 4 remark transformation applicable functional languages sideeffects omega omega omega oe r f figure example illustrate size matching time reduction due transformation figure shows automata f b fa f textual order priority obvious way achieve sharing use standard fsa minimization techniques optimizing tree automaton constructed build efficient method identify equivalence two states without even generating subautomata rooted states observe tree automaton may exponentially larger dag automaton case naive approach uses exponential time space whereas direct construction potentially use polynomial space polynomial time important problem directly building optimal automata even restricted lefttoright traversals remained open 4 propose solution problem identify equivalent states suppose two prefixes u 1 u 2 representative set l u differ positions p every pattern l u variable p since positions irrelevant determining match two prefixes equivalent hand also shown different representative sets differ position equivalent based observation define relevant prefix u term obtained replacing subterms positions p symbol 6 instance prefixes corresponding different states marked fig 2 different relevant prefix fx 6 b showing two states equivalent iff corresponding relevant prefixes identical theorem 7 automaton obtained merging states identical relevant prefixes optimal merging equivalent states described substantially reduce space required automata eg tree automaton fig 2 25 states reduced 16 sharing also recall patterns fig 4 parts automaton reached positive transitions alone exponential show sharing states part automaton become polynomial 51 impact dags space matching time complexity since sharing affects space requirements alone results established far relating space theorem 6 time continue hold dags well follows discuss impact dags results established earlier regarding space show upper bound size dag automata o2 n much smaller corresponding bound automata also establish lower bound o2 n ambiguous patterns unambiguous patterns clear whether lower bound size exponential instance appears patterns used lower bound proof size tree automata unambiguous patterns possess polynomialsize dag automaton reasoning lower bounds becomes extremely complicated dags since difficult capture behavior sharing formally finally greedy strategies well strategy selecting indices cases increase space dag automata failure index selection strategy demonstrates complexity sharing recall index prefix u position fringe must inspected announce match pattern l u absence priorities positions must inspected announce match pattern l exactly fringe positions wherein l nonvariable priorities however may inspect positions wherein l variable order rule match higher priority patterns obvious variable position l must inspected clear compute indices prioritized systems therefore laville 8 proposed indirect method index computation first transforms prioritized patterns equivalent set unprioritized patterns used index computation pattern l transformation generates set l instances instances higher priority pattern typed systems instances observe type discipline generated transformed system l2l l puel suarez 11 developed compact representation sets l based notion constrained terms terms constraints placed substitutions taken variables instance constrained term feqx yjx 6 6 bg denotes set terms precise semantics constrained terms given first regarding term variables denoting set instances constrained term ftjg denotes set instances also satisfy constraint formula define constraint formula first define atomic constraint form 6 form x 6 x variable variables unnamed 5 former case terms satisfy constraint must belong set gamma latter case substitution taken x must instance arbitrary constraint obtained combining atomic constraints using constraint satisfied terms satisfy either similarly constraint satisfied terms satisfy well finally note typed systems always implicit constraint imposed type discipline requires variable substituted term type variable henceforth may use several methods simplify constrained terms methods quite intuitive correctness readily follows semantics using constrained terms set l represented compactly fljl patterns priority greater l constraints l 6 l simplified constraints variables l simplify constraint l 6 l 0 first check two patterns unify constraint simplifies true otherwise let x variables l substituted nonvariable terms say unifying l l 0 simplified constraint using procedure simplification constraints pattern l done os time illustration consider following example defines equality enumerated data type 5 prevent constraints x 6 ay 6 b complicate development materials rest section note two among first n patterns unify condition vacuously hence first n patterns appear unchanged transformed system last rule however unifies every rule gets translated condition ith disjunct prevents instances ith pattern recognized instances last rule seen constraints cnf clear indices obtained puel suarez simplify dnf makes structure terms set denoted constrained term apparent instance constrained term simplifies note typed systems constraints x 6 1 x 6 2 simplified false constraint simplifies x 6 1 6 2 constrained term dnf indices prefix u wrt c easily picked follows firstly variable position u wherein nonvariable symbol index u secondly consider variable position p wherein variable x constraint substitution x appears every conjunct note term instance constrained term must satisfy one constraints 1 since x appears every one conjuncts substitution must examined order determine whether term satisfies constraint therefore positions also indices u conversion constraint pattern l cnf dnf expensive take ojlj n time therefore puel suarezs algorithm based conversion exponential time complexity typed untyped systems lavilles algorithm also exponential typed untyped systems contrast present first polynomialtime algorithm untyped systems operates directly original patterns 61 algorithm index computation untyped systems index prefix computed two steps first compute set indices prefix wrt constrained patterns l u intersection sets thus computed yields indices prefix wrt l u compute indices prefix u wrt single constrained pattern l follows patterns l u priority l also unify l following two steps specify indices u wrt l 1 variable x u l nonvariable position corresponding x 2 variable x must position instantiated l tu determine match higher priority pattern l j remark similar algorithm suggested laville heuristic fast index computation however question power completeness heuristic addressed illustrate algorithm l textual order priority prefix z observe x z indices l 1 step 1 index l 2 x step 1 observe step 2 yield additional indices l 2 l 3 z index step 1 x index step 2 l intersection positions x therefore index u index computation takes time using algorithm show theorem 8 algorithm computing indices untyped systems sound complete proof need establish algorithm computes indices u wrt constrained pattern l clearly position computed using step 1 index wrt l c position selected using step 2 observe constraint l 6 l j simplify x 6 term constraint appear every conjunct dnf fl positions selected step 2 thus indices l c completeness need show position p u selected steps 1 2 index l c accomplished giving instance l c variable p suppose p selected step 1 step 2 l must case either l p variable one position fringe l u need instantiated determining match l either case disjunct obtained simplifying l 6 l contains least one literal different lp consider obtained l u substituting 6 x mentioned note substitutions variables l u satisfies constraints l c hence instance l still variable p proves p index u typed systems unlikely escape exponential complexity since show intuition reason complexity gap typed untyped systems draw analogy index computation constrained terms satisfiability problem note literals constraints generated puel suarezs algorithm form x 6 x variable arbitrary term constrained terms analogous boolean formulas negative literals boolean formulas trivially satisfiable truth assignment assigns false every literal similarly index computation simple untyped systems however typed systems implicit positive constraints introduced type discipline instance implicit constraint constrained term 1 thus constraint contains positive negative literals constrained term analogous boolean formula positive negative literals hence complexity gap proof index selection problem posed decision problem takes form u possess index wrt pattern set l show problem conp need show problem deciding whether p index np let r set fringe nodes u first guess r instances u p variable r verify instance least one patterns l declare u index clearly accomplished polynomial time hence problem determining whether u possess index np index selection problem conp show problem conp complete reduce complement satisfiability problem let instance satisfiability problem disjunct literals form x x x 2 fx g transform index computation problem following system consisting n 1 patterns textual order priority roots patterns symbol f stands common prefix shared patterns arguments last arguments f type consists nonvariables b n 1th pattern form fx specify first n terms unify also assume term type unify terms specify ith pattern 1 b depending upon whether x j x j occurs neither occur j variable observe size pattern set polynomial size construction show determining whether index equivalent determining whether first transform pattern set set constrained patterns following transformation n 1th pattern becomes slightly abused notation replacing x j 6 x j x j 6 b ie x j 6 type discipline x j using heuristic 1 constraint simplified shows fx 0 xm index namely x 0 iff input sat problem satisfiable 63 heuristics fast index computation typed system suppose constrained term form disjuncts contain occurrences x suppose exists term valid type x equal rule 1 indices obtainable constraint exactly obtainable constrained term terms valid type x rule 2 consists single variable index power rule 1 evident fact order apply need identify variable x constraints x simplify false 6 x identified avoid expanding fl 2 n terms instead concern two terms expansion namely illustrate power rule 2 consider constrained term 1 note x 6 1 x 6 simplifies false form 6 also contain 6 saying reduces false mean satisfiable ie contradiction one variable hence index interchanging role x also note x index note computing indices taken time linear sum sizes rules contrast puel suarezs algorithm spends exponential time reducing constraint dnf proof correctness rule 1 expanding fl taking conjunction ffi get ffl disjunction terms containing least one constraint x first term expansion constrains x therefore variable x appears index unless appears every conjunct dnf ffi furthermore since x apears terms expansion except fl 0 clear x index iff fl 0 reduces false exactly captured considering x proof rule 2 expand fl eliminate term reduces false observe every conjunct expansion contains least one form 6 conjunct dnf constrain index 7 concluding remarks paper studied pattern matching adaptive automata presented lower upper bounds worstcase size automata several classes patterns discussed improve space matching time synthesizing traversal orders showed good traversal order selects indices whenever possible uses one greedy strategies especially strategy 4 5 otherwise although greedy strategies may sometimes fail appears complexity counter examples failures may rare functional programming synthesized traversal st monotonic traversal since using st affect termination properties programmer assume whereas implementation benefit significant improvements space matching time also discussed orthogonal approach space minimization sharing equivalent states recall even index selection strategy may fail improve space dag automata occurs index selection may adversely affect way descendants state shared since difficult predict sharing among descendant states possibility improving space without using indices appear practical best approach use strategies section 4 use sharing additional source space optimization tree automata work clearly brings forth impact typing prioritized pattern matching shown several important problems context pattern matching unlikely polynomialtime algorithms typed systems whereas given polynomialtime algorithms untyped systems raises question whether worthwhile consider typing pattern matching clear often typing information used find index determine pattern belong l u cannot found otherwise hand significant penalty terms computational effort problems use typing information r complexity trie index construction definition standard ml report haskell computations nonambiguous linear term rewriting systems lazy pattern matching ml language implementation lazy pattern matching algorithms fast parallel implementation functional languages equals experience refined compilation pattern matching functional languages tr 1491 efficient compilation pattern matching tr ctr nadia nedjah minimal deterministic lefttoright patternmatching automata acm sigplan notices v33 n1 january 1998 nadia nedjah luiza de macedo mourelle efficient concise deterministic patternmatching automata ambiguous patterns acm sigplan notices v37 n2 february 2002 per gustafsson konstantinos sagonas efficient manipulation binary data using pattern matching journal functional programming v16 n1 p3574 january 2006 r sekar v ramakrishnan andrei voronkov term indexing handbook automated reasoning elsevier science publishers b v amsterdam netherlands 2001
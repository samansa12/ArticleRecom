simple confluently persistent catenable lists consider problem maintaining persistent lists subject concatenation insertions deletions ends updates persistent data structure nondestructiveeach operation produces new list incorporating change keeping intact list lists applies although general techniques exist making data structures persistent techniques fail structures subject operations catenation combine two versions paper develop simple implementation persistent doubleended queues deques catenation supports deque operations constant amortized time implementation functional allow memoization b introduction last fteen years considerable development persistent data structures current version also older ones available access partial persistence updating full per sistence particular driscoll sarnak sleator tarjan 5 developed ecient general methods make pointerbased data structures partially fully persistent dietz 3 developed ecient general method make arraybased structures fully persistent general methods support updates apply single version structure time accommodate operations combine two dierent versions structure set union list catenation driscoll sleator tarjan 4 coined term con uently persistent fully persistent structures support combining operations alternative way obtain persistence use purely functional programming take extremely strict view pure functionality disallow lazy evaluation memoization techniques listbased data structure design purely functional programming amounts using lisp functions cons car cdr purely functional data structures automatically persistent indeed con uently persistent simple important problem data structure design makes issue con uent persistence concrete implementing persistent doubleended queues deques catenation series papers 2 4 culminated work kaplan tarjan 11 10 developed con uently persistent implementation deques catenation worstcase constant time space bound deque operation including catenation kaplantarjan data structure precursors obtain con uent persistence purely functional department computer science tel aviv university tel aviv 69978 israel haimkmathtauacil department computer science columbia university new york ny 10027 research carnegie mellon university supported advanced research projects agency csto title fox project advanced languages systems software arpa order c533 issued escens contract f1962895c0050 cokasakicscolumbiaedu z department computer science princeton university princeton nj 08544 intertrust technologies corporation sunnyvale ca 94086 research princeton university partially supported nsf grant ccr9626862 retcsprincetonedu one cares persistence purely functional programming unnecessarily restrictive particular okasaki 14 15 16 observed use lazy evaluation combination memoization lead ecient functional purely functional sense data structures con uently persistent order analyze structures okasaki developed novel kind debitbased amortization using techniques weakening time bound worstcase amortized able considerably simplify kaplantarjan data structure particular eliminate complicated skeleton encodes tree extension redundant digital numbering system paper explore problem simplifying kaplantarjan result obtain con uently persistent implementation deques catenation constant amortized time bound per operation structure substantially simpler original kaplantarjan structure even simpler okasakis catenable deques whereas okasaki requires ecient persistent deques without catenation building blocks structure entirely selfcontained furthermore analysis uses standard creditbased approach give two alternative closely related implementations method rst uses memoization second saves small constant factor time space uses extension memoization expression replace equivalent expression remainder paper consists sections section 2 introduce terminology concepts section 3 illustrate approach developing persistent implementation deques without catenation section 4 extend approach handle stacks catenation section 5 develop solution deques catenation conclude section 6 remarks open problems extended abstract work appeared 9 2 preliminaries objects study lists 11 10 allow following operations lists return new list containing single element x return new list formed adding element x front list l popl return pair whose rst component rst element list l whose second component list containing second last elements l return new list formed adding element x back list l return pair whose rst component list containing last element l whose second component last element l catenatel r return new list formed catenating l r l rst seek implementations operations specic subsets persistent lists operation allowed previously constructed list lists time discussions various forms persistence see 5 stack list push pop allowed queue list inject pop allowed steque stackended queue list push pop inject allowed finally deque doubleended queue list four operations push pop inject eject allowed four structures may may allow catenation catenation allowed push inject become redundant since special cases catenation sometimes convenient treat separate operations easier implement general catenation say data structure purely functional built manipulated using lisp functions car cons cdr structure consists set immutable nodes either atom node containing two pointers nodes cycles pointers nodes use build structures actually contain xed number elds reducing structures two elds per node adding additional nodes straightforward various nodes structure represent lists obtain results extend pure functionality allowing memoization function evaluated node second time function evaluated node value simply retrieved previous computation constructions constant number memoized functions one two implement memoization node point results applying memoized function initially pointer undened rst function evaluation lls appropriate pointer indicate result subsequent evaluations merely follow pointer result takes time also consider use substantial extension pure functionality allow operation replacing node structure another node representing list replacement performed imperative setting replacing elds node instance lisp using replaca replacd replacement viewed generalization memoization structures node replaced twice means structures implemented writeonce memory easy convert algorithm overwrites eld xed constant number times writeonce algorithm constantfactor loss eciency use overwriting instead memoization saves small constant factor running time storage space slightly simplies amortized analysis perform amortized analysis use standard potentialbased framework assign conguration data structure totality nodes currently existing potential dene amortized cost operation actual cost plus net increase potential caused performing operation applications potential empty structure zero potential always nonnegative follows sequence operations starting empty structure total actual cost operations bounded sum amortized costs see survey paper 17 complete discussion amortized analysis 3 noncatenable deques section describe implementation persistent noncatenable deques constant amortized time bound per operation structure based analogous kaplantarjan structure 11 10 much simpler result presented illustrates technique amortized analysis persistent data structure end section comment relation structure proposed previously existing solutions 31 representation subsequent sections say data structure set stores elements representation recursive built boundedsize deques called buers containing three ele 4 h kaplan c okasaki r e tarjen ments buers two kinds prexes suxes nonempty deque represented ordered triple consisting prex denoted prd possibly empty child deque ordered pairs denoted cd sux denoted sfd pair consists two elements child deque cd nonempty represented way dene set descendants deque standard waynamely c 0 exist order elements deque dened recursively one consistent order triple buer pair child deque thus order elements deque rst elements prd elements pair cd nally elements sfd general representation deque uniquethe sequence elements may represented triples dier sizes prexes suxes well contents representations descendant deques whenever refer deque actually mean particular representation one clear context pointer representation representation obvious one node representing deque contains pointers prd cd sfd note pointer structure essentially linked list descendants since c contains pointer c i1 32 operations implementing deque operations straightforward except maintaining size bounds buers specically push deque easy unless prex size three pop deque easy unless prex empty symmetric statements hold inject eject deal buer ow ow proactive fashion rst xing buer operation performed cannot violate size bounds actually operation details follows dene buer green contains one two elements red contains zero three dene two memoized functions deque gp constructs representation list green prex gs constructs representation list green sux apply gp gs respectively list whose prex sux red made green specically gp prex empty child deque must nonempty symmetrically gs give implementations push pop gp implementations inject eject gs symmetric denote deque prex p child deque c sux p c mentioned section 2 implement memoization gp gs node point nodes resulting applying gp gs initially pointers undened prd empty cd let nonempty let x return pair x p ce sfe otherwise ce must empty let x return pair x z three elements prd let p prex containing x let c prd empty cd let x prex containing x followed return p 33 analysis amortized analysis method relies memoization gp gs call node representing deque secondary returned call gp gs primary otherwise secondary node constructed call gpx gsx respectively way access later via another call gpx gsx respectively secondary node returned result push pop inject eject operation means gp gs called primary nodes devide nodes representing deques three states node rr buers red gr exactly one buers red gg buers green subdivide rr gr states rr node rr0 neither gp gs applied rr1 exactly one gp gs applied rr2 gp gs applied gr node gr0 neither gp gs applied gr1 otherwise discussion every secondary node gr0 gg dene rr0 rr1 gr0 numbers primary nodes states rr0 rr1 gr0 respectively dene potential collection nodes representing deques 4rr0 call push either terminal results call gp turn calls push similarly call pop either terminal results call gp turn calls pop charge o1 time spent call gp exclusive inner call push pop push pop calls gp call push results sequence recursive calls push via calls gp bottommost terminal rest nonterminal nonterminal push one following eects converts primary rr0 node rr1 creates new primary gr0 node result push new secondary gr0 node result call gp converts primary rr1 node rr2 creates new primary gr0 node new secondary gr0 node converts primary gr0 node gr1 creates new primary gg node new secondary gg node case total potential drops one paying time needed push excluding recursive call terminal push takes o1 time creates o1 new nodes increases potential o1 conclude push takes o1 amortized time analogous arguments apply pop inject eject giving us following theorem theorem 31 operations push pop inject eject dened takes o1 amortized time 34 implementation using overwriting memoized implementation described primary rr node give rise two secondary gr nodes representing list primary gr node give rise secondary gg node representing list redundant representations exist simultanously gr representation however dominates rr representation performing deque op erations gg representation dominates gr representation allows us improve eciency implementation using overwriting place memo ization gp called node overwrites contents node results gp computation similarly gs one representation list exists time evolves rr gr gg via one two alternative paths depending whether gp gs called rst node needs three elds prex child deque sux instead two extra gp gs use overwriting save constant factor running time storage space also simplies amortized analysis follows dene rr gr number nodes states rr gr respectively secondary nodes dene potential collection nodes 3rr gr nonterminal push one following eects converts rr 6 h kaplan c okasaki r e tarjen node gr creates new gr node converts gr node gg creates new gg node either case reduces potential one paying o1 time required push excluding recursive call terminal push takes o1 time increase potential o1 conclude push takes o1 amortized time similar arguments apply pop inject eject 35 related work structure described based kaplantarjan structure 10 section 4 simplies three ways first skeleton structure sequence descendants stack kaplantarjan structure skeleton must partitioned stack stacks order support worstcase constanttime operations via redundant binary counting mechanism second recursive changes structure make nodes green onesided instead twosided original structure stackofstacks mechanism requires coordination keep sides structure related states third maximum buer size reduced three special case steque maximum size sux reduced two special case queue prex sux reduced maximum size two alternative much older approach uses incremental recopying obtain persistent deques worstcase constanttime operations see 7 discussion approach incremental recopying approach yields arguably simpler structure one presented structure generalizes allow catenation one knows implement eciently using incremental recopying also structure extended support access insertion deletion positions away end list olog amortized time applying ideas 12 4 catenable steques section show extend ideas support catenation specically describe data structure catenable steques achieves o1 amortized time bound push pop inject catenate data structure based recursive decomposition lists section 5 10 pointer structure need much simpler 10 analysis amortized following framework outlined section 2 used section 3 41 representation structure similar structure section 3 slightly dierent denitions component parts section 3 use buers two kinds prexes suxes prex contains two six elements sux contains one three elements nonempty steque represented either sux sfd ordered triple consisting prex prd child steque cd pairs sux sfd contrast section 3 pair dened ordered pair containing prex possibly empty steque pairs observe denition adds additional kind recursion pairs store steques structure section 3 extra kind recursion allows ecient catenation order elements steque one consistent order triple buer pair steque within pair child steque section 3 many dierent representations steque containing given list elements speaking steque mean particular representation pointer structure representation straightforward triple represented node containing three pointers prex child steque sux pair represented node containing two pointers prex steque 42 operations implementation steque operations much like implementation noncatenable deque operations presented section 32 call prex red contains either two six elements green otherwise call sux red contains three elements green otherwise prex suxonly steque considered color sux dene two memoized functions gp gs produce greenprex greensux representations steque respectively called corresponding buer red made green dene push pop inject call gp gs necessary obtain green buer denitions represent steque prex child steque c sux p c case 1 steque represented triple case 2 steque represented sux create prex p containing x rst two elements sfd create sux containing last element sfd return p otherwise create sux pushing x onto sfd return case 1 steque represented triple case 2 steque represented sux create sux containing x return sfd otherwise create sux injecting x sfd return case 1 1 2 represented triples first catenate buers sfd 1 prd 2 obtain p calculate c 0 follows jpj 5 let c 9 create two new prexes p 0 containing rst four elements p p 00 containing remaining elements let c either case return case 2 1 2 represented sux push inject elements suxonly steque onebyone steque note push catenate produce valid steques even second arguments steques prexes length one although steques normally allowed may exist transiently pop every steque immediately passed push catenate discarded however order dene pop gp gs operations dene n aivepop operation simply pops steque argument without making sure result valid steque represented triple let x return consists sux let x pair x case 1 steque represented sux jprdj 2 return n aivepopd case 2 steque represented triple x rst element prd second jsfdj 3 push onto sfd form 8 h kaplan c okasaki r e tarjen return x otherwise jsfdj 3 form p rst two elements sfd form last element sfd return x p case 3 steque represented triple create two new prexes p p 0 splitting prd equally two let c cd 6 proceed follows inspect rst pair p 0 cd jpj 4 0 empty let p 0 inspect p case 1 p contains least four elements pop rst two elements p form inject two elements prd obtain p 0 let c return case 2 p contains three elements push two elements prd onto p obtain p 0 let c nonempty c return steque represented triple contain rst two elements sfd last element sfd let c return 43 analysis analysis method similar analysis section 33 dene primary secondary nodes node states potential function exactly section 33 potential function 4rr0 rr0 rr1 gr0 numbers primary nodes states rr0 rr1 gr0 respectively section 33 charge o1 cost call gp gs excluding cost recursive call push pop inject push pop inject calls gp gs amortized costs push inject o1 argument identical used analyze push section 33 operation catenate calls push inject constant number times creates single new node amortized cost also o1 analyze pop assume call pop recurs depth k via intervening calls gp argument analogous push rst k 1 calls pays decreasing potential one terminal call pop result call either push catenate o1 amortized cost follows overall amortized cost pop o1 giving us following theorem theorem 41 operations push pop inject catenate dened takes o1 amortized time improve time space eciency steque data structure constant factors using overwriting place memoization exactly described section 34 also simplify amortized analysis exactly described section 34 44 related work structure presented section analogous kaplantarjan structure 10 section 5 structure 8 section 7 simplies follows first buers constantbounded size whereas structure 10 section 5 uses noncatenable steques buers structure 8 section 7 uses noncatenable stacks buers buers turn must represented section 3 paper using one methods mentioned contrast structure present section entirely self contained second skeleton present structure stack instead stack stacks 10 8 third changes used make buers green applied onesided needdriven way 10 8 repairs must made simultaneously sides structure carefully chosen locations okasaki 14 devised dierent somewhat simpler implementation con uently persistent catenable steques also achieves o1 amortized bound per operation solution obtains eciency implicitly using form path reversal 18 addition lazy evaluation memoization structure extends doubleended case shall see next section whether okasakis structure extends case open problem 5 catenable deques section show extend ideas support list operations specically describe data structure catenable deques achieves o1 amortized time bound push pop inject eject catenate structure based upon analogous structure okasaki 16 simplied use constantsize buers 51 representation use three kinds buers prexes middles suxes nonempty deque represented either sux sfd 5tuple consists prex prd left deque triples ldd middle mdd right deque triples rdd sux sfd triple consists rst middle buer deque triples last middle buer one two middle buers triple must nonempty triple contains nonempty deque middles must nonempty buers triples prex sux 5tuple contains three six elements sux suxonly representation contains one eight elements middle 5tuple contains exactly two elements nonempty middle buer triple contains two three elements order elements deque one consistent order 5tuple buer triple recursive deque pointer structure straightforward nodes representing 5tuples triples containing one pointer eld 52 operations call prex sux 5tuple red contains either three six elements green otherwise call sux suxonly representation red contains eight elements green otherwise prex suxonly deque considered color sux introduce two memoizing functions functions gp gs sections 32 42 produce greenprex greensux representations deque respectively called corresponding buer red made green give implementations push pop gp catenate implementations inject eject gs symmetric push pop gp respectively denote deque prex p left deque l middle right deque r sux p l case 1 deque represented 5tuple otherwise let case 2 deque represented sux sfd 8 return suxonly deque sux pushx sfd otherwise push x onto sfd form nine elements create new prex p rst four middle next two sux last three return p section 42 implementation pop uses n aivepop case 1 deque represented sux jprdj 3 return n aivepopd case 2 case 3 x rst element prd create new sux containing elements prd mdd sfd except x return pair consisting x deque represented otherwise form p prd popping x injecting rst element mdd 0 mdd popping rst element injecting rst element sfd form sfd popping rst element return x create two new prexes p p 0 p containing rst four elements jprdj p 0 last two return p pushp proceed follows case 1 ldd 6 inspect rst triple ldd either rst nonempty middle buer contains 3 elements contains nonempty deque let assume x nonempty consists one nonempty middle buer apply appropriate one folowing two subcases case 11 3 form x 0 x p prd popping rst element x injecting prd return case 12 2 inject elements x prd form p 0 empty return p l mdd rdd sfd otherwise 0 nonempty let l case 2 inspect rst triple rdd either rst nonempty middle buer contains 3 elements contains nonempty deque let assume x nonempty consists one nonempty middle buer apply appropriate one following two subcases case 21 x 0 prd x popping element injecting prd form p popping element injecting rst element x form 0 popping rst element x form x 0 return case 22 2 inject two elements mdd prd form p let empty r return case 1 1 2 represented 5tuples let rst element prd 2 let x last element sfd 1 create new middle containing x followed partition elements sfd 1 fxg two buers 0 1 1 containing two three elements order 00 possibly empty let ld 0 ld 00 otherwise let ld 00 ld 0 1 similarly partition elements prd 1 fyg two prexes containing two three elements order possibly empty let rd 0 2 return prd 1 ld 00 case 2 1 2 represented sux push inject elements suxonly deque onebyone deque 53 analysis analyze structure use denitions potential function sections 33 43 amortized costs push inject catenate pop o1 argument analogous section 43 amortized cost eject o1 argument symmetric pop thus obtain following theorem theorem 51 operations push pop inject eject catenate dened takes o1 amortized time sections 34 43 improve time space constant factors simplify analysis using overwriting place memoization overwriting preferred implementation unless one using functional programming language supports memoization easily allow overwriting 54 related work structure presented section analogous structures 16 chapter 11 8 section 9 simplies follows first buers constant size whereas 16 8 noncatenable deques second skeleton present structure binary tree instead tree extension redundant digital numbering system 8 also amortized analysis uses standard potential function method 17 rather complicated debit mechanism used 16 another related structure 10 section 5 represents purely functional realtime deques pairs triples rather 5tuples otherwise similar simpler structure 8 section 9 straightforward modify structure presented use pairs triples rather 5tuples 6 results open questions universe elements deques constructed total order extend structures described support additional heap order based order specically support additional operation nding minimum element deque deleting preserving constant amortized time bound every operation including nding minimum merely store buer deque pair triple minimum element related work see 1 2 6 13 also support ip operation deques ip operation reverses linear order elements deque ith front becomes ith back viceversa noncatenable deques section 3 implement ip maintaining reversal bit ipped ip operation reversal bit set push becomes inject pop becomes eject inject becomes push eject becomes pop support catenation well ip use reversal bits levels must also symmetrize denition section 5 allow deque represented prex extend various operations handle possibility interpretation reversal bits cumulative deque x deque inside x regarded reversed odd number reversal bits set 1 along path actual pointers structure node node x performing catenation reversal bit either two deques 1 push bits ipping bit deque x 0 ipping bits deques x points swapping appropriate buers deques prex sux exchange roles left deque right deque order elements prex sux reversed well pushdowns reversal bits assembling new deques overwriting old ones devised alternative implementation catenable deques sizes prexes suxes 3 5 instead 3 6 memoizing pop eject operations avoiding creating new structure green prex sux respectively representing original deque performing pop eject respectively using complicated potential function ones used earlier sections show implementation runs o1 amortized time per operation one direction future research nd way simplify structures fur ther specically consider following alternative representation catenable de ques uses single recursive subdeque rather two subdeques nonempty deque represented triple consists prex prd possibly empty child deque triples cd sux sfd triple consists nonempty prex deque triples nonempty sux nonempty prex sux buers triples operations push pop inject eject implementations similar implementations section 5 major dierence implementation catenate structure requires call pop specically let 1 2 two deques catenated catenate pops cd 1 obtain triple p new deque c injects c sfd 1 obtain 00 pushes p 00 prd 2 nal result prex prd 1 child deque c 0 sux sfd 2 open question whether algorithm runs constant amortized time per operation constant upper lower bounds buer sizes another research direction design con uently persistent representation sorted lists accesses updates positions either end take olog time catenation takes o1 time best structure far developed problem doubly logarithmic catenation time 12 purely functional time bounds worstcase acknowledgment thank michael goldwasser detailed reading paper jason hartline discussions led implementations using memoization r data structural bootstrapping con uently persistant deques via data structural boot strapping fully persistent arrays fully persistent lists catenation making data structures persistent deques heap order lists phd thesis simple con uently persistent catenable lists ex tended abstract optimal ram implementation catenable min doubleended queues amortized computational complexity worst case analysis set union algorithms tr ctr amos fiat haim kaplan making data structures confluently persistent journal algorithms v48 n1 p1658 august george lagogiannis yannis panagis spyros sioutas athanasios tsakalidis survey persistent data structures proceedings 9th wseas international conference computers p16 july 1416 2005 athens greece
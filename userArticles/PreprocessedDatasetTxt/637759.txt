experiences modeling simulation computer architectures devs use traditional approaches teach computer organization usually generates misconceptions students simulated computer alfa1 designed fill gap devs used attack complex design chosen architecture allowing definition integration individual components devs also provided formal specification framework allowed reduction testing time improvement development process using alfa1 students acquired practice design implementation hardware components usually achievable computer organization courses b figure 1 organization integer unit risc processor provided 520 integer registers eight global regglob shared every procedure remaining 512 divided windows 24 registers regblock window includes input output local registers every procedure executed recently routine begins new registers reserved 8 local 8 output 8 output records calling procedure used inputs specialized 5bit register called cwp circular window pointer marks active window every time new procedure starts cwp decremented figure 2 organization processors registers besides general purpose registers architecture includes pcs processor two program counters pc contains address next instruction stores address pc execution present instruction instruction cycle finishes copying npc pc adding 4 bytes one word npc instruction conditional branch npc assigned pc npc updated jump address jump condition valid used product division operations base size memory considered flat neither segmentation pagination mechanisms included likewise multiprogramming supported base register points lowest address program access size stores maximum size available program psr processor status register stores current status program interpreted follows bits content description reserved negative 1 result last operation negative 22 z zero 1 result last operation zero result last operation overflow result last operation carried one bit 1912 reserved lowest interrupt number serviced 6 ps previous state last mode enable trap 1traps enabled 0traps disabled current window pointer points current register window table 1 contents process status register wim window invalid mask 32bit register one bit per window used avoid overwriting window use another procedure cwp decremented circuits verify wimbit active new window case interrupt raised interrupt service routine stores content window memory usually wimonly one bit 1 marking oldest window tbr trap base register points memory address storing position trap routine bits content description base address base address trap table 114 trap type trap serviced 30 constant 0000 table 2 contents trap base register first 20 bits trap base address store base address trap table interrupt request received number trap serviced stored bits 114 therefore tbr points table position containing address service routine last 4 bits 0 guarantees least 16 bytes store routine instruction set level sparc architecture analyzed see instruction fixed size 32 bits memory operands may 8 16 32 bits basic loadstore operations classified according size sign operands arithmetic boolean operations include add div mul xor xnor shift able change psr according operation code used several jump instructions available including relative jumps absolute jumps traps calls return traps instructions include movement register window nops readwrite operations psr multiplication uses 32bit operands producing 64bit results significant 32 bits stored register remaining alures register integer division operations take 64bit dividend 32bit divisor producing 32bit result register stores significant bits divi dend one alu input register stores least significant bits dividend divisor integer result stored alures register remainder register instructions carried alu whose structure depicted following figure includes two multiplexers connected alu multiplierdivider unit shifter figure 3 organization alu two execution modes user kernel certain instructions executed kernel mode also base size registers used program running user mode cpu executes supervision control unit receives signals rest processor using 64 input bits organized 5 groups instruction register psr busbusyin busdackin buserr outputs sent using 70 lines organized 59 groups include readingwriting internal registers activating lines alu multiplexers also connections pc npc trap controller psr registers included finally data address control buses accessed memory organized using byte addressing littleendian store words processor issues memory access operation writing address data needed bus turns address strobe signal interpreted memory order start operation memory uses address available analyzes rdwr line see operation asked read issued one word 4 bytes taken specified address sent data lines write operation address stored byte select register lines bsel03 defines byte accessed word pointed address register address wrong err line turned data acknowledge dtack sent operation finished system components interconnected using bus see figure 4 bus masters use bgrant bus grant iack irq acknowledgment lines connected two devices following lower upper priorities device highest priority connected constant 1 signal bgrant line bgrant signal sent lower priority devices arrival device requested bus device finishes transfer iack transmitted inputoutput operations memory mapped device fixed set addresses data written addresses interpreted instructions device fifteen irq lines irq1irq15 provided devices connected lines higher priority devices connected lower irqs figure 4 organization bus finally external cache memory defined generic structure cache controller defined figure 5 design implementation modules included original version alfa 1 defined assignment done undergraduate students following procedures presented following sections first stage circuits tested separately different algorithms implemented finally device integrated architecture model developed devs model integrated coupled model extension original architecture explained detail shows capabilities extensibility modifiability alfa1 figure 5 organization cache memory 3 implementing architecture devs models architecture presented previous section completely implemented using cd first behavior component carefully specified analyzing inputs outputs timing element specification also provided test cases component defined devs following specification model implemented cd including experimental framework following test cases defined specification finally main model built coupled model connecting submodels previously defined model follows design presented figure 1 detailed definition found 49 two implementations considered first reproduced basic behavior circuit coded transition functions implemented detail using boolean logic basic building blocks developed atomic models coupling using digital logic concepts way two different abstraction levels provided depending interest used thoroughly tested basic models integrated higher level modules completing definition architecture following sections devoted present components implemented assignments done students show different abstraction levels modeled present examples modifiability alfa1 31 incdec explained earlier use 520 general purpose registers organized overlapped windows given time one window active incdec model component chooses active window using 5bit cwp register models part cwp logic shown figure 2 cwp incremented decremented value stored dlatch represented another devs received lines op0op4 outputs transmitted lines res0res4 atomic model defined behavior transition functions informally defined follows x received port increment else decrement dint passivate res04 different last output send resp04 ports op04 figure 6 behavior transition functions incdec model 50 fcod value used tell value must incremented decremented alu model used operation see external event arrives holdin function activated macro represents behavior devs time advance function charge manipulating sigma variable state variable predefined every devs model represents remaining time next scheduled internal event model remain current state time output internal transition functions activated holdin macro makes timing definition easier passivate another macro uses infinite sigma puts model passive phase holdinpassive infinite following figure shows implementation functions using cd see external transition function dext receives five operands inputs together function code according code parameter incremented decremented model keeps present value delay related circuit operation output function l activated circuit changed state present value transmitted internal transition function dint passivates model internal event infinite delay scheduled waiting next input constructor allows specify models name inputoutput ports parameters see definition devs atomic model simpler use standard programming language explained advantages using devs section 1 case see apply build models devs provides interface consisting four functions programmed modular definition independent simulator repeated every model therefore one focus model development user concentrate behavior external events outputs must sent submodels occurrence internal events behavior every model encapsulated functions together elapsed time definition testing patterns easily created model activate functions incdecincdec const string name string time mainsimulatorinstancegetparameter model incdecexternalfunction const externalmessage msg check input ports assigning input values fcod 1 int i0 increment increment va value useing alu int else decrement int i0 i4 decrement v value useing alu int thisholdinactive preparationtime schedule delay circuit return model incdecinternalfunction const internalmessage delay consumed activate output return model incdecoutputfunction const internalmessage msg res0old0 res1old1 res2old2 sendoutputmsgtime res0 res0 sendoutputmsgtime res1 res1 sendoutputmsgtime res2 res2 sendoutputmsgtime res3 res3 sendoutputmsgtime res4 res4 return figure 7 incdec model definition transition functions50 defined atomic model test injecting input values inspecting outputs experimental frame built including pairs inputoutput values test model automatically case build coupled model including model tested defined follows preparation figure 8 incdec coupled model definition 50 definitions follow devs specifications defined components case id instance incdec model external parameters links define influencees translation functions including inputoutput ports model case id model related top model using inputoutput ports defined earlier 32 regglob model defines behavior global registers keeps contents 8 global registers allowing readwrite operations two auxiliary state variables olda oldb store last outputs output signals transmitted bits changed model defined 01 cin 0 2321 sketch model shown figure 2 see uses three select lines asel bsel csel choose two output registers register modified array 32 integers keeps present values registers boolean line cen c enable line used allow write operations external transition function models reception input function stores desired operation according signal received also store input value number register activated new internal event scheduled predefined delay models circuit delay external event arrives end delay operation cancelled model regglobexternalfunction const externalmessage msg switch msgport case cen line turned case reset breset intmsgvalue reset store input lines thisholdin active delay return model regglobinternalfunction const breset int i0 i255 ini0 bcen int i0 i32 return ieth line input enabled store register number received ieth line b input enabled store register number received ieth line c input enabled store register number received reset signal issued 8 register 32 bit deleted write line enabled update desired register wait next internal event model reggloboutputfunction const internalmessage msg oldai inselecta32i thissendoutputmsgtime aout oldbi inselectb32i thissendoutputmsgtime bout return register changed transmit output line register changed transmit output line figure 9 regglob model definition transition functions 50 output function decides register changed querying olda oldb stores previous status b lines register changes value sent chosen output b model shows interesting use internal transition function case considering internal state decide model must react internal transition function sees reset line activated case clears contents every register cen line activated value chosen register updated new input 33 basic components architectural description completed several devs models include generic aspects making brief description behavior include definition models transition func tions built previous examples details models found 49 circuit checks next window used overwritten component consists window invalid mask register returns value cwpeth bit wim register 0 241 rdwr 01 reset 0 1 memory provided three basic operations read write reset reset issued memory initial image loaded processor writes address bus signals memory using signal address ready readwrite signal issued memory reacts according signal using output time related memory latency adder receives two inputs depending result carry bit turned models used align data readwritten loadstore operations model represents behavior integer arithmeticlogic unit capable executing following operations add sub addx subx addsub carry xor andn orn xnor negated xor group models included provide behavior used boolean gates xor receive binary inputs producing result according desired operation rdwr dtack err reset busy 01 bus interprets input signals providing outputs related device received 1 bgrantin port needs write data memory writes 0 bgrantout port smaller priority device able use bus device starts bus cycle turning busysig nal device writes address accessed addresslines data written data byte select mask bselto define byte word used finally turns rdwrout lines tell write operation issued memory receives signal executes memory cycle finishes dtackout line turned device issued operation receives signal dtackin line cycle finished bgrantin still 1 device able transfer new data otherwise turns busyline allowing new bus operation device model used conditional jumps decide branch must executed represents cpu clock period configured model used decide access global registers register window required returns kind register register windowglobal number model updates npc model manages actions take place interrupt received pil processor interrupt lines mask interrupts one irqs whose numbers greater pil received interrupt must serviced see one higher priority tf trap found bit turned tt trap type register loaded according highest level interrupt model represents processor register implemented dlatch ein line enable inputs clear line resets register zero model charge making multiplication divisions turning condition bits models represent 2 4 input multiplexers choose receive 4bit select signal whose bit turned marks input sent output model charge managing register window model charge implementing shifter models extend sign operand 13 22 bits 32 bits component defines trap must serviced based priority system one input lines defines nonmasked trap 7 bits used receive number trap masked model returns bit telling trap must serviced 8 bits telling trap type following table shows kind priorities trap available line description priority trap type instaccexcep instruction access exception 5 0x01 illeginst illegal instruction 7 0x02 privinst privileged instruction 6 0x03 winover window overflow 9 0x05 winunder window underflow 9 0x06 addrnotalign address aligned 10 0x07 dataaccexcep data access exception 13 0x09 instaccerr instruction access error 3 0x21 dataaccerr data access error 12 0x29 divzero division zero 15 0x2a datasterr data store error 2 0x2b table 3 available traps according table model analyzes higher priority trap serviced delay sends corresponding index output ports 34 control unit control unit charge driving execution flow processor explained earlier model uses several inputoutput lines according input received issues different outputs activating different circuits defined previously show part behavior specification inputoutput sets included size details found 49 model ucexternalfunction const externalmessage msg else thispassivate else msgport dtack else msgport cclogic else string portname int portnum namenum msgportname portname portnum portname ir else return model ucinternalfunction const internalmessage return model ucoutputfunction const internalmessage msg see cen line must activated read instruction register decode instruction else else see branches else transmit outputs return figure 10 control unit transition functions see model activated occurrence clock tick case check control unit waiting result coming memory waitfmc case nothing model passivates otherwise register clock tick finished external inputs correspond signal dtack coming memory cclogic input arriving register also recognize inputs instruction register store new instruction execute psr update condition codes internal transition function records address strobe waiting end memory transfer main tasks control unit executed output function see description present input values queried depending number clock tick instruction cycle different output lines activated 4 digital logic level abstraction level several models detailed letting students analyze digital logic level circuits previous stage behavior circuits defined using atomic mod els case models built using atomic models representing basic boolean gates xor models described previous section used components integrated using digital logic coupled model representing complete circuit replaced old atomic ones modifications also done course assignments show extensibility modifiability alfa1 two models implemented way explained following 41 cmp model cmp part address unit detects addresses falling program boundaries model receives two inputs lines opa opb connected base limit registers result returns signal eq values equal lwif lower b figure 11 sketch address unit model composed several onebit comparators coupling n generates nbit compara tors following figure shows basic components building block figure 12 onebit comparator 50 model formally described select atomic defining corresponding building block presented previously section 33 andn1 self self andn2 self notn1 andn1 xorn zij built using described earlier definition coupled model using cd presented following figure opan opbn figure 13 cmp coupled model 50 first define components coupled model corresponding set inputoutput ports included related xy sets defined earlier finally links show model influencees define translation function select function implicitly defined order definition model components 42 chip selector chip selector cs circuit devoted determine address two others model receives 32bit address address strobe returns boolean value telling address boundaries mask models provide two 32bit sets max mask min mask containing boundaries address compared models defined originally latches redefined using boolean gates input address chip selector checked using two comparators instances model defined previous section figure 14 sketch chip selector 50 result obtained transmitted ports lw eq comparators outputs ored first register interested see cmp max lw output second register inverted interested see cmp b min circuit enabled result obtained transmitted components masmaxmas masminmas cmpacmp cmpbcmp and1and and2and oror notnot link a31top opa31cmpa a31top opa31cmpb link a30top opa30cmpa a30top opa30cmpb link out31masmax opb31cmpa out31masmin opb31cmpb link out30masmax opb30cmpa out30masmin opb30cmpb link out0masmax opb0cmpa out0masmin opb0cmpb link inaand2 link eqcmpa inaor lwcmpa inbor link outor inaand1 outnot inband1 link outand1 inband2 link outand2 cstop figure 15 cs coupled model 50 5 simulation results present section shows results obtained models previously presented simu lated first case show results value 20 incremented incdec model figure shows model inputs timestamps output values obtained first step consists giving initial value circuit zero default first event generates output model phase changes preparation time circuit 5 time units occurs 000005000 second input generate changes model output issued simulated time 10 new input inserted port op2 value changed output generated simulated time 15 following 2 inputs registered circuit keeps present state last one increments value register inserting value fcod port incremented value seen 5 time units input output figure 16 inputs outputs incdec model following example shows execution regglob model different inputs instant 0 c enable line activated allowing write operations register case register 4 selected csel21 csel10 csel00 number 0xffffffff used input ter 00000100 register 2 selected csel20 csel11 number 0x55555555 input cin0cin2cin4cin301 cin1 first value stored register 4 second register 2 input output reset 1 figure 17 inputsoutputs regglob 50 00000200 c enable deactivated therefore following operations devoted read registers see value register 4 sent output asel2 register 2 sent b bsel1 result values previously loaded transmitted 0xffffffff 0x55555555 b reset activated try read register 4 00000500 obtain value 0x00000000 next test corresponds traplogic model see result obtained turning trap bits due expect obtaining index highest priority trap pending result obtained delay time corresponds highest one section 34 data store error whose code result obtained also trap found flag turned instaccexcep 1000 illeginst 1000 privinst 1000 winover 1000 winunder 1000 addrnotalign 1000 dataaccexcep 1000 instaccerr 1000 dataaccerr 1000 divzero 1000 datasterr 1000 trapinst 1000 figure 18 execution results traplogic model 50 finally show two execution examples part complete program examples executed pentium processor 133 mhz using linux version cd average performance model one instruction per second source code translated binary using gnu masm assembler linker executable used initial memory image simulator first part following figure shows part program written assembly language second part presents binary code generated together addresses instruction data one word set 0x12345678 r1 st r1 dest sth r1 dest4 sth r1 dest10 stb r1 dest12 stb r1 dest17 stb r1 dest22 stb r1 dest27 unimp initial image addr memory image final image addr memory image load register 1 0x12345678 store dest variable store high halfword store last byte interpretation 01001000 store register 1 address 72 01001100 store high part reg 1 address 76 01010010 store high part reg 1 address 82 01010100 store high byte reg 1 address 84 01011001 store high byte reg 1 address 89 01011110 store high byte reg 1 address 94 01100011 store high byte reg 1 address 99 00000000 unimp 00100000 dest variable 20 space charactervalues figure 19 storing value memory see piece code copies parts number 0x12345678 certain memory addresses show translation binary codes based specification instruction set sparc processor finally show memory image program execution see values stored memory follow instructions defined executable code following example shows execution part another program see goal place 1 given address shift value left storing result following address cycle repeated 12 times set 1 r1 cycle sll r1 r2 r3 stb r3 r2dest subcc r2 12 r0 bne cycle inc 1 r2 delay slot unimp initial image addr memory image 036 10000111 00101000 01000000 00000010 final image load register 1 shift value store result repeat cycle 12 interpretation value 1 number times r2 variable dest times set 1 1 take register 1 shift store r3 store address substract 12 r0 relative jump address 2 words 40 increment 1 unimp destination variable value 0x01 shifted 12 times figure 20 shifting storing results memory basic behavior simulated computer verified thorough integration test attacked explained earlier circuit defined together set inputoutput values encapsulated experimental framework models tested operation instruction set checked procedure developed using verification facilities devs defining 17100 test cases mechanism consisted creating experimental framework executed instruction instruction set execution result stored memory memory dump executed obtaining memory state execution value checked value obtained program executed real architecture included testing experimental framework procedure allowed us find errors derived coupled model instance could see division instruction working properly generated test included following sentences set 274543375 r24 stores value register 24 set 13908050 r22 second value stored register 22 values divided stored r10 st r10 dest result stored memory unimp value ascii value dest word ffffffff result test 100 figure 21 testing routine udiv instruction example executed testing coupled model found error field type expected found dif case destination stored value 19 274543375 divided 13908050 instead found value 1 allowing us see one instructions unexpected behavior way could find errors instructions could fixed also found errors addition instructions conditional jumps prediction finally show part execution simulator example presented figure 20 show log file including messages interchanged modules devs frameworks four kinds messages used signal state change due internal event x used external event arrives models output done indicating model finished task messages initialize corresponding models message show type timestamp value ori gindestination port used transmission message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message x 000000000 message x 000000000 message x 000000000 message x 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message x 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 message 000000000 root00 top01 top01 mem02 top01 bus03 top01 csmem04 top01 cpu05 top01 c164 top01 dpc65 mem02 top01 bus03 top01 top01 cpu05 ir06 cpu05 pcadd07 cpu05 pcmux08 initialize higher level components memory bus cs etc models reply next scheduled event cpu initializes components root00 top01 top01 cpu05 cpu05 npc10 take npc cpu05 1000 pclatch11 send pcinc pcinc13 increment pclatch11 value schedule activation cpu05 pcinc model root00 top01 top01 cpu05 cpu05 pc12 cpu05 initial address pc12 cpu05 root00 top01 top01 cpu05 cpu05 clock45 clock tick clock45 clck 1000 cpu05 clock45 000100000 cpu05 clck 1000 cu43 root00 top01 top01 cpu05 arrival cu cpu05 cu43 activation components cu43 1000 cpu05 message 000000000 message 000000000 message 000000000 message 000000000 message 000010000 message 000010000 message 000010000 message 000010000 message 000010000 message 000010000 message 000010000 message 000010000 message 000010000 message 000010000 message 000010000 message 000010000 message 000020001 message 000020001 message 000020001 message 000020001 message 000020001 message 000020001 message 000020001 message 000020001 message 000020001 message x 000020001 message x 000020001 message x 000020001 message x 000020001 message x 000020001 message x 000020001 message 000020001 cu43 cpu05 root00 top01 top01 cpu05 cpu05 pclatch11 cpu05 root00 top01 top01 cpu05 cpu05 pcinc13 update npc cpu05 root00 top01 top01 mem02 memory returns first instr mem02 dtack 1000 top01 mem02 top01 figure 22 log file simple routine execution cycle starts initializing higher level models memory cpu etc message arrived cpu model sent lower level components instruction register pc adder pc multiplexer control unit etc initialization cycle finishes imminent model executed case npc model acti vated transmitting address next instruction see 2nd 5th bits returned value means npc value see figure 20 program starts address 32 value sent pcinc model charge adding 4 register update finished 10000 activation time model scheduled using circuit delay moment 4 value added npc obtain 3rd 5th bits 1 res3 res5 next pc pc activated value 010000 32 obtained initial address program following event arrival clock tick sent processor cpu schedules next tick 100000 time units transmits signal control unit activates several components amux alu addrmux iretc finally see simulated time 20000 memory returned first instruction compare results bit configuration address 32 instruction sent cpu stored instruction register follow execution rest instruction cycle completed way able follow execution flow program analyzing log file simplify analysis results built set scripts using tk lets students choose components considered way behavior subcomponents followed easily students analyze behavior desired subsystem detail 6 conclusion presented use devs simulate simple computer models based architecture sparc processor includes features existing simpler cpus tools used computer organization courses analyze understand basic behavior different levels computer system interaction levels studied experimental evaluation system done use devs allowed us reusable models case boolean gates comparators multiplex ers latches etc devs also allowed us provide reusable code different configurations provided different machines one running digital logic level instruction set different performance case depending educational needs concept internal transition functions used improve definition timing properties component letting define complex synchronization mechanisms nevertheless case timing delays represented simple putoutput relations met goals proposed alfa1 public domain developed using cd also public domain built using gnu c therefore toolkit available use existing computer organization courses described several levels architecture digital logic level instruction set assembly language level also attacked using public domain assemblers generated executable code could run alfa1 easily extended components instance including cache memory included first versions also modified existing components implementing instance digital logic versions cir cuits thorough testing could done using approach based construction experimental frameworks associated testing functions experimental framework also built final integrated model important achievements related educational goals whole project designed detail assignment 3rd year discrete event simulation course models formally specified specifications used students computer organization course build final version architecture students taken previous prerequisite courses programming knowledge students able build components presented final integration planned group undergraduate teaching assistants also developed control unit coupled model representing whole architecture showed figure 1 individual integration testing also done 2nd year students several modifications showed developed course assignments facts show feasibility approach pedagogical point view upper level courses reported higher success rates detailed knowledge subjects using alfa1 tools obtained httpwwwscecarletoncawainerusenix different experiences attacked using toolkit assembly language level students use existing assemblers build executables run simulator complete analysis execution flow instruction level achieved tracing execution log file students study flow program instruction detail starting memory image executable instruction cycle signal flow datapath easily inspected going deeper see behavior circuits implemented digital logic level extending changing existing instructions implementing changes control unit students experience design instruction sets allows practice instruction en coding relate instruction definition underlying architecture students also include new components showed cache memory example change existing ones implement using digital logic hierarchical nature devs provides means go deeper hierarchy instance logical gates could implemented defining transistor level implemented version planned build assembler linker code generated provided gnu sparc plattforms executed straightforward nevertheless implementation assembler linker interesting assignments faced complete layered view applied courses also debugger alfa1 architecture could built making easier study assembly language level present alfa1 extended defining components inputoutput subsystem several putoutput devices interfaces dma controllers simulated different transference techniques polling interrupts dma considered likewise implementation different cache management algorithms finished tasks faced present include definition graphical interface enhance use toolkit set scripts mentioned section 5 used gather results simulations used inputs displayed graphical way way study analysis different subsystems improved 7 acknowledgements want thank anonymous referees detailed comments made article also thank prof trevor pearce sce carleton university help final version sergio zlotnik collaborated early stage project presented earlier 51 research partially funded usenix foundation ubacyt project jw10 developed gabriel wainer assistant professor computer sciences dept universidad de buenos aires argentina r computer architecture quantitative approach computer organization design hardwaresoftware interface computer organization architecture computer systems design architecture structured computer organization simplescalar tool set version 20 interactive environment teaching computer architecture notes p86 assembly language assembling extensible simulator intel 80x86 processor family mps computer system simulator provir virtual processor performance simulation alpha microprocessor talisman fast accurate multicomputer simulation blockoriented network simulator bones improved parallel architectural simulations sharedmemory multiprocessors experiences simulating declarative multiprocessor microprocessor architecture design atlas designing efficient simulations using maisie harman mastering simulink 4 acsl reference manual company modsim ii language objectoriented programming simscript simulation programming language simulation model design execution hardware description languages concepts principles verilog hardware description language systems engineering sdl alfa0 simulated computer educational tool computer organization craps emulator sparc processor emulator atari processor objectoriented simulation hierarchical modular models devs theory quantization new extensions cd tool tr objectoriented simulation hierarchical modular models intelligent agents endomorphic systems structured computer organization 3rd ed introduction simulation gpss improved parallel architectural simulations sharedmemory multiprocessors executiondriven simulation multiprocessors talisman smprof computer organization architecture 4th ed interactive environment teaching computer architecture using simos machine simulator study complex computer systems simplescalar tool set version 20 performance dependability evaluation scalable massively parallel computer systems conjoint simulation iterative design efficient simulations using maisie gdevs hardware description languages computer systems design architecture simulation model design execution mastering simulink 4 computer architecture quantitative approach verilog hardware description language theory modeling simulation performance simulation alpha microprocessor microprocessor architecture design atlas augmint multiprocessor simulation toolkit intel x86 architectures experiences simulating declarative multiprocessor using devs paradigm implement simulated processor documentation chip computer system version 11 proteus highperformance parallelarchitecture simulator mps computer system simulator
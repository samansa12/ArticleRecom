adaptive efficient algorithms lattice agreement renaming sharedmemory system n independent asynchronous processes distinct names range 0 n1 communicate reading writing shared registers algorithm waitfree process completes execution regardless behavior processes paper considers waitfree algorithms whose complexity adjusts level contention system algorithm adaptive total contention step complexity depends actual number active processes k number unknown advance may change different executions algorithmadaptive algorithms presented two important decision problems lattice agreement 6k1renaming step complexity algorithms ok log k interesting component 6k1renaming algorithm algorithm 2k1renaming improves best previously known 2k1renaming algorithm onnk step complexitythe efficient renaming algorithm modified implementation atomic snapshots using dynamic singlewriter multireader registers best known implementations atomic snapshots step complexity log n using static singlewriter multireader registers using multiwriter multireader registers b introduction asynchronous sharedmemory system contains n processes running arbitrary speeds communicating reading writing shared registers processes distinct names range waitfree algorithm process terminates finite number steps even processes slow even stop taking steps completely step complexity many waitalgorithms depends n example collecting uptodate information processes typically requires read array indexed processes names real distributed systems need accommodate large number processes ie n large often small number processes take part computation systems step complexity depending n n undesirable preferable step complexity adjusts number processes participating algorithm algorithm adaptive total contention step complexity depends total number processes participating algorithm denoted k k unknown advance may change different executions algorithm step complexity adaptive algorithm adjusts number active processes constant single process participates algorithm gradually grows number active processes increases weaker guarantee provided rangeindependent algorithms whose step complexity depends n maximal number processes clearly n fixed executions 1 advantage rangeindependent algorithms quite restricted require priori knowledge n often difficult determine moreover extended abstract paper appeared proceedings 17th acm symposium principles distributed computing june 1998 pp 277286 2 department computer science technion haifa 32000 israel hagitcstechnionacil leonfcstechnionacil supported fund promotion research technion 1 moir anderson 27 use term fast conflicts papers 3 25 2 attiya fouren algorithm union 23 ok log lattice agreement algorithm renaming 27 algorithm ok log algorithm 1renaming algorithm 1renaming log n algorithm 1renaming fig 1 algorithms presented paper double boxes indicate main results step complexity optimal actual number participating processes much lower upper bound yet show useful tools construction adaptive algorithms paper presents adaptive waitfree algorithms lattice agreement naming using read write operations along way improve step complexity nonadaptive algorithms renaming figure 1 depicts algorithms presented paper oneshot renaming problem 10 processes required choose distinct names range size k bounded function paper consider general longlived renaming problem 9 processes repeatedly acquire release names adaptive renaming serve intermediate step adaptive algorithms problems 9 26 27 28 new names replace processes original names making step complexity depend number active processes algorithms employ technique well 6 7 efficient adaptive algorithm renaming could derived known algorithms best previously known algorithm renaming linear name space 18 onnk step complexity yielding ok 3 step complexity best made adaptive thus first present 2k gamma 1renaming algorithm step complexity neither adaptive rangeindependent algorithm based new shrinking network construction consider novel algorithmic contribution paper new linear renaming algorithm employed rangeindependent algorithm 1renaming log n step complexity processes start adaptive ok 2 renaming algorithm whose step complexity ok simple modification rangeindependent renaming algorithm moir anderson 27 processes reduce range names ologn iterations iteration uses new linear renaming algorithm rangeindependent renaming algorithm used construct adaptive 6k gamma 1renaming algorithm ok log complexity algorithm processes partitioned ologk disjoint sets according views obtained adaptive lattice agreement algorithm described partition bounds number processes set allows employ rangeindependent 2k gamma 1 adaptive lattice agreement renaming 3 renaming algorithm designed bound different sets use disjoint name spaces coordination sets required lattice agreement problem 15 processes obtain comparable contain ment subsets set active processes waitfree lattice agreement algorithm turned waitfree implementation atomic snapshot object additional readwrite operations 15 atomic snapshot objects allow processes get instantaneous global views snapshots shared memory thus simplify design waitfree algorithms step complexity adaptive algorithm lattice agreement ok log k algorithm processes first obtain names range size ok 2 using simple algorithm ok step complexity based reduced name process enters adaptive variant tree used lattice agreement algorithm inoue et al 23 appendix c describes shrinking network modified get lattice agreement algorithm step complexity using dynamic singlewriter singlereader registers gives implementation atomic snapshots complexity previous implementations atomic snapshots either log n step complexity using static singlewriter multireader registers 16 step complexity using multiwriter multireader registers 23 renaming problem introduced solved attiya et al 10 messagepassing model barnoy dolev 17 solved problem sharedmemory model burns peterson 19 considered lassignment problem dynamic allocation l distinct resources processes present waitfree lassignment algorithm assumes l number processes trying acquire resource algorithms exponential step complexity 21 borowsky gafni 18 present algorithm oneshot 2k gamma 1renaming using onnk readwrite operations anderson moir 9 define longlived renaming present rangeindependent algorithms oneshot longlived renaming algorithms use testset op erations moir anderson 27 introduced building block later called split ter employ rangeindependent algorithms longlived renaming using readwrite operations moir garay 28 26 give rangeindependent longlived oknrenaming algorithm using readwrite operations combining longlived 1renaming algorithm 19 obtain rangeindependent longlived 1renaming algorithm step complexity dominated exponential step complexity burns petersons algorithm herlihy shavit 22 show oneshot renaming requires names implies rangeindependent renaming algorithm provides optimal name space name space provided adaptive renaming algorithm optimal linear number active processes following original publication paper 12 afek merritt 4 used algorithms obtain adaptive waitfree 2k gamma 1renaming algorithm ok 2 step complexity another paper 13 present adaptive collect algorithm ok step complexity derive adaptive algorithms atomic snapshots immediate snapshots 1renaming paper emphasizes modular use collect operation make known algorithms adaptive algorithms higher step complexity presented algorithms adapt total number participating processes 4 attiya fouren process ever performs step influences step complexity algorithm throughout execution useful algorithms adapt current contention whose step complexity decreases processes stop participating afek dauber touitou 3 present implementations longlived objects adapt current contention use loadlinked storeconditional operations recent papers present algorithms longlived renaming 2 14 collect 6 snapshots 7 adapt current contention using readwrite operations lamport 25 suggests mutual exclusion algorithm requires constant number steps single process wishes enter critical section using readwrite operations several processes compete critical section step complexity depends range names alur taubenfeld 8 show behavior inherent mutual exclusion algorithms choy singh 20 present mutual exclusion algorithms whose time complexitythe time consecutive entries critical sectionis ok using readwrite operations afek stupp touitou 6 use adaptive collect algorithm derive adaptive version bakery algorithm 24 present another mutual execlusion algorithm 5 recently attiya bortnikov 11 presented mutual exclusion algorithm whose time complexity olog k algorithm employs unbalanced tournament tree structure adaptive lattice agreement tree 2 preliminaries 21 model sharedmemory model processes applying operations shared objects process p modeled possibly infinite state machine process p distinct name id shared objects considered paper atomic readwrite registers accessed read write operations readr operation change state r returns current value stored r writevr operation changes state r v multiwriter multireader register allows process perform read operations singlewriter multireader register allows single process perform write operations process perform read operation singlewriter multireader register dynamic identity single process writing register varies different executions otherwise static event computation step single process process determines operation perform according state next state according state value returned operation computations system captured sequences events execution ff finite infinite sequence events process performing event oe r applies read write operation single register changes state according transition function constraints interleaving events different processes reflecting assumption processes asynchronous bound relative speeds consider execution ff algorithm process number readwrite operations p performs ff step complexity ff denoted stepa ff maximum stepa ff process active ff takes step ff stepa ff denotes number active processes ff algorithm rangeindependent function f n 7 n every execution ff stepa ff fn namely step complexity every execution bounded function total number processes known advance depend range initial names adaptive lattice agreement renaming 501 6 diagonal fig 2 grid used ok 2 renaming depicted algorithm adaptive total contention function f n 7 n every execution ff stepa ff fkff namely step complexity ff bounded function number active processes ff clearly number active processes known priori waitfree algorithm guarantees every process completes computation finite number steps regardless behavior processes since kff bounded n follows adaptive algorithms waitfree 22 problems renaming problem 10 requires processes choose distinct names range depends number active processes namely function n 7 n every execution ff processes output distinct names range 1g lattice agreement problem 15 every process p outputs v subset active processes eq view following conditions hold comparable either v j 23 simple ok 2 renaming ok operations first step algorithms simple adaptive ok 2 renaming algorithm algorithm reduces range names depend number active processes later stages use distinct names without sacrificing adaptiveness describe algorithm first since employed adaptive algorithms presented paper basic building block algorithm splitter moir anderson 27 process executing splitter obtains right stop one process obtains stop single process executes splitter obtains stop two processes execute splitter obtain value way set processes accessing splitter split smaller subsets 27 splitters arranged grid size n theta n figure 2 process starts upper left corner grid splitters direct process either continue moving right grid obtain number associated current splitter grid spreads processes process eventually stops distinct splitter difference algorithm moir anderson 27 algorithm number splitters rows number splitters diagonals splitter j row column j 0 figure shows numbering numbering moir anderson appears square brackets 6 attiya fouren algorithm 1 adaptive kk 12renaming procedure adaptive kk private j integer initially 0 row column indices private move fdown right stopg initially direction 1 move 6 stop 2 move splitteri j execute splitter grid position 3 move increase row 4 move right j increase column 5 returni name based current splitter procedure splitteri j moir anderson 27 shared initially shared yi j boolean initially false 1 xi j id 2 yi j returnright 3 else yi j true 4 xi 5 else returndown algorithm 1 presents pseudocode grid splitter 2 say splitter steps away splitter 0 0 top left corner grid shown 27 section 31 k processes access grid process stops ok operations distinct splitter k gamma 1 steps away 0 0 simple counting argument shows splitters numbers range 1g theorem 21 algorithm 1 solves kk 12renaming ok step complexity 3 1renaming operations explained introduction step complexity adaptive renaming depends new linear renaming algorithm neither rangeindependent adaptive algorithm organized network reflectors reflector two distinguished entrances process accessing reflector changes direction movement another process accessed reflector depending entrance entered reflector network consists n columns numbered left right see figure 3 column gammac top bottom process q name c starts topmost reflector column c descends column c sees another process accessing reflector q moves left right towards column outputs row exits column n gamma 1 column c cgamma1 set processes starting columns 1 main property network processes cgamma1 enter column c distinct rows among lowest 2js ones therefore processes cgamma1 access reflectors column c larger may interfere single process descending column c algorithms declare private variables usage obvious initial value important adaptive lattice agreement renaming 7 process q descends column c accesses reflector row r process cgamma1 passed q moves column c remaining row r process p 2 cgamma1 accesses reflector q passed p moves one row column c reflector q pass p moves one row column c 1 therefore processes cgamma1 enter column c rows move one row processes cgamma1 enter column c rows r move one row process q leaves one free rows rows occupied two subsets fqg leave column c distinct rows since new names processes rows leave network output distinct names interaction processes column c guarantees processes cgamma1 move upper rows column c active two additional rows occupied figure 5b q active processes leave column c exactly number rows enter figure 5a thus active process causes two rows occupied k active processes leave network lowest rows formally reflector two entrances 0 1 two lower exits 0 1 two upper exits 0 1 process entering reflector entrance leaves reflector exits see top left corner figure 3 single process enters reflector must leave lower exit one process leaves lower exit possible two processes entering reflector leave upper exits reflector easily implemented two boolean registers see algorithm 2 reflectors column c denoted connected follows upper exit 0 sc r connected entrance 0 sc upper exit 1 sc r connected entrance 0 sc lower exit 0 sc r connected entrance 0 sc lower exit 1 reflector sc r connected entrance 1 reflector lowest reflector column c connected entrance 0 reflector sc algorithm 2 process name c starts entrance 1 upper reflector column c descends column c leaving exit 1 sees another process reaches bottom column point process leaves exit 1 next column moves towards column column enters exactly one reflector entrance 0 leaves exit 0 sees another process exit 0 otherwise suppose p j enters reflector entrance 2 f0 1g process enters reflector entrance 1gammai since process writes r 1gammai p j reads false r 1gammai leaves reflector lower exit implies following lemma lemma 31 single process enters reflector leaves lower exit similar arguments used proof next lemma lemma 32 single process enters reflector 0 single process enters reflector 1 one process leaves reflector lower exit proof assume p enters reflector 0 p j enters reflector 1 processes read true r 1 r 0 algorithm exitp lemma holds otherwise without loss generality p reads 8 attiya fouren reflector 0 1 0 fig 3 network reflectors 2k gamma 1renaming depicted false r 1 since p reads false r 1 p j writes r 1 line 1 p reads r 1 line 2 therefore p j reads r 0 line 2 p writes r 0 line 1 consequently obtains true r 0 algorithm exitp proves lemma recall c contains active processes starting columns every process c value local variable row p accesses first reflector column c 1 next lemma shows processes exit column distinct rows lemma 33 every pair processes proof proof induction column c base case lemma trivially holds since one process may access reflector column 0 induction step suppose lemma holds column c 0 two cases adaptive lattice agreement renaming 9 algorithm 1renaming procedure shrinkname renaming algorithm private col row integer initially name start top reflector column name 1 name descend column name 2 exit reflectorrowcol1 enter 1 3 4 else rowgammagamma 5 row gammacol col reached lowest reflector column 6 move towards column 7 exit reflectorrow col0 enter 0 8 9 else col rowgammagamma 10 returnrow n procedure reflectorentrance r 01 2 r 3 else returnup r case 1 process starts column c 1 algorithm reflector column c1 accessed 1 lemma 31 every process p 2 c leaves column algorithm figure 4a lemma holds induction hypothesis case 2 suppose process q starts column c 1 let sc last reflector accessed q column c 1 q leaves reflectors sc access reflectors lemma 32 every process p 2 c enters column c 1 row r higher exits column c 1 0 lemma 31 every process p 2 c enters column c1 row r lower exits column c 1 0 consider process q algorithm q leaves column c 1 either exit 1 lowest reflector column sc 1 exit 1 reflector q leaves reflector sc1 gammac1 1 figure 4b algorithm process b c fig 4 illustration proof lemma 33column c 1 q leaves reflector sc algorithm lemma 32 process p j 2 c accesses sc1 r 0 rowp algorithm ae leaves 0 induction hypothesis equations imply cases rowp 1 every pair processes therefore processes exit network different rows hence obtain distinct names next lemma shows processes c leave column c lowest rows lemma 34 every process proof proof induction c base case process id since process accesses reflector s0 0 0 therefore algorithm rowp lemma holds induction step suppose lemma holds column c 0 two cases case 1 process starts column c 1 process accesses reflectors column c 1 entrance 1 figure 5a therefore lemma 31 process induction hypothesis also since js c1 lemma follows inequalities case 2 suppose process q starts column c 1 induction hypoth esis processes c access lowest 2js c reflectors column c1 since process accesses upper reflectors sc 0 lemma 31 q accesses reflectors reaches reflector sc1 r 0 adaptive lattice agreement renaming 11 b fig 5 illustration proof lemma 34column c 1 accessed another process reaches lowest reflector sc column figure 5b therefore q leaves column c 1 either exit 1 reflector 1 exit 1 reflector sc 1 algorithm implies 1 according algorithm process ae together induction hypothesis implies 2 also lemma follows inequalities 1 2 3 lemma 34 implies processes leave network rows 2 since js n names chosen line 10 range process 2id reflectors column id j exactly one reflector column id reflector requires constant number operations implying next theorem theorem 35 algorithm 2 solves 2k gamma 1renaming step complexity network consists 2 reflectors reflector implemented two registers register r reflector written process entering reflector entrance entrance 1 reflector accessed single process starting column entrance 0 accessed one process lemma 33 therefore use 2 dynamic singlewriter singlereader registers 12 attiya fouren shrink1 shrink2 shrink3 shrink7 shrink6 shrink5 shrink4 12renaming algorithm 1 fig 6 rangeindependent algorithm 2k gamma 1renaming depicted algorithm 3 rangeindependent 2k gamma 1renaming n processes procedure indrenamingn 1 tempname adaptive kk 2 height tree 3 side tempname mod 2 4 tempname 0 5 1 6 tempname shrinktempname 7 side mod 2 8 b2c 9 returntempname 4 2k gamma1renaming log n operations rangeindependent 2k gamma1 renaming obtained combining adaptive ok 2 renaming nonadaptive 1renaming first names reduced range size 2 algo rithm 1 names used enter shrinking network algorithm 2 reduces range size 2k gamma1 shrinking network started names size 2 hence step complexity simple algorithm 2 algorithm presented section obtains log n step complexity reducing name space gradually olog n iterations distinct copies shrink algorithm associated vertices complete binary tree height copy shrink designed names range size 4n gamma 2 employs network process starts algorithm 3 acquiring name using ok 2 renaming name determines leaf start process performs shrinking network associated vertex v path leaf root starting column determined name obtained previous vertex ascends left subtree v starts one first 2n gamma 1 columns network otherwise starts one last columns process outputs name obtained root vertices tree numbered bfs order figure 4 root numbered vertex v numbered left child numbered 2 right child numbered 2 1 copy algorithm 2 associated vertex numbered denoted shrink lemma 41 every vertex v processes executing shrinkv obtain distinct temporary names range proof proof induction height v base case adaptive lattice agreement renaming 13 algorithm 4 adaptive 6k gamma 1renaming 1 v adaptivela algorithm 5 presented 2 r dlog jvje 3 tempname indrenaming 2 r algorithm 3 4 5 else returntempname executing algorithm 1 processes get distinct names range 1g therefore one process accesses v left executing shrinkv temporary name 0 one process accesses v right executing shrinkv temporary name 1 thus execute shrinkv different temporary names range 3g theorem 35 implies obtain distinct names range f0 1 2g therefore lemma holds induction step assume lemma holds vertices height let v vertex height 1 induction hypothesis algorithm accessing v left child distinct temporary names range accessing v right child distinct names range f2n 3g thus processes execute shrinkv distinct names range distinct names range 2g theorem 35 therefore processes obtain distinct names range completing shrink root process performs shrink n vertices tree vertex requires operations theorem 35 implies following theorem theorem 42 algorithm 3 solves 2k gamma 1renaming log n step complexity 5 1renaming ok log operations adaptive 6k gamma 1 renaming algorithm process estimates number active processes performs copy rangeindependent 2k gamma 1renaming algorithm algorithm designed number processes may different estimates k number active processes perform different copies algorithm 3 instead consolidating names obtained different copies disjoint name spaces allocated copies number active processes estimated size view obtained lattice agreement since views comparable estimate within constant factor see lemma 51 algorithm 4 process p belongs set j size view views obtained lattice agreement partition guarantees js j j 2 j moreover number active processes k js dlog ke dlog ne copies algorithm 3 denoted indrenaming 2 indrenaming 2 dlog ne processes j perform indrenaming 2 j designed 2 j processes obtain names range size 2js j 1 name spaces ne overlap size linear k figure 7 lemma 51 views processes set satisfy comparability selfinclusion properties lattice agreement size view k jsj k proof assume v view maximal size let v view process selfinclusion property implies comparability 14 attiya fouren adaptive lattice agreement renaming rangeindependent fig 7 adaptive 6k gamma 1renaming property implies v v therefore v implying jsj jv j k algorithm process p j jv j 2 j lemma 51 implies next lemma lemma 52 k active processes js every process since views contain active processes therefore implies next lemma lemma 53 k active processes js lemma 52 2 j processes invoke indrenaming 2 j therefore process p invoking indrenaming 2 j obtains tempname 2g theorem 42 algorithm p returns tempname set names returned processes performing indrenaming 2 j denoted namespace next lemma follows algorithm lemma 54 1 namespace namespace dlog ne 2 lemma 55 k active processes return distinct names range proof two active processes p p j execute copy indrenaming obtain distinct names theorem 42 otherwise obtain distinct names lemma 541 lemma 53 processes invoke indrenaming 2 j 0 j dlog ke lemma 542 processes invoking indrenaming range 2g theorem 42 process p invoking last nonempty copy indrenaming 2 dlog ke obtains temporary name range algorithm p returns name range f2 dlog 3 dlog ke1 names form 2 used therefore names obtained algorithm mapped name space size 6k gamma dlog 2 adaptive lattice agreement renaming 15 thus output names range whose size greater 2 dlog correctness algorithm follows lemma 55 k active processes process performs adaptivela pre sented next section ok log operations lemma 53 copies indrenaming less 2k processes invoked therefore process completes indrenaming ok log operations theorem 56 algorithm 4 solves 6k gamma 1renaming ok log upper bound size name space 6k gamma 1 tight algorithm 4 assume processes executing lattice agreement obtain maximal view size access indrenaming 2 dlog ke processes leave range 2g unused since unknown whether previous copies indrenaming empty return names range f2 dlog 2g k integral power 2 output names range size 2 log k2 integral power 2 output names range size merritt private communication noted names reduced partitioning active processes sets size integer 2 active processes partitioned sets adaptiverenaming j designed j participants obtain new names range size 2js j 1 algorithm k processes active adaptiverenaming j accessed 0 j dlog ke processes accessing copies adaptiverenaming j names space size p dlog 2 log k1 gamma1 tends 2k 1 processes accessing last nonempty copy adaptiverenaming dlog new names range size 2k gamma 1 thus size total name space 6 lattice agreement ok log operations lattice agreement algorithm based algorithm inoue et al 23 algorithm process starts distinct leaf based name complete binary tree height climbs tree root vertex path performs procedure merges together two sets views set containing comparable views procedure called union leaf process uses name input union inner vertices uses view obtained previous vertex input union process outputs view obtains root specifically union takes two parameters input view v integer side 2 f0 1g returns output view properties specified next lemma 23 lemma 6 lemma 61 input views processes invoking union comparable satisfy selfinclusion property similarly input views processes invoking union 1 output views processes exiting union comparable 2 output view process exiting union contains input view appendix describes union detail explains next lemma lemma 62 step complexity union ok adaptive algorithm uses unbalanced binary tree r defined inductively follows 0 root v 0 single left child figure 8a r 0 suppose r attiya fouren22 37 29 vr cr t0 b tr1 fig 8 unbalanced binary tree used adaptive lattice agreement algorithm defined identified vertex v r last vertex inorder traversal r notice v r right child r r1 obtained inserting new vertex v r1 right child v r inserting complete binary tree c r1 height r left subtree v r1 figure 8b construction v r1 last vertex inorder traversal r1 vertices tree numbered follows root numbered 1 vertex numbered left child numbered 2 right child numbered figure 8 construction leaves r leaves complete binary subtrees therefore total number leaves r following simple lemma proved appendix b states properties r lemma 63 let w ith leaf r 1 counting left right 1 depth w 2blog ic 2 w numbered 2 algorithm 5 uses 2 log ngamma1 n leaves 4 process starts algorithm obtaining new name range size kk 12 using algorithm 1 name determines leaf process starts climb tree process new name x starts algorithm x th leaf tree counting left right since kk leaves temporary names range size kk 12 lemma 63 x th leaf numbered 2 23 distinct copy union associated inner vertex tree process performs copies union associated vertices along path root returns view obtained root simple induction distance vertex v leaves shows views obtained processes executing union v satisfy comparability self inclusion properties base case v leaf claim trivial since single process starts leaf induction step follows immediately lemma 61 hence views obtained root lattice agreement properties k active processes process p gets unique name x 4 simplicity assume n power 2 adaptive lattice agreement renaming 17 algorithm 5 adaptive lattice agreement procedure adaptivela 1 tempname adaptive kk 2 blog tempnamec 3 tempname leaf corresponding tempname 4 v fp g input processs name 5 1 6 side mod 2 calculate side 7 b2c calculate father 8 v unionv side 9 returnv 12g line 1 lemma 632 starts leaf depth 2blog x therefore p accesses 2blog x vertices vertex execution union requires ok operations lemma 62 thus total step complexity algorithm ok log k implying following theorem theorem 64 algorithm 5 solves lattice agreement ok log 7 discussion work presents adaptive waitfree algorithms whose step complexity depends number active processes lattice agreement 1renaming readwrite asynchronous sharedmemory model step complexity algorithms ok log k clearly complexities algorithmsthe number steps number size registers usedcan improved example algorithm ok renaming ok step complexity would immediately yield lattice agreement algorithm step complexity also would interesting see ideas efficient algorithms improve complexities algorithms adapt current contention 2 6 acknowledgments thank yehuda afek eli gafni helpful discussions yossi levanoni comments earlier version paper reviewers many suggestions improve organization presentation r atomic snapshots shared memory results fast mutual exclusion using localspin kexclusion algorithms improve waitfree object implementation renaming asynchronous environment adaptive efficient mutual exclusion adaptive waitfree algorithms lattice agreement renaming atomic snapshots using lattice agreement atomic snapshots log n operations partial equivalence sharedmemory messagepassing asynchronous failstop distributed environment ambiguity choosing adaptive solutions mutual exclusion problem exponential examples two renaming algorithms topological structure asynchronous computability new solution dijkstras concurrent programming problem fast longlived renaming improved simplified tr ctr michel raynal waitfree computing introductory lecture future generation computer systems v21 n5 p655663 may 2005 hagit attiya faith ellen fich yaniv kaplan lower bounds adaptive collect related objects proceedings twentythird annual acm symposium principles distributed computing july 2528 2004 st johns newfoundland canada wojciech golab danny hendler philipp woelfel o1 rmrs leader election algorithm proceedings twentyfifth annual acm symposium principles distributed computing july 2326 2006 denver colorado usa hagit attiya arie fouren eli gafni adaptive collect algorithm applications distributed computing v15 n2 p8796 april 2002 hagit attiya arie fouren algorithms adapting point contention journal acm jacm v50 n4 p444468 july
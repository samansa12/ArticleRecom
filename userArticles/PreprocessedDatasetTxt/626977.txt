time redundancy approach tmr failures using faultstate likelihoods failure establish majority among processing modules triple modular redundant tmr system called tmr failure detected using two voters disagreement detector assuming one module becomes permanently faulty execution task reexecution task hardware rshw upon detection tmr failure becomes costeffective recovery method 1 tmr system mask effects one faulty module rshw recover nonpermanent faults 2 system reconfigurationreplace faulty hardware reload restart rhwris expensive time hardware propose adaptive recovery method tmr failures optimally choosing either rshw rhwr based estimation costs involved apply bayes theorem update likelihoods possible states tmr system voting result upon detection tmr failure expected cost rshw derived likelihoods compared rhwr rshw continue either recovers tmr failure expected cost rshw becomes larger rhwr number unsuccessful rshws increases probability permanent faults caused tmr failure increase turn increase cost rshw simulation results show proposed method outperforms conventional reconfiguration method using rhwr various conditions b introduction fault tolerance generally accomplished using redundancy hardware software time combination thereof three basic types redundancy hardware software static dynamic hybrid static redundancy masks faults taking majority results replicated tasks 13 dynamic redundancy takes twostep procedure detection recovery faults 2 effectiveness method relies selecting suitable number spares faultdetection scheme switching operation hybrid redundancy combination static dynamic redundancy 4 core based static hardware redundancy several spares provided tolerate faults redundant systems could provide high reliability depending number spares used assumption perfect coverage switching operation however new faults may occur detection existing faults switching operation becomes complex number spares increases order reduce complexity switching operation enhance reliability low cost selfpurging 12 shiftout 5 schemes developed faulty modules removed replaced standby spares schemes additional operation required select nonfaulty spares needed thus making switching operation simpler difficult implement either threshold voter shiftout checking unit requires comparators detectors collectors triple modular redundancy tmr one popular faulttolerance schemes using spatial redundancy faulttolerant multiprocessor ftmp 6 computations done triplicated processorsmemories connected redundant common serial buses quadredundant clocks use bitbybit voting hardware transactions buses cvmp 18 also tmr system traded performance reliability switching tmr mode voting independent modes program control 22 optimal tmr structure recover transient fault shown extend significantly lifetime small system spite requirement reliable voter circuits authors 3 proposed modular tmr multiprocessor increase reliability availability using retry mechanism recover transient faults switching tmr dualprocessor modes isolate permanent fault simple multipleretry policy retry prespecified number times also used discriminate permanent fault employed policy tolerate multiple faults treating sequence single faults repair fault occurrences thus requiring frequent voting effective fault detection tmr failure caused near ccoincident faults different modules must also detected recovered effect dependent faults inducing tmr failure eliminated periodic resynchronization optimal time interval 7 however fault model 7 22 include possibility permanent faults resynchronization longer effective addition use spatial redundancy fault masking reconfiguration time redundancy applied effectively recover transient faults recovery techniques classified instruction retry 10 program rollback 16 program reload restart module replacement several researchers attempted develop optimal recovery policy using time redundancy mainly simplex systems koren 9 analyzed instruction retries program rollbacks design parameters number retries intercheckpoint intervals berg koren 2 proposed optimal module switching policy maximizing applicationoriented availability prespecified retry period lin shin 10 derived maximum allowable retry period simultaneously classifying faults minimizing mean taskcompletion time main intent paper develop approach combining time spatial redundancy applying time redundancy tmr systems note spatial redundancy already encapsulated tmr system tmr failure failure establish majority due multiplemodule faults detected time voting faulty module even effects masked identified tmr system conventionally reconfigured replace three faulty module faultfree modules tmr failure caused transient faults system reconfiguration replacement hardware restart rhwr upon detection tmr failure may desirable due high cost time hardware counter problem propose upon detection tmr failure reexecute corresponding task hardware rshw without module replacement instruction retry intrinsically assumes almostperfect fault detection tmr systems require frequent voting thereby inducing high time overhead however probability system crash due multiplechannel faults shown 17 insignificant general tmr systems even outputs computing modules infrequently voted long system free latent faults unlike simplex systems program rollback adequate tmr systems due associated difficulty checkpointing synchronization consider reexecution tasks tmr system infrequent voting example since 90 faults known nonpermanent 2 field failures caused permanent faults 14 simple reexecution may effective means recover tmr failures may reduce hardware cost resulting hasty elimination modules transient faults ii recovery time would otherwise increase ie result system reconfiguration note system reconfiguration timeconsuming requires location replacement faulty modules program data reloading resuming execution shall propose two rshw methods determining reconfigure system instead reexecuting task without module replacement first nonadaptive method determine maximum number rshws allowable mnr reconfiguring system given task according nominal execution time without estimating system fault state somewhat similar multipleretry policy applied general rollback recovery scheme 20 contrast second adaptive method estimates system state likelihoods possible states ii chooses better rshw rhwr based expected costs system one estimated states rhwr invoked either number unsuccessful rshws exceeds mnr first method expected cost rshw gets larger rhwr second method second method shall develop algorithm choosing rshw rhwr upon detection tmr failure shall also show calculate likelihoods possible states update using rshw results bayes theorem paper organized follows following section present generic methodology handling tmr failures introduce assumptions used section 3 derives optimal voting interval x v given nominal taskexecution time x mnr first method optimal recovery strategy second method computed given x derive probability density function pdf time first occurrence tmr failure probabilities possible types faults time transition probabilities voting time costs rshw rhwr problem updating likelihoods system state recovery policy unsuccessful rshw section 4 presents numerical results compares two recovery methods rshw rhwr paper concludes section 5 detection recovery tmr failure detection location subsequent recovery faults crucial correct operation tmr system tmr system fails either voter fails time voting faults manifest multiple modules execution task fault occurrence rate usually small enough ignore coincident faults caused common cause noncoincident fault arrivals different modules negligible may lead tmr failure disagreement detectors compare values different voters tmr system detect single faults may become faulty ftmp 6 jplstar 1 cvmp 18 example systems use disagreement detectors ftmp detected disagreement stored error latches compress faultstate information error words later identification faulty modules system reconfiguration resolve ambiguity locating source detected error repeated depending source error number units connected faulty bus two fault detection strategies hard failure analysis hfa transient failure analysis tfa provided according number persistency probable faulty units strategies may remove units hard failures update fault index demerit suspected unit frequent voting required make scheme effective faulty module must detected recovered occurrence next fault another module within tmr system voting tmr system masks output one faulty module locate faulty module one however use simple scheme detect faulty modules andor voter assuming probability two faulty modules producing identical erroneous output negligibly small output modulelevel voter becomes immaterial multiple modules faulty 8 tmr failure detected using two identical voters selfchecking comparator shown fig 1 voters implemented conventional combinational logic design 23 comparator easily made selfchecking usually simple function example simple structure made tworail comparators 11 bit utilized high reliability functionality tmr structure also detect voter fault tmr failure voter fault occurs comparator detect mismatch two voters results either failure form majority among three processing modules voter fault note using three voters instead two would make much difference discussion processor 3 processor 2 processor 1 voter 2 voter 1 ae oe comparator phi phi phi phi phi omega omega omega omega omega omega omega oe phi phi phi phi phi j phi phi phi phi phi figure 1 structure tmr system two voters comparator focus twovoter tmr structure comparator indicates mismatch two voters time voting appropriate recovery action must follow though rhwr widely used rshw may prove costeffective rhwr recovering tmr failures explore indepth characterize rshw way mnr determined simplest use constant number rshws irrespective nominal taskexecution time system state defined number faulty modules fault types taking account fact time overhead unsuccessful rshw increases nominal taskexecution time x one determine mnr simply based x without estimating system state complex effective method decide rshw rhwr based estimated system state since system state changes dynamically decision made optimizing certain criterion dynamically modified additional information obtained unsuccessful rshw adaptive method probabilities possible states used instead one accuratelyestimated state upon detection tmr failure expected cost rshw updated compared rhwr failed task reexecuted without replacing module either rshw recovers corresponding tmr failure expected cost rshw becomes larger task execution 2 number unsuccessful rshws increases possibility permanent faults caused tmr failure increases turn increases cost rshw significantly procedure described algorithm fig 4 throughout paper assume arrival permanent faults arrival disappearance nonpermanent faults poisson processes rates respectively optimal recovery tmr failure using rshw 31 optimal voting interval n nominal taskexecution time measured cpu cycles gamma 1th ith voting let x 1 beginning task first voting absence tmrvoter failure shown fig 2 1 n let taskexecution time beginning task first completion ith voting possibly presence module failures let w ew expected execution time task upon detection tmr failure let p q probabilities recoverying task rshw rhwr respectively 1 assuming time overhead reconfiguration constant c w n expressed recursive equation terms w 1 n let f 2 n probability tmr failure units time system state time j gamma 1th voting let f 1 beginning task probability recovery attempt ie rshw rhwr successful depends upon f tmr failure detected time first voting ie occurred execution task portion corresponding x 1 system try rshw rhwr probability p q recover failure process renewed probabilistically variable w 1 actual taskexecution time corresponding nominal taskexecution time x 1 thus c setup time system reconfiguration let v time overhead voting practice negligible equation also renewed w 2 n successful recovery hence defined actual taskexecution time gamma 1th ith votings oe oe oe oe tmr failure voting oe figure 2 graphical explanation v w 1 n equations following recursive expressions derived 2 n applying recursively times get optimal voting frequency derived minimizing w n respect n x subject intervoting intervals assumed identical constant voting interval optimal value n must determined minimizing eq 31 examples n given x typical values shown table 1 voting points inserted programmer compiler 32 predetermination nonadaptive rshws first method determine priori maximum number rshws mnr km based x without estimating system state associated task reexecuted km times x increases effect unsuccessful rshw becomes pronounced possibility successful recovery rshw instead rhwr decrease x due increased rate tmr failures time overhead unsuccessful rshw also increases x time overhead rhwr remains constant km decreases x increases let c 1 k x actual timecost task execution presence k rshws task nominal execution time x expressed p n probability nth rshw becoming successful unsuccessful probability tmr failure x system reconfiguration respectively p n fact p n p n u cannot determined without knowledge system state n gamma 1th unsuccessful rshw complicated derive priori approximate probabilities using following useful properties tmr system since probability permanent faults caused tmr failure increases number unsuccessful rshws p n monotonically decreasing n though rn j p n1 depend upon x fault parameters assumed simplicity p 1 given priori constant p rn constant r n modified terms p r cost rhwr denoted c 2 x derived using recursive equations km determined integer minimizes c 1 k x subject c 1 example values km typical values p r shown table 2 33 adaptive rshw method system chooses upon detection tmr failure rshw rhwr based expected costs rshw continue either becomes successful expected cost next rshw becomes larger rhwr system state characterized likelihoods possible states one observe time tmr failure detection insufficient accurately estimate system state outcome one rshw regardless whether successful used update likelihoods states one called prior state rshw started possible states upon detection tmr failure inferred posterior states updated prior states using rshw result bayes theorem unlike simplex model many possible states events analyze tmr system accurately thus use simplified markovchain model fig 3 derive state probabilities transition probabilities tmr system model consists six states distinguished number permanent faults nonpermanent faults two three fault states merged one state due identical effects analysis fig 3 transitions bidirectional horizontal lines result behavior nonpermanent faults transitions unidirectional vertical lines caused occurrence permanent faults note even occurrences nearcoincident faults represented sequential occurrences slightly different interarrival times model thus includes transitions neighboring states transition state due multiple faults occurs two steps one neighboring states faults may disappear without affecting execution task happens latency fault greater active duration ie manifest note occurrence error module task execution may produce erroneous output task even fault induced error disappeared producing final output task words transient fault may permanent effects task execution 3 optimal recovery algorithm based adaptive method fig 4 illustrated follows upon detection tmr failure first step derive probabilities 3 fact problem eliminated resynchronizing processors transient fault detected 21 however requires frequent voting additional mechanisms detecting errors processor resynchronizing processors possible states time x f evolved prior state let f time tmr system moved failure state prior state 0 x f x f time detecting tmr failure ie voting time occurrence tmr failure represented event want calculate probabilities possible states voting time x f evolved prior state actually conditional probabilities given observed event calculated probabilities types tmr failures f time f transition probabilities pmn remaining taskexecution time f probabilities possible states thus f f subscripts indicate prior state state time f state time x f detecting tmr failure respectively mentioned earlier voting failure may result voter fault multiplemodule faults multiplemodule faults classified based number modules permanent faults typei type ii typeiii failures represent zero one one permanentfault module respectively possible states type listed fig 3 let sx state x permanentfault modules nonpermanentfault modules 3 nonfaulty modules although ten different states need consider six merging merger states simplifies model tmr system without losing model accuracy ffl modifying transition rates one make simplified markovchain model fig 3 represent tmr system accurately ffl merger based realistic assumption simultaneous occurrence faults different processor modules highly unlikely moreover merger change analysis tmr failure merged states similar effects tmr failure compared original states example merged states induce type tmr failure type determined number permanentfault modules four possible states led typei failures ie s0 1 oe oe oe typeiii failure possible states time x f typeii failure possible states time x f typei failure possible states time x f figure 3 simplified markovchain model tmr system s0 2 s0 3 time f nonpermanent fault might disappear inducing errors typeii typeiii failures three possible states fs1 0 s1 1 s1 2g fs2 0 s2 1 s3 0g respectively time f x f notational simplicity let state j sx set possible states merging fs 1 set possible fault states transited 0 f 2 respectively 4 5 may change 5 8 4 f 5 f 8 remains unchanged due persistence permanent fault let path denote transition trajectory pair states since usually one path given pair nodes paths assigned id number simplified model fig 3 f minimumtime path type tmr failure let j time taken tmr failure via path j pdf j calculated convolving pdf subpaths make path j pdf subpath two states obtained using distribution sojourn time several exits markov chain model fig 3 gamma represents set outgoing arcs j k pdf j path j composed subpaths fij must one possible fault states sm 2 fs 1 g interarrival time events fault occurrence fault disappearance fault latency exponentially distributed need semimarkov chain model place markov chain model let j represent set paths fault state sm likelihood fault state sm time equal f obtained set paths possible fault states evolved ie 8g probabilities 1 2 leading typei failure computed based behavior nonpermanent faults ie depending whether nonpermanent fault induced errors still active second nonpermanent fault occurs likewise probabilities 4 5 leading typeii failure computed behavior nonpermanent fault occurred earlier permanent faults intermittent fault considered fault state must divided fault active fault benign states 15 makes problem complicated tractable numerical examples f f x mean f several x given figs 5 6 analytic results compared results obtained montecarlo simulations addition f f transition probabilities pmn sm n f must derived order obtain likelihood every possible state time voting failure detection x f although matrix algebra using transition matrix chapmankolmogrov theorem applied give accurate expressions use simplified method computational efficiency acceptably small loss accuracy transition probabilities f need consider subsequent errors focus states useful choosing rshw rhwr observe occurrence rate p permanent faults much smaller appearance disappearance rates nonpermanent faults using observation one analyze behavior permanent faults separately nonpermanent faults transition probabilities due occurrence permanent faults represented persistence permanent faults although probabilities depend upon approximated using prior probabilities source states f approximation causes small deviation exact values occurrence rate permanent faults usually small compared rates example consider p 1n n 4 ie transitions 1 due occurrence permanent faults corresponding transition probabilities derived model fig 3 terms pdf subpaths two states let f probability f 1 thus reduced 1gammaf 15 transitions source states due occurrence permanent faults derived conse quently prior probabilities transformed f respectively using transformed prior probabilities derive transition probabilities based behavior nonpermanent faults considering behavior nonpermanent faults divides model twostate model fs 4 threestate model fs 0 shown fig 3 transition matrix threestate model fs 0 derived using laplace transform reduces linear differential equations three states algebraic equations ii solving algebraic equations iii transforming solution back time domain linear differential equation fs 0 effects nontransient faults laplace transform solution requires inverse let roots ff fi ij ijth element obtained partial fraction expansion c ij1 c ij2 c ij3 since c ij2 c ij3 conjugates c ff effect permanent faults changes initial probabilities thus ith column 3 theta 3 transition matrix pt reduces to6 6 6 4 equations indicate coefficients exponentials 0 1 2 include effects occurrence permanent faults prior probabilities likewise transition matrix twostate model fs 4 derived as4 e gamma2 nt 4 e gamma2 nt 5 e gamma2 nt 4 2n effects permanent fault occurrences transitions 8 transition matrices probabilities resulting occurrence permanent faults describe possible transitions simplified model fig 3 tmr system 2 5 8 time x f rshw unsuccessful due multiple active faults one module states due disappearance active faults inducing errors system moves recoverable state rshw let f f x probability tmr failure evolved execution time x f f probability distribution function f since exact knowledge system state available estimate state probabilities used calculate expected cost single rshw follows f x x i2f258g i2f014g f 0 probability state starting one rshw upon detecting tmr failure ie probabilities present states become prior states next rshw expected cost rhwr obtained similarly eq 34 f x rshw unsuccessful voting failure occurs prior state probabilities updated additional information obtained rshw using bayes theorem observed information tells us tmr failure occurred current execution note tmr failure detection time current execution x f result prior probabilities possible fault states renewed kth rshw k x f proba tmr failure proba tmr failure x f x f f eq 310 one see probability tmr system permanentfault state increases unsuccessful rshw turn increases chance adopting rhwr rshw upon detection next tmr failure using updated state probabilities get conditional probabilities states upon detection tmrvoting failure rshw successful one likewise update probabilities possible states used guess prior state next voting interval hardware cost high time constraint stringent one may following since fault occurrence rate much smaller disappearance rate nonpermanent faults may wait certain period time called backoff time order current nonpermanent faults disappear task reexecution optimal backoff time determined minimizing expected time overhead task reexecuted without backoff cost one rshw equal eq 38 reexecution starts backing r units time cost changes due change prior states f x x i2f258g i2f014g f optimal backoff time obtained minimizing c 1 r respect r tmr failure derive n x compute c 1 yes successful yes update prior prob oereconfiguration reexecute continue execution figure 4 algorithm recover tmr failure estimating system state comparing costs rshw rhwr table 1 n vs x p table 2 km vs x 200 3000 00001 0002 50 table 3 parameter values used simulations measured hours 4 numerical results discussion system three replicated processing modules two voters comparator simulated compare proposed method called method 1 alternative based rhwr called method 2 upon detection tmr failure method 1 decide rshw rhwr according respective costs method 2 however reconfigure tmr entirely new healthy tmr partially healthy spare modules following appropriate diagnosis nonpermanent fault disappear diagnosis treated permanent fault replaced new nonfaulty spare assume a1 unlimited number tasks nominal taskexecution time available keep running module busy simplifies description system workload a2 unlimited number spares available performances two methods characterized overhead ratio e real execution time including rshw andor rhwr overheads task whose nominal execution time x ran simulations fault generation process parameters given table 3 symbol indicates parameter varied others fixed order observe effects parameter ovr methods since fault oc currencedisappearance rates difficult estimate online experimental data numerical data based model reflecting maturity designfabrication process environmental effects operating conditions number ages components used 19 figs 5 6 probabilities tmr failure failure times 0 4 computed markovchain model simulations compared simulation modeling results close modeling analyses proved effective determining choose rshw rhwr various conditions shown figs 711 results obtained varying x 10 100 hours plotted figs 79 ovrs methods 1 2 optimal number votings compared fig 7 difference ovrs method 1 method 2 increases significantly x x small ovrs two methods small distinguish due mainly small probability tmr failure fig 8 compares multivoting policy optimal number votings one voting policy generally overhead tmr system infrequent voting increases significantly increases probability tmr failure increases x eg voting task execution tmr failure means waste entire nominal execution time x x increases ovr onevoting policy increases rapidly multivoting policy number rhwrs represented percentage rhwr total number simulations fig 9 determine hardware cost spares used increase percentage much larger method method 1 since number tmr failures increases x method 1 recover tmr failures rshw second comparison made varying c resetting time system reconfiguration 25 125 hours x50 hours results plotted fig 10 larger resetting time generally results larger ovr increasing c greatly affects performance method 2 little influence ovr method 1 since system recovers tmr failures rshw nothing c third comparison fig 11 made varying n p 5 25 n fixed 0005 hr hours hours ovrs methods decrease n p magnitude decrease method 1 larger method 2 probability tmr failure decreases p decreases n fixed probability successful rshw increases n simulated proposed schemes units time fault parameters table 3 comparison mean overhead ratios different schemes fault parameters assumed change simulation since estimation system states depends upon fault parameters must estimated first problem solved assuming parameters timevarying estimating online certain adaptive methods turn require samples 5 conclusion paper proposed strategy recovering tmr failures using two different methods determine apply rhwr methods shown outperform conventional method based solely reconfiguration finding consistent fact faults nonpermanent simple reexecution recover nonpermanent faults tmr structure mask effects one faulty module distinct characteristic proposed strategy uses estimated state tmr system even incomplete observation system states detection tmr failure andor unsuccessful rshw always call reconfiguration rhwr requires us derive compare expected costs reconfiguration one additional rshw tmr failures represented using simplified markovchain model tmr failure time probability another unsuccessful rshw also analyzed model one therefore conclude combining time spatial redundancy appropriately effective handling component failures acknowledgement authors would like thank allan white chuck meissner felix pitts nasa langley research center jim smith office naval research technical financial assistance r starselftesting repairing computer investigation theory practice faulttolerant computer design switching policies modular redundancy faulttolerant computing systems modular tmr multiprocessor sys tem reliability analysis hybrid redundancy shiftout modular redundancy ftmpa highly reliable faulttolerant multiprocessor aircraft design dependentfailuretolerant microcomputer system using triplemodular redundancy embedding triplemodular redundancy hypercube architecture analysis class recovery procedures optimal retry policy based fault classification ram architecture concurrent access onchip testing highly efficient redundancy scheme selfpurging redundancy use triplemodular redundancy improve computer reliability measurement analysis transient errors digital computer systems error detection process model design impact computer performance optimal checkpointing realtime tasks study faulttolerant processor advanced launch system case study cmmp cm cvmp part experiences fault tolerance multiprocessor systems theory practice reliable system design watchdog processor based general rollback technique multiple retries transient failures triple modular redundancy systems sequential modules microcomputer reliability improvement using triplemodular redun dancy new design method voter faulttolerant redundancy multiplemodule multimicrocomputer system tr analysis class recovery procedures watchdog processor based general rollback technique multiple retries switching policies modular redundancy faulttolerant computing systems optimal checkpointing realtime tasks embedding triplemodular redundancy hypercube architecture ram architecture concurrent access chip testing optimal retry policy based fault classification ctr hagbae kim kang g shin sequencing tasks minimize effects nearcoincident faults tmr controller computers ieee transactions computers v45 n11 p13311337 november 1996 hagbae kim kang g shin design analysis optimal instructionretry policy tmr controller computers ieee transactions computers v45 n11 p12171225 november 1996 jae kwon kim byung kook kim probabilistic schedulability analysis harmonic multitask systems dualmodular temporal redundancy realtime systems v26 n2 p199222 march 2004 jos manuel cazeaux daniele rossi cecilia metra selfchecking voter high speed tmr systems journal electronic testing theory applications v21 n4 p377389 august 2005 byonghyo shim naresh r shanbhag energyefficient soft errortolerant digital signal processing ieee transactions large scale integration vlsi systems v14 n4 p336348 april 2006
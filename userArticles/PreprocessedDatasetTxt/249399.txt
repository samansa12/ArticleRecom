bounded queries approximation paper investigates computational complexity approximating several npoptimization problems using number queries np oracle complexity measure results show tradeoff closeness approximation number queries required approximation factor kn log logkn n queries np oracle used approximate maximum clique size graph within factor kn however approximation cannot achieved using fewer log logkn n c queries oracle unless constant depend k results hold approximation factors kn geq 2 belong class functions includes integer constant function log n loga n n1a similar results obtained graph coloring set cover npoptimization problems b introduction approximability npoptimization problems central theme study algorithms computational complexity theory npoptimization problems decision versions npcomplete hence equivalent decision problems however approximability optimization problems may vary greatly npoptimization problems efficient algorithms find good approximate solutions others algorithm exist unless standard intractability assumption violated eg polynomial hierarchy collapses recently arora lund motwani sudan szegedy alm showed problem finding largest clique graph latter category following series breakthrough results as92 bfl91 fgl showed exists constant ffl deterministic polynomial time algorithm approximate maximum clique size g graph g n vertices within factor n ffl unless result strongly suggests efficient algorithm find good approximations maximum clique problem resolve questions computational complexity approximating maximum clique size graph particular clear computational resources sufficient andor necessary compute approximation maximum clique size using traditional resource bounded measures eg time space random bits alternation paper use number queries npcomplete oracle complexity measure krentel kre88 used measure show maximum clique size complete polynomial time functions use olog n queries denoted pf np olog n since krentels original work many connections bounded query classes standard complexity classes discovered abg90 ag88 bei87 bei91 ck90 gkr wag86 ww85 many circumstances results show one cannot decrease number queries needed solve problem even single query unless collapses example hoene nickelsen hn93 showed determine many formulas f satisfiable dlogr 1e queries sufficient necessary unless naive binary search determine number satisfiable formulas using queries np oracle number queries needed dlogr dlog r answers ranging 0 r tree pruning technique shows polynomial time machine determine number satisfiable formulas using one fewer query oracle unless thus algorithm uses fewest queries simply naive binary search algorithm paper show approximating several npoptimization problems also property first parts paper focus complexity approximating size maximum clique graph order state results paper correctly need precise term approximation let g denote size maximum clique graph g say number x approximation g within factor kn gkn x g results show tradeoff closeness approximation number queries needed solve approximation problemcloser approximations require queries example approximate g within factor 2 using log log n queries factor upper bound lower bound unless log log n log log log log n gamma log log k log log log n log log n gamma log log log n log log n gamma log log log 1a log log gamma log 1ffl table 1 upper lower bounds approximating maximum clique size np n number vertices graph g contrast computing g exactly done log n queries n queries unless moreover show function using fewer log log n gamma log 1ffl queries oracle approximate g within factor 2 unless ffl constant given corollary 3 alm 92 general results show nice approximation factor kn 2 g approximated within factor kn using log log kn n queries fewer log log kn queries oracle unless corollary 6 show difference log 1ffl upper lower bounds natural interpretation table 1 summarizes results common approximation factors make observations results first since ffl constant large enough constant k log log k would exceed log 1ffl hence k upper bound approximating g within factor k strictly less lower bound approximating within factor 2 hence large k problem approximating within factor k strictly lower complexity terms number queries approximating within factor 2 unless similarly approximating within factor log n lower complexity approximating within constant approximating within factor n 1k even lower complexity believe first results show tradeoff complexity closeness approximation contrast garey johnson gj79 showed g approximated within constant factor p approximated within constant factor p contradictory theorems certainly different flavors next section state lemmas definitions notations needed prove results section 3 show uniform binary search routine provides upper bounds mentioned prove lower bound results start section 42 simple proof shows function pf x1 oracle x approximate within factor 2 unless go proof general lower bound results section 5 discuss results extend np optimization problems eg chromatic number section 6 ponder upon value constant ffl finally section 7 combine techniques results lund yannakakis ly94 hardness approximating set cover problem derive upper lower bounds query complexity approximating minimum set cover size preliminaries definition 1 every graph g let jgj denote number vertices graph let g denote size largest clique g say function ag approximates maximum clique size within factor kn graphs g n vertices gkn papers use alternative condition gkn ag kn delta g find unintuitive consider ag approximation g exist clique size ag g however results paper still hold alternative definition prove lower bounds need result arora et al alm 92 showed exists ffl 0 maximum clique size cannot approximated within factor n ffl deterministic polynomial time unless number vertices graph construction yields next lemma exist constants b given boolean formula f variables construct polynomial time graph g vertices constants b fixed remainder paper particular interest ratio b gamma sd equal ffl mentioned lemma 2 prove intractability n ffl approximation first assume polynomial time algorithm approximate g within n ffl take boolean formula f let number variables f construct g described lemma 2 use polynomial time algorithm obtain approximation x g since n ffl approximation within factor algorithm must guarantee x b hand f 62 sat x definition 3 let pf xqn class functions computed polynomial time oracle turing machines ask qn queries oracle x since queries adaptive query strings may depend answers previous queries 3 upper bounds first examine upper bounds complexity approximating npoptimization problems terms bounded query classes general idea use query sat narrow range optimal solution exists example graph g n nodes 1 g n compute g exactly using binary search log n queries form g greater x hand approximate g within factor 2 need find number x x g 2x thus first partition numbers 1 n intervals ne g interval simply use 2 factor 2 approximation g thus strategy use binary search left endpoints intervals determine interval contains g since dlog ne intervals need dlog dlog nee queries sat perform binary search general case want find approximation g within factor kn l log kn n intervals form kn binary search would use l log l log kn n mm queries sat thus following lemma lemma 4 let kn polynomial time computable function 1 exists function pf sat dlogdlog kn nee approximates g within factor kn graphs g n vertices lemma stated maximum clique size problem obviously holds npoptimization problem solution integer ranging 1 n note matter kn integer checking whether g greater x still np question x fractional number determined g contained interval kn kn i1 output dkn e approximation g also drop ceilings notation derive readable upper bounds complexity approximating g common approximation factors see table 1 binary search strategy used find approximation g may seem naive however shall see later upper bounds differ lower bounds additive constant case improve upper bounds exists polynomial time algorithm gives approximate solution within factor fn strategy first use polynomial time algorithm obtain approximation x know solution x x delta fn find approximation within factor kn divide numbers x x delta fn intervals x case number intervals l log kn fn lemma lemma 5 let kn polynomial time computable function 1 suppose exists polynomial time algorithm approximates g within factor fn exists function pf sat dlogdlog kn fnee approximates within factor kn graphs g n vertices note lemma applies npoptimization problem whose solutions range 1 n lemma may seem somewhat useless since best known polynomial time algorithm approximate size maximum clique within factor onlog n 2 bh92 use new strategy outlined would reduce number queries needed find factor 2 approximation g loglog would save us one query various values n however following corollary lemma allow us gauge quality lower bound results corollary 6 function pf sat log log kn ngammalog 1ffi approximates g within factor kn polynomial time algorithm approximate g within factor n ffi corollary 6 gives us natural interpretation difference upper bound log log kn n lemma 4 lower bound log log kn gamma log 1ffl theorem 15 difference log 1ffl reflects fact know exists polynomial time algorithm approximates g within factor n ffi 1 thus improvement either upper lower bound possible moreover observations lemma 5 useful applied npoptimization problems set cover set cover problem given finite collection c subsets ng asked find size smallest subcollection ng since size smallest set cover approximated within factor following lemma lemma 7 let kn polynomial time computable function 1 exists function pf sat dlogdlog kn ln n1ee approximates size minimum set cover within factor kn comparing lemma 4 lemma 7 obtain quantitative difference complexity approximating g complexity approximating size minimum set cover qualitative difference example allowed make log logln queries sat approximate minimum set cover within factor 2 however using number queries approximate within factor n 1 logln n1 thus conclude approximating set cover within factor 2 complexity approximating g within factor n 1 logln n1 comparison possible taking quantitative view complexity approximations terms number queries note existence good polynomial time approximation algorithm problem greater effect complexity approximating problem complexity finding exact solution example suppose np optimization problem solution ranges 1 n without help approximation algorithm would need log n queries find exact solution log log n queries find factor 2 approximation suppose given polynomial time algorithm guarantees factor 4 approximation find exact solution would still need logn queries however need one query log log approximate within factor 2 upper bounds proven section uses naive binary search strategy determine interval contains optimal solution one might suspect clever algorithm could use substantially fewer queries oracle rest paper show unless intractability assumption violated eg polynomial time algorithm reduce number queries additive constant results give us relative lower bounds number queries needed approximate maximum clique size graph also able extend techniques determine query complexity approximating chromatic number graph minimum set cover 4 lower bounds 41 promise problems clique arithmetic prove lower bound results need introduce definitions notations number formulas ff satisfiable ie sat definition 9 let rt polynomially bounded polynomial time function define p rt following promise problem given sequence boolean formulas f f variables promise technically size input promise problem jf j size otrt boolean formulas restricted ones variable occurs constant number times simplify notation following lemma count queries function rather jf j following lemma provides tight lower bound complexity p r proven using selfreducibility sat tree pruning technique hn93 include proof sake completeness rt logarithmically bounded polynomial time computable function exists oracle x polynomial time function solves p rt using fewer queries x proof let polynomial time oracle turing machine solves p r using qt queries x know log n entire oracle computation tree input f polynomially bounded searched deterministically fact oracle computation tree rt leaves since x 2 dlog xe 2x one leaves represents correct computation contains value sat however rt possible answers sat ranging 0 rt one possible answer call z appear leaf moreover one leaves contains correct answer z 6 sat thus construct polynomial time turing machine 0 input f prints number z rt z 6 sat show given boolean formula f consider disjunctive selfreduction tree node tree formula children node two formulas obtained instantiating one variables formula 0 1 f root tree tree height exponential size however examine rt levels tree time let rt path tree suppose f i1 2 sat since f i1 child f assume thus promise condition p rt holds use 0 find number z z 6 sat replace subtree rooted f z subtree rooted f z1 f z 62 sat f z1 62 sat promise condition f z 2 sat f z1 62 sat z would equal sat construction thus f z1 2 sat iff f z 2 sat shortened path 1 repeat process paths order paths tree length less rt original formula f satisfiable iff one leaves variables instantiated evaluates true since final tree polynomially bounded check every leaf exhaustively 2 proofs follow need construct graphs maximum clique size occur restricted intervals assist construction define two operators graphs phi andomega also use k denote complete graph vertices definition 11 given two graphs g 1 g 2 graph constructed taking disjoint union vertices g 1 g 2 edges h edges g 1 g 2 plus edges u v vertex u g 1 v g 2 every vertex g 1 connected every vertex g 2 given two graphs g 1 g 2 graph constructed replacing vertex g 1 copy g 2 furthermore edge u v g 1 vertex copy g 2 replacing u connected every vertex copy g 2 replacing v note thatomega commutative higher precedence phi lemma 13 let g 1 g 2 two graphs 42 simple lower bound first lower bound result show oracles x function pf x1 approximate g within factor 2 unless start assumption function f 2 pf x1 approximate g within factor 2 show using function solve promise problem p 2 using one query x construction start input promise problem p 2 pair boolean formulas f 1 f 2 variables using reduction lemma 2 construct two graphs g 1 g 2 vertices sufficiently large b 6 consider effect satisfiability f 1 f 2 h f 1 62 sat f 2 62 sat 1 identical graph composition garey johnson cover garey johnson picture 3clique composed graph three points connected 2 edges hand finally promise condition promise problem case restricts value h 3 nonoverlapping intervals intervals separated factor 2 thus factor 2 approximation h tell us formulas satisfiable example given approximation x guaranteed within factor 2 x 15 delta b know f 1 f 2 satisfiable approximation achieved using one query x solve promise problem p 2 pf x 1 43 general construction section prove general theorem lower bound approximating size maximum clique graph first define class approximation factors definition 14 call function k n r nice approximation factor computable polynomial time following hold 1 9n 2 9n 3 log log km log n log kn please note kn nice kn equals n 1a log n log n constant 2 natural interpretation third condition following consider function kn function fn also related kn third condition satisfied fn increasing fn constant fn decreasing converges limit eg 1 thus fn decreasing almost everywhere must converge limit hence third condition satisfied fn alternates increasing decreasing infinitely often rule functions approximation factors theorem 15 let kn nice approximation factor 1 unbounded 2 converges integral constant 3 converges sufficiently large constant oracles x polynomial time function approximate g within factor kn using log log kn fewer queries x unless log1ffl proof general strategy proof reduce promise problem p r problem approximating maximum clique size graph h within factor kn provides us lower bound complexity p r assuming lower bound complexity approximating h begin input promise problem p r boolean formulas f variables actual value r chosen later convert formula graph g vertices according construction described lemma 2 values g restricted choose gap size g simple example g 2 proof value g r depend however notational convenience make dependency explicit moreover choose g whole number given choices r g construct graph h follows first glance appear polynomial time construction could double size succeeding graph however r turn logarithmically bounded jhj polynomially bounded finally let suppose exists polynomial time function approximates h within factor kn using log log kn queries x want show factor kn approximation h also tells us value sat also want constrain choice g r log log kn able approximate h within kn factor using log log kn queries x would imply make claim choices g r critical already encountered one constraint g r constraints arise analyze possible values h moment assume exactly z satisfiable formulas f sat f sat promise condition p r calculate h follows r estimate size second term bound size maximum clique h want show approximation h within factor g also allow us calculate sat assume provided function approximates h within factor g distinguish case z formulas satisfiable case z satisfiable must upper bound h z formulas satisfiable must smaller factor g lower bound h z satisfiable since condition satisfied constraint g r b similarly constraint would also g hence restricted possible values h r disjoint intervals separated factor g thus given number x guaranteed approximation h within factor kn kn g find largest z gx z b largest z equal important note approximation factor kn depends n size h size original input furthermore value n depends value g thus simple task choose g kn g recall summary must choose g r following constraints hold recall use g gt interchangeably constraint 1 gt r constraint 2 kn gt constraint 3 log log kn n gamma c main difficulty proof choose correct values parameters example satisfy constraint 3 picking large value r however r large constraint 1 harder satisfy also satisfy constraint 2 easily choosing large g large g would force us pick small r violates constraint 3 let show following choices satisfy constraints l log g note g r chosen integers important construction also source difficulties calculations reader may find proof easier follow substituting 2 g two extreme possibilities first show constraint 1 holds choice r r log g bgammas g gamma 1g removing log g isolating b using fact g r r obtain following hence constraint 1 holds also use equation 1 estimate n terms construction know equation 1 know r bgammas hence nice approximation factor monotonic point hence large enough holds finally show constraint 3 holds since suffices show log log kn n 1 ffl2 log kn 1 substituting definition r careful floor notation satisfy constraint 3 showingffl log g log kn n ffl log next step rewrite 2ffl follows recall log log log ffl must less 1 3 constraint 3 showing following two inequalitiesffl log g log log log equation 3 holds since gg gamma 1 bounded 2 n show equation 4 holds first pick enough recall log log dkn consider ratio log kn 0 log dkn 0 e kx always integer ratio 1 kx growing monotonically ratio converges 1 eventually rise constant 11 ffi fact sufficient assume kx unbounded function proof also works kx converges integral constant sufficiently large constant proof work kx small fractional constant eg 25 hence exclude case hypothesis theorem case however prove theorem results worse lower bound thus may assume sufficiently large log log log using third niceness property kx sufficiently large log log log n log kn log kn n thus equations 3 4 true constraints satisfied large enough tin preceding theorem make additional assumptions kn beyond niceness show equation 4 holds willing settle slightly worse lower bound prove similar result nice approximation functions kn alternatively make assumption ffl 14 proofs case nearly identical proof theorem 15 except use fact ratio log kn 0 log dkn 0 e bounded log 2 log 3 06309 since kn 2 n corollary let kn nice approximation factor oracles x polynomial time function approximate g within factor kn using log log kn fewer queries x unless log1ffl corollary 17 let kn nice approximation factor ffl 14 oracles x polynomial time function approximate g within factor kn using log log kn fewer queries x unless log1ffl 5 approximating chromatic number results stated far also hold many npoptimization problems npoptimization problem solutions range 1 n even n upper bound number queries needed approximate problem derived easily techniques section 3 show lower bounds hold need reduction sat new problem similar one clique lemma 2 recently lund yannakakis discovered reductions graph coloring related problems ly94 repeat proof special attention must given differences may arise minimization maximization see section 7 thus could obtain results analogous ones theorem 15 problem approximating chromatic number graph section take alternative approach prove lower bounds using approximation preserving reduction maximum clique size problem chromatic number graph ly94 however reduction increases size graphs proof produce best lower bounds approach extended problems lund yannakakis show approximability properties similar graph coloring show clique partition clique cover biclique cover similar lower bounds follows approximation preserving reductions due simon sim90 clique cover biclique cover reductions preserve approximation ratio within 1 ffl ffl 0 new problems size n o1ffl hand able obtain similar result fractional chromatic number reason reduction preserves approximation ratio log n multiplicative factor following let ffg g denote respectively size largest independent set chromatic number graph g next lemma application results lund yannakakis lemma exists polynomial time transformation g graphs g n vertices primes p n p 2n property furthermore proof proposition 41 2 appendix lundyannakakis ly94 exists polynomial time transformation 0 g p r g graph p prime r r given graph g n vertices define follows let find prime p n p 2n primes exist bertrands theorem found easily since length input n log n let following theorem shows derive lower bound complexity approximating chromatic number graph using lemma theorem 19 let kn nice approximation factor large n oracles x polynomial time function approximate g within factor using log log kn fewer queries x unless proof reduce approximating clique size graph q approximating chromatic number graph h h approximated using queries lower bound approximating q corollary 16 would violated conclude given nice approximation factor kn suppose polynomial time algorithm ag approximates g within factor kn using log log kn queries x graphs g n vertices let k 0 simple check 2k 0 n also nice approximation factor proposition 41 stated lund yannakakis requires p r proofs show fact sufficient use proposition instead main theorem deals general graphs instead special graphs produced reduction lemma 2 given graph q n vertices approximate q within factor 2k 0 n follows construct using lemma 18 q 0 complement q know ffq 0 construct graph h adding dummy vertices h 0 finally use algorithm compute approximation h within factor kn uses log log kn log log queries x since ah factor kn approximation know lemma 18 also know thus value p 3 n 2 ah approximates q within factor since 2k 0 n nice approximation factor corollary 16 approximating q within lower bound log log 2k 0 n log log finally since log log kn 8 computing ah used log log 2k 0 n queries x thus algorithm exists decreases lower bound corollary 16 4 queries decrease due part fact jhj jqj 7 thus efficient reduction clique size chromatic number would yield tighter lower bound also specific approximation especially relationship kn kn 7 explicit obtain slightly better lower bounds reproducing proof theorem 15 6 value ffl lower bound results preceding sections depend value constant ffl 1 recall ffl used arora et al show polynomial time algorithm approximate g within factor n ffl unless note larger value ffl indicates better nonapproximability result turn provides tighter upper lower bounds results previous sections also recall bounded query classes even improvement one query significant currently exact value ffl known however weakening assumption bpp 6 np bellare goldwasser lund russell bglr93 shown polynomial time algorithm approximate g within factor n 130gammao1 improvement made bellare sudan bs94 showed polynomial time algorithm approximate g within factor n 15gammao1 unless section use results obtain explicit lower bounds number queries needed approximate g stronger assumption rp 6 np prove lower bound results need adapt proof techniques previous section work randomized functions instead deterministic functions naive approach would use straightforward modification lemma 2 produce randomized reduction f sat clique size difficulty approach randomized version lemma 10 use randomized reduction polynomially many times thus show lower bounds violated careful value ffi make certain success probability overall procedure remains high enough detailed analysis possible using techniques developed rohatgi roh92 however analysis made much simpler observing randomized reduction sat clique size achieved uniform probability random string z used correctly reduce instance sat certain length following let jf j denote length encoding boolean formula f lemma 20 exist constants b deterministic polynomial time function f boolean formula f jf random string z pt ff z produces graph vertices proof reduction implicit work zuckerman zuc93 include proof sketch completeness proof reduction f constructs graph g formula f random string z random string z used choose disperser graph h allows f amplify probability bounds choosing disperser random step used f randomly chosen h indeed disperser h used reduce formula f variables graph g hence success probability reduction independent particular formula f starting point proof deterministic reduction lemma 2 probabilistically checkable proof sat reported arora et al probabilistically checkable proof sat verifier v uses c 1 log n random bits looks bits proof accepts f 62 sat 8 p rob z2f01g c 1 log nv verifier v input f variables use construction feige goldwasser et al fgl 91 construct graph g construction vertex g represents one computation path verifier v every possible random string every sequence answer bits proof edge added two vertices proof contains answer bits agree computation paths construction gives approximation gap 12 obtain better sults decrease probability v accepts incorrect proof f 62 sat without using many additional random bits decrease achieved deterministically cw89 leads lemma 2 lose track values b alternatively zuckerman zuc93 pointed decrease verifiers error randomly key idea zuckermans construction use special graphs called dispersers first introduced sipser sip86 purposes disperser may defined bipartite graph c 3 vertices left c 1 vertices right left vertex degree every set c 1 left vertices connected least c 1 2 right vertices value constant c 3 chosen later theorem zuckerman attributes sipser zuc93 theorem 3 disperser randomly generated probability choosing neighbors left vertex randomly suppose disperser h use h construct new verifier v 0 interpret left vertex h random string v 0 right vertex h random string v v 0 simulates v randomly choosing left vertex h uses c 3 log random bits let z z right vertices connected chosen left vertex times using z random string v every simulation v accepts proof v 0 accepts proof complete simulation uses c 3 log random bits looks dc 2 bits proof clearly f 2 sat v 0 always accept fact v 0 accept even h desired properties conversely consider case f 62 sat want show v 0 accepts probability less c 1 c 3 suppose v 0 accepted probability c 1 c 3 c 1 left vertices cause v 0 accept thus right vertices connected left vertices must cause v accept since h disperser properties mentioned least c 1 2 right vertices must cause v accept contradicts assumption error probability v thus f 62 sat accepts proof probability less c 1 c 3 construct graph g v 0 described since v 0 uses c 3 log random bits looks dc 2 bits proof graph g vertices big clique size c 3 f 62 sat g small clique size c 1 ratio size big clique size small clique expressed terms n substituting c 3 log thus choosing c 3 large enough recall c 2 number bits proof verifier reads calculation shows effect c 2 value ffl finally observe random step used reduction choosing disperser h 2 results bellare goldwasser lund russell bglr93 used show lemma 20 ratio b gamma produce verifier sat uses 29 bits proof follow zuckermans construction described however unable exploit results bellare sudan bs94 use randomness sampling generate pseudorandom bits nevertheless give explicit lower bounds query complexity approximating g theorem 21 let kn nice approximation factor oracles x polynomial time function approximate g within factor kn using log log kn fewer queries x unless proof prove theorem simply follow proof theorem 15 except use instead lemma 2 reduce sat clique size since success probability reduction independent formula f repeated use reduction decrease success probability overall procedure random step entire procedure randomly choosing disperser graph h also case use tree pruning procedure lemma 10 look satisfying assignment given boolean formula since procedure accepts formula satisfying assignment found never accept unsatisfiable formula procedure may reject satisfiable formula graph h turns disperser however probability happening small thus overall procedure rp algorithm sat finally note equation 2 theorem 15 need show log g log kn n ffl log proof value ffl known rewrite 2ffl asffl beforeffl log g 2 also need additional assumptions kn show log log log log dkn 0 e log log log kn 0 log dkn 0 e log 2 log 3 06309 hence 18 delta log kn 0 log dkn 0 e 11 let 01 thus assumption kn nice suffices 2 using proof techniques described also extend results lower bounds approximating chromatic number corollary 22 let kn nice approximation factor large n oracles x polynomial time function approximate g within factor kn using log log kn fewer queries x unless 7 lower bounds set cover instance set cover problem set system ng asked find size smallest collection covers ng denote size minimum cover setcovers discussed section upper bounds set cover problem different complexity compared clique chromatic number exist polynomial time algorithms approximate size minimum set cover within factor 1 section derive lower bound complexity approximating size minimum set covering terms number queries sat one difficulty arises apply techniques minimization problems illustrate consider construction graph h section 42 use reduction sat clique construct graph g 1 formula f 1 reduction special property f 1 2 sat equality important allows us put two copies g 2 h knew g 1 could large thus ensure large enough gap case sat case f 1 would use 2mt b copies g 2 would make graph h big produce bad lower bounds general theorem equality possible settle good upper bound example reduction sat clique guaranteed f 1 2 sat b need put 6 copies g 2 h general case would obtain lower bound log log 3kn reduction sat set cover ly94 give upper bound size minimum set cover original formula unsatisfiable thus must use following lemma theorem lemma exists constant const l const l log exist set b subsets c 1 sequence indices 1 collection covers b j either c complement c 2 cover b 3 furthermore exists probabilistic turing machine input l binary produces set system probability 23 g let subsets c cm collection subsets b chosen randomly independently ie x 2 b c x 2 c probability one half show probability 23 collection suffices fix statement lemma probability number different j 2 l l thus probability collection 1 covers b bounded l hence probability item 1 occurs least 56 secondly note probability first 11l sets cover b using fact 1 gamma x e gamma2x x 2 0 12 need quantity greater hence need log since log holds large enough l therefore desired constant const found hence probability satisfying item 2 least 56 since probability satisfying item 1 56 probability satisfying item 2 56 probability satisfying least 23 2 theorem 24 given formula let instance set cover described let n size exists integer k depending size 099klog n setcovers 11klog last property holds probability least 23 furthermore reduction applied number formulas size probability 23 instances set cover obtained property proof proof theorem modification construction lund yannakakis ly94 rest proof assume reader familiar notation proof ly94 given formula carry construction section 31 ly94 except use sets bc specified lemma 23 building blocks using ideas ly94 obtain 1 2 62 sat implies setcov ers since first 11l answers every query q 2 cover points lemma 23 since jq 1 theorem follows since l chosen log n ffl 0 also note thus apply lemma 23 furthermore note chosen one set system lemma 23 use number reductions involving instances size thus set system required property reduced instances required propertiesthe consequence theorem exists randomized reduction sat set cover runs time polylog n reduction allows us duplicate construction theorem 15 set cover obtain following lower bound theorem r function n large enough 2 kn n implies log log log km log log n log kn let instance set cover oracles x polynomial time function approximate size minimum set cover within factor kn using log log kn fewer queries x unless np rt imen polylog n proof proof analogous proof theorem 21 start promise problem p r r chosen later since construction time polylog n need different lower bound complexity p r using proof technique lemma 10 one show using fewer dlogr 1e queries oracle x np dt imen polylog n theorem 21 important theorem 24 randomized reduction sat set cover used repeatedly without decreasing success probability overall procedure r sequence boolean formulas variables satisfies promise condition promise problem p r use theorem 24 construct r instances set cover size underlying set since construction takes time polylog n ot polylog know probability 23 11klog restrict attention case combine r instances set cover single instance set cover let n size underlying set define phi andomega positive integer accomplished follows let two instances set cover define 1 phi 2 n 1 g define simply phi repeated times proof theorem 15 value g construction chosen later note construct using g rgamma1 copies 1 instead g rgamma1 copies r backwards compared construction h theorem 15 need make change setcovers small f 2 sat large f 62 sat backwards compared clique good approximation setcov ert solve promise problem p r however approximation must within factor 09g instead g know setcov ers interval log 11k log f 62 sat construction exactly z satisfiable formulas f following bounds 11 thus obtain lower bound approximating size minimum set cover assuming np 6 rt imen polylog n show exist r g satisfy following constraints recall n sizes underlying sets respectively value expressible terms make notation simpler express g r terms instead drop argument altogether constraint 1 gm r 11log constraint 2 kn 09gm constraint 3 log log kn proof let n choose g r follows log g proof theorem 15 choice r implies constraint 1 holds nondecreasing almost everywhere follows kn 09gm constraint 2 also holds finally show constraint 3 holds suffices show following equations hold analogous equations 3 4 theorem 15 log kn equation 5 satisfied large since g 2 2 equation 6 proved follows start niceness assumptions kn obtain log kn ln n log log n log kn log log n 0 log recall n large log 11 thus log log n 0 log log log log using fact x 2 log 3 delta log x logdx09e 1 11 delta log log log log logdkn 0 09e log g log 3 0005 also know large enough 0005 log log 175 delta log211 therefore log g log g therefore equation 6 holds completed proof 2 updates since original submission paper additional connections bounded query classes npapproximation problems discovered chang cha94a showed approximating clique size actually complete certain bounded query classes completeness produces reductions npapproximation problems eg approximating chromatic number approximating clique size addition bounded query classes also used measure difficulty finding vertices approximate clique size cha94b also crescenzi kann silvestri trevisan ckst95 shown finding vertices largest clique cannot reduced finding vertices approximate clique unless polynomial hierarchy collapses bounded query classes also used measure hardness optimization problems ct94 compare various kinds approximation preserving reductions ckst95 acknowledgements authors would like thank richard beigel suresh chari many helpful discus sions thanks also go samir khuller martin kummer frank stephan proofreading drafts paper r connections bounded query classes nonuniform complexity polynomial terse sets proof verification hardness approximation problems probabilistic checking proofs structural theorem depends quantitatively complexity sat bounded queries sat boolean hierarchy efficient probabilistically checkable proofs applications approximations approximating maximum independent sets excluding subgraphs improved nonapproximability results query complexity clique size maximum satisfiability structural complexity column machine model npapproxima tion problems revenge boolean hierarchy boolean hierarchy polynomial hierarchy closer connection structure approximation classes approximation scheme preserving reducibility applications approximating clique almost npcomplete computers intractability guide theory npcompleteness approximation algorithms combinatorial problems complexity optimization problems algebraic methods interactive proof systems ratio optimal integral fractional covers hardness approximating minimization problems saving queries randomness approximate solutions combinatorial optimization problems complicated questions maxima minima closures np boolean closure np tr ctr richard chang bounded queries approximations boolean hierarchy information computation v169 n2 p129159 september 15 2001
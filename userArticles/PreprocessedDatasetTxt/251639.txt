intelligent backtracking schema logic programming environment present new method represent variable bindings warren abstract machine wam ages variable bindings easily found using new representation intelligent backtracking schema age variable bound nonvariable term youngest choice point backtracking choice point make variable unbound variable procedure backtracking point choice point procedure currently executed choice point first ancestor choice point variable ages procedure backtracking points used process figuring backtracking points intelligent backtracking schema intelligent backtracking schema performs much better results intelligent backtracking methods literature deterministic programs performance nondeterministic programs comparable results b introduction backtracking method used standard prolog implementation known naive backtracking naive backtracking goal fails backtracking done recent choice point failure last alternative although choice point may nothing failure approach lot unnecessary backtrackings done even though failure occurs many times intelligent backtracking method analyzes reasons failures choose proper choice points avoid redundant backtrackings chosen choice point may recent choice point failure words alternatives choice points recent one chosen one discarded without retrying retried system reencounter failure warren abstract machine wam abstract machine prolog execution consists instruction set several data areas instructions operate wam recognized breakthrough design prolog systems computational logic systems logic programming community many commercial 2 15 noncommercial 3 prolog systems based wam implemented last decade paper assume reader familiar wam details wam found warrens original paper 17 kacis tutorial book wam 1 many intelligent backtracking schemes 4 5 6 7 9 11 12 13 14 16 19 presented avoid unnecessary backtracking steps early works intelligent backtracking 4 9 14 implemented prolog interpreters implementations later works 6 7 11 12 wam based systems intelligent backtracking schema whose parts presented paper implemented extension wam like systems 6 11 mechanism similar mechanisms used systems except way keep unification information variable bindings find reasons failures mechanism find ages variables causing failures central part intelligent backtracking schema paper concentrate new representation variable bindings wam ages variables easily found mechanism propose naturally integrated wam architecture performance results better performance results systems 4 6 11 rest paper organized follows section 2 summarizes related research intelligent backtracking section 3 introduces procedure backtracking points play important role determination variable ages section 4 present unification graphs give concrete definition variable ages prolog variables section 5 present new representation bindings wam variables algorithm find ages wam variables bound nonvariable terms mechanism used figuring intelligent backtracking point procedure call failure described section 6 finally present performance results section 7 related research research intelligent backtracking started late 70s initial proposals made bruynooghe pereira 4 cox pitrzykowski 9 two systems implemented extending prolog interpreters methods collect information bindings unification analyze determine intelligent backtracking point failure occurs also retain information failure ensure failure repeated reason methods known intelligent backtracking methods based unification failure analysis backtracking schema similarities bruynogghes work sense also collect information bindings tagging bindings determine intelligent backtracking points analyzing tagged bindings failure however schema implemented wambased system prolog interpreter lin kumar leungs schema 10 11 12 chooses intelligent backtracking points analysis literals instead analysis unification failures early work 10 used data dependency technique clause level parallel execution logic programs similar mechanism used woo choe 19 andor parallel process models lin kumar 11 12 extend method sequential execution prolog using data dependency technique whole proof tree instead data dependency technique clause level later integrated technique wam wambased implementation maintain list goals goal called blist represent goals backtracking goal may cure failures goals list also tag variables represent data dependency graph tags used figure bindings causing failure goal reduce overhead constructing data dependency graph chang despain 5 construct worstcase data dependency graph compile time clause since backtrack literals chosen compile time schema little bit overhead run time however method capable handling better situations run time tries meet requirements worst case method also needs information possible activations goals compile time analysis information must given user without information static datadependency analysis may degenerate naive backtracking main responsibility user efficiency method depends well possible activations goals marked codognet colleagues propose depthfirst intelligent backtracking schema 6 give wambased implementation 7 schema unification instructions record source bindings failure routines choose intelligent backtracking point update sets intelligent backtracking points unifications create simplified version unification graph records time bindings also attach set intelligent backtracking points literal sets created first entrances literals maintained backtracking process minimize maintenance overhead sets bitvectors used implement claim forward overhead schema occurs unifications compared wam backward overhead occurs failures 5 accept total overhead deterministic programs 20 toh ramamohanrao 16 propose intelligent backtracking schema require datadependency analysis information collected unification according method failed atom used figure intelligent backtracking point since failuredirected mechanism less accurate unificationbased schema schema gives less accurate results compared unification based schemes including schema intelligent backtracking methods literature associate kind sets literals store intelligent backtracking points sets called alternative backtracking points 6 7 blists 12 rejected procedures 4 witness sets 18 candidate sets 8 sets updated either unification failure main difference method maintain kind sets method tag bindings unifications use information tagged bindings figure intelligent backtracking points failures overhead method occurs try find intelligent backtracking point failure methods big percentage overhead intelligent backtracking mechanism occurs maintain sets since methods create sets unification pay heavy penalty even deterministic programs mechanism however pay penalty failures therefore gain intelligent backtracking mechanism nondeterministic programs compensate overheads since mechanism little overhead unification overheads cause big penalties deterministic programs fact forward overhead schema occurs unifications 3 procedure backtracking points regular prolog system backtracking made recent choice point failure occurs due unification failure occurs variable bound nonvariable term cannot unified different nonvariable term unification algorithm cannot unify two variables bound two different nonvariable terms since variable bound nonvariable term responsible failure reoccurrence failure avoided backtracking choice point variable bound nonvariable term unification occurs backtracking recent alternative regular prolog system may fix problem failure may occur thus backtrack youngest choice point variable causing failure unbound choice point called reason failure also avoid failure backtracking first alternative clause failure occurs means completely skip clause unification causing failure occurs course youngest one two points going backtracking point failure intelligent backtracking schema give definition formally describe procedure backtracking point definition 31 procedure backtracking point let p current procedure executed procedure backtracking point certain time execution ffl choice point p p choice point ffl choice point ps first ancestor choice point otherwise unification graph variables b unification graph terms notation unified choice point procedure p procedure backtracking point figure 1 unification graphs procedure backtracking point indicates furthest choice point system backtrack failure failure occurs system backtrack choice point recent one procedure backtracking point procedure backtracking point equal recent choice point known shallow backtracking case recent choice point tried procedure backtracking point older recent choice point case point system backtrack depends reason failure reason failure indicates choice point older procedure backtracking point backtrack procedure backtracking point backtracking current procedure backtracking point completely skip clause unification causing failure occurs words reencounter failure going execute unification wam based implementation intelligent backtracking schema introduce new register pb procedure backtracking point hold procedure backtracking point addition registers original wam architecture register pb updated new choice point created try instruction previous value register pb saved new choice point try instruction backtracking register changed point backtracked choice point fact choice point recent choice point time register pb also restored saved value choice point choice point discarded pb register saved environments allocate instruction way saving environment register e except register pb updated allocate instruction reason saving environments restored stored value current environment proceed instruction proceed instruction executed get context procedure return context one ancestors since ancestor environment procedure backtracking point saved environment register pb restored value unification graphs section introduce unification graphs represent unifications variables prolog program aim section define concept age variable prolog environment age prolog variable bound nonvariable term causes failure plays important role figure intelligent backtracking point failure unification graph set variables labeled acyclic undirected graph vertices graph variables set edge represents unification variables indicated two vertices label edge indicates age unification age unification procedure backtracking point unification backtracking choice point indicated age unification avoid reoccurrence unification words backtracking age unification completely skip clause unification occurs figure 1a gives unification graph three variables x z nonvariable term g labels edges names procedures whose choice points procedure backtracking points unifications example x unified g procedure backtracking points unifications choice points procedures p r respectively unification z choice point procedure q procedure backtracking point note variables bound nonvariable term g result three unifications graph labels edges reflect times unifications three unifications given graph figure 1a performed order age prolog variable bound nonvariable term youngest one among choice points indicated labels path variable nonvariable term unification graph failure occurs variable bound nonvariable term backtracking one choice points indicated labels path variable nonvariable avoid reoccurrence failure figure 1a z bound constant g result three unifications ages p q r age z youngest one p q r variable bound complex nonvarible term constant age variable determined depending part term causes failure figure 1b x unified term fy unified nonvariable term g x causes failure tried unified nonvariable term functor f constant g cause failure first case use youngest one unification ages path x case 1 timexy timey z timexg pxy qyz case 2 timexy timexg timey z pxy oe qyz z case 3 timey z timexg timexy qyz pxy oe rxg case 4 timey z timexy timexg qyz z oe pxy case 5 timexg timexy timey z oe pxy z case oe pxy z oe qyz notation pxy l2 location l1 bound location l2 unification age unification p variables involved unification x time unification x relations used indicate younger older relations among times assumption creation order variables g z x live data area heap figure 2 corresponding reference chains unification graph term fy figure intelligent backtracking point second case use youngest one unification ages paths x fy g 5 ages wam variables section present new representation technique bindings wam locations discuss variable ages terms binding ages wam locations use unification graphs directly wam based implementation unification graph mapped different structures wam locations calculate age wam location corresponding prolog variable different structures wam locations variable wam chain locations ending unbound location nonvariable term since nonvariable terms cause failures unifications concentrate reference chains ending nonvariable terms unbound location bound another location operation called binding variable binding reference chain causes failure binding backtrack procedure backtracking point time binding note age binding may recent choice point time binding following example ages bindings similar bindings variables x must equal q ages bindings x 1 2 equal namely choice point p p q note recent choice points different bindings age bindings choice point procedure p procedure backtracking point bindings thus procedure fails due binding 2 backtrack choice point p instead choice point q definition 51 age binding age binding procedure backtracking point register pb time binding definition corresponds definition age unification unification graphs obvious age binding must equal age unification causing binding prolog since need ages bindings use extra entries store information bindings representation method use four value cells bound wam location first value cell holds actual value stored result binding operation pointer another wam location constant procedure backtracking point binding saved second position age binding may different recent choice point binding third fourth positions hold first locations variables whose unification causes binding unification graph mapped different structures wam locations depending times unifications creation times locations variables graph let us assume locations xy z g figure 1a created reverse order ie creation order g z x data area six different structures reference chains variables depending times three unifications graph figure 2 gives reference chains six cases figure arrow represents binding label arrow represents age binding first locations variables whose unification causes binding example case 5 function location nonvariable term end reference chain v else f notvisited junctionset visited empty done done f delete first node x ageset xy notvisited else f w z ageset wz junctionset xy w z 6 x w z 62 visited w z 62 notvisited add w z ageset wz notvisited last node w z ageset wz visited x w z share common location f let b c new pair b c locations x w z b c 6 x b c 62 visited b c 62 notvisited add b c ageset xy ageset wz notvisited last node g add x ageset xy visited last node g g age v youngest ageset v return age v g figure 3 algorithm find age variable bound ground term arrow z g labels q z represents binding z g age binding q first locations variables causing binding z note q also age unification z corresponding unification graph figure 1a definition 52 age set binding two locations let x two wam locations reference chains join location age set binding x set ages bindings causing junction use notation ageset xy represent age set binding x definition 53 age wam location assume x wam location whose reference chain ends location g holding nonvariable term age x youngest age ageset xg use notation agex represent age x reference chains two locations end location must junction location worst case junction location last location reference chains example x case 3 figure 2 location g junction location junction location z z definition 54 junction set x junction location z junction set set bindings x z z use notation junctionset xy junction set x item junction set pair representing binding first element pair also pair first locations variables whose unification causes binding second element binding pair singleton set age binding example junction set x case 3 figure 2 equal fy z fqg x fpg x g frgg junction set z fy z fqgg fact junction set special form sets bindings age sets set bindings age sets junction set except second element binding pair nonempty set ages binding age pair z fqg means z bound unification whose age q general age set binding age pair represents ages unifications causing binding two locations pair figure 3 gives algorithm written pseudocode find ages variables bound nonvariable terms algorithm first find location g nonvariable term end reference chain given variable v v equal g age location nonvariable term age v otherwise construct ageset v g set ages unifications causing binding v g find age v start junction set junctionset v g v g accomplish task age least one bindings junctionset v g ageset v g continue enlarge set bindings age sets adding junction sets variables bindings currently set new bindings constructed joining two bindings set two bindings joined get new binding share common variable words bindings x z create new binding x z age set new binding union age sets bindings involved join operation bindings considered put set visited rest bindings stay set notvisited new bindings added notvisited produced earlier enlargement set check whether find binding v g enlargement stops find algorithm breath first search search space possible bindings since age variable youngest age age set compute youngest age age set instead computing whole set actual implementation algorithm example shows enlargement steps algorithm tries find age z case 3 figure 2 step give sets visited notvisited indicate current search space bindings ffl calculate junctionset zg assign notvisited adding junctionset xy results join operations bindings visited notvisited ffl visit z adding junctionset z results join operations z fqg bindings visited notvisited ffl visit x g adding junctionset xg results join operations x g frg bindings visited notvisited ffl visit x z adding junctionset xz results join operations x z fp qg bindings visited notvisited ffl visit g adding junctionset g results join operations g fp rg bindings visited notvisited ffl visit z g found ageset zg ageset ffl choose youngest age ageset zg agez optimize algorithm stop search immediately binding z g fp q rg found visit binding x z fp qg 6 finding reasons procedure failure failure normally occurs unification head arguments unification instructions used head matching divided two groups instructions first group eg get constant unify constant try unify variable specific nonvariable term failure occurs variable bound nonvariable term different specific nonvariable term second group instructions eg get val unify val complete unification instructions take two variables unified case failure occurs variables bound two different nonvariable terms first case age variable determines reason failure second case youngest one ages two variables plays role determination reason failure cases reason failure point choice point actually procedure backtracking point binding causing failure procedure call fails clauses procedure fail reason failure procedure call youngest one failure reasons clauses store youngest reason procedure failure reserve space choice points point call field choice points rb reason backtracking point field initialized special value creation choice point try instructions failure rb field choice point indicated procedure backtracking point register pb may updated reason failure updated reason failure reason younger value stored rb field rb field always holds youngest one failure reasons clauses procedure question failure occurs failure reason r points choice point failure routine compares r value stored register pb r younger pb r chosen backtracking point means stay context current clause procedure owning choice point indicated pb words clause failed yet r equal pb clause procedure owning choice point indicated pb fails failure depend outside reason case r chosen backtracking point r older pb clause fails due outside reason since procedure alternatives backtracking point next alternative choice point indicated pb register since clause procedure question fails reason clause failure may needed recorded rb field choice point course reason recorded younger failure reasons previous clauses procedure mapcolorabcde nextxy next1xy next1greenred next1redyellow nextab nextac nextad nextxy next1yx next1greenyellow next1redblue nextae nextbc next1greenblue next1yellowblue figure 4 map coloring programs codognet kumlin bruper 6queensnaive 24 26 25 15 8queensnaive 51 69 44 circuit design 44 42 25 mapcolorbad mapcolorgood 117 12 11 20 tree 103 12 11 14 table 1 speedups intelligent backtracking methods wrt prolog since need choose youngest reason among failure reasons clauses procedure failure reason procedure call procedure also need failure reason last clause make decision means choice point procedure discarded last clause fails reason trust instructions implementation discard choice points behave way retry instructions except put address new wam instruction discardfail instead address next clause choice points last clause procedure fails new instruction discardfail executed discard recent choice point invoke failure reason stored rb field choice point means procedure call going fail youngest one failure reasons clauses note need create choice point procedures single alternative failure reason procedure call procedure failure reason single clause 7 performance results extended byte emulator wam based system als applied logic systems prolog implement mechanism observe gains overheads system tested programs three categories addition standard test programs intelligent backtracking systems first category includes programs lot unnecessary backtrackings regular prolog system system gives good performance programs avoids lot redundant failures map coloring program given figure 4 good example category regular prolog system 147 failures finds solution system 15 failures terms cpu time system 6 times faster prolog system example program last subgoal fails first values variables b c regular prolog system alternatives third fourth subgoals tried second subgoal retried get another value variable c although responsible binding variables b c schema last subgoal completely failed system backtracks next alternative second subgoal without retrying third fourth subgoals second category contains prolog programs lot backtrackings redundant kind programs use machinery schema without gain fact kind programs represent worst case schema example put subgoal nextbc third subgoal clause figure 4 redundant failures case system regular prolog system backtrackings slowdown system 17 percent compared regular prolog system deterministic programs last category since overheads schema occur failure analysis want see effects deterministic programs tested system completely deterministic program slowdown system 23 percent result real encouragement overhead schema minimum failures fact reflects overhead keeping extra information binding operations maintaining pb register storing register choice points environments lot failures gains avoiding redundant backtrackings overheads due complex failure routine also tested implementation certain benchmarks compare results intelligent backtracking methods presented 4 7 12 table 1 shows speed ups slow downs intelligent backtracking methods respect different prolog systems figures table give comparison intelligent backtracking scheme byteemulator als prolog positive numbers reflect speed ups intelligent backtracking schemes negative numbers reflect slow downs table 1 shows speed ups scheme worse results methods nondeterministic programs naive versions nqueens problem circuit design problem bad version map coloring problem good version map coloring problem reflects worst case scheme lot failures program gain much intelligent backtracking scheme problem means worst case still good methods best part scheme low overhead deterministic programs slow downs scheme deterministic programs clever version nqueens problem tree problem much better results methods problems 8 conclusion intelligent backtracking mechanism whose parts presented chooses youngest choice point backtracking failure backtracking choice point avoid reoccurrence failure guaranteed chosen backtracking point youngest choice point backtracking choice point younger chosen choice point cannot avoid recoccurence failure means mechanism chooses exactly right position backtracking new method representation bindings wam variables plays important role process finding ages variables bound nonvariable terms age variable procedure backtracking point introduced determine backtracking point failure due variable new representation smoothly integrated original wam architecture small overheads since overheads system occur failure unification process suitable intelligent backtracking schema overheads unification occur every type program r applied logic systems fast incremental portable prolog compiler deduction revision intelligent backtracking yet another intelligent backtracking method extending wam intelligent backtracking implementing backward execution nondeterministic andparallel systems basis intelligent backtracking intelligent backtracking algorithm parallel execution logic programs intelligent backtracking schema prolog intelligent backtracking plan based deduction quintus prolog reference manual abstract prolog instruction set semantically transparent selective reset parallel interpreters based origin failures selecting backtrack literal andor process model tr
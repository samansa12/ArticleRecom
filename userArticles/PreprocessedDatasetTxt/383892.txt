querying atsql databases temporal logic establish correspondence temporal logic subset atsql temporal extension sql92 addition provide effective translation temporal logic atsql enables user write highlevel queries evaluated spaceefficient representation database reverse translation also provided paper characterizes expressive power syntactically defined subset atsql queries b introduction paper brings together two research directions temporal databases first direction concerned temporal extensions practical query languages sql gad93 na93 sar93 issues addressed include spaceefficient storage effective implementation techniques handling large amounts data direction includes atsql sjb95 integration ideas tsql2 sno95 chronolog boh94 second direction research focuses highlevel query languages temporal databases based temporal logic tc90 gm91 cct94 advantages using logicbased query language come wellunderstood mathematical properties ghr94 declarative character languages also allows use advanced optimization techniques addition temporal logic proposed language choice formulating temporal integrity constraints triggers cho95 ct95 gl96 ls87 sw95 admitting spaceefficient methods enforcing constraints temporal logic may seem natural choice temporal query language semantics defined respect abstract temporal databases timeinstantindexed sequences database states ghr94 point view often disqualified temporal logic practical temporal query language efficiency reasons construct store individual states explicitly indeed impossible sequence finite therefore practical proposals associate concise encoding set time instants particular fact holds tuple representing fact encoding commonly realized period 1 na93 sar90 sno87 tan86 temporal elementa finite union periods cc87 gad88 sno95 contributions paper twofold first develop translation temporal logic atsql translation allows users take advantage highlevel declarative language queries still efficiently evaluated compactly represented atsql temporal databases use period encodings translation also dispels myth logicbased temporal query languages inherently inefficient approach presented paper shows queries expressed temporal logic evaluated efficiently queries practical approaches mentioned also develop syntactic criterion guarantees safety queries temporal logic broad enough contain equivalents domainindependent queries second present reverse translation syntactically defined subset atsql clarify expressiveness picture although use atsql domain reverse translation results apply minor adjustments temporal query language uses distinguished periodvalued attribute represent valid time facts stored database enforces coalescing encoding paper organized follows start discussion basic framework section 2 including syntax semantics temporal logic atsql case atsql introduce constructs relevant development paper full description see sjb95 section 3 give mapping temporal logic atsql conclude section example discussion implementation issues section 4 discuss reverse mapping relate expressive power subset atsql temporal logic section 5 discusses relations temporal query languages including impact presented results 2 basic framework start comparing temporal logic atsql need set common formal framework suitable languages paper fix structure time integerlike linear totally discrete unbounded past future however approach easily adopted structures time eg bounded past natural numbers like time dense rationallike time proposed mapping changes minor ways accommodate extensions also assume single fixed time granularity one year references time paper represent validtime references capturing relationship individual time points validity facts reality jce 94 particular transaction time relates facts stored database considered standard temporal logic deal single temporal dimension finally restrict discussion pointbased view temporal databasethe view adopted temporal logic atsql periodbased use coalescing enforce strictly pointbased semantics coalescing unary operation atsql temporal relations merges valueequivalent tuples adjacent overlapping periods single tuple bss96 throughout make sure base relations well intermediate relations coalesced 21 temporal logic temporal logic abstract query language language defined respect class abstract temporal databases cho94 ct98 abstract temporal database turn database cap 1 paper use term period rather term interval commonly used temporal logic latter term conflicts sql intervals unanchored durations 3 months tures formal semantics temporal database without considering particular representation issues possible view abstract temporal database several different equivalent ways choose snapshot view cho94 every time instant associated finite set facts hold integerlike time abstract temporal databases viewed infinite sequences finite database states form example 21 figure 1 presents example abstract temporal database viewed sequence states database represents information eastern european history modeling independence various countries cho94 fact indicates independent nation capital relation used running example throughout paper year timeslice figure 1 eastern european history abstract temporal database syntax firstorder temporal logic fotl extends first order logic binary temporal connectives since unary connectives 5 previous yesterday 4 next tomorrow informally since b true state true states b true state b true state true future b true rest usual temporal connectives defined terms eg true since true sometime past true sometime future true always past true always future rest paper also consider universal quantifier 8xa shorthand 9xa implication b shorthand b etc example 22 first example query relate different database states query determines years poland slovakia independent country ie times query evaluates true example 23 second example relates different database states query returns name city superseded cracow polands capital years city capital example 24 consider query cho94 p515 list countries lost regained indepen dence abstract temporal database shown figure 1 formulated temporal logic country year result country independent past independent future currently independent formally semantics temporal logic queries defined follows definition 25 abstract temporal database integer indexed sequence database states every database state contains relation relation instance r relation schema r define semantics temporal logic formulas terms satisfaction relation j valuation valuation mapping variables constants result applying variables r valuation identical except maps x c answer temporal logic query set g thus temporal logic may viewed natural extension relational calculus indicated example queries temporal logic provides convenient means expressing rather involved english queries natural way however statebased semantics temporal logic suggest efficient implementation queries implementation taking advantage compact periodbased representation temporal databases promises much better performance 22 atsql atsql sjb95 development tsql2 temporal extension sql92 early version atsql proposed iso international committee standardization incorporation sqltemporal standard implemented therefore use target query language translation atsql databases period pair b left endpoint b right endpoint period b used encode set instants ft ja bg validtime relation finite relation tuples implicitly timestamped periods atsql database finite collection validtime relations figure 2 shows atsql database encodes abstract temporal database shown figure 1 remember throughout paper assume indep country capital valid czech kingdom prague 1198 1620 czechoslovakia prague 1918 1938 czechoslovakia prague 1945 1992 czech republic prague 1993 1 slovakia bratislava 1940 1944 slovakia bratislava 1993 1 poland gniezno 1025 1039 poland cracow 1040 1595 poland warsaw 1596 1794 poland warsaw 1918 1938 poland warsaw 1945 1 figure 2 eastern european history concrete atsql relation atsql temporal relations coalesced timestamps represented maximal nonoverlapping periods assumption fundamental translation temporal logic queries atsql work correctly atsql queries atsql extends query language sql92 ms93 crucial concepts atsql statement modifiers flags prepended queries modify temporal behavior consequence atsql queries come three flavors 1 sql92 queries without additional flags executed temporal database respect current time instant 2 sql92 queries preceded sequenced valid flag evaluated relative every snapshot temporal database results collected temporal relation timestamps corresponding evaluation point cf snapshot reducibility sjb95 3 sql92 queries preceded nonsequenced valid flag case processing timestamps completely controlled query rather implicit mechanism underlying dbms words enclosed statement executed standard semantics timestamps treated like attributes builtin temporal processing performed manipulation timestamps made explicit using following constructs ffl given period p beginp denotes start point p endp endpoint p often use shorthands respectively denote endpoints ffl given two time points b e b e periodbe denotes period constructed two time points instants often use shorthand b e ffl use integer constants denote time instants eg 1998 stands year 1998 also include constants denoting start time timestamp beginning gamma1 end time timestamp forever 1 ffl dislocate given time point one year 2 similar fashion dislocate periods dislocate period one year resulting period b ffl finally use firstts lastts find earlier later respectively point syntax used manipulate timestamps atsql selectblocks first need gain access implicit validtime attributes atsql relations vtimer denotes timestamp associated range variable tuple relation r substitutes lack explicit temporal attributes clause uses temporal builtin predicates specify temporal relationships periods relationships two periods expressed using order relationships endpoints atsql also supports allen algebralike comparisons pairs periods wont use paper consistent sql2 relationships somewhat different meaning identicallynamed relationships all83 easy see relationships boolean combinations express period relationships all83 thus possible topological relationships two periods metric relationships captured using timestamp constructs finally set valid p clause part nonsequenced valid statement modifier precedes actual query defines p resulting timestamp period tuples answer query p usually function vtimer attributes addition every query table reference followed valid flag enforce coalescing corresponding temporal table tuples identical explicit attribute values whose validtimes overlap adjacent merged single tuple period equal union periods original tuples sideeffect duplicates eliminated example 26 order determine name city superseded cracow polands capital cf example 23 query relate different database states atsql means specify valid clause required temporal relationship results following atsql query nonsequenced valid select i1capital indepvalid i1 indepvalid i2 2 paper assume validtime uses granularity year thus 1 shorthand interval 1 year 1 interval 1 year example 27 formulation query becomes even simpler answered looking single snapshots case user simply specifies sequenced semantics formulating query illustrated following query determines periods poland independent slovakia cf example 22 select i1country indepvalid i1 exists select indepvalid i2 proposed translation uses sequenced valid variant atsql queries translate firstorder fragments temporal logic queries nonsequenced valid queries translate temporal connectives mapping temporal logic atsql section introduce main result paper translation queries formulated temporal logic atsql similarly mapping relational calculus queries sql translation identify syntactic subset domainindependent temporal queries safely translated atsql syntactic criterion based extension criterion presented ahv95 however approach analogously used complicated translations eg vgt91 discuss several possible refinements section 35 31 correspondence temporal databases describe actual mapping temporal formulas atsql need establish relationship temporal databases semantics temporal logic queries defined atsql databases target translation definition 31 let abstract temporal database support temporal logic formula valuation set time instants support ground formulas facts particular depend valuation way definition support yields definition class abstract temporal databases interested definition 32 abstract temporal database finitary contains finite number facts support every fact represented finite union periods every abstract temporal database finitary example database contains single fact pa every evennumbered state whose every oddnumbered state empty cannot finitely represented union periods hand class finitary temporal databases captures exactly atsql databases proposition 33 every atsql database represents unique finitary abstract temporal database every finitary abstract temporal database represented atsql database rest paper use kk denote mapping atsql databases corresponding finitary abstract temporal databases 32 domain independence range restriction actual translation temporal logic queries atsql based semantic rules definition 25 however problem direct use rules interpretation variables relative potentially infinite universe data values thus easy formulate unsafe queries temporal logic produce nonfinitary answers use quantification infinite universe data values similarly relational calculus ahv95 avoid problems introduce notion domainindependent temporal logic queries definition 34 let fotl query abstract temporal database define active domain adomd set data constants appear interpretation j u definition 25 relativized universe data values u assume u always contains data constants appearing query temporal database temporal logic query domainindependent sets u 1 u 2 adomd u 1 u 2 valuation free variables note definition relativizes interpretation queries respect data domain universe time instants fixed integerlike linear order z easy see obtain answer domainindependent query sufficient evaluate query using active domain interpretation ie adomd moreover formula characterizing active domain fixed query expressed uniformly temporal logic query lemma 35 let abstract temporal database temporal query formula adomd x 8i 2 zd c set constants r set formulas form r predicate symbol corresponding relation database 9 x string existential quantifiers free variables r x define used restrict variables domainindependent temporal logic queries without changing meaning present syntactic criterion guarantees domainindependence temporal logic que ries domain independence decidable class temporal logic queries contains relational calculus queries show safe range queriesthose queries pass syntactic criterioncan express domainindependent queries temporal logic criterion based modification criterion relational calculus queries ahv95 treat binary temporal connectives since ignore unary ones 3 1 2 0 5 4 definition 36 range restriction rr let arbitrary temporal query fv set free variables define oe since say formula safe range subformulas form 9x x 2 fv oe x 2 rr note extension original criterion relational calculus queries strongest possible map since ignore unary temporal connectives achieve better results would start stronger criterion first order case eg vgt91 theorem 37 let domainindependent query equivalent safe range query domainindependent query correctly evaluated using activedomain semantics active domain adomd defined uniformly temporal logic query adomd x cf lemma 35 add conjuncts restrict domain every variable subformulas resulting formula equivalent safe range follows easy induction structure formula 2 therefore every domainindependent query equivalently asked using saferange query moreover lemma 38 let finitary abstract temporal database saferange query also finitary induction structure sufficient observe temporal connectives preserve finitary properties ii variables rangerestricted 2 however domain independence preserved equivalence queries rr criterion define normal form temporal logic queries improve chances discovering equivalent saferange reformulation given query definition 39 srnf arbitrary temporal logic query define variable substitution rename quantified variables using unique names avoid variable name clashes subsequent transformations removal 8 replace subformulas form 8xa 9xa removal replace implications b ab similarly equivalences pushing negations use following rules push negations towards leaves formulas remove double negations 1 7 2 9xa 7 x 62 fv 3 4 3a 7 1a 1a 7 3a 2a 7 0a 0a 7 2a 5 4a 7 4a 5a 7 5a 6 since b srnf resulting applying rules temporal formula long possible denoted srnf note last rule since valid discrete time dense time omit rule 3 time bounded past would also remove part handling 5 rule 5 equivalence hold time bounded past natural numberslike clearly transformations equivalencepreserving thus lemma 310 db thus end step left equivalent cleanedup temporal formula addition easy see lemma 311 let saferange srnf lemma guarantees applying srnf tl transformation given query improve chances query passes rr criterion thus rr criterion always applied result srnf saferange criterion rr assumes since connectives behave like unfor tunately temporal connectives commutative distributive properties eg oe 6j oe however easy see variable x formula px qx saferange atomic formula qx clearly valuation db must another time instant 0 db 0 qx thus formula qx gives us range restriction x exploit fact propagate range restricting subformulas towards leaves original formula using following equivalences lemma 312 oe j oe 3oe oe j oe 2 show first equivalence proof second one analogous definition know j db j using definition get db let db similarly previous case j thus db similar lemma holds since connective using equivalences move range restricting subformulas left righthand sides since connectives addition may need move range restricting formula scope temporal connective lemma 313 oe j oe 3oe j oe43 prove first statement definition know j db j using definition get db 3 rule may also significantly increase size resulting formula may want use even case discrete time distribute since lefttoright distribute lefttoright since distribute since righttoleft distribute righttoleft b since c 7 52a b since c push since left side b c 7 43a b c push left side c since b 7 c since 2a b push since right side c b 7 c 3a b push right side rules used x variable range restricted subformula denoted x 2 rra free range restricted subformula denoted b x figure 3 ranf rules let db similarly previous case db implied db similar laws hold remaining connectives including unary ones cf rewriting rules definition 314 use laws final step conversion propagate range restricting subformulas towards leaves query way final atsql query always evaluated bottomup goal achieved modified ranf transformation ahv95 definition 314 ranf safe range temporal formula ranf result applying rules figure 3 together commutativity associativity conjunction starting toplevel connective clearly rewriting rules preserve meaning formula lemma 315 db follows lemmas 312 313 standard equivalences first order logic 2 also easy see every rule figure 3 propagates xs restriction towards b lemma 316 let safe range temporal formula every subformula ranf rooted safe range assume ranf contains subformula rooted safe range case analysis show safe range none rules definition 314 applicable assumption contradiction 2 similarly ahv95 ranf rewriting terminates finitely many subformulas original query moreover every safe range temporal query domain independent lemma 317 let saferange temporal query domain independent equivalent ranf query equivalence preserves domain independence sufficient show ranf tl domainindependent follows easy induction structure ranf applied every subformula ranf result together theorem 37 shows classes domainindependent queries saferange queries coincide translation defined three steps 1 first step corresponds transforming formula srnf essentially clean formula remove superfluous connectives especially double negations 2 second step test variables cleaned formula saferange property 3 formulas pass checkthe safe range formulaswe propagate range restrictions significant subformulas also became safe range 33 translation atsql next step traditional translations translation relational algebra however chosen atsql target language translation temporal logic formulas ranf tl atsql defined induction structure formula input transformation saferange temporal logic formula ranf tl translated atsql repeating following two steps 1 first maximal nontemporal subformulas translated sequenced sql queries done using simple ranf tl sql translation patterned eg ranf relational algebra translation ahv95 2 translations subformulas combined using translations temporal connectives defined next section process repeated whole formula translated 331 temporal logic connectives define translations individual temporal connectives atsql atsql query templates subformulas rooted temporal connectives translated subqueries embedded templates connectives since figure 4 graphically illustrates semantics since periods listed possible temporal relationships all83 truth periods two formulas b relationship determined truth period since b b respectively formally truth periods since b b defined follows since b 7 temporal relationship formulas b temporal logic since b since b since b since b since b since b since b since b since b since b since b since b since b truth period formula f figure 4 period semantics since reader may verify general expressions evaluated particular relationship given figure 4 result correct truth period expressions translated atsql straightforwardly using nonsequenced valid modifier specifying final timestamp using set valid clause additional conditions translated appropriate clause conditions precisely since b translated nonsequenced valid select b translated nonsequenced valid select 0 b 0 results applying translation recursively b respectively select lists atsql statements derived sets free variables occurring b variables used b give rise additional clause conditions equate corresponding attributes 0 b 0 important remember translations nonatomic formulas b required produce coalesced temporal relations example 318 consider temporal database containing two temporal relations ax bx 9 easy see coalescing enforced every step translation eg relation recoalesced projecting x attribute translation would correct indeed applying translation noncoalesced results 9xa 9xb would give us result 2 4 9 instead correct result 2 0 9 332 specialized mappings based translation since mapping temporal connectives defined theoretically feasible approach may cumbersome practice leads unnecessarily complicated atsql statements moreover introducing specialized mappings allows us translate wider class temporal formulas atsql cf section 32 connectives 3 2 illustrate definition since used derive efficient special purpose mapping 3 formula 3b equivalent true since b therefore take definition since b section 331 substitute true notice truth period true whole time line means beginvtimea0 evaluates gamma1 beginning time endvtimea0 evaluates 1 end time obvious simplifications obtain nonsequenced valid select considerably less complex original statement similarly use definition derive mapping 2b namely nonsequenced valid select connectives 1 0 1a one rewrite 3a use approach presented unfortunately approach practical may lead formulas cannot translated eg 3px versus 1px therefore derive atsql translation 1a definition easily expressed atsql beginning keyword stands gamma1 nonsequenced valid select coalescing 0 crucial translation work correctly analogy special purpose mapping 0a derived nonsequenced valid select connectives 5 4 use discrete time model temporal domain atsql databases thus addition since connectives add temporal connectives allow us refer immediately previous 5 immediately following mapping connectives defined follows first define truth periods 5a 4a respect truth period result translated atsql using definition corresponding validtime clause shifts validtime period one appropriate direction translation 5a nonsequenced valid select translation 4a nonsequenced valid select similarly previous cases select list obtained set free variables 0 atsql translation 333 putting together using transformation defined section 32 convert every safe range temporal query equivalent ranf already shown ranf preserves equivalence also shown translations individual temporal connectives correct composing two steps theorem 319 let ba safe range temporal logic formula atsql database atsql atsql translation temporal logic query 4 respect chosen granularity time paper year 34 example consider query list countries lost regained independence example 24 formulated temporal logic simplify illustration translation break formula set auxiliary rules translate first rule nonsequenced valid select a0country a0capital indepvalid a0 second rule nonsequenced valid select a1country a1capital main query translated sequenced valid a2country country aux view1valid a2 aux view2valid a3 exists indepvalid a4 note apart sequenced flag last step identical translation first order logic sql atsql handles temporal dimension snapshotreducible queries automatically translation formulas contain temporal connectives reduces translation first order logic sql 35 refinement optimization section 32 described simplest version translation used direct temporal extension translation presented ahv95 however direct extension several drawbacks address section negation pushed deep srnf phase necessary find double negations original formula eliminate however hidden double negations happens many common cases resulting formula srnf improve range restrictedness variables may unnecessarily complicated cases might better using original query cases use weaker srnf push negations chance may cancel subformulas however unique srnf need decide deep want push negations decision based heuristics pick query cheapest execution plan restricting formulas unnecessarily duplicated second problem intimately connected first one transforming original query may end formula need propagate bindings variables across numerous connectives order obtain formula ranf however propagation often unnecessarily duplicates subformulas resulting query underlined px part resulting formula redundant note general problem conversion proposed ahv95 proposals rather temporal extensionour example indeed uses pure first order logic problem addressed two ways 1 restricting depth gets pushed srnf translation often main source problem 2 eliminating superfluous restricting formulas achieved additional bottomup pass generated query ranf note additional pass trying eliminate redundant parts original query difficult eliminate unnecessary subformulas introduced ranf transformation nested temporal connectives conjunctions create unnecessary atsql query blocks translation generates separate atsql query block every temporal connective conjunction however approach may produce unnecessarily nested query blocks may merged single block consider query 31rx translation produces following code valid r however obvious could merge nested select blocks single equivalent block inner temporal operation 1 preserves coalescing thus recoalescing necessary however point need emphasize translations individual temporal connectives require input relations coalesced cf example 318 therefore merge select blocks preserve coalescing example optimization corresponds flattening conjunctions relational calculus queries theory step could performed smart query optimizer aware implementation would able perform optimization query optimizers able perform arithmetic simplifications needed process eg evaluating used example observation summarized following lemma lemma 320 translations since b b 1a 0a 3b 2b 5b 4b remain correct even atsql translation b coalesced however coalesced cases moreover b coalesced result applying temporal connective coalesced lemma together observation coalescing preserved temporal joins differences preserved unions projections allows us safely remove redundant coalescing operators translated formula mapping atsql temporal logic establishing mapping subset atsql temporal logic less important practical point view establishing mapping direction described previous section possible application decompilation atsql queries however main purpose establishing mapping atsql temporal logic identify subset former expressive power latter clarifies issue expressive power proposed restrictions atsql eg wy98 indeed subset atsql mapped back temporal logic several reasons first atsql inherits sql2s duplicate bagtheoretic semantics semantics temporal logic settheoretic second atsql like sql2 aggregate operations firstorder expressible finally atsql like twosorted firstorder logic time sort express queries referring multiple temporal contexts recently shown ahvdb96 tn96 queries expressible temporal logic therefore define subset atsql corresponding temporal logic introduce syntactic restrictions first limits atsql sql2 constructs mapped relational algebra calculus definition 41 atsql query pure 1 use aggregate functions 2 coalescing periods forced using valid sideeffect ensures duplicates generated second restriction prohibits referring multiple temporal contexts definition 42 atsql query q local every subclause q references form vtimev refer range variable v clause particular select similar requirement nontemporal attributes implies nested select clauses cannot refer validtimes range variables specified clause enclosing select example 43 following atsql query local select mapping translates pure local atsql query q temporal logic formula oe q define step step temporal builtin predicates start considering simplified form nonsequenced sql2 queries additionally assume first 1 references valid time query form vtimev v one range variables r 2 ff contain subqueries subsequently relax assumptions atsql queries obeying restrictions mapping defined following steps 1 define set special points contain time instants explicitly referenced query essentially endpoints valid periods relations clause points ordered linearly along time line consistently clause ff try linear orders one one 2 linear orderings divides time line isolated points open periods corresponding set time instants make local characteristic formula written fotl true given database 3 similarly timestamp result atsql query represented disjunction global characteristic formulas one partitions time line defined rest section develop idea formally show extended general class queries query q define set sq special points q also every range variable v q define lv literal r x r relation symbol v x vector unique logical variables length equal arity r way unique logical variable also assigned every attribute every temporal predicate ff negation also written disjunction atomic order predicates relating special points sq therefore one finitely many strict linear orderings sq consistent ff orderings special points may coincide every ordering w construct encodes every special point p 62 fgamma1 1g w determine set atomic formulas p true w modified obvious way every open period special points also determine set atomic formulas true w define local characteristic formula phi p special point p w local characteristic formula phi open period w consider pair consecutive special points w may correspond consecutive time instants eg v gamma call first pointpoint case second case also consider open period two points two cases pointperiod periodpoint set valid clause query q specifies closed period special points w period consists number special points open periods points construct global characteristic formulas psi p special point 0 psi open period 0 formulas encode ordering w position point resp period ordering formula psi encodes past p w psi r encodes future p w periods defined similarly assuming p 0 predecessor p w psi l p psi l defined follows pointpoint case predecessor p period periodpoint case p1 open period formulas psi r symmetric psi l used instead 5 instead since get formula fl w take disjunction global characteristic formulas corresponding points periods 0 finally query corresponding atsql query q obtained disjunction formulas fl w linear orders w sq consistent ff 41 lifting restrictions reverse translation extended restricted atsql queries pure local ones follows nontemporal conditions every condition 1 2 translated variable corresponding attribute 1 resp 2 condition 1 c translated similarly nested subqueries clause query q contain nested subquery q 1 subquery q 1 recursively translated using mechanism yielding formula oe q1 difference subquery refer addition range variables range variables q however q 1 cannot force relationship special points q temporal predicates q 1 cannot refer range variables q q local several ways q 1 may embedded clause q condition exists q 1 translation x vector free variables oe q1 similarly exists condition query rewritten form uses exists exists temporal constants expressions handle temporal constant c need introduce constant 0ary relation r c treat relation part every clause clearly c enough one constant relation eg zero define remaining ones using 5 4 every occurrence temporal expression validv need add points set special points query similarly validv gamma k easy see every pure local atsql query rewritten query temporal expressions either constants form validv sigma k particular occurrences firstlast eliminated splitting query assume clause pure local atsql query q conjunction temporal predicates nontemporal conditions conditions subqueries formula oe q conjunction formulas obtained translating separately conjoining result lv every range variable v query using consistent naming variables correspond relation attributes select list attributes translated existential quantifier prefix consisting variables list finally union translated disjunction except sequenced queries sequenced queries contain temporal predicates except subqueries therefore main query translated standard translation sql relational calculus temporal subqueries translated nested subqueries nonsequenced queries see theorem 44 every pure local atsql query q temporal logic formula fi q every atsql database tuple timestamped period belongs answer q iff jjdjj jjdjj abstract temporal database corresponding valuation maps free variables fi q example 45 assume relation two attributes x relation b one attribute z consider following pure local atsql query b b vtimea contains vtimeb axbz extend previous notation apply tuple variables follows x endvtimex clause query generates following partial order endpoints following points special consider linear orders special points consistent partial order example linear order local characteristic formulas corresponding order follows true global characteristic formulas corresponding order follows going left right order similar way psi r obtained disjunction psi l linear orders special points consistent partial order endpoints generated query formed subsequently conjoined nontemporal condition translation temporal logic atsql presented previous section produces pure local atsql queries thus corollary 46 temporal logic pure local atsql expressive power query languages following natural next question ask logical query language equivalent full atsql lack aggregate functions temporal logic remedied syntactic extension language along lines one proposed relational calculus klu82 requirement maximal periods fundamental fact allowing noncoalesced periods calls temporal logic point periodbased case translation full atsql temporal logic discussed paper even local queries restriction local queries also critical pure atsql expressive power twosorted firstorder logic separate sort time recently shown ahvdb96 tn96 temporal logic strictly less expressive twosorted logic thus translation atsql temporal logic works pure queries 5 related work despite extensive studies theoretical properties temporal logic logicbased temporal query languages gm91 cct94 ahvdb96 tn96 surprisingly little work implementations languages main reason disregarding logicbased approaches practical query language temporal databases perceived inefficiency mainly due pointbased semantics commonly accompanying languages indeed early approaches utilized explicit construction temporal snapshots database tc90 however ffl infinite temporal databases approach fails even databases finitary ffl finite databases space requirements exponentially worse number bits approach avoids problems preserving declarative nature temporal logic similar statement also made translationbased approaches eg tom97 tom98 translation converts saferange temporal logic formulas atsql however translation could used temporal query language target provided operated temporal databases based single distinguished temporal attribute periods corresponding query language enforced coalescing fortunately majority proposed temporal data models languages satisfy conditions therefore temporal logic serve convenient tool interoperability temporal database represented using one models single standard emerges general translation twosorted firstorder logic atsql clear practical interest considerably complicated translation temporal logic atsql given present paper tom96 translation point based twosorted firstorder logic period based temporal query language proposed approach subsequently extended sqlbased temporal query language sqltp tom97 tom98 translation could serve translation twosorted firstorder logic atsql two subtle points ffl generates nonlocal atsql queries indeed results ahvdb96 tn96 show translation twosorted firstorder logic local atsql queries views ffl general generated query may exponential size input query 5 tom97 defined syntactic criterion guarantees polynomial linear increase size subclass twosorted firstorder logic queries moreover subclass contains firstorder temporal logic reverse translation little practical use provides desperately needed insight various practical query languages temporal database compare expressive power allows us classify temporal extensions sql related languages essentially equivalent temporal logic since connectives 6 notion locality plays major role classification languages equivalent temporal logic tquel sno87 hsql sar93 temporal algebra wy98 used temporal data warehousing languages strictly stronger temporal logic atsql sjb95 sqltemporal sbjs96 using explicit coercion temporal attributes data attributes vice versa ixrm lor93 description incomplete sqltp tom97 tom98 important consequence classification first group languages implemented temporal relational algebra universe temporal relations single distinguished validtime attribute tn96 languages second group require relations multiple temporal attributes store intermediate results bottomup query evaluation moreover upper bound number temporal attributes needed even toplevel query boolean comprehensive discussion issues see ct98 6 summary established exact correspondence temporal logic syntactically defined subset atsql translation temporal logic atsql allows efficient implementation temporal logic queries within temporal database management system supporting atsql future work includes extending temporal logic translation support aggregate functions also interesting would adaptation approach dense domain would require first extending atsql domain including support halfopen open periods extending mapping introduced 5 however may happen even translation relational calculus algebra ahv95 6 precisely firstorder fragments equivalent fotl acknowledgment grateful rick snodgrass participating preparation first version paper continued guidance jan chomickis work partially supported nsf grant iri9632870 r foundations databases maintaining knowledge temporal intervals managing temporal knowledge deductive databases coalescing temporal databases historical relational data model hrdm algebra based lifespans completeness historical relational query languages temporal query languages survey efficient checking temporal integrity constraints using bounded history encoding implementing temporal integrity constraints using active dbms temporal logic information systems homogenous relational model query languages temporal databases temporal databases prelude parametric data temporal logic mathematical foundations computational aspects deriving optimized integrity monitoring triggers dynamic integrity constraints temporal logic historical databases glossary temporal database concepts equivalence relational algebra relational calculus query languages aggregate functions intervalextended relational model application validtime databases monitoring dynamic integrity constraints based temporal logic understanding new sql complete guide temporal extensions relational model sql extensions sql historical databases hsql historical query language adding valid time sqltemporal evaluating enhancing completeness tsql2 temporal query language tquel tsql2 temporal query language temporal triggers active databases adding time dimension relational model extending relational algebra temporal relational algebra basis temporal relational completeness temporal databases theory point vs intervalbased query languages temporal databases safety translation relational calculus queries maintaining temporal views nontemporal information sources data warehousing tr temporal query language tquel adding time dimension relational model extending relational algebra monitoring dynamic integrity constraints based temporal logic homogeneous relational model query languages temporal databases temporal relational algebra basis temporal relational completeness safety translation relational calculus evaluation relational algebras incorporating time dimension databases understanding new sql temporal databases completeness historical relational query languages consensus glossary temporal database concepts temporal logic vol 1 efficient checking temporal integrity constraints using bounded history encoding point vs intervalbased query languages temporal databases extended abstract deriving optimized integrity monitoring triggers dynamic integrity constraints temporal logic information systems temportal connectives versus explicit timestamps query temporal databases equivalence relational algebra relational calculus query languages aggregate functions maintaining knowledge temporal intervals temporal statement modifiers tsql2 temporal query language foundations databases extensions sql historical databases temporal triggers active databases implementing temporal integrity constraints using active dbms firstorder queries temporal databases inexpressible temporal logic maintaining temporal views nontemporal information sources data warehousing pointbased temporal extension temporal sql historical relational data model hrdm algebra based lifespans temporal query languages temporal logic myampersandamp historical databases coalescing temporal databases ctr fusheng wang carlo zaniolo xmlbased approach publishing querying history databases world wide web v8 n3 p233259 september 2005 paolo reconciling pointbased intervalbased semantics temporal relational databases treatment telicatelic distinction ieee transactions knowledge data engineering v16 n5 p540551 may 2004 fusheng wang xin zhou carlo zaniolo bridging relational database history web xml approach proceedings eighth acm international workshop web information data management november 1010 2006 arlington virginia usa michael bhlen johann gamper christian jensen algebraic framework temporal attribute characteristics annals mathematics artificial intelligence v46 n3 p349374 march 2006
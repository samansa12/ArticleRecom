comparison reliable multicast protocols analyze maximum throughput known classes reliable multicast transport protocols attain new taxonomy reliable multicast transport protocols introduced based premise mechanisms used release data source correct delivery decoupled mechanisms used pace transmission data effect error recovery receiverinitiated protocols based entirely negative acknowledgments naks sent receivers sender proposed avoid implosion acknowledgements acks source however protocols shown require infinite buffers order prevent deadlocks two solutions ackimplosion problem treebased protocols ringbased protocols first organize receivers tree send acks along tree latter send acks sender along ring receivers two classes protocols shown operate correctly finite buffers shown treebased protocols constitute scalable class reliable multicast protocols proposed date b introduction increasing popularity realtime applications supporting either group collaboration reliable dissemination multimedia information internet making provision reliable unreliable endtoend multicast services integral part architecture minimally end toend multicast service ensures packets source delivered receiver session within finite amount time free errors packets safely deleted within finite time additionally service may ensure packet delivered supported part office naval research grant n00014 9410688 defense advanced research projects agency darpa grant f1962896c0038 correspondence bn levine order sent source although reliable broadcast protocols existed quite time 3 viable approaches provision endtoend reliable multicasting internet emerging endtoend reliable multicast problem facing future internet compounded current size continuing growth makes handling acknowledgements major challenge commonly referred acknowledgement ack implosion problem two popular approaches endtoend reliable multicasting proposed date called senderinitiated receiverinitiated senderinitiated approach sender maintains state receivers send information receive acknowledgments acks senders transmission retransmission multicast receivers packet receiver obtains correctly sends unicast ack sender contrast receiverinitiated approach receiver informs sender information error missing sender multicasts packets giving priority retransmissions receiver sends negative acknowledgement nak detects error lost packet first comparative analysis ideal senderinitiated receiverinitiated reliable multicast protocols presented pingali et al 17 18 analysis showed receiverinitiated protocols far scalable senderinitiated protocols maximum throughput senderinitiated protocols dependent number receivers maximum throughput receiverinitiated protocols becomes independent number receivers probability packet loss becomes negligi ble however paper demonstrates ideal receiverinitiated protocols cannot prevent deadlocks operate finite memory ie applications using protocol services cannot retransmit data existing implementations receiverinitiated protocols inherent scaling limitations stem use messages multicast group members used set timers needed nak avoidance need multicast naks hosts session lesser extent need store messages sent session paper addresses question whether reliable multicast transport protocol reliable multicast protocol short designed enjoys scaling properties ideal receiverinitiated protocols still able operate correctly finite memory address question previous analysis pingali et al 17 18 22 extended consider maximum throughput generic ringbased protocols organize receivers ring two classes treebased protocols organize receivers ack trees classes three known approaches used solve ack implosion problem analysis shows tree ringbased protocols work correctly finite memory treebased protocols best choice terms processing memory requirements results presented paper theoretical nature apply generic protocols rather specific implementations however believe provide valuable architectural insight design future reliable multicast protocols section 2 presents new taxonomy reliable multicast protocols organizes known approaches four protocol classes discusses many key papers literature fit within taxonomy taxonomy based premise analysis mechanisms used release data memory correct reception receivers decoupled study mechanisms used pace transmission data within session detection transmission errors using taxonomy argue reliable unicast multicast protocols proposed date use naks work correctly finite memory ie without requiring application level store data sent session use acks release memory naks improve throughput section 3 addresses correctness various classes reliable multicast protocols introduced taxonomy section 4 extends analysis pingali et al 17 18 22 analyzing maximum throughput three protocol classes treebased treebased local nak avoidance periodic polling treenapp ringbased protocols section 5 provides numerical results performance protocol classes different scenarios discusses implications results light recent work reliable multicasting section 6 provides concluding remarks new taxonomy reliable multicast protocols describe four generic approaches known date reliable multicasting wellknown protocols unicast multicast purposes mapped class taxonomy differs prior work 8 17 18 22 addressing receiverinitiated strategies reliable multicasting decouple definition mechanisms needed pacing data transmission mechanisms needed allocation memory source using approach protocol thought using two windows congestion window cw advances based feedback receivers regarding pacing transmissions detection errors memory allocation window mw advances based feedback receivers whether sender erase data memory practice proto010101000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111000000000000000000111111111111111111111111111000000000000000000111111111111111111111111111000000000000000000000000111111111111111111111111000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111 ack source receiver nak fig 1 basic diagram senderinitiated protocol cols may use single window pacing memory eg tcp 10 separate windows eg netblt 4 reliable protocol assumes existence multicast routing trees provided underlying multicast routing protocols internet trees built using protocols dvmrp 6 corebased trees cbt 1 ordered corebased trees ocbt 20 protocolindependent multicast pim 7 multicast internet protocol mip 14 21 senderinitiated protocols past 17 18 senderinitiated protocols characterized placing responsibility reliable delivery sender however characterization overly restrictive reflect way several reliable multicast protocols rely positive acknowledgements receivers source designed taxonomy senderinitiated reliable multicast protocol one requires source receive acks receivers allowed release memory data associated acks receivers restricted directly contacting source clear source required know constituency receiver set scheme suffers ack implosion problem however characterization leaves unspecified mechanism used pacing transmissions detection transmission errors either source receivers charge retransmission timeouts traditional approach pacing transmission error detection eg tcp context reliable unicasting source charge retransmission timeout however suggested results reported floyd et al 8 better approach pacing multicast session receiver set timeout receiver sends acks source rate accept sends nak source receiving correct packet source amount time exceeds retransmission timeout ack refer specific packet window packets depending specific retransmission strategy simple illustration senderinitiated protocol presented fig 1 notice regardless whether senderdriven receiverdriven retransmission strategy used source still charge deallocating memory receiving acks given packet set packets source keeps packets memory every receiver node positively acknowledged receipt data senderinitiated pro tocol senderdriven retransmission strategy used sender polls receivers acks retransmitting timeout receiverdriven retransmission strategy used receivers poll source ack time 1 important note reliable multicast protocol uses naks mean receiver initiated ie naks basis source ascertain release data memory combination acks naks used extensively past reliable unicast multicast protocols exam ple netblt unicast protocol uses nak scheme retransmission small partitions data ie cw partitions called buffers acks data buffer ie mw upon receipt ack source release data mem therefore netblt really senderinitiated fact naks unnecessary netblt correctness ie buffer considered one large packet eventually must acked important mechanism improve throughput allowing source know sooner retransmit data protocol similar netblt negative acknowledgments periodic polling napp protocol 19 protocol broadcast protocol local area networks lans like netblt napp groups together large partitions data periodically acked lost packets within partition naked napp advances cw naks periodically advances mw acks use naks cause nak implosion source napp uses nak avoidance scheme net blt naks increase napps throughput necessary correct operation albeit slow use periodic polling limits napp lans source still suffer ack implosion problem even acks occur less often senderinitiated protocols like xpress transfer protocol xtp 21 created use internet still suffer ack implosion problem main limitation senderinitiated protocols acks used need source process acks know receiver set two known methods address limitation using naks instead acks b delegating retransmission responsibility members receiver set organizing receivers ring tree discuss approaches subsequently 22 receiverinitiated protocols previous work 17 18 characterizes receiverinitiated protocols placing responsibility ensuring reliable packet delivery receiver critical aspect protocols taxonomy acks used receivers send naks back source retransmission course source still needs timer ascertain connection receiver failed010011010000000000000000000000000000000000000000111111111111111111111111111111111111111111111111110000000000000000001111111111111111111111111110000000000000000001111111111111111111111111110000000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111 nak source receiver fig 2 basic diagram receiverinitiated protocol needed detected either error skip sequence numbers used timeout receivers restricted directly contacting source source receives feedback receivers packets lost delivered source unable ascertain safely release data memory explicit mechanism receiverinitiated protocol source release data memory ie advance mw even though pacing retransmission mechanisms scalable efficient ie advancing cw figure 2 simple illustration receiverinitiated protocol receivers communicate naks back source receiverinitiated protocols possibility experiencing nak implosion problem source many receivers detect transmission errors remedy problem previous work receiverinitiated protocols 8 17 18 adopts nak avoidance scheme first proposed napp senderinitiated protocol receiverinitiated nak avoidance rina protocols shown 17 18 22 better performance basic receiverinitiated protocol resulting generic rina protocol follows 17 18 sender multicasts packets state information giving priority retransmissions whenever receiver detects packet loss waits random time period multicasts nak sender receivers receiver obtains nak packet received started timer send nak receiver sets timer behaves sent nak expiration timer without reception corresponding packet signal used detect lost packet scheme hoped one nak sent back source lost transmission entire receiver set nodes farther away source might even get chance request retransmission generic protocol describe timers set accurately generic rina protocol described constitutes basis operation scalable reliable multicasting srm algorithm 8 srm embedded internet collaborative whiteboard application called wb srm sets timers based lowrate periodic session messages multicast every member group messages specify time stamp used receivers estimate delay source highest sequence number generated node source 2 average multiple sources supported srm focus singlesource case simplicity bandwidth consumed session messages kept small eg keeping frequency session messages low srms implementation requires every node stores packets application layer store relevant data note naks receivers used advance cw controlled receivers sequence number multicast session message used poll receiver set ie ensure receiver aware missing packets although session messages implement polling function 19 cannot used advance mw senderinitiated protocol sender specifies highest sequence number source highest sequence number heard source 3 practice persistence session messages forces source process number messages would needed source know receiver set time one periodic message every receiver accordingly defined basic dissemination session messages srm scale defeats one goals receiverinitiated paradigm ie keep receiver set anonymous source scaling purposes issues limit use rina protocols reliable multicasting first show next section rina protocol requires data needed retransmission rebuilt application approach reasonable applications immediate state data exclusively desired case distributed whiteboard however approach apply multimedia applications current state stream transition states second naks retransmissions must multicast entire multicast group allow suppression naks nak avoidance scheme designed limited scope lan small number internet nodes used treenapp protocols described next sec tion basic nak avoidance algorithm requires timers set based updates multicast every node number nodes increases node must increasing amount work furthermore nodes congested links lans regions may constantly bother rest multicast group multicasting naks approaches limit scope naks retransmission still evolving 8 however current proposals still rely session messages reach group members another example receiverinitiated protocol logbased receiverreliable multicast lbrm 9 uses hierarchy log servers store information indefinitely receivers recover contacting log server using log servers feasible applications afford servers leaves many issues unresolved single server used performance degrade due load server multiple servers used mechanisms must still implemented ensure servers consistent information ideal receiverinitiated protocol three main advantages senderinitiated protocols namely source know receiver set b source 3 prior description srm 11 12 incorrectly assumed session messages contained highest sequence number heard source thank steve mccanne pointing process acks receiver c receivers pace source limitation protocol mechanism source know safely release data memory furthermore argued practical implementations receiverinitiated approach fail provide advantages b following two protocol classes organize receiver set ways permit strengths receiverinitiated protocols applied local scale providing explicit mechanisms source release memory safely ie efficient management mw 23 treebased protocols treebased protocols characterized dividing receiver set groups distributing retransmission responsibility acknowledgement tree ack tree structure built set groups source root tree simple illustration treebased protocol presented fig 3 ack tree structure prevents receivers directly contacting source order maintain scalability large receiver set ack tree consists receivers source organized local groups group group leader charge retransmissions within local group source group leader charge retransmissions local group group leader source communicates another local group either child group leader closer source request retransmissions packets received correctly group leaders may children another local group minimally may contact another local group local group may one group leader handle multiple sources group leaders could also chosen dynamically eg token passing within local group hosts children bottom ack tree termed leaves obviously ack tree consisting source leader leaf nodes corresponds senderinitiated scheme acknowledgments children group including sources group sent group leader children group send acknowledgements group leader soon receive correct packets advancing cw refer acknowledgements local acks local naks ie retransmissions triggered local acks local naks unicast group leaders children similar senderinitiated schemes use local naks unnecessary correct operation protocol treebased protocols also delegate leaders subtrees decision delete packets memory ie advance mw conditional upon receipt aggregate acks children group aggregate acks start leaves ack tree propagate toward source one local group time group leader cannot send aggregate ack children sent aggregate ack using aggregate acks necessary ensure protocol operates correctly even group leaders fail ack tree partitioned long periods group leaf source fig 3 basic diagram treebased protocol time 12 aggregate acks used ie group leader waits children send local acks advancing mw correct operation group leaders fail guaranteed allowing nodes delete packets approach used treebased protocols 13 16 24 lorax 12 lorax protocol 12 first treebased protocol build single shared ack tree use multiple sources single ses sion use aggregate acks ensure correct operation hosts ack tree fail use local acks local naks requesting retransmissions important throughput source scheduled retransmissions based aggregate acks would paced based slowest path ack tree instead retransmissions scheduled independently local group treebased protocols eliminate ackimplosion prob source know receiver set operate solely messages exchanged local groups group leader children ack tree furthermore aggregate acks used treebased protocol work correctly finite memory even presence receiver failures network partitions simplify analysis description protocol assume group leaders control retransmission timeouts however timeouts controlled children source group leaders accordingly source sends packet sets timer group leader sets timer becomes aware new packet timeout local acks received packet assumed lost retransmitted source group leader children first application treebased protocols reliable multicasting internet reported paul et al 15 compared three basic schemes reliable pointto multipoint multicasting using hierarchical structures results fully developed reliable multicast transport protocol rmtp 13 16 generic protocol sends local ack every packet sent source rmtp sends local acks periodically conserve bandwidth reduce processing group leader increasing attainable throughput define treenapp protocol treebased protocol uses nak avoidance periodic polling 19 local groups naks alone sufficient guarantee reliability finite memory receivers send periodic positive local ack parents advance cw note messages sent setting timers needed nak000000111111001111001110000000000001111111111111111 receiver set source nak ack fig 4 basic diagram ringbased protocol avoidance limited local group scalable treebased multicast transport protocol tmtp 24 example treenapp protocol 24 ringbased protocols ringbased protocols reliable multicast originally developed provide support applications require atomic total ordering transmissions receivers one first proposals reliable multicasting token ring protocol trp 3 aim combine throughput advantages naks reliability acks reliable multicast protocol rmp 23 discussed updated wan version trp although multiple rings used naming hierarchy class protocol used actual rings therefore rmp throughput bounds trp base description generic ringbased protocols lan protocol trp wan protocol rmp simple illustration ringbased protocol presented fig 4 basic premise one token site responsible acking packets back source source times retransmits packets receive ack token site within timeout period ack also serves timestamp packets receiver nodes global ordering packets delivery application layer protocol allow receivers deliver packets token site multicast ack receivers send naks token site selective repeat lost packets originally multicast source ack sent back source also serves token passing mechanism transmissions source available piggyback token separate unicast message sent since interested maximum throughput consider latter case pa per token passed next member ring receivers new site correctly received packets former site received token passed site may clear packets memory accordingly final deletion packets collective memory receiver set decided token site conditional passing token source deletes packets acktoken received note trp rmp specify retransmissions sent unicast token site analysis focuses maximum attainable throughput protocol classes assume token passed exactly per message 3 protocol correctness protocol considered correct shown safe live 2 given minimum definition reliable service assumed reliable multicast protocol live deadlock occur receiver source protocol safe data sent source must delivered higher layer within finite time address correctness protocol classes assume nodes never fail duration reliable multicast session multicast session established correctly permanent therefore analysis correctness focuses ability protocol classes sustain packet losses errors assume exists nonzero probability packet received errorfree senders receivers finite memory proof correctness ringbased protocols given chang maxemchuk 3 proof senderinitiated unicast protocols safe live available many sources eg bertsekas gallager 2 proof change significantly senderinitiated class reliable multicast protocols omitted brevity liveness property receiver violated node store counter sequence number next packet delivered higher layer safety property proof also essentially source waits acks members receiver set sliding cw mw forward theorems 1 2 demonstrate generic treebased reliable multicast protocol trmp short correct receiverinitiated reliable multicast protocols live theorem 1 trmp safe live proof let r set nodes belong reliable multicast session including source receivers set organized bary tree height h proof proceeds induction h case reduces nonhierarchical senderinitiated scheme b receivers practicing given retransmission strategy source therefore proof follows correctness proof unicast retransmission protocols presented bertsekas gallager 2 h 1 assume theorem holds must prove theorem holds liveness must prove member tree height live consider subset tree starts source includes nodes tree height 1 leaves subtree also group leaders larger tree ie group leaders nodes bottom larger tree inductive hypothesis liveness property true subtree must show trmp live second subset nodes consisting leaves larger tree group leader parents group second subset follows protocol suffices prove arbitrary group live arbitrary group second subset tree constitutes case senderinitiated reliable multicast difference original transmission sent source external group group leader since leaves contact group leader must prove relationship live inductive hypothesis guarantees group leader parent live assume source transmits packet time c 1 received correctly delivered leaves arbitrary group time c 2 let c 3 time group leader deletes packet advances mw protocol live enter deadlock finite rest proof follows proof bertsekas gallager 2 unicast protocols group leader takes place source therefore trmp live safety safety trmp follows directly proof liveness shows arbitrary packet delivered receiver within finite time qed theorem 2 receiverinitiated reliable protocol live proof proof example focusing sender arbitrary member receiver set r r 1 sender node x enough memory store packets packet takes 1 unit time reach receiver node naks take finite amount time reach sender let p denote th packet beginning zero p 0 sent start time 0 lost network sends next 1 packets successfully sends nak stating p 0 received nak either lost reaches sender time sender decides send packet pm store packets received naks p 0 time must clear assuming received correctly receives nak p 0 time deadlocked unable retransmit p 0 qed indicates ideal receiverinitiated protocol requires infinite memory work correctly prac tice requirement implies source must keep memory every packet sends lifetime session theorem 1 assumes node failures network traffic occur however node failures happen practice changes operational requirements practical treebased protocols treebased protocols shown deleting packets memory node receives local acks children live aggregate acks necessary ensure correct operation treebased protocols presence failures lorax 12 treebased protocol uses aggregate acks operate finite memory presence node failures network partitions 4 maximum throughput analysis 41 assumptions analyze maximum throughput generic reliable multicast protocols introduced sect 2 achieve use model pingali et al 17 18 focuses processing requirements generic reliable multicast protocols rather communication bandwidth requirements accordingly maximum throughput generic protocol function perpacket processing rate sender receivers analysis focuses obtaining processing times per packet given node assume single sender x multicasting r identical receivers probability packet loss p node figure 5 summarizes notation used sec tion clarity assume single ack tree rooted single source analysis treebased protocols selective repeat retransmission strategy assumed protocol classes since well known retransmission strategy highest throughput 2 requirement keeping buffers receivers nonissue given small cost memory assumptions specific protocol listed sect 2 interest modeling maximum throughput make two additional assumptions 1 acknowledgements ever lost 2 loss events node multicast packet mutually independent multicast routing protocols cbt ocbt pim mip dvmrp 1 5 7 14 20 organize routers trees means correlation packet loss receiver first assumption benefits classes especially favors protocols multicast acknowledge ments fact assumption essential rina proto cols order analyze maximum attainable put nak avoidance effective receivers guaranteed receive first nak multicast receiver set number nodes involved nak avoidance increases task successful delivery nak receivers becomes less probable rina treenapp protocols favored assumption rina protocols much probability delivering naks successfully receivers exaggerated second assumption equivalent scenario correlation among packet losses receivers location receivers underlying multicast routing tree source protocols take advantage relative position receivers multicast routing tree transmission acks naks retransmissions would possibly attain higher throughput predicted model however class given relative advantage assumption table 1 summarizes bounds maximum throughput known classes reliable multicast protocols results clearly show treenapp protocols constitute scalable alternative 42 sender receiverinitiated protocols following notation introduced pingali et al 17 18 place superscript variable related senderinitiated protocol n1 n2 variables related receiverinitiated rina protocols respec tively maximum throughput protocols constant stream packets r receivers 17 18 1 table 1 analytical bounds protocol processor requirements p con stant senderinitiated 17 receiver initiated nak avoidance 17 ringbased uni cast retrans treebased ob1 p treenapp 3 even probability packet loss goes zero throughput senderinitiated protocol inversely dependent r size receiver set ack must sent every receiver source transmission correctly received contrast p goes zero throughput receiverinitiated protocols becomes independent number receivers notice however throughput receiverinitiated protocol inversely dependent r number receivers ln r probability error negligible note result assumes perfect setting timers used rina protocol without cost single nak reaches source interested maximum attainable throughput protocols 43 treebased protocols denote class protocols simply h1 use superscript variables related protocol class following derive bound expected cost type node consider overall system throughput make use symmetry assume without loss generality enough receivers form full tree level without loss generality assume local group ack tree consists b children group leader allows us make use symmetry throughput calculations also assume local acks advance mw rather aggregate acks assumption receiver fails system assume perfect setting timers without cost single nak reaches source interested maximum attainable throughput protocols 431 source node consider first x h1 processing costs required source successfully multicast arbitrarily chosen packet branching factor tree group size r size receiver set time feed new packet higher protocol layer xp time process transmission packet xa times process transmission ack nak local ack respectively time process timeout sender receiver node respectively yp time process newly received packet time deliver correctly received packet higher layer ya yn h times process transmit ack nak local ack respectively probability loss receiver losses different receivers assumed independent events r number local acks sent receiver r per packet using treebased protocol r number acks sent receiver r per packet using unicast protocol total number local acks received receivers per packet mr number transmissions necessary receiver r successfully receive packet number transmissions receivers receive packet correctly protocols n1 n2 number transmissions receivers receive packet correctly protocols h1 h2 processing time per packet sender receiver respectively protocol w n1 n2 h1 h2 r processing time per packet group leader treebased tree napp protocols respectively per packet tokensite ringbased protocols w x throughput protocol w n1 n2 h1 h2 r x one source receiver leaf r group leader h tokensite subscript denotes overall system throughput x times process reception transmission respectively periodic local ack fig 5 notation receivers using h1 protocol processing requirement arbitrary packet expressed sum costs receiving acks x f time get packet higher layer time taken attempt successful transmission packet x time process timeout interrupt transmission attempt x h time process local ack h1 number transmissions source make packet using h1 protocol l h1 number local acks received using h1 protocol taking expectations derived far extremely similar eqs 1 2 analysis pingali et al 17 18 fact use analysis understanding b size receiver subset source collects local acks therefore expected number local acks received sender substituting eq 6 eq 5 rewrite expected cost source node pingali et al 17 18 shown expected number transmissions per packet n1 n2 equals 8 h1 number receivers r b expected number transmissions per packet h1 protocol simplified 17 18 19 pingali et al 17 18 provide bound em apply em h1 using eq 11 bound eq 7 follows follows p constant ex h1 ob 432 leaf nodes let h1 denote requirement nodes forward packets leaves notice leaf nodes h1 protocol process fewer retransmissions thus send fewer acknowledgements receivers protocol use analysis similar one pingali et al 17 18 receivers using senderinitiated protocol receiving transmissions sending local acks p time takes process retransmission h time takes send local ack f time deliver packet higher layer l h1 number local acks generated node h ie number transmissions correctly received since receiver sent transmissions probability p packet lost obtain taking expectations eq 13 substituting eq 14 noting bound em h1 given eq 11 p treated constant ey h1 433 group leaders evaluate processing requirement group leader h note node caught source node children two jobs receive retransmit packets convenient group leader sender receiver express costs terms x sum costs receiving transmissions sending local acks collecting local acks case source node l h1 expected number local acks received node hs children packet l h1 h number local acks generated node h substitute eqs 6 14 eq obtain first two terms equivalent processing requirements leaf node last two almost cost source node substituting subtracting difference yields words cost group leader source leaf without cost receiving data higher layers one less transmission original one substituting eqs 12 16 eq 20 p constant eh h1 dominant term throughput analysis overall system 434 overall system analysis let throughput sender h1 1ex h1 group leaders h1 1eh h1 leaf nodes h1 r 1ey h1 throughput overall system r 22 eqs 12 16 21 follows p constant p 0 obtain therefore maximum throughput protocol well throughput nonnegligible packet loss independent number receivers class reliable multicast protocols exhibits degree scalability respect number receivers 44 treebased protocols local nak avoidance periodic polling bound overall system throughput generic tree napp protocol repeat method used treebased class first derive bound expected cost source group leaders leaves case treebased protocols assume enough receivers form full tree level place superscript h2 variables relating generic treenapp protocol 441 source node consider first x h2 processing costs required source successfully multicast arbitrarily chosen packet receivers using h2 protocol processing requirement arbitrary packet expressed sum costs receiving local naks receiving periodic local acks x f time get packet higher layer time retransmission attempt x n time receiving local nak receiver set amortized time process periodic local ack associated current congestion window h2 number transmission attempts source make packet taking expectations using eq 11 bound em h1 bound eq 28 follows follows p constant ex h2 442 leaf nodes let h2 denote processing requirement nodes forward packets leaves sum cost expressed receiving transmissions sending periodic local acks sending local naks receiving local naks let p time takes process retransmission r number transmissions required packet received receiver r n j time takes send local nak j x n j time takes receiver local nak j another receiver k time set timer k f time deliver packet higher layer amortized cost sending periodic local ack group packets packet member taking expectations eq 30 follows distribution r 17 18 32 therefore noting eq 32 probm r derive eq 31 expected cost using bound em h1 given eq 11 bound eq 33 34 p treated constant ey h2 443 group leaders sum costs group leaders job sender receiver receiving transmissions sending periodic local acks receiving periodic local acks receiving local naks sending local naks retransmissions children taking expectations substituting eq 32 obtain similar group leaders h1 protocol processing cost group leader source leaf without cost receiving data higher layer one less transmission substituting eq 28 eq 33 eq 36 subtracting difference expected cost expressed therefore eq 36 bounded 38 p constant eh h2 o1 therefore nodes treenapp protocol constant amount work regard number receivers 444 overall system analysis overall system throughput h2 protocol minimum throughput attainable type node tree r 39 eqs 29 34 38 follows accordingly either p constant p 0 obtain eq 40 o1 41 therefore maximum throughput treenapp pro tocol well throughput nonnegligible packet loss independent number receivers 45 ringbased protocols section analyze throughput ringbased pro tocols denote superscript r using assumptions sects 43 44 interested maximum attainable throughput assuming constant stream packets means ignore overhead occurs acks piggyback tokenpassing messages 451 source source nodes practice special form unicast roaming token site sum costs incurred processing acks r x mr r number transmissions required packet received token site mean r number acks receiver r case token site sent unicast ie number packets correctly received r number always 1 accordingly taking expectations eq 42 obtain r assume constant costs operations shown p constant o1 regard size receiver set 452 token site current token site following costs note trp rmp specify retransmissions sent unicast r 1 receivers multicasting acktoken processing naks unicasting retransmissions r r 1probm r 1 mr l r number naks received token site using ring protocol derive l r consider r number transmissions necessary receiver r successfully receive packet r expected value 11p last transmission naked r 1 receivers sending naks token site obtain r 1p therefore mean processing time token site r r 1p expected cost token site bounded r 1p regard number receivers p constant 453 receivers receivers practice receiverinitiated protocol current token site assume one packet ack token time stamp multicast token site per data packet cost associated arbitrary packet therefore receiving first transmission sending naks receiving retransmissions r mr mr first term equation cost receiving acktokentime stamp packet token site second cost receiving first transmission sent sender assuming received error free third cost delivering errorfree transmission higher layer fourth cost receiving retransmissions token site assuming first failed last two terms consider nak sent first transmission attempt fails interrupt occurs nak sent taking expectations obtain shown previously 17 18 52 substituting eqs 43 52 32 eq 51 assuming operations constant costs shown regard size receiver set consider p constant ey r 454 overall system analysis overall system throughput r generic token ring protocol equal minimum attainable throughput parts r 55 eqs 45 49 54 follows p constant p 0 obtain r 1p 5 numerical results compare relative performance various classes protocols mean processing times set equal 1 except periodic costs x set 01 figure 6 compares relative throughputs protocols n1 n2 h1 h2 r defined sect 2 graph represents inverse eqs 19 36 48 spectively throughputs treebased tree napp ringbased protocols well inverse throughput equations derived previously 17 18 sender receiverinitiated protocols top middle bottom graphs correspond increasing probabilities packet loss 10 25 respectively exact values em h1 calculated using finite version eq 9 exact values em similarly calculated 22 performance nak avoidance protocols especially treenapp protocols clearly superior however assumptions place two subclasses advantage base classes first assume acknowledgements lost received error effectiveness nak avoidance dependent probability naks reaching receivers thus without assumption effectiveness nak avoidance decreases number receivers involved increases accordingly treenapp protocols advantage limited branching factor ack tree rina protocols advantage increases size entire receiver set second assume timers used nak avoidance set perfectly reality messages used set timers would subject endtoend delays exhibit regularity become arbitrarily large 1000 2000 3000 4000 5000 6000 7000 8000 9000 1000002throughput h2 1000 2000 3000 4000 5000 6000 7000 8000 9000 1000002number ofreceivers fig 6 throughput graph exact equations protocol probability packet loss respectively branching factor trees set 10 conjecture relative performance nak avoidance would actually lie closer respective base classes depending effectiveness nak avoidance scheme words curves shown upper bounds nak avoidance performance results show considering base classes since one advantage another treebased class performs better classes considering subclasses use nak avoidance treenapp protocols perform better rina protocols even though model provides unfair advantage rina protocols hierarchical structure organization receiver set treebased protocols guarantees scalability improves performance protocols using nak avoidance small scale increases performance even addition nak avoidance failed treenapp protocol eg due incorrect setting timers performance would still independent size receiver set rina protocols property failure nak avoidance rina protocols would result unscalable performance like receiverinitiated protocol degrades quickly increasing packet loss increase processor speed smaller branching factor would also increase throughput treebased pro tocols however number receivers smaller branching factor implies retransmissions must traverse larger number treehops towards receivers expecting tree example packet lost immediately source retransmission multicast children nodes tree must wait retransmission trickles tree struc ture poses latency problem addressed taking advantage dependencies underlying multicast routing tree retransmissions could multicast toward receivers attached routers subtree router attached receiver requested missing data number treehops receiver source also factor quickly source release data memory presence node failures discussed levine et al 12 supportable receivers h2 n2 r fig 7 number supportable receivers protocol probability packet loss respectively branching factor trees set 10 figure 7 shows number supportable receivers different classes relative processor speed requirements number obtained normalizing classes baseline processor described pingali et al 17 18 baseline uses protocol support exactly one speed processor support r receivers protocol set 1 baseline cost equal 17 18 1 58 using eqs 18 36 48 58 derive following treebased treenapp ringbased protocols respectively r 1p 61 number supportable receivers derived sender receiverinitiated protocols shown 17 18 2em 64 fig 6 7 clear treebased protocols support number receivers processor speed bound node treenapp protocols attain highest maximum throughput also important note maximum throughput rina protocols attain becomes insensitive size receiver set probability error decreases assumed single nak reaches source naks never lost session messages incur processing load implicitly assume optimum behavior rina protocols simulation results reported srm floyd et al 8 agree model result assuming nak losses single packet loss ex periments figure 7 shows treenapp protocols made perform better best possible rina protocol limiting size local groups unicast nature retransmissions ringbased protocols protocols approach senderinitiated protocols indicates allowing multicast retransmissions would improve performance greatly 6 conclusions compared analyzed four known classes reliable multicast protocols course model constitutes crude approximation actual behavior reliable multicast protocols internet ack nak simply another packet probability ack nak lost received error much error probability data packet assumption gives protocols use nak avoidance advantage classes therefore reasonable compare separately results show treebased protocols without nak avoidance perform better classes use nak avoidance treenapp protocols perform better rina protocols even though rina protocols artificial advantage every class conjecture effects ack nak failure correlation failures along underlying multicast routing trees accounted relative performance protocols observed results summarized table 1 already known senderinitiated protocols scalable source must account every receiver listening receiverinitiated protocols far scalable unless nak avoidance schemes used avoid overloading source retransmission requests however unboundedmemory requirement protocol class used efficiently applicationlayer support limited set applications furthermore set timers needed nak avoidance existing instantiations rina protocols require group members transmit session messages periodically makes unscalable ringbased protocols designed atomic total ordering packets trp rmp limit throughput requiring retransmissions unicast would possible reduce cost bound oln r assuming p constant nak avoidance techniques presented ramakrishnan jain 19 used analysis shows ack trees good answer scalability problem reliable multicasting practical implementations treebased protocols maintain anonymity receiver set treebased treenapp classes throughputs constant respect number receivers even probability packet loss negligible would preclude accurate setting nak avoidance timers treebased protocols delegate responsibility retransmission receivers employ techniques applicable either sender receiverinitiated protocols within local groups ie node children tree ack tree mechanism used receivers session receiverinitiated protocol adopted treebased protocol added benefit throughput number supportable receivers completely independent size receiver set regardless likelihood packets acks naks received correctly hand scope naks retransmissions reduced without establishing structure receiver set 8 limiting scope session messages needed set nak avoidance timers contain scope naks retransmissions require aggregation messages leads organizing receivers local groups must aggregate sessions messages sent source local groups efficiently ever leads hierarchical structure local groups much like treebased protocols require hence appears organizing receivers hierarchically ack trees oth erwise necessity scaling reliable multicast protocol r core based trees cbt architecture scalable interdomain multicast routing data networks reliable broadcast protocols netblt highthroughput transport protocol multicast routing datagram internetwork multicast routing datagram internetworks extended lans architecture widearea multicast routing reliable multicast framework lightweight sessions application level framing transmission control protocol rmtp reliable multicast transport protocol multicast transport protocols highspeed networks reliable multicast transport protocol rmtp protocol realtime scheduling issues multimedia applications comparison senderinitiated receiverinitiated reliable multicast protocols negative acknowledgement periodic polling protocol multicast lan xtp xpress transfer protocol reliable dissemination protocol interactive collaborative applications received b current research interest analysis design algorithms protocols computer communication tr data networks netblt high throughput transport protocol multicast routing datagram internetworks extended lans xtp xpress transfer protocol multicast routing datagram internetwork core based trees cbt comparison senderinitiated receiverinitiated reliable multicast protocols architecture widearea multicast routing reliable dissemination protocol interactive collaborative applications logbased receiverreliable multicast distributed interactive simulation reliable multicast framework lightweight sessions application level framing protocol realtime scheduling issues multimedia applications case reliable concurrent multicasting using shared ack trees reliable broadcast protocols high performance totally ordered multicast protocol ordered core based tree protocol comparison known classes reliable multicast protocols ctr v ramakrishna max robinson kevin eustice peter reiher active selfoptimizing multiplayer gaming architecture cluster computing v9 n2 p201215 april 2006 christian maihfer bandwidth analysis reliable multicast transport protocols proceedings ngc 2000 networked group communication p1526 november 0810 2000 palo alto california united states shuju wu sujata banerjee xiaobing hou comparison multicast feedback control mechanisms proceedings 38th annual symposium simulation p8087 april 0406 2005 shuju wu sujata banerjee xiaobing hou performance evaluation comparison multicast feedback control mechanisms simulation v82 n5 p345362 may 2006 brian neil levine sanjoy paul j j garcialunaaceves organizing multicast receivers deterministically packetloss correlation proceedings sixth acm international conference multimedia p201210 september 1316 1998 bristol united kingdom maurice herlihy srikanta tirthapura roger wattenhofer ordered multicast distributed swap acm sigops operating systems review v35 n1 p8596 january 1 2001 athina p markopoulou fouad tobagi hierarchical reliable multicast performance analysis placement proxies proceedings ngc 2000 networked group communication p2735 november 0810 2000 palo alto california united states ryan g lane scott daniels xin yuan empirical study reliable multicast protocols ethernetconnected networks performance evaluation v64 n3 p210228 march 2007 suman banerjee seungjoon lee ryan braud bobby bhattacharjee aravind srinivasan scalable resilient media streaming proceedings 14th international workshop network operating systems support digital audio video june 1618 2004 cork ireland suman banerjee seungjoon lee bobby bhattacharjee aravind srinivasan resilient multicast using overlays acm sigmetrics performance evaluation review v31 n1 june philip k mckinley ravi rao robin f wright hrmc hybrid reliable multicast protocol linux kernel proceedings 1999 acmieee conference supercomputing cdrom p8es november 1419 1999 portland oregon united states brian neil levine sanjoy paul j j garcialunaaceves organizing multicast receivers deterministically packetloss correlation multimedia systems v9 n1 p314 july suman banerjee seungjoon lee bobby bhattacharjee aravind srinivasan resilient multicast using overlays ieeeacm transactions networking ton v14 n2 p237248 april 2006 carlos oliveira panos pardalos survey combinatorial optimization problems multicast routing computers operations research v32 n8 p19531981 august 2005
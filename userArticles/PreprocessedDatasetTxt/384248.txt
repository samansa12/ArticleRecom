finding right cutting planes tsp given instance traveling salesman problem tsp reasonable way get lower bound optimal answer solve linear programming relaxation integer programming formulation problem linear programs typically exponential number constraints theory solved efficiently ellipsoid method long algorithm take solution either declare feasible find violated constraint practice often case many constraints violated raises question choose among improve performance simplest tsp formulation possible efficiently find violated constraints gives us good chance try answer question empirically looking random two dimensional euclidean instances large instances tsplib ran experiments evaluate several strategies picking among violated constraints found information constraints prefer resulted modest gains unable get large improvements performance b introduction given set locations distance function traveling salesman problem tsp find shortest tour ie simple cycle locations problem long history see eg 11 famous example nphard problem accordingly also long history heuristics finding good tours techniques finding lower bounds length shortest tour paper focus one wellknown technique finding lower bounds basic idea formulate tsp integer linear program ip solve linear programming lp relaxation simplest formulation following ip pair fi jg cities objective minimize work done author att labsresearch constraints interpretation program x ij tell us whether go directly location location j first constraints say must either go go second say must enter leave city exactly third guarantee get one large cycle instead several little disjoint ones third constraints called subtour elimination constraints main concern work relax ip lp standard way replacing first constraints 1 observe solution ip solution lp optimum find smaller original opti mum thus get lower bound known heldkarp bound5 6 experimental analysis shown bound pretty good random two dimensional euclidean instances asymptotically bound 07 different optimal tour length realworld instances tsplib 12 gap usually less 2 7 distances obey triangle inequality bound least 23 length optimal tour 13 15 possible give complicated ips whose relaxations smaller gaps attempt work reasons explain reviewed method detail observe trivial plug linear program lp solver exponentially many subtour elimination constraints neverthe less even theory still hope efficiency ellipsoid method 4 requires efficient separation algorithm algorithm takes solution either decides feasible gives violated constraint subtour elimination constraints construct complete graph set locations vertices x ij edge weights suffices determine whether minimum cut graph way separate vertices two groups total weight edges crossing groups minimized less two minimum cut gives us violated constraint take smaller two groups constraint feasible many algorithms finding minimum cuts known ranging algorithms follow early work maximum flows 1950s 3 recent monte carlo randomized algorithm runs om log 3 n time graph edges n vertices 9 even better possible find nearminimum cuts long graph connected thus find violated subtour elimination constraints leads us ask obvious question violated constraints want use one constraint violated reporting certain violated constraints others may lead shorter overall running time primary goal work explore question several algorithms finding nearminimum cuts include flowbased algorithm due vazirani yannakakis 14 contractionbased algorithm due karger stein 10 treepackingbased algorithm due karger 9 chose use kargerstein algorithm primarily implementation available far needed try others believe time find cuts small enough compared time spent lp solver would change results significantly point justify use simplest ip decision made partly grounds simplicity historical precedent better reason simplest ip use kargerstein minimum cut algorithm find violated constraints one construct complicated ips give better bounds adding constraints simple ip useful constraints separation algorithms none sets extra constraints people tried known efficiently find violated constraints would difficult determine constraints would like use may still possible determine constraints use complicated ip leave subject research note constraints complicated ips include constraints simple ip answering question simple ip reasonable first step towards answering question complicated ips found valuable consider sets small disjoint constraints relatedly seems better fix violations small areas graph first strategy reduces number lps solve total running time note interesting got improvement using kargerstein algorithm context finding one minimum cut experimental studies found algorithms perform significantly better 2 8 results demonstration kargerstein algorithm useful practice rest paper organized follows sect 2 give important details implementations started sect 3 discuss constraint selection strategies tried results obtained fi nally sect 4 summarize findings give possibilities future work starting implementation section give details implementations started discuss attempts improving sect 3 reference note use n denote number citiesnodes refer total edge weight crossing cut value cut 21 main loop starting point work tsp code concorde written applegate bixby chvatal cook 1 code corresponds state art lower bound computations tsp course wants use far subtour elimination constraints mode restrict simple ip refer way concorde works mean way works restricted mode changed structure code little mainly replacing algorithm finds violated constraints code differs significantly theoretical description review works first concorde use ellipsoid method solve lp instead uses simplex method poor worstcase time bounds typically works much better practice simplex used follows 1 start lp constraints 1 2 2 run simplex method current lp 3 find violated subtour elimination constraints add lp none terminate 4 repeat 2 observe initial lp describes fractional 2matching problem concorde gets initial solution running fractional 2matching code rather using lp solver second important pay attention cuts added lp reoptimizing overhead associated run lp solver would inefficient add one cut time side since many constraints actually constrain optimal solution would foolish overwhelm lp solver many constraints one time notice also constraint playing active role lp may desirable remove lp solver deal future thus concorde uses following general process adding constraints lp assuming found somehow placed list 1 go list picking constraints still violated 250 found end list reached 2 add constraints lp reoptimize 3 newly added constraints keep ones basis thus 250 constraints added time constraint stays lp plays active role optimum added constraint kept assumed sufficiently relevant allowed thrown away many iterations case simplicity never allowed kept cut leave solving simple ip takes enough iterations change shouldnt large impact third undesirable work constraints also undesirable practice work variables 0 optimal solution similar process selecting variables work solving lp variables later checking see variables might needed ie might nonzero optimal solution initial sparse graph comes greedy tour plus 4 nearest neighbors respect reduced costs fractional 2matching finally necessary find minimum cuts find violated constraints graph disconnected connected component defines violated constraint fact set connected components defines violated con straint giving number violated constraints exponential number components concorde considers constraints defined one compo nent choice makes sense connected component forced join another one make good progress least halving number components another heuristic concorde uses consider cuts defined segment pretty good tour ie connected piece tour concorde uses heuristics find pretty good tour beginning authors noticed cuts found often corresponded segments inverted observation heuristic mention heuristic used original im plementation compare use modified code finally full pseudocode description starting version concorde find initial solution fractional 2matching code build initial sparse graph greedy tour nearest fractional matching reduced costs add connected component cuts add segment cuts connected add flow cuts else add connected component cuts cuts added fifth pass loop check 50 nearest neighbor edges see need added cuts added edges added check edges see need added edges added note lines marked make changes adding cuts lines includes calling lp solver 22 kargerstein minimum cut algorithm starting implementation kargerstein minimum cut algorithm ks code written chekuri goldberg karger levine stein 2 make large modifications code already differs significantly theoretical description algorithm original algorithm easy state graph less 7 nodes solve brute force repeat twice repeat n nodes remain randomly pick edge probability proportional edge weight contract endpoints run recursively contracted graph contracting two vertices means merging combining resulting parallel edges adding weights easy see contraction create cuts destroy cut unless nodes opposite sides contracted idea algorithm likely destroy minimum cut definition relatively edges crossing particular random contractions n nodes give least 50 chance preserving minimum cut thus repeat contraction procedure twice reasonable chance minimum cut preserved one recursive calls moderate omega 1 log n chance minimum cut preserved one base cases repeating entire procedure olog n times success probability improved 1 gamma 1n course interested minimum cuts want cuts value less 2 find fewer contractions time leaving n nodes modification makes cuts nearminimum cut value 2 hopefully also good chance found ks montecarlo algorithm easy way sure given right answer want affect correctness concorde whenever implementation ks found cuts value less two always doublechecked concordes original flowbased cut finding algorithm later refer implementations use ks find cuts really mean always use ks unless ks fails find cuts typically time ks failed find cuts either done close reasonable ignore fact flow algorithm always still important thing notice ks two parameters play one many contractions time governs depth success probability recursion many times run whole procedure order achieve specific success probability choose one willing away theoretical analysis make heuristic algorithm choose since correctness check place making ks heuristic reasonable thing particular started first parameter set would find cuts value less two probabilityomega 1 log n second parameter set three found three iterations sufficient typically find good fraction approximately two thirds cuts performance seemed good enough purposes later gathered information cuts worried reducing time spent ks set first parameter would find cuts value less one probabilityomega 1 log n note regardless setting first parameter code always report cuts value less two finds later version code disregard higher value cuts result changing parameter merely lower chance finding implemented version chooses edges contraction one pass rather one time modification allow contractions certain good circumstances cause trouble possible get unlucky recursion depth get large see 2 thorough discussion implemented version change made repeat contraction step nothing gets contracted change obvious one make likely throws analysis bit since make algorithm heuristic anyway chose worry exactly little change note disable many padbergrinaldi heuristics used starting implementation work looking minimum cuts nearminimum cuts also make modifications could run disconnected graphs graph disconnected exponentially many minimum cuts cannot hope report first worked around problem disconnected graphs forcing graph connected starting implementation concorde however later study wanted try running ks earlier something disconnected graphs new workaround find connected components report cuts run ks component modification ignores many cuts connected component added cut form another cut value chose approach 1 something 2 aspects experiments describe shortly suggest approach appropriate one last modification made contract paths edges weight one beginning point heuristic edge path weight one small cut every edge small cut would find many cuts similar experiments suggested useful find violated constraints different used heuristic avoid finding similar cuts 3 experiments results 31 experimental setup experiments run sgi multiprocessor running irix 62 processors code parallelized ran one processor hopefully machine 6 gb main memory 1 mb l2 cache code compiled sgi cc 72 o2 optimization option set produce 64 bit executables cplex 50 used lp solver several processes run danger contention memory bus slowed codes nothing easy could reason believe big problem case codes run similar conditions comparisons fair used two types instances one random two dimensional euclidean instances generated picking points randomly square running times report later averages 3 random seeds second type instance realworld tsplib tested rl11849 usa13509 brd14051 pla33810 pla85900 32 observations modifications started study taking concorde disabling segment cuts substituting ks flow algorithm first time algorithms behavior changed graph connected ks first called point gathered statistics random 10000 node instance cuts found cuts kept figure 1 shows two histograms comparing cuts found cuts kept first histogram size cuts found kept number nodes smaller side second shows similar histogram value cuts found kept note scaling yaxis histograms unusual histograms show several interesting features first almost kept cuts smallfewer 100 nodes found cuts also biased towards small cuts much example many cuts size approximately 2000 found none kept second interesting feature minimum cut unique value approximately 3 smallest kept cut value approximately 6 kept cuts value one observation immediately suggests worthwhile consider minimum cuts number cuts want anyway furthermore appears something special cuts value one large fraction kept try get better idea going took look fractional solution figure 2 shows fractional 2matching solution 200 node instance cut finding procedures first applied surprisingly picture many small cycles structure appears several times path funny edge weights end allow satisfy constraints presence structures suggests looking biconnected components graph induced nonzero weight edges long path sense good tour looks locally like path important two ends meet say graph must connected biconnected cut size2575number cuts100030005000 cut size first connected random 10000 city instance cut number cuts20006000 cut value first connected random 10000 city instance fig 1 histograms showing properties cuts found compared cuts kept gray bars represent found cuts black bars represent cuts note unusual scaling yaxes fig 2 picture fractional 2matching initial solution 200 node instance edge weights indicated shading white 0 black 1 tried various ways incorporating biconnected components finding method worked well two issues one try find biconnected components wait graph connected check biconnectivity connected components second issue cuts report given long path violated constraint corresponding every edge path stated generally violated constraint corresponding every articulation point node whose removal would disconnect graph first attempt look biconnected components graph connected report violated constraints approach reduced number iterations main loop took time overall running biconnected components earlier reduced number iterations also took long reduce number cuts found modified biconnected components code report constraints corresponding biconnected components one zero articulation points note biconnected component 0 articulation points also connected component idea behind modification idea used report constraints based connected components context said made sense consider constraints corresponding individual components thus picking small disjoint constraints likewise taking biconnected components one zero articulation points picks small disjoint constraints use biconnected components proved valuable reduced number iterations outer loop reduced overall running time accordingly version give data results section experience ks similar using find violated constraints turned many even though saved iterations total running time far worse seemed faster run ks right beginning waiting graph become connected generalized idea report smallest disjoint cuts report cut smaller number nodes cut shares nodes easy see rules given selecting cuts connected biconnected components special cases rule eventual implementation ks uses right beginning always reports smallest cuts note handling disconnected graphs consistent finding smallest cuts notice also reporting smallest cuts means introduce constraint force connected component join connected components component satisfies subtour elimination constraints choice may seem foolish introducing constraint could easily find often happens connect component another process fixing violations inside component would useless introduce connectivity constraint vein discovered could actually harmful force graph connected running ks would surprising time spent getting graph connected merely wasted actually saw instances cut problem arose graph connected much harder anything ks would deal run beginning result finding connected components first actually cost factor two running time note implementation selecting smallest cuts integrated ks could ks output cuts looked pick small ones ks easily keep track sizes contracts nodes possible never consider many cuts save time also one observation failed exploit noticed value histogram shows preference keeping cuts small denominator value kept cuts value one several value 32 43 53 etc unfortunately come way exploit observation tried sorting cuts denominator adding lp hoping would get cuts wanted first able quickly discard others unable get consistent improvement way even improvement clear whether entirely due fact cuts value one got added first 33 results present data form plots three types one reports total time another reports number lps solved third considers time add cuts described counts time process lists cuts reoptimize time find cuts total time includes everything time add cuts time find time add edges time get initial solution etc also two classes plots two classes inputs random instances instances times reported relative square number cities function seems approximate asymptotic behavior implementations precisely yaxes plots report times always 1000000 time secondsn 2 scale allows us see algorithms compare large small problem sizes note also xaxes tsplib plots categorical scale table 1 summarizes implementations appear plots short name description starting point original concorde implementation wo segments original segment cuts disabled biconnect using smallest biconnected components instead connected ks cut finding done ks ks1 cut finding done ks probabilities set cuts value table 1 summary implementations report data several things notice plots first looking time add cuts random instances fig 3 see using either biconnected components ks consistently improves time little bit furthermore using version ks looser probabilities causes little damage unfortunately gain looks like may disappearing move larger instances looking number lps solve shows clearer version results fig 4 looking total time fig 5 see difference made adjusting probabilities ks stricter version ks distinctly worse original concorde whereas looser version ks like version biconnected components bit better looking total time looks even like gains disappearing larger sizes story similar tsplib instances figs 687 biconnected components continue give consistent improvement ks gives improvement instances pla instances number cities07111519 running time squared random instances add cuts running time starting point wo segments biconnect ks ks1 fig 3 strategy looking smallest cuts seems reasonable idea reduces number iterations improves running time bit gain big also makes intuitive sense giving number cities50150number lps solved random instances lps solved starting point wo segments biconnect ks ks1 fig 4 number cities1525running time squared random instances total running time instance0515running time squared instances add cuts running time starting point wo segments biconnect ks ks1 fig 6 number lps solved instances lps solved instance051525running time squared instances total running time starting point wo segments biconnect ks ks1 fig 8 lp solver smallest region graph constraint violated encourage solver really fix violation rather move violation around worth noting right cuts definitely simply ones easiest find mentioned possible slow implementation significantly trying use easytofind cuts first also interesting possible make improvement ks flow based code experimental studies indicate finding one minimum cut generally much better use flowbased algorithm hao orlin study suggests different result kss ability find nearminimum cuts fact make practical situations extra cuts might useful future work seem like would particularly helpful work harder finding subtour elimination constraints tsp however studies constraints find complicated ips tsp could useful might interesting investigate ks contexts minimum cuts used acknowledgements many thanks david johnson several helpful discussions suggestions including suggestion work first place many thanks david applegate help concorde numerous helpful discussions suggestions r solution traveling salesman problems experimental study minimum cut algorithms geometric algorithms combinatorial optimization travelingsalesman problem minimum spanning trees travelingsalesman problem minimum spanning trees part ii asymptotic experimental analysis heldkarp traveling salesman bound practical performance efficient minimum cut algorithms minimum cuts nearlinear time new approach minimum cut problem rinooy kan analyzing heldkarp tsp bound monotonicity property applications suboptimal cuts enumeration heuristic analysis tr analyzing heldkarp tsp bound monotonicity property application minimum cuts nearlinear time asymptotic experimental analysis heldkarp traveling salesman bound suboptimal cuts
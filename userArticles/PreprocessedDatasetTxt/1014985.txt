inference termination conditions numerical loops prolog present new approach termination analysis numerical computations logic programs traditional approaches fail analyse due non wellfoundedness integers present technique allows overcoming difficulties approach based transforming program way allows integrating extending techniques originally developed analysis numerical computations framework querymapping pairs wellknown framework acceptability integration contributes understanding termination behaviour numerical computations also allows us perform correct analysis computations automatically extending previous work constraintbased approach termination finally discuss possible extensions technique including incorporating general term orderings b introduction numerical computations form essential part almost realworld program clearly order termination analyser practical use contain mechanism inferring termination compu tations however topic attracted less attention research com munity work concentrate automatic termination inference logic programs depending numerical computations dershowitz et al 8 showed termination general numerical computations instance floating point numbers may counterintuitive ie observed behaviour necessarily coincide theoretically expected one thus restrict integer computations discussing termination integer computations following question asked conditions queries sumed queries terminate refer question termination inference problem example 1 px x 7 x1 x1 px1 program terminates queries px integer values x thus answer termination inference problem condition true 2 example also hints traditional approaches termination analysis fail prove termination example approaches mostly based notion level mapping function set possible atoms natural numbers decrease traversing rules case level mapping depend x x negative well two approaches solving problem possible first one change definition level mapping map atoms integers ever integers general wellfounded prove termination one supported goa generation logic programming language prove mapping wellfounded subset integers example gamma1 7 forms subset ordering x x respect usual ordering integers second approach present paper require changing definition level mapping indeed level mapping required exists maps px 7 0 otherwise level mapping decreases traversing rule ie size px greater size px1 6 gamma x thus proving termination present transformation allows us define level mappings automatic way incorporating techniques 8 level mapping inference wellknown framework acceptability respect set 5 6 integration provides better understanding termination behaviour integer computations also possibility perform analysis automatically decorte et al 7 rest paper organised follows making preliminary remarks present section 3 transformationfirst means example formally section 4 discuss practical issues present algorithm implementing termination section 5 discuss extensions proving termination programs depending numerical computations well ones review related work conclude preliminaries follow standard notation terms atoms query finite sequence atoms given atom rela denotes predicate occuring atom p denotes set atoms constructed language underlying p extended base p quotient set atom p modulo variant relation sldtree constructed using lefttoright selection rule prolog called ldtree goal g ldterminates program p ldtree p g finite definition 1 1 let p program p q predicates occuring say p refers q p clause p uses p head q body p depends q p write p w q p q transitive reflexive closure relation refers p q mutually recursive write p q p w q q w p recall basic notions related termination analysis level mapping function j set naturals study termination programs respect sets queries following notion one basic notions framework definition 2 6 let p definite program set atomic queries call set callp set atoms variant selected atom derivation p f qg q 2 lefttoright selection rule following definition 14 generalises notion acceptability respect set 5 6 extending mutual recursion definition 3 let set atomic queries p definite program p acceptable respect exists level mapping j delta j 2 callp 0 p cas oe b holds j j de schreye et al 5 characterise ldtermination terms acceptability theorem 1 cf 5 let p program p acceptable respect set p ldterminating queries also need introduce notion interargument relations definition 4 7 let p definite program pn predicate p interargument relation pn r p n n r p valid interargument relation pn respect norm k delta k every characterise program transformations bossi cocco 3 introduced following notion program p query q mp foe j successful ldderivation q p cas oeg f j infinite ldderivation q pg section introduce methodology using simple example subsequent sections formalise discuss different extensions following example generates oscillating sequence stops generated value greater 1000 smaller gamma1000 example 2 interested proving termination set queries z integerg respect following program direct attempt define level mapping px x fails since x positive well negative thus complex level mapping defined start observations first clause applicable 1000 second one gamma1 thus termination px x gamma1000 1 x 1000 trivial moreover infinite sequence obtained applying first clause first step recursive call px1 holds gamma1000 second clause applied first step infinite sequence recursive call px1 holds use observation replace predicate p two new predicates p 1x1000 p gamma1000xgamma1 p 1x1000 called px called holds p gamma1000xgamma1 called px called gamma1000 holds following program obtained define two different level mappings one atoms p 1x1000 another one atoms p gamma1000xgamma1 let j p 1x1000 n verify acceptability transformed program respect fp 1x1000 n gamma1g implies termination transformed program respect queries thus termination original program respect due lack space discuss queries form p 1x1000 n 1000 clause head unified query first clause atom predicate mutually recursive p 1x1000 p hold 1 ie 1000 true n 1 2 intuitive presentation hints major issues discussed following sections cases extracted program program transformed 31 basic notions section formally introduce notions analysis based recall aim analysis find given predicate query sufficient condition termination query respect program thus need define notion termination condition start number auxiliary definitions 1 clause applicable 1 definition 5 let p predicate arity n 1 called argument position denominators predicate clear context superscripts omitted definition 6 let p program set queries argument position predicate p called integer argument position every integer argument position denominators corresponding integer argument positions called integer argument position denominators integer inequality atom one following forms exp1 constructed integers variables four operations arithmetics symbolic inequality arguments predicate p constructed similarly integer inequality however instead variables integer argument positions denominators used example 3 integer inequalities given predicate p arity 3 integer argument positions symbolic inequalities arguments p 2 disjunctions conjunctions based integer inequalities called integer conditions similarly propositional calculus formulae based inequalities arguments predicate called conditions integer arguments predicate definition 7 let pt atom let c p symbolic condition arguments p instance condition respect atom c p pt obtained replacing argument positions denominators corresponding arguments ie p example 4 let px 5 atom let c p 1 p ready define termination condition formally definition 8 let p program q atomic query symbolic condition c relq termination condition q given c relq q holds q leftterminates respect p termination condition example 2 true ie px terminates every integer x well see always case discuss inferring values integer arguments take traversal rules ie case analysis performed example 2 provides already underlying intuitioncalls predicate p c identical calls predicate p c holds arguments formally define notion set adornments later specify guardtuned show guardtuned set adornments constructed definition 9 let p predicate set symbolic conditions integer arguments p called set adornments example 5 example 2 continued following examples sets adornments 32 program transformation next question answered program transformed given set adornments transformation behave respect transformed program exactly calls satisfy condition c define transformation formally introduce following definition rule called prefix rule integer inequality variables arguments variables h called maximal prefix rule prefix prefix since prefix constrains variables appearing head clause exists symbolic condition arguments predicate head prefix instance respect head general symbolic condition necessarily unique following notion guarantees uniqueness symbolic conditions case say symbolic condition corresponds prefix definition 10 8 rule h called partially normalised integer argument positions h occupied distinct variables 2 also say program p partially normalised rules p partially normalised integer argument positions identified program easily rewritten partially normalised form ready present transformation formally 2 rule integer arguments apt et al 2 call homogeneous definition 11 let p program let p predicate let q set possible adornments p program p called adorned respect p obtained two steps following 1 every rule r p every subgoal qt body r every 2 q replace qt 2 every rule r adornments inequalities body r consistent notreject rule r defines q q p get adornments head r 2 q consistent comparisons maximal prefix r adornments body r example 6 example 2 continued sets adornments presented example 5 used first set adornments obtain p second set adornments used program p 2 obtained correctness transformation proved finiteness number clauses number subgoals clause number elements adornment ensure transformation terminates next need prove transformation preserves termination adorning clauses introduces new predicates means query q gives rise number different queries clearly termination queries respect p equivalent termination q respect p augmented set clauses every p relq every 2 p clause px call extended program p ag lemma 1 let p program let q query let p ag program obtained described mp ag q mp q proof proofs refer 13 xi second direction containment depends consistency check strategy applied point marked definition p example 7 let q px let p following program predicates p q mutually recursive thus adorned let p f1 0 1 0g q f1 0 1 0g following program obtained first step adorning process second step adorning process infers adornments heads clauses possibly rejecting inconsistent ones inference technique tries use information body constraints adornments body subgoals program fq 10 x obtained clauses rejected inconsistency query px terminates respect extended program terminate respect original one thus inference technique actually improve termination order termination preserved weaker inference engine used example considering inequalities maximal prefix following obtained p 10 x 0 q 10 x query px terminate respect extended program expected following lemma shows weaker inference used termination preserved 2 lemma 2 let p program let q query let p ag program obtained described mp q mp ag q case maximal prefixes following summarises results theorem 2 let p program let q query let set adornments let p ag program obtained described respect mp ag q theorem two important corollaries corollary 1 let p program let q query let set adornments let fa j 2 q relq w q recursive p g a2a termination condition p example 8 example 6 continued p 2 p 1gamma1000gamma11111000 depend recursive predicates corollary 1 gamma1000 termination condition px 2 theorem 2 implies program p ldterminating respect queries set atomic queries p ag constructed acceptable respect latter equivalent acceptability p respect fq g corollary 2 let p program set atomic queries q set adornments let p obtained respect p ldterminating respect queries p acceptable respect fq g corollary allows us complete termination proof example 2 example 9 show p 2 acceptable respect set xg defined j p 1000x gamma1000 prove completely p 2 acceptable respect analyse one call p 111000 x two clauses 1 2 heads unified 2 recursive condition holds vacuously 1 recursive acceptability requires descent clear otherwise descent level mapping calls proved similarly 2 4 practical issues previous section shown transformation allows reasoning termination numerical computations section discuss number practical issues considered automation 41 guardtuned sets adornments example 5 seen two different sets adornments valid according definition 9 however fgamma1000 1000g sense preferable f1 100 1 100g first declarative reading sets constructed express conditions allow traversing rule second observe p 1 two mutually recursive predicates p 2 also selfloop one predicates distinguish better worse sets adornments define guardtuned sets adornments definition 12 let p partially normalised program let p predicate p set adornments p called guardtuned every every rule r 2 p symbolic condition c corresponding maximal prefix either c holds example 10 first set adornments presented example 5 guardtuned second one guardtuned 2 examples suggest two ways constructing guardtuned set adornments given program p one might collect symbolic conditions corresponding maximal prefixes rules defining predicate p denote set c p add completion constructed disjunction unfortunately set necessarily set adornments necessary guardtuned example 11 rx two sets symbolic conditions constructed fr set adornments fr 15 r 15 g guardtuned 2 use different approach first find c g define p set conjunctions c negations claim constructed set always guardtuned set adornments example 12 c 10g simplifying removing inconsistencies lemma 3 let p program p predicate p p constructed described p guardtuned set adornments 42 define level mapping problem defining level mappings reflect changes possibly negative arguments remain nonnegative time also like remain framework level mappings atoms defined linear combinations sizes arguments definition 13 let adorned predicate expressions ae 2 f g primitive level mapping defined one conjunct appears adornment level mapping defined linear combination primitive level mappings corresponding conjuncts conjunct disjunction ignored since disjunctions introduced rule cannot applied definition 14 let p c adorned predicate natural level mapping cs natural number coefficients example 13 level mappings used example 9 natural level mappings c 1 p 1gamma1000gamma11111000 definition holds trivially 2 approach 7 defines symbolic counterparts level mappings infers values coefficients solving system constraints 43 inferring termination constraints section combine steps studied far algorithm infers termination conditions termination condition constructed disjunction two c 1 nonrecursive cases according corollary 1 c 2 recursive cases incrementally refined adding conjunction constraints integer variables obtained acceptability condition 7 3 algorithm presented figure 1 example 14 qx look values x qx terminates first algorithm infers adornments case f1 2 1 2g inferred adorned version program clause defining q 12 corollary 1 1 2 termination condition one denoted c 1 termination condition q 12 denoted c 2 initialised 1 2 level mapping otherwise acceptability decrease implies see 3 technique proving termination able provide constraint implies termination used instead 7 let p partially normalised program let q query let q relq 1 p q construct ap 2 adorn p respect q pq ap 3 let fa j 2 aq p q w recursive p g a2a let a2aq a62a 4 remove irrelevant clauses aq consistent c2 adornments q every rule r p q 6w relheadr remove r p 5 define symbolic counterparts norms level mappings interargument relations 6 construct constraints symbolic variables obtain 7 solve solution doesnt produce extra constraints variables report termination c1 c2 b solution produces extra constraints involving new integer variables conjunct constraints termination condition c2 go back step 2 c otherwise report termination c1 fig 1 termination inference algorithm c 12 hold update c 2 1 2 2 0 restart whole process respect 0 following adorned program obtained second third clauses removed since irrel evant respect 2 0 level mapping redefined ae ae acceptability decreases imply c 12 inequality holds since assumed hold solution impose additional constraints integer variables thus analysis terminates reporting order prove correctness algorithm prove termination partial correctness termination follows termination steps finiteness number integer variables restricting number backwards steps 7b 2 partial correctness follows correctness transformations 7 5 extensions section discuss possible extensions algorithm presented first reconsider inference adornments discuss integrating termination analysis numerical symbolic computations 51 inference adornments set adornments p inferred subsection 41 may sometimes weak inferring precise termination conditions example 15 px maximal prefix rule 0g termination condition found 1 0 precise termination condition 1 problem occured due fact p restricts subset integer argument positions termination proof information integer arguments outside subset may needed definition 15 let p program let p predicate p let c q set symbolic conditions integer argument positions q integer argument positions p called extension c exists r 2 p defining p integer argument position denominator appearing c appear c p c implied c q 2 c q recursive subgoals interargument relations nonrecursive ones let c set symbolic conditions integer argument positions p let c c fc j c extension cg define set adornments p fc 0 c 0 lambda fixpoint powers c p defined subsection 41 example 16 example 15 continued extension c p gamma1g thus c p alternative approach propagating information suggested 8 allows one propagate existing adornments infer new ones thus less precise approach 52 integrating numerical symbolic computation realworld programs numerical computations sometimes interleaved symbolic ones illustrated following example 11 example 17 prove termination fcollecttree variable g three decreases shown call collect call process call process call collect two calls process first two shown symbolic level mapping third oneonly numerical approach 2 thus goal combine existing symbolic approaches numerical one presented far one possible ways combine two level mappings j mapping atom p pair natural numbers j establishing decreases orderings pairs 14 example 18 example 17 continued collectt l0 termsize norm decreases satisfied respect defined n n usual order naturals 2 integrated approach allows one analyse correctly examples ground unify numbervars 15 example 612 8 6 conclusion termination numerical computations studied number authors 1 2 8 apt et al 2 provided declarative semantics called thetasemantics prolog programs firstorder builtin predicates including arithmetic operations framework property strong termination ie finiteness ldtrees possible goals completely characterised based appropriately tuned notion acceptabil ity approach provides important theoretical results seems difficult integrate automatic tools 1 claimed unchanged acceptability condition applied programs pure prolog arithmetic defining level mappings ground atoms arithmetic relation zero approach ignores actual computation thus applicability restricted programs using arithmetic really relaying quick sort moreover example 14 illustrates many programs terminate queries alternatively dershowitz et al 8 extended querymapping pairs formalism 9 deal numerical computations however approach inherited disadvantages 9 high computational price research done termination analysis constraint logic programs 4 10 12 since numerical computations prolog written way allows system verify satisfiability see numerical computations prolog ideal constraint system thus results obtained ideal constraints systems ap plied unfortunately research either oriented towards theoretical characterisations 12 restricted domains isomorphic n 10 contrast approach 8 restricted verifying termination presented methodology inferring termination con ditions clear whether 8 extended infer conditions main contribution work theoretical understanding termination numerical computations situating wellknown framework acceptability allowing integration existing approaches termination symbolic computations methodology presented integrated automatic termination analysers 7 kernel technique powerful enough analyse correctly examples gcd mod 8 examples appearing chapter 8 15 dedicated arithmetic examples include examples appearing 1 moreover approach gains power underlying framework 7 thus allows one prove termination examples cannot analysed correctly 8 similar confused delete 7 extended technique presented section 5 allows one analyse correctly examples ackermanns function ground unify numbervars 15 example 612 8 future work consider complete implementation al gorithm due use constraint solving techniques expect powerful highly efficient r logic programming prolog declarative approach firstorder builtins prolog preserving universal temination unfoldfold termination constraint logic programs framework analyzing termination definite logic programs respect call patterns termination analysis practical properties norm level mapping space general framework automatic termination analysis logic programs automatic termination analysis logic programs inferring leftterminating classes queries constraint logic pro grams verification validation logic programs inference termination conditions numerical loops art prolog tr ctr alexander serebrenik danny schreye termination floatingpoint computations journal automated reasoning v34 n2 p141177 december 2005
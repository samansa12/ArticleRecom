role commutativity constraint propagation algorithms constraing propagation algorithms form important part constraint programming systems provide simple yet general framework allows us explain several constraint propagation algorithms systematic way framework proceed two steps first introduce generic iteration algorithm partial orderings prove correctness abstract setting instantiate algorithm specific partial orderings functions obtain specific constraint propagation algorithms particular using notions commutativity semicommutativity show ac3 pc2 dac dpc algorithms achieving directional arc consistency directional path consistency instances single generic algorithm work reported extends simplifies apt 1999a b introduction constraint programming nutshell consists formulating solving socalled constraint satisfaction problems one important techniques developed area constraint propagation aims reducing search space maintaining equivalence constraint propagation widely used concept instance altavista httpwwwaltavistacomon november 19 1999 query constraint prop agation yielded 2344 hits addition literature several names used constraint propagation algorithms consistency local consistency consistency enforcing waltz filtering narrowing algorithms total number hits may well larger 4413 number hits query npcompleteness last twenty years several constraint propagation algorithms proposed many built existing constraint programming systems algorithms usually aim reaching form local consistency notion loose sense approximates notion global consistency apt 1 introduced simple framework allowed us explain many algorithms uniform way framework notion chaotic iterations fair iterations functions cartesian products specific partial orderings played crucial role monfroy rety 14 framework modified study distributed chaotic iterations resulted general framework distributed constraint propagation algorithms stated apt 1 attempts finding general principles behind constraint propagation algorithms repeatedly reoccur literature constraint satisfaction problems spanning last twenty years devoted three pages survey work two references perhaps closest work benhamou 3 telerman ushakov 17 developments led identification number mathematical properties relevance considered functions namely monotonicity inflationarity idempotence see eg saraswat rinard panangaden 16 benhamou older 4 show also notions commutativity socalled semi commutativity important apt 1 explain constraint propagation algorithms proceed two steps first introduce generic iteration algorithm partial orderings prove correctness abstract setting instantiate algorithm specific partial orderings functions partial orderings related considered variable domains assumed constraints functions ones characterize considered notions local consistency terms fixpoints presentation allows us clarify properties considered functions responsible specific properties corresponding algorithms resulting analysis simpler apt 1 concentrate constraint propagation algorithms always terminate allows us dispense notion fairness hand prove stronger results taking account commutativity semicommutativity information article organized follows first section 2 drawing approach monfroy rety 14 introduce generic algorithm case partial ordering analyzed next section 3 refine case partial ordering cartesian product component partial orderings section 4 explain introduced notions related constraint satisfaction problems last two sections essentially follow apt 1 started generic iteration algorithms arbitrary partial orders built framework discuss role commutativity next four sections instantiate algorithm section 2 refinements obtain specific constraint propagation algorithms particular section 5 derive algorithms arc consistency hyperarc consistency algorithms improved taking account information commutativity done section 6 yields wellknown ac3 algorithm next section 7 derive algorithm path consistency section 8 improve using information commutativity yields pc2 algorithm section 9 clarify assumptions generic algorithm section 2 simplified simple loop statement instantiate simplified algorithm derive section 10 dac algorithm directional arc consistency section 11 dpc algorithm directional path consistency finally section 12 briefly discuss possible future work deal classical algorithms establish directional arc consistency directional path consistency twenty respectively ten years old however several modern constraint propagation algorithms also explained framework particular apt 1 page 203 derived generic algorithm simple algorithm achieves notion relational consistency dechter van beek 8 turn mimicking development sections 10 11 use framework section 9 derive adaptive consistency algorithm dechter pearl 7 dechter 6 showed algorithm formulated general framework bucket elimination turn used explain wellknown algorithms directional resolution fouriermotzkin elimination gaussian elimina tion also various algorithms deal belief networks algorithms presentation completely general consequently delay discussion constraint satisfaction problems till section 4 follows shall rely following concepts definition 1 consider partial ordering v least element finite set functions f ff iteration f mean infinite sequence values defined inductively j element 1k say increasing sequence 0 v 1 v elements eventually stabilizes j 0 follows shall consider iterations functions satisfy specific properties definition 2 consider partial ordering v function f f called inflationary x v fx x f called monotonic x v implies fx v fy x 2 following simple observation clarifies role monotonicity subsequent result clarify role inflationarity consider partial ordering v least element finite set monotonic functions f suppose iteration f eventually stabilizes common fixpoint functions f least common fixed point functions f proof consider common fixpoint e functions f prove v e let iteration question j 0 suffices prove induction v e claim obviously holds holds 0 monotonicity f j induction hypothesis get f j since e fixpoint f j 2 fix partial ordering v least element set functions interested computing least common fixpoint functions f end study following algorithm inspired similar algorithm monfroy rety 14 generic iteration algorithm gi g g 6 choose g g g gd od g g set functions updateg g f ff b implies updateg c implies g 2 updateg intuitively assumption states updateg g least contains functions f gamma g fixpoint gd loop iteration functions added set g turn assumption b states functions added g case value change note even though assignment g holds assumption provide information g added back g information provided assumption c whole idea keep g least functions f current value fixpoint obvious example update function satisfies assumptions b updateg however choice update function computationally expensive function f f gamma g would compute values fgd fd practice interested approximations update function shall deal matter next section prove correctness algorithm following sense theorem 1 gi every terminating execution gi algorithm computes common fixpoint functions f ii suppose functions f monotonic every terminating execution gi algorithm computes least common fixpoint functions f iii suppose functions f inflationary v finite every execution gi algorithm terminates proof consider predicate defined 8f note established assignment g f moreover easy check virtue assumptions b c preserved loop iteration thus invariant loop algorithm fact assumptions b c chosen becomes invariant hence upon termination holds ii direct consequence stabilization lemma 1 iii consider lexicographic ordering strict partial orderings defined elements theta n use inverse ordering defined given finite set g denote cardg number elements assumption functions f inflationary virtue assumption b loop iteration modified algorithm pair card g strictly decreases ordering lex assumption v finite wellfounded consequently theta n lex implies termination 2 particular obtain following conclusion corollary 1 gi suppose v finite partial ordering least element let f finite set monotonic inflationary functions every execution gi algorithm terminates computes least common fixpoint functions f 2 practice interested update function easy compute also generates small sets functions therefore show function update made smaller additional information functions f available yield specialized versions gi algorithm first need following simple concepts definition 3 consider two functions f g set say f g commute call f idempotent following result holds theorem 2 update updateg g satisfies assumptions b c function updateg idempotent otherwise ii suppose g set functions commg f element commg commutes g updateg g satisfies assumptions b c function updateg proof suffices establish case assumption c let ff introducing gi algorithm noted already g 62 assumption implies updateg assumption c suffices note ggd 6 gd implies g idem potent ie ii consider f 2 suppose f 2 commg contradiction f 62 commg consequently assumption implies updateg assumption c suffices use fact g 62 commg 2 conclude given instance gi algorithm employs specific update function obtain instances using update functions modified note modifications independent therefore applied together particular function idempotent function comm satisfies assumptions ii following holds updateg g satisfies assumptions function updateg 3 compound domains applications study iterations carried partial ordering cartesian product partial orderings assume partial ordering v cartesian product partial orderings least element assume function f depends affects certain components precise introduce simple notation terminology definition 4 consider sequence partial orderings scheme n mean growing sequence different elements 1n given scheme n denote v cartesian product partial orderings given function f say f scheme say f depends element given ntuple scheme n denote ds tuple l particular j 2 1n dj jth element 2 consider function f scheme extend function f follows take 2 set scheme obtained removing elements call f canonic extension f domain scheme f informally summarize saying f change components depend meant stating considered function affects certain components say two functions f scheme g scheme commute functions f instead defining iterations case functions schemes rather reduce situation one studied previous section consider equivalently iterations canonic extensions functions common domain however specific form considered functions use simple definition update function precisely following observation note 1 update suppose function f form f following function update satisfies assumptions b c updateg depends di 6 g scheme proof deal assumption take function f g f e coincides components scheme f suppose additionally f e ie differs component scheme f words f depends di 6 g di scheme g consequently proof assumption b immediate finally deal assumption c suffices note implies turn implies together gi algorithm yields following algorithm introduced variable 0 hold value g used f 0 ff functions schemes instead canonic extensions generic iteration algorithm compound domains cd g 6 choose g suppose g scheme g g depends di 6 0 ig od following corollary gi theorem 1 update note 1 summarizes correctness algorithm corresponds theorem 11 apt 1 iteration algorithms introduced immediately compound domains corollary 2 cd suppose v finite partial ordering cartesian product n partial orderings least element f finite set functions form f suppose functions f monotonic inflationary every execution cd algorithm terminates computes least common fixpoint functions f 2 subsequent presentation shall deal following two modifications cd algorithm cdi algorithm version cd algorithm functions idempotent function update defined update theorem 2i used algorithm version cd algorithm functions idempotent combined effect functions update defined update theorem 2 used function comm algorithms counterparts cd corollary 2 hold 4 partial orderings constraint satisfaction problems far completely general discussion recall aim derive various constraint propagation algorithms able apply results previous section need relate various abstract notions used constraint satisfaction problems perhaps right place recall definition fix notation consider finite sequence variables x x respective domains associated variable x ranges domain constraint c x mean subset 1 constraint satisfaction problem short csp mean finite sequence variables x respective domains together finite set c constraints subsequence x write hc consider element dn subsequence x denote dy sequence 1 solution mean element 2 1 theta dn constraint c 2 c sequence variables call csp consistent solution two csps p 1 p 2 sequence variables called equivalent set solutions definition extends obvious way case two csps sets variables let us return framework previous section involved partial orderings least elements correspond partial orderings csps original csp least element partial ordering determined local consistency notion wish achieve ii monotonic inflationary functions schemes correspond functions transform variable domains constraints function associated one constraints iii common fixpoints correspond csps satisfy considered notion local consistency let us specific items ii deal local consistency notions considered paper shall introduce two specific partial orderings csps considered csps defined sequences variables begin fixing set collection fd subsets includes f function given set yields set subsets belongs dealing notion hyperarc consistency fd simply set pd subsets specific domains specific subsets cho sen example deal constraint propagation linear constraints integer interval domains need choose fd set subintervals original interval dealing path consistency constraint c collection fc also set pc subsets c however general choices may needed example deal cutting planes method need limit attention sets integer solutions finite sets linear inequalities integer coefficients see apt 1 pages 193194 next given two csps oe hc n write oe v iff constraints c 0 restrictions constraints c domains n next given two csps oe hc follows call v domain reduction ordering v c constraint reduction ordering deal arc consistency hyperarc consistency directional arc consistency notions shall use domain reduction ordering deal path consistency directional path consistency notions shall use constraint reduction ordering consider ordering fixed initial csp p least element words domain reduction ordering form constraint reduction ordering form ii domain reduction ordering constraint reduction ordering directly amenable analysis given section 3 therefore shall rather use equivalent partial orderings defined compound domains end note hc equivalence means domain reduction ordering fp cartesian product partial orderings additionally csp domain reduction ordering uniquely determined domains initial p indeed definition ordering constraints csp restrictions constraints p domains csp similarly allows us identify constraint reduction ordering cartesian product partial orderings also csp constraint reduction ordering uniquely determined constraints initial p follows instead domain reduction ordering constraint reduction ordering shall use corresponding cartesian products partial orderings compound orderings sequences domains respectively con straints ordered componentwise reversed subset ordering component ordering fd set least element reason use compound orderings employ functions schemes used section 3 function f defined subcartesian product constituent partial orderings canonic extension f introduced section 3 defined whole cartesian product suppose dealing domain reduction ordering least initial csp p sequence domains uniquely determine csp ordering 0 fortiori f viewed function csps elements domain reduction ordering words f viewed function csps considerations apply constraint reduction ordering shall use observations arguing equivalence original final csps various constraint propagation algorithms considered functions schemes used presence componentwise ordering following observation useful consider function f cartesian product f inflationary wrt componentwise ordering x also f monotonic wrt componentwise ordering x 2 1m following holds words f monotonic wrt iff monotonic wrt reversal set inclusion course hold inflationarity notion 5 hyperarc consistency algorithm begin considering notion hyperarc consistency mohr masini 13 use terminology marriott stuckey 11 known notion arc consistency mackworth 10 obtained restricting ones attention binary constraints let us recall definition definition 5 consider constraint c variables x respective domains c 1 theta delta delta delta theta dn call c hyperarc consistent every exists 2 c di call csp hyperarc consistent constraints hyperarc consistent 2 intuitively constraint c hyperarc consistent every involved domain element participates solution c employ cdi algorithm section 3 make specific choices involving items ii iii previous section partial orderings least elements already mentioned previous section function f choose powerset function p domain put fd pd given csp p sequence domains take domain reduction ordering p least element already noted identify ordering cartesian product partial orderings pd 1n elements compound ordering thus sequences x respective subsets domains reversed subset ordering ii monotonic inflationary functions schemes given constraint c variables respective domains abbreviate j 2 1k set fdj j 2 cg pi j c thus pi j c consists jth coordinates elements c consequently pi j c subset domain e j variable j introduce 2 1k following function cg function associated specific constraint c note x 0 function boils projection ith component iii common fixpoints use clarified following lemma also lists relevant properties functions see apt 1 pages 197 202 common fixpoint functions associated constraints c ii projection function associated constraint c inflationary wrt componentwise ordering monotonic wrt componentwise ordering taking account binary constraints obtain analogous characterization arc consistency functions 1 2 defined directly follows cg cg fix csp p instantiating cdi algorithm associated constraint pg equal get hyperarc algorithm enjoys following properties theorem 3 hyperarc algorithm consider csp p hc finite hyperarc algorithm always terminates let p 0 csp determined p sequence domains 0 n computed v least csp hyperarc consistent equivalent p 2 due definition v ordering item rephrased follows consider hyperarc consistent csps form hc constraints c 0 restrictions constraints c domains 0 n among csps p 0 largest domains proof termination immediate consequences counterpart cd corollary 2 cdi algorithm hyperarc consistency lemma 2 prove ii note final csp p 0 obtained means repeated applications projection functions starting initial csp p conforming discussion end section 4 view function function csps noted apt 1 pages 197 201 functions transforms csp equivalent one 2 6 improvement ac3 algorithm section show exploit information commutativity functions recall section 3 modified notion commutativity case functions schemes need following lemma lemma 3 commutativity consider csp two constraints c variables variables z 1k functions j constraint c commute ii variables z j identical functions c j e commute proof suffices notice ktuple x subsets domains respective variables assumed j ii let considered csp form hc assume common variable identical variable x h let solc e denote set 2 1 dn ds 2 c scheme c scheme e finally let f denote function c g j function e easy check ntuple x subsets respectively worthwhile note pairs j functions commute example 1 first consider case two binary constraints variables consider two variables x corresponding domains x fa bg fc dg two constraints x c 1 fa c b dg c 2 fa dg next consider 1 function c 1 2 function c 2 applying functions one order namely 2 1 x yields x unchanged whereas applying order 1 2 yields x equal fbg ii next show commutativity also violated due sharing single variable example take variables x z corresponding domains x fa bg fbg z fc dg constraint c 1 fa bg x b dg x z consider function c 1 function c 2 applying functions one order namely x z yields z equal fcg whereas applying order fix csp derive modification hyperarc algorithm instantiating time cdc algorithm use set functions f 0 associated constraint pg equal additionally employ following function comm associated constraint c associated constraint cg associated constraint e ith variable c jth variable e coincideg virtue commutativity lemma 3 set commg satisfies assumptions update theorem 2ii limiting oneself set functions 1 2 associated binary constraints obtain analogous modification corresponding arc consistency algorithm using counterpart cd corollary 2 cdc algorithm conclude algorithm enjoys properties hyperarc algorithm counterpart hyperarc algorithm theorem 3 holds let us clarify difference algorithm hyperarc algorithm limited binary constraints assume considered csp form hc dei reformulate algorithm follows given binary relation r put f 0 choose set 1 functions constraints relations set binary constraint cg binary constraint cg finally 1 function c 2 0 x define 1 function c g 1 function e 2 0 x z z 6j yg assume pair variables x one constraint exists x 1 consider corresponding instance cdc algorithm incorporating effect functions 1 corresponding domains obtain following algorithm known ac3 algorithm mackworth 10 assume de x ac3 algorithm binary constraint cg binary constraint cg 6 choose c 2 suppose c x changed variables od useful mention corresponding reformulation hyperarc algorithm differs second assignment variables z x z x g capitalized commutativity corresponding projection functions 1 follows first constraint relation x z z added exploited part ii commutativity lemma 3 second constraint relation x added exploited part commutativity lemma 3 assumption 1 c constraint relation x coincides 2 function c case assumption 1 considered csp dropped resulting algorithm somewhat less readable however use following modified definition comm 1 1 function e 2 0 x z z 6j yg get instance cdc algorithm differs ac3 algorithm qualification 6j x j removed definition second assignment set 7 path consistency algorithm notion path consistency introduced montanari 15 defined special type csps simplicity ignore unary constraints usually present studying path consistency definition 6 call csp p normalized subsequence x variables exists one constraint x p given normalized csp subsequence x variables denote cx unique constraint variables x exists otherwise universal relation x equals cartesian product domains variables x 2 every csp trivially equivalent normalized csp indeed subsequence x variables p constraint x exists need replace set constraints x intersection note universal relations cx constraints normalized csp simplify notation given two binary relations r define composition r note r constraint variables x constraint variables z r delta constraint variables x z given subsequence x two variables normalized csp introduce supplementary relation c yx defined recall relation c introduced previous section supplementary relations parts considered csp none defined subsequence variables allow us compact presentation introduce following notion definition 7 call normalized csp path consistent subset fx zg variables words normalized csp path consistent subset fx zg variables following holds c 2 c xz exists b b 2 c xy b c 2 c yz definition used relations form c uv subset fu vg considered sequence variables u v subsequence original sequence variables c uv supplementary relation constraint original csp expense redundancy rewrite definition constraints considered csp universal relations involved contents following simple observation useful later section alternative path consistency normalized csp path consistent iff subsequence z variables x z fig 1 three relations three variables figure 1 clarifies observation instance indirect path x via z requires reversal arc z translates first formula recall subsequence x z variables relations c xy c xz c yz denote either constraints considered normalized csp universal binary relations domains corresponding variables given subsequence x z variables p introduce three functions pc xy theta pc xz theta pc yz f z xy f finally introduce common fixpoints defined functions end need following counterpart hyperarc consistency lemma 2 lemma 4 path consistency normalized csp hc fixpoint functions f z associated subsequences z variables ii functions f z xy f xz f x inflationary wrt componentwise ordering monotonic wrt componentwise ordering proof direct consequence alternative path consistency note 2 proof ii straightforward properties functions f z xy f xz f x already mentioned apt 1 page 193we instantiate cdi algorithm set functions z subsequence variables p f 2 ff z equal c call resulting algorithm path algorithm enjoys following properties theorem 4 path algorithm consider normalized csp p hc assume constraint c finite path algorithm always terminates let p 0 hc 0 sequence constraints c 0 k computed v c least csp path consistent equivalent p case hyperarc algorithm theorem 3 item rephrased follows consider path consistent csps form hc 0 largest constraints proof proof analogous hyperarc algorithm theorem 3 prove ii note final csp p 0 obtained means repeated applications functions f z xy f xz f x yz starting initial csp p conforming discussion end section 4 view function function csps noted apt 1 pages 193 195 functions transforms csp equivalent one 2 8 improvement pc2 algorithm case hyperarc consistency improve path algorithm taking account commutativity information fix normalized csp p abbreviate statement x subsequence variables p x oe following lemma lemma 5 commutativity suppose x oe let z u variables p fu zg fx functions f z xy f u xy commute words two functions pair variables subscript commute proof following intuitive argument may help understand subsequent formal justification first considered functions three arguments share exactly one argument modify shared argument second functions defined terms settheoretic intersection operation applied two un changed arguments yields commutativity since commutative formal argument note first relative positions z u wrt x specified total three possibilities concerning z three possibilities concerning u instance z x x consider total nine cases follows limit analysis three representative cases proof remaining six cases completely analogous case 1 oe z oe u x z fig 2 four variables connected directed arcs helps visualize variables figure 2 informally functions f z xy f u xy correspond respectively upper lower triangle figure fact triangles share edge corresponds fact functions f z xy f u xy share precisely one argument one pc xy ignoring arguments correspond schemes functions f z xy f u xy assume functions f z defined functions changes first argument fact elements respectively pc xy pc xz pc yz pc xu pc yu f z case 2 x oe z oe oe u intuitive explanation analogous case 1 confine noting f z defined changes second argument fact f z case 3 z oe x oe u case functions f z defined changes third argument fact f z instantiate cdc algorithm set functions f 0 section 7 additionally use function comm defined follows x oe z 62 fx yg commf z thus function g set commg contains precisely number variables considered csp quantifies maximal gain obtained using commutativity information update stage corresponding instance cdc algorithm add gamma 3 less elements case corresponding instance cdi algorithm considered previous section virtue commutativity lemma 5 set commg satisfies assumptions update theorem 2ii conclude instance cdc algorithm enjoys properties original path algorithm counterpart path algorithm theorem 4 holds make modification path algorithm easier understand proceed follows function form f u xy x oe u 62 fx yg identified sequence x u variables note relative position u wrt x fixed x u subsequence variables p allows us identify set functions f 0 set next assuming x oe introduce following set triples different variables p xg informally v xy subset v 0 consists triples begin end either x x corresponds set functions one following forms f uy f ux instance cdc algorithm becomes following pc2 algorithm mackworth 10 initially choose apply f u xy current domains od phrase apply f u xy current domains made precise relative position u wrt x known suppose instance u x f u xy defined pc ux theta pc uy theta pc xy f u xy phrase apply f u xy current domains replaced assign ment analogously two possibilities difference pc2 algorithm corresponding representation path algorithm lies way modification set v carried case path algorithm second assignment v 9 simple iteration algorithms let us return framework section 2 analyze loop generic iteration algorithm gi replaced loop first weaken notion commutativity follows definition 8 consider partial ordering v functions f g say f semicommutes g wrt v fgx v gfx x 2 following lemma provides answer question posed elsewhere omit brackets writing repeated applications functions argument lemma 6 simple iteration consider partial ordering v least element let f f finite sequence monotonic inflationary idempotent functions suppose f semicommutes f j j least common fixpoint functions f 2 proof prove first 2 1k indeed assumption 2 following string inclusions last one due idempotence considered functions additionally inflationarity considered functions also 1k common fixpoint functions f means iteration f starts f k f eventually stabilizes f 1 stabilization lemma 1 get desired conclusionthe lemma provides us simple way computing least common fixpoint set finite functions satisfy assumptions lemma particular condition 2 namely suffices order functions appropriate way apply starting argument end maintain considered functions set list given nonempty list l denote head headl tail taill next given sequence elements n 0 denote list formed list empty denoted following algorithm counterpart gi algorithm assume condition 2 holds functions f simple iteration algorithm si k gd od following immediate consequence simple iteration lemma 6 counterpart gi corollary 1 corollary 3 si suppose v partial ordering least element let f f finite sequence monotonic inflationary idempotent functions 2 holds si algorithm terminates computes least common fixpoint functions f 2 note contrast gi corollary 1 require partial ordering finite iteration loop exactly one element removed list l end loop list l empty consequently algorithm reformulation one line k replaced view si algorithm specialization gi algorithm section 2 elements set functions g represented list l selected specific way update function always yields empty set section 3 refined gi algorithm case compound domains analogous refinement si algorithm straightforward omitted next two sections show use refinement si algorithm derive two wellknown constraint propagation algorithms directional arc consistency algorithm consider notion directional arc consistency dechter pearl 7 let us recall definition definition 9 assume linear ordering oe considered variables consider binary constraint c variables x domains x call c directionally arc consistent wrt oe two conditions c exactly one needs checked call csp directionally arc consistent wrt oe binary constraints directionally arc consistent wrt oe 2 derive algorithm achieves local consistency notion first characterize terms fixpoints end given p linear ordering oe variables rather reason terms equivalent csp p oe obtained p reordering variables along oe constraint p oe sequence variables x x 1 oe x following simple characterization holds lemma 7 directional arc consistency consider csp p linear ordering oe variables let p oe hc directionally arc consistent wrt oe iff fixpoint functions associated binary constraints p oe 2 instantiate appropriate way si algorithm compound domains 1 functions associated binary constraints p oe way obtain algorithm achieves p directional arc consistency wrt oe first adjust definition semicommutativity functions different schemes end consider sequence partial orderings cartesian product v take two functions f scheme g scheme say f semicommutes g wrt v semicommutes wrt v q 2 following lemma crucial lemma 8 semicommutativity consider csp two binary constraints c 1 u z c 2 x oe z 1 function c 1 semicommutes 1 function c 2 wrt componentwise ordering proof denote f uz 1 function c 1 f xy 1 function c 2 following cases arise case 1 functions f uz f xy commute since schemes disjoint case 2 fu zg fx yg 6 subcase 1 functions f uz f xy commute virtue commutativity lemma 3ii subcase 2 let considered csp form hc rephrase claim follows denote f uz f yz x prove note first whereas hyperarc consistency lemma 2ii function inflationary monotonic wrt componentwise ordering first property applied f yz second property applied f xy x 0 establishes claim subcase 3 z x subcase cannot arise since variable z precedes variable whereas assumption converse case subcase 4 z assume subcase 1 u 6 x functions f uz f xy commute since changes first component concludes proof 2 consider csp p linear ordering oe variables corresponding csp p oe able apply lemma order 1 functions binary constraints p oe appropriate way namely given two associated constraint u z g associated constraint x put f g oe z precisely let x xn sequence variables p oe x 1 oe x 2 oe list lm consist 1 functions binary constraints p oe x j xm x j order list lm arbitrarily consider list l resulting appending ln order elements ln front virtue semicommutativity lemma 8 function f precedes function g list l f semicommutes g wrt componentwise ordering instantiate refinement si algorithm compound domains abovedefined list l equal domain variable x assume l k elements obtain following algorithm directional arc consistency algorithm darc k suppose g scheme od algorithm enjoys following properties theorem 5 darc algorithm consider csp p linear ordering oe variables let p oe hc darc algorithm always terminates let p 0 csp determined p oe sequence domains 0 n computed v least csp fp directionally arc consistent wrt oe equivalent p 2 termination immediate consequences counterpart si corollary 3 si algorithm refined compound domains directional arc consistency lemma 7 proof ii analogous hyperarc algorithm theorem 3ii note contrast hyperarc algorithm theorem 3 need assume domain finite assume pair variables x original csp p exists precisely one constraint x holds p oe suppose p oe denote unique constraint p oe x darc algorithm rewritten following algorithm known dac algorithm dechter pearl 7 j n 2 gamma1 od od 11 dpc directional path consistency algorithm section deal notion directional path consistency defined dechter pearl 7 let us recall definition definition 10 assume linear ordering oe considered variables call normalized csp directionally path consistent wrt oe subset fx zg variables definition relies supplementary relations ordering oe may differ original ordering variables example original ordering z precede x case c zx c xz constraint csp consideration case path consistency rewrite definition using original constraints fact following analogue alternative path consistency note 2 note 3 alternative directional path consistency normalized csp directionally path consistent wrt oe iff subsequence x z variables xthus three inclusions precisely one needs checked characterize local consistency notion terms fixpoints end previous section given normalized csp p rather consider equivalent csp p oe variables p oe ordered according oe pair variables exists unique constraint following counterpart directional arc consistency lemma 7 direct consequence alternative directional path consistency note 3 lemma 9 directional path consistency consider normalized csp p linear ordering oe variables let p oe hc directionally path consistent wrt oe iff c fixpoint functions f z associated subsequences x z variables p oe 2 obtain algorithm achieves directional path consistency instantiate appropriate way si algorithm end need following lemma consider normalized csp two subsequences variables x suppose u oe z function f z semicommutes function f u x2 y2 wrt componentwise ordering proof following cases arise case 1 cases equality two pairs variables mean first component variables x 1 x 2 second component variables 1 2 identical case functions f z x1 y1 f u x2 y2 commute virtue commutativity lemma 5 case 2 ignoring arguments correspond schemes functions f z f u x2 y2 assume functions f z defined following holds elements respectively pc x1 y1 f z case 3 ignoring arguments correspond schemes functions f z x1 y1 f u x2 y2 assume functions f z defined following holds elements respectively pc x1 y1 f z case 4 ug fact since assumption lemma variable z differs variables u thus functions f z xy f u xy commute since schemes disjoint concludes proof 2 consider normalized csp p linear ordering oe variables corresponding csp p oe able apply lemma order appropriate way f rs functions variables r oe oe namely put f z x1 y1 f u precisely let x xn sequence variables p oe x 1 oe list lm consist functions f xm x x j order list lm arbitrarily consider list l resulting appending order virtue semicommutativity lemma 9 function f precedes function g list l f semicommutes g wrt componentwise ordering instantiate refinement si algorithm compound domains abovedefined list l equal constraint c assume l k elements yields directional path consistency algorithm dpath apart different choice constituent partial orderings identical directional arc consistency algorithm darc previous section consequently dpath algorithm enjoys analogous properties darc algorithm summarized following theorem theorem 6 dpath algorithm consider csp p linear ordering oe variables let p oe hc dpath algorithm always terminates let p 0 hc 0 sequence constraints c 0 k computed v c least csp fp directionally path consistent wrt oe equivalent p 2 case darc algorithm theorem 5 need assume domain finite assume x sequence variables p oe denote unique constraint p oe x dpath algorithm rewritten following algorithm known dpc algorithm dechter pearl 7 n 3 gamma1 od od od conclusions article introduced general framework constraint propagation allowed us present explain various constraint propagation algorithms uniform way noted already apt 1 using single framework easier automatically derive verify compare algorithms meantime work monfroy rety 14 showed framework also allows us parallelize constraint propagation algorithms simple uniform way additionally already noted large extent benhamou 3 general framework facilitates combination algorithms property often referred solver cooperation starting presentation generic iteration algorithms arbitrary partial orders clarified role played constraint propagation algorithms notions commutativity semicommutativity turn allowed us provide rigorous uniform correctness proofs ac3 pc2 dac dpc algorithms turn focusing constraint propagation algorithms always terminate could dispense notion fairness considered apt 1 line research presented could extended number ways first would interesting find examples existing constraint propagation algorithms could improved using notions commutativity semicommutativity second already stated apt 1 would useful explain similar way constraint propagation algorithms ac4 algorithm mohr henderson 12 ac5 algorithm van hentenryck deville teng 18 pc4 algorithm han lee 9 gac4 algorithm mohr masini 13 complication algorithms operate extension original csp fact recently rosella gennari private communication used framework paper explain ac4 ac5 algorithms finally would useful apply approach paper derive constraint propagation algorithms semiringbased constraint satisfaction framework bistarelli montanari rossi 5 provides unified model several classes nonstandard constraints satisfaction problems acknowledgements victor dalmau rosella gennari pointed us apt 2 assumptions b page 4 sufficient establish theorem 1 added assumption c suggested us rosella gennari r essence constraint propagation rough guide constraint propagation heterogeneous constraint solving applying interval arithmetic real bucket elimination unifying framework structuredriven inference local global relational consistency comments mohr hendersons path consistency algorithm consistency networks relations programming constraints artificial intelligence good old discrete relaxation chaotic iteration distributed constraint propagation networks constraints fundamental properties applications picture processing semantic foundations concurrent constraint programming data types subdefinite models generic arcconsistency algorithm specializations tr arc path consistence revisited networkbased heuristics constraintsatisfaction problems comments mohr hendersons path consistency algorithm optimal italickconsistency algorithm semantic foundations concurrent constraint programming generic arcconsistency algorithm specializations local global relational consistency semiringbased constraint satisfaction optimization chaotic iteration distributed constraint propagation using myampersandldquoweakermyampersandrdquo functions constraint propagation real numbers essence constraint propagation bucket elimination coordinationbased chaotic iteration algorithm constraint propagation rough guide constraint propagation constraint propagation soft constraints arc consistency algorithms via iterations subsumed functions heterogeneous constraint solving data types subdefinite models ctr laurent granvilliers frdric benhamou algorithm 852 realpaver interval solver using constraint satisfaction techniques acm transactions mathematical software toms v32 n1 p138156 march 2006 monfroy carlos castro basic components constraint solver cooperations proceedings acm symposium applied computing march 0912 2003 melbourne florida zhendong su david wagner class polynomially solvable range constraints interval analysis without widenings theoretical computer science v345 n1 p122138 21 november 2005 bistarelli r gennari f rossi general properties termination conditions soft constraint propagation constraints v8 n1 p7997 january krzysztof r apt sebastian brand schedulers rulebased constraint programming proceedings acm symposium applied computing march 0912 2003 melbourne florida sebastian brand krzysztof r apt schedulers redundancy class constraint propagation rules theory practice logic programming v5 n45 p441465 july 2005 antonio j fernndez patricia hill interval constraint system lattice domains acm transactions programming languages systems toplas v26 n1 p146 january 2004
open shut typecase two different ways defining adhoc polymorphic operations commonly occur programming languages first form polymorphic operations defined inductively structure types second form polymorphic operations defined specific sets typesin intensional type analysis operations defined induction structure types therefore new cases necessary userdefined types types equivalent underlying structure however intensional type analysis closed extension behavior operations cannot differentiated new types thus destroying distinctions types designed expresshaskell type classes hand define polymorphic operations sets types operations defined class instances considered openthe programmer add instances new types without modifying existing code however operations must extended specialized code new type may tedious even impossible add extensions apply large universe new typesboth approaches benefits important let programmers decide appropriate needs paper define language supports forms adhoc polymorphism using basic constructs b introduction adhoc polymorphism execution programs depends type information parametrically polymorphic permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copies bear notice full citation first page copy otherwise republish post servers redistribute lists requires prior specific permission andor fee september 1922 2004 snowbird utah function must behave instantiations ever instance adhoc polymorphic function integers may behave dierently instance booleans call functions depend type information typedirected adhoc polymorphism compelling addition typed programming language well suited dynamic environments used implement dynamic typ ing dynamic loading marshalling also essential definition generic versions many basic operations equality structural traversals particular adhoc polymorphism simplifies programming complicated data structures eliminating need repetitive boilerplate code example implementation compiler may include many data structures representing intermediate languages many passes data structures without typedirected programming code traversing abstract syntax must implemented intermediate language generic traversals defined adhoc polymorphism allow programmer concentrate important parts transformation currently two forms adhoc polymorphism typed functional languages first based nominal analysis type information haskell type classes 30 execution adhoc operation determined solely name type argument name head constructor list example may use type implement polymorphic structural equality type class declares typedirected operation called eq instance class describes eq behaves type composite types products lists equality defined terms equality components type class eq eq bool instance eq int instance eq bool instance eq eq b eq ab instance eq eq nominal analysis naturally limits domain adhoc operation types definition provided example eq defined function types typedirected operations nominal framework naturally open time may extended instances new types without modifying existing code second form adhoc polymorphism based structural analysis types example intensional type analysis 11 allows programmers define typedirected operations case analysis type structure polymorphic equality defined runtime type analysis may look like typecase bool x else bc eq fst xfst snd xsnd bc error eq defined functions typedirected operations defined case analy sis naturally closed extension fact cases types must provided operations defined two forms adhoc polymorphism dier way treat userdefined types userdefined types haskells newtypes 23 important part many languages although new types isomorphic existing types express applicationspecific distinctions made type checker example programmer may wish ensure confuse phone numbers ages application even though may represented using integers nominal operations open must extended instances new userdefined type may tedious even dicult add new operations apply many types furthermore types defined separate inaccessible modules impossible programmer extend operation types instead must rely definer type add instance guarantee respect invariants typedirected operation hand closed operations cannot extended new types structural systems treat new types equal definitions approach destroys distinctions new types designed express typedirected operation cannot treat age dierently phone numberboth treated integers systems allow adhoc definitions userdefined types loss abstractiona typedirected operation always determine types underlying representation presence userdefined types neither purely nominal purely structural adhoc polymorphism entirely satisfactory 11 combining forms one language paper unifies two dierent forms adhoc polymorphism foundational language called l language provides capabilities structural nominal analysis coherent framework allowing developers choose characteristics wish use system core l simple system structural type analysis augmented userdefined types structural analysis operator typecase may include branches new names scope naturally typedirected operations may unable handle newly defined types types containing names branch operation cannot allowed argument evaluation become stuck therefore type system l statically tracks names used types compares domain type analysis operation new names generated dynamically execution desirable extend typedirected operations branches new names purpose introduce firstclass maps names expressions intuitively maps branches typecase may passed typedirected operations extending handle new names also l includes support coerce types expressions mention new type names stress consider l appropriate source language humans much way f appropriate source language humans defined l requires programs heavily annotated written highlystylized fashion next step research program develop automated assistance common idioms inference type arguments firstclass maps 12 contributions work l language important step towards improving practicality typedirected programming particu lar paper following contributions define language allows definition open closed typedirected operations previous work chosen one augmented adhoc mechanisms counter diculties define language allows programmers statically restrict domain typedirected operations defined structural system natural manner previous work 11 4 requires programmers use typelevel analysis programming makes restrictions show reconcile typecase analysis higherorder type constructors previous work 31 based analysis interpretation type constructors l show implement operations simpler constructs present sophisticated system coercions converting new types definitions extend previous work 23 29 26 higherorder coercions presence type constructor isomorphisms remainder paper follows next section introduce features l examples first describe semantics core language section 3 extend fully reflexive section 4 section 5 show higherorder analysis may defined discuss additional extensions section 6 discuss related work section 7 conclude section 8 2 programming l core l polymorphic lambda calculus 25 augmented type analysis userdefined types syntax l appears figure 1 addition standard kinds type constructors terms fl includes labels l sets labels l labels may considered type constants model builtin types int userdefined types kinds types l labels l type typepoly terms l type labelpoly terms sls type setpoly terms l1 l2 type typecase branches terms e x xe e1 e2 calculus fix xe integers recursion new e label creation e l firstorder coercion higherorder coercion typecase e type analysis l e e1 e2 branches le e le e l label polymorphism slse el label set polymorphism labels l variables constants label sets u empty universe l l1 l2 singleton union figure 1 core l language important point l supports runtime analysis type information instead requiring typedirected operations resolved compile time runtime analysis necessary many situations types known compile time example large programs benefit typedirected programming important compiled entirety furthermore separate compilation dynamic loading runtime code generation requires runtime type analysis even within single compilation unit type information may available compile time firstclass polymorphism data structure may hide type polymorphic recursion iteration loop instantiated dierent type following subsections describe important features l detail 21 generative types l language includes simple mechanism users define new type constants call type constants labels emphasize fact vary arbitrary label constants written annotated kinds distinguished constants language constructors primitive types label 0 nullary constructor type integers 1 binary constructor function types use syntactic sugar int refer two labels however labels appear types use notation int stand int 1 2 stand function type 1 2 examples extend language new forms types booleans bool products 1 2 lists list add new label constants written bool list form types expression new e creates userdefined labels expression dynamically generates new label constant binds label variable inside scope e type isomorphic type kind operators coerce expressions types apparent context elide annotation example new unlike forms userdefined types haskell newtypes mechanism dynamically creates new types generating new labels requires operational eect run time however coercions convert new label definition runtime cost chose mechanism model generative types l simplicity sophisticated language could base mechanism type generativity module system note even though runtime type analysis destroys parametricity created type polymorphism users may still hide implementation details abstract datatypes generative types outside scope new label impossible determine underlying definition example know polymorphic function f must treat term argument parametrically even presence runtime type analysis cannot coerce type int new 22 type analysis restricted domain term typecase e may used define typedirected operations l operator determines head outermost label normal form type argument int list selects appropriate branch finite map e labels ex pressions example expression typecase int int evaluates 1 finite map typecase may formed singleton map int e int join two finite maps e1 e2 join domains disjoint second map precedence compound maps abbreviated challenging part design l ensuring matching branch analyzed type ex ample stuck expressions typecase bool int 2 type check branch boolean type rather label reason checking typecase expression l calculates set labels may appear within analyzed type requires set subset set labels branches typecase label sets l may empty may contain single label l may union two label sets l1 l2 may entire universe labels u analogously finite maps l1 l n abbreviates l1 ln allow type polymorphism annotate quantified type variable set labels may appear types instantiate example know instantiated type formed labels int bool ie int bool match typecase expression annotate type variable u unanalyzable typecase cover branches 1 realistic use typecase polymorphic equal ity function eq implements polymorphic equality function data objects composed integers booleans products lists following examples let list fix eql0 bool l0 typecase int eqint bool xbool ybool x else 1 l0 2 l0 fst xfst list l0 xlist ylist all2 eq x product types two subcomponents branch abstracts two type variables subcomponents likewise list case abstracts type list elements general type branch typecase determined kind matched label typecase determines head label argument steps corresponding map branch applies branch arguments applied head label exam ple applying polymorphic equality type integer lists results list branch applied int eqlist int l0 xlist ylist all2 eq x int xlist int ylist int all2 eqint x ability restrict arguments polytypic function valuable example polytypic equality function cannot applied values function type l naturally makes restriction omitting set labels argument eq 23 generative types type analysis function eq closed extension however creation new labels may many types expressions programmers would like apply eq l provide two solutions problem rewrite eq extensible new branches new labels otherwise leave eq application coerce arguments eq types contain new labels 231 extensible type analysis l rewrite eq extensible new branches new labels programmers may provide new typecase branches additional argument eq type argument firstclass map labels ex pressions written l1 l2 first component 1 flexibility unanalyzable types impor tant approach best way support parametric polymorphismit allow types partly abstract partly transparent type domain map second third components used describe types branches 2 using firstclass maps pass branch ints following operation x int bool int typecase int bool true x simplicity l makes attempt enforce domains joined maps disjoint instead maps dered existing branches may shadowed rightmost matching branch selected following expression int false supplied x expression evaluate false x int bool int typecase int bool false int true x redefining behavior typecase int may programmer intended allowing scenario aect soundness l programmer wished prevent redefinition could join x left however even typedirected function abstracts map typecase still extensible type map specifies labels domain branches newly created labels cannot supplied therefore l includes labelset polymorphism typical idiom extensible operation abstract set labels map set require argument polytypic function composed labels plus labels already branches typecase call functions defined manner open exam ple create open version eq follows let list code variable describing domain labels map eq function may instantiated types containing labels l0 slsys bools l0 fix eq l0 bool l0 typecase list version eq treat labels dierently underlying representations example dollar amounts stored floating point numbers round two decimal places comparing calculus explicitly witnesses design complexity open polytypic operations suppose wished call open operation called important body open se rializer called tostring intuitively important elides part data structure deciding whether recursion continue tostring applied type provides map new labels important must also applicable types two ways write tostring first supply branches important additional argument 2 type branch determined kind label matched branch well two components precise specification relationship appears section 3 tostring slsy tos string fix tostring typecase tos fst x tostrings1 fst x else tostrings2 snd x else s1 s2 dependencystyle generic haskell 20 uses technique language additional arguments automatically inferred compiler however dependencies still show type operation hindering modularity program second solution provide tostring mechanism coercing away labels set call important case important would able specialize execution newly provided labels ever tostring called many open operations somehow infeasible supply map important may reasonable implementation contrast closed polytypic operation may easily call closed polytypic functions 232 higherorder coercions typedirected operations extensible programmers may wish reason operation closed world furthermore even operation ex tensible many new labels behavior operation identical underlying representa tion although data structure containing new label may converted mention new label repeated use still may dicult computationally expensive coerce components large data structure example coercing list list ints requires deconstructing list coercing element individually creating new list avoid unnecessary eort program written executed add higherorder coercions l terms provide ecient mechanism coercing values labeled types underlying representations back like firstorder coercions operations runtime eect merely alter types expressions example suppose define new label equivalent pair integers new intint variable x type list say also closed typedirected operation f type int int call f list x type check domain f however know isomorphic int could call f coercing type elements list mapping firstorder coercion across list f list int map however operationally map destructs rebuilds type contexts empty context bound type vars l label variables sls label set variables l bound type vars signatures l contexts x l l e v1 v2 le le slse tycon paths figure 2 syntax necessary static dynamic semantics list could computationally expensive higherorder coercions coerce x type list int without computational cost list general higherorder coercion annotated type constructor case list describes location label coerce type term 3 core language next describe semantics core l detail including dynamic static semantics mechanisms described previous section semantics language defined number judgments important described judgments employ number new syntactic categories listed figure 2 reference complete semantics language appears appendix judgment states term e wellformed type type context term context possibly using type isomorphisms described type isomorphisms induced new expressions introduce new label variables isomorphic types show terms well typed often requires determining kinds types judgment set possible labels may appear types judgment l judgment describes smallstep call byvalue operational semantics language says term e set labels l steps new term e possibly larger set labels l evaluation new operator labelset component allows selection fresh label previously used way resembles allocation semantics 22 8 initial state execution includes type constants int l semantics calculus fragment l including fix integers standard discuss 31 semantics generative types dynamic static rules new new e l l int l l 1 figure 3 operational semantics higherorder coercions excerpt new e dynamically new operation chooses label constant previously referred substitutes label variable within scope e statically must appear type e escape scope type checking e isomorphism available coercions primitive coercions change head constructor type arguments syntax denotes type head type path path sequence applications several type arguments operationally primitive coercion cancels primitive coercion higherorder coercions extend expressiveness primitive coercions allow nonhead positions type change described last section useful coercing types values stored data structures coercions annotated type constructor describes part data structure coerced l intuitively higherorder coercion maps primitive coercions expression guided type constructor figure lists rules describe operational semantics term weakhead normal form constructor determines operation higherorder coercions form determined following kinddirected relation first rule assures type kind normalizes weakhead normal form relation standard weakhead reduction relation listed appendix type kind second rule applies eventually reduce nesting abstractions around weakhead normal form type constructor annotation higherorder coercion must kind kind know reduce type constructor form also know path headed variable constant universal type branch type form determines execution higherorder coercion path beginning type variable location firstorder coercion used however may parts value coerced ie may occurrences path besides head position inside firstorder coercion another higherorder coercion otherwise form must match value body coercion form value operational rule example int value must integer coercion goes awayno primitive coercions necessary value function semantics pushes coercion function changing type argument body function similar rules apply value forms 32 semantics type analysis rule describing execution typecase rule uses relation determine weakhead normal form analyzed type form must label head type path typecase chooses rightmost matching branch map argument v steps specified term applying series type arguments specified term path p term path derived obvious fashion static semantics typecase defined following rule l l1 l2 l l1 important part rule checks may safely analyzed typecase whatever head normal form must corresponding branch typecase judgment l conservatively determines set labels could appear part type judgment states typing context type may mention labels set l important rules judgment labels variables l l l first rule labels added set used types second two rules correspond two forms type variable binding type variables bound term language annotated set labels may appear types used instantiate however variables bound typelevel abstractions annotation consequently contribute label set last rule sound appropriate labels recorded typelevel abstraction applied types analyzable core l language types firstclass maps polymorphic expressions may analyzed normal forms labels heads next section show extend calculus types may represented labels therefore analyzed core language however prevent types argument typecase including rules determine label set types rule type checking typecase determines labels could appear argument type looks type firstclass map determine domain map given map e domain l1 type argument mentions labels l rule checks map handle possible labels l l1 result type typecase depends type map argument l1 l2 important rule checking maps rule singleton maps first component map type case l describes domain map second two components l describe types branches map judgments ensure label l label set l wellformed respect type context labels higher kind typecase apply matching branch arguments path matched label therefore branch label must quantify arguments correct type branch determined kind label polykinded type notation l notation defined following rules label set component kindindexed type used restriction quantified type variables ensure safe apply branch subcomponents type argument rule typecase requires second label set type map least big first label set important expressiveness calculus typecase rule conservatively determines set labels may occur anywhere type argument also sound define version rule determines possible labels head position type examined typecase however case branches match labels higher kinds must use u restriction quantified type variables determining head labels types provide information labels parts type precision would prevent important examples expressible calculus many typedirected operations polymorphic equality folds cata morphisms structure types determine behavior algorithm composite types product types function must make recursive calls subcomponents type recursive calls type check show subcomponents satisfy label set requirements entire operation mentioned must assumed subcomponents label set u unanalyzable 33 properties l language type sound following usual progress preservation theorems 32 proofs theorems inductions derivations defined theorem 31 progress int dom e value exist l e theorem 32 preservation int exists e also shown coercions necessary operational semantics untyped calculus coercions erased preserving types analysis operational behavior calculus words expressions l evaluate value coercionerased versions evaluate coercion erased value 4 full reflexivity core language demonstrates basic idea extensible typecase expressions oer capability full reflexivity types cannot analyzed typecase full l language addresses problem extends set analyzable types include types expressiveness full language also includes label label set runtime analysis operators rest section discuss extensions modifications kinds 1 2 labels l label sets l types l 12 slsl l terms e setcase l lindex l setcase e e e u eu branches figure 4 modifications full reflexivity label polymorphism label set polymorphism kind polymorphism figure 5 distinguished label kinds syntax core l support full reflexivity appear figure 4 core l language universal types map types cannot argument typecase full language introduces distinguished labels represent constructors universal types map types kinds distinguished labels shown figure 5 types become syntactic sugar applications appropriate labels shown figure 7 new distinguished labels require new forms abstractions type level labels l label sets sls kinds addition also reflected kind level kinds include kinds core l kinds label abstractions l1 2 kinds label set constructors ls finally universal kinds kinds kind abstractions type level one implication addition new abstraction forms polykinded types cannot determined statically general kind parameterized may unknown compile time therefore polykinded types part syntax full language instead derived forms type equivalence relation encodes fact equivalent certain simpler types interesting equivalences given figure 6 notice polykinded types label constructor figure 7 run time closed polykinded types always reduced one type forms although typecase allows programmer determine label matches one given set labels provide way learn new labels fore full l language introduces operator lindex returns integer associated argument label con stant operator provides programmer way figure int int 1 2 1 2 figure 7 syntactic sugar types distinguish labels run time rule lindex straightforward lindex another addition label set analysis operator setcase language label sets fixed setcase branches possible forms label setempty sin gleton union universe operationally setcase behaves much like typecase converting argument normal form equivalent label sets behavior stepping appropriate branch demonstrate label label set analysis consider following example function computes string representation label set assume language extended strings operations concatenation conversion tofrom integers fix settostringls stringls setcase s1 lss2 ls rule type check setcase setcase l e e rule e must able take label argu ment whatever kind label therefore expression must kind polymorphic 5 higherorder analysis higherorder type analysis 31 extension runtime analysis types higherorder kind used define operations terms parameterized data structures lists trees operations must able distinguish type parameter rest type example generic length operation determines length list number nodes tree must able distinguish data matter type rest structure l generate new labels run time make distinctions result higherorder analysis depends kind analyzed constructor previous systems 31 12 typedirected operation defined interpretation type constructor type functions mapped term type applications term applications type variables term variables way equivalences term language reflect equivalences type language even though types int bool bool syntactically dierent semantically type analysis produces results however l analysis weakhead normal form types equal types normal form equivalences already preserved furthermore know constructors kind equivalent type functions extensionality encode analysis constructor polymorphic term function whose body uses typecase analyze constructor kind generalizing kinds encode higherorder analysis firstorder analysis example suppose f open polytypic operation type slssss l say want use instance f type kind l contains labels modify call site f polymorphic function interpretation type functions function abstracts type argument branch x interpretation creates new label passes branch f maps new label interpretation way matter type instantiated interpretation always x lxnew 6 extensions branches one diculty working l typecase must always branch label argument showed earlier work around using higherorder coercions firstclass maps however cases natural provide default branches apply branches match label add another form map e domain labels extension type variables restricted u parametric branch matches labels kind type depends kind matched label therefore type kind polymorphic polymorphism within l reasonable terms could default branch however addition linguistic mechanisms exceptions default branches provide another way treat new type names recursive uncoercions new types l may recursively defined however higherorder coercions cannot completely eliminate new label type expression instead coercion unroll type leaving occurrence new label possible use firstorder coercions recursively remove occurrences new type result unnecessarily decomposing rebuilding data structure coercions computational content reasonable provide primitive operator jk l uncoercing impossible know statically exact shape e unrolled type e hidden using existential type type bottoms use int although could use type example following list could uncoerced follows jinr 1 inr 3 inl resulting existential package could opened contents used arguments typedirected operation cannot handle label record variant types current systems typedirected programming trouble record variant types names fields constructors often systems translate types internal representation analysis 2 labels integral part l small extension use represent types natively extension need record variant types finite type maps labels types kind finite type maps new syntactic category form abstraction application type term languages well finite map analysis rules analogous label set subsumption membership equality defined finite maps map e mmape em mapcase distinguished label rec kind map forms record types finite maps many versions records types equivalent permutation record terms formed empty records singletons concatenation e1 e2 l domain record type record projection el wellformed provide abstractions finite maps records get form row polymorphism 24 free straightforward develop similar extensions variants key dierence records branches used typecase record label must kind arbitrarilykinded labels allowed code analyzing record types would need kind polymorphic limiting usefulness 7 related work much research typedirected programming runtime type analysis allows structural analysis dynamic type information abadi et al introduced type dynamic types could coerced later via case analysis extracted 1 core semantics typecase l similar intensional polymorphism harper morrisett 11 however l include typelevel analysis operator extension l fully reflexive follows similar extension harper morrisetts language trifonov saha shao 28 weirich 31 extended runtime analysis higherorder type constructors following work hinze 12 generic programming uses structure datatypes generate specialized operations compile time charity language 3 automatically generates folds datatypes polyp 15 extension haskell allows definition polytypic operations based positive regular datatypes functorial ml 17 bases polytypic operations composition functors lead programming language fish 16 generic haskell 2 following work hinze 12 allows polytypic functions indexed type type constructor nominal forms adhoc polymorphism usually used overloading type classes haskell 30 implement overloading defining classes types instances set polytypic operations hinze peyton jones 13 explored extension automatically derive type class instances looking underlying structure new types dependencystyle generic haskell 20 revises generic haskell language based names types instead structure however automatically define generic functions converts userdefined types underlying structural representations specific definition provided many languages use form generative types represent applicationspecific abstractions example standard ml 21 haskell 23 rely datatype generativity type inference modern module systems also provide generative types 5 definition new type known type isomorphisms paper dier calculi type equalities provided harper lillibridge 10 stone harper 27 require explicit terms coerce type name definition explicit coercions dicult programmer use simplify semantics generative types explicit coercions also make sense conjunction typedirected programming even definition known distinction still made dynamic type analysis researchers considered combination generative types forms dynamic type analysis glews 8 source language dynamically checks predeclared subtyping relationships type names lammel peyton jones 18 used dynamic type equality checks implement number polytypic iterators rossbergs n calculus 26 dynamically checks types possibly containing new names equality rossbergs language also includes higherorder coercions allow type isomorphisms behave like existen tials hiding type information inside precomputed expres sion however coercions dierent semantics higherorder coercions reminiscent colored brackets grossman et al 9 also used leifer et al 19 preserve type generativity marshalling 8 discussion conclusion l language provides good way understand properties nominal structural analysis represent forms makes apparent advantages disadvantages view l solid foundation design userlevel language incorporates versions polytypism design l explored many alternatives simplify language example tried combining labels label sets syntactic category types thereby eliminating need separate abstraction forms however combination dramatically increases complexity semantics fact change allows new expressions create new names types label sets even labels complicates process determining appropriate set labels used type constructor aside developing usable source language number extensions would worthwhile con sider first type definitions provide simplistic form generativity plan extend l module system possessing sophisticated type generativity type analysis especially useful applications marshalling dynamic loading would useful develop distributed calculus based upon l avoid need centralized server provide unique type names name generation could done randomly large domain low probability collision finally increase expressiveness core lan guage plan extend two ways first typecase makes restrictions labels appear argument express catamorphisms structure type language however every typedirected function catamorphism operations determine head form type others hybrids applicable specific pattern type structure example add references calculus could extend eq refer ences even contents comparable using pointer equality calculus cannot express pattern furthermore operations applicable specific patterns example operation may applicable functions take integers arguments functions form int int int int int operations still expressible core calculus way statically determine whether type argument satisfies one patterns dynamic checks must used approach problem plan investigate pattern calculi may able precisely specify domain typedirected operations example mechanisms languages designed support native xml processing 14 6 statically enforce treestructured data particular form furthermore also important add typelevel analysis types language shown past work impossible assign types typedirected functions without feature one way might extend primitiverecursive operator trifonov et al 28 include firstclass maps labels types acknowledgments thanks steve zdancewic benjamin pierce andreas rossberg helpful discussion 9 r dynamic typing staticallytyped language generic haskell users guide charity flexible type analysis type system higherorder modules regular object types type dispatch named hierarchical types syntactic type abstraction compiling polymorphism using intensional type analysis polytypic values possess polykinded types jones derivable type classes regular expression pattern matching xml programming fish functorial ml jones scrap boilerplate practical design pattern generic programming global abstractionsafe marshalling hash types definition standard ml revised abstract models memory management jones editor haskell 98 language libraries revised report records variants natural extension ml types abstraction parametric polymorphism generativity dynamic opacity abstract types deciding type equivalence language singleton kinds fully reflexive intensional type analysis typed compilation recursive datatypes make adhoc polymorphism less adhoc syntactic approach type soundness tr ctr ralf lmmel simon peyton jones scrap boilerplate class extensible generic functions acm sigplan notices v40 n9 september 2005 geoffrey washburn stephanie weirich good advice typedirected programming aspectoriented programming extensible generic functions proceedings 2006 acm sigplan workshop generic programming september 1616 2006 portland oregon usa john billings peter sewell mark shinwell rok strnia typesafe distributed programming ocaml proceedings 2006 workshop ml september 1616 2006 portland oregon usa
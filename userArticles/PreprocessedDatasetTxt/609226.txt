generic reification technique objectoriented reflective languages computational reflection gaining interest practical applications witnessed use reflection java programming environment recent work reflective middleware reflective systems offer many different reflection programming interfaces socalled metaobject protocols mops design subject number constraints relating among others expressive power efficiency security properties since constraints different one application another would desirable easily provide speciallytailored mopsin paper present generic reification technique based program transformation enables selective reification arbitrary parts objectoriented metacircular interpreters reification process fine granularity individual objects runtime system reified independently furthermore program transformation applied different interpreter definitions resulting reflective implementation provides different mop directly derived original interpreter definition b introduction computational reflection possibility software system inspect modify runtime gaining interest practical applications modern software frequently requires strong adaptability conditions met order fit heterogenous evolving computing environment reflection allows instance host services determined dynamically enables modification interaction protocols runtime concretely java programming environment java relies heavily use reflection implementation javabeans component model remote method invocation mechanism furthermore adaptability prime requirement middleware systems several groups therefore research reflective middleware coi99bc00 reflective systems offer many different reflection programming interfaces socalled metaobject protocols mops 1 design mop subject number constraints relating among others expressive power efficiency security properties instance using reflection extended version c 2001 kluwer academic publishers higherorder symbolic computation 141 2001 appear use term mop sense kiczales et al kic91 page 1 metaobject protocols interfaces language give users ability incrementally modify languages behavior implementation well ability write programs within language debugging purposes may require mop provide access execution stack however security concerns stack access must frequently restricted java example allowed modify untyped stack security properties essentially rely type information since constraints different one application another able provide speciallytailored mop particular set constraints moreover constraints may change overall software life cycle hence development speciallytailored mops lightweight process traditional approaches development mops meet goal instead provides specific mop hardly modified see discussion related work section 9 consider instance singleprocessor application distributed case distinct tasks performed message sending side receiving side example sender side local calls replaced remote ones instead relying proxies receiver side incoming messages synchronized many existing mops allow behavior message senders modified hence distribution strategy cannot implemented using reflection systems systems see instance coda aff95 provide access senders right start therefore introduce overhead local applications paper present reification mechanism objectoriented interpreters based program transformation techniques use generic transformation applied compile time class nonreflective interpreter definition mechanism used transform different subsets metacircular interpreter order generate increasingly reflective interpreters also applied different interpreter definitions order automatically get different reflective interpreters resulting reflective implementation provides different mop directly derived original interpreter definition paper structured follows section 2 briefly introduce smiths seminal reflective towers upon work based sketch architecture transformational system section 3 provides overview metacircular interpreter java generic reification technique formally defined application nonreflective interpreter exemplified section 4 section 5 devoted reflective programming details reification technique work presenting several applications section 6 complements section 4 presenting technicalities postponed sake readability section 7 discusses correctness transformation sketches formal correctness proof section 8 illustrates refined definition nonreflective interpreter produces expressive reflective interpreter section 9 discusses related work fi nally section 10 concludes discusses future work code occuring paper refers freely available prototype implementation called metaj metaj enables execution reflective programming examples present provides platform experimentation technique 2 overview reification process opinion smith definition reflection smi84 remains key reference clean semantic foundation generality paper proposes one method transpose technique domain objectoriented languages section first introduce smithlike reflection presenting architecture reification method level 0 level 1 level 2 level 3 interpreter program program interpreter interpreter interpreter program interpreter program figure 1 smithlike reflective towers 21 smithlike reflection smiths seminal work reflective 3lisp defines reflection notion reflective towers figure 1 left hand side tower shows userwritten ie level 0 program doublesquare box interpreter defines operational semantics simple classic example reflective programming deals introduction debugging traces trace generation requires interpreter modified two steps performed runtime provide accessible representation current interpreter change representation computation creates extra interpretation layer means reification operator reify level 1 interpreter becomes part program illustration included double square box get second tower three levels program modify standard semantics language defined level 1 interpreter get interpreter generates traces execution see third tower finally nonstandard semantics interpreter interpreter required extra interpretation level introduced illustrated fourth tower fourth tower would required example trace interpreter abstract level smiths reflection model well reification technique two essential properties potentially infinite tower reflective interpreters interpreter level n interprets actual code interpreter level n 1 22 making objectoriented interpreters reflective order get first intuition reification technique consider following simple example intend reflection used color information represented class color added pairs runtime using reflection could dynamically modify inheritance graph pair inherits color achieved pair extends object pair extends color 4 reification operator application reification operator expression yields accessible representation value denoted expression example expression pair denotes corresponding class object say c interpreters memory see figure 7 4pair returns instance say ie object type instance interpreters memory represents c inspected modified default superclass pair replaced color assigning field extendslink newly instantiated pairs contain color information crucial approach reified representation based definition c parser javajjt runtime system expassignjava reflective interpreter reflectiveprogjava java2expvisitorjava parser javajjt runtime system expassignjava nonreflective interpreter progjava java2expvisitorjava instancejava baseclassjava instancejava generation reflective interpreter program transformation figure 2 system architecture achieved system architecture shown figure 2 nonreflective java interpreter repre sented box top takes nonreflective program progjava input program parsed syntax tree evaluated according required reflective capabilities language designer 2 transforms subset classes nonreflective interpreter basically transformation generates two classes original class example file classjava represents classes nonreflective interpreter becomes baseclassjava different version classjava reflective one reflective interpreter relies nonreflective interpreter order build levels reflective tower core issue approach tower levels shown figure 1 effectively built runtime basis verbatim definition nonreflective interpreter smiths model original definition classjava input reflective interpreter figure 2 behavior reflective interpreter derived nonreflective one furthermore approach selective complete transformation applicable class nonreflective interpreter definition implements one version system architecture parser implemented means javacc jjtree versions 08pre2 03pre6 respectively metaj operational jdk versions 116 12 3 simple nonreflective interpreter implemented nonreflective metacircular interpreter subset java provides support essential objectoriented imperative features classes objects fields meth ods local variables assignment statements implement features primitive 2 note building reflective interpreter transformation writing reflective programs two different tasks former performed language designers latter application programmers class expid extends exp private string id expidstring id data evalenvironment locale return localelookupthisid figure 3 class expid class expassign extends exp private exp lhs private exp rhs expassignexp lhs exp rhs data evalenvironment locale data data return d2 figure 4 class expassign types loop constructs could integrated reified similarly java programs represented abstract syntax trees nodes denote javas syntactic constructs implemented corresponding classes example variables assignment statement method call class instantiation expressions respectively encoded classes expid expassign expmethod expnew classes define evaluation method data evalenvironment locale takes values local variables locale returns value expression wrapped data object particular expid see figure 3 holds name variable evaluation method yields value currently associated variable local environment expassign node see figure stores two subexpressions assignment evaluation method evaluates location righthand side expression followed value represented lefthand side expression finally performs assignment expmethod see figure 5 represents method call receiver expression exp method name methodid argument expressions args method call evaluation proceeds evaluating receiver constructing environment argument values looking method definition applying expnew see figure 6 encodes class name classid constructor argument expressions evaluation fetches class definition global environment instantiates possibly calls constructor suggested interpreter defines classes provide runtime system implement operational semantics example class class see figure 7 represents classes reference superclass extendslink list fields datalist list methods methodlist provides methods instantiating class instantiate accessing list methods including super classes methodlist etc methods represented class expmethod extends exp private exp exp receiver private string methodid method name private explist args arguments expmethodexp exp string methodid explist args data evalenvironment locale evaluate lhs receiver instance evaluate arguments get new local environment environment lookup apply method return mapplyargse figure 5 class expmethod class expnew extends exp private string classid class name private explist args constructor arguments expnewstring classid explist args data evalenvironment locale get class create instance instance call non default constructor exists igetinstancelinkmethodlistmemberthisclassidbooleanvalue environment lookup apply method return new figure class class class extendslink superclass datalist datalist field list methodlist methodlist classclass el datalist dl methodlist ml class getextendslink return thisextendslink implementation javas new operator instance instantiate compute complete method list incl superclasses methodlist methodlist figure 7 class class class method private stringlist args parameter names private exp body method body methodstringlist args exp body data applyenvironment argse instance name argument argseaddthis new eval body definition method return thisbodyevalargse figure 8 class method class method see figure 8 means list argument names args body expression body method apply binds argument names values including evaluates body classes include instance contains reference instancelink class list field values provides field lookup method lookup methodlist data implements mutable memory cells fields datalist environment maps identifiers values etc architecture interpreter follows standard design objectoriented interpreters presented gamma et al ghjv95 interpreter design pattern instantiating design pattern following correspondences hold client interpreters main method methods interpretcontext evalenvironment reification technique described paper applicable interpreters architecture note interpreters may implement many different runtime systems 4 generic reification code transformation section give overview generic reification scheme class class formally define underlying program transformation sake readability postpone discussion technicalities section 6 apply detail class instance 41 overview generic reification scheme reification object change semantics object change representation provide access changed representation example possible modify superclass class runtime nonreflective interpreter although reference representing inheritance relation exists memory underlying implementation reified representation class provides access reference internal representation exposed access structure allows semantics program changed eg means dynamic class changes note form structural reification interpreter memory subsumes traditional notions structural behavioral reflection illustration purposes consider class pair two fields fst snd implemented interpreter memory class c denotes instance class c order reify pair choose class reifiable basically reifiable entity two different representations exemplified figure 9 either base representation reified represen tation since reification object change behavior object provide method interface representations common interface implemented using dispatch object 3 class denoted pair dispatch object points currently active representation either base representation baseclass figure 9a reified representation instance denoted 4pair figure 9b dispatch object provides method reify triggered 4 switch base representation reified one call reify creates new tower level dispatch object executes incoming method calls according active representation base representation active dispatch simply delegates incoming method calls reified representation active dispatch object interprets method call whether object accessed dispatch object reified representation irrelevant modification object access path pair visible access path 4pair property commonly referred causal connection levels 3 dispatch technique close bridge state patterns introduced gamma et al ghjv95 denotes methodlist dispatch object class instance datalist methodlist extendlink active representation instance b pair pair pair pair pair different representations figure 9 reification class pair obviously two paths provide different interfaces consider example problem keeping track number pair instances using static field countinstances field could accessed either paircountinstances 44pairstaticdatalistlookup 4 last expression outermost reification operation necessary order call lookup data list object cf fourth item order conclude overview briefly mention important properties reification scheme since reflection provides objects representing internal structure use userlevel programs every reification operation returns instance eg one figure 9b implies reification reified entities requires instances reifiable 4exp yields accessible representation value denoted exp ie object interpreters memory class instance method 5 references dispatch objects active representations cannot accessed user programs call reification operator may modify references ensures tower structure cannot messed user programs scope reification process limited individual objects interpreters memory example reification class reify list methods methodlist superclass three categories objects coexist runtime reified objects nonreified 4 metaj allow static fields could extended easily deal examples 5 4 strict operator syntax extension would necessary reify expression eg ast representing 14 rather value denoted expression eg integer 5 class name type f1 field f1 type fn field fn nametype f1 arg f1 type fn arg fn body type m1 method m1 type m11 arg m11 type 1k arg 1k body m1 figure 10 original class definition reifiable ones nonreifiable ones program accesses object reified one use restricted exactly nonreflective case 4pairextendslink example references class representing superclass pair therefore valid operations reference new 4pairextendslink 6 well accesses static fields members class structure behavior superclass changed must reified first implies accesses nonreifiable objects reified ones safe 42 formal definition generic reification scheme based implementation technique outlined generic reification scheme automatic program transformation applied arbitrary class called name following definition original interpreter shown figure 10 classes consist number fields methods must constructor arguments fields transformation set classes time space complexity linear number classes transformation consists two main steps 1 introduce class basename see figure 11 defines base representation original class name class similar original class name 2 redefine class name see figure 12 implements corresponding dispatch object class provides method interface original class name implements method reify creates reified representation switches base representation reified one figure 11 shows generated base class figures section use different style conventions verbatim text schema variables text substitutions ba sically original class renamed field referent added remember reifiable entity implemented dispatch object points current representation referent field initialized constructor points back representation dispatch object mandatory distinguish dispatch object representation used access 6 current parser metaj allow expression new requires class identifier however parser could easily extended deal expressions allow notation paper class basename type f1 field f1 type fn field fn name referent basenametype f1 arg f1 type fn arg fn name referent body type m1 method m1 type m11 arg m11 type 1k arg 1k figure generated base class fields methods base class denote dispatch object 7 transformation implemented substituting matching keyword followed anything dot thisreferent generated dispatch class shown figure 12 two fields representation points either base representation reified representation boolean field isreified discriminates active representation constructor creates base representation object methods method signature original version base representation active ie isreified false method call delegated base representation reified representation active ie isreified true method call interpreted corresponding call expression parsed parserjava2exp local environment built argseadd method arguments field representation dispatch object method call evaluated eval note sake clarity code intentionally naive actual implemented version could optimized example call parser could replaced corresponding syntax tree method reify builds reified representation base representation evaluating newexpression corresponding class cloned order build new tower level every reified object copy class way behavior reified object specialized independently sharing required application programmer achieve explicitly manipulating references finally reified representation installed current representation reference returned series experiments led us sharing strategy previous version transformation clone class sharing led cycling dependency relationships reflective overlap reification particular reification class class introduced 7 typical problem wrapperbased techniques introduce two different identities object class name object representation boolean isreified nametype f1 arg f1 type fn arg fn new basenamearg f1 arg fn type m1 method m1 type m11 arg m11 type 1k arg 1k thisisreified reifiedrepmethod m1 arg m11 arg 1k environment argseaddreifiedrep thisrepresentation argseaddarg m11 arg m11 data return resultread else return basename thisrepresentationmethod m1 arg m11 arg 1k instance reify thisisreified baserepfield fn environment argseaddbaserepfield f1 thisrepresentationfield f1 argseaddbaserepfield fn thisrepresentationfield fn argseaddaclass aclass return instancethisrepresentation figure 12 generated dispatch class nontermination alternatively experimented one copy class per level case reification without modification object could already change behavior generic reification technique based two assumptions 1 syntactic construct represented appropriate expression interpreter execu tion assume expressions evaluated using method evalargse argse contains current environment ie values free variables current expression 2 assume textual definitions reifiable classes parsed interpreter creation time stored class objects global environment mainglobale objects cloneable way reify creates extra interpreter layer based actual interpreter definition note simple assumptions formal definition enable transformation performed automatically java operator new returns object ie instance therefore order let user build runtime entities instances classes methods provide family deification 8 operators one entities operators inverse generic reification operator example reflective program r class denotes deification operator classes righthand side expression returns class dispatch object front instance created new note deification operators functionally inverting reification operation change representation object back unreified structure eg baseclass case classes dispatch objects engender structure reflective tower implementation accessible user particular reification operator deification operators encapsulate fields representation isreified dispatch objects well field referent base class user programs cannot arbitrarily change tower structure however user type system developed avoid creation meaningless structures r class new method 43 example making class instance reifiable illustrate definition transformation apply class instance see figure 14 used examples reflective programming next section class implements objects interpreter example pair object two fields fst snd implemented instance field datalist contains two memory cells labelled fst snd field instancelink points class containing methods class pair method lookupdata called whenever field pair accessed sake conciseness show methods instance lookupmethod application transformation defined instance yields two classes ba seinstance see figure 15 dispatch class instance see figure 16 pair implemented dispatching instance shown figure 13 default unreified representation baseinstance say b 1 whose datalist field contains fields labelled fst snd see 8 prefer term deification iyl95 equivalent terms reflection wf88 absorption meu98 dispatch object instance dispatch object instance denotes active representation instance b baseinstance datalist instancelink instance different representations dispatch object instance figure 13 reification object pair class instance public class instancelink ref class public datalist datalist field list instanceclass instancelink datalist datalist field access data lookupdatastring name return thisdatalistlookupname figure 14 original class instance class baseinstance class instancelink datalist datalist instance referent baseinstance class instancelink datalist datalist instance referent data lookupdatastring name return thisdatalistlookupname figure 15 class baseinstance figure 13a pair reified see figure 13b represented instance points baseinstance say b 2 note contrast reification classes shown figure 9 reified representation instance reifiable instance hence second dispatching instance figure 13b since reification based actual definition original instance datalist b 2 contains three fields instancelinkdatalist containing fst snd referent definition method lookupdata dispatch object calls method lookupdataof b 1 long pair reified reified definition lookupdata instance interpreted order prove feasibility approach applied reification technique different classes defining objectoriented features java interpreter resulting prototype metaj imperative features nonreflective interpreter tackled analogously way could example redefine sequentialization operator order count number execution steps given method say one way achieve reification occurrences exps reified dynamically changing classes class performing profiling within eval method another solution would replace exps nodes reified nodes including profiling reflective programming section express several classic examples reflective programming framework detailed examples reflective interpreter work help readers understanding systems working examples highlight important feature design since reification scheme relies original interpreter definition metaobject protocol corresponding reflective interpreter ie interface reflective system quite easy apprehend consists classes reifiable metaj reification operator 4 deification operators r figure 17 class pair defined main new instance pair created interpreter object pair represented instance see figure 13a generic reification method provides access representation instance name metapair denoted 4pair figure 13b basic use reflection objectoriented languages consists class instance object representation boolean isreified instanceclass instancelink datalist datalist new baseinstanceinstancelink datalist data lookupdatastring name thisisreified interpret lookup method call pass already evaluated values environment argseaddname name argseaddreifiedrep thisrepresentation data unpack result return dataresultread else return baseinstancethisrepresentationlookupdataname data reify thisisreified copy base class baseinstance create initialize new representation environment argseaddbaserepinstancelink thisrepresentationinstancelink argseaddbaserepdatalist thisrepresentationdatalist argseaddaclass aclass return new figure dispatch class instance class pair string fst string snd pairstring fst string snd class printablepair extends pair string tostring return thisfst class instancewithtrace extends instance method lookupmethodstring name trace methodcalled systemoutprintlnmethod return thisinstancelinkmethodlistlookupname class main void main pair new pair1 2 invariance reification instance test existence super class metaclassgetextendslink null systemoutprintlnclass pair superclass class change methodcall semantics instance metametapairsetinstancelinkinstancewithtrace instance class deification systemoutprintlnr instancemetapairfst figure 17 examples reflective programming reifying object changing internal representation without modifying behavior see example 1 another simple use introspection let us consider problem testing existence super class given class example 2 class pair represented class interpreter reified enables method getextendslink called metaj reflective programming limited introspection internal state interpreter also modified aka intercession third example main shows behavior instance modified changing class dynamically imagine would like print pairs using method called tostring define class printablepair extends original class pair implements method tostring pair made printable dynamically changing class pair printablepair remember field instancelink instance holds class represented instance see figure 15 afterwards object pair understands method tostring fourth example deals method call tracing debugging purposes class instance interpreter defines method method lookupmethodstring name returns effective method called within inheritance hierarchy interpreter lookup followed apply thus method call tracing introduced defining class instancewithtrace specializes class instance interpreter method lookupmethod prints name parameter order install tracing method calls instance pair standard behavior defined interpreter class instance note class accessed interpreter definition integral part reflective system built top reflective interpreter replaced instancewithtrace reification pair provides access instance whose field instancelink denotes class pair sequence two reification operations pair provides access instance whose instancelink denotes class instance link set class instance withtrace method call object pair prints name method therefore tostring printed third example finally note towerbased reflection scheme makes easy trace tracing code required number levels may created sequence calls 4 fifth rather artificial example illustrates deification deifying metapair metaclass order create instance class base level deification reified representation metapair show baselevel operations performed resulting ob ject case class deification restore original class pair advanced examples illustrate approach rely capacity reify arbitrary parts underlying interpreter discussed section 43 reification exps allows behavior sequence operator changed way could instance stop program execution every statement debugging purposes handle numeric overflow exceptions reexecuting current statement block higherprecision data representations furthermore reification control stack would allow javas trycatchmecanism exception handling extended retry variant 6 nuts bolts generic reification section 4 presents essential parts generic reification mechanism however actual implementation fullfledged reflective system requires several intricacies handled current section motivate problems must handled sketch solution developed indepth understanding technicalities refer reader metaj source code class expid extends exp fields constructor data evaloriginalenvironment locale definition eval data evalenvironment locale localemembermetalevelbooleanvalue return thisevaloriginallocale else thisidequalsthis return new datainstance localelookupthisreadreferent else return evaloriginallocale figure class expmethod extends exp data evalenvironment locale instance localemembermetalevelbooleanvalue return thisevaloriginallocale else evaluate lhs object part object instanceof reifiable reifiable ogetisreified evaluate receiver evaluate arguments get new local environment environment new environmentnull null null argseaddmetalevel new lookup method apply return mapplyargse else instanceof datalist thismethodidequalslookup environment return new datadatalist else delegation cases figure 19 class expmethod first reflective interpreter reified object represented dispatch object reified representation basically reified object two different identities technique bound representation rather dispatch object parsing expression reifiedrep method m1 arg m11 dotsarg 1k dispatch object see figure 12 however statement return interpreted denote dispatch object otherwise userlevel programs could expose reified representations interpreter class expid charge identifier evaluation including therefore modified account havior figure 18 method eval distinguishes two cases means environmenttag metalevel 9 first interpretation initiated interpreters entry point nonreflective evaluation necessary second interpretation initiated dispatch object reflective interpretation required first case evaloriginal called method definition eval nonreflective interpreter second case identifier dispatch object current representation returned remember field referent points back base representation dispatch object mechanism used link reified representation dispatch object field must set methods reify class instance provide field 10 second remember scope reification limited single object interpreter memory means interpretation involves reified nonreified objects example reification instance reify neither field list datalist class denoted stancelink particular instance reified interpretation method lookupdata repeated figure 14 data lookupdatastring namereturn thisdatalistlookupname requires thisdatalist interpreted call lookupname delegated thisdatalist denotes nonreifiable object abstract terms dispatch object introduces interpretation layer call eval layer eliminated scope current reified object left scheme implemented expmethodeval see figure 19 two problems methods expdataeval expneweval modified similarly means reification scheme cannot applied four classes expid expmethod expdata expnew 11 however method provides much expressive power restrictions fix relationship certain syntactic constructs runtime system runtime mechanisms still modified exemplified section 5 order weaken restriction designed implemented variant 12 reification scheme require expid expdata modified unfortunately advantage comes price field referent exposed modified reification case 7 discussion correctness transformation complete treatment correctness technique beyond scope paper however section discuss briefly work related semantics reflective systems sketch essential properties constituting skeleton formal correctness proof technique 9 dispatch objects insert tag local environment 10 sake simplicity code shown figures 12 16 mention field referent 11 restriction parts reflective system cannot reified seem inherent reflection wf88 variant also bundled metaj distribution semantics reflective programming systems complex research domain almost existing body research work domain reflection functional programming languages wf88dm88mul92mf93 even context foundational problems still exist example seems impossible give clean semantics avoids introducing nonreifiable components wf88 logics programming languages must considerably weakened order obtain consistent theory reification mul92 one formal studies reflection nonfunctional setting done malenfant et al mdc96 work deals reflection prototypebased languages focuses lookup apply mop formalized means rewriting systems approach thus restricted serve basis correctness concerns general semantic accounts imperative languages difficult define functional case particular transposition results obtained functional case approach requires work anticipate simpler transformational setting arbitrary reflective imperative systems order prove correctness scheme basic property satisfy would equivalence nonreflective interpreter nr reflective interpreter generated applying transformation nr ie since transformation tr operating individual classes property tackled establishing equivalence arbitrary class say c nonreflective interpreter transformed counterpart essentially transformation introduces extra interpretation layer evaluation methods c programs interpretations introduced transformation satisfy property property proven induction structure ast representation p note formulation property intentionally simplistic parameterized contextual information global environment store applied dispatch classes see figure 12 fold interpreting code delegating code thenbranches dispatching methods rewritten using property left right thenbranches equal corresponding elsebranches henceforth conditionals become useless dispatch objects become simple indirections suppressed case method reify rewriting leads expression new name creates copy nonreified representation finally strongly believe transformation typesafe although formally prove every welltyped interpreter transformed welltyped reflective interpreter obviously wronglytyped user programs may crash nonreflective interpreter way reflective programs may crash reflective interpreter instance confusing reflective levels trying access field previously suppressed using intercession specialized type systems static analysis methods safe reflective programming developed generating alternative metaobject protocols already mentioned set reified classes along definitions determines mop think key property approach provides basis systematic development speciallytailored mops section modify messagesending part nonreflective interpreter order provide finergrained mop distinguishes sender receiver message class instance add two new methods data sendmsg msg return msgtoreceivemsg data receivemsg msg return msgtolookupmethodmsgmethodid class expmethod extends exp data evalenvironment locale evaluate receiver arguments argse new code determine sender build send message instance new msgself thismethodid argse return selfsendmsg figure 20 alternative original interpreter class instancewithsendertrace extends instance data sendmsg msg systemoutprintlnmethod called return figure 21 userdefined extension instance original interpreter expmethodeval evaluates method call implementing composition lookupmethodapply behavior receiver method call modified easily changing definition lookupmethod illustrated trace insertion section 5 however modification concerning sender method call see coda aff95 motivation making sender explicit context distributed programming much difficult implement change would require modification instances expmethod abstract syntax tree ie occurrences operator indeed check whether object contexts nonstandard behavior solution problem modify nonreflective interpreter reflective version provides mop enabling explicit access sender method call intuitively split message sending two parts sender side receiver side first introduce new class msg fourtuple method call contains sender receiver method name methodid corresponding argument values argse two methods dealing messages added definition instance original interpreter send receive see figure 20 finally expmethodeval redefined creates sends message receiver new version nonreflective interpreter made reflective applying program transformation user example introduce tracing message senders see figure 21 way traces introduced previous section example highlights three advantages approach mops precisely defined application programmers provided minimal mops tailored needs language designers extend mops compile time without anticipation changes 9 related work comparison reflective systems inherently difficult wide variety conceptual complexity reflective models implementations example detailed definition clos mop requires book kic91 thorough comparison clos already fills book chapter coi93 consequently restrict comparison three basic properties reflection model obeys first second characterizing smithlike approaches third fundamental goal construction speciallytailored mops 1 tower potentially infinite tower reflective interpreters 2 interpreter interpreter level n interprets code interpreter level n 1 3 selectivity completeness part runtime system almost syntax tree see section 6 interpreter level n reified accessible representation level first reflective systems based notion reflective towers provide potentially infinite number levels notable exception openc chi95 iguana gc96 whose mops provide one metalevel second approach semanticsbased following smiths seminal work reflective 3lisp smi84 functional languages also case prototypebased languages 3krs mae87 agora meu98 objectoriented approaches reflection including obj vlisp coi87 smalltalk bri89 riv96 classtalk bri89 clos kic91 metaxa gol97 semanticsbased sense second property cited feed higherlevel interpreters code lowerlevel interpreters instead different levels represented appropriate pointer structures proceeding allows efficient implementations semantic foundation moreover reflective languages monolithic entities modular approach consists three simple parts nonreflective interpreter operator 4 operators r third approach enables language designers precisely select mechanisms language reflective exception iguana openc reflective systems cited characteristic finally note approach shares general notion completeness 3lisp 3krs agora programming model defined interpreter almost features made reifiable primitives 3lisp cannot reified instance asai et al amy96 also starts complete model interesting approach reflection functional languages restricts reifiable entities order allow optimization partial evaluation contrast remaining reflective systems described base reflection features underlying interpreter implement ad hoc mop notion completeness therefore make sense conclusion future work paper presented program transformation technique generate reflective object oriented interpreters nonreflective ones technique allows speciallytailored mops produced quickly new mops developed scratch refinement existing ones exemplified section 8 compared general mops speciallytailored ones could tuned instance towards better efficiency security properties best knowledge resulting framework reflective objectoriented languages first one satisfying three basic properties mentioned section 9 consequently approach cleanly distinguishes reifiable nonreifiable entities thus helping understanding reflective programs prototype implementation called metaj metaj available future work presented generic reification technique objectoriented reflective languages provides basis exploration metaprogramming design space optimization techniques formalization reflective systems first system level design space mops explored defining refining different nonreflective interpreters exemplified section 8 yielding taxonomy reflective mechanisms user level proliferation reflective dialects requires appropriate design programming tools including libraries userfriendly reflective operators program analyses type systems second reflection deeply related interpretation dispatch object introduces new interpretation layer calling method eval specialization techniques like partial evaluation bn00 prime candidates efficiency improvements furthermore userwritten reflective programs may use reflective capabilities provided reflective interpreter eg make use bound number reflective levels case optimization techniques presented asai et al amy96 could used merge interpretation levels third since reflective programming rather complex task based formal semantics eg define ensure security properties believe transformation could used generate speciallytailored reflective semantics nonreflective one finally firmly believe reification technique also applied parts applications instead interpreter order make reflective preliminary results found related paper authors ds00 acknowledgements thank anonymous referees numerous constructive comments editor olivier danvy work reported also benefited remarks kris de volder shigeru chiba jan vitek improved many discussions colleagues noury bouraqadi mathias braux thomas ledoux r duplication partial evaluation better understanding reflective languages programming explicit metaclasses smalltalk metaobject protocol c first class objects objvlisp model objectoriented programming clos perspectives intensions extensions reflective tower lightweight selective introduction reflective capabilities applications design patterns design implementation meta architecture java using metaobjects support optimisation apertos operating system sun microsystems art metaobject protocol concepts experiments computational reflection semantics introspection reflective prototypebased language towards theory reflective programming languages httpwww prototypebased programming mlisp representationindependant dialect lisp reduction seman tics smalltalk reflective language reflection semantics lisp mystery tower revealed nonreflective description reflective tower tr ctr gregory sullivan aspectoriented programming using reflection metaobject protocols communications acm v44 n10 p9597 oct 2001 manuel clavel jos meseguer miguel palomino reflection membership equational logic manysorted equational logic horn logic equality rewriting logic theoretical computer science v373 n12 p7091 march 2007
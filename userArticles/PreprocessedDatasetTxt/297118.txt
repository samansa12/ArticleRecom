coordinating autonomous entities stl paper describes ecm new coordination model stl corresponding language stls power expressiveness shown distributed implementation generic autonomybased multiagent system applied collective robotics simulation thus demonstrating appropriateness stl developing generic coordination platform autonomous agents b introduction coordination constitutes major scientific domain computer science works coming within coordination encompass conceptual methodological issues well implementations order efficiently help expressing implementing distributed appli cations autonomous agents discipline artificial intelligence enjoys boom since couple years embodies inherent distributed applications works coming within autonomous agents intended capitalize coexistence distributed entities autonomybased multiagent systems mas oriented towards interactions collaborative phenomena autonomy todays state art parallel programming mod els distributed shared memory models data task parallelism parallel object oriented models overview see 30 used implementing general purpose distributed appli cations however suffer limitations con part work financially supported swiss national foundation scientific research grants 214726296 200502697 cerning clear separation computational part parallel application glue coordinates overall distributed program especially limitations make distributed implementations burdensome study problems related coordi nation malone crowston 25 introduced new theory called coordination theory aimed defining glue research area focused definition several coordination models corresponding coordination languages order facilitate management distributed applications coordination likely play central role mas systems inherently dis tributed importance coordination illustrated two perspectives one hand mas built objective dependencies refers configuration system appropriately described implementation hand agents subjective dependencies requires adapted means program often involving highlevel notions beliefs goals plans paper presents stl new coordination language based coordination model ecm model multigrain distributed applications stl used provide coordination framework distributed mas made autonomous agents enables describe organizational structure architecture mas conceived basis generic multiagent platform coda 1 coordination theory models languages coordination defined process managing dependencies activities 25 field programming languages process building programs gluing together active pieces 10 formalize better describe interdependencies necessary separate two essential parts parallel application namely computation coordination sharp distinction also 1 coordination distributed autonomous agents key idea famous paper gelernter carriero 10 authors propose strict separation two concepts main idea identify computation coordination parts distributed application two parts usually interfere semantics distributed applications difficult understand fulfill typical coordination tasks general coordination model computer science composed four components see also 20 1 coordination entities processes agents running parallel subject coordination 2 coordination medium actual space coordination takes place 3 coordination laws specify interdependencies active entities 4 set coordination tools 10 authors state coordination language orthogonal computation language forms linguistic embodiment coordination model linguistic embodiment means language must provide language constructs either form library calls form language extensions means materialize coordination model orthogonal computation language means coordination language extends given computation language additional functionalities facilitate implementation distributed applications prominent representative class new languages linda 9 based tuple space abstraction underlying coordination model application model realized piranha 8 mention one various applications based lindas coordination model lindas tuple space used networked based load balancing functionality pagespace 14 effort extends lindas tuple space onto worldwideweb bonita 28 addresses performance issues implementation lindas primitives models languages based controloriented approaches iwimmanifold 2 3 concoord 18 darwin 24 toolbus 5 message passing paradigms cola 17 actors 1 objectoriented techniques objective linda 19 javaspace 31 multiset rewriting schemes bauhaus linda 11 gamma 4 linear logic linear objects 6 good overview coordination issues models languages found 27 work takes inspiration controloriented models tuplebased abstractions focuses coordination purpose mas distributed implementations 3 coordination using encapsu lation ecm ecm 2 model coordination multigrain distributed applications uses encapsulation mechanism primary abstraction blops offering structured separate name spaces hierarchically organized within blops active entities communicate anonymously connections established matching entities communication interfaces ecm consists five building blocks 1 processes representation active entities 2 blops abstraction modularization mechanism group processes ports 3 ports interface processesblops external world 4 events mechanism react dynamic state changes inside blop 5 connections representation connected ports figure 1 gives first overview programming metaphor used ecm according general characteristics makes coordination model corresponding coordination language elements classified following way 1 coordination entities ecm processes distributed application 2 two types coordination media ecm events ports connections enable coordination blops repository coordination takes place 3 coordination laws defined semantics coordination tools operations defined computation language work port abstraction semantics interactions coordination media means events application written using ecm methodology consists hierarchy blops several processes run processes communicate coordinate via events connections ports serve communication endpoints connections result pairs matched ports encapsulation coordination model connection blop process event figure 1 coordination model ecm 31 blop mechanism encapsulate set ob jects objects residing blop per default visible within home blop blops abstraction agglomeration objects coordinated serve separate name space port objects processes subordinated blops well encapsulation mechanism events figure 1 two blops shown blops interface processes ie name possibly empty set ports hierarchically structured 32 processes process ecm typed object name possibly empty set ports processes ecm model know kind process iden tification instead black box process model used process care process information transmitted received process creation termination part ecm model specified instance model 33 ports ports interface processes blops establish connections processesblops ie communication ecm handled via connection therefore ports ports names set well defined features describing ports charac teristics names features port referred ports signature combination port features results port type features ports characterized set features communication feature mandatory must supported ecm alizations communication feature materializes communication paradigm includes pointto point stream communication classical messagepassing semantics closed group broadcast se mantics blackboard communication additional port features specify eg amount ports port may connect see stl example matching matching ports defined relation port signatures four general conditions must fulfilled two ports get matched 1 compatible values fea tures 2 name 3 belong level abstraction ie visible within hierarchy blops 4 belong different objects process blop conceptually matching process ports described follows process created blop creates port signature potential blop currently embedded conditions fulfilled two potentials blop connection corresponding ports established potentials disappear 34 connections matching ports results following connections ffl pointtopoint stream 11 1n n1 nm communication patterns possible ffl group messages broadcast members group closed group semantics used ie processes must member group order distribute information ffl blackboard messages placed blackboard used several processes persistent retrieved sequence defined processes 35 events events attached conditions ports blops processes conditions determine event triggered blop condition blop world process definition process p1 p2pin port1 input bb port2 bb ports processes new blop blops create process p1 create processes create blop b1 create blops end blop world figure 2 layout typical program written stl checking implementation dependent see stls event definition example define event semantics ports 4 coordination language designed implemented first language binding ecm model called stl realization ecm model applied multithreaded applications lan unix workstations stl materializes separation concern uses separate language exclusively reserved coordination purposes provides primitives used computation language interact entities implementation stl 21 based ptpvm 22 library providing message passing process management facilities thread process level cluster workstations particular blops represented heavyweight unix processes ecm processes implemented lightweight processes threads ecm model realized stl program whose general structure outlined figure 2 starting default blop world hierarchy processes blops defined showing hierarchical structure language definition level 41 stls specialities section look particularities instantiation ecm model stl 3 simple thread language blops name blop used create instances blop object blop objects placed onto specific physical machine distributed onto cluster workstations creation blop complex recursive procedure includes initialization static processes ports defined blop subordinated blops figure 3 shows definition two blops called world sieve stl syntax line create blop sieve initializes blop somewhere parallel machine statement could annotated machine name specify actual workstation blop initialized port definitions explained later blop world blop sieve declaration blop sieve two ports types names group connector create blop sieve create blop figure 3 blop declaration invocation stl ecm processes stl activated within coordination language computation language coordination language done instantiation process object inside blop dynamically create new processes process object instantiation done body event computation language directly extent tradeoff regarding goal totally separate coordination computation code level however order preserve high level flexibility application level allow two possibilities process termination implicit function implements process inside computation language terminated process disappears blop figure 4 shows example stl process type worker two static ports res thread entry point worker syntax semantics port definitions explained next section ports connections knows static ports interface process blop defined coordination language dynamic ports created runtime computation language however type dynamic attribute p2p bb group myport explanation communication stream blackboard group stream communication structure saturation 1 5 amount ports may connect capacity 12 capacity port data items synchronization async async async async semantics message passing model orientation inout inout inout direction data flow table 1 stls builtin ports user defined port corresponding port attribute values process type worker process worker p2pin work input port p2pout res result output port create process worker w instance figure 4 process declaration invocation stl port ie features must determined coordination language ports use set attributes implementation ecms port features attributes must compatible order establish connection two ports table 1 gives overview attributes port combinations attributes lead port types provides following builtin port types pointtopoint output ports p2pout pointtopoint input ports p2pin pointtopoint bidirectional ports p2p groups group blackboards bb variants types possible defined user classical stream port two matched ports type result stream connection following semantics every send operation port non blocking port infinite storage capacity stl infinity symbolized matches exactly one port orientation attribute defines whether port output port p2pout input port p2pin p2p group set group ports form group mechanism stl ports type gathered group message send operations based broadcast message items always transfered members group closed group semantics used bb bb stands blackboard resulting connection blackboard semantics defined ecm contrast previous port types messages blackboard persistent objects processes retrieve messages using symbolic name tag combinations basic port types possi ble example define 1n pointtopoint con nection saturation attribute p2p port augmented n see table 1 port myport synchronous communication achieved changing type message synchronization syn chronous thus yielding pointtopoint synchronous communication 1n means data producing process blocks n processes connected port every send operation returns n processes received data item stl synchronization attribute overrides capacity attribute synchronous communication implies capacity zero however asynchronous communication made little bit less asynchronous setting capacity attribute value n make sure process blocks sent n messages note capacity attribute local relation process port asynchronous communication certain port capacity guaranteed message placed connection necessarily mean another process connected via port connection actually received message connections result matched ports defined accordance ecm model stls events events triggered using condition operation port event handled event handler inside blop conditions related ports processes blops determine event executed blop overview port conditions see table 2 whether event must triggered checked system every time data flows process accesses otherwise condition like isempty would uninterruptedly trigger events ports processes startup process ports empty condition description unboundport p saturation 6 predicate unbound returns true port yet matched potential communication partners ports saturation unbound predicate returns always true accessedport p equals true whenever port accessed general isemptyport p checks whether port messages stored isfullport p returns true ports capacity reached msg handledport p int n less msg handledport p int n equals true n messages less n messages handled respectively table 2 conditions ports event newworker create process worker new unboundnewout newworker process type worker process worker p2pin work port p2pout work port create process worker w attach event port unboundwout newworker figure 5 example event handling stl event triggered blop tuned anymore handle subsequent events type order handle events event handling routine must reinstalled usually done event handling routine event currently processed useful unbound condition ports enables construction parallel software pipelines elegantly reconsider figure 4 extend figure 5 see interaction event conditions ports stl first event new worker declared event attached unbound condition port initial process denoted wout process w either reads writes data fromto port event new worker triggered time ports wout currently bound unboundwout returns true event body event declaration new worker creates new process type worker resulting new port signature potential blop blop matches two ports wout newin information transferred w new mechanism recursively works port created process new condition unbound attached port newout example illustrates necessity reinstalling explicitly event handlers ensure coordinated execution event handler body case process creation primitives stl separate language used addition given computation language case c however coordination entities must accessed within computation language therefore implemented c library interact coordination facilities stl set primitives includes operations creating dynamic ports methods transfer data ports operations process management see 21 detailed specification 42 stl compiler runtime syste figure 6 shows basic building blocks stl programming environment context ptpvm distributed application consists two files coordination part appstl computation part appfuncc stl part parsed compiler produce pure ptpvm code final program linked runtime libraries stl ptpvm user supplied code generated code stl compiler appfunco appstl appc appfuncc appo stlliba user user compiler compiler linker app ptpvma figure programming environment stl 5 coordination autonomous agents stl one target stl distributed implementation class multiagent systems multiagent methodology recent area distributed artificial intelligence mas organization given set artificial entities acting environment focusing collective behaviors methodology aimed studying taking advantage various forms agent influences interactions widely used either pure simulation interacting entities instance artificial life 23 problem solving 26 definitions mass general enough address multiple domains specified nature agents environment proceed composing typical software mas starting problematics logically inducing dis tributed approach could capitalize selforganizing collective phenomena one key concept approaches emergence apparition functional features level system whole work aimed leading robust solutions applications frameworks robotics parallelism design sys tems follow new ai trend 7 13 agents embodied situated environ ment primeval feature attempt embody autonomy latter believed necessary condition flexibility scalability adaptability emergence follows formally describe class mass attempt implement distributed ar chitectures motivate project discuss difficulties encountered distributing mass eventually present implementation stl peculiar application belonging class mass 51 generic model autonomous agents system generic model composed environment set agents environment encompasses list cells one encapsulating list oncell available objects given time objects manipulated agents list connections cells namely neighborhood implicitly sets topology way encoding environment allows user cope type topol ogy regular since set neighbors specified separately every cell general architecture agent displayed figure 7 agent possesses sensors perceive world within moves effectors act world embodiment implementation different modules presented figure 7 namely perception state actions control algorithm depends application users responsibility order reflect embodiment situatedness perception must local agent perceives features one cell small subset cells given time control algorithm module particularly important defines type autonomy agent precisely inside module designer decides whether implement operational behavioral autonomy 33 operational autonomy defined capacity operate without human intervention without remotely controlled behavioral autonomy supposes basis selfsteering originates agents capacity form adapt principles behavior agent behaviorally au tonomous needs freedom formed learned decided principles behavior experience least part instance basic autonomy would consist randomly choosing type action take sophisticated one would consist implementing learning capabil ities eg using adaptive neural network 52 typical application gathering agents class mas support numerous applica tions illustrate simulation framework mobile collective robotics agents agent simulates behavior real robot seek objects distributed environment would like stack objects like displayed figure 8 approach rests system integrating operationally autonomous agents agent system acts freely cell agent decides action take according control algorithm local perception therefore master responsible supervising agents system thus allowing flexible fault tolerant agents neither explicit coordination features sensors effectors content connections occupied cell perception actions objects move manipulate algorithm control state figure 7 architecture agent figure 8 collective robotics application stacking objects detecting managing antagonism situations con flicts respective goals communication tools negotiation fact communicate indirect way via influences environment simulation environment composed discrete two dimensional l cellsided grid set n objects n mobile agents object located cell carried agent given constraints implemented several variants agent modules details found 12 16 simple control algorithm used follows agents move randomly cell connected one agent carry object comes cell containing objects pick one object probability given 1no ff ff 0 constant agent carries object comes cell containing objects systematically drop object cell empty nothing happens simulation already serially imple mented exhibiting emergence properties system cooperation yielded recurrent interactions agents agents cooperate achieve task without aware details simulation outcomes found 16 53 coexistence distribution autonomous agents would like stress problem implementing mas one described distributed architecture instantiation mas time se rial however may one draws inspiration group robots living entities seems clear agents may run parallel level abstraction mas specification term parallelism simply conveys notion coexistence autonomous agents hence parallelism ideally underlies every conception mas thought implicitly taken account serial imple mentation paradoxically projection mas onto distributed architecture turns far obvious discuss fundamental origins difficulty details may found 15 concerns different concepts time mas distributed comput ing respectively illustrate difference concepts coordination distributed computing mas problem crystallizes around different levels understand speaking coordination conception stage ie implemen tation notion coordination agents refers level organization quite different one programming level studied mas application gathering agents order investigate methods cooperation agents namely emergent selforganized cooperation subdomain coordination stage cooperation agents deals dependencies agents autonomous entities challenge find appropriate tradeoff cooperation necessary fruitful coordination interdependent entities relative autonomy stage envisaged cooperation methods must described terms agents architecture perception actual sensors effectors thus methods completely undertaken internal control algorithm result embodiment situatedness prescriptions implementation stage notion coordi nation agents deals organization actual processes pieces software structures objects represent agents machine level serial implementation agents work round robin fashion way data consistency preserved therefore coordination problems occur thus serial implementations perturb conceptual definition coordination agents distributed implementation new problems arise due shared resources data synchronization consistency concerns coordination models distributed computing aimed providing solutions problems describe coordination media tools external agents deal consequences spatial distribution supporting processes example coordination medium ports connections ecm substratum coordinated entities embedded concerns coordi nation dimension substratum confused agents environment described mas level reflects distributed supporting ar chitecture find notion orthogo nality coordination medium orthogonal model agents environment take separation concern account means coordination introduced conceptual level implemented control algorithm module agents belongs computational part implemented computational language whereas coordination supporting processes implemented coordination language nevertheless question determine extent separation computation including agents conceptual coordination coordination distributed processes possible words extent coordination methods distributed processes interfere coordination methods agents specified mas level kind coordination media tools may provide coordination means compatible agent architecture autonomy locality prescriptions usual platforms enable distributed computing belong mas domain distributed implementations mas existing languages would give rise precautions taken hybrid system realizes improper junction two levels definition coordination case agent processes coordinated synchronized rate means conceptual definition mas chosen language provides compels use order manage processes processes designed aim representing autonomous agents resulting system may exhibit characteristics image property mas one goals understand prescribe precautions taken develop platform makes distributed implementations mas class easier task start implementation mas class stl 54 constraints distributed im plementation aim able express autonomy based multiagent model distributed architecture natural way preserve autonomy identity agents attempt use stl order distribute system gathering agents problematics sketched well reflected try distribute environment several processes machines purpose division environment instance 4 blocks l2 2 cells take advantage given distributed architecture clearly necessitates means addition coordination mechanisms described mas level mechanism needed cope agents crossing borders subenvironments course achieved transparently user part software platform moreover need another type mechanism order cope data consistency eg updating number objects cell mechanisms alter every agen ts autonomy behavior dismiss unnecessary dependency 55 implementation stl environment torus grid every cell four neighbors four connectivity note using four connectivity eight connectiv ity basically change anything except slightly alleviates implementation agents comply rigorously model previously introduced figure 7 sense environment sensors act upon perception take advantage distributed systems environment split subenvironments encapsulated blop depicted figure 9 thus providing independent functioning subenvironments hence agents roaming different subenvironments note blops arranged preserve topology subenvironments implement figure 9 environment split among 4 blops implementation new port types introduced namely p2p nin p2p nbi respectively variants p2pin p2p saturation attribute set infinity see figure 10 port p2pnin port p2pnbi figure 10 userdefined port types global structure metablop world composed init process charge global initialization system set n predefined blops called bx x ranging 1 n encapsulating handling subenvironment figure 11 gives graphical overview organization within blop bx metablop world note figure one blop bx represented avoid overload picture case application multiple blops bx connections init process blops well connections north ports top blops south ports bottom blops east ports east blops west ports west blops intentionally dropped init process four static ports every blop initialized three type p2pout init nbagts cre agts cre subenv one type p2p eot role init process threefold first create init nbagts cre agts ports initial agents within every blop second set cre subenv port subenvironment size number objects position objects cells every blop third collect result exper iment signal end experiment properly shutdown system eot port blops bx figure 13 see appendix shows implementation application depicted figure looks like stl coordination lan guage case four blops bx namely b1 b2 b3 b4 figure 12 see appendix presents declaration instantiation processes belonging blop bx two types processes may distinguished processes purposebuilt distributed implementation multiagent application enable distributed implementation namely initagent taxi processes actually peculiar multiagent application viz subenv agent processes ports blop bx blop twelve static ports four p2pout outflowing direction ports north south west east four p2pin inflowing direction ports north south west east gateway ports enabling agent migration across blops three p2pin ports namely agents b subenv used creation initial agents actually realized initagent process appropriate setup subenvironment achieved subenv process p2p port b eot used forward init process result experiment indicate end experiment time topology blops set static manner creating ports appropriate names see figure 13 appendix four inflowing direction ports blop match port inner process initagent four outflowing direction ports blop match ports inner process taxi initagent process new agt event inita gent process responsible creation agents four static ports nb agts type p2pin newarrival type p2p nin location type p2p init type p2pout outset ex periment initagent process nb agts port informed init process number agents created present blop initagent process loop newarrival port receive identifiers agents created soon value comes port new agt event see figure 12 appendix triggered create new agent process meantime initagent process draw randomly every agents identifier agents position location port enables initagent process communicate subenv process better control position agent regard agents objects positions eg ensure outset one agent reside empty cell initagent process write init port values agent created latter creation port read information previously written init port initagent process values transmitted feature instance position agent state note newarrival port connected inflowing direction ports blop within resides thus enabling deal migrating agents across blops course experiment event mechanisms described lo init creagtsb1 cresubenvb1 blop bx bagents creation reqans blackboard bnortho bwesto bsoutho beasto taxi tsouth twest conagt tnorth teast agent creation reqans initagent init newarrival subenv init location location nbagts eot beot bnbagts world figure 11 init process single blop bx solid dotted lines introduced purpose visualization cation port useful point initagent process already check subenv process whether position agent intends move permitted case initagent process draw randomly new position neighborhood position agent intended go agent process process two static ports req ans type bb creation type p2pin plus taxi dynamic p2pout port already stated process reads creation port values position state req ans ports agents connected blackboard agents sense environment perception act action performing lindalike inout operations appropriate messages type action agent take depends type control algorithm implemented within agent see architecture agent figure 7 taxi port used communicate dynamically taxi process case migration position state agent indeed copied taxi pro cess decision migrating always taken subenv process subenv process subenv process handles access subenvironment charge keeping data consistency also responsible migrating agents cross border sub environment static port type bb connected blackboard static p2pout port taxi connected taxi process initialized init p2pin port subenv process builds subenvironment performing inout operations appropriate tuples subenv process process requests agents eg number objects given cell move next cell reply requests eg x objects given cell move allowed registered move agent lead cross border cell located another blop subenv process first inform agent migrate inform taxi process agent migrated direction agent take transmitted taxi process know port write location p2p port used communicate initagent process request position agent regard agents objects positions taxi process taxi process responsible migrating agents across blops four static direction ports type p2pout connected four outflowing direction ports blop within stands process receives static p2pin port requ direction towards agent migrate create dynamic p2pin port con agt order establish appropriate agent process communication means collect useful information agent intended position plus state values written port corresponding direction take transferred newarrival port initagent process concerned blop inducing dynamic creation new agent process blop thus materializing migration 6 discussion 61 stl coordination language coordination language distributed program ming ecm along stl present similarities several coordination languages particularly iwim model 2 instantiation manifold 3 however differ several important points ffl one might inclined identify blops iwim managers manifolds case blops coordinators create explicitly interconnections ports establishment connections implicit resulting matching mechanism depending types states ports definitely different point view communication patterns imposed main characteristics blops encapsulate objects thus forming separate namespace enclosed entities encapsulation mechanism events nested blops powerful mechanism structure private namespaces offering explicit hierarchical model ffl ecm generalizes connection types either stream blackboard group adds powerful means express coordination tuplespace models restrict channels refined semantics defined virtue port characteristics features ffl ecm events signals broadcast environment routines belonging blops attached ports conditions state determine events launched events create new blops pro cesses attach events ports action area limited blop ffl interconnections evolve configuration changes set ports within blop induced events also processes selves fact latter create new processes new ports thus yielding communication topology changes ecm stl present similarities several coordination models languages like linda 9 darwin 24 concoord 18 mention specific characteristics work like several developments linda model instance objective linda 19 ecm uses hierarchical multiple coordination space model contrast single flat tuple space original linda processes get started event blop automatically upon initialization blop creation operation another process linda uses one single mechanism eval processes execute medium used transfer data order communicate references processes ports belonging entities communicate anonymously ports 62 agent language stl new instantiation ecm model besides advantage better overview coordination duties however turned separation code stl always main tained although black box process model ecm good attempt separate coordination computation code dynamic properties proved difficult express separate language example reflected stl primitives must used computation language order use dynamic coordination facilities stl dynamic properties separated totally actual program code furthermore duplication code processes may introduce difficulties manage code distributed application observations lead us development another instantiation ecm namely coordination language stl new language binding implements ecm enriching given object oriented language c case coordination primitives offering high dynamical properties stl application set classes inheriting basic classes stl library stl aims giving basic constructs implementation generic multiagent platforms thus agent language 32 thorough description stl found 29 7 conclusion paper presented ecm coordination model stl language binding built first stlbased prototype top existing pt pvm platform 22 implementation classical collective robotics simulation illustrated power demonstrated appropriateness coordinating class autonomous agents whose critical constraint preservation autonomy dismissing coordination mechanisms exclusively embedded purpose implementation unnecessary dependencies far development platform multiagent programming concerned stl seen first starting point stl already includes mechanisms appropriate multiagent pro gramming among 1 absence central coordinator process relate type entity multiagent system 2 notion ports avoiding additional coordinator process 3 despite 2 notion blop hierarchy case allows us represent encapsulation environment agents stl coordination model still extended order encompass many generic coordination patterns possible yielding stl skeletons disposal general purpose implementations future works consist 1 improving model introducing new userdefined attributes ports dynamic ports blops data typing port types refining subtyping ports supporting multiple names ports 2 developing graphical user interface facilitate specification coordination part distributed application two major outcomes work first autonomous agents systems aimed addressing problems naturally distributed coordination platform provides user possibility actual distributed implementation therefore benefit numerous advantages distributed systems work step forward autonomous agents commu nity secondly generic patterns coordination autonomybased multiagent implementations embedded within platform user quite easily develop new applications eg changing type autonomy agents type insofar comply generic model acknowledgements grateful andre horstmann christian wettstein valuable work consisted realizing parts stl platform r actors model concurrent computation distributed systems iwim model coordination concurrent activities overview manifold implementation programming multiset transformation toolbus coordination architecture extending objects rules intelligence without reason adaptive parallelism pi ranha linda con text coordination languages significance bauhaus linda cooperation implicite et autonomous agents concepts implementation architecture coordinate distributed applications web performance autonomybased systems tuning emergent cooperation cola coordination language massive parallelism software environment concurrent coordinated programming objective linda coordination model objectoriented parallel pro gramming coordination requirements open distributed systems ptpvm concepts tools coordination multithreaded appli cations artificial life structuring parallel distributed programs interdisciplinary study coordination design intelligent agents layered approach coordination models languages set tuple space primitives distributed co ordination programming languages parallel processing agent ories adaptive behavior autonomous agents tr
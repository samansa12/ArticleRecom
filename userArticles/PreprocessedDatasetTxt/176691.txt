generating linear extensions fast one important sets associated poset cal p set linear extensions ecal p paper presents algorithm generate linear extensions poset constant amortized time time oecp ecp fastest previously known algorithm generating linear extensions poset runs time cdot ecp n number elements poset algorithm presented first constant amortized time algorithm generating naturally defined class combinatorial objects corresponding counting problem pcomplete furthermore shown linear extensions generated constant amortized time extension differs predecessor one two adjacent transpositions algorithm practical modified count linear extensions efficiently compute p x pairs xy time on2 ecal p b introduction one definition adverb fast quick succession websters collegiate dictionary 1 purpose paper show linear extensions partially ordered set poset generated fast fast fact algorithm faster constant factors furthermore constants involved small algorithms extend practical range posets extensions generated counted linear extensions great interest computer scientists relation sorting scheduling problems example many npcomplete oneprocessor scheduling problems precedence constraints 13 one obvious way solving problems generating linear extensions precedence constraints picking best extension linear extensions also interest combinatorists relation counting problems 221 results used efficiently generate standard young tableau given shape alternating permutations many combinatorial objects viewed linear extensions particular posets given poset p two questions naturally arise generation question asks whether linear extensions ep p efficiently generated counting question asks whether ep size set ep efficiently determined recent result brightwell winkler 4 counting question p complete indicates counting question may easier generation question give best possible answer generation question sense algorithm generates ep time complexity oep aside small amount preprocessing say generation algorithm runs constant amortized time runs time n number objects generated case linear extensions assume unit cost oracle available takes two poset elements b returns whether oe b also assume poset elements department computer science university toronto toronto ontario m5s 1a4 canada garacsutorontoca research supported part nserc research paper took place visiting simon fraser university burnaby canada department computer science university victoria victoria bc v8w 2y2 canada fruskeycsruvicca research supported part natural sciences engineering research council canada grant a3379 labeled particular manner described later labeling carried time 2 n element poset aside space used poset amount space required algorithm constant amortized time generation algorithm previously known class combinatorial objects corresponding counting problem pcomplete problem generating linear extensions poset considered knuth szwarcfiter 12 varol rotem 24 kalvin varol 11 papers term topological sorting used instead linear extension efficient algorithms appears varol rotem 24 whose time complexity given delta ep 11 n number elements poset worth noting varol rotem algorithm simple elegant quite efficient practice algorithm aware counting linear extensions arbitrary posets wells 25 appears difficult analyze particular classes posets seriesparallel bounded width efficient algorithms counting known see example bouchitte habib 3 2 strategy definitions popular strategy efficiently generating set combinatorial objects insist successive objects listing differ small prescribed way listings combinatorial objects property called generalized combinatorial gray codes example binary reflected gray codes yield method generating nbit strings bit string differs predecessor flipping one bit gray codes found several classes combinatorial objects many described wilf 26 regard linear extensions permutations elements poset generating various classes permutations common closeness criteria successive permutations differ transposition two elements sometimes restricted transposition adjacent elements wellknown algorithm steinhaus 22 johnson 10 trotter 23 provides gray code listing n permutations n elements permutation differs predecessor transposition two adjacent elements thus say n permutations generated adjacent transpositions permutations nset correspond linear extensions poset n element antichain general always possible generate linear extensions poset transpositions adjacent example linear extensions poset consisting two nontrivial chains n odd 5 6 16 thus linear extensions poset figure 1 two 2element chains cannot generated transpositions linear extensions classes posets shown generable transpositions see 1815 20 open problem characterize posets property even linear extensions family posets generated transpositions fast algorithm perform generation may exist basic strategy initial algorithm generate linear extension twice extension flagged plus minus algorithm keeps track signs extensions outputs plus extensions thus sense algorithm falls class generation algorithms generate objects actually output introduce terminology notation poset partially ordered set p reflexive transitive antisymmetric relation rp set sp ordered pair b 2 rp denoted p b lead confusion simply b oe b mean b 6 b element minimal p element b b oe let minp denote set minimal elements p oe b exist c sp oe c oe b say b covers let covera denote set elements cover elements b said incomparable 6 b b 6 write akb indicate b incomparable pair elements sp incomparable p total ordering p total ordering x oe x j j sometimes use xn denote p extension p poset q extension p total ordering called linear extension p let ep denote set linear extensions p let ep denote jepj let sigmaep denote fl gammal j l 2 epg height hx element x average position occupies linear extension thus minimum element height 1 maximum element height jspj p antichain elements height jspj probability x precedes denoted p number extensions x precedes divided total number extensions connection sorting algorithms desirable find pairs elements x p close 12 sp let pnt denote poset set spnt relations set suppose b incomparable elements sp relationship elements sp b precisely suppose c 2 sp c oe c oe b oe c b oe c b called siblings posets p q rp rq antisymmetric let p q denote poset set sp sq relation set transitive closure rprq example pabc poset set sp fa b cg relation set transitive closure rp fa b b cg p say p induces q example every linear extension p oe b oe c therefore say p induces abc element disjoint total orders ff fi fl ffi denote poset fffi consider graph ep vertex set two vertices adjacent graph whenever corresponding linear extensions differ single transposition graph called transposition graph poset p denoted gp subgraph gp vertex set containing edges correspond adjacent transpositions called adjacent transposition graph denoted g 0 p generating linear extensions p adjacent transpositions equivalent finding hamiltonian path graph gp g 0 p figure 1 shows poset transposition graph ff fi linear extensions p dff fi denote distance gp ff fi 0 ff fi denote corresponding distance g 0 p transposition graphs bipartite connected partite sets gp size hamiltonian cycle graph difference size partite sets one hamiltonian path graph thus linear extensions p cannot generated transpositions ruskey 17 conjectures necessary condition existence hamiltonian path also sufficient suggesting possible characterization 1 2 1 fig 1 poset transposition graph fig 2 graph gp theta k 2 posets whose linear extensions generated transpositions figure 1 partite sets size difference two linear extensions poset cannot generated transpositions g graph let g theta k 2 graph results taking two copies g adding edges correspond isomorphism two copies differentiate copies g prefix vertices one copy g gamma example figure 2 shows gp theta k 2 p poset shown figure 1 lemma useful later sections stated follows lemma 21 b siblings p gp proof observe ba linear extension l p transposing b l yields another linear extension p therefore operation transposes b linear extension provides isomorphism total order gp theta k 2 edge purpose inductively showing existence hamiltonian cycles consider graph hamiltonian cycle since hamiltonian path endpoints adjacent 3 graph g 0 p theta k 2 hamiltonian proof g 0 p theta k 2 hamiltonian forms basis efficient algorithm presented next section true certain kind poset called bposet shown 9 r r r r r r r r r r r r fig 3 bposet pruesse ruskey 15 result used proof general case definition 31 bposet poset p whose elements partitioned two disjoint chains x 1 oe x j 1 example bposet shown figure 3 note linear extension bposet extension called canonical linear extension bposet define mrx largest index j x k bposet figure 3 7 following lemma proved 15 lemma 32 let p bposet exists hamiltonian cycle uses edge gamma figure 4 shows graph g 0 p theta k 2 p bposet shown figure 3 edges corresponding isomorphism two copies g 0 p omitted sake clarity one think traveling vertical edge transposing neighbor right traveling along horizontal edge transposing x 1 one neighbors hamiltonian path gamma shown figure 5 bposets used remainder paper call 2bposets graph similar shown figure 4 arises whenever call typical case oe 1 g 0 p path call atypical case words typical case occurs mra 0 atypical case occurs theorem 33 every poset p graph g 0 p theta k 2 hamiltonian proof proof theorem induction jspj base cases induction p poset zero one elements cases g 0 p theta k 2 edge suppose jspj 1 p unique minimum g 0 p inductive hypothesis g 0 pnfag theta k 2 hamiltonian otherwise let p two minimal elements b inductive hypothesis graph g 0 pnfa bg theta k 2 hamiltonian cycle h 0 replace signed linear extension ff h 0 abff replace linear extension gammaff baff result cycle exactly linear extensions b precede elements sp r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r gammaay r r r r r r r r r r r r r r r r r r r r r r r r r r fig 4 graph g 0 p theta k2 r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r fig 5 hamiltonian cycle g 0 p theta k 2 cycle visits linear extensions x2spnfabg poset p 0 p extended b covered every element minp fi poset px bposet lemma 32 hamiltonian path g 0 px fi gammafi substitute occurrence fi path h 0 odd even substitute reverse path occurrence fi call resulting walk h prove h hamiltonian cycle g 0 p theta k 2 necessary show every vertex cycle h linear extension p true since ep 0 ep hence bposet generated extension p also necessary show linear extension l p l gammal occur exactly h suppose l induces order xy fa bg order bg xyi linear extension p 0 l linear extension bposet every bposet generated either induce order xy induce order therefore l gammal generated generation ep l gammal generated exactly observe reference lemma 32 preceding proof strictly necessary bposets occur 2bposets typical case cycle figure 5 could used atypical case cycle obvious move b right far possible change signs move b back left mrb even cycle figure 5 slightly different uses edge aflb gammaaflb cycles used algorithm following section corollary 34 p poset pair siblings gp hamiltonian proof suppose p pair siblings b theorem 33 g hamiltonian therefore gp hamiltonian hence lemma 21 gp hamiltonian open problem determine whether g 0 p hamiltonian p poset pair siblings 4 algorithm proof theorem 33 constructive section present recursive algorithm implicit inductive proof algorithm runs constant amortized time ie generating linear extensions poset p takes time oep first give overview algorithm use small example give general understanding works give details algorithm proof correctness algorithm inplace algorithm maintains array le contains current linear extension maintains variable isplus keeps track sign gamma go one linear extension next making changes array reversing sign main procedure used algorithm call genle recursive basically follows path indicated figure 5 every level recursion associated pair minimal elements current subposet example poset shown figure 1 pair minimal elements pair minimal elements g pairs determined preprocessing described later procedures move switch used change current linear extension operate o1 time follows sign changed isplus changed transposed call transposes x element left call transposes x element right time new linear extension l p generated call genlei ie time move switch called genlei1 called call genlei1 moves possible ways l maintaining order depending order point calling genlei1 nothing example starting 1 b 1 2 b 2 executing calling sequence genle2 switch2 genle2 poset shown figure 1 leads trace calls shown figure 6 follow details implementation reader refer pascal procedure genle figure 8 implementation algorithm maintains four global arrays array le linear extension array li inverse arrays b store elements b discussion algorithm b considered fixed outset unchanging throughout run algorithm arrays maintained ai always contains value leftmost ith pair procedure call linear extension fig 6 trace calling sequence poset figure 1 bi contains rightmost also current sign either plus minus gamma maintained boolean function rightx used determine whether element x move right operates o1 time follows returns true bi incomparable element right array le returns true ai incomparable element right array le element right bi describe preprocessing successively strip pairs elements elements left unique minimum element encountered simply deleted become part pair let maxpair index last pair minimal elements strip p remainder p total ordering empty preprocessing detailed figure 7 note maxpair uniquely determined poset depends order elements stripped p say linear extension l proper order 1 elements j b j adjacent l l induces orders 1 1 maxpair initial linear extension listing must properly ordered maxpair preprocessing figure 7 assuming right bmaxpair1 false initial call simply genle following procedure calls call calling sequence genle maxpair switch maxpair genle maxpair algorithm consists executing preprocessing setting isplus plus sq 6 q exactly one minimal element x begin else begin let two minimal elements q ai maxpair fig 7 preprocessing routine executing calling sequence pascal procedure implementing genle given figure 8 prove following theorem theorem 41 algorithm genle generates linear extensions along hamiltonian path g 0 p theta k 2 proof order prove theorem first prove following proposition proposition 42 let linear extension array le properly ordered linear extension l 2 ep genlei generates l gammal exactly furthermore last extension generated gamma 1 last extension generated 0 differs transposition igamma1 b igamma1 proof proof proceeds induction recursive calls genle0 nothing switch0 changes sign ffia 1 induced p easy confirm algorithm figure 8 stripped recursive calls switch changes sign simply follows path indicated figure 2 case genle1 finds hamiltonian path gamma g 0 q theta k 2 q 2bposet p loss generality sign storage genle invoked ff fi fl way preprocessing selects pairs assured p induces could empty mentioned basic structure algorithm stripped recursive calls follows hamiltonian path 2bposet indicated figure 2 switch transposes linear extension e 0 properly ordered gamma 1 linear extension called l inductive procedure genle begin mrb 0 typical false right bi begin move bi riht genle i1 mra 0 right ai begin typical true repeat mra move ai riht genle i1 right ai typical begin x 1 mla begin move ai left genle i1 typical odd mrb move ai left else switch i1 x 1 mrb begin move bi left genle i1 fig 8 pascal procedure genle hypothesis call generates sigmaep respectively starting l ending l 0 2 ending gammal 2 since even number vertices product graph edge even number calls genlei1 thus 2 sign final permutation unchanged relative ordering igamma1 b igamma1 unchanged union sigmaep b let b amaxpair bmaxpair respectively suppose calling sequence executed preprocessed poset p proposition first call b transposed sigmaep ba generated therefore ep generated theorem proved analyzing time complexity algorithm assume right switch move implemented constant time easily accomplished long inverse li le maintained call move switch generates one linear extension observe call genlei generates least two calls genlei1 iteration whileloop forloop algorithm executes move thereby generating linear extension occasion genle recursively called linear extension generated happens per linear extension generated therefore algorithm runs constant time per linear extension generating sigmaep suppressing linear extensions prefixed gamma generate ep constant amortized time another way think preceding argument consider underlying computation tree internal node recursive call leaf linear extension total amount computation divided node assigned constant amount computation since internal node least two children number leaves greater number internal nodes therefore total amount computation proportional number leaves observe generation minus gamma vertices occurs algorithm genle suggests treated special case minus gamma vertices omitted entirely simply skipping next plus vertex done saves computation list extensions produced successive extensions differ large number transpositions one wants compute number extensions computation saved computing number vertices level recursion generating extensions explicitly ie never moving 1 number vertices extensions determined mra mra number mra mrb change unity one extension next since adjacent transpositions used leads algorithm whose running time oep n general lower bound attained 1 oe c b 1 oe c elements c p n g upper bound attained 1 b 1 maximal well minimal 5 gray codes linear extensions show linear extensions listed successive extensions differ adjacent transposi tions first show existence listings modify results previous sections show set linear extensions poset listed successive extensions differ one two adjacent transpositions let us say ordering ff extensions p delay c thus going show existence delay 2 ordering ep furthermore listing done constant amortized time existence delay 3 ordering difficult show g graph g k denote graph vertex set g edge every pair vertices connected path length k g words incidence matrix g k incidence matrix g k arithmetic done mod 2 cube g g 3 square g g 2 poset p delay k ordering g 0 p k hamiltonian result sekanina 19 cube every connected graph hamiltonian since g 0 p always connected g 0 p 3 hamiltonian delay 3 ordering exists graph g 0 p always 2connected otherwise existence delay 2 ordering would implied result fleischner 7 states square every 2connected graph hamiltonian even though g 0 p general 2connected posets 2connected transposition graphs easy characterize first consider question transposition graphs pendant vertices p consists two disjoint chains g 0 p two pendant vertices p bposet disjoint union two chains g 0 p one pendant vertex otherwise g 0 p pendant vertices lemma 51 every poset p graph hp 2connected hp pendant vertices may proven showing every pair incident edges hp 4 6 8cycle lemma help us finding efficient algorithm listing delay 2 ordering ep instead prove applying theorem 33 following lemma lemma 52 g bipartite g theta k 2 hamiltonian g 2 hamiltonian proof let g bipartite graph n vertices let hamiltonian cycle g theta k 2 v consider sequence vertices since g bipartite g theta k 2 thus vertices vertices one partite set g theta k 2 also vertex u g u 1 u 2 adjacent therefore different partite sets g theta k 2 therefore vertex g appears exactly vertices v v i2 either distance one g distance two g x therefore hamiltonian cycle g 2 conjecture lemma 52 may extended graphs bipartite conjecture 53 g theta k 2 hamiltonian g 2 hamiltonian graph class hs closed walk visits every vertex least times times see 8 14 thus h1 1 class hamiltonian graphs observe g theta k 2 hamiltonian g 2 h1 2 consider walk results two copies g identified converse true g triangle pendant edge added vertex g 2 h1 2 g theta k 2 hamiltonian theorem 33 shows every poset p graph g 0 p h1 2 general graphs hamiltonian make conjecture conjecture 54 g 2 h1 2 g 2 hamiltonian example k 26 shows converse conjecture false proof lemma 52 constructive applying construction g 0 p yeilds following result theorem 55 linear extensions poset generated delay 2 constant amortized time proof run algorithm genle given figure 8 instead suppressing linear extensions negative sign suppress every linear extension ie generate list l 1 output list l 1 proof lemma 52 delay 2 listing linear extensions running time genle ie constant amortized time remainder section discuss use algorithm compute use version genle generates extension exactly twice successive extension differs adjacent transposition predecessor first discuss compute p let us define xyrun maximal sequence successive extensions x precedes maintain two arrays integers call value sx sum lengths previous xyruns value x iteration current xyrun started iteration exactly one adjacent pair say xy transposed occurs tth iteration sx incremented gamma x x set termination algorithm divided 2ep since constant amount update done iteration total computation compute hx proceed similar fashion xrun maximal sequence extensions x occupies position value sx weighted sum lengths previous xruns x iteration current xrun started iteration exactly one adjacent pair say xy transposed occurs tth iteration sz incremented pz set pz position z occupied extension termination value hx sx divided 2ep 6 concluding remarks algorithm given section 6 generates linear extensions poset constant amortized time improvement amortized time algorithm 11 fastest previously known algorithm refinement work presented would generate linear extensions loopfree algorithm ie constant computation worst case producing new extension current one fully implemented counting generating algorithms c found quite efficient practice sun sparcstation slc program generated 2702765 extensions 12 element fence poset 42 seconds extensions counted euler numbers counting took 17 seconds 199360981 extensions 14 element fence counted 91 seconds generated 281 seconds 2674440 extensions 2 14 grid generated 83 seconds extensions counted catalan numbers enumeration linear extensions poset recently shown pcomplete algorithm section 3 constitutes first constant amortized time algorithm generating naturally defined class combinatorial objects associated counting problem pcomplete leads interesting questions complexity generating combinatorial objects counting pcomplete pcomplete problems admit constant amortized time generation algo rithms asking question assume initial object supplied part input example hamiltonian cycles input would consist graph g hamiltonian cycle g similarly paper assumed linear extension input poset intuitively existence question difficult npcomplete generation question difficult well answered even formalized intuition even existence question easy p many problems complexity generating unknown example ideals given input poset generated constant amortized time counting ideals pcomplete finding ideal trivial generating spanning trees graph constant amortized time finding spanning tree counting number trees p one discovered constant amortized time algorithm generating spanning trees fact interesting relationship constant amortized time generation algorithms complexity existence andor counting related questions various polynomial time complexity measures instead constant amortized time considered johnson yannakakis papadimitriou 9 acknowledgements would like thank derek corneil mike fellows carla savage helpful discussions malcolm smith work figures especially ken wong implementing algorithms carefully reading manuscript note added proof pointed l babai private communication easy contrive pcomplete object generated quickly starting pcomplete object pumping number instances taking union easilycounted easilygenerated numerous object exam ple given poset p n vertices consider set fx x ideal pg fx x g set pcomplete count given appropriate representation easy generate constant amortized time counterexample twentyfour vertices conjectures 53 54 recently found j van den heuvel private communication r websters new collegiate dictionary combinatorial theory calculation invariants ordered sets counting linear extensions gray codes restricted density hamilton paths minimal change algorithm square every twoconnected graph hamiltonian generating maximal independent sets generation permutations adjacent transpositions generation topological sortings structured program generate topological sorting ar rangements complexity machine scheduling problems generalization hamiltonicity generating linear extensions certain posets transposi tions adjacent interchange generation combinations ordering set vertices connected graph hamilton paths graphs linear extensions unions posets one hundred problems elementary mathematics algorithm 115 perm algorithm generate topological sorting arrangements elements combinatorial computing combinatorial algorithms tr ctr scott effler frank ruskey cat algorithm generating permutations fixed number inversions information processing letters v86 n2 p107112 jeanluc baril vincent vajnovszki minimal change list lucas strings graph theoretic consequences theoretical computer science v346 n2 p189199 28 november 2005 j sawada oracles vertex elimination orderings theoretical computer science v341 n1 p7390 5 september 2005 l chandran l ibarra f ruskey j sawada generating characterizing perfect elimination orderings chordal graph theoretical computer science v307 n2 p303317 7 october karel de loof hans de meyer bernard de baets exploiting lattice ideals representation poset fundamenta informaticae v71 n23 p309321 august 2006 gang wang wenrui gong ryan kastner instruction scheduling using maxmin ant system optimization proceedings 15th acm great lakes symposium vlsi april 1719 2005 chicago illinois usa russ bubley martin dyer faster random generation linear extensions proceedings ninth annual acmsiam symposium discrete algorithms p350354 january 2527 1998 san francisco california united states karell bertet jens gustedt michel morvan weakorder extensions order theoretical computer science v304 n13 p249268 28 july larry huston rahul sukthankar rajiv wickremesinghe satyanarayanan gregory r ganger erik riedel anastassia ailamaki diamond storage architecture early discard interactive search proceedings 3rd usenix conference file storage technologies march 3131 2004 san francisco ca martin charles golumbic ron shamir complexity algorithms reasoning time graphtheoretic approach journal acm jacm v40 n5 p11081133 nov 1993
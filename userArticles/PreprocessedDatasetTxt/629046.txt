interactive parallel programming using parascope editor parascope editor intelligent interactive editor parallel fortran programs centerpiece parascope project integrated collection tools help scientific programmers implement correct efficient parallel programs discussed parascope editor reveals users potential hazards proposed parallelization program provides variety powerful interactive program transformations shown useful converting programs parallel form parascope editor supports general user editing hybrid text structure editing facility incrementally analyzes modified program potential hazards shown parascope editor supports exploratory programming style users get immediate feedback various strategies parallelization b introduction widespread availability affordable parallel machines increasingly challenged abilities programmers compiler writers alike programmers eager use new machines speed existing sequential scientific codes want maximal performance minimal ef fort success automatic vectorization led users seek similarly elegant software solution problem programming parallel computers substantial amount research conducted whether sequential fortran 77 programs automatically converted without user assistance execute sharedmemory parallel machines 2 3 7 8 42 49 results research promising disappointing although systems successfully parallelize many interesting programs established level success make possible avoid explicit parallel programming user hence research turned increasingly problem supporting parallel programming systems automatic detection parallelism based analysis dependences program two statements depend execution one affects process calculating dependences program known dependence analysis dependence crossing regions executed parallel may correspond data race indicating existence potential nondeterminism program general automatic parallelization system cannot allowed make transformation introduces data race changes original semantics program systems automatic detection parallelism fortran suffer one principal drawback inaccuracy dependence analysis presence complex control flow symbolic expressions procedure calls factors limit dependence analyzers ability prove disprove existence dependences cannot proven dependence exist automatic tools must conservative assume dependence lest enable transformations change meaning program situations user often able solve problem immediately presented specific dependence question unfortunately completely automatic tool user never given opportunity 1 parallelization systems example see 45 provide directive instructs compiler ignore dependences use broad directives like unsound danger user discard real dependences false ones leading errors hard detect address problem developed ptool interactive browser displays dependences present program 6 within ptool user selects specific loop presented analyzer believes dependences preventing parallelization loop user may confirm delete dependences based knowledge underlying algorithms program although ptool effective helping users understand parallelism available given fortran program suffers browser rather editor 33 presented dependences user frequently sees transformation eliminate collection dependences frustrated performing transformation requires moving editor making change resubmitting program dependence analysis furthermore ptool cannot help user perform transformation correctly parascope editor ped overcomes disadvantages permitting programmer tool best tool builds dependences provides expert advice performs complex transformations programmer determines dependences valid selects transformations applied transformations performed ped updates source dependence information quickly cor rectly format avoids possibility user accidentally introducing errors program name implies parascope editor based upon source editor also supports arbitrary user edits current version reconstructs dependences incrementally structured transformations provides simple edits deletion addition assignment statement arbitrary unstructured edits broader scope batch analysis used reanalyze entire program current prototype ped powerful tool exploring parallel programs presents programs data control relationships user indicates effectiveness program transformations eliminating impediments parallelism also permits arbitrary program changes familiar editing operations ped supports several styles parallel programming used develop new parallel codes convert sequential codes parallel form analyze existing parallel programs particular ped currently accepts generates fortran 77 ibm parallel fortran 36 parallel fortran sequent symmetry 46 parallel computing forum developing pcf fortran 44 pcf fortran defines set parallel extensions large number manufacturers committed accepting obviating current need support numerous fortran dialects extensions supported emerge remainder paper organized follows section 2 discusses evolution parascope parallel programming environment particular parascope editor section 3 outlines program analysis capabilities ped section 4 describes manner dependence information displayed may modified survey program transformations provided ped appears section 5 issues involving interactive programming ped discussed section 6 section 7 summarizes related research section 8 offers conclusions background ped developed context parascope project 17 parallel programming environment based confluence three major research efforts rice university ir n rice programming environment 23 pfc parallel fortran converter 8 ptool parallel programming assistant 6 major contributors ideas behind parascope editor begin short description figure 1 illustrates evolution parascope 21 ir n programming environment ped enjoys many advantages integrated ir n programming environment begun 1982 ir n programming environment project pioneered use interprocedural analysis optimization program compilation system accomplish built collection tools collaborate gather information needed support interprocedural analysis preparing program execution included collection source editor fortran combines features text structure editing representing programs internally abstract syntax trees also available whole program manager debugger sequential parallel programs interprocedural analysis optimizations excellent optimizing scalar compiler ir n written c runs x windows mature environment distributed source executable form many external sites one ptool 1985 dependence analysis interprocedural analysis program transformations user interface dependence filters ped parascope 1987 textstructure editor interprocedural analysis optimization figure 1 evolution parascope goals ir n consistent user interface easy learn use large system consisting many independent related portions another goal create modular easily modified implementation resulting environment well suited integrating extending research parallel programming parascope includes builds functionality ir n project 22 pfc pfc project begun 1979 goal producing automatic source source vectorizer fortran written pl1 runs ibm mainframe recent years project focused difficult problem automatically parallelizing sequential code pfc performs data dependence analysis 9 13 14 56 interprocedural side effect analysis 25 interprocedural constant propagation 18 recently implementation regular section analysis 20 32 determines subarrays affected procedure calls completed analysis significantly improves precision pfcs dependence graph arrays longer treated single units across procedure calls pfc also performs control dependence analysis 28 describes execution one statement directly determines another execute analyses performed pfc result statement dependence graph specifies partial ordering statements program ordering must maintained preserve semantics program parallelization dependence graph conservative may include dependences exist cannot eliminated imprecise dependence analysis conservative pfc guarantees safe transformations applied many opportunities parallelism may overlooked special version pfc modified export results control data depen dence dataflow symbolic interprocedural analysis form ascii file use ptool ped pfc concentrates discovering enhancing loop level parallelism original sequential program although loops contain possible parallelism program several reasons focusing scientific numerical applications computation occurs loops also separate iterations loop usually offer portions computation require similar execution times often provide enough computation keep numerous processors occupied pfc many successes influential design several commercial vectorization systems 47 successfully found nearoptimal parallelism selected set test cases 19 however successful enough obviate need explicit parallel programming large complex loops tends find many spurious race conditions one sufficient inhibit parallelization therefore also turned attention use dependence information support parallel programming process 23 ptool ptool program browser developed overcome limitations automatic parallelizing systems displaying dependences fortran programs use debugging analysis tool various sites around country cornell national supercomputing facility ptool developed request researchers los alamos national laboratory wanted debug programs parallelized hand uses dependence graph generated pfc examine dependences prevent loops run parallel assist users determining loops may run parallel ptool also classifies variables shared private examining large scientific programs users frequently found overwhelming number dependences large loops including spurious dependences due imprecise dependence analysis 33 ameliorate problem number improvements made pfcs dependence analysis addition dependence filtering mechanism incorporated ptool browser could answers complex queries dependences based characteristics user could use mechanism focus specific classes dependences ped incorporates extends abilities see section 4 24 parascope editor parascope editor interactive tool sophisticated user programmers rice los alamos elsewhere indicated want involved process parallel programming feel output automatic tools confusing easily map original code often sequential analysis may invalidated parallel version even worse unavailable complicates users ability improve modified source want program recognizable want control parallelization want able tailor codes general usage well specific inputs ped intended users type ped interactive editor provides users information available automatic tools addition ped understands dependence graph parallel con structs provide users expert advice mechanical assistance making changes corrections programs ped also update source dependence graph incrementally changes ped group specific transformations provide format modifying programs structured manner changes takes structured form updates incremental immediate ped also supports general arbitrary edits program changes unstructured source updates done immediately dependence analysis program performed upon demand 3 program analysis 31 control data dependences sequential languages fortran execution order statements well defined making excellent program definition build dependence graph statement dependence graph describes partial order statements must maintained order preserve semantics original sequential program dependence statement 1 denoted 1 indicates 2 depends 1 execution 1 must precede 2 two types dependence control data control dependence 1 indicates execution 1 directly determines 2 executed following formal definitions control dependence postdominance relation taken literature 27 28 x postdominated g f every path x stop contains stop exit node g f given two statements x 2 g f control dependent x 1 9 nonnull path p x postdominates every node x p 2 postdominate x data dependence 1 indicates 1 2 use modify common variable way requires execution order preserved three types data dependence 40 ffl true flow dependence occurs 1 stores variable 2 later uses ffl anti dependence occurs 1 uses variable 2 later stores ffl output dependence occurs 1 stores variable 2 later stores dependences also characterized either loopcarried loopindependent 5 9 consider following enddo dependence 1 loopindependent true dependence exists regardless loop constructs surrounding loopindependent dependences whether data control dependences occur single iteration loop inhibit loop running parallel example 1 ffis 2 dependence loop loop could run parallel statements executed iteration affect statements iteration iterations comparison 1 ffis 3 loopcarried true dependence loopcarried dependences dependences cross different iterations loop constrain order iterations loop may execute loopcarried dependence 3 uses value created 1 previous iteration loop prevents loop run parallel without explicit synchronization nested loops level carried dependence outermost loop first arises 5 9 32 dependence analysis major strength ped ability display dependence information utilize guide structured transformations precise analysis control data dependences program thus important peds dependence analyzer consists four major com ponents dependence driver scalar dataflow analysis symbolic analysis dependence testing dependence driver coordinates components dependence analyzer handling queries transformations edits scalar dataflow analysis constructs control flow graph postdominator tree structured unstructured programs dominance frontiers computed scalar variable used build static single assignment graph procedure 26 coarse dependence graph arrays constructed connecting fdefsg fdefs usesg array variables loop nest program symbolic analysis determines compares values expressions programs possible component eliminates characterizes symbolic expressions used determine loop bounds loop steps array subscript expressions array dimensions control flow main goal improve precision dependence testing ssa graph provides framework performing constant propagation 53 auxiliary induction variable detection expression folding symbolic analysis techniques detecting data dependences program complicated array references since difficult determine whether two array references may ever access memory location data dependence exists references location may accessed references dependence testing process discovering characterizing data dependences array references difficult problem subject extensive research 9 13 14 56 conservative data dependence analysis requires dependence cannot disproven must assumed exist false dependences result conservative dependences actually exist important objective dependence analyzer minimize false dependences precise analysis ped applies dependence testing algorithm classifies array references according complexity number loop index variables separability shared index variables fast yet exact tests applied simple separable subscripts powerful expensive tests held reserve remaining subscripts cases results merged exact test 30 ped also characterizes dependences flow values respect enclosing loops information represented hybrid distancedirection vector one element per enclosing loop element vector represents distance direction flow values loop hybrid vector used calculate level loopcarried dependences generated array reference pair dependence information used refine coarse dependence graph constructed scalar dataflow analysis precise statement dependence graph statement dependence graph contains control data dependences program since ped focuses looplevel parallelism dependence graph designed dependences particular loop may collected quickly efficiently dependences may displayed user analyzed provide expert advice respect transformation details dependence analysis techniques ped described elsewhere 38 33 interprocedural analysis presence procedure calls complicates process detecting data dependences interprocedural analysis required worst case assumptions need made calls encountered interprocedural analysis provided parascope discovers aliasing side effects variable definitions uses interprocedural constants 18 25 unfor tunately improvements dependence analysis limited arrays treated monolithic objects possible determine whether two references array actually access memory location improve precision interprocedural analysis array access patterns summarized terms regular sections data access descriptors abstractions describe subsections arrays rows columns rectangles quickly intersected determine whether dependences exist 12 20 32 distinguishing portion array affected procedure regular sections provide precise analysis dependences loops containing procedure calls 34 synchronization analysis dependence preserved synchronization guarantees endpoints dependence always executed correct order sophisticated users may wish employ event synchronization enforce execution order loopcarried dependences parallel loop cases important determine synchronization preserves dependences loop otherwise may exist race conditions establishing order specified certain dependences always maintained proven conphard however efficient techniques developed identify dependences preserved parallel loops post wait event synchronization 21 22 52 ped utilizes techniques transformation determines whether particular dependence preserved event synchronization loop forms synchronization currently handled ped intend expand implementation include related technique automatically inserts synchronization preserve dependences implementation status though implementation dependence analysis ped made much progress several parts still construction underlying structures control flow graph postdominator tree ssa graphs built yet fully utilized dependence analyzer ped propagates constants currently perform forms symbolic analysis dependence tests implemented work remains banerjeewolfe symbolic tests interprocedural analysis aliases side effects constants performed parascope environment integrated peds dependence analysis integration underway part larger implementation encompassing interprocedural symbolic regular section analysis overcome gaps current implementation dependence analysis ped import demand dependence information pfc invoked special option pfc utilizes mature dependence analyzer produce file dependence information ped converts dependence file internal representation process temporary expedient unnecessary dependence analysis ped complete 4 dependence display section describes peds interface allows users view modify results program analysis persistent view provided ped appears figure 2 ped window divided two panes text pane dependence pane text pane top consists two parts row buttons title bar large area fortran source code displayed 2 buttons text pane provide access functions editing saving searching syntax checking program transformations directly text pane dependence pane dependences displayed also two parts buttons perusing loops dependences larger pane detailed dependence descriptions dependence pane shows results program analysis users since ped focuses loop level parallelism user first selects loop consideration regardless whether loop parallel sequential analysis assumes sequential semantics dependences loop displayed current loop set using next loop previous loop buttons dependence pane using mouse select loop header text pane loops header footer displayed italics user ped display dependences current loop one loopcarried loopindependent control private variable 3 dependences type dependences displayed selected using view button default view displays loopcarried dependences 2 code displayed portion subroutine newque code simple two dimensional lagrangian hydrodynamics program heat diffusion produced lawrence livermore national laboratory 3 private variables discussed section 42 figure ped dependence display filter represent race conditions may lead errors parallel loop although many dependences may displayed one dependence considered current dependence current dependence set dependence pane using next dependence previous dependence buttons direct selection mouse convenience user current dependence indicated panes dependence pane current dependence underlined text pane source reference underlined sink reference emboldened dependence following information displayed dependence pane dependence type control true anti output source sink variable names involved dependence hybrid dependence vector containing direction andor distance information exclamation point indicates information exact loop level dependence first occurs common block containing array references show next section dependences interest classified organized assist users concentrating important group dependences 41 dependence filter facility ped facility filtering classes dependences display restricting display certain classes feature needed often many dependences user effectively comprehend example filtering mechanism permits user hide dependences already examined show class dependences user wishes deal moment edge hidden still dependence graph transformation algorithms still consider simply visible dependence display users also delete dependences feel false dependences inserted result imprecise dependence analysis edge deleted removed dependence graph longer considered transformation algorithms dependence filter facility shown figure 2 class dependences specified query queries used select sets dependences according specific criteria query criteria names variables involved dependences names common blocks containing variables interest source sink variable references dependence type number array dimensions queries except source sink variable references require user type string appropriate query field variable reference criteria set user selects variable reference interest text pane selects sink reference source reference buttons one query criteria specified user choose show hide matching dependences show option dependences current dependence list whose attributes match query become new dependence list figure 2 selected show single query criterion variable name drk hide option dependences current list whose characteristics match query hidden current list remaining dependences become new list criteria set empty using clear button user also push sets dependences onto stack push makes set dependences matching current query become current database subsequent queries pop returns dependence database active time last push multiple pushes corresponding pops supported show presents dependences part current database dependence list sorted source reference sink reference dependence type common block group dependences selected deleted database using delete button delete destructive removed dependence longer considered transformation algorithms appear dependence display section 6 discuss implications dependence deletion 42 variable classification one important parts determining whether loop run parallel identification variables made private loop body important private variables inhibit parallelism hence variables legally made private likely loop may safely parallelized variable classification dialog illustrated figure 3 used show classification variables referenced loop shared private initially classification based upon dataflow analysis program variable ffl defined loop used inside loop ffl defined inside loop used loop figure ped variable classification ffl defined one iteration loop used another assumed shared cases variable must accessible one iteration variables assumed private accessible iterations shared variables must allocated global storage private variables must allocated every iteration parallel loop may put processors local storage notice figure 3 first loop parallel induction variable declared private iteration needs copy consider second loop figure 3 assume n live loop values n needed single iteration loop needed iteration execution loop iteration loop must copy n results executing loop parallel sequential execution otherwise n shared problem would one iteration might use value n stored iteration problem inhibits parallelism n cannot determined private figure 3 variable classification dialog displays shared variables left list private variables right list current loop current loop transformed parallel loop variables shared list would implicitly specified global storage variables private list would explicitly included private statement user select variables either list mouse variable selected reason classification displayed notice figure 3 variable underlined indicating selected reason must sharedmemory displayed bottom pane users need accept classification provided ped transfer variables one list selecting variable selecting arrow button points list users transfer variables one list another making assertion overrides results dependence analysis guarantee semantics sequential loop parallel counterpart usually programmers try move variables shared private storage increase parallelism reduce memory contention latency assist users task classify vars button supports classification variable lists mechanism helps users identify shared variables may moved private storage using transforma tions correcting conservative dependences 5 structured program transformations ped provides variety interactive structured transformations applied programs enhance expose parallelism ped transformations applied according power steering paradigm user specifies transformation made system provides advice carries mechanical details single transformation may result many changes source done one time may leave intermediate program either semantically incorrect syntactically incorrect power steering avoids incorrect intermediate stages may result user required code restructuring without assistance also side effects transformation dependence graph known graph updated directly avoiding unnecessary dependence analysis order provide users flexibility ped differentiates safe unsafe inapplicable transformations inapplicable transformation cannot performed mechanically possible example loop interchange inapplicable single loop transformations safe preserve sequential semantics program transformations always preserve dependence pattern program therefore always safely applied mechanically possible others safe dependence pattern program specific form unsafe transformation maintain original programs semantics mechanically possible transformation unsafe users often given option override system advice apply anyway example user selects parallel button sequential loop loopcarried dependences ped reminds user dependences user wishes ignore loop still made parallel override ability extremely important interactive tool user given opportunity apply additional knowledge unavailable tool perform transformation user selects sequential loop chooses transformation menu transformations enabled may selected transformations enabled based control flow contained selected loop transformations enabled loop loops nested within contain control flow transformations enabled contain structured control flow enabled arbitrary control flow transformation selected ped responds diagnostic transformation safe profitability estimate given effectiveness transformation additional advice suggested number iterations skew may offered well transformation unsafe warning explains makes transformation unsafe transformation inapplicable diagnostic describes transformation cannot per formed transformation applicable user decides execute user selects transformation name button fortran source dependence graph automatically updated reflect transformed code transformations divided four categories reordering transformations dependence breaking transformations memory optimizing transformations miscellaneous transformations category transformations ped currently supports briefly described 4 51 reordering transformations reordering transformations change order statements executed either within across loop iterations without violating dependence relationships transformations used expose enhance loop level parallelism program often performed concert transformations structure computations way allows useful parallelism introduced ffl loop distribution partitions independent statements inside loop multiple loops identical headers used separate statements may parallelized must executed sequentially 37 38 40 partitioning statements tuned vector parallel hardware specified user ffl loop interchange interchanges headers two perfectly nested loops changing order iteration space traversed loop interchange safe used adjust granularity parallel loops 9 38 56 4 details peds implementation several transformations appear 38 ffl loop skewing adjusts iteration space two perfectly nested loops shifting work per iteration order expose parallelism possible ped computes suggests optimal skew degree loop skewing may used loop interchange ped perform wavefront method 38 54 ffl loop reversal reverses order execution loop iterations ffl loop adjusting adjusts upper lower bounds loop constant used preparation loop fusion ffl loop fusion increase granularity parallel regions fusing two contiguous loops dependences violated 4 43 ffl statement interchange interchanges two adjacent independent statements 52 dependence breaking transformations following transformations used break specific dependences inhibit par allelism often particular dependence eliminated safe application transformations enabled course dependences carried loop eliminated loop may run parallel ffl scalar expansion makes scalar variable onedimensional array breaks output anti dependences may inhibiting parallelism 41 ffl array renaming also known node splitting 41 used break anti dependences copying source anti dependence newly introduced temporary array renaming sink new array 9 loop distribution may used separate copying statement separate loop allowing loops parallelized ffl loop peeling peels first last k iterations loop specified user useful breaking dependences arise first last k iterations loop 4 ffl loop splitting index set splitting separates iteration space one loop two loops user specifies iteration split example 1 100 split 50 following two loops result 100 loop splitting useful breaking crossing dependences dependences cross specific iteration 9 53 memory optimizing transformations following transformations adjust programs balance computations memory accesses make better use memory hierarchy functional pipelines transformations useful scalar parallel machines ffl strip mining takes loop step size 1 changes step size new user specified step size greater 1 new inner loop inserted iterates new step size minimum distance dependences loop less step size resultant inner loop may parallelized used alone order iterations unchanged used concert loop interchange iteration space may tiled 55 utilize memory bandwidth cache effectively 24 ffl scalar replacement takes array references consistent dependences replaces scalar temporaries may allocated registers 15 improves performance program reducing number memory accesses required unrolling decreases loop overhead increases potential candidates scalar replacement unrolling body loop 4 38 ffl unroll jam increases potential candidates scalar replacement pipelining unrolling body outer loop loop nest fusing resulting inner loops 15 16 38 54 miscellaneous transformations finally ped miscellaneous transformations parallel converts sequential loop parallel loop vice versa ffl statement addition adds assignment statement ffl statement deletion deletes assignment statement ffl preserved dependence indicates whether current selected dependence preserved post wait event synchronization loop ffl constant replacement performs global constant propagation procedure program using sparse conditional constant algorithm 53 variable found constant value replaced value increasing precision subsequent dependence analysis 55 example following example intended give reader flavor type transformational system consider first group nested loops figure 4 let 1 first assignment statement involving array 2 second assignment statement involving array e two loopcarried dependences 1 ffis 1 first true dependence carried loop first subscript position second true dependence e carried j loop second subscript position notice loops inhibited running parallel different dependences involved separate independent statements consider distributing loops distribution inner loop results message shown figure 4 message indicates results performing distribution loop would execution distribution results following code enddo enddo enddo unfortunately dependence 1 carried loop still inhibits loop parallelism perform distribution time outer loop figure enddo enddo enddo enddo decided distribute parallelism example even though 2 3 independent algorithm leaves together increase amount computation parallel loop selected vectorization would placed separate loops continuing example notice second loop run parallel inner j loop first nest run parallel achieve higher granularity parallelism first loop nest user interchange loops safely moving parallelism outer loop seen second loop nest figure 4 safely separated two independent statements dependences achieving two parallel loops 6 relating user changes analysis previous sections discussed users may direct parallelization process making assertions dependences variables well applying structured transforma tions section first briefly describes editing ped interaction program changes analysis examined editing fundamental program development tool flexible means making program changes therefore parascope editor integrates advanced editing features along capabilities ped supplies simple text entry templatebased editing underlying hybrid text structure editor also provides search replace functions intelligent customizable view filters automatic syntax type checking unlike transformations assertions editing causes existing dependence information unreliable result transformations dependence display disabled editing rely dependence information may date users finish editing request program reanalyzed selecting analysis button syntax type checking performed first errors reported errors dependence analysis performed peds analysis may incremental scope edit contained within loop nest insertion deletion simple assignment statement details incremental analysis edits transformations discussed elsewhere 38 purpose edit may error correction new code development rearrange existing code unlike transformations correctness preexisting source assumed ped know intent edit consequently user advised correctness edit instead new program becomes basis dependence analysis subsequent changes editing history maintained similarly transformations user performs edit whether safe unsafe included new basis however prior editing user made assertions analysis causes lost example suppose user knows value symbolic based knowledge user deletes several overly conservative dependences loop transforms parallel loop later user discovers error somewhere else program corrects substantial edit user reanalyzes program current implementation parallel loop remain parallel deleted dependences reappear experience shown annoy users result sophisticated mechanism planned 29 future edges deleted users marked rather removed dependence graph ad ditionally time date user optional usersupplied explanation recorded assertions mechanism also support general types assertions variable ranges values may affect many dependence edges records used analysis keep deleted dependences reappearing however prevent errors edits conflict assertions users given opportunity reconsider assertions may affected edit users may delay ignore opportunity mechanism assertions also available execution debugging assertion found erroneous users presented anomalies may ignored overlooked introduced 7 related work several research groups also developing advanced interactive parallel programming tools ped distinguished large collection transformations expert guidance provided transformation quality program analysis user interface briefly describe sigmacs 48 pat 50 mimdizer 1 superb 57 placing emphasis unique features sigmacs interactive emacsbased programmable parallelizer faust programming environment utilizes dependence information fetched project database maintained database server sigmacs displays dependences provides interactive program transformations work progress support automatic updating dependence information statement insertion deletion faust compute display call process graphs may animated dynamically runtime 31 node process graph represents task process separate entity running parallel faust also provides performance analysis prediction tools parallel programs pat analyze programs containing general parallel constructs builds displays statement dependence graph entire program pat program text corresponds selected portion graph perused user may also view list dependences given loop however pat analyze programs one write occurs variable loop like ped incremental dependence analysis used update dependence graph structured transformations 51 rather analyzing effects existing synchronization pat instead insert synchronization preserve specific dependences since pat compute distance direction vectors loop reordering transformations loop interchange skewing supported mimdizer interactive parallelization system shared distributedmemory machines based forge mimdizer performs dataflow dependence analysis support interactive loop transformations cray microtasking directives may output successfully parallelized loops associated tools graphically display control flow dependence profiling call graph information history transformations performed program saved user mimdizer also generate communication programs executed distributedmemory machines though designed support parallelization distributedmemory multiprocessors superb provides dependence analysis display capabilities similar ped superb also possesses set interactive program transformations designed exploit data parallelism distributedmemory machines algorithms described incremental update usedef defuse chains following structured program transformations 39 conclusions programming explicitly parallel machines much difficult sequential program ming encourage scientists use machines need provide new tools level sophistication commensurate difficulty task believe parascope editor tool permits user develop programs full knowledge data relationships program answers complex questions potential sources error correctly carries complicated transformations enhance parallelism ped improvement completely automatic systems overcomes imprecision dependence analysis inflexibility automatic parallel code generation techniques permitting user control parallelization process improvement dependence browsers supports incremental change user reviewing potential problems proposed parallelization ped also proven useful basis development several advanced tools including compiler 34 data decomposition tool 10 11 distributedmemory machines well onthefly access anomaly detection system sharedmemory machines 35 believe ped representative new generation intelligent interactive programming tools needed facilitate task parallel programming acknowledgments would like thank donald baker vasanth balasundaram paul havlak marina kalem ulrich kremer rhonda reese jaspal subhlok scott warren pfc research group many contributions work efforts made ped useful research tool today addition gratefully acknowledge contribution ir n parascope research groups provided software infrastructure upon ped built r mimdizer new parallelization tool overview ptran analysis system multiprocessing framework detecting useful parallelism catalogue optimizing transformations dependence analysis subscripted variables application program transformations automatic decomposition scientific programs parallel execution pfc program convert fortran parallel form automatic translation fortran programs vector form interactive environment data partitioning distribution static performance estimator guide data partitioning decisions technique summarizing data access use parallelism enhancing transformations dependence analysis supercomputing interprocedural dependence analysis parallelization improving register allocation subscripted variables estimating interlock improving balance pipelined machines parascope parallel programming environment interprocedural constant propa gation vectorizing compilers test suite results analysis interprocedural side effects parallel programming environment analysis event synchronization parallel programming tool static analysis lowlevel synchronization blocking linear algebra codes memory hierarchies impact interprocedural analysis optimization ir n programming environment efficient method computing static single assignment form experiences using control dependence ptran program dependence graph use optimization practical dependence testing integrated environment parallel programming experience interprocedural analysis array side effects use diagnostic dependencyanalysis tools parallel programming experiences using ptool compiler support machineindependent parallel programming fortran parallel program debugging onthe fly anomaly detection advanced tools techniques automatic parallelization structure computers computations analysis transformation programs parallel computation structure advanced retargetable vectorizer dependence graphs compiler optimizations pcf fortran language definition guidebook fortran supercomputers guide parallel programming sequent computer systems vectorizing fortran compiler sigmacs programmable programming environment empirical investigation effectiveness limitations automatic parallelization incremental dependence analysis interactive parallelization analysis synchronization parallel programming environment constant propagation conditional branches loop skewing wavefront method revisited iteration space tiling optimizing supercompilers supercomputers superb tool semiautomatic mimdsimd parallelization tr impact interprocedural analysis optimization rsupnsup programming environment interprocedural constant propagation interprocedural dependence analysis parallelization vectorizing fortran compiler program dependence graph use optimization automatic translation fortran programs vector form loop skewing wavefront method revisited practical environment scientific programming automatic decomposition scientific programs parallel execution estimating interlock improving balance pipelined architectures framework determining useful parallelism guide parallel programming sequent computer systems 2nd edition vectorizing compilers test suite results static analysis lowlevel synchronization analysis interprocedural side effects parallel programming environment overview ptran analysis system multiprocessing technique summarizing data access use parallelism enhancing transformations efficient method computing static single assignment form iteration space tiling use diagnostic dependenceanalysis tools parallel programming experiences using control dependence ptran improving register allocation subscripted variables analysis event synchronization parallel programming tool analysis transformation parascope editor static performance estimator guide data partitioning decisions parallel program debugging onthefly anomaly detection loop distribution arbitrary control flow experience interprocedural analysis array side effects practical dependence testing analysis synchronization parallel programming environment incremental dependence analysis interactive parallelization optimizing supercompilers supercomputers dependence analysis supercomputing dependence graphs compiler optimizations guidebook fortran supercomputers structure computers computations faust blocking linear algebra codes memory hierarchies constant propagation conditional branches dependence analysis subscripted variables application program transformations ctr p havlak k kennedy implementation interprocedural bounded regular section analysis ieee transactions parallel distributed systems v2 n3 p350360 july 1991 eran gabber amir averbuch amiram yehudai portable parallelizing pascal compiler ieee software v10 n2 p7181 march 1993 yang bo zheng fengzhou wang dingxing zheng weimin interactive symbolic data dependence analysis based ranges expressions journal computer science technology v17 n2 p160171 march 2002 flanagan matthew flatt shriram krishnamurthi stephanie weirich matthias felleisen catching bugs web program invariants acm sigplan notices v31 n5 p2332 may 1996 warren editor new interactive parallel programming tool proceedings 1994 conference supercomputing p733ff december 1994 washington dc united states hiranandani ken kennedy chau wen tseng scott warren editor new interactive parallel programming tool proceedings 1994 acmieee conference supercomputing november 1418 1994 washington dc ishfaq ahmad yukwong kwok minyou wu wei shu casch tool computeraided scheduling ieee concurrency v8 n4 p2133 october 2000 mary w hall ken kennedy kathryn mckinley interprocedural transformations parallel code generation proceedings 1991 acmieee conference supercomputing p424434 november 1822 1991 albuquerque new mexico united states mary w hall timothy j harvey ken kennedy nathaniel mcintosh kathryn mckinley jeffrey oldham michael h paleczny gerald roth experiences using parascope editor interactive parallel programming tool acm sigplan notices v28 n7 p3343 july 1993 gina goff ken kennedy chauwen tseng practical dependence testing acm sigplan notices v26 n6 p1529 june 1991 ken kennedy kathryn mckinley chauwen tseng analysis transformation parascope editor proceedings 5th international conference supercomputing p433447 june 1721 1991 cologne west germany thomas fahringer bernhard scholz unified symbolic evaluation framework parallelizing compilers ieee transactions parallel distributed systems v11 n11 p11051125 november 2000
write barrier removal static analysis present set static analyses removing write barriers programs use generational garbage collection knowledge first analyses purpose intraprocedural analysis uses flowsensitive pointer analysis locate variables must point recently allocated object eliminates write barriers stores objects accessed via one variables callee type extension incorporates information types objects allocated invoked methods caller context extension incorporates information recently allocated object call sites invoke currently analyzed method results implemented system show full interprocedural analysis incorporates extensions eliminate majority write barriers programs benchmark set producing modest performance improvements 7 overall execution time moreover dynamically instrumenting executable able show two nine benchmark programs analysis close optimal sense eliminates write barriers almost store instructions observed create reference older object younger object b introduction generational garbage collectors become memory management alternative choice many safe languages basic idea behind generational collection segregate objects dierent generations based age gen research supported part nsf fellowship darpa contract f3361500c1692 nsf grant ccr00 86154 nsf grant ccr0063513 erations containing recently allocated objects typically collected frequently older generations young objects age surviving collections collector promotes older generations generational collectors therefore work well programs allocate many shortlived objects longlived objects promoting longlived objects older generations enables garbage collector quickly scan objects younger generations scans generation collector must locate references generation older generations write barriers standard way locate references every instruction stores heap reference object compiler inserts code updates intergenerational reference data structure data structure enables garbage collector nd references objects older generations objects younger generations use references roots collections younger gen erations write barrier overhead traditionally accepted part cost using generational collector paper presents set new program analyses enables compiler statically eliminate write barriers instructions never create reference object older generation object younger generation basic idea use pointer analysis locate store instructions always write recently allocated ob ject object youngest object store instruction never create reference older object younger object write barrier instruction therefore super uous transformation eliminates 1 implemented several analyses use basic approach write barrier elimination intraprocedural analysis analysis analyzes method separately methods uses owsensitive intraprocedural pointer analysis nd variables must refer recently allocated object method entry analysis conservatively assumes variable points recently allocated object method invoca analysis assumes recently allocated object always allocated youngest generation cases may desirable allocate large objects older gener ations straightforward extension analysis would statically identify objects might allocated older generations suppress write barrier elimination stores write objects tion site analysis also conservatively assumes variable refers recently allocated object callee type extension extension augments intraprocedural analysis information invoked methods nds variables refer object recently allocated within currently analyzed method methodyoungest object also tracks types objects allocated invoked method program point extracts pair set variables refer methodyoungest object set types objects potentially allocated methods invoked since methodyoungest object allocated store instruction writes reference object methodyoungest object c supertype type transformation eliminate write barrier methodyoungest object younger object caller context extension extension augments intraprocedural analysis information pointsto information call sites may invoke currently analyzed method receiver object currently analyzed method recently allocated object possible call sites algorithm assume variable refers recently allocated object entry point currently analyzed method full interprocedural analysis combines callee type extension caller context extension obtain analysis uses type information callees pointsto information callers experimental results show set benchmark programs full interprocedural analysis often able eliminate substantial number write barriers producing modest overall performance improvements 7 reduction total execution time moreover instrumenting benchmarks dynamically observe age source target objects store instruction able show two nine bench marks analysis able eliminate write barriers virtually store instructions create reference older object younger object execution default input benchmark suite words analysis basically optimal benchmarks finally optimality requires information calling context called methods neither callee type extension caller context extension able eliminate signicant number write barriers paper provides following contributions write barrier removal identies write barrier removal eective means improving performance programs use generational garbage collection analysis algorithms presents several new static analysis algorithms enable compiler automatically remove unnecessary write barriers class treenode treenode left treenode right integer depth static public void mainstring arg void linkdepthint new void linktreetreenode l treenode r int 1 linkdepthd 2 right static treenode buildtreeint new treenode return figure 1 binary tree example best knowledge rst algorithms use program analysis eliminate write barriers experimental results presents complete set experimental results characterize eectiveness analyses set benchmark programs results show full interprocedural analysis able remove majority write barriers programs benchmark suite producing modest performance benets 7 reduction total execution time remainder paper structured follows section presents example illustrates algorithm works used remove unnecessary write barriers section 3 presents analysis algorithms discuss experimental results section 4 related work section 5 conclude section 6 2 example figure presents binary tree construction example addition left right elds implement tree structure tree node also depth eld refers integer object containing depth subtree rooted node example main method invokes buildtree method calls recursively create left right subtrees creating root treenode linktree method links left right subtrees current node invokes linkdepth method allocate integer object holds depth link new object tree focus two store instructions generated lines 1 2 figure store instructions link left right subtrees receiver linktree method absence information relative ages three objects involved left tree node right tree node receiver implementation must conservatively generate write barriers store operation particular program write barriers super uous receiver object always younger left right tree nodes program example common pattern many objectoriented programs program allocates new object immediately invokes method initialize object write barriers often unnecessary assignments object initialized often recently allocated object 2 example analysis allows compiler omit unnecessary write barriers follows analysis rst determines call sites invoke linktree method receiver object linktree recently allocated object analyzes linktree method information since allocations occur entry point linktree method store instruction line 1 receiver object remains recently allocated object write barrier store instruction safely removed lines 1 2 linktree method invokes linkdepth method allocates new integer object hold depth call linkdepth receiver object longer recently allocated object analysis linktree method algorithm tracks types objects invoked method may create line 2 analysis records fact receiver referred recently allocated object linktree method invoked linktree method allocated new objects far linkdepth method called linktree method allocates integer objects store instruction line creates reference receiver object treenode object treenode superclass integer referred treenode object must existed linktree method started execution receiver recently allocated object point store instruction line 2 creates reference object least old receiver write barrier line 2 therefore super uous safely removed 3 analysis analysis following structure consists purely intraprocedural framework two interprocedural extensions rst extension call callee type extension incorporates information called meth ods second extension call caller context extension incorporates information calling context two extensions applied separately combination set four analyses given table 2 2 note even common case constructors initialize recently allocated object receiver constructor may recently allocated object object allocation initialization separate operations java bytecode object allocations may occur object allocated initialized callee caller type extension context extension callee yes caller full interprocedural yes yes figure 2 four analyses remainder section structured follows present analysis features section 31 program representation section 32 section 33 present intraprocedural analysis present callee analysis section 34 caller analysis section 35 section 36 present full interprocedural analysis finally section 37 describe analysis results used remove unnecessary write barriers 31 analysis features analyses owsensitive forward data ow analyses compute must pointsto information progam point precise nature computed data ow facts depends analysis general analyses work set variables v must point object recently allocated current method optionally set types objects allocated invoked methods 32 program representation rest paper use v v0 v1 denote local variables m0 m1 denote methods c c0 denote types statements relevant analyses follows object allocation statement move statement call statement given form rst parameter call v1 points receiver object method instance method 3 assume preceding stage compiler constructed control ow graph method call graph entire program use entry denote entry point method statement st program predst set predecessors st control ow graph use st denote program point immediately st st denote program point immediately st program point p form st st denote ap information computed analysis program point use callersm denote set call sites may invoke method 33 intraprocedural analysis simplest set analyses intraprocedural analysis owsensitive forward data ow analysis generates program point set variables must point recently allocated object known mobject call variable points mobject mvariable property lattice pvar powerset set 3 java instance method nonstatic method assignment v v n fvg statements v figure 3 transfer functions intraprocedural analysis variables var normal set inclusion ordering lation var set program variables operator used combine data ow facts control ow merge points usual set intersection operator u figure 3 presents transfer functions analysis case allocation statement c new object clearly becomes recently allocated object since v variable pointing newlyallocated object transfer function returns singleton fvg call statement transfer function returns since absence interprocedural information analysis must conservatively assume called method may allocate number type objects move source move v2 mvariable destination move v1 becomes mvariable transfer function therefore returns union current set mvariables singleton fvg move statement source move mvariable type assignment ie load eld static eld destination move may mvariable move transfer function therefore returns current set mvariables less destination variable statements leave set mvariables unchanged analysis result satises following equations st entry ufast st rst equation states analysis result program point immediately st st entry point method otherwise result meet analysis results program points immediately predecessors st want compute set variables denitely point recently allocated object use meet operator set intersection second equation states analysis result program point immediately st obtained applying transfer function st analysis result program point immediately st analysis starts set mvariables initialized empty set entry point method full set variables var top element property lattice program points uses iterative algorithm compute greatest xed point aforementioned equations subset inclusion 34 callee analysis callee type extension builds upon framework intraprocedural analysis extends using information types objects allocated invoked methods extension stems following observation intraprocedural analysis loses information call sites must conservatively assume invoked method may allocate number type objects callee type extension allows us retain information across call computing summary information types objects invoked methods may allocate callee type extension relaxes notion mobject intraprocedural analysis mobject simply recently allocated object callee type extension mobject object recently allocated statement currently analyzed method analysis computes program point tuple containing variable set v type set variable set v contains variables point mobject mvariables type set contains types objects may allocated methods invoked since allocation mobject property lattice var set program variables types set types used program ordering relation lattice corresponding meet operator top element lattice fact cartesian product lattices two lattices dierent ordering relations elements different meanings must information may information figure 4 presents transfer functions callee analysis except call statements transfer functions treat variable set component tuple way intraprocedural analysis call statements unanalyzable methods example native methods transfer function produces conservative approximation h call statements transfer function returns variable set unchanged adds type set types objects may allocated call due dynamic dispatch method invoked st may one set methods obtain call graph using auxiliary function calleesst determine types objects allocated particular method use another auxiliary function allocated types set types may allocated call st simply union result allocated types function applied component set calleesst transfer function modies type set st allocated typesm assignment v hv n fvg statements hv figure 4 transfer functions callee analysis allocation statement returns second component tuple callees function obtained directly program call graph allocated types function eciently computed using simple owinsensitive analysis determines least xed point equation given figure 5 analysis solves data ow equations figure 4 using standard work list algorithm starts entry point method initialized h program points initialized top element hvar computes greatest xed point equations solution 35 caller analysis caller context extension stems observation intraprocedural analysis information mobject entry point method caller context extension augments analysis determine mobject always receiver currently analyzed method analyzes method variable element set variables v must point mobject entry point method caller context extension property lattice associated ordering relation meet operator intraprocedural analysis figure 6 presents additional data ow equation denes data ow result entry point method equation basically states receiver object method object call sites may invoke method variable refers mobject start method note class static methods receiver v always start methods straightforward extend treatment handle call sites mobject passed parameter receiver within stronglyconnected components call graph analysis uses xed point algorithm compute greatest xed point combined interprocedural intraprocedural equations initializes analysis fthisg method entry point var program points within stronglyconnected component iterates xed point stronglyconnected components algorithm simply propagates caller context information topdown fashion stronglyconnected component analyzed components contain methods may invoke 36 full interprocedural analysis full interprocedural analysis combines callee type extension caller context extension transfer functions callee analysis given table 4 likewise property lattice associated ordering relation meet operator callee analysis analysis result entry point method however subject equation given figure 7 extension analysis recognize use hfthisg analysis result entry point entry method call sites may invoke receiver object method mobject type set note expand denition safe method additionally propagate type set information calling context called method like algorithm caller analysis algorithm full interprocedural analysis uses xed point algorithm within stronglyconnected components propagates caller context information topdown fashion components initializes analysis algorithm compute greatest xed point data ow equations 37 use analysis results easy see results intraprocedural analysis used remove unnecessary write barriers since mvariable must point recently allocated ob ject write barrier removed store object pointed mvariable since reference created must point younger object older one results caller analysis used way less obvious analysis results used callee type extension applied since results include type set addition variable set consider store form v1 analysis result computed program point immediately store v1 2 v v1 must point mobject object allocated recently mobject must type c c 2 actual ie dynamic type object pointed v2 included object v2 points must older object v1 points write barrier associated allocated st st call allocated typesm j ac c c c c figure 5 equation allocated types function aentry instance method st 2 callersm v1 2 v st form figure equation entry point method caller analysis store therefore removed v1 2 v type v2 ancestor type note v2 62 sucient condition since static type v2 may dierent dynamic type analysis results used way whenever callee type extension applied ie callee full interprocedural analyses 4 experimental results next present experimental results characterize eectiveness optimization general full interprocedural analysis able remove majority write barriers applications applications execute many write barriers per second optimization deliver modest performance benets 7 overall execution time synergistic interaction callee type extension caller context extension general analysis must use extensions remove signicant number write barriers 41 methodology implemented four write barrier elimination analyses mit flex compiler system aheadoftime compiler java programs written java system including implemented analyses available gnu gpl wwwflexclcsmitedu flex runtime uses copying generational collector two generations nursery tenured generation uses remembered sets track pointers tenured generation nursery 18 1 remembered set implementation uses statically allocated array store addresses created references write barrier therefore executes store next free element array increments pointer element manually tuning size array characteristics applications able eliminate array ow check would otherwise necessary implementation 4 present results analysis running java ver 4 write barriers therefore somewhat ecient would general system designed execute arbitrary programs apriori information behavior program sion olden benchmarks 6 5 benchmark set contains following applications implementation barneshut nbody solver 2 bisort implementation bitonic sort 4 em3d models propagation electromagnetic waves objects three dimensions 8 simulates healthcare system colombia 15 mst computes minimum spanning tree graph using bentleys algorithm 3 perimeter computes total perimeter region binary image represented quadtree 17 power maximizes economic eciency community power consumers 16 treeadd sums values nodes binary tree using recursive depthrst traversal tsp solves traveling salesman problem 14 voronoi computes voronoi diagram random set points 9 include results tsp uses nonde terministic probabilistic algorithm causing number barriers executed vastly dierent run executable addition three benchmarks bh power treeadd modied benchmarks construct mathvector leaf treenode data structures respectively bottomup instead topdown manner present results following compiler options baseline optimization writes heap associated write barriers aentry instance method st 2 callersm v1 2 v hv st form figure 7 equation entry point method full interprocedural analysis intraprocedural intraprocedural analysis described section 33 callee analysis described section 34 uses information types objects allocated invoked methods caller analysis described section 35 uses information contexts method invoked specically analysis determines receiver analyzed method always recently allocated object exploits fact analysis method full interprocedural analysis described section 36 uses information types objects allocated invoked methods contexts analyzed method invoked caller full interprocedural analyses view dynamically dispatched calls analyzable transfer functions call sites conservatively set analysis information h explained section 44 including allocation information call sites sig nicantly increases analysis times provides corresponding increase number eliminated write barriers application analyses used mit flex compiler generate two executables instrumented executable counts number executed write barriers uninstrumented executable without counts versions except baseline version compiler uses analysis results eliminate unnecessary write barriers ran executables 900mhz intel pentiumiii cpu 512mb memory running redhat linux 62 used default input parameters java version olden benchmark set application given table 13 42 eliminated write barriers figure 8 presents percentage write barriers dierent analyses eliminated bar version application bar plots 1 wwb 100 w number write barriers dynamically executed corresponding version program wb number write barriers executed baseline version program bh health perimeter treeadd full interprocedural analysis eliminated 80 write barriers eliminated less 20 bisort em3d note synergistic interaction occurs exploiting information called methods calling context applications except health caller callee versions analysis able eliminate write barriers combined full interprocedural analysis many cases analysis able eliminate vast majority write barriers bh bisort em3d health mst perimeter power treeadd voronoi full interprocedural caller callee intraprocedural 0 20 40 80 100 percentage decrease write barriers executed figure 8 percentage decrease write barriers execute evaluate optimality analysis used mit flex compiler system produce version application write instruction instrumented determine current execution program write instruction ever creates reference older object younger object instruction ever creates reference write barrier denitely necessary cannot removed agebased algorithm whose goal eliminate write barriers associated instructions always create references younger objects older objects two possibilities store instruction never creates reference older object younger object 1 regardless input store instruction never create reference older object younger object case write barrier statically moved even though store instruction create reference older object younger object current execution may executions inputs case write barrier cannot statically removed figure 9 presents results experiments present one bar application divide bar three categories unremovable write barriers percentage executed write barriers instructions create reference older object younger object removed write barriers percentage executed write barriers full interprocedural anal0103050709bh bisort em3d health mst perimeter power treeadd voronoi proportion dynamicwrite barriers unremovable removed potentially removable figure 9 write barrier characterization ysis eliminates potentially removable rest write barri ers ie percentage executed write barriers full interprocedural analysis failed eliminate instructions never create reference older object younger object run input set results show two applications analysis almost optimal sense managed eliminate almost write barriers eliminated agebased write barrier elimination scheme 43 execution times ran version application without instrumen tation four times measuring execution time run times reproducible see figure 15 raw execution time data standard deviations figure presents mean execution time version application execution time normalized mean execution time baseline version general benets rather modest optimization producing overall performance improvements 7 six applications obtain signicant benet optimiza tion even though analysis managed remove vast majority write barriers applications figure 11 presents write barrier densities dier ent versions dierent applications write barrier density simply number write barriers executed per second ie number executed write barriers divided execution time program numbers clearly show obtain signicant benets write barrier elimination two things must occur 1 baseline version application must high write barrier density 2 analysis must eliminate write barriers 44 analysis times figure 12 presents analysis times dierent applications analyses include full dynamic interprocedural analysis table version analysis includes callee allocated type information call091093095097099bh bisort em3d health mst perimeter power treeadd voronoi normalized execution time intraprocedural callee caller full interprocedural figure 10 normalized execution times benchmark programs benchmark write barrier density write barrierss bisort 4769518 em3d 773375 health 624960 mst 1031059 perimeter 2053484 power 3286 treeadd 955755 figure 11 write barrier densities baseline version benchmark programs sites dynamic dispatch multiple potentially invoked methods times indicate including dynamically dispatched call sites signicantly increases analysis times including sites signi cantly improve ability compiler eliminate write barriers however since full interprocedural analysis already nearly optimal seven nine benchmark programs 45 discussion experimental results show many benchmark programs analysis able remove substantial number write barriers performance improvement removing write barriers depends inherent barrier density application larger barrier density larger performance improve ment performance impact optimization clearly vary based performance characteristics particular execution platform optimization produces modest performance increases platform instrumenting application nd store instructions analysis time full full dynamic benchmark intraprocedural callee caller interprocedural interprocedural bh bisort em3d health mst perimeter power treeadd voronoi figure 12 analysis times dierent analysis versions create reference older object younger object able obtain conservative upper bound number write barriers agebased write barrier elimination algorithm would able eliminate results show two cases algorithm achieves upper bound anticipate future analyses transformations focus changing object allocation order expose additional opportunities eliminate write barriers general may nontrivial task automate since may involve hoisting allocations several levels call graph even restructuring application change allocation strategy entire data structure 5 related work vast body literature dierent approaches write barriers generational garbage collection comparisons techniques found 19 12 13 several researchers investigated implementation techniques ecient write barriers 7 10 11 goal reduce write barrier overhead view techniques orthogonal complementary goal analyses reduce time required execute write barrier nd super uous write barriers simply remove program best knowledge algorithms rst use program analysis remove unnecessary write barriers 6 conclusion write barrier overhead traditionally unavoidable price one pays use generational garbage collec tion results paper show possible develop relatively simple interprocedural algorithm many cases eliminate write barriers program key ideas use intraprocedural must pointsto analysis nd variables point recently allocated object extend analysis information types objects allocated invoked methods information must pointsto relationships calling contexts incorporating two kinds information produces algorithm often eectively eliminate virtually unnecessary write barriers benchmark input parameters used bh bisort 250000 numbers em3d 2000 nodes outdegree 100 health 5 levels 500 time steps mst 1024 vertices perimeter power 10000 customers treeadd 20 levels voronoi 20000 points figure 13 input parameters used java version olden benchmarks 7 acknowledgements c scott ananian implemented flex compiler infrastructure analysis implemented many thanks alexandru salcianu help formalizing analyses 8 r simple generational collection fast allocation hierarchical log n force calculation algorithm parallel algorithm constructing minimum spanning trees adaptive bitonic sorting optimal parallel algorithm sharedmemory machines data ow analysis software prefetching linked data structures java software caching computation migration olden design implementation self compiler parallel programming splitc remembered sets also play cards garbage collection algorithms automatic dynamic memory management probabilistic analysis partitioning algorithms travelingsalesman problem plane performance study time warp decentralized optimal power pricing development parallel program computing perimeters regions images represented quadtrees generational scavenging nondisruptive high performance storage reclamation algorithm barrier methods garbage collection tr adaptive bitonic sorting optimal parallel algorithm sharedmemory machines simple generational garbage collection fast allocation comparative performance evaluation write barrier implementation design implementation self compiler optimizing compiler objectoriented programming languages decentralized optimal power pricing parallel programming splitc software caching computation migration olden garbage collection data flow analysis software prefetching linked data structures java generation scavenging
loop shifting loop compaction idea decomposed software pipelining decouple software pipelining problem cyclic scheduling problem without resource constraints acyclic scheduling problem resource constraints terms loop transformation code motion technique formulated combination loop shifting loop compaction loop shifting amounts moving statements iterations thereby changing loop independent dependences loop carried dependences vice versa loop compaction schedules body loop considering loop independent dependences taking account details target architecture paper show loop shifting optimized minimize length critical path number dependences loop compaction first problem wellknown solved algorithm due leiserson saxe show second optimization combination first one also polynomially solvable fast graph algorithm variant minimumcost flow algorithms finally analyze improvements obtained loop compaction experiments random graphs b introduction modern computers exploit parallelism instruction level microprocessor sequential microprocessor anymore simple unit processes instructions following unique stream processor may multiple independent functional units pipelined possibly nonpipelined take advantage parallel functionalities processor sucient exploit instructionlevel parallelism inside basic blocks feed functional units may necessary consider schedule instructions one basic block finding ways extract instructionlevel parallelism ilp led large amount research hardware software perspective see example 12 chap 4 overview hardware solution problem provide support speculative execution control done superscalar architectures andor support predicated execution example ia64 architecture 8 software solution schedule statements across conditional branches whose behavior fairly predictable loop unrolling trace scheduling eect also software pipelining technique loop branches loops scheduled iteration softwarepipelined code made instructions belong dierent iterations original loop software pipelining nphard problem resource limited reason huge number heuristic algorithms proposed following various strategies comprehensive survey available paper allan et al 2 classify algorithms roughly three dierent categories modulo scheduling 16 24 variations 23 13 18 quote kernel recognition algorithms 1 21 movethenschedule algorithms 14 19 5 briey speaking ideas dierent types algorithms following modulo scheduling algorithms look solution cyclic allocation resources every clock cycles resource usage repeat algorithm thus looks schedule compatible allocation modulo given called initiation interval value incremented solution found kernel recognition algorithms simulate loop unrolling scheduling pattern appears means point schedule would cyclic pattern form kernel softwarepipelined code movethenschedule algorithms use iterative scheme alternatively schedules body loop loop compaction moves instructions across backedge loop long improves schedule goal paper explore deeply concept movethenschedule algorithms particular see moving instructions help loop compaction explained b rau 22 although code motion yield improvements schedule always clear operations moved around back edge direction many times get best results close gets practice optimal studied fact approach even notion optimal dened following ideas developed decomposed software pipelining 9 27 4 show nd directly one preprocessing step good 1 loop shifting ie move statements across iterations loop compaction likely improved general idea twostep heuristic decomposed software pipelining decouple software pipelining problem cyclic scheduling problem without resource constraints nding loop shifting acyclic scheduling problem resource constraints loop compaction rest paper organized follows section 2 recall software pipelining problem wellknown results problem complexity lower bounds initiation interval etc section 3 explain combining loop shifting loop compaction give better performance loop compaction alone loop shifting changes loop independent dependences loop carried dependences vice versa loop compaction schedules body loop considering loop independent dependences taking account details target architecture rst optimization shift statements minimize critical path loop compaction done 4 using algorithm due leiserson saxe second optimization minimize number constraints loop compaction ie shift statements remain loop independent edges possible optimization main contribution paper presented full details section 4 section 5 discusses limitations technique think could overcome future 2 software pipelining problem mentioned section 1 goal determine context movethenschedule software pipelining algorithms move statements make loop compaction ecient thus need able discuss optimality performances relative optimum need model loops considering model architecture targeting simple enough optimality discussed simplied models presented section 21 summarize theoretical point view assume simple loop ie conditional branches 2 constant dependence distances nite number put good quotation marks technique remains course heuristic loop compaction npcomplete case resource constraints optimality arbitrary loops general easy discuss shown schwiegelshohn et al 25 non pipelined homogeneous functional units despite simplied model algorithm still used practice sophisticated resource models even theoretical guarantee give longer true indeed loop shifting technique develop rst phase process depend architecture model dependence constraints shifts statements critical path number constraints loop compaction minimized resource constraints taken account second phase algorithm compacting loop specic aggressive instruction scheduler used task handling conditional branches however considered yet although movethenschedule algorithms usually capability 19 27 thus explore future feature integrated shifting technique could also rely predicated execution modulo scheduling algorithms 21 problem formulation consider problem scheduling loop possibly large number iterations loop represented nite vertexweighted edgeweighted directed multigraph w vertices v model statements loop body v 2 v represents set operations one iteration loop statement v delay latency directed edges e model dependence constraints edge weight 2 n dependence distance expresses fact operation u instance statement u iteration k must completed execution operation instance statement v iteration k terms loops edge e corresponds loop independent dependence loop carried dependence otherwise loop independent dependence always directed statement u statement v textually loop body thus g corresponds loop circuit c zero weight wc 6 0 goal determine schedule operations v k ie function respects dependence constraints resource constraints p non pipelined homogeneous resources available p operations processed clock cycle performance schedule measured average cycle time dened among schedules schedules exhibit cyclic pattern particularly interesting cyclic schedule schedule v n schedule period pattern computations occurs every units time within period one one instance statement initiated reason called initiation interval literature also equal average cycle time schedule 22 lower bounds average cycle time complexity results average cycle time schedule cyclic limited resource dependence constraints denote 1 resp p minimal average cycle time achievable schedule cyclic innitely many resources resp p resources course p 1 circuit c denote c duration distance ratio wc let following wellknown lower bounds dependence constraints 1 max resource constraints p resource constraints scheduling problem polynomially solvable indeed max optimal cyclic schedule possibly fractional initiation interval 1 integral schedule found standard minimum ratio algorithms 10 pp 636 641 complexity ojv jjej logjv j look max look max e karps minimum meanweight cycle algorithm 15 used complexity ojv jjej resource constraints however decision problem associated problem determining schedule minimal average cycle time nphard open whether belongs np restricting cyclic schedules problem npcomplete see 11 overview cyclic scheduling problem 3 loop shifting loop compaction section explain loop shifting used improve performances loop compaction rst formalize loop compaction study performances cyclic schedules obtained loop compaction alone 31 performances loop compaction alone loop compaction consists scheduling body loop without trying mix iterations general principle following consider directed graph ag captures dependences lying within loop body words loop independent dependences correspond edges e graph ag acyclic since g circuit c thus scheduled using techniques directed acyclic graphs example list scheduling new pattern built loop body repeated dene cyclic schedule whole loop resource constraints dependence constraints respected inside body list scheduling resource constraints dependence constraints dierent iterations respected fact patterns overlap algorithm following algorithm 1 loop compaction w dependence graph 1 dene 0g 2 perform list scheduling ag 3 compute makespan 4 dene cyclic schedule 8v 2 v 8k 2 n v dependence constraints loop compaction limited critical paths ie paths p maximal delay dp denote g maximal delay path ag whatever schedule chosen loop compaction cyclic schedule satises g furthermore list scheduling used comans technique 6 shows path p ag related optimal initiation intervals 1 p know acyclic scheduling problem g lower bound makespan schedule thus list scheduling heuristic worstcase performance ratio 2 1p unfortunately g priori nothing minimal average cycle time p reason loop compaction alone arbitrarily bad goal mix iterations loop shifting see following section resulting acyclic graph ag subgraph loop independent dependences likely optimized loop compaction 32 loop shifting rst dene loop shifting formally loop shifting consists following transformation dene statement v shift rv means delay operation v rv iterations words instead considering vertex graph g represents operations form v k consider represents operations form v k rv new dependence distance w r e edge since dependence u k ru v k denes transformed graph g w r note shift change weight circuits circuits c two operations dependence computed dierent iterations transformed code w r e 0 two operations computed original order dependence loop carried dependence w r operations computed iteration place statement corresponding u textually statement corresponding v preserve dependence loop independent dependence reordering always possible since transformed graph g circuit g g r circuit weights w r e 0 loop shifting legal note g r g two representations problem indeed onetoone correspondence schedules g schedules g r r schedule g r function dened v rv schedule g words reasoning g r change representation cannot prevent us nd schedule dierence original code shifted code due loop bounds shifted code typically standard loop plus prologue epilogue see example section 43 function r called legal retiming context synchronous vlsi circuits 17 vertex v represents operator delay dv weight edge e interpreted number registers retiming amounts suppress ru registers weight edge leaving u add rv registers edge entering v constraint means negative number registers allowed legal retiming graph ag used loop compaction algorithm 1 graph edges without register called g largest delay path without register called clock period circuit link loop shifting circuit retiming new used several algorithms loop transformations see example 5 3 4 7 including software pipelining 33 selecting loop shifting loop compaction select good shifting loop compaction let us rst consider strategies followed dierent movethenschedule algorithms enhanced software pipelining extensions 19 circular software pipelining 14 rotation software pipelining 5 use similar approaches loop compaction shift backwards forwards vertices appear beginning resp end loop body schedule words candidates backwards shifting ie sources ag candidates forwards shifting ie sinks ag rotation performed long benets schedule guarantee given technique decomposed software pipelining principle slightly dierent algorithm iterative process uses loop shifting loop compaction alternately loop shifting chosen following mathematically welldened objective loop scheduled two intuitive objectives may shift statements minimize maximal delay g path ag since tightly linked guaranteed bound list scheduling shown section 31 lower bound performances loop compaction reducing g reduces performance upper bound list scheduling used number edges acyclic graph ag reduce number dependence constraints loop compaction intuitively fewer constraints freedom exploiting resources eort put rst objective 9 27 loop rst software pipelined assuming unlimited resources cyclic schedule obtained corresponds particular retiming r used compacting loop shown technique maximal critical path ag r less 4 shift chosen critical path loop compaction minimal using retiming algorithm due leiserson saxe 17 clockperiod minimization see algorithm 2 derived retiming r g r opt minimum achievable clock period g also shown techniques lead similar guaranteed performances non pipelined resources indeed performances loop compaction see equation 2 become unlike loop compaction alone critical path ag r related p performances arbitrarily bad loop compaction alone techniques however limited fact optimize retiming critical parts graph example situation see section 41 reason cannot address second objective trying retime graph dependences possible loop independent 4 integer linear programming formulation proposed solve problem show next section pure graphtheoretic approach possible calland et al suspected let us recall algorithm leiserson saxe technique use binary search determining minimal achievable clock period opt test whether potential clock period feasible following ojv jjej algorithm used produces legal retiming r g g r synchronous circuit clock period g r retiming exists overall complexity ojv jjej log jv j algorithm 2 feasible clock period 1 vertex set rv 0 2 repeat following times compute graph g r existing values r b vertex v 2 v compute v maximum sum dp vertex delays along zeroweight directed path p g r leading v c vertex v v set rv rv 1 3 run algorithm used step 2b compute g r g r feasible retiming exists otherwise r desired retiming 4 minimizing number dependence constraints loop com paction deal problem nding loop shifting number dependence constraints loop compaction minimized rst consider particular case dependence constraints removed section 41 give algorithm either nds retiming proves retiming exists section 42 heart paper give algorithm minimizes retiming number zeroweight edges graph section 43 run complete example illustrate technique finally section 44 extend algorithm minimize number zeroweight edges without increasing clock period given constant instance minimal clock period allows us combine objectives proposed section 33 applying loop shifting minimize number constraints critical path loop compaction 41 particular case fully parallel loop body rst give example illustrates minimizing number constraints loop compaction may useful example also case constraints removed example 1 i1n dependence graph example represented figure 1a assume execution time two cycles loads one cycle addition three cycles multiplication multiplication minimal clock period cannot less 3 figure 1b depicts retimed graph clock period 3 retiming values found run leiserson saxe algorithm algorithm 2 figure 1c represents graph obtained minimizing number zeroweight edges still clock period 3 load load d3a load load b load load 11c figure 1 dependence graph example 1 b clock period minimization c loopcarried dependence minimization b c ls alu ls alu ls alu cycles load load load load load load figure 2 loop compaction example 1 b clock period minimization c loopcarried dependence minimization following principle decomposed software pipelining retiming shift found schedule subgraph generated zeroweight edges compaction order nd pattern loop body assume limits resources schedule given one loadstore unit two alus see figure 2a simple compaction without shift gives bad result initiation interval 8 since constraints impose sequential execution operations clock period minimization figure 2b multiplication longer executed addition signicant improvement found still limited single loadstore resource associated two loop independent dependences constrain addition wait serial execution two loads initiation interval 5 finally minimization loopcarried dependences figure 2c constraints loop compaction except resource constraints get optimal result initiation interval equal 4 improved two loads single loadstore resource example resources kept busy time note assume pipelined resources fetch one instruction cycle delays latency get similar results see figure 3 corresponding initiation interval respectively 7 5 3 try initiate next iteration complete end previous one 3 4 3 overlap patterns see section 5 mean overlapping b c ls alu ls alu ls alu load load load cycles load load load figure 3 loop compaction example 1 pipelined resources b clock period minimization c loopcarried dependence minimization example 1 easy case solve possible remove constraints loop compaction retiming loop body fully parallel case compaction phase reduced problem scheduling tasks without precedence constraints though np complete easier guaranteed heuristics better performance ratio list scheduling exist formally say body loop fully parallel possible shift loop dependences become loop carried let lc length number edges circuit c graph g following proposition gives simple ecient way nd retiming makes body fully parallel proposition 1 shifting loop dependence graph g loop fully parallel body possible wc lc circuits c g proof assume rst g retimed loop fully parallel body exists retiming r 8e 2 e w r e 1 summing inequalities circuit c g get w r c lc since weight circuit unchanged retiming get conversely assume circuits c g wc lc graph g dened 8e 2 e w circuit negative weight thus dene vertex u u minimal weight path leading u construction weight path leading v words desired retiming proposition 1 deduce algorithm nds retiming g loop body fully parallel answers retiming found algorithm 3 fully parallel body adding new source g setting apply bellmanford algorithm g 0 nd shortest path vertex v two cases occur bellmanford algorithm nds circuit negative weight case return false bellmanford algorithm nds values u vertex u g 0 case set return true complexity algorithm dominated complexity bellmanford algorithm ojv jjej also notice graph acyclic directed graph always retimed loop fully parallel body since contain circuit consequently circuit negative weight g 0 case algorithm simplied simple graph traversal instead complete bellmanford algorithm leading 42 zeroweight edges minimization general case since cannot always make loop body fully parallel must nd another solution minimize constraints loop compaction give pure graph algorithm nd retiming edges possible edges register ie many dependences possible loopcarried loop shifting algorithm adaptation minimal cost ow algorithm known outofkilter method 10 pp 178185 proposed fulkerson 1961 421 problem analysis given dependence graph retiming r g dene previous sections retimed graph g edge want count number edges e w r dene cost v r e edge e follows dene cost retiming r number zeroweight edges retimed graph say r optimal r e minimal ie r minimizes number zeroweight edges g rst give lower bound cost retiming show nd retiming achieves bound use ows g dened functions f nonnegative ow ow 8e 2 e fe 0 ow f corresponds union cycle multicycle c f traverses fe times edge e fe 0 edge used forwards fe 0 edge backwards ow nonnegative ow corresponds union circuits multicircuit 10 p 163 given legal retiming r given nonnegative ow f dene edge e 2 e kilter index kie easy check kilter index always nonnegative since v r since ow nonnegative show proposition 4 kilter indices zero found optimal retiming need independence property related ows retimings dene cost ow f graph g r course cost ow depends edges c f ie edges e fe 6 0 following proposition shows cost ow depend retiming ie cost f g g r equal proposition 2 proof fea since f ow ready give lower bound cost retiming proposition 3 legal retiming r nonnegative ow g proof 1 fewe since 8e 2 e v r e 0 v r prop 2 0 since 8e 2 e kie 0 proposition 4 let r legal retiming ow f 8e 2 e optimal proof edge g v r proposition 3 proposition 4 alone show lower bound achieved remains show nd retiming ow kilter indices zero study happens characterizing edges terms kilter index 422 characterization edges us represent edges e pair fe w r e get diagram figure 4 called kilter diagram edges e correspond black angled line line kie 0 call conformable edges non conformable edges kie 0 assign type edge e depending values w r e fe follows type 1 w r e 1 type 3 w r type 4 w r type type 7 w r conformable edges type 2 w r e 0 fe 1 w r e 1 fe 0 type 5 w r non conformable edges every edge conformable edge e optimal reached furthermore notice conformable edge e possible modify one unit either w r e fe keeping conformable non conformable edge possible decrease strictly kilter index changing either w r e fe one unit precisely following cases fe increases edges types 3 6 7 become respectively type 4 7 7 remain conformable edge type 5 becomes conformable type 6 kilter index edge increases strictly fe decreases edges type 4 7 become respectively type 3 6 7 remain conformable edge type 2 becomes conformable type 4 1 kilter index decreases strictly kilter index edges type 6 increases strictly increases edges type 1 3 6 become respectively type 1 1 4 remain conformable edge type 5 becomes conformable type 3 kilter index edge increases strictly decreases edges type 1 4 become respectively type 1 3 6 remain conformable edge type 2 becomes conformable type 4 7 kilter index decreases strictly kilter index edges type 3 increases strictly going exploit possibilities order converge towards optimal solution successive modications retiming ow type 7 type 6 fe1r figure 4 kilter diagram edge types black black black red green uncoloured green figure 5 coloration dierent types edges 423 algorithm algorithm starts feasible initial solution makes evolve towards optimal solution null retiming null ow respectively legal retiming feasible ow edge e 2 e means kilter index equal 1 zeroweight edge 0 edge notice solution edge type 1 3 5 edges type 5 non conformable problem make kilter index type 5 edges decrease without increasing kilter index edge realize assign type edge color see figure 5 expresses degree freedom allows black edges type 3 5 6 fe w r e increase green edges type 2 4 fe w r e decrease red edges type 7 fe increase decrease w r e kept constant uncoloured edges type 1 fe cannot changed w r e increase decrease note actually algorithm take account green edges longer indeed start solution involve edges make kilter index black edges type 5 decrease without increasing kilter index edge never create non conformable edge particular edge type 2 created use painting lemma due minty 1966 see 10 pp 163165 standard outofkilter algorithm painting lemma let e graph whose edges arbitrarily colored black green red edges may uncoloured assume exists least one black edge e 0 one one two following propositions true cycle containing e 0 without uncoloured edge black edges oriented direction e 0 green edges oriented opposite direction b cocycle containing e 0 without red edge black edges oriented direction e 0 green edges oriented opposite direction r r g g uncoloured g figure two cases mintys lemma proof proof constructive proof based labeling process see 10 end following algorithm algorithm 4 minimize number zeroweight edges 1 start color edges explained 2 8e 2 e return r optimal retiming b else choose non conformable edge e 0 black apply painting lemma cycle found add one respectively subtract one ow edge oriented cycle direction e 0 resp opposite direction ii cocycle found cocycle determines partition vertices two sets add one retiming vertex belongs set terminal vertex e 0 c update color edges go back step 2 proof denition edge colors express ow retiming changes possible easy check step algorithm edge whose retiming ow value changes becomes conformable remains conformable otherwise furthermore retiming remains legal w r e 0 ow nonnegative fe 0 application painting lemma least one non conformable edge becomes conformable repeating operation coloration variation ow retiming edges become conformable end optimal retiming 424 complexity looking cycle cocycle painting lemma done marking procedure complexity ojej see 10 pp 164165 step least one non conformable edge becomes conformable total number steps less equal number zeroweight edges initial graph less total number edges graph thus complexity algorithm 4 ojej 2 note implementation algorithm optimized rst considering strongly connected component independently indeed strongly connected component retimed dene mentioned section 41 retiming value strongly connected component edges dierent strongly connected components positive weight done simple traversal directed acyclic graph dened strongly connected components 43 applying algorithm run complete example minimizing number zeroweight edges gives benet example toy example computes oating point number n given recursion straight calculation powers expensive improved possibility make calculation follows initialization rst example 2 assume sake illustration time multiply twice time add one cycle dependence graph depicted figure 7 clock period already minimal equal due circuit length 3 corresponding loop compaction given assuming two multipurpose units restricted resources impose execution three multiplications least 4 cycles loop independent dependences second addition wait last multiplication starting get pattern 5 cycles long dierent steps algorithm following see also figure 8 choose example non conformable edge nd circuit b c change ow accordingly choose non conformable edge nd cocycle dened sets fag change retiming accordingly choose c non conformable edge nd circuit c change ow accordingly figure 7 dependence graph associated schedule two resources choose b non conformable edge nd cocycle dened two sets ftg v n ftg change retiming accordingly edges conformable retiming optimal equal note step choose non conformable edge choosing dierent one result dierent number steps possibly dierent solution result still optimal note also example clock period remains unchanged minimization need use technique presented section 44 g g g g g r u g green red uncoloured flow unit distance register unit g g c g g g c c c c non conformable black figure 8 dierent steps zeroweight edge minimization minimization figure 9 remain two instead four loop independent dependences form single path second resource remaining tasks results 4 cycles pattern optimal resource constraints figure 9 dependence graph associated schedule two resources transformation resulting shifted code given since dierent retiming values 1 0 extra prelude postlude added compared original code i4n computed clock cycle computed clock cycle 1 computed clock cycle 2 computed clock cycle computed clock cycle 2 44 taking clock period account show algorithm given section 423 extended minimize number zeroweight edges subject constraint clock period retiming words given dependence graph want retime g graph g r whose clock period g r less equal given constant must feasible clock period zeroweight edges possible recall clock period g dened largest delay zeroweight path gg 441 clock edges following leiserson saxe technique 17 add new constraint pair vertices linked path whose delay greater desired clock period since path contain least one register equation w u v denotes minimal number registers path u v du v denotes maximal delay path u v w u v registers see 17 detailed discussion clock period minimization problem redundant constraints removed corresponds adding new edges weight w u v 1 pair vertices u v du v denote e clock set new edges let notice although new edges call clock edges must eect retiming cost since part original graph taken account counting number zeroweight edges may inuence ow cost since constrain register moves 442 changes algorithm show incorporate new edges algorithm dene coloration compatible previously dened colors problem following given dependence graph w goal nd retiming r z r legal course minimizes number zeroweight edges e summarizing previous observations change denition kilter index following way kilter index still nonnegative leads us change also proofs propositions 3 4 taking account new edges denote c f resp c fclock set edges e resp e clock fe 0 c 0 multicircuit g 0 dened f proposition 5 f fewe proof f f v r f r e proposition 2 v r kie denition kilter index proposition 5 gives new optimality condition takes clock edges account proposition 6 8e r optimal furthermore g r proof proof similar proof proposition 4 v r clock r e r e f f thus f fewe proposition 5 furthermore since retiming legal inequalities 4 satised construction e clock words g r remains draw kilter diagram e clock assign types colors types type 1 w r e 0 type 3 w r type 4 w r conformable edges type 2 w r e 0 fe 0 non conformable edges colors chosen follows black type 3 edges red type 4 edges green type 2 edges uncoloured type 1 edges see figure 10 black fe red r w e r uncoloured green figure 10 kilter diagram coloration clock edges note need start legal retiming ie retiming g r less edge weights nonnegative including weights clock edges retiming computed using algorithm 2 initially edges e clock conformable algorithm never creates non conformable edges green edges e clock never appear nal algorithm similar algorithm 4 reaches optimal retiming keeping clock period less given constant number steps still bounded jej since clock edges conformable remain conformable number edges g 0 ojv since g 0 complete graph worst case new clock edges marking procedure thus ojv overall complexity algorithm ojejjv j 2 5 conclusions limitations future work heuristic shiftthencompact algorithm proposed fall traps even rely optimal exponential algorithm loop compaction words given problem instance shift select may best one loop compaction nevertheless separation two phases cyclic problem without resource constraints acyclic problem resource constraints allows us convert worst case performance results acyclic scheduling problem worst case performance results software pipelining problem see equation 3 important idea due gasperoni schwiegelshohn 9 one interests decomposed software pipelining method including moduloscheduling property close get optimal proved separation two phases several advantages rst advantage already mentioned need take resource model account loop compaction phase thus design use aggressive even exponential loop compaction algorithms specic architectures second advantage fairly easy control statements move simply incorporating additional edges enforced critical path loop compaction smaller given constant constant could opt choosing larger value give freedom second objective minimization loop independent edges long value less holds another example want limit constant le maximal value w r e edge linked number registers needed store value created u simply add edge v u weight le taking additional edges account done clock edges third advantage still need explore rst phase loop shifting maybe used alone precompilation step even architectures dynamically scheduled minimizing number dependences inside loop body example reduce number mispredictions data speculation 20 despite advantages mentioned technique still one important weakness comes fact never try overlap patterns obtained loop compaction practice course instead waiting completion pattern initiating following one choosing initiation interval equal makespan loop compaction see algorithm 1 could choose smaller initiation interval long resource constraints dependence constraints satised resource p dene endp last clock cycle p used acyclic schedule given choose initial interval smallest satises dependences larger p example found initiation intervals equal 3 4 3 example 2 pipelined resources end section 43 overlapping approach may work well practice improve general worst case performance bound equation 3 still nd improvements direction especially dealing pipelined resources point gasperoni schwiegelshohn approach 9 weakness least worst case performance bound considering shifting schedule innite resources whole use loop compaction algorithm release dates tasks scheduled soon possible ensures good overlapping resulting worst case performance bound max replaced 1 case pipelined resources problem however seems dicult incorporate objectives zeroweight edge minimization described paper gasperoni schwiegelshohn approach since real separation shifting scheduling problems nevertheless loop compaction release dates looks promising plan explore possibility dealing pipelined resources change graph cutting operation several nodes rst real node corresponding eective resource utilization several virtual nodes one unit latency virtual nodes scheduled innite virtual resources approach nd shorter clock period delay node cut several parts equal 1 e situation actually equivalent case unit delays unpipelined resources thus bound equation 3 max replaced 1 problem however algorithm pseudopolynomial number vertices graph depends linearly max unacceptable pipeline latencies large another strategy rely several heuristics loop unrolling hide preponderance max worst case bound overlapping unrolling loop sucient number times p large compared max since resources limited unrolling loop increases lower bound due resources thus minimal initiation interval also completely satisfying thus working better optimization choices initial shift improved compaction phase overcome problem currently algorithm implemented source level using sourcetosource transformation library nestor 26 mainly check correctness strategies found dicult completely control compiler backends particular lot work remains done better understand link loop shifting lowlevel optimizations register allocation register renaming strength reduction even way code translated consider example 2 write instead simple modication reduces 1 opt 3 minimizing number zeroweight edges still lead best solution loop compaction clock period equal 4 except simultaneously want keep clock period less 3 programs equivalent software pipelining problem changes control leads general question level software pipelining performed r perfect pipelining software pipelining circuit retiming applied decomposed software pipelining rotation scheduling loop pipelining algorithm combining retiming scheduling techniques loop parallelization loop tiling generating close optimum loop schedules parallel processors graphs algorithms cyclic scheduling parallel processors overview computer architecture quantitative approach 2nd edition circular scheduling characterization minimum cycle mean digraph software pipelining retiming synchronous circuitry swing modulo scheduling lifetimesensitive approach dynamic speculation synchronization data dependences iterative modulo scheduling algorithm software pipelining iterative modulo scheduling scheduling techniques easily schedulable horizontal architecture high performance scienti nestor library tool implementing fortran source source transformations decomposed software pipelining tr graphs algorithms software pipelining effective scheduling technique vliw machines optimal parallelization arbitrary loops circular scheduling efficient resourceconstrained global scheduling technique superscalar vliw processors lifetimesensitive modulo scheduling rotation scheduling minimum register requirements modulo schedule specification software pipelining using petri nets decomposed software pipelining software pipelining circuit retiming applied decomposed software pipelining computer architecture 2nd ed ia64 architecture work perfect pipelining scheduling techniques easily schedulable horizontal architecture high performance scientific computing swing modulo scheduling ctr pemysl cha zdenk hanzlek antonn hemnek jan schier scheduling iterative algorithms matrix operations efficient fpga designimplementation finite interval constant modulus algorithm journal vlsi signal processing systems v46 n1 p3553 january 2007
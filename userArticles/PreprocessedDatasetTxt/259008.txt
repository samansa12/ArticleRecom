generating efficient virtual worlds visualization using partial evaluation dynamic compilation argue runtime program transformation partial evaluation dynamic compilation essential tools automated generation flexible highly interactive graphical interfaces particular techniques help bridge gap highlevel functional description efficient implementation support claim describe application techniques functional implementation nvision realtime visualization system represents multivariate relations nested 3d interactors auto visual rulebased system designs nvision visualizations highlevel task specifications nvision visualizations specified using simple functional language programs transformed cached dataflow graph partial evaluator used particular computationintensive function applications results compiled native code functional representation simplifies generation correct code program transformations ensure good performance demonstrate transformations improve performance cannot done compile time b introduction modern programming language implementation techniques extremely important even essential implementing flexible efficient interactive visualization tools case point describe new version nvision visualization tool originally developed present multivariate functions interactive 3d virtual worlds 3 appear acm sigplan conference partial evaluation semanticsbased program manipulation pepm97 used functional programming program transforma tion partial evaluation dynamic compilation improve functionality efficiency original version nvision added benefit simplifying production maintenance code primary focus research improvement graphics visualization systems knowledgebased automated design generation general believe capturing rules techniques graphic design applying specific application domains increase quality visualizations presented users relieve users burden creating visualizations experimental automated generation systems developed variety fields including information visualization 13 5 16 3 21 pictorial explanations 17 multimedia explanations 6 1 current work continuing development autovisual 3 rulebased component designs nvision visualizations highlevel userspecified visualization tasks autovisual produces representations real time interactive graphical scenes actually small functional programs generate render graphical objects response user input programs compositions small known components allow user interactively explore 3d visualizations multivariate lations space possible visualizations produced extremely large diverse automated tool helpful searching thus promising domain automated generation research unfortunately straightforward evaluation visualization programs inefficient even specialpurpose 3d graphics hardware computing rendering components scene animation frame expensive achieve frame rates 1020hz need make effective interactive visualizations therefore redesigned nvision perform carefully selected transformations optimizations programs specifically exploit frame coherence defined tendency successive frames animation sim ilar avoid redundant computation frames 7 first visualization specification transformed cached dataflow graph nodes whose input values changed since previous firing reevaluated cached output values used instead simple form memoization effective situation second partial evaluation dynamic compilation used optimize sampling loops user functions visualized rendering computationintensive part nvision get large speedups factoring subexpressions functions invariant within loops find even though optimizations sim ple strategic application improves efficiency nvision enormously time simplifying implementation observed many languages still batchoriented assuming compilation done runtime conclude work improved language models implementations would benefit interactive system development greatly specifically conjecture functionality stages compiler exposed available programmer runtime producing sort visible compiler nvision autovisual nvision visualization system designed exploring multivariate functions novel display interaction metaphor called worlds within worlds used represent higher dimensions use realtime 3d graphics stereo display 3d input devices user works highest possible natural dimension nvision worlds varied complex design implementation quite difficult users get good grasp space function wish view much less space possible visualizations function address problem developing autovisual knowledgebased system designs implements nvision worlds worlds within worlds worlds within worlds method uses hierarchy nested graphs graph interactor dynamic object responds user inputs consider function fx1 x2 graphed height field surface plot 3d instead gx1 x5 height field used graph slice function created holding three variables constant programming language terms constants c3 c4 c5 create closure original function plot instead using scheme syntax would define sliced function follows define gsliced lambda x1 x2 g x1 x2 c3 c4 c5 allow user interactively modify values x3 x4 x5 redefining replotting gsliced whole function space could explored interactively define higherorder function actually slicing define gslicer x3 x4 x5 lambda x1 x2 g x1 x2 x3 x4 x5 whenever values x3 x4 x5 change reevaluate gslicer resulting function graphed height field key worlds within worlds representing slicing dependency graphically create 3d volume x3 x4 x5 bound axis point within volume determines particular constants c3 c4 c5 call outer world embed another 3d world inside inner world containing surface plot gsliced origin constrained lie within bounds outer world position inner worlds origin relative outer world determines values x3 x4 x5 user translates inner world within outer world closure recomputed resulting graph redrawn example nvision world seen figure 1 thus worlds within worlds method composing graphs become browsers higherdimensional space traditional graphs used display functions think outer world graph higherorder function point within space determining unique function user views function particular point placing origin function graph technique applied recursively visualize variables given function hx1 x8 could three levels worlds inner two would outermost axes would bound x6 x7 x8 higherorder function graphed within outermost world must return higherorder function form gslicer define hslicer x6 x7 x8 lambda x3 x4 5 lambda x1 x2 h x1 x2 x3 x4 x5 number instances worlds may placed level giving multiple samples higherdimensional space worlds may rotated scaled well trans lated operations equivalent semantics translation used adjust worlds better viewing presented particular 3d example obviously worlds within worlds method flexible implemented number variations clearly variables function may also permuted bound different axes however worlds may also graphically real izable dimension 0 3 graphs functions may also type eg line graphs images volume renderings required graph appropriate encoding function represented world figure 2 shows visualization multiple inner worlds volume renderings used display many samples function possible also extended notion world redisplay portions function graph general define worlds tools virtual interaction devices used select values tools redisplay describe fully 3 beyond scope paper autovisual nvision worlds quite complex design variables may permuted functions sliced many different ways different graph types substituted forth factors difficult master figure 1 nvision world representing function 5 variables hierarchy graphs height field inner world encodes function constant values x3 x4 x5 determined position inner worlds origin relative outer world user translates inner world nvision updates height field tedious control interactively alleviate complexity building autovisual knowledgebased system transforms user functions highlevel task specifications interactive nvision worlds work autovisual motivated many design features new version nvision design process must criteria evaluating quality particular design specification autovisual use criteria derived set forth mackinlays work apt 13 generated static graph must expressive effective expressive graph presents exactly desired data user less effective graph easy read draw inferences autovisual try establish design potentially expressive potentially effective interactive graph display data user must potential seeing data time similarly every view interactive 3d graph effective must possible user find one viewpoints configurations visualization effective furthermore graph must reasonably responsive visualization complex display real time hard work new method representing nvision worlds functionally eases burden autovisual functional composition small general components allows autovisual design wide variety worlds yet able verify particular implementation correct exhibit reasonable performance representing visualizations graphical applications one primary optimization techniques exploiting coherence tendency neighboring pixels image regions similar often common subexpressions computation image figure 2 nvision world representing function 6 variables inner world simple volume rendering sampling function three variables encoding result color multiple inner worlds instantiated give user quick overview behavior function factored evaluated animations generally exhibit frame coherence tendency successive images similar hence computations redun dancy unfortunately interactive application nvision possible determine redundancies compile time depend users actions exploit frame coherence wrapping function applications caching functions effect implementing simple form memoization nvision worlds specified using simple functional language functional expressions describe scene rendered based user input expressions evaluated repeatedly inside interaction loop expressions language easily transformed executable dataflow graphs standard method representing scenes graphical applications display list developed early history computer graphics hierarchical display list represents graphical scene hierarchical composition reference frames coordinate systems objects instanced relative particular reference frame however display lists general representation functional dependency graphical components hierarchical structure allow objects defined relative limited applications particular limited represent complex dependencies inherent nvision worlds data dependencies implicit part functional specification obviating need special change propagation mechanism active variables 4 20 whenever function node graph evaluated interpreter automatically distributes results nodes require dependencies specify partial ordering function evaluation ensuring function evaluated arguments calculated node need evaluated regardless often results used language definition functional language used implement nvision worlds quite simple singleassignment language supports let followedby expressions function appli cations functions may multiple return values also function may tagged volatile indicating sideeffect currently lambda expressions sup ported functions defined compiled runtime implementing direct manipulation 18 requires access geometry values computed previous animation frame therefore need representation state followedby expression provides functionality form followedby head rest constructs infinite lazy stream first element stream value first argument evaluated first iteration interaction loop kth element list k 1 value second argument evaluated iteration interaction loop dataflow transformations dataflow graph constructed functional specification visualization function node created call site expression representing argument call recursively transformed dataflow graph output port root node connected appropriate input port function node constant values placed special nodes attached directly input ports nodes containing volatile functions marked functions always evaluated node fires case followedby expression special node two inputs created first firing removes token left arc subsequent firings removes token right arc arcs created constructing argument graphs allowed back arcs allowing values computed one iteration graph used next graph constructed transformation engine performs two standard optimizations first constant folding arguments function call constants function labeled volatile expression evaluated function nodes output ports replaced constant nodes second optimization finding eliminating common subexpressions addition reducing computation within nodes optimizations tend reduce number nodes hence overhead executing dataflow graph caching graph constructed passed running animation loop evaluation graph produces image screen mentioned graphical applications often display frame coherence implies values computed particular call site high probability one iteration loop next use special caching mechanism wrapped around every function node exploit values transmitted around dataflow graph small data structures called tokens token bit called changebit indicating whether current value different previous one constant tokens changebit true first iteration graph force evaluation nodes false addition every function node cache output token node fires none input values changed function evaluated cached tokens used instead changebits set false one input values changed function reevaluated caches updated newly computed value compared corresponding cached value new old values equal changebits outgoing tokens set false figure 3 shows pseudocode caching mechanism equality operators specified per type user objects equality expensive compute may assigned operators always return false large objects often use equality pointers summary node evaluated one input values changed node reevaluated produces value values subsequent nodes evaluated thus function acts lowpass filter resulting computation filtered well values change leaf nodes graph computation avoided except application volatile nodes overhead traversing graph tokens type struct tokent bool ch changedbit tx1n input tokens ty1m output token caches y1m holds newly computed values eval shorthand multiple return values y1 forint i1 im forint i1 im figure 3 c pseudocode caching mechanism function evaluation nodes nvision partial application present model essential computation nvision using curried functions serves two purposes mentioned consider nvision visual representation currying representation seems natural also helps simplify discussion use partial evaluation simplicity assume functions f visualized nvision map ntuples real numbers single real value design autovisual first produce new function f 0 partitioning arguments f multiple ntuples corresponding level visualization curry result produce f 00 level visualization corresponds partial application f 00 consider example given function autovisual designed visualization three levels world 2d innermost world contains line graph outermost world w0 encodes x1 x2 middle world w1 encodes x3 x4 innermost world w2 plots value function x5 curried version g call h0 visualization outermost world w0 represents h0 selecting point w0 applying h0 yields h1 function represented w1 similarly world w2 represents h2 obtained applying point selected world note h2 type function encoded traditional line graph within world w2 sampling set 1d points fs0 partial evaluation within computation animation frame sampling functions graph far expensive computation hence targeted optimization partial evaluation compilation sampling loops obvious optimizations situation complicated dynamic nature design process running application unlike many applications discussed 11 10 must run partial evaluator runtime effect autovisual generates programs fly dynamic higherorder functions language processing optimizing facilities must operate fly well consider twolevel visualization shown figure 2 3 theta 3 theta 3 grid innermost worlds calculates 4 theta 4 theta 4 grid requiring 1700 sam ples reasonable visualization would least theta 16 theta 16 grid within world requiring 100 000 samples animating visualization rate say 10hz moving entire grid inner worlds would thus require one million function samples per second clearly goal applying partial evaluation optimize functions h previous section language provided user implementing functions visualized quite simple consisting solely constants variables primitive functions serves two purposes partial evaluator much simpler write result lightweight ie small fast goal verify partial evaluation useful context build full specializer result partial evaluator little cogen operator constant folding however enough confirm expectations partial evaluation important tool visualization software especially used runtime discussed section sophisticated specializers designed could substituted within innermost sampling loop want evaluate smallest possible function example function would h2 obvious optimization therefore would like precisely result specialiser partial evaluation algorithm takes arguments abstract syntax tree function specialized list l lists variables eg list represents partial applications level visualization order beginning outermost level working inward generated autovisual algorithm takes first set variables labels static performs binding time analysis syntax tree partitioned forest completely static sub trees one tree dynamic values algorithm recurses dynamic tree pruned static subtrees generates residual function generating function evaluates pruned subtrees wrapped around residual result returned result set nested functions implement partial application performing much computation possible stage compiled dynamically linked ensure optimal performance step 6 subtle evaluation static parameters yield new values must made available residual functions step new values located added argument list residual function known arity raising covered detail 11 page 224 new arguments given generated variable names form gvi seen generated code figure 5 step 7 generates list let bindings capture values computing subtrees labelled static bindings spliced resulting function code step 8 prunes tree fullystatic subtrees replacing references variables defined binding lists previous step following pseudocode use scheme macro notation construct new functions scope let constructs covers entire algorithm function unparse converts syntax tree sexpression given function g define g x1 x2 x3 x4 x5 1 given abstract syntax tree list l lists variable names 2 let 3 tl nil return value lambda vs unparse 4 label leaves either constant variable v v vs else 5 traverse depth first labelling internal node either subexpressions node labelled else perform depth first search tree stopping node labelled node variable add name list vn generate unique variable name attach node add name vn 7 let bl variable v vn create list v unparse st st subtree labelled v add result list bl 8 let nt copytreet variable v vn replace subtree labelled v v 9 let ttl tail tl htl head tl let rfrecurse nt cons append vn htl ttl let rfn unique function name 10 return value lambda vs let rfn rf let bl lambda figure 4 pseudocode partial evaluator used optimize visualization functions partioning list l specializer generates code figure 5 result compact efficient two partial applications resulting function performs one multiplication one addition per call efficiency present estimates efficiency gains resulting dataflow caching partial evaluation sets measurements obviously highly dependent individual programs run however observed general trends applications present approximate figures first dataflow architecture introduces extra cost execution graph caching mechanisms dataflow executive running lambda x1 x2 let rf1 lambda x3 x4 gv0 gv1 let rf0 lambda x5 gv2 gv1 let gv2 gv0 x3 x4 lambda let gv0 x1 x2 lambda x3 x4 figure 5 specialized code function five variables caching active always missing overhead averages 10 15 percent typically 20 percent nodes labelled volatile always fire remaining nodes one third reevaluated average interactive controls made vary continuously program control climbs 100 percent general though many controls user move time however nodes carry equal weight rendering operations performed volatile nodes function sampling nodes intensive clean structure functional programming specification makes easy guarantee nodes fired absolutely necessary know hard experience true event propagation systems commonly used user interface software partial evaluation dynamic compilation perform well time required specialization typically less second hence unnoticeable inter action happens function first defined compilation loading takes several seconds operations require disk activity believe given small inmemory code generator delay would also unnoticeable running time functions easy construct unbalanced functions visualizations speedup gained however functions tried sampling time within innermost loop generally less 20 percent original sometimes low percent considering formidable multipliers discussed section important gain precompilation important realize complexity design space visualizations understand partial evaluation dynamic compilation described necessary assume moment function user wishes visualize fixed design visualization fixed except order binding variables particular axes features make using nvision pleasant eg allowing user specify new functions visualize without recompiling nvision absolutely essential however reorienting view multidimensional space selectively reordering axes often essential comprehension function must allow user dynamically given fixed points ask following question precompute compile functions implement possible sampling loops possible binding axes innermost worlds computation intense could generate compile partiallyevaluated optimized function general equation number functions must precompiled however general function sampled three variables volume rendering innermost world reducing equation tox 2 perform matrix transposition results sampling appropriately dont need generate functions permutation parameters unique set maximum three sampling variables isx 6 3 graph number sampling functions need without permutations shown figure 6 clearly even without permutations number functions needed increases unacceptably past 9 10 vari ables ideally would like nvision used functions many variables this100300500700900 figure number functions would need precomputed user function n variables implementation dataflow interpreter implemented c datatypes functions used computations also defined c simple preprocessor written awk used provide nice syntax multiple return values code generation evaluation guards caching functions runtime type information generated dynamic construction dataflow graphs also typechecked scheme bindings creating connecting dataflow nodes constants generated scheme macros functions used implement syntax functional language perform transformations programs currently scheme interpreter stk8 reasonably efficient excellent support user nvision functions restricted tiny language described section partial evaluator specializes expressions source language generates c code compiled loaded dynamically conclusions future work though yet series definitive benchmarks clear existing system gives good perfor mance increased flexibility dataflow system previous implementation making redesign implementation autovisual much easier clearly many optimizations could done caching transformations simplistic minimum need support lambda functions language apply caching guards hi erarchically avoiding traversal well recomputation whole subgraphs even better would statistical modeling reevaluation behavior nodes clearly partial evaluation dataflow nodes sampling functions may beneficial better scheduling dataflow graph also possible large sections could almost certainly converted straight code however believe done important optimizations next step finish automated generation system allow us evaluate wide variety visualization configurations really put system test believe help pinpoint much accurately optimizations done partial ordering computation specified functional programs precisely required parallelization computation believe design extend distributed version interpreter though built one yet partialevaluation applied similar situations inspiration applying partial evaluation nvision synthesis efficient operating system uses partial evaluation one optimization techniques14 berlin weise use partial evaluation specialize scientific computations2 believe system requires different solutions dynamic nature clear us optimization techniques useful especially exposed language features invoked runtime leone lee use partial evaluation runtime code generation fabius improve performance mllike language12 currently evaluating whether fabius flexibility necessary efficient implementation nvision fur thermore believe simple binding time analysis specialization subsumed recent work multilevel specialization 9 19 application would benefit sophisticated language implementing functions without loss efficiency general believe functions compilation system ie parsing typechecking optimizing trans formations code generation made visible programmers invoke directly would possible build programs would simpler yet interactive efficient makes perfect sense one imagines user interface flexible user actually programming interactively acting kind online script generator compilers still batchoriented believe languages compilers need interactive truly build interactive applications tried small way new version nvision acknowledgments would like thank bruce naylor original inspiration transforming functional scene representation cached dataflow graph research described supported part onr contract n000149410564 nsf grant cda9024735 columbia university cat high performance computing communications healthcare funded ny state science technology foundation gift digital image design r wip automatic synthesis multimodal presentations compiling scientific code using partial evaluation scope automated generation graphical interfaces automating generation coordinated multimedia explanations computer graphics principles practice designing meta object protocol wrap standard graphical toolkit efficient multilevel generating extensions program specialization introduction partial evaluation partial evaluation automatic program generation lightweight runtime code gen eration automating design graphical presentations relational information efficient implementation fundamental operating system services tcl toolkit data characterization intelligent graphics presentation automated generation intentbased 3d illustrations direct manipulation step beyond programming languages cogen six lines using active data uims data characterization automatically visualizing heterogeneous information tr automating design graphical presentations relational information using active data uims scope automated generation graphical interfaces data characterization intelligent graphics presentation taskanalytic approach automated design graphic presentations automated generation intentbased 3d illustrations synthesis efficient implementation fundamental operating system services partial evaluation automatic program generation wip automatic synthesis multimodal presentations automating generation coordinated multimedia explanations tcl computer graphics 2nd ed c cogen six lines introduction partial evaluation auto visual efficient multilevel generating extensions program specialization designing meta object protocol wrap standard graphic toolkit data characterization automatically visualizing heterogeneous information compiling scientific code using partial evaluation ctr david durand paul kahn mapa system inducing visualizing hierarchy websites proceedings ninth acm conference hypertext hypermedia links objects time spacestructure hypermedia systems links objects time spacestructure hypermedia systems p6676 june 2024 1998 pittsburgh pennsylvania united states
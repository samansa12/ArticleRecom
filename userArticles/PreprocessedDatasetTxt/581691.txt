template metaprogramming haskell propose new extension purely functional programming language haskell supports compiletime metaprogramming purpose system support algorithmic construction programs compiletimethe ability generate code compile time allows programmer implement features polytypic programs macrolike expansion user directed optimization inlining generation supporting data structures functions existing data structures functionsour design implemented glasgow haskell compiler ghc b introduction compiletime program optimizations similar po etry written actually published commercial compilers hard economic reality many interesting optimizations narrow audience justify cost alternative allow programmers define compiletime op timizations already happened accidentally c albeit imperfectly obvious functional programmers committee realize later c templates functional language evaluated compile time 12 haskell workshop oct 2002 pittsburgh robinsons provocative paper identifies c templates jor albeit accidental success c language design despite extremely baroque nature template metaprogramming templates used fascinating ways extend beyond wildest dreams language designers 1 perhaps surprisingly view fact templates functional programs functional programmers slow capitalize cs success recent flurry work runtime meta programming much less done compiletime meta programming scheme community notable exception discuss section 10 paper therefore present design compiletime metaprogramming extension haskell stronglytyped purely functional language purpose extension allow programmers compute parts program rather write seamlessly conveniently extension viewed template system haskell la c well typesafe macro system make following new contributions describe quasiquotation mechanism language binders precisely described translation monadic computation allows use gensym like operator even purely functional language like haskell sections 61 9 staged typechecking algorithm coroutines type checking compiletime computations staging use ful supports code generators written ordinary programs would need given dependent types language therefore expressive simple dependent still secure runtime computations either handwritten computed always typechecked executed section 7 reification programmerwritten components supported computed parts program analyze structure userwritten parts particularly useful building boilerplate code derived data type declarations sections 5 81 addition original contributions synthesized previous work coherent system provides new capabilities include representation code ordinary algebraic datatype makes possible use haskells existing mechanisms case analysis observe structure code thereby allowing programmer write code manipulation programs well code generation programs sections 62 93 augmented quotation monad encapsulates metaprogramming features fresh name generation program reification error reporting monadic library syntax operators built top algebraic datatypes quotation monad provides easytouse interface metaprogramming parts system sections 4 6 63 section 8 quasiquote mechanism built top monadic li brary template haskell extends metalevel operations static scoping static typechecking objectlevel code fragments built using quasiquote mechanism sec tions 9 71 static scoping typechecking automatically extend code fragments built using algebraic datatype representation would programmed user sections 9 93 reification facilities quotation monad allows programmer compiletime query compilers internal data structures asking questions line number sourcefile current position useful error reporting kind type construc tor section 82 metaprogram produce group declarations including data type class instance declarations well expression section 51 2 basic idea begin example illustrate mean meta programming consider writing clike printf function haskell would like write something like printf error line msg line one cannot define printf haskell printfs type de pends complicated way value first argument see 5 ingenious alternative template haskell though define printf typesafe ie report error compiletime msg line type string int respectively efficient control string interpreted compile time userdefinable fixed number compiler extensions ever enough write call template haskell printf error line msg line says evaluate compile time call printf returns haskell expression spliced place call compilation original expression proceed often use term splice splice printf returns following code s0 n1 show lambda abstraction typechecked applied msg line example interactive session illustrate prompt printf error line bad var 123 error bad var line 123 1 note template haskell followed open parenthesis alphabetic character special syntactic form x means x applied splice whereas x means ordinary infix application function ordinary haskell situation similar ab means something different b function printf executed compile time program produces program result metaprogram template haskell user define printf thus printf string expr type printf says transforms format string haskell expression type expr auxiliary function parse breaks format string tractable list format specifiers data string parse string format example parse returns l even though parse executed compile time perfectly ordinary haskell function leave definition exercise function gen much interesting first give code gen assuming exactly one format specifier gen format expr gen l results gen constructed using quasiquote notation templates template haskell quasiquotations users interface representing haskell programs constructed placing quasiquote brackets around ordinary haskell concrete syntax fragments function lift string expr lifts string expr type producing expr executed would evaluate liftss ar gument say lift section 91 matters become interesting want make gen recur sive deal arbitrary list format specifiers give auxiliary parameter namely expression representing string prefix result adjust call printf accordingly printf string expr gen format expr expr gen inside quotations splice annotation still means evaluate quasiquoted code constructed gen called recursive calls gen therefore run compile time result spliced enclosing quasiquoted expression argument type expr second argument recursive call gen accumulating parameter type expr hence another quasiquoted ex pression notice arguments recursive calls gen refer objectvariables n bound outer quasiquotes occurrences within static scope binding occurrence static scoping extends across template mechanism 3 templates write programs highlevel languages make programs shorter concise easier maintain easier think many low level details data layout memory allocation abstracted compiler programmer longer concerns details time good since expert knowledge embedded compiler compiler job manner superior users could manage sometimes programmer knows particular details compiler compiler couldnt deal details economic reasons doesnt 12 limit number features compiler writer put one compiler solution construct compiler manner ordinary users teach new tricks rationale behind template haskell make easy programmers teach compiler certain class tricks compilers manipulate programs making easy users manipulate programs also easy interlace manipulations compilers manipulations creates powerful new tool envision template haskell used programmers many things conditional compilation extremely useful compiling single program different platforms different debugging options different configuration crude approach use preprocessor like cpp indeed several compilers haskell support directly mechanism part programming language would work much better program reification enables programs inspect structure example generate function serialise data structure based data type declaration structure algorithmic program construction allows programmer construct programs algorithm describes construct program simpler program generic functions like map show prime examples compiletime specialized programs like printf code compiled specialized compiletime constants abstractions transcend abstraction mechanisms accessible language examples include introducing higherorder operators firstorder language using compiletime macros implementing integer indexed functions like zip1 zip2 zipn strongly typed language optimizations may teach compiler domainspecific optimizations algebraic laws inlining opportunities template haskell functions execute compile time written language functions execute run time namely haskell choice sharp contrast many existing systems example cpp language define etc template metaprograms c written entirely type system big advantage approach existing libraries programming skills used directly arguably disadvantage explicit annotations necessary specify bits code execute another consequence programmer may erroneously write nonterminating function executes compile time case compiler fail terminate regard programming error avoidable divergence run time rest paper flesh details design shall see following sections turns simple quasiquote splice notation introduced far enough 4 flexible construction one starts use template haskell long one discovers quasiquote splice cannot express anything like full range metaprogramming opportunities want haskell builtin functions selecting components namely fst snd want select first component triple write hand case x abc template haskell instead write sel 1 least would like write sel sel int int expr sel case x uh oh cant write ordinary haskell pattern case expression depends n quasiquote notation broken instead need way construct haskell syntax trees directly like sel int int expr sel alt match pat patt rhs expr based string code use syntaxconstruction functions construct expressions patterns list types concrete examples reference syntax patterns pvar string patt x ptup patt patt xyz pcon string patt patt fork x pwild patt syntax expressions var string expr x app expr expr expr f x lam patt expr expr x 5 case x simplem patt expr match xxs 2 code sel verbose printf uses explicit constructors expressions rather implicit ones exchange code construction fundamentally flexible sel shows template haskell provides full family syntax construction functions lam pvar documented appendix two styles mixed freely example could also sel like sel int int expr sel illustrate idea suppose want nary zip func tion whose call might look like zipn bs cs lists zipn int expr generates code nary zip lets start write zipn zipn int expr metafunction zipn generates local let binding like let zip3 body binding dots generated auxiliary metafunction mkzip defined low function defined let zip3 example paragraph recursive name function doesnt really matter since used result let never escapes scope let whole let expression returned name function must passed mkzip mkzip generates body let properly scoped size zipping function n also parameter mkzip useful see mkzip generates particular n understanding works applied 3 object variable var ff generates value expr type prettyprinting value concrete syntax get case y1y2y3 note parameter var ff ends function one arms case user level function zipn opposed auxiliary function mkzip applied 3 obtain full let note name bound variable zp0 passed parameter mkzip ends recursive call case y1y2y3 zp0 function mkzip operates generating bunch patterns eg y1 y2 y3 x1xs1x2xs2x3xs3 bunch expressions using variables bound patterns generating several patterns patternvariable associated expressions expressionvariable common abstract function string int pattexpr map pvar ns map var ns pvar x1pvar x2var x1var x2 mkzip use function construct three lists matching patterns expressions assemble pieces lambda abstraction whose body case analysis lambda abstracted variables pxs pys pcons x pcons pxs pxss b use quasiquotation mechanism patterns p function apps another idiom worth abstracting function application function multiple arguments apps expr expr apps apps message section works quasiquote notation simple convenient secure understands haskells static scoping type rules however quasiquote alone enough usually want generate code sequences indeterminate length template haskells syntaxconstruction functions app lam casee etc allow programmer drop less convenient expressive notation necessary 5 declarations reification haskell one may add deriving clause data type declaration data tip fork deriving eq deriving eq clause instructs compiler generate boilerplate code allow values type compared equality however mechanism works handful builtin type classes eq ord ix want instances classes write hand tiresome winstanley wrote drift preprocessor haskell allows programmer specify codegeneration algorithm use algorithm generate boilerplate code many data types 17 much work also done polytypic algorithms whose execution specified based structure type 9 6 template haskell works like fullyintegrated version drift example data tip fork splice geneq reifydecl code shows two new features seen reification declaration splicing reification involves making internal representation available data structure compiletime computations reification covered detail section 81 51 declaration splicing construct splice may appear declaration group needed whereas seen expression expected splice instructs compiler run enclosed code compiletime splice resulting declaration group place splice call 2 splicing generate one declarations example geneq generated single instance declaration essential aside syntax use splice rather latter seems rather terse declaration context particular application deriving general could also generate one class data type value declarations generating declarations rather expressions useful purposes deriving code data types consider nary zip function discussed section 4 every time write zipn bs cs fresh copy 3way zip gener ated may precisely programmer wants say may also want generate single toplevel zip function like might want generate zip functions 10 20 whatever write splice genzips 20 understanding zip1 zip2 zip20 brought scope 6 quasiquotes scoping quotation monad ordinary haskell statically scoped template haskell example consider metafunction cross2a cross2a expr expr expr executing cross2a var x var expect var x var would inadvertently captured local objectvariables x inside quasiquotes cross2as definition indeed case prompt cross2a var x var displaying toplevel term type expr quasiquote notation renames x get expected result static scoping works ordinary haskell quasiquotes lift behavior objectlevel well unfortu nately syntax construction functions lam var tup etc behave way consider lam ptup pvar x pvar tup app f var xapp g var applying cross2b x results inadvertent capture prompt cross2b var x var displaying toplevel term type expr since program generators cannot written using quasiquote notation alone appears syntax construction functions inadequate expressing static scoping appears trouble need way generate fresh names turn next 61 secrets revealed one correct rendering cross template haskell without using quasiquote cross2c expr expr expr x gensym x return lam ptup pvar xpvar tup app ft var x example reveal three secrets type expr synonym monadic type q exp deed true declarations code returned cross2c represented ordinary haskell algebraic datatypes fact two algebraic data types example exp expressions constructors lam tup app etc pat patterns constructors pvar ptup etc monad q quotation monad supports usual monadic operations bind return fail notation well gensym operation gensym string q string generate expr returned cross2c using haskells monadic donotation first generate fresh name x using monadic gensym build expression return notice tiresomely also perform f g monad giving ft gt type exp f g type might internal gensyms see avoid pain section 63 summarize template haskell three layers representation objectprograms order increasing convenience decreasing power bottom layer two parts first ordinary algebraic data types represent haskell program fragments section 62 second quotation monad q encapsulates notion generating fresh names well failure inputoutput section 8 library syntaxconstruction functions tup app lift corresponding algebraic data type constructors tup app quotationmonad level providing convenient way access bottom layer section 63 quasiquote notation introduced section 2 convenient seen important metaprograms cannot express revisit quasiquote notation section 9 show built top previous layers programmer freely mix three layers latter two simply convenient interfaces first discuss detail first two layers code representation leave detailed discussion quasiquotes section 9 62 datatypes code since objectprograms data haskell represents data structures using algebraic datatypes natural template haskell represent haskell objectprograms using algebraic datatype particular data types used template haskell given appendix b highlights include algebraic datatypes represent expressions exp declarations dec patterns pat types typ additional data types used represent syntactic elements haskell guarded definitions body expressions comprehensions statement arithmetic sequences dotdot used comments freely appendix b illustrate algebraic datatypes concrete syntax examples tried make data types complete yet simple modelled haskells concrete surface syntax haskell programs able use algebraic constructor functions represent advantage algebraic approach objectprogram representations ordinary data particular analysed using haskells case expression pattern matching disadvantages approach verbosity construct representation program requires considerably effort required construct program little support semantic features object language scoping typing 63 syntaxconstruction functions syntaxconstruction functions section 4 stand revealed monadic variants corresponding data type constructor example types data type constructor app monadic counterpart remember app exp exp exp app expr expr expr arguments app computations whereas arguments app data values however app convenience function simply performs argument computations building result app expr expr expr x b return app b convenience worth example yet another version cross cross2d expr expr expr x gensym x lam ptup pvar x pvar tup app f var x var use monadic versions constructors build result thereby avoid bind ft gt hand cross2c instead lam app tup us general use following nomenclature fourcharacter type name eg expr monadic version threecharacter algebraic data type eg exp lowercased function eg app monadic version uppercased data constructor eg app 3 expr decl monadic computational versions underlying concrete type corresponding types patterns patt types type simply synonyms underlying data type 3 constructors whose lowercase name would clash haskell keywords like let case data class instance use convention suffixing lowercase names initial letter type lete casee doe datad classd instanced reason need gensym constructing patterns types look cross2d would point gensyming x inside pattern variables must scope body lambda well nevertheless provide type synonyms patt type together lowercase constructors pvar ptup etc programmers use consistent set lowercase working computational setting even though formation exp dec computational uppercase working algebraic datatype setting syntaxconstruction functions ordinary haskell library one readily extended program mer seen one example definition apps end section 4 many others possible example consider common pattern wish generate code scope newlygenerated pattern dont care names variables pattern dont clash existing names one approach gensym new variables construct pattern expression hand cross2d alternative clone whole pattern one fell swoop rather generate new variable one time vfp genpat ptup pvar xpvar lam p tupapp f vf xapp g vf function genpat patt q stringexpr patt alpharenames whole pattern returns new pattern function maps names variables original pattern exprs names variables alpharenamed pattern easy write recursion pattern scheme even mixed quasiquote notation vfp genpat p xy usees quasiquote notation patterns p mentioned passing section 4 also supply quasiquote notation declarations types course renaming happens automatically quasiquotation explain detail section 9 7 typing template haskell template haskell strongly typed milner sense welltyped program cannot go wrong runtime traditionally strongly typed program first typechecked compiled executed situation template haskell little complicated example consider first example printf error line urk 341 cannot readily typechecked form type spliced expression depends complicated way value string argument template haskell type checking takes place stages first type check body splice case printf error line expr next compile execute splice result place call example program becomes s0 n1 show urk 341 typecheck resulting program programmer written program first place hence type checking intimately interleaved compiletime execution template haskell compiletime metasystem metalevel operators brackets splices reification appear code generated example f 3 ille gal restrictions well example definition illegal unless inside quotation says evaluate compile time splice value x known f called common staging error enforce restrictions like break staticchecking part compiling process three states compiling c state normal compilation without metaoperators compiler would always state compiler enters state bracket compiling code inside quasiquotes compiler enters state splicing encounters expression escape inside quasiquoting brackets example consider definition f statically checked state c call foo typed state b call zipn typed state addition states count levels starting state 0 incrementing processing quasiquotes decrementing processing inside splice levels used distinguish toplevel splice splice inside quasiquotes example call h statically checked state level 1 x2 checked state b level 0 three states legal transitions reflected figure 1 transitions diagram indicate error transitions tempting think states merged together case transitions state c imply compiletime computation thus require complicated static checking including computation transitions states rules diagram enforced weaving type checker formal typing judgments type checker given figure 2 embody transition diagram supplying cases legal states study rules detail 71 expressions begin rules expressions simpler indeed simplifications wellestablished rules metaml 16 type judgment rules expressions takes conventional form g environment mapping variables types binding states e expression type state describes state type checker n level described reify reify splice figure 1 typing states template haskell rule bracket says one states c expression e type q exp regardless type e ever notice e still typechecked new state b increment level reflects legal transitions figure 1 emphasizes use bracket typing rule one listed states type checking term e detects internal type inconsistencies right away example would rejected immediately represents interesting design compromise metafunctions including code fragments generate statically checked guarantee metafunction produce welltyped code completed splices rechecked believe new approach typing meta programs approach catches many errors early possible avoids need using dependent types yet still completely typesafe notice rule quasiquotes state b quasiquotes cannot nested unlike multistage languages metaml rule escb explains type check splice e inside quasi quotes state b type e must q exp tells us nothing type expression e evaluate hence use unspecified problem soundness ever expression splice sits typechecked later indeed precisely happens rule escs deals splicing state c expression e type checked evaluated give new expression e expression type checked scratch state c programmer written first place rules lam var deal staging environment g contains assumptions form records xs type also level bound rule lam think environment finite function variable x used level n check n later binding level rule var 72 declarations figure also gives rules typing declarations whose judgments form states cbs reifydecl fun figure 2 typing rules template haskell g environment declarations checked g minienvironment gives types variables bound decl 4 rules quite conventional example rule fun explains type function definitions rule splicing interesting one follows pattern splicing expres sions first typecheck spliced expression e run typecheck declarations returns ability generate group declarations seems fundamental usefulness raises interesting complication cannot even resolve lexical scoping program let alone types splicing done example program valid splice genzips 20 well valid splice brings zip3 scope expect doesnt similar remarks naturally apply instance declaration produced geneq function section 51 module contains several splices may obvious order expand tackle complication assuming programmer intends splices expanded toptobottom precisely 4 single haskell declaration bind many variables typecheck group declarations 1 n follow following procedure group declarations follows splice e a2 b splice e b splice e z z2 n splice declarations ones indicated explicitly group 1 etc ordinary haskell declarations perform conventional dependency analysis followed type checking first group free variables scope environment thus established typecheck expand first splice typecheck result expanding first splice augmented environment thus established typecheck next ordinary group algorithm implements judgment declaration lists used rule splice 73 restrictions declaration splicing notice rule splice assumes state c level 0 permit declaration splice state example permit splice pq h int decl typechecking f cannot run computation h x x known yet run h x know let binds cannot sensibly typecheck body let namely pq would possible give typechecking body since result every call f typechecked logical conclusion line thought would give typechecking body quasiquote expression would sound would defer many type errors definition site metafunction call sites choice pending experience err side earlier error detection want effect f still get dropping lower level fact currently restrict splice must toplevel declaration like haskells data class instance declara tions reason restriction concerns usability rather technical complexity since declaration splices introduce unspecified new bindings may clear variable occurs original program bound situation similar haskells existing import statements bring scope unspecified collection bindings restricting splice top level make worthwhile gain given occurrence x see lexically enclosing binding x indeed xs binding top level splice cannot hide another toplevel binding import x haskell permit two definitions value top level contrast nested splice could hide enclosing binding x indeed one think toplevel splice kind programmable import statement 8 quotation monad revisited far used quotation monad generate fresh names useful purposes discuss section 81 reification reification template haskells way allowing programmer query state compilers internal symbol tables example programmer may write module data tip fork rept decl lengthtype type percentfixity q int q string first construct reifydecl returns computation type decl ie q dec representing type declaration performed computation rept perhaps writing rept would obtain dec data mt constr mtip tvar constr mfork tapp tcon name mt tvar tapp tcon name mt tvar write mt mean unambiguously defined module say mt original name original names part syntax haskell necessary describe indeed implement metaprogramming cor rectly say original names section 91 similar way reifydecl f gives data structure represents value declaration f similarly classes deed reification provides general way get compiletime formation construct reifytype length returns computation type type ie q typ representing compilers knowledge type library function length similarly reifyfixity tells fixity argument useful figuring print something finally reifylocn returns computation type q string represents location source file reifylocn occurred reify always returns computation combined computations compiletime reification language construct say map reifytype xs example important reification returns result quotation monad example consider definition assertion function assert expr bool b r else error assert fail notice comment giving type expression generated assert static type system metaml would nicer one might invoke assert like find xs assert splice expanded get find xs n error assert fail line 22 foohs n 10 xs n vital course reifylocn captures location splice site assert rather definition site precisely achieve making reifylocn return com putation one take idea making asserts behaviour depend commandline argument analogous cpps command mechanism defining symbols dfoo cassert expr bool mb reifyopt debug isnothing mb else assert assume another reification function reifyopt string maybe string returns nothing command line option specified string defined value one one could go yet clear much reification allowed example might useful restrict use reifydecl type constructors classes variables eg function declared top level current module perhaps type constructors declared data declarations imported modules may also useful support additional kinds reification making compiler symbol table information available 82 failure compiletime metaprogram may fail programmer made error example would expect zipn 1 fail make sense produce nary zip function arguments errors sort due inappropriate use rather bogus implementation metaprogram metaprogrammer needs way cleanly report error another place quotation monad useful case zipn write zipn int expr arg zipn must 2 fail standard monadic fail operator class monad whose type instance fail string q compiler catch errors reported via fail gracefully report occured 83 inputoutput metaprogram may require access inputoutput facilities example may want write splice genxml fooxml generate haskell data type declaration corresponding xml schema stored file fooxml together boilerplate haskell functions work data type end easily provide way performing arbitrary inputoutput quotation monad qio io q naturally power open abuse merely compiling malicious program might delete entire file store many compromise positions possible including ruling io altogther allowing limited set benign operations file reading policy choice technical one consider 84 printing code far produced code order splice module compiled sometimes want write programs generate haskell program put file rather compiling happy parser generator example existing program follows paradigm indeed pedagogic reasons extremely convenient display code generated rather compile end libraries provided make exp dec etc instances class show instance show exp instance show dec etc display code constructed computational framework supply function runq q io thus compile run program e runq sel 1 output x case x abc pro duced notice absence splicing sel defined section 4 implementing q far treated q monad abstractly easy im plement io monad augmented environment newtype q environment contains mutable location serve name supply gensym source location toplevel splice invoked evaluation reifylocn compilers symbol table support implementation reifydecl reifyfixity reifytype commandline switches support reifyopt things could course readily added 9 quasiquotes lexical scoping introduced quasiquote notation informally time pay direct attention quasiquote notation convenient shorthand representing haskell programs lexically scoped precisely every occurrence variable bound value lexically scope occurrence site original source program template expansion obvioussounding property lisp community calls hygienic macros 10 metaprogramming setting nearly easy implement one might think quasiquote notation implemented top quotation monad section 6 saw variables bound inside quasiquotes must renamed avoid inadvertent capture cross2a example variables bound outside quasiquotes 91 crossstage persistence possible splice expand expression contains names scope splice occurs need take care happens consider rather contrived example module genswap consider call genswap another module module foo import genswap splice genswap 45 expand cannot expand swap 45 module foo plain swap would bind boolean value defined foo rather swap defined module splice expand tswap 45 using haskells qualifiedname notation tswap scope foo genswap imported foos name space import genswap instead expand splice tswap 45 using original name tswap original names first discussed section 81 context representations returned reify solve similar problem part code representations must unambiguously refer global toplevel variables may hidden scopes representations may used extension haskell template haskell uses implement static scoping across metaprogramming extensions accessible ordinary part haskell example one cannot write mmap f 123 ability include generated code value variable exists compiletime special name crossstage persistence requires care implement correctly seen happens toplevel variables swap nested variables require different treatment particular consider status variable x free quotation swap x unlike swap x toplevel binding module indeed nothing xs type known module com piled way give original name since value vary every call genswap crossstage persistence kind variable qualitatively dif ferent requires turning arbitrary values code example compiler executes call genswap 45 passes value 45 genswap latter must return data structure type exp app var tswap tup lit int 4 lit int 5 somehow code genswap lift value exp show happens genswap becomes quasiquotes translated away lift x return app var tswap take advantage haskells existing typeclass mecha nism lift overloaded function defined type class class lift lift expr instances lift allow programmer explain lift types choice expr example ones provided part template haskell instance lift int instance lift alift b lift ab taking advantage type classes way requires slight change typing judgment var figure 2 stage b inside quasiquotes variable x bound outside quasi quotes top level type checker must inject type constraint lift x type omitted mention type constraints figure 2 real system course summarize lexical scoping means free variables swap x toplevel quasiquote right hand side definition genswap statically bound clo sure need scope application site inside module foo case indeed quite different value name may scope nothing terribly surprising simply lexical scoping action precisely behaviour would expect genswap ordinary function 92 dynamic scoping occasionally programmer may instead want dynamic scoping strategy generated code template haskell express dynamic scoping like splice site genswapdyn 45 expand swap 45 swap bind whatever swap scope splice site regardless scope definition genswapdyn behaviour sometimes useful template haskell clearly flagged use stringquoted variable name var swap unquoted variables lexically scoped open question whether power desirable easily removed making var take gensym return abstract type instead string 93 implementing quasiquote quasiquote notation explained terms original names syntax constructor functions use gensym return lift operation one think translation process term within quasiquotes another term figure 3 makes translation precise expressing translation ordinary haskell function skeleton handle enough constructors pat exp illustrate process omit many others interest brevity main function tre translates expression inside quasi quotes first argument environment type venv ignore couple paragraphs given term exp call cl construct another term exp evaluates genswap example compiler translates genswaps body swap x executing translation function tre arguments tre cl app var swap var x result call exp app app var app app var var str tswap app var lift var x printed concrete syntax app var tswap lift x wed expect quasiquoted swap x expand quasiquotes translated environment cl tells tre treat swap x differently capturing translation process haskell function write tre cl app b trans trans b tre cl cond x z trans x trans trans z tre cl simple pattern capture tre cl app cl ab tre cl cond x cl xyz tres venv exp exp tres cl es map tre cl es rep string exp exp apps f apps f return environment cl venv section 91 discovered variables need treated differently depending bound environment records information used tre decide translate variable occurrences string varclass data modname lifted bound varclass variable v follows tre cl var case cl bound rep var var lifted rep lift var orig mod rep var str mods tre cl elitint tre cl app f cl fx tre cl tup cl es tre cl lam ps ps cl e tre cl esc tre cl br nested brackets allowed tres venv exp exp tres cl es map tre cl es copy venv exp exp copy cl var copy cl lit c lit c copy cl app f cl f copy cl x copy cl lam ps ps copy cl e copy cl br cl e trp pat statement pat exp decpat trp p pvar rep pvar var ps ps trps pat statement pat exp decpat figure 3 quasiquote translation function trexp orig means v bound top level module v original name lifted means v bound outside quasiquotes top level translation function generate call lift type checker later ensure type v class lift bound means v bound inside quasiquotes alpharenamed three cases reflected directly case var tre figure 3 need auxiliary function trp translate patterns trp pat statement pat exp decpat first part pair returned trp list statements representing gensym bindings generated translation second part pair pat representing alpharenamed pattern example translating patternvariable x get one binding statement x gensym x result pvar x trp hand look lam case tre lambda expression f x f x wish generate local binding preserves scope quoted lambda f gensym f lam pvar fpvar x app var f var x bindings f gensym f x gensym x renamed patterns pvar fpvar x bound metavariables ss1 xs call trps ps assembled body app var f var x generated recursive call tre new expression returned last interesting case esc case consider example translation tre translates follows tup f gensym f lam pvar f var f f gensym f lam pvar fptup pvar xpvar app app var f var w notice body splice w transcribed literally translated code w copy function looking copy interesting case reach nested quasiquotation resort back tre example given code transformer f quasiquoted term nested quotations within escape x gensym x lam pvar x tup f var xlit int 5 related work 101 c templates c elaborate metaprogramming facility known templates 1 basic idea static compiletime computation takes place entirely type system c template class considered function whose arguments either types integers thus factorial7 returns type one extract integer result returning struct selecting conventionallynamed member thus factorial7ret type system rich enough one construct manipulate arbitrary data structures lists trees etc type system use computations control objectlevel code gen erated widely recognized typesystem computation language simply extraordinarily baroque functional language full ad hoc coding tricks conventions fact c templates widely used strong evidence need thing barriers use considerable believe template haskell takes principled approach task particular static computation language dynamic language new programming idiom required first think idea course lisp community years discuss next 102 scheme macros lisp community taken template metaprogramming seriously twenty years 11 modern scheme systems support elaborate towers language extensions based entirely macros early designs suffered badly namecapture prob lem problem solved evolution hygienic macros 10 4 dybvig hieb bruggemans paper excel lent selfcontained summary state art 7 differences vocabulary worldview combined subtlety material make quite difficult give clear picture differences scheme approach immediatelyobvious difference template haskell statically typed expansion afterwards scheme macro expanders sort static type system however reports staging errors beyond three pervasive ways scheme system powerful less tractable scheme admits new binding forms consider macro call suitablydefined macro foo might require first argument variable name scopes second ar gument example call foo might expand much complexity scheme macros arises ability define new binding forms way template haskell much clumsily hand least makes clear occurrence var k lexically scoped source program declaration splice splice e bind variables declaration splices occur top level outside quasi quotes situation tractable scheme macros special binding form definesyntax call site syntactic baggage instead macro call identified observing token function position bound definesyntax template haskell special syntax definition site template functions ordinary haskell functions splice required call site interesting tradeoff template haskell macros completely higherorder first class like function passed arguments returned results partially applied constructed anonymous lamb das scheme macros pretty much first order must called name bawden discussed firstclass macros 2 scheme admits side effects complicates everything mutable value instantiated move compiletime runtime shared haskell free complications 103 metaml derivatives goals metaml 16 14 13 template haskell differ sig nificantly many lessons learned building metaml influenced template haskell design important features migrated metaml template haskell include use template quasiquote notation means constructing object programs typesafety program fragment ever executed context typechecked type checking constructed program fragments happens compiletime static scoping objectvariables including alpha renaming bound objectvariables avoid inadvertent capture crossstage persistence free objectvariables representing runtime functions mentioned objectcode fragments correctly bound scope code created used 1031 metaml also significant difference template haskell metaml differences follow different assumptions metaprogramming systems used following assumptions used design template haskell differ strongly metamls users compute portions program rather writing pay runtime overhead hence assumption exactly two stages compiletime runtime metaml code built executed even runtime template haskell code meant compiled metacomputation happens compiletime code represented algebraic datatype hence amenable inspection case analysis appears first odds staticscoping quasiquotation mechanisms shown accomplished rather interesting way using monads everything statically typechecked checking delayed last possible moment using strategy justintime type checking allows powerful metaprograms written without resorting dependent types handwritten code reifiable ie data representing obtained manipulation runtime function data type definition reified ie data structure representation obtained inspected compiletime functions quasiquotes metaml indicate boundary stages execution brackets run metaml akin quote eval scheme template haskell brackets indicate boundary compiletime execution runtime execution one main breakthroughs type system metaml introduction quasiquotes respect scoping typing metaml code generating program typecorrect programs generates 16 property crucial generation step happens runtime late start reporting type errors however security comes price metaml cannot express many useful programs example printf example section 2 cannot typed metaml type call printf depends value string argument one way address problem using dependent type system approach distinct disadvantages start programmer would burden writing function transforms format string type type system becomes much complicated explain template haskell second stage may give rise type errors still occur compile time situation much less serious runtime code generation contribution current work development semantics quasiquotes monadic computations allows quasi quotes exist pure language without side effects process generating fresh names encapsulated monad hence quasiquotes referentially transparent 1032 metaocaml metaocaml 3 staged ml implementation built top ocaml system like metaml runtime code generation sys tem unlike metaml compiler rather interpreter generating compiled bytecode runtime demonstrated impressive performance gains staged programs non staged counterparts translation quasiquotes manner preserves scopingstructure quoted expression first implemented metaocaml 1033 macroml macroml 8 proposal add compiletime macros ml language macroml demonstrates even macros implement new binding constructs given precise semantics staged programs macros strongly typed macroml allows introduction new hygenic local binders macroml supports generative macros macros limited constructing new code combining code fragments cannot analyze code fragments 1034 dynamic typing approach justintime typechecking roots earlier study 15 dynamic typing staged typeinference work well template haskell typing code fragments split stages template haskell code finally typechecked toplevel splice points splice state c work code type checked splice points addition code construction splice point typechecking runtime activi ties significant effort placed reducing runtime overhead typechecking implementation small prototype read template haskell perform compiletime execution throes scaling prototype full implementation embodying template haskell extension glasgow haskell compiler ghc ghc implementation fully supports separate compilation deed compiling module functions defined modules compilied earlier executed compile time rea son execute function defined compiler would need compile function functions calls way executable code even typechecking parts compiletime function invoked compiler finds previouslycompiled executable dynamically links modules packages imports running com piler module consisting completely metafunctions need linked executable built final link step although ghc make yet clever enough figure work design represents work progress hope provide working implementation work driven directly experiences real users meanwhile many avenues already know want work important exception reifying data type defini tions said little userdefined code manipulation optimization one advertised goals well get yet know confusing error messages template haskell given may arise code programmer see least possible display code already found one often wants get earlier type security additional documentation saying expr whose type int like metamls type expect add parameterised code types expr int using expr indicate type statically known c templates scheme macros lighterweight syntax calling macro indeed programmer may need aware macro involved interesting tradeoff discussed briefly section 102 lot said reducing syntactic baggage call site speculative ideas inferring splice annotations acknowledgments would like particularly thank matthew flatt several long conversations explored relationship template haskell scheme macros errors comparison two remain also thank magnus carlsson fergus henderson tony hoare dick kieburtz simon marlow emir pasalic haskell workshop referees helpful comments drafts work would also like thank students class cse583 fundamentals staged computation winter 2002 participated many lively discussions uses staging especially bill howe whose final project motivated tim sheard begin work work described supported nsf grant ccr 0098126 mj murdock charitable trust department defense r modern c bytecode compiled macros work functional unparsing technical overview generic haskell syntactic abstraction scheme macros multistage computations typesafe derivable type classes hygienic macro expansion special forms lisp impact economics compiler optimiza tion accomplishments research challenges meta programming introduction multistage programming using metaml tr macros work syntactic abstraction scheme multistage programming explicit annotations dynamic typing staged type inference hygienic macro expansion firstclass macros types impact economics compiler optimization macros multistage computations accomplishments research challenges metaprogramming special forms lisp ctr andy gill introducing haskell equational reasoning assistant proceedings 2006 acm sigplan workshop haskell september 1717 2006 portland oregon usa bjrn bringert anders hckersten conny andersson martin andersson mary bergman victor blomqvist torbjrn martin student paper haskelldb improved proceedings 2004 acm sigplan workshop haskell p108115 september 2222 2004 snowbird utah usa walid taha patricia johann staged notational definitions proceedings second international conference generative programming component engineering p97116 september 2225 2003 erfurt germany sava krsti john matthews semantics reflect language proceedings 6th acm sigplan international conference principles practice declarative programming p3242 august 2426 2004 verona italy gregory neverov paul roe towards fullyreflective metaprogramming language proceedings twentyeighth australasian conference computer science p151158 january 01 2005 newcastle australia sheard languages future companion 19th annual acm sigplan conference objectoriented programming systems languages applications october 2428 2004 vancouver bc canada martin sulzmann meng wang aspectoriented programming type classes proceedings 6th workshop foundations aspectoriented languages p6574 march 1313 2007 vancouver british columbia canada ralf lmmel simon peyton jones scrap boilerplate class extensible generic functions acm sigplan notices v40 n9 september 2005 louisjulien guillemette stefan monnier typesafe code transformations haskell electronic notes theoretical computer science entcs v174 n7 p2339 june 2007 bjrn bringert aarne ranta pattern almost compositional functions acm sigplan notices v41 n9 september 2006 marcos viera alberto pardo multistage language intensional analysis proceedings 5th international conference generative programming component engineering october 2226 2006 portland oregon usa ralf lmmel scrap boilerplate xpathlike combinators acm sigplan notices v42 n1 january 2007 lloyd allison programming paradigm machine learning case study bayesian networks proceedings 29th australasian computer science conference p103111 january 1619 2006 hobart australia tim sheard emir pasalic twolevel types parameterized modules journal functional programming v14 n5 p547587 september 2004 arthur baars doaitse swierstra typesafe self inspecting code proceedings 2004 acm sigplan workshop haskell september 2222 2004 snowbird utah usa syme leveraging net metaprogramming components f integrated queries interoperable heterogeneous execution proceedings 2006 workshop ml september 1616 2006 portland oregon usa amr sabry modeling quantum computing haskell proceedings acm sigplan workshop haskell p3949 august 2828 2003 uppsala sweden martin erwig zhe fu software reuse scientific computing program generation acm transactions software engineering methodology tosem v14 n2 p168198 april 2005 jerzy karczmarczuk structure interpretation quantum mechanics functional framework proceedings acm sigplan workshop haskell p5061 august 2828 2003 uppsala sweden james cheney scrap nameplate functional pearl acm sigplan notices v40 n9 september 2005 ralf lmmel simon peyton jones scrap boilerplate practical design pattern generic programming acm sigplan notices v38 n3 march stephanie weirich replib library derivable type classes proceedings 2006 acm sigplan workshop haskell september 1717 2006 portland oregon usa edwin brady kevin hammond verified staged interpreter verified compiler proceedings 5th international conference generative programming component engineering october 2226 2006 portland oregon usa murdoch j gabbay new calculus contexts proceedings 7th acm sigplan international conference principles practice declarative programming p94105 july 1113 2005 lisbon portugal maribel fernndez fabien fleutot historic functional objectoriented calculus proceedings 8th acm sigplan symposium principles practice declarative programming july 1012 2006 venice italy chiyan chen hongwei xi metaprogramming typeful code representation journal functional programming v15 n6 p797835 november 2005 sheard languages future acm sigplan notices v39 n12 december 2004 ralf hinze generics masses journal functional programming v16 n45 p451483 july 2006 martin erwig deling ren update calculus expressing typesafe program updates science computer programming v67 n23 p199222 july 2007 jim grundy tom melham john oleary reflective functional language hardware design theorem proving journal functional programming v16 n2 p157196 march 2006 judith bayard cushing nalini nadkarni michael finch anne fiala emerson murphyhill lois delcambre david maier componentbased enduser database design ecologists journal intelligent information systems v29 n1 p724 august 2007 rita loogen yolanda ortegamalln ricardo peamar parallel functional programming eden journal functional programming v15 n3 p431475 may 2005 paul hudak john hughes simon peyton jones philip wadler history haskell lazy class proceedings third acm sigplan conference history programming languages p1211255 june 0910 2007 san diego california
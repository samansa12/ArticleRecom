comparative study various nested normal forms objectrelational databases ordbs become popular industry important database designers produce database schemes good properties new kinds databases one distinguishing feature ordb tables may first normal form hence ordbs may contain nested relations along collection types help design process ordb several normal forms nested relations recently defined called nested normal forms paper investigate four nested normal forms nnf 20 nnf 21 nnf 23 nnf 25 respect generalizing 4nf bcnf reducing redundant data values design flexibility another major contribution paper provide improved algorithm generates nested relation schemes nnf 2 database scheme general type acyclic database schemes presenting algorithm nnf 20 algorithms four nested normal forms nested database schemes generate compared discovered given set mvds conflictfree nnf 20 inferior three nested normal forms reducing redundant data values however cases considered paper nnf 20 least good three nested normal forms b introduction objectrelational databases ordbs could alternative nextgeneration databases sbm98 hybrid approach sound based mature relational technology adding objectoriented features relational database ordb obtained since approach seems like natural extension relational database numerous relational commercial products already supporting many objectoriented features kim97 urm97 one distinguished feature ordb relation nested another relation thus nested relation since ordbs support nested relations imperative database designers able design nested databases good properties past numerous normal forms defined flat relations flat relation scheme satisfies certain normal form relations scheme enjoy properties normal form long time database designers using normal forms guides flat relational database design spirit numerous normal forms defined recently nested relations well mne96 oy87a oy89 rk87 rks88 among cited normal forms partition normal form pnf defined rks88 fundamental essence pnf basically states nested relation never distinct tuples agree atomic attributes either nested relation nested relation embedded within rks88 since basic property nested relations normal forms defined mne96 oy87a oy89 rk87 imply pnf guides database design normal forms used cautions database designers understand strengths weaknesses normal form order use intelligently example well known 4nf able remove redundancy caused fds however dependency preserving hand 3nf dependency preserving able remove redundancy caused fds cases knowing information like fact vital successful database design hence main purpose paper compare normal forms defined mne96 oy87a oy89 rk87 find strengths weaknesses particular investigate respect generalizing 4nf bcnf reducing redundant data values design flexibility addition also examine algorithms nested database schemes generate since algorithms normal forms investigated take opportunity provide general algorithm normal form defined mne96 ones gave me96 me98 turns another contribution paper would like recognize normal forms defined nested relations ones ly94 tss97 however included investigation normal form tss97 mainly dealing semantic issues opposed removing redundancy one ly94 based extended mvds makes hard compared others following avoid wordy abbreviate normal form defined mne96 called nested normal form nnf mne96 similarly normal form defined oy87a abbreviated nnf oy87a one defined oy89 nnf oy89 one defined rk87 nnf rk87 notice comparisons among nnf oy87a nnf oy89 nnf rk87 already done presented oy89 rk87 results reproduced paper organized follows section ii present basic definitions concepts normal forms formally compared section iii conclude section iv ii basic concepts terminology first present basic definitions definition normal forms presented nested relation schemes nested relations following definitions nested relation schemes nested relations scheme trees adapted mne96 however equivalent definitions concepts oy87a oy89 rk87 used well nested relation allows tuple component either atomic another nested relation may nested several levels deep 1 let u set attributes nested relation scheme recursively defined follows 1 x nonempty subset u x nested relation scheme set attributes x 2 x x 1 pairwise disjoint nonempty subsets u r 1 rn nested relation schemes x 1 respectively x r 1 rn nested relation scheme xx 1 dept chair prof hobby matriculation student interest cs turing jane skiing phd young chess soccer barker skiing ms adams skiing pat hiking phd lee travel math polya steve dance ms carter travel hiking skiing fig 1 nested relation definition 2 let r nested relation scheme nonempty set attributes z let domain attribute 2 z denoted doma nested relation r recursively defined follows 1 r form x x set attributes fa 1 g n 1 r nested relation r possibly empty set functions function 1 maps j element 2 r form x r 1 rm set attributes fa 1 g n 1 r nested relation r r possibly empty set functions ft 1 p g function 1 p maps j element nested relation r k 1 k function nested relation r nested relation scheme r nested tuple r 2 several observations made definitions 1 2 first flat relation schemes also nested relation schemes second two distinct embedded nested relation schemes attribute common example nested relation scheme c b c allowed third paper every nested relation pnf rks88 example 1 figure 1 shows nested relation scheme dept chair prof hobby matriculation student interest contains two nested tuples embedded nested relation also contains nested tuples example young fchess soccerg barker fskiingg nested tuples embedded nested relation scheme student interest notice required pnf satisfied thus values atomic attributes dept chair differ embedded nested relation atomic values differ 2 definition 3 let r nested relation scheme let r nested relation r total unnesting r recursively defined follows 1 r form x x set attributes r total unnesting r 2 r form x r 1 rn x set attributes r 1 n total unnesting exists nested tuple u 2 r tuple total unnesting ur example 2 figure 2 shows total unnesting nested relation figure 1 2 dept chair prof hobby matriculation student interest cs turing jane skiing phd young chess cs turing jane skiing phd young soccer cs turing jane skiing phd barker skiing cs turing jane skiing ms adams skiing cs turing pat hiking phd lee travel math polya steve dance ms carter travel math polya steve dance ms carter skiing math polya steve hiking ms carter travel math polya steve hiking ms carter skiing fig 2 total unnesting nested relation fig 1 graphically represent nested relation scheme tree called scheme tree scheme tree captures logical structure nested relation scheme explicitly represents set mvds definition 4 scheme tree corresponding nested relation scheme r recursively defined follows 1 r form x single node scheme tree whose root node set attributes x 2 r form x r 1 rn root node set attributes x child root root scheme tree corresponding scheme tree nested relation scheme r onetoone correspondence scheme tree nested relation scheme along definition nested relation scheme impose several properties scheme tree let scheme tree denote set attributes asett observe atomic attributes nested relation scheme level nesting constitute node scheme tree observe since definition 1 requires nonempty sets attributes every node consists nonempty set attributes furthermore since sets attributes corresponding nodes pairwise disjoint include attributes nodes pairwise disjoint union asett let n node notationly ancestorn denotes union attributes ancestors n including n similarly descendentn denotes union attributes descendants n including n scheme tree edge v w v parent w denotes mvd ancestorv notationly use mvdt denote set mvds represented edges construction mvd mvdt satisfied total unnesting nested relation since fds also interest use fdt denote set fds equivalent fds given set fds mvds set attributes u asett u xy asett example 3 figure 3 shows scheme tree scheme nested relation figure 1 figure 3 also gives set attributes asett set mvds mvdt observe mvds mvdt satisfied unnested relation figure 2 2 given set mvds fds set attributes u scheme tree asett u asett may proper subset u however may imply mvds fds hold theorem 5 fag77 mvd x holds respect x asett exists set attributes prof hobby matriculation student interest matriculation student interest matriculation student interest dept chair prof hobby dept chair prof matriculation student interest dept chair prof matriculation student interest dept chair prof matriculation student interestg fig 3 scheme tree asett mvdt nested relation scheme fig 1 student interestg fstudent interest prof hobby hobbyequipment hobby hobbyequipmentg fig 4 given constraints set attributes z u xy asett implies x u example 4 figure 4 shows given set attributes u given set fds f u given set mvds u fds f hold scheme tree figure 3 mvds hold particular neither hobby hobbyequipment prof hobby hobbyequipment holds since hobby hobbyequipment asett hold although prof hobby hold observe implied f u 2 b conflictfree sets mvds acyclic database schemes researchers claimed realworld sets mvds conflictfree acyclic database schemes sufficiently general encompass realworld situations bfmy83 sci81 fact conflictfree sets mvds acyclic database schemes numerous desirable properties bfmy83 therefore would like examine normal forms respect conflictfree sets mvds acyclic database schemes definitions presented mvd x x disjoint splits two attributes b one u gamma xy u set attributes set mvds splits b mvd splits mvd set mvds splits set x x u splits two distinct attributes x let set mvds fds u lhs denotes set lefthand sides members usual depx denotes dependency basis x partition u gamma x definition 5 set mvds conflictfree 1 split element lhs 2 every x 2 lhs every 2 lhs conflictfree set mvds allows unique 4nf decomposition bfmy83 shall use fact proof lemma 6 database scheme set attributes u set relation schemes relation scheme r subset u n notice every database scheme r corresponds unique join dependency namely 1r mai83 database scheme r acyclic join dependency 1r equivalent conflictfree set mvds bfmy83 also r acyclic r join tree bfmy83 definition database scheme join tree r tree r node 1 edge r r j labeled set attributes r r j 2 every pair r r j r 6 r j every r r j edge along unique path r r j includes label possibly among others 2 let set mvds set attributes u notationly use denote closure intersection property whenever mvds x z z implied z disjoint x furthermore intersection property implied join dependency 1r bfmy83 shall use property proof theorem 6 c nnf mne96 present nnf mne96 definition 7 let u set attributes let set mvds u f set fds u let scheme tree asett u nnf mne96 respect f following conditions satisfied 1 set mvds fds hold respect f equivalent mvdt 2 nontrivial fd x holds respect f respect f na node contains 2 nnf oy 87a definition reduced mvds fundamental nnf oy87a nnf oy89 nnf rk87 adapted oy87a oy87b definition 8 let u set attributes let set mvds u x w 1 trivial 2 leftreducible x 0 ae x x 0 w 3 rightreducible w 0 ae w x w 0 nontrivial mvd 4 transferable x 0 ae x x 0 mvd x w reduced nontrivial leftreduced nonleftreducible rightreduced nonright reducible nontransferable 2 let 1 2 sets mvds set attributes u 1 cover 2 definition 9 let u set attributes let set mvds u let x w reduced mvd g elements lhs called minimal cover mmin subset gamma proper subset mmin cover 2 nnf oy87a disallows several configurations scheme trees achieve goal transitive dependencies fundamental keys scheme tree defined let set mvds set attributes u let scheme tree asett u say implies mvdt asett mvd implies mvd x z u assuming implies mvdt asett let v w edge suppose key x exists z 2 depx descendentw exist sibling nodes w 1 wn w hold respect w transitive redundant respect x case x descendentw asett transitive dependency asett let v subset u set fundamental keys v denoted fk v defined fk v fds given nnf oy87a uses mvds counterparts fds given fd replaced set mvds fx j 2 g ready present nnf oy87a definition 10 let u set attributes let set mvds fds u let set g let scheme tree asett nnf oy87a respect 1 implies mvdt asett 2 edge v w ancestorv descendentw asett left rightreduced respect 3 node n key x n transitive redundant respect x 4 root key node n fk descendentn fds given normal form uses envelope sets defined yo92 handle mvds fds together hence necessary consider mvds counterparts fds given set mvds fds authors first derive envelope set e normal form defined terms e envelope set e defined fx w j x 2 lhs w 2 depx x 6 wg notice authors also redefine transitive dependencies fundamental keys normal form affect conditions 3 4 new definition fundamental keys set attributes v denoted defined fv 2 lhs e min g new definition transitive dependencies lengthy involved however furthermore since use new definition transitive dependencies paper reproduce definition 11 let u set attributes let set mvds fds u let e envelope set let scheme tree asett u nnf oy89 respect 1 e implies mvdt asett 2 edge v w ancestorv descendentw asett left rightreduced respect e 3 node n key x e n transitive redundant respect x 4 root key e edge v w imply ancestorv leaf node 2 f nnf rk87 fds given normal form uses integrated approach described bk86 handle mvds fds together hence necessary consider mvds counterparts fds given set mvds fds authors first derive another set 0 mvds normal form defined mainly terms 0 notice following x denotes closure set attributes x nnf rk87 uses original definition fundamental keys section iid definition 12 let u set attributes let set mvds fds u let 0 set g let scheme tree asett u nnf rk87 respect 1 0 implies mvdt asett 2 edge v w ancestorv descendentw asett left rightreduced respect 0 3 node n key x 0 n transitive redundant respect x 4 root key 0 lhs 0 node n fk descendentn normalization specified remove redundancy caused fds contains node n x n x ae n replace n n 0 n 0 ae n n 0 n n 00 ae n 0 essence node n replaced one candidate keys defined usual sense ram98 sks99 2 iii comparison normal forms section compare normal forms respect generalizing 4nf bcnf reducing redundant data values nested relation providing flexibility nested relation schemes design furthermore also examine algorithms see generate nested relation schemes preserve set given mvds fds another contribution providing general algorithm nnf mne96 ones me96 me98 generalizing 4nf bcnf mentioned section iia flat relation schemes also nested relation schemes show nnf mne96 nnf oy87a nnf oy89 nnf rk87 imply 4nf respect given set mvds fds nested relation scheme actually flat furthermore normal forms also implies bcnf fds however converses results true nnf oy87a nnf oy89 nnf rk87 theorem 1 let u set attributes let set mvds fds u let single node scheme tree asett u nnf mne96 respect 4nf respect proof theorem 61 mne96 2 lemma 1 let u set attributes let set mvds u let z key x ae z exists v 2 depx z ae xv proof lemma 35 oy87b 2 lemma 2 let u set attributes let set mvds u let z key z 4nf respect proof let x ae z lemma 1 exists v 2 depx z ae xv hence x v split z every therefore z 4nf respect 2 theorem 2 let u set attributes let set mvds fds u let single node scheme tree asett u nnf oy87a respect also 4nf respect proof since single node scheme tree consists root condition 4 nnf oy87a root key set mvds defined definition 10 lemma 2 root 4nf respect definition clear root also 4nf respect 2 lemma 3 let u set attributes let set mvds fds u let e envelope set let r u r 4nf respect e r also 4nf respect proof proposition 42 yo92 2 theorem 3 let u set attributes let set mvds fds u let single node scheme tree asett u nnf oy89 respect also 4nf respect proof since single node scheme tree consists root condition 4 nnf oy89 root key e lemma 2 root 4nf respect e lemma 3 root also 4nf respect 2 theorem 4 let u set attributes let set mvds fds u let single node scheme tree asett u nnf rk87 respect also 4nf respect proof condition 4 nnf rk87 root k key 0 lhs 0 set mvds 0 defined definition 12 following k replaced one candidate keys namely since k key 0 lemma 2 k 4nf respect 0 show 4nf respect assume nontrivial mvd x holds respect implies mvd x z u claim nontrivial mvd holds k respect 0 x therefore k 4nf respect 0 contradiction first show x w holds k respect 0 since implies x z implies x z definition 0 holds k respect 0 next show x w nontrivial since x nontrivial holds neither candidate key therefore attribute 2 x 6 since 2 therefore 2 w since x 6 62 x similarly attribute b nontrivial k 2 however converses theorems 2 3 4 false following example shows example 5 let r ab relation scheme bg given set mvds fds trivially r 4nf respect however since contains trivial mvd sets mvds e 0 defined definitions 10 11 12 respectively contains trivial mvds thus definition 9 none sets mvds key hence r violates conditions 4 nnf oy87a notice fact nnf mne96 nnf oy87a nnf oy89 nnf rk87 imply bcnf fds given follow immediately theorems 1 2 3 4 example 5 sounds trivial however implications cannot underestimated first clearly equivalent empty set mvds vacuously conflictfree hence nnf oy87a nnf oy89 nnf rk87 least current forms difficulties generating nested relation schemes respect conflictfree sets mvds second manytomany relationships two attributes one b example 5 arise naturally practice important normal form welldefined simple situations elaborate subject section iiic conclude subsection stating nnf mne96 superior nnf oy87a nnf oy89 nnf rk87 generalizing 4nf bcnf prof articletitle publicationlocation steve programming c usa programming ada hong kong pat programming ada usa hong kong prof articletitle publicationlocation steve programming c usa steve programming ada usa steve programming c hong kong steve programming ada hong kong pat programming ada usa pat programming ada hong kong fig 5 nested relation redundancy caused mvd b reducing redundant data values subsection normal forms investigated respect reducing redundant data values nested relation two cases considered given set mvds conflictfree given set mvds conflictfree b1 non conflictfree sets mvds terminology needed given set mvds fds set attributes u scheme tree asett u consistent mvd x mvdt implies mvd x z u scheme tree consistent given mvds fds otherwise scheme implies mvd follow given mvds fds hence consistent scheme trees considered paper theorem 5 let u set attributes let set mvds fds u let scheme tree asett u consistent nnf mne96 respect every nested relation r r redundancy caused mvd fd implied holds proof follow immediately theorems 51 52 mne96 2 neither nnf oy87a nnf oy89 nnf rk87 property following example shows example 235 mne96 example publicationlocationg let articletitle prof g given set mvds consider nested relation total unnesting figure 5 redundant data values nested relation example last hong kong value publicationlocation redundant covered based mvd articletitle publicationlocation data values nested relation deduce must hong kong notice conflictfree violates condition 2 definition 5 2 scheme tree violates condition 1 condition 2 nnf mne96 lemmas 52 53 54 mne96 exists nested relation redundancy caused mvd holds prof articletitle prof publicationlocation steve programming c steve usa programming ada hong kong pat programming ada pat usa hong kong fig 6 decomposition nested relation fig 5 scheme nested relation figure 5 violates condition 1 nnf mne96 example 6 designed show redundancy theorem 5 nested relation scheme figure 5 violates nnf mne96 however stated mne96 nested relation scheme satisfies nnf oy87a nnf oy89 nnf rk87 example see nnf oy87a nnf oy89 nnf rk87 allow nested relations redundancy satisfy nnf mne96 nested relation figure 5 needs decomposed two smaller nested relations shown figure 6 number data values however increases 9 11 therefore decomposing nested relation figure 5 cannot remove redundant data values thus cannot reduce number data values hand nnf oy87a nnf oy89 nnf rk87 accept nested relation figure 5 without requiring decomposed general paths scheme tree separated satisfy nnf mne96 given set mvds conflictfree beneficial separate paths situations example 6 shows hand stated bk86 rarely satisfactory solution normalization respect non conflictfree sets mvds notice fd example 6 however even fds added example 6 arguments still hold suppose add attribute dept fd prof dept example 6 also modify nested relation scheme figure 5 adding dept child root prof figure 1 steve professor mathematics department pat professor computer science department new scheme tree still satisfies nnf oy87a nnf oy89 still violates nnf mne96 furthermore modified nested relation nested relation figure 5 redundant data values interestingly given set mvds intersection property conditions 1 2 nnf oy87a imply condition 3 nnf oy87a theorem u set attributes let set mvds u intersection property let scheme tree asett u satisfies conditions 1 2 nnf oy87a respect also satisfies condition 3 nnf oy87a respect proof suppose satisfy condition 3 nnf oy87a shall derive contradiction assume edge v w key x exists z 2 depx descendentw assume also sibling nodes w 1 wn w hold respect ancestorv ancestorv otherwise ancestorv descendentw asett leftreduced respect thus violates condition 2 nnf oy87a hence x 6 ancestorv since satisfies condition 1 implies mvd ancestorv z 0 u descendentw nodes pairwise disjoint disjoint z intersection property proper subset ancestorv thus ancestorv descendentw asett leftreduced respect contradiction 2 conclude subsection stating nnf oy87a nnf oy89 nnf rk87 superior nnf mne96 reducing redundant data values respect non conflictfree sets mvds addition given set mvds intersection property condition 3 nnf oy87a redundant implies given set mvds conflictfree need check condition 3 nnf oy87a since conflictfree sets mvds intersection property bfmy83 b2 conflictfree sets mvds shall show scheme tree nnf oy87a respect conflictfree set mvds also nnf mne96 converse result however true furthermore scheme tree consistent conflictfree set mvds path defined 4nf respect nesting structure able squeeze redundant data values since given fd nnf oy87a nnf oy89 nnf rk87 equivalent therefore results also hold nnf oy89 nnf rk87 notice consider fds instead fds considered section iiid given scheme tree leaf node v ancestorv called path set paths denoted patht notice definition path different one mne96 path defined list nodes v root however defining path ancestorv convenient paper lemma 4 let u set attributes let conflictfree set mvds u let scheme tree asett u nnf oy87a respect patht 4nf respect proof stated conclusions oy87a 2 lemma 5 let u set attributes let scheme tree asett u mvdt imply mvd x asett x splits path proof lemma 51 mne96 2 lemma u set attributes let conflictfree set mvds u let scheme tree asett u consistent let set mvds implied hold patht 4nf respect mvdt implies asett proof mentioned section iib conflictfree set mvds allows unique 4nf decomposition bfmy83 since patht 4nf respect conflictfree consistent patht unique 4nf decomposition asett respect suppose mvdt imply mvd x mvdt imply x lemma 5 splits path thus patht unique 4nf decomposition asett respect contradiction 2 notice given set mvds conflictfree lemma 6 hold demonstrated example 6 theorem 7 let u set attributes let conflictfree set mvds u let scheme tree asett u nnf oy87a respect also nnf mne96 respect proof since given fd need show satisfies condition 1 nnf mne96 since condition 1 nnf oy87a consistent thus set defined condition 1 nnf mne96 implies mvdt asett lemma 4 patht 4nf respect lemma 6 mvdt implies set defined condition 1 nnf mne96 asett 2 theorem 7 says given set mvds conflictfree nested relation scheme acceptable nnf oy87a also acceptable nnf mne96 converse theorem 7 however true demonstrated example 5 theorem 1 notice given set mvds example 5 equivalent empty set mvds clearly conflictfree lemma 7 let u set attributes let conflictfree set mvds u let scheme tree asett u nnf mne96 respect patht 4nf respect proof assume path p patht p 4nf respect nontrivial mvd x holds p since given fd mvdt imply condition 1 nnf mne96 2 given fd main cause problem examples 6 given set mvds conflictfree set mvds conflictfree may one possible 4nf decomposition hence even path scheme tree 4nf may still mvds hold follow mvdt mvds ones cause redundancy therefore even paths scheme tree separated satisfy nnf mne96 redundant data values remain problem happen conflictfree sets mvds lemmas 4 6 scheme tree nnf oy87a mvds hold follow mvdt thus nesting structure able squeeze redundant data values lemmas 6 7 nnf mne96 also property since given fd nnf oy87a nnf oy89 nnf rk87 equivalent nnf oy89 nnf rk87 property example 7 let hobbyequipmentg given set mvds notice conflictfree consider nested relation figure 7 scheme violates nnf mne96 nnf oy87a nnf oy89 nnf rk87 one paths namely prof hobby hobbyequipment 4nf respect due violation redundant data values nested relation see equipments hiking stored twice nested relation decompose nested relation two smaller nested relations figure 8 redundant data values removed notice every path two nested relation schemes figure 8 4nf nested relation schemes satisfy nnf mne96 nnf oy87a nnf oy89 nnf rk87 2 conclude subsection stating fd given nnf mne96 nnf oy87a nnf oy89 nnf rk87 able reduce redundant data values respect conflictfree sets mvds furthermore given fd nnf oy87a implies nnf mne96 respect conflictfree sets mvds results hold nnf oy89 nnf rk87 prof student hobby hobbyequipment pat lee hiking water bottle hat steve carter hiking water bottle hat dance dancing shoe costume chiming null null fig 7 nested relation redundancy caused mvd prof student hobby hobby hobbyequipment pat lee hiking hiking water bottle steve carter hiking hat dance dance dancing shoe chiming null costume fig 8 decomposition nested relation fig 7 c design flexibility show several examples illustrate flexible normal forms nested relation schemes design turns nnf mne96 allows greater flexibility nested relation schemes design nnf oy87a nnf oy89 nnf rk87 example 8 let us replace child b toy example 5 following three nested relation schemes child toy child toy toy child nnf mne96 vacuously choosing one use course depends application hand however since key mentioned example 5 nested relation schemes violate nnf oy87a nnf oy89 nnf rk87 notice manytomany relationships one child toy occur commonly 2 example 9 let hobbyequipmentg given set mvds notice conflictfree nested relation scheme allowed nnf oy87a nnf oy89 nnf rk87 hobby prof hobbyequipment since hobby key nested relation scheme data forced stored point view hobby fine application hand dictates notice nested relation scheme also satisfies nnf mne96 suppose need store data point view prof nested relation schemes needed prof hobby hobby hobbyequipment nested relation schemes satisfy nnf mne96 however since prof key prof hobby violates conditions 4 nnf oy87a nnf oy89 nnf rk87 2 turn example involves fds example 10 discussed mne96 scheme tree figure 3 nnf mne96 violates nnf oy87a nnf oy89 nnf rk87 several violations since rationale behind violations nnf oy89 nnf rk87 quite similar nnf oy87a focus nnf oy87a argue matriculation cannot inner node scheme tree consider set attributes descendentmatriculation equal fmatriculation student interestg student fk descendentmatriculation student key contained descendentmatriculation however since matriculation key therefore fk descendentmatriculation thus scheme tree violates subcondition condition 4 nnf oy87a moreover dept chair cannot root since dept chair key therefore scheme tree violates another subcondition condition 4 nnf oy87a work reader check two violations also apply nnf oy89 nnf rk87 2 observe examples 8 9 10 quite natural reasonable unlike example 6 examples easily created practical examples see conditions 4 nnf oy87a nnf oy89 problematic nnf rk87 inherits problem due limitations nnf oy87a nnf oy89 nnf rk87 restrict attribute clustering design flexibility conclude subsection stating nnf mne96 provides greater design flexibility three normal forms algorithms nested database schemes subsection first present algorithm generates scheme trees nnf mne96 acyclic database scheme set fds given fd embedded relation scheme given database scheme defined algorithm generalizes algorithms me96 me98 flacyclic database schemes considered fag83 acyclic database schemes consider paper however ffacyclic database schemes general type acyclic database schemes fag83 section iib numerous equivalent definitions ffacyclic database schemes presented avoid wordy however acyclic database scheme simply means ffacyclic database scheme paper presenting algorithm nnf mne96 shall compare algorithms normal forms nested database schemes generate addition assumptions given database scheme acyclic given fd embedded relation scheme given database scheme also assume relation scheme bcnf respect given fds assumptions justified follows first section iib already mentioned importance acyclic database schemes second stated fmu82 fds relevant data structuring embedded relation schemes given database scheme furthermore fds derived semantic data models use me96 me98 indeed embedded relationship sets roughly correspond relation schemes paper third stated me98 cases relation schemes small arity majority binary thus believe relation schemes practice bcnf d1 algorithm nnf mne96 present algorithm 1 algorithm generates nested relation schemes nnf mne96 example 11 consider set u attributes set mvds set f fds figure 4 save space abbreviate dept chair c prof p hobby h hobbyequipment e matriculation student interest notice f equivalent 1r f g step 1 join tree j r derived shown figure 9 initially nodes j unmarked step 21 suppose dc selected seed relation scheme r seed new scheme tree single path scheme tree tdc simply created dc node dc j marked entered l algorithm 1 input acyclic database scheme set nontrivial fds f f embedded r xy r furthermore r bcnf respect f without loss generality r subset another r j 6 j nested relation schemes nnf mne96 respect r f internal data structure join tree j r firstin firstout queue l relation schemes initially empty 1 use graham reduction derive j r mai83 begin graph nodes r 1 rn edge let r 0 r applying zero node removals time r 0 removed r 0 add edge r r j graph eventually added graph resulting graph j notice since may one possible reduction sequences acyclic database scheme may one join trees 2 unmarked node j 21 select unmarked node r seed j create single path scheme tree tr seed r seed mark r seed enter r seed l 22 l empty 221 let rm first marked relation scheme l remove rm l 222 unmarked neighbor ru rm j 2221 node n tr seed ru ancestorn several nodes satisfy conditions choose lowest one modify tr seed follows 22211 ancestorn otherwise create single path scheme tree tru ru gamma rm attach root tru child n 22212 mark ru enter ru l 3 scheme tree produced step 2 modified moving attribute asett nodes path appears long satisfies condition 2 nnf mne96 remains step 221 rm becomes dc one unmarked neighbor dp j node n step 2221 dc step 22211 p attached child dc dp marked entered l back step 221 rm becomes dp two unmarked neighbors ph sp j successively h become children p tdc ph sp marked entered l back step 221 rm becomes ph one unmarked neighbor since node n tdc ancestorn cannot extend path contains h back step 221 rm becomes sp two unmarked neighbors si sm j si node n step 2221 becomes child tdc sm node n step 2221 also since ancestorn put attribute node n thus node n becomes sm notice example order choosing unmarked neighbors step 222 make difference tdc unmarked node left j thus second iteration step 2 single path scheme tree created generated fig 9 join tree join dependency example 11 fig 10 join tree join dependency example 12 marked step 3 may choose move parent tdc algorithm 1 generated scheme tree figure 3 2 database scheme r example 11 flacyclic following example shows algorithm 1 able generate scheme trees nnf mne96 ffacyclic flacyclic database scheme example 12 let aceg join tree generated step 1 shown figure 10 suppose select abc seed relation scheme single path scheme tree tabc created step 21 ac b abc one unmarked neighbor ace later e becomes child ac tabc reader may verify cde aef cannot attached tabc second third iterations step 2 two single path scheme trees created cde aef respectively notice cde aef cannot appear scheme tree example neighbors join tree figure 10 2 concept closed set relation schemes crucial proof correctness algorithm 1 let database scheme set attributes u let r let r 2s r closed every r 2 r r k 2 r r k notice r acyclic closed set relation schemes r also acyclic bfmy83 also proof correctness algorithm 1 depends lemmas 8 10 well characterize set mvds set fds hold scheme tree generated algorithm 1 let 1r join dependency database scheme set attributes u 1r implies numerous mvds however every mvd implied 1r also implied mvd mvd1r mvd1r set mvds form 1f i2s1 r ng shown chapter 13 mai83 r acyclic mvd1r 1r equivalent lemma 8 let u set attributes let database scheme u let r let r 2s r closed set mvds hold respect 1r equivalent mvd1s proof let x mvd implied 1r x thus x x equivalent join dependency 1fxy x u gamma xy g 1r implies 1fxy x u gamma xy g r xy r hence r r xy r x u gamma xy g thus 1 every mvd x u x equivalent join dependency 1fxy x u gamma xy g 1r implies 1fxy r xy r implied mvd mvd1r implied mvd1s consider mvd v w mvd1s equivalent join dependency 1fvw v gamma vw g let us construct mvd implied 1r denoted 1fl rg initially add relation schemes r gamma either l set r set since closed l r always equal v thus 1r implies mvd v z u following g set fds w set attributes gw wg lemma 9 let database scheme let f set fds fd f embedded r 1r f implies fd x f implies proof lemma 1 gy84 2 lemma 10 let u set attributes let acyclic database scheme u let j join tree r let f set fds u fd f embedded r let j 0 connected subtree j let set nodes relation schemes j 0 let r 2s r set fds hold respect 1r f equivalent r proof lemma 9 1r nothing closures sets attributes ifpart obvious r 2 proceed onlyif part without loss generality assume righthand side every fd f single attribute first show w embedded relation scheme assume shall derive contradiction let rb relation scheme r gamma wb rb since j 0 connected unique node relation r u j 0 among nodes j 0 r u closest node rb condition 2 definition 6 r j 2 r j rb r u since wb therefore wb r u contradiction fd since x 2 xa derivation sequence z x using fds f let z following derivation sequence appears z v subsets implies every v subset thus proved embedded relation scheme proof done assume suppose p first attribute z since 2 q appears z 1 2 q 2 let ra relation scheme r embeds connected rap node j 0 z arranged way v p1 v q contain attributes p qgamma1 implies arrange z rap belong remaining connected subtree j 00 remove nodes j 0 j edges j incident nodes j 0 since j 0 connected subtree unique node r v j 0 among nodes j 0 r v closest node node j 00 show induction x basis since 1 2 rap j 00 rap 62 therefore condition 2 definition 6 induction assume x l every l p l q consider l 1 construction z v l1 p l x node j 0 v l1 ra l1 implies v l1 p l x since ra l1 node j 0 x condition 2 definition 6 x r v induction hypothesis x conclude since v q q embedded r q r q using reasoning possible show implied r lemma 11 let u set attributes let scheme tree asett u mvdt equivalent join dependency 1patht asett proof proposition 41 oy87a 2 lemma 12 nodes tr seed satisfy conditions step 2221 path proof assume two nodes n n 0 satisfy conditions ru implies rm neighbors j ru asettr seed since every given fd embedded relation scheme given database scheme ru force n n 0 path step 22211 2 following proof assume reader familiar chase described chapter 8 mai83 theorem 8 algorithm 1 correct proof obvious step 1 generates join tree given acyclic database scheme next show every tree generated algorithm 1 satisfies definitions 1 4 particular show nodes generated tree nonempty pairwise disjoint assumption relation scheme subset another relation scheme given database scheme also since ru rm neighbors derived join tree ru seed empty intersect asettr seed furthermore single path scheme trees generated steps 21 22211 thus empty node step 3 simply violate two definitions thus algorithm 1 generates trees satisfy definitions 1 4 obverse algorithm 1 generates scheme tree nodes connected subtree derived join tree since nodes connected subtree constitutes closed set relation schemes algorithm 1 generates scheme tree closed set relation schemes fact exactly purpose join tree created step 1 example fcde aefg example 12 closed set relation schemes thus cde aef cannot appear scheme tree purpose firstin firstout queue algorithm 1 however ensure scheme tree built level level next need characterize set mvds fds hold scheme tree generated algorithm 1 let closed set relation schemes constructed let r 2s r thus asett equal turns equivalent r 1s proof follows implies r given database scheme r acyclic closed acyclic thus mvd1s 1s equivalent however since closed lemma 8 therefore implies 1s consider reverse implication lemma 10 set fds equivalent r mvd definition r f imply mvd x z u r 2rr x us run chase tableau txz x z txz two rows r 1 r 2 r 1 xzcolumns bs elsewhere r 2 xu gamma xzcolumns bs elsewhere since r f imply x z u lemma 9 assume apply fds f b changed every r ag r ag statement also holds every using fds r instead fds f lemma 9 fds r strong enough ensure every r 2 r ag ag thus r imply x ready prove induction scheme tree generated algorithm 1 nnf mne96 induction size denoted jsj basis created step 21 mvdt set trivial mvds thus equivalent 1s trivial join dependency definition fdt equivalent r condition 1 nnf mne96 assumption every given relation scheme bcnf hence also satisfies condition 2 nnf mne96 step 3 patht remains thus still satisfies nnf mne96 induction assume statement true every closed set relation schemes r 1 jsj k consider 1 connected subtree j 0 defined let n k1 node j 0 exactly one neighbor j 0 denote scheme tree n k1 added ts gamman k1 scheme tree n k1 added ts goal show mvdt r 1s observe fdt equivalent r 2s f equivalent join dependency 1patht asett scheme tree hence 1s implies r path p patht r p therefore left show 1patht us run chase tableau t1s 1s notice t1s rows t1s gamman k1 tableau 1s gamma n k1 observe fdt gamman k1 fdt induction hypothesis 1patht gamman k1 consider adding n k1 ts gamman k1 lemma 12 one node n ts gamman k1 satisfies conditions step 2221 one path added ts gamman k1 paths contain n enlarged ancestorn changes done t1s using fds r equivalent fdt thus path p patht row r t1s p fc j ag therefore 1patht imply 1s thus mvdt imply 1s hence condition 1 nnf mne96 satisfied satisfies condition 2 nnf mne96 implied fact every given relation scheme bcnf conditions step 2221 remains thus still satisfies nnf mne96 2 b c 3fig 11 instance scheme abc d2 advantages fds first discuss fds used constructing large scheme trees thus big clusters data mvd b c scheme tree root b child c child b b c holds redundancy caused mvd easily seen instance abc figure 11 cover data f3 4g first nested tuple c tell must f3 4g using mvd b c data values abc nnf mne96 respect u b c neither nnf oy87a nnf oy89 nnf rk87 however additional fd b redundancy cannot happen example violates b since bvalue 1 associates two avalues 5 6 fact fd data instance satisfies mvd fd example redundancy abc nnf mne96 respect u dependencies b c b however abc satisfy nnf oy87a nnf oy89 nnf rk87 even presence fd b since nnf oy87a nnf oy89 take advantages fds opposed nnf mne96 definitions lead small scheme trees thus small clusters data particular removing partial dependencies defined conditions 2 nnf oy87a nnf oy89 regardless given fds main cause problem example scheme tree figure 3 partial dependencies respect nnf oy87a nnf oy89 consider edge student interest ancestorstudent descendentinterest leftreduced thus scheme tree violates condition 2 nnf oy87a work also show scheme tree violates condition 2 nnf oy89 edge student interest using reasoning ancestorprof descendenthobby also leftreduced respect nnf oy87a nnf oy89 remove partial dependencies cause data redundancy presence given fds figure 4 algorithms nnf oy87a nnf oy89 decompose necessary generate small scheme trees specific scheme tree p root h children p generated algorithms furthermore algorithm nnf rk87 also generate one scheme tree example way handle fds short nnf oy87a nnf oy89 nnf rk87 take full advantages fds constructing large scheme trees nnf mne96 d3 dependency preservation addition characterizing data redundancy another property interest nested database schemes dependency preservation subsection mainly focus nnf mne96 nnf oy89 algorithms definitions needed let set mvds fds set attributes u dependency preserving set f fds fd f embedded r 1r f equivalent u yo92 furthermore conditions defined extended conflictfree yo92 one interesting property among many others extended conflictfree set mvds fds u acyclic dependency preserving 4nf decomposition u respect proposition 51 yo92 using decomposition algorithm oy89 set scheme trees ft 1 tm g 1 generated given set mvds fds set attributes u according proposition 63 oy89 extended conflictfree acyclic dependency preserving decomposition u respect following theorem show algorithm 1 also property theorem 9 algorithm 1 generates nested database scheme dependency preserving respect extended conflictfree set mvds fds proof since extended conflictfree according proposition 51 yo92 equivalent 1r f r acyclic 4nf database scheme f set fds fd f embedded relation scheme r r 4nf implies r bcnf hence satisfies input requirements algorithm 1 assume algorithm 1 generates scheme trees 1 tm closed sets relation schemes 1 sm r construction algorithm consider running chase tableau t1r 1r theorem 8 mvdt equivalent r 2s j therefore mvdt 1 equivalent 1 f equivalent 1r f turn equivalent 2 thus given set mvds fds extended conflictfree decomposition algorithm oy89 algorithm 1 produce nested database scheme dependency preserving iv conclusions summarize results paper first nnf mne96 superior nnf oy87a nnf oy89 nnf rk87 generalizing 4nf bcnf second respect non conflictfree sets mvds nnf oy87a nnf oy89 nnf rk87 superior nnf mne96 reducing redundant data values addition condition 3 nnf oy87a redundant respect sets mvds intersection property third fd given given set mvds conflictfree nnf mne96 nnf oy87a nnf oy89 nnf rk87 able reduce redundant data values nnf oy87a nnf oy89 nnf rk87 imply nnf mne96 however nnf mne96 imply nnf oy87a nnf oy89 nnf rk87 fourth nnf mne96 provides greater design flexibility three normal forms fifth nnf oy87a nnf oy89 nnf rk87 take full advantages fds creating large scheme trees nnf mne96 finally sixth algorithms nnf mne96 nnf oy89 dependency preserving respect extended conflictfree sets mvds r desirability acyclic database schemes integrated approach logical design relational database schemes multivalued dependencies new normal form relational databases degrees acyclicity hypergraphs relational database schemes simplified universal relation assumption properties independent database schemas bringing objectrelational earth nfnr practical normal form nested relations theory relational databases transforming conceptual models objectoriented database designs practicalities using nnf transform conceptual data models objectoriented database designs normal form precisely characterizing redundancy nested relations new normal form nested relations reduced mvds minimal covers normalization nested relational databases database management systems design 1nf relational databases nested normal form extended algebra calculus nested relational databases database system concepts object normal forms dependency constraints objectoriented schemata oracle8 plsql programming unifying functional multivalued dependencies relational database design tr ctr emanuel grant rajani chennamaneni hassan reza towards analyzing uml class diagram models objectrelational database systems transformations proceedings 24th iasted international conference database applications p129134 february 1315 2006 innsbruck austria hai zhuge fuzzy resource space model platform journal systems software v73 n3 p389396 novemberdecember 2004 hai zhuge resource space model design method applications journal systems software v72 n1 p7181 june 2004 wai yin mok designing nesting structures userdefined types objectrelational databases information software technology v49 n910 p10171029 september 2007 sven hartmann sebastian link klausdieter schewe functional multivalued dependencies nested databases generated record list constructor annals mathematics artificial intelligence v46 n12 p114164 february 2006
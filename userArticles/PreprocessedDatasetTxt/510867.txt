efficient global register allocation minimizing energy consumption data referencing program execution significant source energy consumption especially dataintensive programs paper propose approach minimize energy consumption allocating data proper registers memory careful analysis boundary conditions consecutive blocks approach efficiently handles various control structures including branches merges loops achieves allocation results benefiting whole program computational cost solving energy minimization allocation problem rather low comparing known approaches quality results encouraging b introduction todays high demand portable electronic products makes low energy consumption important high speed small area computer system design even nonportable high performance systems lower power consumption design helps decrease packing cooling cost increase reliability systems 25 lot research done improving power consumptions various components computer systems 8 13 19 20 25 particular well recognized access dierent levels storage components register cache main memory magnetic disk diers dramatically speed power consumption 8 17 hence allocation variables program dierent storage elements plays important role toward achieving high performance low energy consumption 13 todays ic technology computer architecture memory readwrite operations take much time consume much power register readwrite operations 3 8 dataintensive applications energy consumption due memory access 5016 paper focus problem allocating variables program registers main memory achieve short execution time low energy consumption register allocation achieving optimal execution time program given system well known problem studied extensively general existing results divided two categories local register allocation 5 15 18 global register allocation 2 4 11 14 22 23 27 28 29 local register allocator considers code one basic block sequence code without branch time nds best allocation variables basic block achieve minimum execution time global allocator deals code containing branches loops procedure calls global register allocation problems general nphard 22 modeled graphcoloring problem 1 4 6 7 11 integer linear programming approaches heuristics proposed solve global register allocation problems 22 14 however optimaltime register allocations necessarily consume least amount energy 8 19 20 researchers recognized challenge proposed interesting approaches deal optimalenergy register allocation problem 9 13 25 chang pedram 9 gave approach solve register assignment problem behavioral synthesis process formulated register assignment problem minimum energy consumption minimum cost clique covering problem used maxcost ow algorithm solve memory allocation considered 9 gebotys 13 modeled problem simultaneous memory partitioning register allocation network ow problem ecient network ow algorithm applied nd best allocation variables basic block registers memory however work 13 applicable basic blocks paper extend work 13 investigating problem register memory allocation low energy beyond basic blocks consider programs may contain combination branches merges loops basis approach perform allocation block block carefully analyzing boundary conditions consecutive blocks able nd best allocation block based allocation results previous blocks way maintain global information make allocation decision benet whole program basic block approach applied dierent energy variable access models time complexity algorithm ob ln k b total number blocks ln k time complexity register allocation single block n variables k available registers function ln k either onlog n oknlog n okn 2 depending dierent energy access models used rest paper organized follows section 2 reviews energy models known approaches local register allocation low energy also give overview allocation approach works section 3 gives approach allocation branch control structure section 4 presents algorithm low energy register allocation merge structure control ow graph section 5 discuss treat loops get better register allocation results section 6 summarizes experimental results concludes discussions overview allocating variables dierent levels storage components usually done compiler many factors aect allocation results number techniques applied reduce number cycles needed execute program including instructions reordering loop unrolling paper assume optimization techniques applied program satisfactory schedule program already given 21 energy models known approaches set variables program consideration given schedule lifetime variable v basic block well dened denoted starting time v nishing time f v use vr resp vm represent set variables assigned k available registers resp memory furthermore let e wv energy consumed reading resp writing variable v resp memory e r wv energy consumed reading resp writing variable v resp registers v specied e r represents energy consumed one read resp write access memory e r r represents energy consumed one read resp write access registers denote total energy consumed given program e objective register allocation problem map variable v 2 v register les memory locations order achieve least energy consumption due data accesses minimize v2vr dierent energy models dierent data access models proposed literatures 5 8 9 13 20 depending particular models used calculation energy consumption varies one energy model static energy model se assumes references storage component consume amount energy 8 model like referencetime model accesses storage component take amount time matter value referenced data 9 20 authors proposed sophisticated energy model called activity based energy model ae capturing actual data conguration storage model energy consumed program related switched capacitance successive accesses data variables share locations switched capacitance varies dierent access sequences particular product hamming distance number bits two data items dier 10 measurements 9 total capacitance storage used represent switched capacitance two consecutive references whether data variable read sr multiple times mr dened written also eect overall energy estimation carlisle lloyd 5 presented greedy algorithm putting maximum number variables registers minimize execution time basic block signal read model approach also gives optimal energy consumption static energy model takes onlog n time quite easy implement multipleread case algorithm proposed 13 uses graph 2 edges worst case better graph model given 5 edges applying minimum cost network ow algorithm optimaltime solution also optimal energy solution obtained oknlog n time 5 rather okn 2 13 one see dierent models result dierent computational overhead computing energy consumption example aemr model comprehensive also computationally expensive one depending availability models architecture features system computational overhead one willing incur models may used energy consumption estimation therefore consider two energy models two variable access models paper activity based energy model consider register le access simplify problem formulation adopting activity based model memory simple extension algorithm discussed later paper model total energy consumption program calculated hamming distance v v j designates v j accessed immediately v v v j share register c r rw average switched capacitance register le reference vr operational voltage register le objective optimal energy allocation minimize objective function 2 single read multiple read models gebotys 13 formulated problem minimum cost network ow problem solution okn 2 complexity cost edge network ow problem dierent read models also dierent designs desirable allow variable assigned registers one time interval switched memory another time interval order minimize total number accesses memory called split lifetime 11 split lifetime model used graph model need accommodate cases split occurs hence 2 graph edges needed algorithm 5 okn 2 complexity 13 results discussed apply variables basic block ie piece straightline code real application programs may contain control structures branches merges loops merge case one block one parent blocks type control ows occurs instruction one entry point due branching looping subroutine calls consider register allocation program control structures one must deal variables whose lifetimes extend beyond one basic block straightforward way applying existing approaches programs would enumerate possible execution paths treat path piece straight line code two problems arise approach first number paths increases exponentially worst case number basic blocks increases secondly variable may dierent lifetimes dierent paths hence approach would computationally costly dicult obtain optimal allocation hand nding optimal allocation variables general program known computational intractable nphard problem 22 overview approach following outline heuristic approach nd superior solutions minimum energy register allocation problem avoid diculties encountered known approaches discussed use iterative approach handle programs containing non straightline code program modeled directed graph g node represents basic block given nature program corresponding graph always node whose indegree zero furthermore loop edges branch backwards identied topological order nodes g thus established removing edges branching backwards ease explanation generalize concept parent child used trees parent resp child block b block whose corresponding node g immediate ancestor resp descendent node corresponding b hence block may multiple parents blocks case merge may parent block case loop solve register allocation problem basic block topological order allocation variables within block based results parent blocks assignment variable current block must consider eect initial assignment furthermore allow allocation result block aect result parent blocks allowing allocation results propagate downwards without backtracking eliminate excessive computational cost yet obtain superior allocations main challenge handle variables whose lifetimes extend beyond basic block overall energy consumption program minimized made several observations help deal variables key idea set appropriate boundary conditions parent child basic blocks use conditions guide register allocation procedure within child basic blocks rst describe graph model used 13 introduce extensions handle variables beyond basic blocks consider basic block b g directed graph generalization interval graph associated b data variable whose lifetime overlaps execution duration b two nodes n v n f v introduced correspond starting time v v rst written nishing time f v v last read respectively note v either variable referenced b variable referenced bs descendents f b c e f nsa nsb nsc nsd nfa nfd figure 1 graph g basic block without considering blocks program several dierent types arcs used g first pair n v n f v connected arc v n f v dene rest arcs introduce concept critical set critical set c set variables overlapping lifetimes one another number variables set greater k number available registers pair c c i1 index ordering based scanning variables beginning end block b let set variables whose lifetimes minimum nishing time variables c maximum starting time variables c i1 note 0 contains variables whose lifetimes starting time b maximum starting time variables c 1 g set variables whose lifetimes minimum nishing time variables c g last critical set b nishing time b arc introduced n f u u 2 c n v intuitively arcs represent allowable register sharing among subsequent data references similar 13 source node nish node f introduced beginning end b respectively arcs used connect n v v 2 0 c 1 connect u 2 c g g f nodes f considered registers available beginning end block b example graph shown figure 1 solid lines correspond arcs associated variables b dash lines arcs introduced based c graph variable b c form rst critical set c 1 variable b form set 0 handle allocation beyond block boundary graph needs modied substantial modications existing approaches well new ideas proposed order eciently handle branch merge loop structures bc figure 2 four dierent allocation results crossboundary variable 3 register allocation branch structure section discuss detail algorithms register allocation branch structure two dierent energy models 31 beyond boundary allocation static energy model rst consider case single read allowed extend result multiple read case variable v dened block b 0 also read another block b lifetime v crosses boundary two blocks block b 0 parent block b p block b say v b p b algorithm computes allocation b p performs computation v cross boundary come block b make best allocation decision v b based allocation result v b p totally four dierent combinations allocation results v two consecutive blocks 1 v register b p b rr 2 v register b p memory b rm 3 v memory b p register b mr 4 v memory b p b mm shown figure 2 figure 2 solid line segments mean variable register dashed segments mean variable memory use convention throughout paper unless stated otherwise explicitly analyze energy consumption four cases rr rm mr mm rr case energy consumed v block b p e r w dened block b e r r read register totally energy consumed v two consecutive blocks r applying analysis three cases obtain amount energy consumed crossingboundary variable dierent blocks shown column rr rm mr mm table 1 local variable b written read block b energy consumed table 1 energy consumption dierent blocks dierent allocation results block r r r r local r local w e r r e r r e r r r e r r e r r b e r r e r assigned register local r memory local location consumes energy b p since exist b p energy consumed local variable b shown last two columns local r local table 1 table 1 easy see based allocation result b p best choice global variable b memory b p stay memory b achieve lowest energy comparing two columns corresponding situation v memory b p mr mm clear v memory b p assigned register cost energy assign memory b rlocal v register b p treated brand new local variable block b achieve optimal energy energy data block b b columns rr local r data diers e r r columns rm local total amount energy much larger dierence simple way treat kind global variable brand new local variable whose allocation determined block b turns assigned register b stay register uses b p treating v extends beyond boundary assigned register b p brand new variable b clearly approximation another way assign actual energy saving energy saved assigning variable register comparing assigning memory weight variable construct network ow use minimumcost network ow algorithms solve problem described 5 weighted case variable v also dened b read child b read grandchild even grandgrandchild b analysis kind variable analysis variable dened b p used b conclusion drawn allocation children blocks b rules execute local register allocation algorithm blocks program simple case time complexity allocation whole program obnlog n n largest number local variables basic block complex case time complexity obknlog n algorithm shown algorithm 1 discussed earlier section 2 variable program may read written case use graph model 5 modify weights algorithm 1 algorithm low energy register allocation static energy model input scheduled program blocks p g output register assignment every variable v program p denitions allocation result variable v block b b v 1 v register 0 v memory weightv weight variable v apply algorithm unweighted case 5 b 1 using simple way approximation variables v live b p b else v treated local variables end apply algorithm unweighted case 5 b else variables v live b p b read b else r end variables v live b p b read b else end variables written read b end variables written read b w e r end apply algorithm weighted case 5 b end table 2 weight global variables local variables b block global v register b p global v memory b p local associated certain graph edges specically assign energy saving assigning variable register weight variable current block b weight variable dened b h v e r e r total number read accesses v dened section 2 variable live parent block b p assigned register b p weight current block b h v e r otherwise allocated memory b p weight h v e r note weight energy saving v allocated register current block b since total energy accessing variabls memory xed basic block energy saved allocating variables registers less energy block consumes weight assignment summaried table 2 applying network ow approach 5 weighted intervals basic block one another get low energy allocation solution whole program obknlog n time splitting allowed graph model 5 allows register transfered longer sucient case use graph model described next section network ow approach presented 13 assign weights described table 2 use minimumcost network ow algorithm solve problem obkn 2 time 32 register allocation branches activitybased energy model handle allocation beyond block boundary approach decide register allocation block b based allocation result bs parent block b p depending variable assigned register prior entering b amount energy consumption variable b dierent therefore simply using single source represent registers available beginning b longer sucient generalize construction graph g b b parent least one child follows graphs root leave blocks simply special cases graph discuss variables referenced b introduce arcs nodes associated way discussed start nish nodes f b also maintained let starting nishing times block b b f b respectively variable v b whose starting resp nishing time earlier resp later starting use two end nodes n v n f v g associated arc av means v considered e f c npa nsc nfc f figure 3 graph g block b based allocation parent block b p graphs corresponding blocks lifetime v overlaps arcs nodes f dened ways discussed previous paragraphs furthermore introduce register set vrb contains variables residing registers completion allocation process block b note vrb becomes uniquely dened allocation process b completed size vrb jv rb j always less equal k number available registers expand g adding node n p v parent block b dicult see variables vrbp variables chance pass register locations variables b directly insert arc n p u n v v 2 dened previous paragraphs comparing generalized graph original graph one see k additional nodes k jd additional arcs used generalized graph figure 3 shows example graph g current block b assuming three available registers sometimes program may read variable v case introduce additional node n r v read v except last read additional arcs also introduced model possible register sharing variables due page limit omit discussion part given directed graph g b ready construct network ow problem associated g let xn f u n v cn f u n v amount ow cost one unit ow arc f u n v respectively denote total amount energy consumed b e objective function network ow problem written v2bjts vts b apq2a set arcs g 3 rst three terms amount energy consumed b variables assigned memory last term represents energy saved allocating certain variables registers values xp q unknown determined corresponds variable v v assigned register values cp q dependent types arcs associated categorized following cases 1 arc node type n f another node type n ie f u n v cost associated arc cn f u n v computed r hu vc r n set nodes g amount energy saved reading u register writing v register arc node type n p another node type n ie p u n v cost associated arc cn p u n v dened dierently total 7 cases considered 21 u bie us lifetime overlap b v written b cost cn p u n v computed 22 u b v assigned register allocation process b p u b v assigned memory allocation process b p r hu vc r u b v written b cost cn p u n v dened 6 case 22 25 u b v assigned register allocation process b p u b v assigned memory allocation process b p r hu vc r 27 u v represent variable cost cn p u n v simply assigned zero arc start node another node type n ie need three dierent cost functions 31 v written b h0 v average hamming distance 0 variable v normally assumed 05 v assigned register allocation process b p v assigned memory allocation process b p arc node type n f nish node f ie f v f v 2 g c g need two dierent cost functions v read b cn f v f r 42 v read b cost cn f v f simply assigned zero 5 arc node type n another node type n f arc corresponding variable cost associated arc assigned zero using equations objective function network ow problem uniquely dened constraints network ow problem dened based number registers available arc summarized following applying network ow algorithm one 21 network ow problem instance obtain value xp q okn 2 time block b k number available registers n number variables whose lifetimes overlap lifetime b resulted x value arc associated variable b one variable assigned appropriate register based ow information formulation applied basic block program tree depthrst search order discussed beginning section point method also used one wishes explore program execution paths determine register allocation example associate execution path program priority one way assign priorities based execution frequency path obtained proling another way based timing requirements solve register allocation problem one start highest priority path p 1 proceed lower priority ones sequentially rst path form super block path use local register allocation algorithm 13 nd best allocation single path next path remove basic blocks path whose register assignments determined form super block b 0 rest basic blocks path construct graph super block b 0 need consider b p child b 0 introduce necessary n p nodes complete graph network ow problem super block b 0 use formulations discussed process repeated subsequent paths applying algorithm variable allocation decisions made higher priority paths changed allocation processes lower priority paths rather results higher priority paths used insure good allocations found lower priority paths based results hence eectively eliminated con icting assignments arise solving allocation problem path separately 4 register allocation blocks merging parent blocks section present approach handle merge case fact allocation results dierent parent blocks may dierent makes merge case dicult handle branch case variable v alive b dened written b v must alive leaving every bs parents since allocation results v dierent parent blocks may dierent cannot simply allocation v b based allocation result one particular parent block hence register allocation approach programs branches basic block one parent block adequate block one blocks merging handle control structure merge blocks devise method capture nonunique assignments variables registers based approach formulate problem register allocation static energy model activity based energy model instance network ow problem let parent blocks b b assuming total number blocks merge b 1 parent block b p associated probability p b indicating frequently block executed probabilities obtained proling information allocation parent block nished allocation decision variable b p goes beyond boundary b p b xed dene probability v allocated register resp memory b p p v r b let p v r probability v assigned register r j block b p also dene p v r total probability v allocated register resp memory parent blocks p v r total probability v allocated register r j parent blocks following relations hold variables dened k total number registers modify ow graph used merge case follows source node nish node f kept nodes used represent variable v still n v starting node n f v nishing node register assignments dierent parent blocks may dierent cross boundary variable may dierent allocation assignment dierent parent blocks ect fact critical set c dened set variables overlapping lifetimes one another number variables written b set greater number k available registers furthermore introduce new set register nodes n r correspond registers addition arcs dened section 2 add new arcs source node register node n r complete bipartite graph formed register nodes starting nodes variables rst critical set c 1 0 example ow graph block b multiple parent blocks shown figure 4 assuming two registers r 1 r 2 available system minimizing energy consumption single block multiple blocks merging one minimize overall energy consumption execution scenarios block thus objective function ow problem needs take account probabilities executing dierent parent blocks dierent energy models static energy model activity based energy model objective function cost associated arcs slightly dierent reduce repetition integrate presentation formulations models point dierences wherever necessary objective function written f b c e f nsa nfa nsc nsd nfc nfd figure 4 graph g basic block one parent blocks v2bjts vts b apq2a 1 static energy model rst three terms computing objective function 19 amount energy consumed block b variables assigned memory last term represents energy saved allocating certain variables registers dierence value due fact activity based energy model energy consumption register references computed switched capacitance two consecutive accesses captured cost cp q associated corresponding arcs last term 19 values xp q unknown determined xp corresponds variable v v assigned register values cp q dependent types arcs associated categorized following cases 1 arc node type n f another node type n ie f u n v cost associated arc cn f u n v computed dierently two dierent kinds energy model static energy model r activity based energy model r hu vc r n set nodes g amount energy saved reading u register writing v register arc node type n r another node type n ie r n v cost associated arc cn r n v take one following values 21 v written b static energy model cn r n w e r activity based energy model cn r n static energy model energy saving energy memory write e energy register write e r w hand activity based energy model energy writing v register determined hamming distance v variable u occupied r entry block b since probability variable u occupying r p u r hamming distance would summation hamming distance v u nonzero probability occupying r one parent blocks energy writing variables r back memory r assigned v already included objective function second item 22 v written b static energy model cn r n rst term energy consumption v assigned memory location second energy assigning v r b v memory b 0 parent blocks last term energy assigning v r b v already register r bs parent blocks activity based energy model cn r n r last term energy consumed assigning v r determined hamming distance v variables occupies r bs parent blocks arc source node node type n r ie n r cost function simply zero arc node type n f nish node f ie f v f v 2 g c g need two dierent cost functions v read b static energy model cn f v f r e r activity based energy model cn f v f r 27 42 v read b cost cn f v f simply assigned zero static activity based energy model 5 arc node type n another node type n f arc corresponding variable cost associated arc assigned zero using cp q denitions objective function network ow problem uniquely dened constraints network ow problem dened based number registers available dierent types arcs summarized following applying network ow algorithm 21 network ow problem instance value xp q obtained okn 2 time block b k number available registers n number variables whose lifetimes overlap lifetime b resulted x value arc associated variable one variable assigned appropriate register based ow information formulation applied basic block program control ow graph topological order 5 register allocation loop section extend approach handle programs loops loop considered control structure one parent blocks merging however presents unique challenges since one parent blocks one way solve allocation problem loops modify ow problem formulation presented last section consider loop one basic block shown figure 5 dash lines represent variables referenced one iteration loop execution refer variables loop variables rest nonloop variables graph modeling allocation problem loop block built following guidelines used merge case graph loop block figure 5 shown figure 6 note existence loop variables change graph since register nodes needed model parent block assignments similar merge case associate certain probabilities variables boundary loop block parent blocks capture potentially dierent assignments dictated dierent parent blocks example figure 5 assuming loop one parent block corresponds loop may seem one simply use ow problem formulation merge case nd allocation loop however diculty probabilities associated loop variable eg p dependent allocation result loop block yet determined f f c e e inassignment preassignment postassignment loop variable loop variable figure 5 loop one basic block e f loop variables b c nonloop variables optimization problem still solved longer simple ow problem general assume b p l loop body probability block loops back p b p l p b p l obtained proling information probability associated loop variable v expressed follows v assigned register r upon exiting loop ie xn f v f assigned memory upon exiting loop ie xn f v f consequently following expression derived follows ow problem 19 transformed integer quadratic programming loop block e f f f c e nsc nsd nfa nfc nfd figure flow graph loop figure 5 problem integer quadratic programming problems generally nphard may solved branchandbound method 26 propose ecient heuristic approach generally produces superior allocation sults recall register allocation algorithm determines variable allocation block based allocation results parent blocks consider loop variable may initial assignments dictated allocation parent blocks loop block self another assignment rst reference loop block yet another assignment upon leaving block ease explanation refer assignments preassignment inassignment postassignment respectively figure 7a show possible assignment result block figure 5 variable e preassignment register inassignment memory postassignment register basis approach following observations general loop body executed frequently ie p b p l relatively close one loop variables preassignment dierent inassignment single switching memory register vise versa required however loop vari ables inassignment dierent postassignment many switchings number loop iterations would needed hence reducing number loop variables dierent inassignment postassignment would tend result better allocations algorithm employs iterative approach rst allocation attempt ignore fact loop body one parents compute allocation simply using results parent blocks value p v r b ow formulation 19 assumed zero b p loop body v loop variable refer initialization phase 0 algorithm proceeds follows loop variable whose inassignment dierent postassignment optimal allocation found algorithm exits otherwise perform two allocation phases second phase 1 third phase 2 second phase let inassignment loop variable value obtained 0 solve resultant allocation problem since values p v unknown v loop variable may seem still need solve integer quadratic programming problem however applying simple manipulations avoid diculty particular modify value cost cn f v f loop variable v instead always setting zero merge case dened according inassignment loop variable follows cn f v f inassignment register e e r otherwise value p v r b p l p v mb p l loop variable v still assumed zero modied ow problem correctly captures overall energy consumption inassignment loop variable set obtained 0 solution modied ow problem leads improved allocation result third phase 2 x postassignment loop variable value obtained 0 p v r b p l p v mb p l computed postassignment register r vs postassignment memory substituting 19 probability values reduce allocation problem mincost ow problem solving ow problem result allocation improves result obtained 0 better one 1 2 kept best allocation result found far improvement could obtained iterations carried treating current best allocation one obtained 0 following procedure used following show optimal allocation loop block obtained algorithm exits initialization phase 0 furthermore show second third phase needed results always improve 0 energy consumption loop block b p l e 0 energy consumption l assuming loop variables loop back mine mine 0 computed setting 19 p v r zero loop variable v e expressed r l e r l e r vl set loop variables dicult verify e e 0 combination xnr values hence mine mine 0 2 based lemma 1 prove following theorem theorem 1 allocation result initialization phase 0 makes inassignment loop variable postassignment proof consider loop variable v b p l inassignment postassignment memory xnr contribution e 31 reduces zero similarly vs inassignment postassignment register r vs contribution e 31 becomes zero one loop variable exists conclusion obtained therefore inassignment loop variable postassignment ej 0 total energy consumption b p l using allocation obtained 0 since mine mine 0 lemma 1 obtain according theorem 1 inassignment loop variable post assignment allocation result 0 optimal one loop block allocation phases needed inassignment loop variable diers postassignment result 0 longer optimal reason problem formulation used 0 fails account extra energy incurred loop variable switching assignment loop boundary second third phases aim reducing energy second phase 1 inassignment loop variable assumed obtained 0 best allocation based assumption identied let ej 0 energy consumption b p l allocation result 0 used ej 1 energy consumption b p l inassignments loop variables obtained 0 used 1 obtain allocation result minfej 1 g energy consumption note ej 0 simply one possible values ej 1 hence minfej 1 1 always improves result 0 third phase 2 x postassignments loop variables values obtained 0 nd corresponding best allocation similar statement made 1 allocation result 2 also improves 0 allocation phases carried based better allocation 1 2 improvement may obtained approach essentially hillclimbing technique could settle suboptimal solution however observe incremental improvement based optimal allocation loop body usually small subset variables loop loop variables therefore approach tends good chance obtain optimal allocation experimental results also support observation use example figure 5 illustrate algorithm works singleblock loop figure 7a depicts allocation result initialization phase since inassignment postassignment loop variables e f dierent second third phase needed second phase cost cn f2 e f ow graph figure 6 set e w e r r inassignment e memory cost cn f2 f f set zero inassignment f register allocation result second phase shown figure 7b third phase let p since postassignment e register r 1 p f r b p l since postassignment f memory allocation result third phase 1 since inassignment e resp f postassignment allocation result process stops obvious allocation result optimal block algorithm readily extended handle case one block inside loop body ie control structure inside loop body contains branches loops branches merges phase algorithm needs solve allocation problem block loop body following process discussed section 3 4 1 resp 2 inassignments resp postassignments loop variables obtained 0 used compute necessary cost probability values loops inside loop sequence allocation determined nested levels loops since inner loops executed frequently outer loops innermost loop allocated rst result used outer loops b e e c f f e e c f f figure 7 allocation results dierent allocation phases loop solid lines correspond variables registers dash lines correspond variables memory 6 experimental results discussions graphcoloring based techniques ones 6 often used solving register allocation problem compare algorithm graphcoloring approach implemented graphcoloring register allocator blockbyblock register allocator tiger compiler presented 1 modularity tiger compiler makes easy x phases compiler alternate register allocation algorithms procedures nding basic blocks building trace computing lifetime variable kept allocators implementation graphcoloring allocator interference graph built program applying graphcoloring approach color graph node degree less number available registers graph node highest degree spilled nodes colored spilled implementation algorithm network ow graph built block algorithm dierent control structures applied basic block topological order nd best allocation compare allocation results two dierent approaches several real programs containing complex control structures numbers memory references two allocators summarized table 3 improvement energy consumption number memory references using algorithm graphcoloring approach summarized table 4 according data 3 17 12 reasonable assume ratio average energy memory reference average energy register reference e e r range 10 30 table 5 summarize sizes allocation problems two approaches need solve stated beginning paper complexity algorithm ob ln k b total number blocks ln k time complexity solving register allocation problem single block n variables k available registers function ln either onlog n singleread staticenergy model oknlog n multipleread staticenergy model okn 2 activity based energy model 5 13 table 3 number memory references allocated two approaches approach graphcoloring example k register data spilled memory spilled memory programs candidates references candidates references candidates references branch 14 28 67 table 4 improvement results algorithm graphcoloring energy improvement improvement programs e e factorial 728 807 896 298 branch 682 770 874 239 table 5 size problems solved two approaches interference graph network ow benchmarks nodes edges blocks b max variables n branch 28 293 4 26 experiment results show algorithm achieve 60 improvement energy consumption due data references program graphcoloring approach time also saved 20 memory references save execution time due data references program furthermore approach simple use running time polynomial improved graphcoloring based algorithms one 11 register allocation results improved algorithms better simple graphcoloring approach implemented algorithms proposed optimize execution time energy consumption program algorithm proposed paper take account look ahead information register allocation also allow backtracking cases approach may produce suboptimal allocation results one simple extension algorithm would change cost cn f v f associated arc f v f cross boundary variable v according possible allocation results v child blocks paper proposed new algorithm deal variables whose lifetimes extend beyond basic blocks low energy register allocation algorithm much less time space complexity approaches register allocation variables extending beyond basic blocks experimental results using algorithm far promising experiments larger code sizes conducted also investigating deal procedure calls acknowledgment research supported part national science foundation grant ccr 9623585 mip9701416 external research program grant hewlettpackard laboratories bristol england r modern compiler implementation c digital circuits microprocessor applications computer architecture quantitative approach networks matroids integer tr combinatorial optimization algorithms complexity minimization loadsstores local register allocation prioritybased coloring approach register allocation register allocation via hierarchical graph coloring global dynamic register allocation binding data path synthesis system allocation algorithms based path analysis italickitaliccoloring intervals register allocation binding low power power minimization ic design demanddriven register allocation low energy memory register allocation using network flow optimal nearoptimal global register allocations using 0myampersandndash1 integer programming design implementation rap computer architecture 2nd ed global register allocation minimizing energy consumption modern compiler implementation c digital circuits microprocessor applications global register allocation based graph fusion register allocation myampersandamp spilling via graph coloring
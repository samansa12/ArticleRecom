logic query language abstractresearch nonmonotonic reasoning focused largely idea representing knowledge world via rules generally true defeated even relational databases nowadays main tool storing large sets data approach using nonmonotonic ai formalisms relational database query languages investigated much smaller extent work propose novel application reiters default logic introducing default query language dql finite relational databases based default rules main result paper dql expressive existentialuniversal fragment secondorder logic result theoretical importance exhibit querieswhich useful practicethat expressed dql cannot query languages based nonmonotonic logics datalog negation stable model semantics particular show dql wellsuited diagnostic reasoning b introduction f purpose knowledge representation nonmonotonic reasoning nmr henceforth formalisms used two dierent ways languages representing knowledge world via rules generally true de feated retrieving information nonmonotonic knowledge base kind amounts prove theorem example use default logic state birds generally order prove bird tweety ies try prove specic formula follows default logic semantics set general rules plus set specic facts relational database query languages retrieving information amounts computing set tuples belonging intensional relation starting extensional relations example query relational database means datalog program ie datalog program negated literals body rules equipped specic semantics negation research nmr focused largely former idea remarkable results computational complex preliminary partial version paper appears proceedings fourth international conference principles knowledge representation reasoning kr94 bonn germany may 1994 morgan kaufmann publishers inc san francisco ca cadoli dipartimento di informatica e sistemistica universita di roma la sapienza via salaria 113 i00198 roma italy email cadolidisuniroma1it eiter g gottlob information systems depart ment technical university vienna paniglgasse 16 a1040 wien austria email eiterjgottlobdbaituwienacat ity several formalisms obtained many authors cf 1 survey topic even relational databases nowadays main tool storing large sets data latter approach investigated much smaller extent one important aspects query language relational databases expressive power ie set relations compute querying expressive power relational database query languages studied twenty years cf 2 research focused mainly monotonic query languages ie languages extensional relations grow intensional ones grow well recently interesting works investigating expressive power nonmonotonic query languages appeared kolaitis papadimitriou study 3 expressive power two semantics datalog programs particular prove datalog xedpoint semantics expressive 9 existential fragment secondorder logic schlipf proves 4 analogous result datalog stable model semantics logic programs 5 stable models called default models 6 7 following refer variant datalog datalog stable sacca gives 8 insight expressive power interesting variants stable van gelder analyzes 9 expressive power datalog wellfounded semantics 10 papers databases modeled nite structures ie nite interpretations theories work concerned default logic query language default logic 11 one popular nmr formalisms extensively investigated semantical computational point view also proposed 7 tool inferencing logical databases ie databases theories anyway behavior default logic nite structures ie relational databases analyzed far propose novel application default logic introducing default query language dql nite relational databases based default rules main result paper dql expressive stable particular dql expressive 98 existentialuniversal fragment secondorder logic result theoretical importance exhibit queries useful practice expressed dql datalog stable two queries taken realm economics another one deals diagnostic reasoning cir cuit appears dql allows easy formalization process alternative way describing main result say dql captures complexity class p 2 cadoli eiter gottlob default logic query language 101 polynomial hierarchy datalog stable captures class np therefore dql expressive stable provided p hierarchy collapse property widely conjectured assumed throughout work remind p 2 completeness credulous propositional default reasoning recently proven 12 13 therefore important remark expressive power language necessarily complexity several languages property known cf 14 15 example language capture np even underlying npcomplete problem shown stewart 16 show dql wellsuited formulating useful practical queries dierent domains present several examples one examples deals troubleshooting electric circuits appears dql allows elegant implementation advanced diagnostic reasoning principles particular abductive modelbased diagnosis 17 18 examples deal relevant queries business administration structure paper following section ii provides motivating examples section iii state necessary preliminaries query languages relational databases provide brief introduction default logic section iv give denition query language dql providing syntax semantics section v give formal proof fact dql captures p 2 brie address computational complexity dql consider sublanguage normal dql queries analogous normal default theories section vi show complex problems like presented section ii solved dql draw conclusions compare dql query languages arising logic programming nal section vii order increase readability proofs results moved appendix ii motivating examples diving technical part paper let us motivate examples query languages higher expressiveness datalog stable needed examples dealt much detailed way section vi rst example domain modelbased diagnosis mbd electric devices promising eld active research area ai cf 19 20 would therefore interesting integrate paradigm mbd relational databases descriptions large electric systems eg power networks benecially stored database example 1 electric circuit troubleshooting electric circuit several components might way malfunctioning even misdesigned eg resistance value resistor could small simplied electric circuit represented figure 1 battery two resistors two fuses conf fig 1 electric circuit trol light bulb higher batterys voltage higher currents amperage similarly smaller resistors resistance higher amperage perage circuit exceeds certain amount one fuses melts circuit interrupted control light predictable one fuses melt even kind mbd known abductive diagnosis customary say component work properly one eects show moreover eect originated set causes set causes originate univocally eect circuit melting fuse eect batterys voltage high cause similarly melted fuse well broken bulb cause eect control light cf 21 17 18 22 background overview results abductive diagnosis abductive diagnosis knowledge circuit one typically described diagnostic theory consists rules form c causes e j eects example following rule states melting one fuses occur whenever resistance values low necessarily antecedents rule kind 1 possible causes example might sure rst resistor underdimensioned case r 1 low would possible cause possible causes called hypotheses finally specic situation make set observations eg control light given situation described set rules kind 1 set hypotheses set observations abductive diagnosis looks explanation observations make explanation minimal set hypotheses wrt inclusion validity implies rules observations general situation possible one many explanations exist hypotheses belong least one explanation diagnostic problem called relevant problem computing relevant facts diagnostic problem important subtask troubleshooting able focus fault localization subset possible causes easy conceive database stores rules causes eects well hypotheses observations anyway results complexity propositional abduction 22 follows easily computing relevant facts troubleshooting problems problem hard complexity class p 2 polynomial hierarchy cf 23 fact already deciding specic fact relevant hard means possible compute relevant facts datalog stable reason discussed section iiia similarly possible formulate boolean query datalog stable decides specic fact relevant hand section vi show possible write dql query computes facts relevant problem 2 remaining examples section deal business applications somewhat simplied economic world example 2 strategic companies suppose holding owns companies company produces set products product produced two com panies example pasta produced barilla saiwa wine produced barilla 1 suppose holding experiences crisis sell one company holdings policy keep producing products clearly makes impossible sell companies example barilla company situation would impossible produce wine anyway managers even cautious know future may necessary sell companies want get situation able produce products formally interested minimal sets companies produce products company strategic least one minimal sets therefore query relevant managers whether company strategic prefer sell nonstrategic company rst transaction minimal sets companies produce products remain let us consider slightly complex situation three say companies control another company example companies barilla saiwa together control company frutto assume following constraint imposed determining strategic companies company controlled companies sold also one companies sold constraint completely changes minimal sets companies produce products former case controlled companies problem deciding whether company strategic complexity class np cf 24 latter case problem easily shown complete class coincidence existing companies purely casual 2 polynomial hierarchy cf 25 consequence cf section iiia former query expressible stable latter section vi show possible write two dql queries compute sets strategic companies two cases 2 example 3 maximal trust set companies possible make agreements company may agreement another company course simultaneously several agreements dierent compa nies trust set companies one agreement company trust maximal trust 0 companies ie jt 0 j jt j following query rises companies belong maximal trust computing query nphard problem also conphard problem consequence cf section iiia query written datalog stable unless unexpected collapse complexity classes hand query expressed dql 2 iii preliminaries relational databases background relational databases query lan guages reader referred 26 27 database schema r nite set fr relation schemata relation schema r name n nite list attributes sometimes denoted r number l arity relation assume underlying set u objects used relations socalled main domain u arbitrarily large nite given relation schema r relation instance set tuples form ha database instance w set relation instances set objects occurring database socalled active domain subset possibly strict u database query often simply query mapping set database instances xed database schema r intuitively input relations database instances xed database schema output rela tions assumed mapping computable generic ie invariant renamings constants u query language syntax semantics evaluates wellformed formula query database instance returns answer database stance thus query denes database query answer io query set relation instances answer boolean query either yes case schema consists single propositional letter technically 0ary relation expressive power relational database query languages one studied topics database theory basically one interested knowing relations expressed query language relations relation expressible query language cadoli eiter gottlob default logic query language 103 query language input database instance returns precisely desired relation answer example transitive closure graph expressible datalog 26 one way presenting result area say query language cancan express specic relation example wellknown relational calculus express transitive closure relation 28 relation satisable propositional clause sets computed xed program datalog stable datalog unless pnp cf 4 measuring complexity boolean queries straight forward usually dened referring following problem given database instance decide query evaluates yes complexity query language complexity problem queries lan guage also termed data complexity query xed ie query database given input analogously obtain combined complexity query language often much higher order deal complexity expressive power io queries use key concept query recognizability denition iii1 cf 29 let c complexity class query mapping database instances r database instances crecognizable deciding whether tuple belongs certain output relation 2 c data combined complexity io query language dened terms queryrecognizability similar boolean queries typically expressive power query language represented set logical sentences exam ple results 4 entail expressive power stable brave semantics 9 existential fragment secondorder logic ie set sentence list predicate symbols functionfree rstorder formula among possibly others predicates occur traditional notion query language capturing complexity class c queries denable language precisely recognizable c example fagins celebrated theorem class 9 queries captures class np 30 figure describes wellknown relations expressive powers several query languages correspondences complexity classes cf 31 32 2 edge denotes inclusion ie less expressive power assuming complexity classes collapse always strict wellknown datalog express queries computable polynomial time incomparable rstorder logic stratied datalog ationary datalog increasing expressive power express rstorder queries still polynomial time computable queries queries latter possible already datalog negation input relations linear ordering universe given cf 33 firstorder logic equivalent relational algebra 28 note datalog express queries whose computation pcomplete hence unless included class queries computable nccircuits queries denable rstorder logic linear ordering ac 0 queries 31 ac 0 class problems solvable uniform families constant depth circuits polynomial size fanin gates unbounded ac 0 queries proper subclass ncqueries nc class problems solvable polylog parallel time polynomial amount total work likely proper subclass queries computable polynomial time whilequeries constitute class queries denable programmingstyle query language provides assignments rstorder expressions tuple variables sequencing statements statements class appears quite powerful since pspacehard queries expressed hand queries computable pspace expressed eg universe even size however possible linear ordering universe provided already mentioned stable brave semantics equivalent 9 fragment secondorder logic thus captures np queries den able existentialuniversal secondorder logic 98 ie set sentences relational functionfree vocabulary disjoint lists predicate symbols rstorder particular interest paper query language based default logic present section iv dql express exactly 98 fragment secondorder logic captures class p 2 polynomial hierarchy consists decision problems solved nondeterministic turing machine polynomial time use oracle problem ie subroutine solving problem unit time np cf 23 consequently unless p widely conjectured false dql much expressive datalog stable fi nally queries denable full secondorder logic computable within polynomial hierarchy 34 35 b default logic introduced reiter 11 one extensively studied nonmonotonic malisms detailed treatment formal system reader referred 36 interesting relations default logic database theory shown bidoit froidevaux 37 used default logic dening semantics negation deductive databases default logic knowledge world divided two parts representing certain knowledge defeasible rules respectively rst part denoted w horn clause queries queries firstorder queries 9 firstorder queries firstorder queries datalog stratified existential fixedpoint queries firstorder queries relational algebra whilequeries ncqueries inflationary datalog fixedpoint queries polynomialtime queries fixedpointqueries stable secondorder queries whilequeries fig 2 query languages noncollapsing complexity classes set closed rstorder formulae second one denoted collection special inference rules called defaults default rule form wellformed formulas whose free variables among x called prerequisite default 1 called justications x con sequence propositional constant true implicitly assumed justication de fault convenience omit writing x prerequisite default closed none contains free variables default theory hd w closed defaults closed default default theory closed called open semantics closed default theory hd w based notion extension possible state world according knowledge base formally extension dened using quasiinductive construction follows dene set e rst order formulae cons denotes classical deductive closure e extension hd w e deductively closed hence innite object extension e hd w identied generating defaults allow compact representation e generating defaults e denote gde hd w defaults 2 e constructible w gde hd w follows lemma 1 11 theorem 25 let e extension closed default theory denition extension extended open default theories assuming defaults free variables implicitly stand innite set closed defaults obtained replacing free variables terms herbrand universe default theory default theory one multiple extensions 2 actually equivalent characterization extensions rather original denition terms xedpoints operator cadoli eiter gottlob default logic query language 105 general therefore dening entailment formula default theory hd w straightforward standard variants credulous entailment entailed belongs least one extension hd w skeptical entailment follows belongs extensions hd w computational side credulous skeptical reasoning extensively studied literature 38 12 13 conclude section wellknown example default theory example 4 nixon diamond assume q r propositional atoms meaning someone pacist quaker republican spectively default theory two exten sions consf g rst extension republican also quaker paci st second former extension generating default qp p latter rp p thus credulous semantics conclude person pacist well pacist cautious semantics conclude neither 2 iv default query language dql section give syntax semantics default query language dql consider simple example examples applications considered section vi syntax dql inputoutput query q pair b set b rstorder formulas background knowledge set open default rules rstorder language functionfree quantierfree plus set output relation schemata g set predicate symbols occurring defaults q contains names relation schemata database extensional relations possibly symbols intensional lations output relations intensional intuitive meaning query following want compute tuples relations inferred credulous default semantics see next section formal denition particular apply credulous default semantics propositional instantiation open defaults background knowledge query plus database dql boolean query set open default rules plus ground formula intuitive meaning query following want know whether follows credulous default semantics propositional instantiation defaults query plus database example 5 marys oce two relation schemes prog programmer mgr man single attribute name database instance w following table peter paul mary mgr name mary io query q b follows background knowledge b empty smallo icex consists single relation scheme small officename relational database states peter paul mary programmers mary manager query made three open defaults rst one states person provably programmer proven exceptional small oce default second default states people proven exceptional regarded exceptional third default states rule people provably programmers managers ex ceptional intuitive meaning query want know set people small oces example boolean query consider set defaults plus ground formula smallo icep eter intuitive meaning query want know whether peter small oce 2 b semantics semantics dql q dened terms default theory obtained instantiating query domain database cf 2 14 let w database instance set relation schemata g relation instance r let r jw set tuples w belonging r denote comp w completion database ie set following ground literals tuple ha standard translation databasesasmodels databasesascompletetheories essentially shown example 39 let x formula whose free variables among list objects u denote x result simultaneously substituting x let b pair background knowledge open defaults boolean io query q denote inst b instantiation b set ground similarly denote inst instantiation set ground defaults 106 ieee transactions knowledge database w r domain u denote qw default theory defaults inst rstorder formulas comp w credulous semantics query q dened follows q io query ie pair b plus set output relations answer q database instance w 0 domain u dened follows 2 jw 0 set ground tuples u follows qw credulous semantics ie least one extension qw q boolean query answer yes distinguished ground formula q follows q credulous default semantics otherwise answer skeptical semantics query q dened analo gously q io query jw 0 contains tuples follows qw skeptical semantics q boolean answer yes follows q skeptical semantics otherwise remark notice semantics dql queries two sorts nonmonotonic reasoning involved rst database completed comp w secondly default rules applied completion database prohibits new positive facts concluded input predicates usual requirement setting strict relational databases fact whole mechanism could made homogeneous using default rules obtaining completion database well one way achieve use following method extensional relation r introduce new predicate r 0 arity occur elsewhere build set 0 consisting following defaults 1 n set ground atoms r 0 tuple jw r shown default theory provides answers boolean io queries qw intuitively r 0 predicates serve transfer extension input relations respective predicate letters r fact extension r 0 complete ie every ground atom true false rst default r 0 must coincide r second third default note one allow occurrence extensional relations conclusions user defaults similar restriction often made logical query languages eg datalog b also default theory w seen set ground atoms r r r provides answers qw note background theory used state integrity constraints input eg possible using designated atom invalid whose derivability indicates integrity constraints violated eg functional dependency constraint relation r implemented formula rx yrx zy 6 z invalid appears credulous skeptical variant dql dual respect complements expressive capability fact forthcoming results complexity expressiveness credulous dql apply skeptical dql dualized form ie complexity class replaced complementary complexity class instance forthcoming theorem 1 credulous dql rephrased skeptical dql saying boolean skeptical dql queries precisely capture class 2 carry rephrasements leave well adaptations proofs interested reader moreover brevity mainly use credulous dql examples applications notice credulous semantics skeptical semantics coincide q w one extension often case let us see semantics dql works example shown previous subsection example 5 marys oce continued assume domain fp eter p aul mary g ie domain active domain progp aul mgrp aul progmary mgrmaryg progmaryexmary smallo icemary smallo icepaul progp eterexp eter smallo icep eter exp eter default theory q w one extension whose generating defaults smallo icepaul progp eterexp eter smallo icep eter answer io query credulous well skeptical semantics relation instance peter paul words peter paul small oces mary small oce answer boolean query yes 2 v expressive power dql previous section seen default logic suitable query language ie language manipulating relations interesting question fol lowing relations computed dql cadoli eiter gottlob default logic query language 107 relations words expressive power dql section show expressive power dql 98 existential universal fragment second order logic result derived boolean queries well general io queries order rst derive result boolean dql queries using result derive result general dql io queries established expressive power dql analyze expressive power two natural sublanguages dql namely normal dql seminormal dql allow normal seminormal defaults query respectively restrictions dql correspond classes normal seminormal default theories constitute important fragments default logic boolean dql queries ready prove main result concerns dql boolean queries following theorem says dql capable boolean queries whose complexity class p 2 practitioner provides helpful information expressed dql soon know complexity query want implement often immediately tell whether query feasible dql example queries section ii complexity p consequence expressed dql cf section vi hand complexity higher p impossible extremely unlikely query implemented dql consequence query tells whether player win given situation gogame stored database written dql since pspacecomplete problem cf eg 40 theorem 1 boolean dql queries precisely capture class p notice query languages express part queries p even p hard queries fail express simple queries 15 languages general easy tell whether certain even simple query expressed leaves programmer uncertainty whether query implemented result expressiveness dql immediately derive result complexity dql particular obtain following characterization data complexity ie evaluating xed query q varying databases following theorem tells us p complete problem general roughly speak ing means query evaluation still npcomplete even oracle ie subprogram solving npcomplete problems available account calls oracle practically speaking means reduce query evaluation solving npcomplete problem eg checking classical satisability set propositional clauses eciently particular ecient reduction integer programming methods investigated context logic programming 41 feasible theorem 2 data complexity boolean dql p complete remark complexity grows lot query xed ie case evaluating given query given database combined complexity fact exponential increase complexity combined complexity shown complete class nexptime np exponential analogue p b dql io queries consider dql queries compute output rela tions using theorem 1 show following general theorem tells io queries complexity p 2 expressed dql case boolean queries gives valuable information implemented example immediately know query computing transitive closure graph implemented dql since complexity polynomial theorem 3 database query p recognizable denable dql io query c normal dql queries fragments default logic resulting imposing syntactical restrictions default rules considered already reiter seminal paper 11 common restrictions rules forms called normal default rules x called seminormal default rules default theory called normal resp seminormal every default normal seminormal classes normal seminormal default theories important wellstudied fragments default logic particular normal default theories model jumping conclusion possible seminormal defaults allow expressing priorities otherwise normal defaults many applications default knowledge represented normal seminormal default theory cf eg 42 extensive treatment motivates consider sublanguages dql correspond normal seminormal default ories respectively denition v1 default query q called normal default normal seminormal ie form clearly normal dql queries also seminormal thus proper syntactical restriction example students employees assume r consists two relation scheme r relation schemes married student single attribute name io query specied b used compute instances output relations adultname employeename background knowledge married people adults rst default states students typically employed second adults usually employed consider following instance w r domain f john sue betty g married name sue john sue query computes following output sue suethe question rises normal dql seminormal dql less powerful general dql turns normal dql already powerful general dql thus express queries p 2 shown slight modications default theories constructed proofs theorems 1 3 theorems sharply describe implemented language advantage complexity query one mostly immediately tell whether implemented although give us clue query program may look like theorem 4 boolean normal dql queries precisely capture class p theorem 5 normal io dql queries precisely capture class p recognizable queries immediate corollary obtain analogous results seminormal dql corollary 1 seminormal boolean dql queries capture class p 2 resp class p recognizable queries remark theorems 4 5 proved though less instructive combining results 37 43 recent results authors 15 vi applications dql section show write dql queries solving problems mentioned section ii example 1 electric circuit troubleshooting continued rules causes eects kind 1 stored appropriate relation note assume rules uniform type since encode rules two causes andor eects easily small number rules using new dummy facts conjunction disjunction represented new fact f resp g rules instance rule c 1 rewritten f c 3 gd 3 clear rules rewritten note general clause set transformed method uniform clause set polynomial time assumed symbols f represent empty cause intuitively always true empty effect always false respectively special relations truecause falseeffect contain always single tuple f respectively example following relation instances describe rules causes eects circuit figure 1 bhigh melts f 2 melts low r 2 low f 1 melts f 2 melts melts lighto f bulbbroken lighto f meaning rst tuple rule whenever batterys voltage high one fuses might melt even resistors ok second tuple states melting fuses occur whenever resistors low cf rule2 tuples state melted fuse broken bulb causes control light set possible causes stored another relation already mentioned necessarily names cited rst three columns relation possible causes hypothesis fact bhigh bulbbroken organization knowledge useful one wants decouple static knowledge knowledge circuit dynamic knowledge knowing whether specic device malfunctioning set observations making spe cic situation stored third relation observa tionsymptom observation symptom already mentioned explanation minimal set facts wrt inclusion taken relation hypothe sis validity implies causeseects cadoli eiter gottlob default logic query language 109 relationships rule facts relation observa tion ie every truth value assignment remaining facts compatible causeseects rela tionships facts observation must true example set fbulbbrokeng explanation elements occur hypothesis relation fact lighto explained rule represented last tuple rule note set fbulbbroken r 2 lowg explanation since minimal wrt inclusion fbhighg alternative explanation possible set explanations diagnosis instance computed means following background knowledge b open defaults intuitive meaning tx x true ie proven using knowledge circuit observations intuitive meaning expx x part explanation predicates exp 0 x 0 x removex used assuring minimality explanation explain detail rst second default represent choice whether fact f considered explanation rst formula b represents constraint former case f must appear hypothesis considered true assumption third default claries fact inferred true using diagnostic rules fourth default states fact f observation must provable ie consistent assume negation f infer contradiction remaining part default theory serves assuring explanation indeed minimal wrt inclusion exploits simple fact set facts entailing observations explanation fact f removal f longer observed facts entailed cf 22 easy proof fact f represents second formula b set described exp removal f last formula states facts set considered true fth default produces copy diagnostic rules f used verify f occurs ffg entail observations test implemented last two defaults f occurs removef must provable shown extensions instantiated default theory correspond onetoone explana tions fact f belongs explanation exactly belongs corresponding default extension consequently credulous dql io query output relation expfact computes facts belong least one explanation diagnostic problem ie relevant facts notice analog cautious version dql io query computes facts necessary ex planation ie facts belong every explanation nal remark note requiring minimality explanations source complexity results 22 p 2 hardness deciding relevance holds also nonminimal explanations admissible fact default query case would even much simpler 2 example 2 strategic companies continued possible situation products companies described following database instance producers product company 1 company 2 pasta barilla saiwa tomatoes frutto barilla wine barilla bread saiwa panino symbol means entry void mally represent special object domain specied relation voidobject situation barilla saiwa strate gic fbarilla saiwag produce products neither fbarillag fsaiwag hand frutto strategic following relation instance describes control companies companies control controlled cont 1 cont 2 cont 3 frutto barilla saiwa meaning tuple companies barilla saiwa together control frutto taking account frutto sold either barilla saiwa also sold minimal sets companies produce products completely changed example fbarilla saiwag longer set fbarilla saiwa fruttog case controlled companies manager easily express dql boolean query whose answer tells specic company c strategic writing set open defaults producersx straty stratz adding formula stratc b empty intuitive meaning defaults product x least one producers z strategic compa nies companies nonstrategic default answer boolean query yes precisely company c strategic add default stratw boolean query stratc gives desired answer case controlled companies nal remark note example could allow unbounded numbers producers product controllers company although queries would get involved 2 example 3 maximal trust continued straightforwardly represent agreements database companies using relation agreecomp1 comp2 tuple barilla saiwa relation stands agreement companies barilla saiwa query companies belong maximal trust computes output relation maxcomp listing searched companies p recognizable 2 class problems decidable deterministic turing machine polynomial time oracle np problem cf 23 thus since p 2 query recognizable expressed dql fact little extra work shows query even p recognizable p olog n subclass p 2 number oracle calls bound olog n n size input cf 23 hand maximal trust query expressed datalog stable unless olog n widely assumed false indeed computing maximal trust query p since deciding given instance agree certain company c whether c belongs maximal trust nhard problem follows trivially olog nhardness deciding whether given node belongs clique maximum size graph 44 2 vii conclusions paper dened dql query language relational databases based default logic expressiveness complexity dql investigated boolean queries io queries results shown theoretical importance presented queries useful practice handled dql query languages based nonmonotonic logics stable let us compare contrast dqls expressive power detail expressive power computational paradigms logic programs stable semantics results displayed figure 3 expressive power datalog stable credulous semantics np ie precisely queries formulated general logic programs using stable mod els whose complexity np follows results 4 expressiveness result preceded complexity results credulous reasoning propositional logic programs npcomplete stable semantics 37 45 results also explain possible reduce computation stable models e lstable polynomialtime queries choice fig 3 expressiveness stable models noncollapsing complexity classes ciently linear programming shown promising approach implementing stable model semantics 41 hand expressive power dql p 2 means strictly queries formulated linear programming methods eciently applied implementing dql queries un less complexity classes collapse strongly believed dierent disjunctive logic programs endowed expressive power dql shown 15 expressive power disjunctive datalog programs using stable models datalog stable p expressive power also available called least undened partial stable lstable models 46 normal logic programs datalog stable relaxation concept stable model alternative allow negation datalog order increase expressive power choice operator introduced 47 roughly choice operator allows atoms choicex rule bodies choose precisely one instantiation variables instantiation x variables since several possibilities exist general language computes nondeterministic queries ie several outputs possible rather deterministic ones consider shown 48 semantics choice operator subsumed stable mod els 49 datalog 6 augmented dynamic choice expresses exactly nondeterministic queries computable polynomial time deterministic fragment language detdatalog precisely queries computable polynomial time cf50 however recognized notice conjectured query language precisely polynomial time queries exists see 29 conclude outlining possible issues future work dql denition query section iva open defaults quantier functionfree one direction generalization dql allowing rstorder formulas quantiers andor functions another direction identifying tractable fragments dql particular fragments resemble subclass polynomialtime cadoli eiter gottlob default logic query language 111 computable queries determining expressive pow ers good starting point project 38 several important tractable fragments default logic identied appendix theorem 1 boolean dql queries precisely capture class p proof easy part show every boolean dql expressed p recognizable boolean query end sucient prove data complexity dql ie regarding query xed p 2 notice semantics dql given section ivb transforms query answering credulous reasoning propositional default theory transformation clearly polynomial size database proven 12 13 problem credulous inference propositional default theories p part proof complete dicult part show boolean query expressible sentence 98 expressed dql already noticed introduction take advantage fact propositional credulous default reasoning p hard expressiveness query language necessarily complexity without loss generality assume sentence 3 form lists predicate symbols x lists individual variables rst order formula function symbol quantier occurs pass 3 4 wellknown logic justied report 51 show query qso98 form 4 dql query qdql two queries give answer possible database instances w unquantied relations 4 outline idea qdql formula encoded follows use predicate denes linear order set ytuples together associated predicates f state rst tuple 0 successor last tuple respectively furthermore use predicate zx intuitively states tuple 0 initial segment designated propositional letter indicates xtuple za b true b last ytuple 9x8y x true case derivable encode default rules every extension contains valuation spredicates dened every valuation tpredicates za b true ie sentence 4 true underlying database w formally qdql consists ground formula pair b follows background knowledge b contains set axioms state linear order ie equality tuples set contains following open defaults predicate p rules associated predicates derivation ie checking 9x8y x true let w database instance denote default theory qdql w easy see consistent extensions formally easily proved lemma 1 claim atom belongs extension w assume w valuation 0 predicates dene set f formulas follows let 0 arbitrary linear order ytuples let f 0 associated extensions f l follows let denote tuples appropriate arities domain set contains following formulas extension show rst note e consistent indeed extend valuations given w assigning true letting z 0 set possible tuples letting remaining predicates arbitrary extension valuation satises f moreover e extension easily shown denition extension obtain hence extension prove claim remains show 2 e since suces show true every valuation satises f consider arbitrary valuation satises f let 0 valuation z 0 valuation z 5 let arbitrary tuple nite induction 0 show b 2 z 0 b basis let b 0 rst tuple 0 since b 0 2 f 0 b 0 true thus b 0 induction assume statement holds tuple b show holds also b 0 b b 0 induction hypothesis b 2 z 0 6 b 0 true hence follows za b 0 true ie b 0 shows induction case particular last tuple 0 ie b 1 2 l 0 however za b 1 value true valuation consequently shown 2 e concludes part proof extension 2 e notice e consistent denes valuation 0 predicates ie p p 2 e p 2 e tuple follows since defaults p p inst moreover e denes valuation 0 0 satises axioms linear order tuples arity furthermore follows instantiated default rules predicates associated e denes total valuation f l f rst tuple 0 sa 0 successor 0 0 la 2 e last tuple 0 claim prove assume false hence exists valuation 0 extend valuation model e false let tuple x rst tuple b 0 ws b notice exists dene valuation z 0 z z g assign value false valuation predicates denes model e prove lemma 1 sucient show valuation model g gdeg since comp w left show g satised easy see every z occur satised consider remaining ie conclusion default deriving three cases rst tuple formula certainly satised b successor b 0 considering three cases 1 readily checked denition z 0 formula satised c b last tuple 0 denition z 0 za b false hence since false formula satised thus valuation satises comp w hence also e since false model e 2 e contradiction however hence claim 7 proved claim 7 means concludes part proof remark defaults made prerequisitefree deleting prerequisite rewriting conclusion 2 theorem 2 data complexity boolean dql p complete proof theorem 1 every boolean dql query denes p database property gives membership part hardness part notice every 98 sentence 3 equivalent sentence cadoli eiter gottlob default logic query language 113 form 4 proof theorem 1 constructed cf appendix equivalent default query qdql easily constructed even polynomial time consequently problem deciding whether xed sentence 3 valid given database instance w p 2 hard transformable boolean dql query polynomial time 2 theorem 3 database query p recognizable denable dql io query proof deciding whether tuple belongs certain output relation 2 transforms polynomial time credulous reasoning propositional default theory cf proof theorem 1 hence p recognizability follows p recognizable query dene q database property p relation scheme following way instance w jw jqwr denotes restriction w relations r pw true tuple belongs jw computed q instance wr r notice p fact database property moreover easy see p p recognizable consequently theorem 1 p expressed boolean dql query dql without loss generality may assume dql form query qdql constructed proof theorem 1 notice database relations dql r q p dql construct dql io query q q dql follows background knowledge one q p dql ie b open defaults 0 dened database relations given r output relations rules x enforce total valuation predicates intuitively defaults simulate extensions instance w r instance w 0 processed defaults query dql default cutts extensions atom contained hence default extensions ew 0 w 0 left pw 0 true query q q dql collects brave semantics tuples belongs default extension ew 0 denition p means exactly tuples collected q computes database w words q q dql computes database w q ie q q dql denes q dql formally show following let w instance r dene set formulas g f proof theorem 1 let w 0 extension w r extension q p easy see denition extension e also extension q q dql w follows show q q dql q compute w thus remains show let e extension q q notice 2 easy see e also extension extension w r 0 consequently pw 0 true means follows jq q thus shown q q dql denes q concludes part proof proves theoremtheorem 4 boolean normal dql queries precisely capture class p proof reconsider boolean dql query qdql constructed proof theorem 1 let q 0 dql dql query resulting qdql replacing b obtained b spectively removing every nonnormal default associated predicates adding b notice boolean formula built atoms since defaults yy 0 yy 0 easy see default theories extensions every instance w thus express query let 00 result replacing 0 every nonnormal default ie rule deriving dql query obtained q 0 dql replacing 0 00 notice q 00 dql normal dql query one easily show every database instance w r set e extension q 00 e extension q dql w hence follows q 00 extension e 2 e w result follows 2 theorem 5 normal io dql queries precisely capture class p recognizable queries proof show modication construction proof theorem 3 without loss generality assume boolean dql query q p dql expressing p form query q 00 dql theorem 4 instead qdql theorem 1 analogous lines proof theorem 3 obtain io query q q dql constructed q p dql adding defaults x expresses query q let q query obtained q q dql replacing occurrence every 2 0 new predicate arity replacing default defaults let w instance r notice belongs every extension q q atom belongs extension e q belongs e thus easy see set e extension dql w extension q hand e extension qw 2 e extension q q thus follows q computes w q q dql consequently q q q dql represent query since q normal dql io query result follows acknowledgements authors grateful torsten schaub interesting comments semantics dql also appreciate useful comments anonymous reviewers helped improve reading paper rst author partially supported esprit basic research action 6810 compulog ii progetto finalizzato informatica cnr italian research coun cil second third authors partially supported christian doppler laboratory expert systems r readings modelbased diagnosis abductive inference models diagnostic problem solving principles database knowledge base sys tems foundations databases computational complexity ellis horwood lim ited tr ctr thomas eiter axel polleres towards automated integration guess check programs answer set programming metainterpreter applications theory practice logic programming v6 n12 p2360 january 2006 binding propagation techniques optimization bound disjunctive queries ieee transactions knowledge data engineering v15 n2 p368385 february simona perri francesco scarcello nicola leone abductive logic programs penalization semantics complexity implementation theory practice logic programming v5 n12 p123159 january 2005 thomas eiter wolfgang faber nicola leone gerald pfeifer declarative problemsolving using dlv system logicbased artificial intelligence kluwer academic publishers norwell 2000 cristinel mateis quantitative disjunctive logic programming semantics computation ai communications v13 n4 p225248 december 2000 victor w marek jeffrey b remmel expressibility stable logic programming theory practice logic programming v3 n4 p551567 july nicola leone gerald pfeifer wolfgang faber thomas eiter georg gottlob simona perri francesco scarcello dlv system knowledge representation reasoning acm transactions computational logic tocl v7 n3 p499562 july 2006 gianluigi greco sergio greco ester zumpano logical framework querying repairing inconsistent databases ieee transactions knowledge data engineering v15 n6 p13891408 november logic programming knowledge representationthe aprolog perspective artificial intelligence v138 n12 p338 june 2002 thomas eiter georg gottlob heikki mannila disjunctive datalog acm transactions database systems tods v22 n3 p364418 sept 1997 christoph koch nicola leone gerald pfeifer enhancing disjunctive logic programming systems sat checkers artificial intelligence v151 n12 p177212 december
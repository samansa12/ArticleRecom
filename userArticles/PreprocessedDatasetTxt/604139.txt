bitwidth aware global register allocation multimedia network processing applications make extensive use subword data since registers capable holding full data word subword variable assigned register part register used new embedded processors started supporting instruction sets allow direct referencing bit sections within registers therefore multiple subword variables made simultaneously reside register without hindering accesses variables however new register allocation algorithm needed aware bitwidths program variables capable packing multiple subword variables single register paper presents one algorithmthe algorithm propose two key steps first combination forward backward data flow analyses developed determine bitwidths program variables throughout program analysis required declared bitwidths variables often larger true bitwidths moreover minimal bitwidths program variable vary one program point another second novel interference graph representation designed enable support fast highly accurate algorithm packing subword variables single register packing carried node coalescing phase precedes conventional graph coloring phase register allocation contrast traditional node coalescing packing coalesces set interfering nodes experiments show bitwidth aware register allocation algorithm reduces register requirements 10 50 traditional register allocation algorithm assigns separate registers simultaneously live subword variables b introduction programs manipulate data subword level ie bit sections within word common place embedded domain examples applications include media processing well network processing codes 12 19 key characteristic applications point data exists packed form multiple data items packed together single word memory fact cases input output application consists packed data input consists packed data application typically unpacks processing output required packed form application computes results explicitly packs generating put since c language choice embedded applications packing unpacking operations visible form bitwise logical operations shift operations code addition generation extra instructions packing unpacking data additional registers required hold values packed unpacked form therefore causing increase register pressure new instruction set architectures embedded network processors allow bit sections within register directly referenced 6 15 18 example following instruction adds 4 bit value r2 6 bit value r3 stores 8 bit result r1 operands extended adding leading zero bits match size result addition carried recent work incorporated bit section referencing popular arm processor shown proper use instructions eliminates need explicit packing unpacking operations thus reduces number executed instructions significantly 13 another important consequence instruction set support multiple subword sized variables made simultaneously reside register without hindering access variables thus approach reduces register requirements program since embedded processors support small number registers eg arm 16 supports 16 registers even fewer directly accessible instructions thumb mode efficient use register resources extremely important illustrate potential reduction register requirements let us consider examples shown fig 1 typical embedded codes code fragments taken adpcm au dio gsm speech applications respectively perform unpacking packing code fragment references three variables declared size 8 bits live ranges variables including widths shown examining live ranges find traditional register allocator must use two registers hold values however bitwidth aware register allocation dramatically reduce register requirements unpacking last use delta1 last use delta2 packing unpacking packing char char delta1 delta2 char alpha1 alpha2 inbuffer delta2 alpha2 outbuffer figure 1 subword variables multimedia codes hold values variables 8 bits 7 bits single register respectively two code fragments remaining bits register used hold additional subword sized variables paper describe approach achieving register allocations use part single register opposed multiple registers code fragments two key components approach first employ algorithms constructing live ranges variables minimal bitwidths widths short live ranges various program points also com puted second employ fast effective method packing together multiple live ranges packing phase essentially performs coalescing interfering nodes enhanced interference graph representation program following packing register allocation carried using conventional graph coloring algorithm assigns single register node graph 1 3 8 number challenges developing fast yet effective algorithms components described live range construction first challenge identify minimal width live range relevant program point analysis must developed purpose due two reasons illustrated exam ples variables declared larger needed bitwidths eg delta1 declared 8 bit entity uses 4 bits bitwidth variable change one program point another variable may contain multiple data items consumed one one eg inbuffer initially 8 bits data delta1 assigned contains 4 bits useful data present combination forward backward data flow analysis find minimal widths second challenge efficiently identify minimal widths obvious way develop analysis given variable declared b bits wide determines need keeping b bits register program point cost bitwise analysis high directly dependent upon bitwidths variables achieve efficiency develop analysis views variable regardless size made three bit sections called leading middle trailing sections goal analysis determine minimal sized middle section must kept register leading trailing sections discarded approach effective practice unneeded bits variable program point typically form leading andor trailing bit sections packing multiple variables register variables packed together coalescing two nodes interference graph shapes live ranges must taken account determine whether live ranges co alesced coalescing possible characteristics coalesced live range must determined perform coalescing simple approach problem may accurate leading missed opportunities coalescing example earlier example maximum width inbuffer delta1 8 4 bits respectively simple method ignores shapes assigns width 12 bits live range resulting coalescing two overestimates width 4 bits therefore approach simple thus fast miss coalescing opportunities completely accurate approach developed compares shapes live ranges relevant program points determine whether coalesced possible computes compact shape resulting live range approach miss coalescing opportunities expensive present fast highly accurate approach node coalescing based upon enhanced labeled interference graph shapes interfering live range pairs compared exactly generate labelling node coalescing driven labelling updated constant time following coalescing step labelling approximate highly accurate practice therefore missed coalescing opportunities rare outline remainder paper organized follows section 2 present live range construction algorithm enhanced interference graph representation node coalescing algorithm based upon affect variable packing described section 3 experimental evaluation presented section 4 related work discussed section 5 conclusions given section 6 2 live range construction definition 1 live range live range variable v program region value v live point live range subset bits vs current value may used future computation right hand side reference variable v program statement need explicitly reference bits v execution statement consequence point vs live range bits representing v live therefore different amounts bits may needed hold value v register different program points definition 2 dead bits given variable v according declaration represented bits subset bits say dead program point p computations following point p use current value v performed without explicitly referring bits definition 3 live range width given program point p variable vs live range width vs live range point p denoted wv p defined bits representing variable v according declaration divided three contiguous sections follows leading section l v p dead bits middle section wv p live bits trailing section tv p dead bits p let sv denote statement refers value variable v define nousesv v ordered pair l leading l bits trailing bits v need explicitly referred execution sv conditions subset bits variable v sufficient evaluating expression given fig 2 first three situations exploit use compile time constants left shift right shift bitwise operations results computed expressions dependent upon subset bits v thus remaining bits considered used next two situations exploit presence zero bits v leading zero bits present v need explicitly held register perform arithmetic relational operations results operations correctly computed without explicitly referring bits similarly results bitwise operation computed without explicitly referring leading trailing zero bits v therefore consider zero bits used finally cases right hand side reference v considered use bits v ie nousesv v 0 0 identify dead bits hence width live range program point live range perform following analy sis first carry forward analysis compute safe estimate leading trailing zero bit sections program variable program point information needed computation nousesv v two cases described arithmeticrelational operations bitwise operation computed information fully second carry backward analysis identify dead bit sections program variable program point describe analyses next without loss generailty assume discussion variables declared bitwidth leading trailing zero bit sections described leading trailing zeros need found results operations computed without explicitly referring thus sections treated dead bit sections forward analysis employed determine leading trailing zero bit sections variable program point variable v assigned cases examining expression right hand side determine leading trailing zero bit sections v following assignment case constant assignment looking value constant c determine zero bit sections v case signed numbers leading zero bit section formed sign extension bits ie zeros ones right left shift constant amount ie results creation leading trailing bit sections bitwise logical operation ie results propagation zero bit sections copy assignment zero bit sections x simply propagated v nothing asserted value assigned v analysis conservatively assumes leading trailing zero bit sections note since zero bit sections one variable may depend upon zero bit sections another variable variables must analyzed simultaneously meet operator forward analysis safely computes smallest leading trailing zero bit sections present variable across incoming edges data flow equations computing zero bit sections given fig 3 zbs inout n v represents zero bit sections variable v entryexit node n recall simplicity list situations involving variables bitwidth variables different size considered additional opportunities arise example unsigned short integer assigned unsigned long integer leading zero bit section created latter situations found enhance analysis leading trailing dead bit sections fig 3 also gives data flow equations computing dead bit sections dbs inout n v represents leading trailing dead bit sections variable v entryexit node n expected determination dead bit sections based upon backward analysis examines statement sv identify subset bits variable v whose values used statement information represented nousesv v described earlier computed statement given results zero bit sections analysis bit sections nousesv v dead point statement sv also dead immediately statement sv statement defines v use bits variable dead indicated ie leading trailing dead bit sections size equal width variable join operator conservatively computes bit sections dead exit node also dead entry points successor nodes example results applying analyses illustrated using example shown fig 4 simplicity use straightline code example although technique applies programs complex control flow structures given code fragment first show zero bit sections variable point assigned value next show results dead bit sections analysis set dead variables immediately following statement given example immediately following statement 3 higher order 4 bits variable zero case entire variable dead simply list name variable eg involved variables fully dead immediately preceding code fragment results dead bit sections analysis equivalent live ranges shown area enclosed solid lines corresponds bit section dead examine ranges easy see maximum combined width live ranges program point bits therefore single bit register sufficient handle variables note traditional register allocator ignores widths variables need four registers code fragment sv characteristics sv nousesv v trailing bits v used l compile time constant l leading bits v used c compile time constant l l leading bits trailing l leading trailing zero bits bits v used v op op arithmetic relational operator l leading bits v used v least l leading zero bits v least l leading zero bits l l leading bits trailing bits trailing zero bits v used forms statements use v 0 bits v used figure 2 partial use variables bits input control flow graph end node contains single intermediate code statement definitions boundary conditions variable v zbs start v dbsout end v bitwidth variable v initialization set vectors number variables meet join operators v meet join operator forward backward analysis respectively zero bit sections analysis solve iteratively zbs n v zbsout p v zbsout n v constant sections l c constant l c constant zbs n x elseif n zbs n x zbs n elseif n zbs n x zbs n elseif n 0 zbs n v otherwise dead bit sections analysis solve iteratively dbs n v uses v dbsout n v otherwise dbsout n v dbs v figure 3 forward backward bit sections analysis int short e 16 bits char b c 8 bits 2 3 4 es last use 5 use 7 8 9 last use 10 last use b0x80 11 last use c 12 last use zero bit sections 1 e 00 2 00 3 40 4 120 5 6 240 7 b 00 8 c 00 9 10 11 12 dead bit sections 1 abcd 2 abc 3 abcd40 4 a120bcd40e 5 a120bcd40e 6 a240bcd40e 7 a240cd40e 8 a240b07d40e 9 ab07d40e 10 abd40e 11 abcd40e 12 abcde4 121 7e figure 4 illustration live range construction 2 3 4 es last use 5 use 7 8 9 last use 10 last use b0x80 11 last use c 12 last use 1 2 3 4 5 use r019 7 8 9 last use r07 10 last use r16 11 last use r815 12 last use r2031 1 2 3 4 5 use r2019 7 8 9 last use r207 10 last use r215 11 last use r21623 12 last use r11627 original code code using one register code using two registers figure 5 using registers packed variables 3 variablepackingiterativeco alescing interfering nodes section present variable packing algorithm let us first see impact variable packing generated code fig 5 shows code resulting packing variables fig 4s example one register r subscripts indicate bit sections within r referenced clear bit section referencing supported small number registers used effectively note shift operations statements 3 4 6 translated intraregister bit section moves move sequence bits one position another also two additional intraregister moves preceding statements 4 8 required moves required sometimes variable allocated register defined free contiguous register bit section appropriate size may available free bits may fragmented case values live variables present register must shifted combine smaller free bit section fragments one large contiguous bit section algorithm developed sacrifices variable packing opportunities favor fast execution time preceding example although one register sufficient algorithms allocates b c one register e another reg ister resulting code based upon using two registers shown figure since variables packed tightly find need carry two intraregister moves overcoming problem fragmentation free bits interference graph approach variable packing perform prepass global register allocation merit approach existing register allocation algorithms used without modifications variable packing performed addition design variable packing algorithm operate upon live range interference graph must constructed way perform global register allocation nodes interference graph correspond live ranges interference edges introduced node pairs representing overlapping live ranges easy see perspective interference graph variable packing performed iterative coalescing interfering nodes step pair interfering live ranges coalesced one node place program collective width greater number bits register variable packing register allocation performed using transformed interference graph definition 4 maximum interference width given pair live ranges lr1 lr2 maximum interference width live ranges denoted miw lr1 lr2 maximum combined width live ranges across program points two live ranges overlap let p denote width live range lr program point p miw lr1 lr2 computed follows iff 8n st lr1 lr2 overlap n clear lr1 lr2 coalesced iff number bits register always assume variable width greater jrj desired goal coalescing set achieving maximal coalesing reduces number nodes interference graph mimimum possible achievable legal sequence coalescing operations however theorem present next establishes achieving maximal coalescing npcomplete fact construction seen result holds true even straightline code theorem live range coalescing npcomplete given set live ranges l constant l jlj exist live range coalesing reduces number live ranges l width coalesced variable exceeds jrj program point proof trivial see live range coalescing problem np given solution easy verify correct polynomial time performing reduction bin packing problem see 7 page 226 show live range coalescing npcomplete bin packing problem stated follows given set items u size su u 2 u positive integer bin capacity b partition u disjoint sets u1 u2 uk sum sizes items set u b less instance bin packing problem transformed instance live range coalescing problem fol lows corresponding item u 2 u construct live range uniform width su assume program point live ranges fully overlap let find live range coalescing reduces number live ranges l none coalesced live ranges width greater jrj essentially solved corresponding instance bin packing problem overall outcome coalescing depends upon selection order pairs nodes examined coalescing given result use iterative coalescing heuristic picks node graph coalesces many neighboring nodes possible repeats process remaining nodes let us briefly consider runtime complexity iterative coalescing algorithm coalescing must carried series steps step two nodes coalesced determine whether two nodes say lr1 lr2 coalesced must check condition miw lr1 lr2 jrj scanning two live ranges across entire length program two live ranges overlap time complexity operation ol l bounded number statements program number coalescing operations bounded number nodes n interference graph thus total time spent coalescing bounded l avoid expensive operation scanning two live ranges compute miw lr1 lr2 time attempting coalescing explore use fast methods based upon use conservative estimates miw lr1 lr2 conservative estimate overestimate miw must never underestimate let us consider simple obvious approximation scanning entire program exactly precompute maximum width live range lr maxlr using information estimated maximum interference width emiw lr1 lr2 computed follows emiw lr1 lr2 note need scan program compute emiw lr1 lr2 method simple allows estimation emiw two live ranges time iterative coalescing o1 time fails handle common situation well fig 6 live ranges b shown clear allocated single register however since 64 cannot coalesce using simple approach edge labelling node labelling figure vs edge labels address problem node labels make use edge labels edge b labelled pair values ba b ba represent widths b respectively program point corresponding maximum interference width b ie miw example edge label 16 16 important observation looking edge label determine coalescing b possible combined width program point exceed edge labels formally defined definition 5 interference graph labels initially interference edge b labelled ba contributions b miw b ie miw subsequently edge c formed coalescing labelled cd dc cd dc contributions c emiw c ie emiw c nodes coalesced labels edges emanating newly created node must computed process imprecision introduced developed fast highly accurate method computing edge labels next present method detail updating edge labels following coalescing edge node c one nodes b edge ab c transformed graph must determine label abc cab edge two cases arise handled shown fig 7 first case involves situation c connected edge either b case label edge ab c label edge c b c case may since c interferes b coalescing b maximum interference width ab c maximum interference width b c noted additional imprecision introduced generation label edge abc second case considers situation edge c b case additional imprecision may introduced estimation abc cab edge ab c label based upon conservative estimate c goal carry estimation quickly avoiding examining complete live ranges corresponding nodes b c addition would like obtain label precise possible based upon existing labels three nodes edges three candidate estimates emiw b c denoted ea eb ec fig 7 considered ea estimate sum widths b c point maximum interference width b c takes place point best estimates widths b c c b respectively ie represents point maximum interference width c takes place therefore values eb ec similarly computed may case emiw b c equal three computed values ie ea eb ec derive conservative estimate emiw b c values particular sort values ea eb ec intermediate value eint safe approximation emiw b c therefore shown fig 7 choose value depending upon whether eint ea eb ec accordingly compute abc cab theorem fig 8 formally proves correctness method case node c edge either b abba abba acca acca case ii node c edge b abba acca bccb figure 7 updating labels coalescing b intermediate value theorem follows single coalescing operation takes o1 time coalescing operation removes node interference graph therefore number coalescing operations bounded number nodes n interference graph hence run time complexity coalescing operations bounded recall slow algorithm complexity l example let us apply coalescing operations using intermediate value theorem interference graph live ranges constructed example fig 4 assume registers 32 bits wide example live ranges constructed first build five node interference graph shown fig 9 nodes interference graph coalesced number ways one order shown fig 9 first merge e according rules handling case labels edges emanating become labels corresponding edges emanating de next two steps nodes b c coalesced case ii arises therefore labels edges updated using intermediate value theorem giving results shown figure note bitwidths variables ignored original interference graph requires 4 registers color graph contains clique four nodes contrast register allocator need use two colors color coalesced interference graph thus proposed coalescing algorithm reduces register requirements interference graph 4 registers 2 registers code based upon usage two registers shown fig 5 let us conisder result application simple coalescing approach maintains node labels assuming pairs nodes considered coalescing considered application algorithm based upon edge labels fig 9 perform two coalescing operations shown fig 10 thus case 3 registers would required therefore using edge labels superior using node labels example figure 9 illustration node coalescing8 figure coalescing using node labels theorem intermediate value theorem emin eint emax st eint safe proof proof carried two parts lemma 1 shows general emin safe estimate miw bc emin less miw shows emin less miw b c values eint emax greater miw b c lemma 1 lemma 2 follows eint best safe estimate miw b c among three values ea eb ec lemma 1 emin miw b c true consider construction live ranges shown figure low note 1 construction clearly confirms indeed emin may safe estimate c wd wd ww wwd w1wd lemma contributions b c miw b c definition miw must case loss generality let us assume emin ea given emin miw 3 bc c b wb wc 6 ac c 7 b ba 9 ec miw b c shown ea miw bc eb miw b c ec miw b c given ea emin thus conclude emin miw c lemma 1 lemma 2 follows emiw eint best safe estimate miw b c among three values ea eb ec hence proof intermediate value theorem complete figure 8 intermediate value theorem priority based coalescing far focussed fundamental issues bitwidth aware register allocation ie analysis live range construction variable packing using node coalescing addressed following issues coalescing always good order node coalescing attempted coalescing reduce chromatic number graph always case situations coalescing may increase chromatic number graph graph shown chromatic number two coalescing increases three coalescing solution preventing harmful coalescing proposed briggs et al 1 observed node created coalescing two nodes fewer k neighbors degree k k number colors resulting node always colorable thus propose restricting coalescing situations resulting nodes guaranteed colorable cd figure 11 increase chromatic number due coalescing order node coalescings attempted impacts shape final graph thus number colors required color resulting graph example reconsider example fig 10 merge nodes b well nodes c resulting graph contains three nodes colored using two colors opposed three colors required resulting graph fig 108 e28 figure 12 impact ordering coalescing operations one approach propose address problem assign priorities nodes node highest priority say n picked neighbors n considered coalescing decreasing order priority nodes coalesced n next highest priority node picked process repeated priority live range l computed shown greater savings due elimination loads stores higher priority however savings normalized respect amount register resources used register usage based upon duration number bits occupied live range hence simply area live range obtained summing together number bits occupied live range relevant program points liverangearea algorithm carrying node coalescing followed register allocation summarized fig 13 following iterative node coalescing phase set coalesced variables given new name code transformed use name ad dition intravariable moves introduced preserve program se mantics resulting interference graph processed using traditional coloring based register allocator 1 construct interference graph 2 label edges interference widths 3 construct prioritized node list 4 node list 6 5 get node say n prioritized node list 6 node ns adjacency list 7 attempt coalescing n 8 successful update graph prioritized list 9 endfor 10 endwhile 11 replace coalesced variable set new name 12 introduce intravariable moves 13 perform coloring based register allocation figure 13 algorithm summary 4 experimental results evaluated proposed technique using benchmarks taken mediabench 12 adpcm g721 netbench 14 crc dh bitwise project mit 17 softfloat newlife motiontest bubblesort histogram representative class applications important embedded domain also added image processing application thres applied technique selected functions benchmarks large size constructed interference graphs selected functions measured register requirements fully coloring graphs using following algorithms bitwidth unaware algorithm given time allows single variable reside naive coalescing nc algorithm labels node declared width uses labels perform coalescing c coalescing oc algorithm builds live ranges using bit section analysis labels edges maximum interference width information drive coalescing three cases register requirements computed repeatedly applying chaitins algorithm find minimum number registers graph could fully colored results experiments given table 1 oc algorithm reduces register requirements 10 50 nc algorithm nearly successful reducing register requirements registers quality code expected improve significantly particularly true arm processor bit section referencing extensions 13 context research carried arm 16 registers table 1 register requirements benchmark registers used function bu nc oc adpcm decoder 15 15 13 adpcm coder g721update g721quantize 6 5 5 threshomogen motiontestmain 6 6 5 bubblesortmain 9 9 7 histogrammain 7 7 6 table 2 benefits coalescing benchmark number nodes function adpcm decoder 17 15 adpcm coder 20 17 g721update 22 15 thresmemo 6 4 threscoalesce threshomogen 12 7 thresclip 7 5 newlifemain 8 5 motiontestmain 9 7 bubblesortmain 15 11 histogrammain 13 11 crcmain 12 11 dhencodelastquantum 8 5 table 3 change maximum clique size benchmark number nodes function adpcm decoder 15 13 adpcm coder g721quantize 6 5 thresmemo 6 4 threscoalesce threshomogen 11 6 thresclip 6 4 newlifemain 7 4 motiontestmain 6 5 dhencodelastquantum 7 4 table 4 live ranges bitwidth bits number live range widths bits live declared max size ranges size bsa adpcmdecoder adpcmcoder g721update g721fmult g721quantize thresmemo threscoalesce threshomogen thresclip newlifemain motiontestmain bubblesortmain histogrammain crcmain dhencodelastquantum understand significance two key steps algorithm namely live range construction based upon bit section analysis node coalescing examined data greater detail results table 2 show extent node coalescing reduces number nodes interference graph see significant amount coalescing observed occur data table 4 shows significance live range construction algorithm declared widths live ranges well reduced maximum widths bit section analysis bsa given see many live ranges declared widths much larger reduced maximum widths reason nc algorithm nearly successful oc algorithm made clear part data declared bitwidths variables often much greater true bitwidths finally noted although coalescing necessarily guarantee reduction register requirements programs significant reduction observed looked interference graphs understand case found programs significantly large cliques present accounted register require ments moreover maximum sized clique interference graph typically contained multiple subword data items thus node coalescing resulted reduction size maximum sized clique hence register requirements table 3 shows reduction size largest cliques programs observation holds benchmarks exhibit behavior omitted table case soft float bubblesort large cliques case g721update histogram although large cliques present reduced size node coalescing 5 related work bit section analysis stephenson et al 17 proposed bitwidth analysis discover narrow width data performing value range analysis compiler proven certain data items require complete word memory compressed smaller size eg word data may compressed halfword byte data number important differences bitwidth analysis analysis live range construction first analysis aimed narrowing width variable program point much possible since allocate varying number register bits variable different program points second approach eliminate trailing bit section value range analysis never approach eliminate leading bit section dead bits contains nonzero values value range analysis eliminate leading bit section contains zero bits program budiu et al 2 propose analysis inferring values individual bits analysis much expensive analysis must analyze bit variable approach maintains summary information form three bit sections variable finally analysis zhang et al 9 aimed automatic discovery packed variables paper aimed carrying analysis facilitate variable packing memory coalescing data compression davidson jinturkar 4 first propose compiler optimization exploits narrow width data proposed memory coalescing improving cache performance program zhang gupta 20 proposed techniques compressing narrow width pointer data improving cache performance however techniques explored context general purpose processors therefore aggressive packing scalar variables registers studied contrast work present paper aimed new class embedded processors efficient use small number registers made possible holding multiple values single register work aware deals register allocation processors support bit section referencing wagner leupers 18 ever work exploits bit section referencing context variables already contained packed data carry additional variable packing described paper multimedia instruction sets support long registers hold multiple words data carrying simd operations 5 11 compiler techniques allocate array sections registers con trast work aimed shrinking scalars subword entities packing registers one word long scalar variables handle ignored superword techniques finally context embedded processors work done dealing irregular constraints register allocation eg 10 however work done context arm instruction set bit referencing extensions bit section packing important issue 13 6 conclusions multimedia network processing applications make extensive use subword data moreover embedded processors typically support small number word sized registers instruction set support bit section referencing provides us opportunity make effective use small number registers packing multiple subword sized variables single register without incurring additional penalty accessing packed variables however techniques exist either identifying variable bitwidth data packing registers presented first algorithms solve problems presented efficient analyses constructing variable bitwidth live ranges efficient variable packing algorithm operates enhanced interference graph experiments show proposed techniques reduce register requirements embedded applications 10 50 7 acknowledgements work supported darpa award f296010010183 national science foundation grants ccr0208756 ccr0105535 ccr0096122 eia9806525 university arizona 8 r improvements graph coloring register allocation bitvalue inference detecting exploiting narrow width computations register allocation spilling via graph coloring memory access coalescing technique eliminating redundant memory accesses compiling simd within register data alignment subword parallelism dsp computers intractability guide theory npcompleteness iterated register coalescing representation bit section based analysis optimization preferencedirected graph coloring exploiting superword level parallelism multimedia instruction sets tool evaluating synthesizing multimedia communications systems bit section instruction set extension arm embedded applications benchmarking suite network processors new network processor architecture high speed communications arm architecture reference manual bitwidth analysis application silicon compilation c compiler design industrial network processor commbench telecommunications benchmark network processors data compression transformations dynamically allocated data structures tr improvements graph coloring register allocation memory access coalescing iterated register coalescing mediabench bidwidth analysis application silicon compilation exploiting superword level parallelism multimedia instruction sets compiler design industrial network processor preferencedirected graph coloring arm architecture reference manual computers intractability bit section instruction set extension arm embedded applications netbench compiling simd within register bitvalue inference representation bit section based analysis optimization data compression transformations dynamically allocated data structures register allocation myampersandamp spilling via graph coloring ctr ranjit jhala rupak majumdar bit level types high level reasoning proceedings 14th acm sigsoft international symposium foundations software engineering november 0511 2006 portland oregon usa bengu li rajiv gupta simple offset assignment presence subword data proceedings international conference compilers architecture synthesis embedded systems october 30november 01 2003 san jose california usa lal george matthias blume taming ixp network processor acm sigplan notices v38 n5 may oguz ergin deniz balkan kanad ghose dmitry ponomarev register packing exploiting narrowwidth operands reducing register file pressure proceedings 37th annual ieeeacm international symposium microarchitecture p304315 december 0408 2004 portland oregon
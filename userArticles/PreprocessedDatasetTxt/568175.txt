jones optimality bindingtime improvements strength program specializers jones optimality tells us program specializer strong enough remove entire level selfinterpretation show jones optimality originally aimed futamura projections plays important role bindingtime improvements main results show regardless bindingtime improvements apply source program matter extensively specializer jonesoptimal strictly weaker specializer jones optimal viewing bindingtime improver generating extension selfinterpreter connect results previous work interpretive approach b introduction bindingtime improvements semanticspreserving transformations applied source program prior program specialization instead specializing original program modified program specialized goal produce residual programs better sense ones produced original program classical example 6 bindingtime improvement naive pattern matcher oine partial evaluator 20 produce specialized pattern matchers ecient generated knuth morris oine partial evaluator cannot achieve optimization without suitable bindingtime improvement wellknown two programs functionally equivalent may specialize dierently bindingtime improvements lead faster residual programs improving flow static data make specializer terminate often dynamizing static computations numerous bindingtime improvements described literature eg 3 7 20 routinely used oine online specializers main advantage require user modify specializer order overcome limitations specialization method hence handy many practical situations surprisingly several questions raised bindingtime improving programs limitations bindingtime improvements conditions modifications trigger desired specialization ef fect good luck naive pattern matcher may rewritten lead oine partial evaluator perform kmpoptimization bindingtime improvements found problem specializer paper answers related questions conceptual level rely particular specialization method technical details interested statements valid specializers identified conditions figure 1 shows structure specializer system employing bindingtime improver preprocessor bindingtime improver bti takes program p division sd classifies ps parameters static dynamic returns functionally equivalent program p program specialized respect static data x specializer spec specializer bindingtime improver take division sd input static specializer system spec figure 1 bindingtime improver preprocessor program specializer data x available specializer flow transformation common virtually specializer systems usually specializer automatic program transformer bindingtime improvements often done hand investigation matter steps performed results paper extend previous work jones optimality 18 28 22 32 interpretive approach 11 13 34 see jones optimality 18 plays key role power bindingtime improvers together static expression reduction establishes certain kind nontriviality among others precisely answer old question whether oine partial evaluator powerful online partial evaluator paper organized follows reviewing standard definitions interpreters specializers sect 2 present two main ingredients work jones optimality sect improvers sect 4 main results proven sect 5 additional theorems presented sect 6 connection interpretive approach established sect 7 opportunities optimizing constructions discussed sect 8 conclude related work sect challenges future work sect 10 assume reader familiar partial evalu ation eg presented 20 part ii 2 preliminaries section reviews standard definitions interpreters specializers notation adapted 20 use divisions sd classifying parameters program static dynamic 1 assume always dealing universal programming languages 21 notation program text p written language l let denote application lprogram p input index l unspecified assume language l intended multiple arguments written list notation strict arguments equality program applications shall always mean strong computational equivalence either sides imply specializers use oine partial evaluation equation defined equal sides undefined programs input output drawn common data domain including program texts convenient dealing programs accept programs data input suitable choice set lists known lisp define program domain leave programming language unspecified elements data domain evaluate programs applied enclosing define program using abstraction expression needs translated corresponding programming language denoted p q p translation always possible l universal programming language 22 interpreters specializers follows standard definitions interpreters specializers definition 1 interpreter lprogram int int definition 2 selfinterpreter lprogram sint sint selfinterpreter l sint llinterpreter definition 3 specializer lprogram spec spec specializer l ip p x simplicity assume programs specialize two arguments first argument static even though make use division sd definition keep explicit reasons explained 12 specializer need total definition allows spec diverge p sd x diverges x practice specializers often sacrifice termination behav ior discussion termination issues see 19 specializer trivial residual programs produces simple instantiations source programs definition 4 trivial specializer lspecializer spec triv spec trivial realistic specializers evaluate static expressions source program expression static depends known data thus precomputed specialization time define special case static expression reduction sucient purposes definition running time taken 20 sect 317 2 definition 5 running time program data d1 dn let p d1 dn denote running time definition 6 static expression reduction specializer spec spec static expression reduction q q p 2 measure running time timed semantics eg number elementary computation steps definition tells us terms residualprogram eciency dierence specializing program q respect value specializing composition p q q respect value x implies specializer contains least interpreter universal program evaluate static applications definition p specializer static expression reduction nontrivial definition implies power perform universal computations specializers im plemented including online oine partial evaluators try evaluate many static expressions possible improve eciency residual programs satisfy static expression reduction property given 3 jones optimality translating program specializing interpreter important entire interpretation overhead moved let us look problem closely explain definition jones optimality 31 translation specialization let p n program let intn n linterpreter let spec specializer l 1st futamura projection 9 defined using defs 1 3 functional equivalence q p note program p written language n program q written language l n toltranslation achieved specializing n linterpreter intn respect p say q target program source program p translation always performed consider trivial specializer first argument intn instantiated p result trivial target program clearly translation expect target program inecient contains entire interpreter natural goal therefore produce target programs ecient source programs unfortunately cannot expect specializer produce ecient target programs interpreter nontrivial languages specializer exists 16 could make maximal use static input p programs 32 jonesoptimal specialization specializer said strong enough 18 completely remove interpretation overhead selfinter preter definition adapted 20 64 makes use 1st futamura projection definition 7 jones optimality let sint sint self interpreter specializer spec spec jonesoptimal sint joptspec sint specializer spec said jonesoptimal exists least one selfinterpreter sint source programs p target program p least ecient inputs source program p tells us spec remove entire layer selfinterpretation case selfinterpreter specialization interesting easy judge extent interpretive overhead removed comparing source target programs written language particular programs p p identical safe conclude goal achieved also explained 25 limits structure residual programs inherited structural bounds source programs best observed specializing selfinterpreter eg arity function definitions residual program easy require jones optimality always easy satisfy instance partial evaluator firstorder functional language algebraic data types 25 combination several transformation methods necessary constant folding unfolding polyvariant specialization partially static values constructor specializa tion type specialization jones optimality first proven 28 lambdamix see also 24 first implementation jonesoptimal specializer oine partial evaluator 26 lisplike language early oine partial evaluator 23 similar language utilizes partially static structures produce near identity mappings many specializers known whether jonesoptimal partial evaluators fclmix 15 impossible write selfinterpreter makes jones optimal recent work 32 jones optimality concerns tagelimination specializing selfinterpreters strongly typed languages note definition jones optimality satisfied simple construction else mysint fixed selfinterpreter want myspec jonesoptimal spec triv trivial specializer def 4 specializer myspec returns last argument x unchanged first argument p equal mysint otherwise myspec performs trivial specializa tion clearly specializer useful practice formally joptmyspec mysint finally show jonesoptimal specializer static expression reduction exists fact play important role next sections properties satisfied simple construction myspec stat case p case implements pattern matching program p consists composition two arbitrary programs p decomposed 3 q q q specialized respect result evaluating sint selfinterpreter otherwise p specialized respect x specializer jonesoptimal mysint expression reduction property def 6 realistic 3 shall concerned technical details parsing lprogram p jonesoptimal specializers instance 26 23 25 28 also satisfy property static expression reduction 4 bindingtime improvers bindingtime improvements 20 semanticspreserving transformations applied source program specialization aim produce residual programs better sense produced original source program numerous bindingtime improvements described literature eg 3 7 20 formally bindingtime improver program takes program p division ps arguments static dynamic transforms p functionally equivalent program p bindingtime improver performs transformation independently static values available specializer definition 8 bindingtime improver lprogram bti bti bindingtime improver l using defs 3 8 following functional equivalence residual programs r r produced directly specializing p specializing bindingtime improved version p practice expect hope program r better sense program r example bindingtime improvements lead faster residual programs improving flow static information specialization time important note bindingtimer improver cannot precompute residual program since static values make table containing possible residual programs since general specialization source program allows infinite number dierent residual programs compare translator translator cannot precompute results source program store say table target program since general infinite number dierent results term bindingtime improvement originally coined context oine partial evaluation 20 improve flow static information easing transformations routinely used specialization methods surprising since exists specialization method could make maximal use available information cases use term bindingtime improvement semanticspreserving pretransformation regardless particular specialization method note def 8 require source program transformed identity transformation correct trivial bindingtime improver course bindingtime improver useful must perform nontrivial transformations least programs oth erwise residual programs r r 4 always identical 5 jonesoptimalitybindingtime improvements previous sections two dierent streams ideas presented bindingtime improvements jones optimality specialization programs related put ideas together present two main results 51 sufficient condition first theorem tells us every jonesoptimal specializer spec 1 exists bindingtime improver allows specializer achieve residualprogram e ciency specializer jones optimality su cient condition proof makes use general construction bti theorem 1 jones optimality sucient specializers reduction following holds proof proceed two steps 1 let sint 1 selfinterpreter spec 1 jones optimal specializer spec 2 define bindingtime improver z two stages q bindingtime improver depends sint 1 spec 2 program p given program p division sd program bti produces new program performs ps computation two stages first spec 2 specializes p respect x sint 1 evaluates residual program remaining input defs 2 3 follows new program functionally equivalent p according def 8 bti bindingtime improver since p p x 2 consider rhs implication thm 1 spec 2 let bti bindingtime improver defined 6 let p program let x data bindingtime improved program obtain residual program r specializing p respect x reduces static expressions since p form suits def 6 rewrite 8 9 obtain program r evaluating application spec 2 9 obtain 10 recall rhs implication r 11 result specializing sint 1 respect r spec 1 program r fast r according def 6 specialization 10 joptspec 1 sint 1 conclude r least fast r since relation holds p x proves theorem 52 necessary condition second theorem tells us specializer spec 1 jonesoptimal cannot always reach residualprogram eciency another specializer spec 2 jones optimality necessary condition theorem 2 jones optimality necessary specializers following holds proof assume rhs implication holds choose sint joptspec 2 sint 2 specializer exists nontrivial programming language eg myspec sect 3 let bti bindingtime improver satisfies rhs implication respect spec 2 define sint since bti bindingtime improver sint 2 self sint 1 also selfinterpreter rhs implication let p sint 2 let x program q let data since joptspec 2 sint 2 combining 14 16 realize relation holds q thus conclude joptspec 1 sint 1 proves theorem second theorem imply specializer jonesoptimal cannot benefit bindingtime im provements limit achieved bindingtime improver spec 1 jonesoptimal observe proof thm 2 rhs implication weakened instead quantification spec 2 spec needed quantification spec 2 spec remark literature 22 jones optimality often defined using r assumption follows directly rhs thm 2 must reduce static expressions spec 2 53 discussion 1 combining theorems conclude terms residualprogram eciency specializer jonesoptimal strictly weaker specializer jonesoptimal 2 question whether oine partial evaluator powerful online partial evaluator answered precisely oine partial evaluator static expression reduction jonesoptimal achieve residualprogram eciency online partial evaluator using suitable bindingtime im prover bindingtime improver depends partial evaluators source programs 3 jones optimality important building specializers work well futamura pro jections previously found intuition would good property 17 18 theorems give formal status term optimal name criterion 4 results also support observation 25 specializer weakness cannot overcome inherited limits best observed specializing selfinterpreter amounts testing whether specializer jonesoptimal way test strength specializer see whether derive certain wellknown ecient programs naive inecient programs one popular tests 10 6 29 2 see whether specializer generates naive pattern matcher fixed pattern ecient pattern matcher makes jones optimality stand comparison tests jonesoptimal specializer static expression reduction guaranteed pass tests suitable bindingtime improvement thm 1 specializer may successfully pass number tests long jonesoptimal strength limited way thm 2 even though construction bindingtime im prover used proof thm 1 suggests source program p transformed new p deep transformation may necessary cases extent source program needs transformed practice depends desired optimization actual power specializer spec 1 realistic bindingtime improvers need transform source program 6 robustness section presents two results regarding jones opti mality establish certain kind nontriviality jonesoptimal specializers static expression reduction particular tell us infinite number selfinterpreters jonesoptimal specializer static expression reductions also jonesoptimal theorem 3 jones optimality singularity let spec 1 two jonesoptimal specializers spec 1 reduces static expressions let sint 1 sint 2 sint two selfinterpreters joptspec 1 sint 1 joptspec 2 sint 2 exists selfinterpreter sint 3 sint different beyond renaming sint 1 sint 2 proof proof uses construction combines two selfinterpreters specializer new selfinterpreter without breaking jones optimality define selfinter preter sint 3 sint 3 new selfinterpreter sint 3 dierent beyond renaming selfinterpreters sint 1 sint 2 since sint 3 contains programs show joptspec 1 sint 3 examine spec 1 specializes sint 3 since spec 1 reduces static expressions since sint 3 form suits def 6 conclude relation holds p desired property joptspec 1 sint 3 proves theorem first observe spec 1 jonesoptimal sint 3 spec 2 sint faster p turn faster p surprising since specializers usually idempotent repeatedly applying specializer program lead opti mizations known area compiler construction optimization may enable optimization also underlines realistic choose timing condition def 7 already discussed sect 3 second special case thm 3 let spec sint conclude repeatedly applying theorem every jonesoptimal specializer static expression reduction exists infinite number selfinterpreters specializer also jones optimal state formally following theorem theorem 4 jones optimality robust let spec spec specializer static expression reduction let sint sint selfinterpreter joptspec sint 1 exists infinite number selfinterpreters sint sint pairwise dierent beyond renaming joptspec sint 2 exists infinite number specializers spec spec pairwise dierent beyond renaming joptspec sint proof let copy 0 program define number programs copy i1 copy copy j dierent beyond renaming j 0 1 define number programs sint 0 sint sint selfinterpreter selfinterpreters dierent beyond renaming since contain different copy programs sint form used def 6 conclude joptspec sint since 2 define number programs spec 0 spec specializer specializers dier ent beyond renaming since contain dierent copy programs conclude joptspec sint since proves theorem remark first item also proven using construction proof thm 3 requirement static expression reduction theorems hints certain kind nontriviality jones optimal specializers also suggested thm 1 static expression reduction sure jones optimality singularity specializer infinite number selfinterpreters jonesoptimal specializer static expression reduction said robust respect certain nontrivial modifications selfinterpreters eectively excludes jones optimal specializer myspec defined sect 3 may kind fairness sought earlier work 22 7 three techniques bindingtime improving programs section establish connection three known techniques bindingtime improvements fig ure 2 using standalone bindingtime improver bti c previous sections stacking source program p instrumented selfinterpreter b show thm 1 thm 2 cover two new cases minor adaptions three techniques produce residual programs thus equally powerful respect bindingtime improvements consider following fragments thm 1 thm 2 bindingtime improved version p specialized respect x observe bti functionality translatorif disregard extra argument sd wellknown 20 generating extension 8 interpreter transla tor since bindingtime improver functionality ltol translator generating extension self interpreter l instead bindingtime improving p bti specialize suitable selfinterpreter sint respect p two ways produce residual program specializing selfinterpreter either directly specializer projections 11 incrementally futamura projections 9 b examine two cases 71 incremental specialization let bti bindingtime improver suppose spec 0 specializer sint 0 selfinterpreter 4 using equality obtain new set equations thus every bindingtime improvement performed translative way 29 interpretive way 32 example 34 latter case polyvariant expansion source program specializing suitable self interpreter applying bindingtime monovariant oine specializer modified program overall eect transformation bindingtime polyvariant oine specializer even though bindingtime mono variant oine specializer used produce residual program similarly known 21 27 30 31 optimizing translators generated suitable interpreters techniques also used selfinterpreters improve specialization programs theorems 1 2 carry interpretive case provided replace rhs implication quantification quantification spec 0 spec sint use 32 33 instead 29 30 72 direct specialization two steps 32 33 also carried one step notational convenience let us first redefine format selfinterpreter specializer make easier accommodate programs two three arguments selfinterpreter sint interpreting programs two arguments defined specializer spec specializing programs three 4 every bti exists pair spec 0 sint 0 31 vice versa prop 1 2 appendix arguments defined program q specialized respect one static argument 35 respect two static argu ments b 36 residual program takes remaining arguments input note case dierent division using spec two steps 32 33 carried one step let q selfinterpreter sint defined let twoargument program p let b c arguments x respectively p specialized respect x via sint using 36 r residual program p follows 34 36 let bti bindingtime improver let spec 1 specializer 29 30 suppose spec specializer sint selfinterpreter 5 equation 37 1st specializer projection 11 selfinterpreter instead interpreter specializing program via interpreter also known interpretive approach 11 example 13 generation kmpstyle pattern matcher naive pattern matcher inserting instrumented selfinterpreter naive pattern matcher oine partial evaluator similix mentioned sect 1 oine partial evaluator cannot achieve optimization specializing naive matcher via instrumented selfinterpreter job another example simulation online partial evaluator oine partial evaluator 33 bootstrapping program transformers 30 note transformation 37 optimized another level specializing spec respect sint yields new specializer internalizes techniques self interpreter new specializer know 2nd specializer projection 11 results generating optimizing specializers reported elsewhere eg 13 33 30 main theorems apply case replacing quantification bti bti sint sint rhs implication 73 summary three techniques bindingtime improving programs summarized fig 2 produce residual programs thus equally powerful respect bindingtime improving programs technique preferable practice depends application hand exist example applications literature case results section shed new light relation bindingtime improvements interpretive approach two main theorems cover three cases 5 every pair spec 1 bti exists pair spec sint 39 vice versa prop 3 4 appendix direct specialization one step 1st specializer projection incremental specialization b two steps 1st futamura projection c three steps 2nd futamura projection figure 2 three techniques bindingtime improving programs add 29 30 step generates bindingtime improver selfinterpreter obtain 40 41 42 2nd futamura projection detail formal reasons due definition specializer spec 35 arguments bti reordered 8 optimizingthetheoreticalcon proof thm 1 makes use general bindingtime improver many cases certain fragments relevant bindingtime improving programs particular specializer spec 1 need incorporated bindingtime improver entire specializer spec 2 remainder section point possibilities optimizing general construction program specialization program composition 1 specialization observe bindingtime improved produced bti 7 contains specializer whose argument fixed p makes program structure p much general usually components spec 2 needed specialize p improve construction replacing spec 2 generating extension gen p p program specified generating extension gen p generator ps residual programs use following program instead z composition x q 44 2 composition notice fixed composition sint 1 gen p 44 intermediate data structure residual program produced gen p consumed sint 1 methods program composition may fuse two programs eliminate intermediate data structures code generation parsing redundant operations interesting examine whether known bindingtime improvements justified starting general construction whether new bindingtime improvers derived general construction spec 2 represents desired level specialization lets us illustrate example suppose onpe online partial evaluator ope oine partial evaluator reduces static expressions jonesoptimal selfinterpreter sint specializers according thm 1 r r two residual programs produced bindingtime improver defined bindingtime improving p bti performance r produced ope least good one r produced onpe derive useful bindingtime im prover bti program specialization program com position obtain automatically one bindingtime improved programs published literature eg 6 2 specializing bti respect source program eg naive pattern matcher another challenging question whether bindingtime improver specified combining atomic bindingtime improvements relates combining semantics towers nonstandard interpreters 1 9 related work first version optimality appeared 17 problem 38 specializer called strong enough program p program essentially programs definition optimality used paper appeared first 18 p650 see also 20 sect 64 since power specializer judged many different ways use term jones optimality proposed 22 works focus problem selfapplication none considers role jonesoptimal specialization bindingtime improvements also said 25 specializer weak cannot overcome inherited limits best observed specializing self interpreter results underline argument perspective bindingtime improvements term bindingtime improvement originally coined context oine partial evaluation 20 sourcelevel transformations programs prior specialization routinely used connection specialization method bindingtime improvements range rearrangements expressions eg using associativity arithmetic operations transformations require ingenuity eg transformation naive pattern matchers 6 2 transformations incorporate fragments specializer 4 collection bindingtime improvements oine partial evaluation found 3 sect7 20 chapter 12 actual power bindingtime improvements investigated works idea 11 controlling properties residual programs specializing suitable interpreters used perform deforestation unificationbased information propagation 13 14 bindingtime polyvariant specialization 34 30 transformations 30 oine partial evaluator apparently dierent streams work connected bindingtime improvements related work 5 shown without using bindingtime improvements oine partial evaluator maximally polyvariant bindingtime analysis functionally equivalent online partial evaluator partial evaluators based constant propagation paper shows oine partial evaluator simulate online partial evaluator suitable bindingtime improver provided oine partial evaluator jonesoptimal 10 conclusion anecdotal evidence suggests bindingtime improvement programs useful inexpensive method overcome limitations specializer without modify specializer pretransformation often ad hoc applied improve specialization programs know theoretical limitation conditions method powerful pretransformation results show one always overcome limitations jonesoptimal specializer static expression reduction using suitable bindingtime improve ment always case specializer jonesoptimal thus regardless bindingtime improvements perform source program matter extensively specializer jones optimal said strictly weaker specializer jonesoptimal also answers question whether oine partial evaluator powerful online partial evaluator jones optimality originally formulated assess quality specializer translating programs specializing interpreters results give formal status term optimal name criterion previously found intuition would good property indeed proposed rename optimal special ization jonesoptimal specialization precisely felt wrong imply specializer better jonesoptimal one paper shows way implication indeed true proofs make use construction bindingtime improver works specializer construction sucient theoretical purposes practical incorporates entire specializer practice specialized methods produce residual eect connection particular specializer evidenced numerous bindingtime improvements given literature however universal construction may provide new insights nature bindingtime improvements instance interesting see whether nontrivial bindingtime improvements eg 6 2 justified universal construc tion whether new pretransformations derived specializer incorporated universal construction represents desired specialization strength eventually may lead better understanding design reason bindingtime improvements results imply specializers jonesoptimal cannot benefit bindingtime improve ments example seems kmp test passed oine partial evaluator jones optimal leads question practical limits specializers jonesoptimal work needed identify cause eect concrete level aware online partial evaluator shown jones optimal question answered positively already done oine partial evaluators also much practical experience building jonesoptimal specializers realistic programming languages stance work needed retyping transformations strongly typed languages make transformations standard program specializers truly jonesoptimal acknowledgments comments sergei abramov kenichi asai mikhail buly onkov niels christensen yukiyoshi kameyama siaucheng khoo eijiro sumii earlier version paper greatly appreciated special thanks due anonymous reviewers thorough careful reading submitted paper providing many valuable comments preliminary version paper presented second asian workshop programming languages systems daejeon south korea 11 r combining semantics nonstandard interpreter hierarchies abstraction instantiation stringmatching programs similix 50 manual extracting polyvariant binding time analysis polyvariant specializer equivalence online partial evaluation pattern matching strings better support static data flow partial computation principle partial evaluation computing process approach compilercompiler generalized partial computation generation specializers mechanics metasystem hierarchies program transformation generating optimizing specializers generating transformers deforestation supercompilation compiler generation partial evaluation case study partial evaluation challenging problems partial evaluation mixed computation partial evaluation program generation partial evaluation automatic program generation generating compiler lazy language partial evaluation jonesoptimal specialization strongly typed languages partially static structures selfapplicable partial evaluator evolution partial evaluators removing inherited limits structure selfapplicable partial evaluator ml pattern match compilation partial evaluation mechanical proof optimality partial evaluator positive supercompiler bootstrapping higherorder program transformers interpreters realistic compilation partial evaluation tag elimination jonesoptimality generation higherorder online partial evaluator polyvariant expansion compiler generators tr partial evaluation myampersandohgrcompleteness algebraic specifications structure selfapplicable partial evaluator partial evaluation pattern matching strings partial evaluation selfapplication types better support static data flow generating compiler lazy language partial evaluation partial evaluation automatic program generation extracting polyvariant binding time analysis polyvariant specializer realistic compilation partial evaluation bootstrapping higherorder program transformers interpreters program generation termination bindingtime analysis tag elimination jonesoptimality jonesoptimal specialization strongly typed languages polyvariant expansion compiler generators combining semantics nonstandard interpreter hierarchies mechanics metasystem hierarchies program transformation evolution partial evaluators mk pattern match compilation partial evaluation ctr niels h christensen robert glck offline partial evaluation accurate online partial evaluation acm transactions programming languages systems toplas v26 n1 p191220 january 2004
bounded model checking using satisfiability solving phrase model checking refers algorithms exploring state space transition system determine obeys specification intended behavior algorithms perform exhaustive verification highly automatic manner thus attracted much interest industry model checking programs commercially marketed however model checking held back state explosion problem problem number states system grows exponentially number system components much research devoted ameliorating problemin tutorial first give brief overview history model checking date focus recent techniques combine model checking satisfiability solving techniques known bounded model checking fast exploration state space types problems seem offer large performance improvements previous approaches review experiments bounded model checking public domain industrial designs propose methodology applying technique industry invariance checking summarize pros cons new technology discuss future research efforts extend capabilities b figure must cause initial state visited infinitely often particular reason counter work way use example illustrate fairness constraints imposed bounded model checking given fairness constraint counterexample liveness property afba would need include transition 00 state path loop additional constraint b hold somewhere loop changes generated boolean formula follows backloop ts2s3 state s3 required equivalent either s0 s1 s2 add term requires ab hold loop example possible loop s2 s0 case s3 s0 would replace a3 ci defined ai bi counterexample would satisfy fairness constraint case resulting propositional formula would unsatisfiable 34 conversion cnf satisfiability testing propositional formulae known npcomplete problem known decision procedures exponential worst case however may use different heuristics guiding search therefore exhibit different average complexities practice precise characterization hardness certain propositional problem difficult likely dependent specific decision procedure used many propositional decision procedures assume input problem cnf conjunctive normal form usually goal reduce size cnf version formula although may always reduce complexity search experience however reducing size cnf reduce time satisfiability test well cnf represented set clauses clause set literals literal either positive negative propositional variable words formula conjunction clauses clause disjunction literals example b c e represented ffabcgfdegg cnf also referred clause form given boolean formula f one may replace boolean operators f apply distributivity rule de morgans law convert f cnf size converted formula exponential respect size f worst case occurring f disjunctive normal form avoid exponential explosion use structure preserving clause form transformation 28 procedure booltocnf f vf f case cached f v return clausevf return clause f vf f hg return clausevf fig 2 algorithm generating conjunctive normal form f g h boolean formulas v vh vg boolean variables represents boolean operator figure outlines procedure statements underlined represent different cases considered assignment symbol denotes equality given boolean formula f boolto returns set clauses c satisfiable original formula f satisfiable note c logically equivalent original formula rather preserves satisfiability procedure traverses syntactical structure f introduces new variable subexpression generates clauses relate new variables figure 2 use symbols g h denote subexpressions boolean formula f use vf vg vh denote new variables introduced f g h c1 c2 denote sets clauses subexpression q cached call cachedq returns variable vq introduced q procedure clause translates boolean formula clause form replaces boolean connectives implication equality etc combinations negation operators subsequently converts derived formula conjunctive normal form brute force manner applying distributivity rule de morgans law example u v boolean variables clause called u returns ffuvgfuvgg noted clause never called booltocnf 3 literals practice cost conversion quite acceptable v vh vg boolean variables boolean operator v vh vg logically equivalent clause form clausevf vh vg 4 clauses contains 3 literals internally represent boolean formula f directed acyclic graph dag ie common subterms f shared procedure booltocnf preserve sharing subterms subterm f one set clauses generated boolean formula f booltocnf ftrue generates clause set c ojfj variables ojfj clauses jfj size dag f figure 2 assume f involves binary operators however unary operator negation handled similarly also extended procedure handle operators multiple operands particular treat conjunction disjunction nary operators example let us assume vf represents formula vni0 ti clause form ffvf t0gfvf t1gfvf tngfvf t0tngg treat binary operator need introduce n1 new variables subterms vni0 ti optimization comparison two registers r occurring subformula v1i50ri converted clause form without introducing new variables 4 experimental results carnegiemellon university model checker implemented called bmc based bounded model checking input language subset smv language 26 takes circuit description property proven user supplied time bound k generates type propositional formula described section 31 supports dimacs format 20 cnf formulae input format prover tool 5 based stalmarcks method 35 experiments used prover tool well two public domain sat solvers sato 39 grasp 33 use dimacs format first discuss experiments circuits available public domain known difficult bddbased approaches first investigated sequential multiplier shift add multiplier 12 specified sequential multiplier finished output output certain combinational multiplier c6288 circuit iscas85 benchmark set input words applied multipliers c6288 multiplier 16x16 bit multiplier allowed 16 output bits 12 together overflow bit checked property output bit individually results shown table 1 bddbased model checkers used manually chosen variable ordering bits registers interleaved dynamic reordering application tries change reorderings fly failed find considerably better ordering reasonable amount time proof multiplier finished finite number steps involves verification simple liveness property checked instantly bdd based methods bounded model checking 25 asynchronous circuit distributed mutual exclusion described consists n cells n users want exclusive access shared resource proved liveness property request using resource eventually acknowledged liveness property true asynchronous gate delay execution indefinitely assumption modeled fairness constraint fairness constraints explained section 33 cell exactly gates therefore model n bit sec mb sec mb sato sec mb prover sec mb13579111315 43983 73 26 sum 71923 2202 23970 1066 table 1 16x16 bit sequential shift add multiplier overflow flag 16 output bits n number cells since bound maximal length counterexample verification circuit could verify liveness property completely rather showed counterexamples particular length k illustrate performance bounded model checking chose 510 results found table 2 repeated experiment buggy design simply removing several fairness constraints prover sato generate counterexample 2 step loop nearly instantly see table 3 cells sec mb sec mb sato sec mb prover sec mb sato sec mb prover sec mb3579111315 4857 9 5 22 8 9 8 107 19 168 22 54 5 444 9 table 2 liveness one user dme cells sec mb sec mb sato sec mb prover sec mb3579111315 5622 38 segmentation 28 14 44 413 702 719 702 table 3 counterexample liveness buggy dme 5 experiments industrial designs section discuss series experiments industrial designs checking whether certain predicates invariants designs first explain optimization bounded model checking used experiments 51 bounded cone influence cone influence reduction well known technique3 reduces size model propositional formulae specification depend state variables structure basic idea cone influence coi reduction construct dependency graph state variables specification building dependency graph state variable represented node node edges emanating nodes representing state variables upon combinationally depends set state variables dependency graph called coi variables specification paper call classical coi differentiate bounded version variables classical coi influence validity specification therefore removed model idea extended call bounded cone influence formal definition bounded coi given 4 give intuitive explanation intuition bounded time interval need consider every state variable classical coi time point example check ef p p propositional formula time bound k 0 would need consider state variables upon p combinationally depends initial values consistent p holding ef p would evaluate true without needing consider additional state variables classical coi let us convenience call set state variables upon p combinationally depends initial support could prove ef p true wanted check would need consider set state variables upon initial support depend may include already initial support set feedback present underlying circuit clearly set union initial support set plus second support set state variables upon truth value ef p depends time 1 always subset state variables entire classical coi restrict expanding formula 1 section 31 variables bounded coi particular k get smaller cnf formula general expand entire classical coi main idea behind bounded cone influence 3 cone influence reduction seems discovered utilized number people independently note seen special case kurshans localization reduction 23 52 powerpc circuit experiments ran experiments subcircuits powerpc microprocessor design motorolas somerset design center austin texas processor design somerset designers insert assertions register transfer level rtl simulation model boolean expressions important safety properties ie properties hold time points assertion ever false simulation immediate error flagged experiments checked using bmc two public domain sat checkers sato grasp 20 assertions chosen 5 different processor design blocks turned ag p property p original assertion 1 checked whether p tautology 2 checked whether p otherwise invariant 3 checked whether ag p held various time bounds k 0 20 gate level netlist 5 design blocks translated smv file latch represented state variable individual next state initial state assignments latter assigned 0 1 values knew latches would designated poweronreset sequence4 primary inputs design blocks modeled unconstrained state variables ie neither next state initial state assignments combinational tautology checking eliminated initialization statements ran bmc bound checking inner propositional formula p ag p specifications conditions specification could hold p true assignments state variables support invariance checking entails checking whether propositional formula holds initial states preserved transition relation latter meaning successors states satisfying formula also satisfy conditions met call predicate inductive invariant ran bmc input files initialization assignments intact design block p ag p specification time bound determined whether formula p held single valid initial state design ran bmc mode design block ag p specification initialization assignments removed input file instead initial states predicate added indicated initial states states satisfying p note really believe initial states actually satisfying p technique simply way getting bmc tool check successors states satisfying p one time step time bound k set 1 ag p specification checked specification held showed p preserved transition relation since ag p could hold circumstances successors every state satisfying p also satisfied p note ag p holding conditions could possibly due exclusively behaviors unreachable states instance unreachable state existed satisfied p successor s0 check would fail therefore possible bad behaviors unreachable states technique show p invariant cannot show however found type inductive invariance checking inexpensive bounded model checking therefore valuable fact made cornerstone methodology recommend section 6 experiments used grasp 33 sato 38 satisfiability solvers giving results however indicate solver came rather show best results two actually interesting justification experience time needed satisfiability solving often seconds usually minutes however problem instances particular sat tool labor far longer timeout limit reached quite often found one sat solving tool needs aborted problem instance another tool handle quickly additionally solvers often switch roles later problem instance former slow solver suddenly becoming fast former fast one slow since memory cost satisfiability solving usually slight makes sense give particular sat problem parallel several solvers versions solvers different command line arguments simply take first results come method running multiple solvers job something recommend smv input files given recent version smv model checker smv1version referred earlier compare bdd based model checking 20 smv runs checking ag p specifi cations separately running smv used command line options enabled early detection 4 microprocessors generally designed specified reset sequences powerpc designs resulting values latch known designers appropriate initial state model checking reachability analysis false ag p properties mode verifier need compute fixpoint counterexample existed made comparison bmc appropriate also enabled dynamic variable ordering running smv experiments run wall clock time limits satisfiability solvers given 15 minutes wall clock time maximum complete run smv given hour runs bmc never timed task translating design description specification usually done quite quickly satisfiability solving smv runs done rs6000 model 390 workstations 256 megabytes local memory 53 environment modeling model interfaces subcircuits ran experiments rest microprocessor external computer system processor would eventually placed commonly referred environment modeling one would ideally like environment modeling subcircuits experimented since closed systems rather depend correct functioning upon input constraints ie certain input combinations sequences occurring rest system must guarantee 21 however type invariant checking one would always assured true positives since safety property holds totally unconstrained environment holds real environment proven 13 18 likely industrial design team would first check safety properties unconstrained environments since careful environment modeling time consuming would decide individual basis properties failed invest environment modeling accurate model checking order separate false failures real ones hope digital simulation find real violations exist importantly model checkers counterexamples could provide hints simulations complete design subcircuit may need run instance counterexample may indicate certain instructions need execution certain exceptions occurring etc properties pass invariance test need digital simulation thus conserve cpu resources examples run negatives proved upon inspection designers false negatives experiments still yield however useful information capacity speed bounded model checking section 6 describe methodology reduce eliminate false negatives 54 experimental results mentioned checked 20 safety properties distributed across 5 design blocks single powerpc micro processor control circuits little datapath elements sizes follows circuit latches pis gates bbc 209 479 4852 ccc 371 336 4529 cdc 278 319 5474 dlc 282 297 2205 circuit spec latches pis dlc 7 119 153 table 4 classical coi primary inputs table 4 report sizes circuits classical coi reduction applied ag p specification given arbitrary numeric label circuit relate specifications different design blocks eg specification 2 dlc way related specification 2 sdc many properties involved much cone circuitry design block seen large number specifications cones influence number latches pis however reduced circuits identical one specification another though shared much circuitry table 5 gives results tautology inductive invariance checking p ag p specifica tion runs done bounded coi enabled columns tautology checking preservation transition relation preservation initial states last two conditions must hold boolean formula inductive invariant ay leftmost part column indicates condition holding n recorded time memory usage may appear separated slashes recorded times 1 second memory usage 5 megabytes otherwise appears insignificant time memory seen tautology invariance checking remarkably inexpensive extremely important finding quite costly bdd based methods heart verification methodology propose section 6 surprised small number assertions combinational tautologies expected designers would try insure safety properties held relying combinational opposed sequential circuitry however real environment may fact constrain inputs design blocks combinationally combinational tautologies see section 6 discussion stated many examples exhibited false negatives low time bounds examples found inductive invariants satisfiability solving went quickly high values k counterexamples existed low values k property invariant difficult sat runs neither counterexamples proofs correctness found table 6 shows four examples type bbc specs 1 3 4 sdc spec 1 results obtained using bounded coi also ran examples using classical coi observed improvement bounded coi brings relative classical coi wears higher k values specifically values near 10 intuitively due fact extend time eventually compute valuations state variables classical cone influence however since expect bounded model checking effective finding short counterexamples bounded coi helping augment systems strengths table 6 long k highest k value satisfiability solving accomplished vars clauses list number literals clauses cnf file highest k level time column gives cpu time seconds run highest k value regarding memory usage usually exceed tens megabytes roughly storage needed cnf formula table 7 lists circuits specifications either shown inductive invariants counterexamples found column holds indicates finding inductive invariant n existence counterexample counterexamples next column fail k gives value k counterexample found since counterexamples found k values 2 list time memory usage extremely slight case satisfiability solving took less second memory usage never exceeded 5 megabytes lastly results bddbased model checking smv given 20 properties separately completed one verifications 19 others timed one hour wall clock time smv run somerset computer network allowed unimpeded access cpu running still circumstances smv able complete verification sdc specification 3 classical coi specification gave small circuit 23 latches 15 pis smv found specification false initial state approximately 2 minutes even however contrasted bmc needing 2 seconds translate specification cnf satisfiability solver needing less 1 second check 55 comparison bdd based model checking useful reflect experiments powerpc microprocessor circuits show first experiments interpreted evidence bdd based model checkers cannot handle circuits size given approximation techniques instance certain portions circuit deleted approximated simpler boolean functions still yield true positives invariance checking could employed verifications may gone circumstances however experiments run give measure size limits bdd based sat based model checking input constraints proved easy reach states violated purported invariants noted empirically many users bdd based tools much harder build bdds incorrect designs correct designs theoretical explanation may well circuit spec tautology tran reln init state dlc 6 n n table 5 tautology invariance checking results circuit spec long k vars clauses time table 6 size measures difficult examples circuit spec holds fail k dlc dlc 6 n 2 dlc 7 n 0 table 7 invariants counterexamples smv another bdd based model checker could successfully completed many property checks versions designs accurate input constraints however way credit bounded model checking seems able handle problem instances difficult bdds another observation design large number errors random digital simulation find counterexamples quickly many commercial formal verification tools first run random digital simulations design see property violations detected easily experiments feel likely would found quick counterexamples however shows bounded model checking least powerful method buggy designsyet bounded model checking additional capability conducting exhaustive searches within certain limits limits big question bounded model checking whether find long coun terexamples clearly advantage bdd based model checking bdds built manipulated infinite computation paths ie loops state graph examined often mentioned bdds cannot built manipulated cases even bounded model checking cannot run many time steps give exhaustive verification time step certainly worth running experiments produce information would answer question expected length counterexamples verifications attempted 4 yielded neither counterexamples proofs correctness simply timed means property checked designs buggy depth checked four bbc specs 1 3 4 sdc spec 1 bmc able go 4 10 5 4 time steps respectively see table 6 thus expect current technology might limited 5 time steps large designs course could let sat tools run longer undoubtedly would extended numbers goal experiment tried see one could expect running large numbers designs verifier much time could spent individual verification felt would replicate conditions would occur indus try still even end limited end explorations within 5 10 time steps initial states explorations done quickly exhaustive certain aid finding design errors industry course hope extend limits research lastly results invariance checking speak believe performance would improve given accurate input constraints logical reason believe otherwise yet hard improve existing performance since nearly every invariance check completed 1 second 6 verification methodology experimental results lead us propose automated methodology checking safety properties industrial designs follows assume design divided separate blocks norm hierarchical vlsi designs methodology follows 1 annotate design block boolean formulae required hold time points call blocks inner assertions 2 annotate design block boolean formulae describing constraints blocks inputs call blocks input constraints 3 use procedure outlined section 62 check blocks inner assertions input constraints using bounded model checking satisfiability solving methodology could extended include monitors satisfaction sequential constraints manner described 21 input constraints considered context bdd based model checking 61 incorporating constraints let us consider propositional input constraints valuations circuit inputs must always consistent discussed kripke structures section 2 used model digital hardware systems defined unrolled transition relation kripke structure formula 1 section 31 incorporate input constraints unrolled transition relation shown assume input constraints given propositional formula c state variables representing inputs speak checking invariants input constraints mean using formula 2 place formula 1 unrolled transition relation 62 safety property checking procedure steps checking whether blocks inner assertion p invariant input constraints c 1 check whether p combinational tautology unconstrained k using formula 1 exit 2 check whether p inductive invariant unconstrained k using formula 1 exit 3 check whether p combinational tautology presence input constraints using formula 2 go step 6 4 check whether p inductive invariant presence input constraints using formula 2 go step 6 5 check bounded length counterexample exists ag p presence input constraints using formula 2 one found need examine c since counterexample would exist without input constraints5 counterexample found go step 6 input constraints may need reformulated procedure repeated step 3 6 check input constraints c pertinent design blocks explained inputs constrained one design block general outputs another design block b check input constraints turn inner assertions b check procedure one must take precautions circular reasoning circular reasoning detected automatically however therefore barrier methodology ease carried tautology invariance checking indicates entirely feasible searching counterexample step 5 may become costly high k values however arbitrarily limited expected design teams would set limits formal verification would complement use simulation remainder available resources conclusions summarize advantages bounded model checking follows bounded model checking entails slight memory cpu usage especially user willing push time bound k limit encouraging results larger values k well 32 technique extremely fast invariance checking counterexamples witnesses minimal length make easy understand technique lends well automation since needs little byhand intervention disadvantages bounded model checking present implementations limited types properties checked clear evidence technique consistently find long counterexample witnesses discussion follows current stage development bounded model checking alone replace traditional symbolic model checking techniques based bdds entirely however combination traditional techniques bounded model checking able handle verifications tasks consistently particularly larger designs bdds explode bounded model checking often still able find design errors experiments violations certain environment assumptions since bounded model checking rather recent technique lot directions future research 1 use domain knowledge guide search sat procedures 2 new techniques approaching completeness especially safety property checking may possible 3 combining bounded model checking reduction techniques 5 implied theorems 13 18 mentioned section 52 4 lastly combining bounded model checking partial bdd approach reader may also refer 32 presents successful heuristics choosing decision variables sat procedures context bounded model checking industrial designs 37 early results combining bdds bounded model checking reported see also 1 related approach efforts continue directions expect technique successful industrial arena presently constituted feel prompt increased interest research area good impel us faster towards valuable solutions r automatic verification finiestate concurrent systems using temporal logic specifcations verification future bux cache coherence protocol model checking abstraction model checking abstraction model checking verifying temporal properties sequential machines without building state diagrams computing procedure quantification theory building decision procedures modal logics propositional decision procedures case study modal model checking modular verification intermediate design language analysis second dimacs implementation challenge design constraints symbolic model checking pushing envelope planning test generation using boolean satisfiability design selftimed circuit distributed mutual exclusion symbolic model checking approach state explosion problem computational theory implementation sequential hardware equivalence structurepreserving clause form translation specification verification concurrent systems cesar analyzing powerpc 620 microprocessor silicon failure using model checking efficient bdd algorithms fsm synthesis verification tuning sat checkers bounded modelchecking search algorithms satisfiability problems combinational switching circuits algorithms solving boolean satisfiability combinational circuits combinational test generation using satisfiability combining decision diagrams sat procedures efficient symbolic model checking decision procedure propositional logic sato efficient propositional prover tr automatic verification finitestate concurrent systems using temporal logic specifications graphbased algorithms boolean function manipulation structurepreserving clause form translation representing circuits efficiently symbolic model checking model checking abstraction symbolic model checking model checking modular verification model checking abstraction computeraided verification coordinating processes intermediate design language analysis algorithms solving boolean satisfiability combinational circuits symbolic model checking using sat procedures instead bdds computing procedure quantification theory symbolic model checking symbolic model checking without bdds symbolic reachability analysis based satsolvers industrial success verification tools based stmyampersandaringlmarcks method design constraints symbolic model checking verifiying safety properties power pc microprocessor using symbolic model checking without bdds combining decision diagrams sat procedures efficient symbolic model checking tuning sat checkers bounded model checking introduction computational theory implementation sequential hardware equivalence verifying temporal properties sequential machines without building state diagrams analyzing powerpctm620 microprocessor silicon failure using model checking design synthesis synchronization skeletons using branchingtime temporal logic verification futurebus cache coherence protocol building decision procedures modal logics propositional decision procedure case study modal k sato ctr wojciech penczek alessio lomuscio verifying epistemic properties multiagent systems via bounded model checking fundamenta informaticae v55 n2 p167185 may kacprzak lomuscio w penczek bounded unbounded model checking temporal epistemic logic fundamenta informaticae v63 n23 p221240 april 2004 alex aiken suhabe bugrara isil dillig thomas dillig brian hackett peter hawkins overview saturn project proceedings 7th acm sigplansigsoft workshop program analysis software tools engineering p4348 june 1314 2007 san diego california usa stephanie kemper andr platzer satbased abstraction refinement realtime systems electronic notes theoretical computer science entcs 182 p107122 june 2007 wojciech penczek alessio lomuscio verifying epistemic properties multiagent systems via bounded model checking fundamenta informaticae v55 n2 p167185 april liang zhang mukul r prasad michael hsiao thomas sidle dynamic abstraction using satbased bmc proceedings 42nd annual conference design automation june 1317 2005 san diego california usa w penczek lomuscio verifying epistemic properties multiagent systems via bounded model checking proceedings second international joint conference autonomous agents multiagent systems july 1418 2003 melbourne australia liang zhang r prasad hsiao incremental deductive inductive reasoning satbased bounded model checking proceedings 2004 ieeeacm international conference computeraided design p502509 november 0711 2004 clark barrett leonardo moura aaron stump design results 2nd annual satisfiability modulo theories competition smtcomp 2006 formal methods system design v31 n3 p221239 december 2007 indradeep ghosh mukul r prasad technique estimating difficulty formal verification problem proceedings 7th international symposium quality electronic design p6370 march 2729 2006 matti jrvisalo tommi junttila ilkka niemel unrestricted vs restricted cut tableau method boolean circuits annals mathematics artificial intelligence v44 n4 p373399 august 2005 dionisio de niz peter h feiler aspects industry standard aadl proceedings 10th international workshop aspectoriented modeling p1520 march 1212 2007 vancouver canada boena wona actls properties bounded model checking fundamenta informaticae v63 n1 p6587 january 2004 panagiotis manolios sudarshan k srinivasan daron vroon automatic memory reductions rtl model verification proceedings 2006 ieeeacm international conference computeraided design november 0509 2006 san jose california nadia creignou herv daud john franco sharp threshold renameablehorn qhorn properties discrete applied mathematics v153 n1 p4857 1 december 2005 harald rue leonardo de moura simulation verification simulation verification back proceedings 35th conference winter simulation driving innovation december 0710 2003 new orleans louisiana k subramani john argentieri chain programming difference constraints nordic journal computing v13 n4 p309327 december 2006 carsten sinz visualizing sat instances runs dpll algorithm journal automated reasoning v39 n2 p219243 august 2007 schafer heike wehrheim challenges building advanced mechatronic systems 2007 future software engineering p7284 may 2325 2007 miroslav n velev randal e bryant effective use boolean satisfiability procedures formal verification superscalar vliw microprocessors journal symbolic computation v35 n2 p73106 february alur thao dang franjo ivani predicate abstraction reachability analysis hybrid systems acm transactions embedded computing systems tecs v5 n1 p152199 february 2006 tobias schuele klaus schneider bounded model checking infinite state systems formal methods system design v30 n1 p5181 february 2007 henry kautz bart selman state sat discrete applied mathematics v155 n12 p15141524 june 2007 lucas bordeaux youssef hamadi lintao zhang propositional satisfiability constraint programming comparative survey acm computing surveys csur v38 n4 p12es 2006
concurrency control issues nested transactions concept nested transactions offers decomposable execution units finergrained control concurrency recovery flat transactions furthermore supports decomposition unit work subtasks appropriate distribution computer system prerequisite intratransaction parallelism however exploit full potential suitable granules concurrency control well access modes shared data necessary article investigate various issues concurrency control nested transactions first mechanisms cooperation communication within nested transactions impede parallel execution transactions among parent children among siblings therefore model nested transactions proposed allowing effective exploitation intratransaction parallelism starting set basic locking rules introduce concept downward inheritance locks make data manipulated parent available children support supervised restricted access concept refined controlled downward inheritance initial concurrency control scheme based sx locks flat nonoverlapping data objects order adjust scheme practical applications set concurrency control rules derived generalized lock modes described compatibility matrix also rules combined hierarchical locking scheme improve selective access data granules varying sizes tied together types hierarchies transaction object shown controlled downward inheritance hierarchical objects achieved nested transactions finally problems deadlock detection resolution nested transactions considered b introduction multiple users access database simultaneously data operations coordinated order prevent incorrect results preserve consistency shared data activity called concurrency control provide concurrent user illusion referencing dedicated database classical transaction concept eswaran76 defines transaction unit concurrency control database management system dbms guarantee isolated execution entire transaction implies results derived multiprogramming environment obtained serial execution schedule important transaction properties atomicity consistency durability defined hrder83 dbms component responsible achieving properties transaction management includes concurrency control major function current dbmss transaction management typically designed single level control structure implementation optimized execute short transactions data references anon85 twophase locking far common method controlling concurrency among transactions accepted standard solution bernstein81 gray78 running centralized dbms transaction granularity well locking protocols usually obtain satisfactory performance high performance transaction systems special concurrency control methods considered mandatory increase level parallelism gawlick85 reuter82 however without requiring changes transaction concept executing complex transactions involving example sequences joins sort operations relational dbms turns single level transactions achieve optimal flexibility performance especially distributed systems highly desirable general control structures supporting reliable distributed computing effectively major concerns decomposable finer grained control concurrency recovery solution problems concept nested transactions proposed moss moss85 single level transactions enriched inner control structure mechanism allows dynamic decomposition transaction hierarchy subtransactions thereby preserving properties transaction unit assuring atomicity isolated execution every individual subtransaction consequence subtransactions may distributed system among various processor nodes performing subtasks entire transaction prime aspects nested transactions decomposition unit work subtasks distribution lead following advantages computing system par ticular distributed dbms intratransaction parallelism larger transaction inherent parallelism may anticipated execution take advantage inherent concurrency application suitable granules concurrency control well access modes eg locking modes necessary environments enabling parallel execution nested transaction concept embodies appropriate control structure support supervised therefore safe intratransaction concurrency thereby increasing efficiency decreasing response time intratransaction recovery control uncommitted subtransaction aborted rolled back without sideeffects transactions outside hierarchy hence concept nested transactions contributes considerable refinement scope intransaction undo compared single level transactions undo recovery necessarily yielded state begin transaction bot may refined adding appropriate savepoint concept nested transactions hrder87 rothermel89 explicit control structure parallel asynchronous activities coordinated single unit work external point view introduction powerful explicit control structure allowing delegation pieces work atomic execution appears mandatory structure greatly reduce complexity programming enhance reliability transaction processing system modularity subtransactions facilitate simple safe composition transaction program whose modules may designed implemented independently system modularity serves design goals well encapsulation information hiding failure limitation security distribution implementation concept nested transaction supports implementation distributed algorithms flexible control structure concurrent execution distribution data processing turn major impact overall efficiency terms costeffective use hardware special processors io devic es responsiveness distribution also affects availability replication data hence robustness system may improved various ways centralized dbms nested transactions uses however exploit full potential due lack resources obvious advantage clearer control structure execution complex transactions supporting design reliable programs also allows isolated rollback uncommitted subtransaction case forced abort transaction failure serializability transactions controlled strict 2phase locking protocols equivalent methods quired neither lock granules lock duration affected approach subtransactions release locks inherited parent transaction multilayered centralized dbms kind multilevel transaction management provided subtransactions serve control structures various layers gain higher degree concurrency flexible control lock granules socalled multilevel concurrency control introduced furthermore isolated rollback subtransactions guaranteed system r concept used two layers locking applied twice tuples eot long tuple locks pages duration tuple operation short page locks actions since tuple operations regarded subtransactions page locks released eot parent transaction technique called open nested transaction problems involved discussed gray81 generalization open nested transactions centralized systems called multilevel transactions proposed weikum86 weikum84 moss86 been89 allow early release locks lower levels control however rely compensation operations subtransactions applied case rollback recovery detailed description aspects multilevel transaction management including discussion performance issues given weikum91 dont want consider kind multilevel structure concurrency control centralized dbms operations due salient properties supported nested transactions many researchers focussed attention design implementation distributed systems approach based pro posals results experiences distributed systems design especially reported allchin83 jessop82 liskov85 mllerl83 spector83 walter84 tries adjust concept nested transactions improves use distributed dbms prime goal investigation conceivable extension flexible intratransaction parallelism due space limitations restrict discussion concurrency control deadlock detection issues recovery problems dealt moss87 hrder87 rothermel89 facilitate discussion introduce model nested transactions designed prohibit parentchild siblingparallelism sec 3 basic concurrency control model invented moss moss85 discussed systems extended refined concept downward inheritance enabling transactions pass locks child transac tions sec 4 propose number generalizations extensions concurrency control nested transactions concept controlled downward inheritance enables parent give child access shared data time restrict mode usage another refinement allows use general lock modes compared simple sx lock model hence applications may better adjust synchronization needs far efforts directed towards enhancement concurrency control transaction hierarchies operating flat objects since every practical dbms forced use object hierarchy provide fine well coarse lock granules reasonable cost design concurrency control protocol combines object transaction hierarchies well supports controlled downward inheritance conclude summarize results final section 2 model nested transactions concurrency control techniques going present paper based nested transaction model introduced moss moss85 transaction may contain number subtransactions may composed number subtransactions conceivably resulting arbitrarily deep hierarchy nested transactions root transaction enclosed transaction called toplevel transaction tltransaction transactions subtransactions called par ents subtransactions children also speak ancestors descendants ancestor descendant relation reflexive transitive closure parent child relation use term superior inferior nonreflexive version ancestor descendant set descendants transaction together parentchild relationships called transactions hierarchy following use term transaction denote tltransactions subtransactions hierarchy tltransaction represented socalled transaction tree nodes tree represent transactions edges illustrate parentchild relationships related transactions transaction tree shown fig 1 root represented tltransaction children subtransaction c f g parent c b inferiors c e f g superiors b course descendants ancestors sets c additionally contain c hierarchy c depicted subtree spanned cs descendants properties defined flat transactions atomicity consistency isolated execution durability acidproperties hrder83 nested transaction model acidproperties fulfilled tltransactions subset defined subtransactions subtransaction appears atomic transactions may commit abort independently aborting subtransaction affect outcome transactions belonging subtransactions hierarchy hence subtransactions act firewalls shielding outside world internal failures concurrency control scheme introduced moss applied isolated execution guaranteed subtrans actions however increase intratransaction parallelism enhanced schemes proposed pa figure 1 example transaction tree f g hierarchy c per allow transactions belonging tltransaction hierarchy share data controlled man ner durability effects committed subtransaction depends outcome superiors even commits aborting one superiors undo effects subtransactions effects become permanent tltransaction commits consistency property subtransactions seems restrictive sometimes parent transaction needs results several child transactions perform consistency preserving actions exploit inherent potential nested transactions advantages stated sec 1 degree intratransaction parallelism high possible two kinds intratransaction parallelism defined parentchildparallelism siblingparallelism first kind parallelism supported transaction may run parallel children second kind siblings allowed run concurrently using definitions able characterize four levels intra transaction parallelism neither parentchild siblingparallelism point time one transaction active tltransaction hierarchy ie intratransaction parallelism since transactions hierarchy executed serially concurrency control among needed ex ample transaction executed single process processes communicate means synchronous remote procedure call mechanism level parallelism provided siblingparallelism siblings may performed concurrently transaction never runs parallel superiors kind restricted parallelism enables transaction share objects ancestors without concurrency control example argus system lisk85 intratransaction parallelism restricted level parentchildparallelism since transaction children may run concurrently siblings may tltransaction hierarchy transactions along one path hierarchy may run parallel kind restriction simplifies intratransaction concurrency control sense transactions residing path synchronized reason hardly justifies system design parentchild well siblingparallelism level permits arbitrary intratransaction parallel ism ie principle transactions tltransaction hierarchy may executed concurrently course compared degrees parallelism described degree requires sophisticated concurrency control scheme example locus mller83 clouds allchin83 support level parallelism discussed far transaction model contain essential restrictions transactions may either performed entirely single processor site may distributed multiple processors located one sites moreover model restrict kind data distribution implemented underlying system hence considerations apply data sharing well data distribution approaches rahm92 since focus concurrency control concepts introduction refinements implementation issues would burden discussion 3 basic locking rules nested transactions locking standard method concurrency control dbms used successfully variety applications past decade longer therefore reasonable choose conventional locking protocols starting point investigation nested transactions conventional locking protocols offer two modes synchronization read permits multiple transactions share object time write gives right single transaction exclusively accessing object eg see gray78 far concurrency control concerned data model initially consists disjoint objects lockable units next part section summarize locking scheme nested transactions proposed moss moss85 scheme allows upward inheritance locks ie transaction inherit locks children vice versa last part extend scheme supports upward well downward inheritance schemes presented section implemented several systems 31 upward inheritance locks describing locking rules proposed moss introduce terminology possible lock modes object nl xmode null mode nl represents absence lock request lock object transaction acquire lock object mode holds lock mode termination besides holding lock transaction retain lock subtransaction commits parent transaction inherits locks retains transaction holds lock right access locked object corresponding mode true retained locks retained lock place holder retained xlock denoted rx opposed hx xlock held indicates transactions outside hierarchy retainer cannot acquire lock descendants retainer potentially transaction retains xlock nondescendants cannot hold lock either x smode retainer slock guaranteed nondescendant cannot hold lock xmode potentially smode soon transaction becomes retainer lock remains retainer lock terminates introduced terminology formulate locking rules transaction may acquire lock xmode transaction holds lock x smode transactions retain lock x smode ancestors transaction may acquire lock smode transaction holds lock xmode transactions retain lock xmode ancestors r3 subtransaction commits parent inherits ts held retained locks parent retains locks mode x held retained locks previ ously 2 r4 transaction aborts releases locks holds retains superiors holds retains locks continue obviously rules stated allow upward inheritance locks ie transaction inherit childrens locks vice versa principle upward inheritance exemplified fig 2 use notions x ssphere describing implications principle x 2 note inheritance mechanism may cause transaction conceptually retain several locks object course number locks retained transaction limited one retaining restrictive lock figure 2 upward inheritance locks r r rs r retains xlock acquired slock eott r r r retains xlock acquired xlock eott xsphere ssphere sphere ssphere object defined set transactions potentially lock object xmode smode fig 2a xsphere object disappears entirely transaction acquires slock object ie transaction may acquire xlock object transaction rs hierarchy may lock object smode commit new xsphere established consists descendants ts parent transaction fig 2b x well ssphere disappear acquires xlock commits new x ssphere established gen eral transaction acquiring lock object may cause objects x ssphere shrink termination transaction may cause grow rules stated allow upward inheritance commit time ie transaction may inherit childs locks latter commits restriction guarantees transactions see effects committed children hence affected failures children furthermore restriction ensures subtransactions transaction tree serializable allowing upward inheritance commit time would cause transactions become dependent outcome child transac tions ie subtransactions would act firewalls anymore hrder87 application code within subtransaction cope concurrency recovery issues 32 downward inheritance locks feel especially restrictions caused allowing upward lock inheritance prevent desirable decompositions transactions set cooperating subtransactions example assume application navigates object base updates accessed objects desirable decomposition task depicted fig 3 transaction reads object determines next object accessed applying next operation current objects content creates new child transaction asynchronously performs update operation current object reads next object acts described decomposition appealing characteristics 1 update operations performed parallel 2 update operation fails affect operations failed operation restarted later point time 3 update operations performed isolation particular importance update object may imply updates objects example update two different objects may imply two updates access path figure 3 decomposition application update o1 update o2 update unfortunately decomposition impossible basic locking rules proposed moss applied able perform next operation object must hold rlock object since must hold rlock commits child ever acquire xlock object words object read cannot updated ts children anymore decomposition required example fig 3 possible soon downward inheritance locks supported underlying locking scheme scheme subtransactions may inherit locks superiors inheritance lock take place superior holding lock explicitly offered lock downward inheritance transaction offer lock holds transactions hierarchy acquire lock according locking rules stated consequently concept downward inheritance allows transaction make subset locks available hierarchy locking rules proposed moss easily extended support downward inheritance adding new rule r5 transaction holding lock offer lock transactions hierarchy offering lock retains lock mode held lock transaction offering lock temporarily disclaims right access locked object gives transactions hierarchy opportunity lock object mode course hierarchy might either one transaction holding lock xmode number transactions holding lock smode since transaction offering lock still retains lock mode held lock transaction outside hierarchy lock object mode conflicts mode retained lock become holder transaction must acquire lock anew succeeds rules r1 stated fulfilled example applying lock offering mechanism illustrated fig 4 transaction r offers xlock holds xsphere comprising rs hierarchy established corresponding object ie descendants r opportunity lock object either xmode depicted example objects x ssphere disappear descendant r locks object xmode figure 4 downward inheritance locks r r holding xlock r r offered xlock r acquired xlock r eott xsphere ssphere downward inheritance locks possible isolation property transactions may violated transactions belonging different tltransaction hierarchies still cannot interfere transactions hierarchy may share data consequence transaction may see uncommitted data supe riors however cannot lead inconsistencies since effects transaction undone superior aborts hand transaction may never see uncommitted data inferiors ie subtransactions act firewalls even downward inheritance locks allowed lock offering mechanism similar one described implemented locus system mller83 kind automatic downward inheritance provided argus system liskov85 particular approach concurrency control considerably simplified since conflicts among transactions hierarchical path prevented allowing siblingparallelism automatic downward inheritance implicitly obtained rule transaction may acquire lock transaction holding lock superior 4 enhanced concurrency control nested transactions using idea downward inheritance gain flexibility lock inheritance given transaction hierarchy however poor control specific usage reason kind offering concept still shortcomings situations transaction offering lock desires control mode inferiors hold lock example consider access sequence shown fig 3 additional rule r5 possible make desired decomposition transaction offers xlock o1 o2 o3 etc children c1 c2 c3 etc acquire hold lock mode later however would helpful could prevent child ci able hold lock xmode order make sure ci cannot change resp oi 41 controlled downward inheritance need controlling lock mode inferiors access offered object becomes obvious consider example cooperative design environment bancilhon85 kim84 fig 5 shows design task structured threelevel transaction hierarchy assume transaction b generates object describing interface work piece transactions c children b design subparts work piece therefore require read access interface descrip tion allow children read b must offer lock holds way control mode children hold lock one children may acquire lock xmode two undesirable consequences first child change second child blocks siblings preventing reading overcome problems suggest extension locking rules introduced previous section scheme discussed previously transaction offer locks holds inferiors extended scheme replace lock offering mechanism primitives supporting upgrading downgrading locks downgrade transaction holding lock mode downgrade lock less restrictive mode downgrading lock transaction holds lock mode mand retains lock mode ex ample transaction holding lock xmode downgrade lock mode nl 3 upgrade transaction holding lock mode upgrade lock restrictive mode following condition satisfied transaction holds lock mode conflicting transactions retain lock mode conflicting ancestors 4 example transaction holding lock smode upgrade lock mode x transaction holds lock x smode transactions retaining lock x smode ancestors extended scheme holding retaining lock exactly semantics mosss scheme downgrading lock mode mode transaction holds lock mode retains mode since transaction retains lock mmode prevents transactions outside hierarchy holding lock mode conflicting hand since holds lock mode keeps inferiors holding lock mode conflicting contrast offering locks described basic scheme downgrade allows transaction control 3 note downgrading nl correspond general release lock release locks limited shere downgrader 4 note condition equivalent condition must satisfied transaction acquiring lock figure 5 decomposition design task b rxhs b lx acquire lock xmode ls acquire lock smode ds downgrade lock smode ux upgrade lock xmode holds xmode retains xmode holds smode task structure b concurrent work steps c inferiors hold lock example transaction downgrades lock x smode prevents transactions outside hierarchy holding lock mode precludes inferiors holding lock xmode allows inferiors hold lock smode course downgrading lock nlmode equivalent offering lock basic scheme stated holder lock upgrade lock mode restrictive current hold mode feature allows transaction upgrade lock downgraded previously eg transaction downgraded lock smode could upgrade lock mode x soon children committed course transactions also upgrade lock without downgraded following describe extended locking rules italics used point extensions added mosss scheme transaction may acquire lock xmode upgrade lock holds mode x transaction holds lock x smode transactions retain lock x smode ancestors transaction may acquire lock smode transaction holds lock xmode transactions retain lock xmode ancestors er3 subtransaction commits parent inherits ts held retained locks parent retains locks mode x held retained er4 toplevel transaction commits releases locks holds retains er5 transaction aborts releases locks holds retains superiors hold retain locks continue holding lock xmode downgrade lock mode nl performing downgrade operation retains lock xmode er7 transaction holding lock smode downgrade lock mode nl performing downgrade operation retains lock smode mode transaction downgrades lock determines modes transactions ts hierarchy cannot hold lock downgraded mode transactions ts hierarchy cannot hold lock xmode since conflicts x downgraded mode nl transactions ts hierarchy potentially hold lock mode examples may help clarify key issue controlled downward inheritance effect offering xlock depicted scenario fig 4 similar scenario fig 6 illustrates downgrading xlock mode downgrading slocks handled analogous manner essential issue observed example slocks may granted within rs hierarchy ie xsphere established lock downgraded mode given extended locking rules problem described design environment example solved easily see fig 5 generated object transaction b downgrades xlock holds mode since holds lock smode c prevented holding lock xmode guarantees cannot change block note since retains lock xmode downgrading lock transactions e cannot hold lock mode ie e neither read write commit c b upgrade lock 42 correctness concerns stated section 31 upward lock inheritance commit ensures subtransactions act firewalls case failure subtransactions tltransaction remain isolated since proposed concept controlled downward inheritance like discuss impact concept correctness concurrent executions tltransactions serializable transaction tltransaction tree locks data object accessing locks hold transactions transaction tree released tltransaction commits locking protocol corresponds strict 2phase locking tltransactions determines serialization order time commit holds singlelevel transactions figure controlled downward inheritance r r holding xlock u r rxhs u r rxhs u r rxhs u r downgraded x slock u acquired slock eott ssphere let us discuss visibility data changes induced dependencies within transaction tree mosss nested transaction model following holds transaction may see changes transactions committed depends 5 say transaction depends transaction undoing effects causes abortion transaction seen state object state never seen changed another transaction commits contrast model allows controlled downward inheritance makes uncommitted data available inferiors reason observe following properties transaction may see changes transactions committed depends upon transactions superiors object state seen transaction may changed inferiors transaction may see changes superiors transactions downgraded corresponding locks explicitly whether transaction may see effects superiors controlled application logic terms failures transaction seeing changes superiors causes problems superior aborts transaction aborted also note transaction seen object object cannot changed superior transaction commits transaction downgrades lock must aware consequences reduced isolation downgrading nlmode may cause unrepeatable reads downgrading transactions point view xlocks two cases must considered downgrading x nlmode x smode first case downgraders point view lost updates und unrepeatable reads possible principle however much flexible cooperation enabled correctness execution enforced application level protocols cscwlike applications even conceivable kind highlevel control based socalled social protocols end users latter case prevents inferiors downgrading transaction keeping downgraded lock xmode neither unrepeatable reads lost updates occur important question whether firewall property nested transactions way affected downgrading mechanism transaction downgrading lock become dependent outcome inferiors child fails updates possibly objects downgraded locks rolled back therefore downgrading transaction affected may create another child 5 remember effects committed subtransaction become permanent toplevel transaction commits reason transaction may see data committed transactions depends upon ensure aborted effects one transactions wiped due failure transaction hierarchy depicted fig 5a transaction e may see changes transaction c b committed b commits e becomes dependent c failure wiping effects c causes course e aborted work summary fact transaction may see changes superiors causes problems firewall property affected downgrading mechanism lost updates may happen locks downgraded x nlmode case provides highest degree flexibility terms cooperation applicationlevel concurrency control mechanisms needed ensure required form correctness since application decide use downgrading mechanism adapt level system supported isolation cooperation needs facilities applicationspecific concurrency control 43 generalization lock modes thus far described refined concurrency control scheme sx locks flat nonoverlapping objects eg tuples relations particular developed mechanism controlled downward inheritance locks nested transactions closer consideration reveals lock modes comprising x far may enriched special modes better adapt concurrency control access patterns practical applications example tailored lock modes frequent kinds object access could helpful effectively exploit inherent parallelism concurrent transactions furthermore use semantic knowledge could greatly optimize contention patterns data access however requires enhanced lock modes particular presupposes ability introduce userdefined lock modes eg see allchin83 schwarz84 refinement lock modes may easily integrated model presented far assume data model remains unchanged locking rules stated sec 41 sx schemes generalized basic andor userdefined lock modes follows transaction may acquire lock mode upgrade lock holds mode transaction holds lock mode conflicts transactions retain lock mode conflicting ancestors gr2 subtransaction commits parent inherits ts held retained locks parent retains locks mode held retained gr3 toplevel transaction commits releases locks holds retains gr4 transaction aborts releases locks holds retains superiors hold retain locks continue gr5 transaction holding lock mode downgrade lock less restrictive mode downgrading lock retains mode locking rules stated allow upward well controlled downward inheritance arbitrary lock modes rule gr5 omitted would get generalization mosss scheme provides upward inheritance 44 use hierarchical locks nested transactions let us reconsider underlying data model serious drawbacks realistic concurrency control situations particular flat object structure requires disjoint lockable units given granule makes impractical large databases small granules needed transactions larger ones others improve selective access data granules varying sizes hierarchical locking schemes proposed context hierarchically structured objects introduce certain complexity deal orthogonal transaction data hierarchies mentioned earlier locking disjoint partitions given size insufficient performance reasons applications choice lockable units affects locking overhead transaction space lock control blocks time request release locks well concurrency among transactions hence implies dichotomy increased concurrency using fine lockable units higher cost lock management small granules appropriate simple transactions accessing tuples intolerable hard implement complex transactions accessing large fraction data base assume example sequential scan relation 10 6 tuples tuples lockable units would require 10 6 consecutive lock requests storing many lock control blocks course main memory performance reasons hence coarser granularity locks sometimes natural efficient eg sorting reorganizing relation arguments convince every dbms designer object hierarchy locking purposes provided fact every practical dbms supports hierarchy typically 2 3 4 levels eg system r generic 4level hierarchy database segment relation tuple astrahan76 appropriate hierarchical locking scheme proposed flat transactions gray76 two key ideas allowed design scheme could adapted transactions needs either locking items using fine lockable unit locking larger sets items larger lock granules node r hierarchy locked explicitly result entire subtree implicitly locked transaction locking part hierarchy places intention mode locks along path r avoid situation ancestor node r locked incompatible mode compared r ilocks merely serve place holders signalling fact locking subtree done lower level hierarchy thereby preventing incompatible locks granted corresponding nodes besides known modes x intention share mode intention exclusive mode ix introduced express transactions intent read update read object lower level hierarchy respectively refinement share intention exclusive mode six grants slock entire subtree transaction addition indicates transactions intention request xlocks explicitly finer object granules later following table taken gray76 shows compatibilities among requestlock modes derive semantics comprehensive discussion precise effects lock modes compatibilities refer reader seminal work j gray gray78 basic locking rules object hierarchies introduced essential ingredients generalized locking rules nested transactions appropriate lock modes object hierarchy combine together start basic concurrency control model upward inheritance allowed transaction hierarchy generalized rules gr1 gr4 apply furthermore acquiring lock object consider additional rules resulting object hierarchies opposed flat objects according gray et al approach controlling concurrent access object hierarchy obey following rules 1 instead locking object directly every transaction observe strict hierarchical protocol requesting appropriate locks root leaf object hierarchy following denoted roottoleaf rule lock granted level according compatibilities expressed table soon lock obtained transaction may request another appropriate lock next lower level 2 leveltolevel transitions obey following constraints called leveltolevel rules held node allows requested descendant nodes ix granted node carries privilege request ix six x next level x allow read write access respectively descendants node without locking six carries privileges ix hence mode allows read access de scendants write access lower levels may requested ix x next level ix mode lock compatibility mode request nl ix six x yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes far acquiring locks concerned rules obtained transaction hierarchy object hierarchy must satisfied independently following roottoleaf rule transactions must request locks root leaf object hierarchy whether lock object may granted particular mode decided according leveltolevel rules generalized locking rules gr1 gr4 lock mode compatibilities depicted table since rules introduced object hierarchy independent underlying transaction model rules hierarchies applied independently protocol proposed gray76 flat transactions differ rules implied transaction model example may clarify issues involved lock retainment object hierarchies following sce hierarchical locks xaccess relation r parent p eott 1 retained locks p inferiors qualified acquire read write access r tuples r following table shows locks 2 3 obtaining write read access tuples r upgrading downgrading hierarchical locks although succeeded tying together hierarchy types transaction object hierarchies far obtained economical efficient solution concurrency problem compared basic approach sec 31 since cannot make transactions objects available inferiors arguments discussed earlier apply therefore desirable enable controlled downward inheritance presence object hierarchies assume example transaction p holds sixlock relation r wants permit write access tuples r inferiors using kind inheritance mechanism sec 41 p downgrade lock object appropriate mode p retains sixlock r rsix holds r ixmode hix note rsix prevents incompatible locks r granted nondescendants inferiors let us examine whether straightforward approach may applied scenario depicted following table p holds r sixmode tuples r xmode assume p downgrades sixlock r requesting lock inferior implies obeys roottoleaf leveltolevel rules hence soon acquired appropriate locks ancestors r request compatible lock r presented scenario meant serve counterexample ar database db hix rix hix segment hix rix hix relation r hx rx hix tuples hx 1 hs 3 hx 2 hs 4 object hierarchy bitrary inheritance hierarchical locks aims clarifying new issue inheritance objects data hierarchies shows p holds locks tuple level downgraded corresponding lock relation level nlmode ie without particular protection illustrated situation acquires sixlock r giving read access tuples r hand p still tuples locked xmode namely 1 2 exclusively locked tuples would read since read access tuples r need checked anymore even worse writewrite interference tuples could occur locked r xmode course sketched examples may cause severe consistency problems anomalies would occur lock relation r together locks tuples downgraded control given holdmode alone would guarantee desired consistency exemplified downgrading r smode key observation example downgrading lock without considering whole object hierarchy may lead inconsistencies shown upgrading locks object hierar chies example transaction locked database ismode upgrades slock holds segment database xmode similar inconsistencies may occur obviously prevent violations leveltolevel rules upgrading downgrading lock may enforce upgrade downgrade operations locks held object hierarchy transaction upgrades lock held object within object hierarchy might necessary also upgrade locks held superior objects order satisfy leveltolevel rules example holds slock database segment database relation segment respectively leveltolevel rules enforce upgrading islocks ixmode relation lock upgraded xmode since upgrading locks object superior objects performed atomic manner upgrading done roottoleaf direction course upgrade operation take place generalized locking rules gr1 gr4 ful filled otherwise blocked may cause deadlocks occur see sec 5 since upgrading lock object converts mode locks restrictive one level tolevel rules violated far locks inferior objects concerned however due upgrade operation locks held upgrading transaction inferior objects may become useless example lock relation r upgraded six xmode lock escalation bernstein87 locks held upgrading transaction individual tuples r needed anymore clean approach handling useless locks release part upgrade operation actual object hierarchy p p downgrade using downgraded lock database db hix hix hix segment hix hix hix relation r hsix rsix hsix tuples hx 1 hx 1 hx 3 hx 2 hx 2 hx 4 implementation may optimize cleanup process using pragmatic arguments eg see system r astrahan76 downgrading lock held transaction object confined subhierarchy root object superiors object hierarchy involved since downgrading cannot violate leveltolevel rules far superiors concerned however respect objects subhierarchy downgrading lock may cause violation leveltolevel rules holds lock subobject downgrading mode lock held may violate leveltolevel rules example assume holds ixlock relation r xlock tuple r downgrades lock r ix ts xlock consistent anymore lock mode parent object consequence downgrading lock may require downgrading locks held objects subhierarchy leveltolevel rules satisfied example would require downgrading ts lock tuple nlmode following table derived leveltolevel rules lists possible mode lock graded modes hold locks objects subhierarchy without violating leveltolevel rules example lock downgraded ismode hold subobjects either nl smode subobjects held restrictive modes locks objects must downgraded one listed modes note since downgrading entire subhierarchy cannot done atomically downgrading performed leaftoroot direction observing rules consistencypreserving downward inheritance locks may easily achieved p previous example downgrading tuples 1 2 downgrading relation r control lock usage possible downgrading appropriate modes following scenario locks subhierarchy relation r downgraded different modes allows selective control access rs subobjects object transaction downgraded mode ix consistent modes locks subobjects nl nl ix six x object hierarchy p p downgrade using downgraded lock database db hix hix hix segment hix hix hix relation r hsix rsixhix hsix tuples hx 1 rxhs 1 hs 1 hx 2 rx 2 hx 2 downgrade intention mode ix six implies subsequent downgrades locks subobjects order satisfy leveltolevel rules however avoided restricting downgrade operations xlocks holds lock object xmode entire subhierarchy locked implicitly hold locks subobjects hence downgrade involve downgrading locks lower levels os subhierarchy let us summarize findings controlled downward inheritance locks data hierarchy gen eral downgrading entire subtrees necessary hierarchical objects guarantee consistency downward inheritance nested transactions mlock held transaction object downgraded might necessary downgrade locks held inferiors order satisfy leveltolevel rules downgrading allowed x slocks downgrading lock never involves locks held lower levels object hierarchy simplifies downgrade mechanism substantially 5 deadlock detection nested transactions lock protocols pessimistic blocking lock requests data currently granted another transaction conflicting mode therefore immune deadlocks deadlocks may occur among transactions belonging various tltransactions even among subtransactions within single transaction hierarchy deadlock detection mainly follow basic approach sketched moss85 allows identify existing deadlocks addition propose maintenance information waitsforretainedlocks relation detect openingup deadlocks early possible deadlocks nested transactions resolved concepts known singlelevel transactions extended mechanisms tailored properties nested structure moss85 rukov91 transaction acquires lock data incompatible lock held another transaction requesting transaction deactivated direct wait lock holder occurs direct waits maintained waitsforlock relation order detect deadlocks using waitsforlock relation deadlock detection performed immediately transaction blocked elapsed time deadlock exists cycle found waitsforlock relation singlelevel transactions cycle composed direct waits waits lock seen sec 31 nested transactions inner structure determines along paths locks inherited whether retained locks acquired assume subtransaction r waits lock held subtransaction commit locks inherited retained parent transaction p see fig 7 lock requests transactions ps xor sphere served transaction r outside ps sphere however cannot acquire retained locks reason wait retained locks p waits retained locks indirect waits propagate along ancestor hierarchy p following introduce two different waiting relationships waitsfor retainedlocks lock requestor r directly waits lock holder mode requested lock conflict lock mode hold let q highest ancestor ancestor r r indirectly waits ancestors q commit wait relationships called waitsforretainedlock wait rule implies requestor r tltransaction r must wait retained locks ts tltransaction released commit waitsforcommit since waiting lock requestor r cannot proceed work ancestors r may wait fig 7 u cannot commit r us parent cannot commit u ancestors r cannot commit r doeswe denote kind wait relationship waitsfor commit represented parentchild relationships outlined fig 7 due dependency ancestor r may wait transactions r directly indirectly waits course waiting may broken soon one ancestors abort illustrated fig 7 r directly waits indirectly waits retained locks p q furthermore since u wait commit r also wait p q sec 44 hierarchical locking employed nested transactions key observation exhibited object transaction hierarchies orthogonal consequence aspects added deadlock detection hierarchically composed objects used illustrated fig 7 waitsfor relations occur among transactions thus rules hierarchical locking protocol interfere waitsforlock waitsforcommit relationships long roottoleaf leveltolevel rules observed u waitsforlock waitsforcommit fig 7 lock commit waits 51 detection existing deadlocks order handle deadlock detection nested transactions successfully combine various waitsfor relations considering waitsforlock relation directwait deadlocks found indicated fig 8a whereas kinds deadlocks cannot detected true matter whether deadlock occurs within tltransaction among subtransactions various tltransactions cycle fig 8a consists direct waits transactions cycle cannot proceed fig 8b however another kind cycle encountered situation mean progress stopped everywhere cycle waits lock q q p may proceed time cannot commit without aborting since must rolled back anyway best decision detect resolve ancestordescendant deadlock immediately request causing lock wait ancestor q detected using combined waitsforlock waitsforcommit relation information situations illustrated fig 8b would frequently caused descendants refer exclusively used data uncoordinated way controlled downgrading locks however provides mechanism avoid cycles application knowledge applied reduce possibility deadlock involving lock commit waits coordinated work requires parent p downgrade lock object currently granted p creates child work acquire lock nonconflicting mode without causing blocking situation downgrading enables deadlockfree cooperation cannot enforce requests lock mode restrictive offered one deadlock may arise upgrading lock may lead wait situations therefore deadlocks occur singlelevel transactions assume fig7 r already hold slock object r upgrades lock mode x r wait direct ancestor r retains lock r tltransaction ts tltransaction committed hence wait rule applies lock grades directwait deadlock fig 8 deadlock situations r b ancestordescendant deadlock 52 detection openingup deadlocks combined use waitsforlock waitsforcommit relations turned sufficient nested transactions detect existing cycles embodying directwait ancestordescendant deadlocks since waitsforlock relationship represented requestor holder lock commit lock holder current retainer waitsforretainedlock relationships requestor ancestors holder retainer explicitly established waitsfor informa tion nested transactions however waitsforretainedlock relationships taken account provide early deadlock detection may save lot useless work shown scenario fig 9 fig 9 represents deadlockfree situation since transactions possibly others proceed work rwaits g obtain requested locks waits indicated waits forcommit r indirectly waits oldest ancestor ancestor r hand g indirectly waits v evaluate information r g v able immediately detect cycle opening optimistic attitude would care openingup deadlock since abort transaction involved would eventually avoid actual occurrence deadlock example abort transaction fig9 resolves openingup deadlock progress ceases within tl transactions v however transaction aborts regarded exceptions taken account remedy break openingup deadlock cycles contrast pessimistic approach usually saves work use transitive waitsforcommit waitsforretainedlock relationships ancestors eg v r g well r g v construct direct future cycle v roll back either v ever deadlock detection resolution level highest noncommon ancestors transactions caused conflict may appropriate deadlock resolution typically based transaction rollback affect minimal data granules work lost u r f g fig 9 openingup deadlock among nested transactions reason special measures used determine openingup deadlock early possible suitable level nested transaction hierarchies addition waitsforlock waits forcommit relations waitsforretainedlock relationships included waitsfor infor mation example fig9 relationships r c r b r well g p g q represented order successfully search openingup cycles opening deadlock detected transactions involved considered determine lowcost victim rollback since rollback parent transaction implies rollback inferiors committed un committed rollback child transaction always cheaper corresponding parent trans action reason rollback lock holder retainer lock requestor always cheaper ancestors potential cycle hence set transactions choose rollback victim set lock holders retainers lock requestors fig 9 set candidates dt rg respectively note contrast moss85 transaction model transactions must leaves current transaction tree however methods cost measures could applied breaking cycle principle since candidate transactions occur arbitrarily transaction hierarchy resource estimation involving evaluation subtrees may become much complicated summarize waitsforretainedlock relationships evaluated detect openingup deadlocks early possible since candidate transactions breaking cycle lock holders retain er lock requestors mechanisms deadlock resolution derived provided singlelevel transactions early detection openingup deadlocks saves transaction work however discussed additional representation management waitsforretainedlock relationships require overhead deadlocks infrequent particular system implementation take tradeoff account 6 comparison system implementations following compare systems implementing nested transactions regard degree parallelism supported applied concurrency control schemes way deadlocks treated particular consider argus liskov88 liskov87 camelot spector88 epingers91 clouds ahamad87 dasgupta89 eden almes85 pu85 locus mller83 weinstein85 table summarizes results camelot clouds eden locus allow parentchild well sibling parallelism argus permit parent transaction run parallel children resulting simpler locking rules liskov87 systems considered based twophase locking however clouds locus support downward inheritance downward inheritance scheme locus requires lock holder explicitly state downward inheritance may potentially take place transaction clouds allowed share locks ancestors totally uncontrolled manner allchin83 transaction closes file locus lock held file becomes retained lock although supports downward inheritance means explicit offering mechnism locus scheme uncontrolled sense lock holder offering lock cannot control mode descendants may acquire lock none five systems supports controlled downward inheritance support object hierarchies argus camelot clouds implement deadlock resolution based timeout mechanism whereas eden applies woundwait deadlock avoidance scheme rosenkrantz78 locus neither performs deadlock detection implements avoidance scheme however provides interface operating system data permitting system process detect deadlock constructing waitforgraph manner different deadlock resolution strategies may implemented weinstein85 7 conclusions presented investigation concurrency control nested transactions focus paper primarily achieving high degree intratransaction parallelism within nested transactions using locking protocols parentchild sibling downward controlled object deadlock parallelism parallelism inheritance downward hierarchy avoidance inheritance support detection argus yes timout based resolution camelot yes yes timeout based resolution clouds yes yes yes timeout based resolution eden yes yes woundwait avoidance scheme locus yes yes yes neither resolution avoidance initial concurrency control mechanism nested transactions based sx locking protocols flat objects seriously limited parentchild parallelism therefore concept downward inheritance introduced refined controlled downward inheritance order enable transaction restrict access mode inferiors object controlled downward inheritance turned useful concept achieving safe parentchild cooperation data structures read written shared manner practical applications sometimes need specialized lock modes well multilevel object hierarchies offering efficient ways lock granules varying sizes therefore generalized locking rules nested transactions applied richer access modes flat objects impor tantly kind generalization prerequisite integration transaction object hierar chies since appropriate use object hierarchies implied suitable access modes beyond x locks result could combine types hierarchies general concurrency control model could enhance model using concept controlled downward inheritance even richer set access modes finally studied principles deadlock detection nested transactions contrast singlelevel transactions waitsforlock relation sufficient search waiting cycles among transac tions detection deadlocks nested transactions requires maintenance waitsfor commit relation combined use waitsforlock relation deadlocks frequently antici pated openingup deadlocks may span transaction trees detected early possible save transaction work purpose additionally introduced waitsforretainedlock relation acknowledgements c mohan shared great knowledge experience concurrency control us would like thank contributions led essential simplifications clarifications concepts proposed paper would also like thank j palmer p schwarz referees helpful comments paper r eden system technical review fault tolerant computing object based distributed systems architecture decentralized systems system r relational approach database management model concurrency nested transaction systems concurrency control distributed database sys tems concurrency control recovery database systems model cad transactions clouds distributed operating system notions consistency predicate locks database system camelot avalon distributed transaction facility camelot avalon hot spots notes database operating systems transaction concept virtues limitations granularity locks degrees consistency shared data base principles transactionoriented database recovery concepts transaction recovery nested transac tions eden transaction based file system nested transactions engineering design databases implementation argus argus language system distributed programming argus transaction management r nested transactions approach reliable distributed computing nested transaction mechanism locus nested transactions general objects eden implementa tion framework workload allocation distributed transaction processing systems concurrency hightraffic data elements ariesnt recovery method based writeahead logging nested transactions system level concurrency control distributed database systems hierarchical deadlock detection nested transactions synchronizing shared abstract types transactions construct reliable distributed computing flexible nested transactions multiple commit points approach structure advanced database applications theoretical foundation multilevel concurrency control principles realization strategies multilevel transaction manage ment transactions synchronization distributed operating system tr principles transactionoriented database recovery synchronizing shared abstract types nested transactions approach reliable distributed computing concurrency control recovery database systems theoretical foundation multilevel concurrency control abstraction recovery management measure transaction processing power implementation argus concepts transaction recovery nested transactions distributed programming argus model concurrency nested transactions systems ariesnt recovery method based writeahead logging nested transactions principles realization strategies multilevel transaction management camelot avalon framework workload allocation distributed transaction processing systems system level concurrency control distributed database systems system r transactions synchronization distributed operating system concurrency control distributed database systems notions consistency predicate locks database system concurrency hightraffic data elements transaction mechanism engineering design databases nested transactions multiple commit points architectural issues transaction management multilayered systems logbased recovery nested transactions notes data base operating systems argus language system nested transaction mechanism locus ctr erhard rahm parallel query processing shared disk database systems acm sigmod record v22 n4 p3237 dec 1993 patiomartnez r jimnezperis arvalo implementing transactions using ada exceptions features missing acm sigada ada letters vxxi n3 september 2001 hongren chen h chin scheduling valuebased nested transactions distributed realtime database systems realtime systems v27 n3 p237269 september 2004 elisa bertino barbara catania elena ferrari nested transaction model multilevel secure database management systems acm transactions information system security tissec v4 n4 p321370 november 2001 kunal verma john miller boanerges alemanmeza designing highperformance database engine db4xml native xml database system journal systems software v69 n12 p87104 01 january 2004 laurent dayns grzegorz czajkowski lightweight flexible isolation languagebased extensible systems proceedings 28th international conference large data bases p718729 august 2023 2002 hong kong china stefan deloch theo hrder nelson mattos bernhard mitschang joachim thomas advanced data processing krisys modeling concepts implementation techniques clientserver issues vldb journal international journal large data bases v7 n2 p7995 may 1998 c mohan repeating history beyond aries proceedings 25th international conference large data bases p117 september 0710 1999 alexander thomasian concurrency control methods performance analysis acm computing surveys csur v30 n1 p70119 march 1998 klaus r dittrich hans fritschi stella gatziu andreas geppert anca vaduva samos hindsight experiences building active objectoriented dbms information systems v28 n5 p369392 july norman w paton oscar daz active database systems acm computing surveys csur v31 n1 p63103 march 1999
computing local consensus trees inference consensus set evolutionary trees fundamental problem number fields biology historical linguistics many models inferring consensus proposed paper present model deriving call local consensus tree set trees cal model propose presumes function f called total local consensus function determines every triple species form local consensus tree take show local consensus trees exist constructed polynomial time many fundamental problems solved linear time also consider partial local consensus functions study optimization problems model present linear time algorithms several variations finally point local consensus approach ties together many previous approaches constructing consensus trees b introduction evolutionary tree also called phylogeny phylogenetic tree species set rooted tree leaves labeled distinct elements evolutionary history difficult determine computationally difficult optimization problems area nphard scientifically difficult well since range approaches appropriate different types data exist common approach solving problem apply many different algorithms given data set different data sets representing species set look common elements set trees returned several methods described literature deriving one tree set trees paper propose new model called local consensus model based upon functions called local consensus rules inferring rooted topology homeomorphic subtree induced triples species show local consensus function supported part nsf grant ccr9108969 supported part aro grant daal03890031pri z supported part aro grant daal03890031pri computed polynomial time many natural forms local consensus computed linear time also analyze optimization problems based upon partial local consensus rules show many also solved polynomial time preliminaries 21 definitions let set species evolutionary tree also known phylogenetic tree simply phylogeny rooted tree n leaves labeled distinct element internal nodes denote ancestors species arbitrary subset 0 ae denote tjs 0 homeomorphic subtree induced leaves 0 particular specified triple fa b cg ae denote tjfa b cg homeomorphic subtree induced leaves labeled b c topology completely determined specifying pair species among b c whose least common ancestor lca lies furthest away root b pair denote b c said resolved triple b c binary may happen three pairs species least common ancestor case say unresolved denote topology b c given tree containing nodes u v w let lca u v w denote least common ancestor u v w also let u v denote v path u root set input trees ft consensus problem sometimes referred profile let b c represent set rooted subtrees leaf set fa b cg local consensus rule function given local consensus rule f set r evolutionary trees flocal consensus exists tree r f triples r f said total local consensus otherwise f said partial local consensus problem determining flocal consensus exists constructing called flocal consensus problem also consider optimization versions local consensus problem discussed subsequent sections set general machinery look special case need build consensus two trees describe specific local consensus functions f produce efficient algorithms 22 particular local consensus rules define binary local consensus optimistic local consensus pessimistic local consensus problems binary local consensus problem takes input two binary trees whereas optimistic local consensus pessimistic local consensus problems take input two trees necessarily binary examples total local consensus rules definition 21 local consensus rule f conservative every triple fa b cg jfa b cg required resolved particular profile tree profile resolves fa b cg differently trees necessarily binary local consensus rule interpret unresolved triple one two distinct ways supposing resolution three way split possible supposing unresolved node represents threeway speciation event depending upon interpretation therefore local consensus rule may decide 1 resolved 2 unresolved triple output resolved identically 1 unresolved call first type local consensus rule optimistic second type pessimistic define three consensus rules definition 22 let 1 2 two rooted binary trees leaf set rooted tree necessarily binary called binary local consensus 1 2 iff triples b c jfa b definition 23 let 1 2 two rooted trees leaf set rooted tree called optimistic local consensus 1 2 iff triple b c c b c definition 24 let 1 2 two rooted trees leaf set rooted tree called pessimistic local consensus 1 2 iff triple b c differences appropriate particular types data given definitions three models local consensus tree may exist sections 3 4 5 give linear time algorithms either construct tree looking exists conclude tree exists however practicing biologists linguists need build kind consensus tree therefore considered variants local consensus tree problem always solutions end define notion relaxedaccord local consensus relaxeddiscord local consensus follows definition 25 let 1 2 two rooted binary trees leaf set rooted tree necessarily binary called relaxedaccord local consensus 1 whenever triple b c differing topologies 1 2 triple unresolved preserves topology maximal set triples 1 2 agree prove existence relaxedaccord local consensus tree sufficient show exists tree every triple 1 2 disagree unresolved set trees property partially ordered based set triples 1 2 agree whose topology preserve partial order known nonempty proved existence relaxedaccord local consensus since maximal element partial order consensus tree note star topology leaves unresolved triples 1 2 disagree hence partial order nonempty relaxedaccord local consensus tree always exists section 6 show tree unique definition 26 let 1 2 two rooted trees necessarily binary leaf set rooted tree called relaxeddiscord local consensus 1 2 preserves topology triples 1 2 agree addition leave unresolved maximal set triples 1 2 disagree using argument similar one used prove existence relaxedaccord local consensus noting 1 preserves topology triples 1 agree conclude relaxeddiscord local consensus always exists section 6 show relaxeddiscord local consensus also unique look problems give standard definitions available literature definition 27 let rooted tree leaf set given node v 2 v denote lt v set leaves subtree v rooted v also called cluster v represented ff v set ct called cluster encoding every rooted tree leaves labeled contains singletons entire set ct clusters called trivial clusters define maximal cluster cluster defined child root allow maximal cluster defined leaf also also define notion compatibility set clusters definition 28 set clusters said compatible iff exists tree ct following proposition found 12 proposition 21 set clusters compatible iff 8ff g state theorem used later sections theorem 21 let 1 2 two rooted trees leaf set let f conservative local consensus rule flocal consensus tree exists ct compatible sets proof suppose suppose without loss generality ct compatible set proposition 21 9ff 2 ct fi 2 ct 1 ff g pick ff topology triple b c 1 c b b c since f conservative local consensus rule impossible 2 3 binary local consensus section look binary local consensus problem start restating definition binary local consensus tree let 1 2 two rooted binary trees leaf set rooted tree necessarily binary called binary local consensus 1 2 iff triples b c jfa b 31 characterization construction show althought binary local consensus two trees may exist exist nice characterization proposition 31 given binary tree cluster ff ff compatible ct iff proof ff 62 ct ff compatible ct exists proper refinement 0 ct 0 binary tree proper refinement 2 lemma 31 let 1 2 rooted binary trees leaf set f conservative local consensus function flocal consensus tree exists proof previous lemmas ct since f conservative corollary 31 binary local consensus tree 1 2 exists 1 2 binary ct proof need show ff 2 ct ff 2 ct 1 ff pick identically also resolves tree ct called strict consensus tree particular consensus tree always exists constructed time 6 construction part algorithm binary local consensus trees therefore simple remains verification strict consensus tree also binary local consensus tree ie tree constructed using algorithm 6 satisfies constraints imposed upon binary local consensus rule 32 verifying consensus tree binary local consensus tree prove structural lemmas help determine whether consensus tree fact binary local consensus lemma 32 let 1 2 rooted binary trees leaf set let ff cluster intersection let strict consensus tree 1 2 let e 1 e edges respectively respective internal nodes define cluster ff let species ff binary local consensus 1 2 1 subtree e binary local consensus subtrees e 1 e 2 2 upon replacing subtrees respectively binary local consensus 1 2 proof clearly binary local consensus tree 1 2 conditions 1 2 hold conversely 1 2 holds binary local consensus tree 1 2 triple b c incorrectly handles triple b c e condition 1 handles b c correctly similarly least two e condition 2 handles triple correctly remains show handles triples exactly two b c one edge e since cluster triple properly thus binary local consensus 1 2 2 lemma yields obvious divideandconquer strategy determine whether binary local consensus exists next explore pairs binary trees possible binary local consensus star ie tree none trivial clusters definition 31 caterpillar rooted binary tree one pair sibling leaves given leaf labeled caterpillar root r height h natural ordering induced leaves let hg function gs distance r species ordered increasing order 1 ga 1 note pair sibling leaves arbitrarily ordered definition 32 two caterpillars x leaf set said oppositely oriented iff k k smallest elements x contained among k1 largest elements vice versa proposition 32 let 1 2 two rooted binary trees leaf set whose binary local consensus star b sibling pair leaves 1 lca b 2 must root 2 proof suppose species c least common ancestor c least common ancestor b 2 1 jfa b hence binary local consensus 1 2 cannot star 2 lemma 33 suppose 1 2 binary trees leaf set suppose least 5 leaves binary local consensus tree star 1 2 must caterpillars proof suppose contradiction 1 caterpillar two pairs sibling leaves b c previous proposition pairs must root least common ancestor 2 thus without loss generality c lie left subtree root 2 b lie right subtree root 2 thus follows 2 must two sibling pairs p q r one subtree root note 1 least common ancestor p q least common ancestor r root 1 without loss generality let p r lie left subtree root 1 q lie right subtree root x either subtrees 1 figure 1 topologies 1 2 respect p q let x species besides p q figure 1 suppose without loss generality x lies left subtree root 2 consider following two triples 2 topology triples x p x q r respectively show 1 agrees least one triples two cases x lies left subtree root 1 topology triple x p 1 clearly x p x lies right subtree root 1 topology triple x q r 1 x q r thus either case triple 1 agrees triple 2 binary local consensus cannot star 2 lemma 34 let 1 2 two caterpillars leaf set binary local consensus 1 2 star 1 2 oppositely oriented caterpillars proof suppose two caterpillars oppositely oriented ie satisfy two intersection conditions let x z three leaves let indices ordering leaves 1 respectively topology x z 1 x z looking smallest elements 2 set must contain z cannot contain x consequently topology triple 2 x z star valid binary local consensus conversely suppose two caterpillars satisfy intersection conditions without loss generality suppose exists least one k k smallest elements 2 contained within largest elements 1 pick smallest k say x leaf 2 rank k x belong set k largest elements 1 pigeonhole principle exist least two leaves 2 ranks greater k contained set k largest elements 1 suppose two leaves z 1 jfx implies binary local consensus cannot star 2 b c e f c figure 2 example oppositely oriented caterpillars corollary 32 binary local consensus two trees verified star linear time 33 binary local consensus tree algorithm 1 use days algorithm produce strict consensus tree nontrivial cluster maintain pointer edges 1 2 give rise cluster 2 traverse postorder nontrivial cluster found check subtrees edge 1 2 caterpillars satisfy conditions lemma replace entire subtree single node belonging subtree 1 2 declare binary local consensus tree theorem 31 construction verification binary local consensus done linear time proof days algorithm 6 runs linear time also step 2 algorithm takes linear time since linear number species reintroduced replacement also checking caterpillars done time linear number leaves caterpillar4 optimistic local consensus section look problem finding optimistic local consensus olc tree two trees defined previous section note optimistic local consensus two trees may exist recall definition olc tree let 1 2 two rooted trees leaf set rooted tree called optimistic local consensus 1 2 iff triple c b c 41 characterization olc tree following lemma characterizes optimistic local consensus tree exists theorem 41 let 1 2 two rooted trees species set optimistic local consensus tree olc exists ct olc ff 2 2 ct 2 ff compatible ct 1 ct 2 g proof pick cluster ff 2 look triple x triple resolved x z one tree either resolved unresolved tree either case ff 2 ct olc conversely pick cluster two cases namely case ff compatible least one ct 1 ct 2 case ff compatible ff compatible least one ct 1 ct 2 using theorem 21 observe second case pick smallest clusters ff 1 note nodes v u defining clusters ff 1 ff 2 respectively lcas 1 2 respectively species ff 9fi smallest clusters 1 2 respectively containing ff since ff compatible ct 1 ct 2 implies ff union clusters least two children v also union clusters least two children u moreover 9a b 2 ff b b thus pick c 2 fi 1 jfa b c topology given olc b c thus 42 construction phase since optimistic local consensus rule conservative tree set clusters hence exists tree satisfying ct construct refining 1 reduce contracting unnecessary edges thus obtain olc approach take note approach breaks construction two stages refinement contraction refining main objective refine 1 include clusters olc explain precisely introduce notation lemmas previous works enable us efficiently definition 41 let v arbitrary node tree children representative set v set fx 1 x denote repv one representative set lemma 41 optimistic local consensus tree olc trees 1 2 exists olc jrepv isomorphic 2 jrepv proof follows fact 1 jrepv star 2 definition 42 let v node tree children subtree induced fv g refinement follows modify tree 1 initialised postorder fashion every seen v also number children v since processing done postorder fashion say replace subtree v rooted v following manner replace nv isomorphic copy next replace x subtree 1 rooted u let tree produced considering nodes 1 theorem 42 let given suppose olc exists tree produced algorithm described previous paragraph satisfies ct proof since ct olc need show olc jrepv cannot proper refinement 2 jrepv fa b cg repv olc jfa b cg would resolved 2 jfa b cg unresolved since fa b cg repu 1 jfa b cg also unresolved forcing olc also unresolved 2 note reduced problem constructing problem discovering linear time algorithm however need able compute 2 jrepv quickly cite following result 13 useful us case lemma 42 13 given lefttoright ordering leaves tree ability determine topology triple leaves b c constant time construct tree linear time use lemma need two things 1 able determine topology triple 2 o1 time 2 node 1 ordered representative set ordering consistent lefttoright ordering leaves 2 accomplish 1 first preprocess 2 lca queries determine topology triple b c simply compare lcas b b c c second requirement challenging also handled show computing ordered representative sets time ffl initially nodes 1 empty labelings ffl 2 taken lefttoright ordering leaves 2 1 trace path 1 leaf towards root encountering either root node already labeled 2 append ordered set node path traced including first node encountered already labeled figure 3 shows example computation described b c e b c e b c e c added rep sets w v lefttoright ordering c b e c r added rep sets u v r iv completion figure 3 example showing computation representative sets nodes 1 based lefttoright ordering species 2 note computation takes time since node v visited odegv times order produced exactly required thus node v 2 v 1 defined set leaves leaf different subtree v every subtree v represented order leaves appear lefttoright ordering 2 thus proved lemma 43 compute 2 jrepu ojrepuj time therefore following theorem 43 given construct tree ct exists time rest task constructing olc contraction unneeded edges contracting simply go edge check needs kept must deleted note edges added refinement phase required need checked therefore need check original tree edges let u v edge representative sets u v easily choose three species b c lcaa lcab c v topology triple 2 differently resolved b c know edge u v contracted hand 2 jfa b cg either b c b c u v retained optimistic local consensus tree olc construction algorithm phase 0 preprocessing make copies 0 2 1 2 respectively node v tree 0 compute ordered representative sets ordered lefttoright ordering tree preprocess tree 0 answer lca queries leaves well internal nodes phase refine 0refine 0 1 postorder fashion end ct 0 exists phase ii contract 0contract edges e 2 et 0 1 c e cluster e lies ct 1 thus shown following theorem theorem 44 algorithm stated constructs olc two trees 1 2 olc exists analysis running time phase 0 preprocessing 18 harel tarjan give time algorithm preprocessing trees answer lca queries constant time already shown computing ordered representative sets takes time thus preprocessing stage takes time phase refining 0this stage involves local refinements 0 1 shown cost refining around node v odegv summing nodes v obtain time phase ii contracting edges stage clearly takes time theorem 45 construction optimistic local consensus tree done linear time 43 verification phase lemma 44 let tree leaf set let obtained sequence refinements followed sequence edge contractions exists function subset v children fv proof define set clusters therefore subset v children fv v 0 2sv ff v lemma 45 suppose olc 1 2 leaf set containing least 5 species star iff either one following holds 1 1 2 oppositely oriented caterpillars 2 1 2 stars proof direction easy see assume olc star contains triple b c unresolved 2 must also unresolved b c conversely whenever 1 resolved b c 2 must differently resolved b c thus either binary case 1 2 binary definition olc coincides definition binary local consensus appeal proofs lemma 33 lemma 34 argue 1 2 must oppositely oriented caterpillars binary show node v 1 children fu node v 0 2 children fu 0 k g ff u pick three species b c b c unresolved 1 let b c b c must unresolved 2 let v b c claim ff see suppose subtree v contradicts assumption star thus ff next note x child v 1 different children exists z x z resolved 1 unresolved 2 would contradict fact star establishes claim implies nonbinary node v root 1 find two species b v b v species c c 6 v cg thus root must three children case means cluster defined child root contains two species triple 1 2 agree thus 1 2 must stars 2 verification proceeds follows phase 0 suppose tree constructed refining 1 contracting edges resulting tree modification 2 ie refine 2 using information 1 contract edges resulting tree call tree 0 clearly isomorphic 0 terminate output olc exist know compatible set clusters defines unique tree know olc exists uniquely characterized phase 1 phase 0 successful verify compute ordered representative set every node w v node w 1 check homeomorphic subtrees 1 2 induced repw stars oppositely oriented caterpillars neither terminate output olc exist 2 identify parent w say w look repw excluding representative element w call set identify lcas repw 1 2 check species belongs lies lca repw 1 2 terminate output olc exist implementation step 1 phase using lefttoright ordering species 1 compute ordered representative set rep node shown previous section u 2 v able quickly compute homeomorphic subtree 2 induced species repu need know ordering theses species appear lefttoright ordering 2 associate u new rep set rep u rearranged version species repu according ordering 2 define specifies 2 node v 2 v closest root 2 repv function limit together lefttoright ordering species 2 help filling rep sets since belong rep sets nodes path limits first show compute using algorithm limit show rep sets filled initialisation visited topdown traversal f 2 repv set limits identified 2 proceed compute rep u follows look lefttoright ordering species 2 species lefttoright order trace path leaf towards root add rep set node encountered path terminate reach limits note process identifying rep rep done analysis running time isomorphism test phase 0 performed using simple modification treeisomorphism testing algorithm 1 cost preprocessing 1 2 answer lca queries phase 1 implementation step 1 phase 1 involves one time cost preprocessing identify rep rep node time step 1 called node w additional time odegrepw taken exploiting fact 1 2 preprocessed answer lca queries seen step 2 phase 1 takes odegw thus total time taken verification phase correctness verification procedure theorem 46 passes tests olc 1 2 proof need show handles every triple properly following cases handled assuming passed isomorphism test case 1 passes isomorphism test 0 triple b c two trees resolve differently unresolved follows since created refining contracting 1 2 actions take resolved triple different resolution case 2 involves triple b c topology b c 1 2 claim first step phase 1 pass topology triple b c see suppose b c unresolved b c cannot resolved b c c b look nodes u v lcas b 1 2 respectively node w lcaa b c also lcaa b since b c unresolved infer f function defined lemma 44 node w contain species c node w contain either b similar argument look repw compute homeomorphic subtrees 1 2 induced repw induced trees exist three species x z x u v 1 2 z character defined u v thus induced trees triple x topology x z induced trees neither stars oppositely oriented caterpillars thus verification process terminate output olc exist case 3 involves triple b c resolved b c one tree unresolved proof case essentially follows lines proof case 2 case 4 involves triple b c unresolved trees claim second step phase 1 pass triple unresolved see suppose b c resolved b c let lca b c x let lca also suppose without loss generality x parent let 1 child 2 ff 1 let 2 child b 2 ff 2 let z 6 child x c 2 ff z let b c b c look functions f 1 f 2 defined lemma 44 v v 1 respectively v note cluster defined child u nonempty intersection one ff 1 ff 2 similarly v thus representatives chosen ff 1 ff 2 respectively least common ancestor u 1 v 2 however f 1 z 1 v thus representative chosen ff z lie u v 1 2 respectively causing us conclude olc exist 2 5 pessimistic local consensus recall definition pessimistic local consensus two rooted trees leaf set rooted tree called pessimistic local consensus 1 2 iff triple b c jfa b 51 characterization following theorem characterizes plc tree two trees 1 theorem 51 let 1 2 two trees leaf set pessimistic local consensus tree plc 1 2 exists identically equal ct proof pick cluster ff 2 ct since ff belongs trees look triple ff triple resolved x z thus conversely pick cluster two subcases 1 ff compatible least one ct 1 ct 2 case theorem 21 2 ff compatible ct 1 ct 2 case pick nodes 1 define smallest clusters containing ff pick triple b c ff triple unresolved either 1 2 thus construction phase theorem 51 pessimistic local consensus tree exists identically strict consensus tree thus construct pessimistic local consensus tree suffices use algorithm 6 strict consensus tree 53 verification phase let 1 2 input trees let strict consensus tree constructed using algorithm 6 want able verify whether actually pessimistic local consensus case star 1 2 already star nothing verify since true pessimistic local consensus assume case two cases consider first either 1 2 say 1 least two children root leaves second case 1 2 exactly one child root leaf made observations cases apply divide conquer strategy adopted binary local consensus problem lemma 51 suppose 1 2 two trees leaf set 1 least two children root leaves let ff 1 ff l maximal clusters 1 maximal clusters 2 pessimistic local consensus star iff proof suppose 1 means 8x lcax 1 root 2 lcax root thus triple x topologies 1 2 agree thus star suppose defined node leaf look ff k node 1 defining ff k leaf node two cases handle either least one species ff k fi j species ff k fi j ie ff k ae fi j former case pick species z ff k fi j also pick two species x ff agree triple x namely triple topology x z trees thus cannot star latter case since know fi j 6 pick two species x ff k another species z gamma fi j 1 2 topology triple x z thus cannot star 2 since species belongs one maximal clusters tree test done linear time following lemma handles case 1 2 exactly one child root leaf lemma 52 suppose 1 2 two trees leaf set pessimistic local consensus star suppose 1 2 exactly one child root leaf let leaves 1 children root let v lca 2 every child v contains one species x g moreover pair species x g least common ancestor x 2 lies path v root proof suppose 9 child v contains least two species gamma fs g picking x lie child v 2 picking lies different child v find trees topology triple cannot star furthermore 9x lcax 2 lie path v root triple x would identical topologies trees wouldnt star 2 definition 51 rooted tree millipede set internal nodes defines single path root leaf b c figure 4 example millipede g 2 js 1 millipede say let l children root 2 leaves look 1 js 1 say either 1 one nonleaf child least two nonleaf children former case apply previous lemma infer millipede later case apply lemma 52 check pessimistic local consensus star following subsection show verify star input trees millipedes 531 verification input trees millipedes proof following lemma straightforward lemma 53 suppose 1 2 two millipedes leaf set pessimistic local consensus star iff exists triple trees topologies triple describe linear time algorithm verifying 1 2 triple topology define ordering species 1 using function f distance root 1 h height 1 2 write union sets sequence 1 height 2 contains exactly species distance root 2 replace species set fs call multiset integers thus get sequence multisets definition 52 say triple integers p q r special observe pessimistic local consensus 1 2 star iff special triple p q r exists following algorithm check plc takes input sequence returns fail exists special triple integers otherwise returns pass check plc works scanning multiset th iteration makes use three variables global min local min temp start th iteration global min stores smallest integer seen first multisets variable local min used store smallest integer 9b b 2 local min initialised 1 variable temp initialised 0 long temp remains 0 local local min stores temp stores b previously mentioned realtionship b holds th iteration check plc either returns fail special triple exists necessary modifies variables global min local min temp hold intended values first multisets sequence reasoning storing values start th iteration follows 9p p q r special triple global min together q r 2 also special triple since global min p similarly 9p j q 2 l p q r special triple local min temp r 2 also special triple describe check plc initialisation global local procedure outputs fail terminates pessimistic local consensus star outputs pass otherwise f 2 f scan jaj 2 output fail 2 local global f scan either jaj 2 jbj 1 output fail else global min minm set local min global min global min minm set local min global min 2 global output pass analysis running time check plc runs linear time since scanned constant number times theorem 52 algorithm check plc correct proof induction observe step 1 executed th iteration 8j l x follows step 1 executed th iteration start iteration local thus case global min stores smallest integer seen first multisets first multisets special triple p q r exists q r 2 check plc correctly outputs fail since global min p otherwise two cases depending upon value variables global min temp local min updated global min holds smallest value first multisets also local min correctly holds smallest value exists b stored temp b 2 case 0 case global min updated hold minm smallest value first multisets observe temp updated store nonzero value never stores 0 thus temp set nonzero value iteration 0 iteration iteration k step 2 executed assume step 2 executed iteration 0 assume inductively start iteration 0 global min stores smallest value first multisets local min stores smallest value exists b stored temp b 2 iteration 0 easily seen check plc correctly outputs fail exist special triple p q r cases ensures iteration 0 global min stores smallest value first 0 multisets local min stores smallest value exists b stored temp b 2 using arguments seen check plc gives correct output sequence multisets 2 thus also following theorem theorem 53 given two millipedes 1 2 check pessimistic local consensus star linear time 6 relaxed versions local consensus rules seen far output tree satisfying particular rule need exist motivates need look relaxed versions local consensus solutions always exist recall definitions relaxedaccord local consensus relaxed discord local consensus existance solutions problems shown section 22 61 relaxedaccord local consensus subsection show relaxed accord local consensus two binary rooted trees 1 2 actually strict consensus two trees theorem 61 1 2 two rooted binary trees relaxedaccord local consensus always exists identically strict consensus 1 2 proof existence relaxedaccord local consensus tree shown section 2 show tree strict consensus tree suppose exists triple b c resolved differently 1 2 say b c b c respectively say lca 1 neither ff u ff v strict consensus tree thus strict consensus tree leaves unresolved triple different topologies 1 2 let 0 tree every triple b c 1 2 differ 0 unresolved topology triple suppose possible 0 contains cluster intersection sets clusters 1 2 let ff cluster suppose without loss generality ff cluster 1 0 pair species x 2 ff species z 62 ff topology x z however also case 1 1 must also possess cluster ff contradicting assumption thus must exist pair species species z 62 ff 1 topology x z implies cannot relaxedaccord local consensus hence candidate 0 relaxedaccord local consensus contain clusters intersection cluster sets 1 2 0 contains proper subset clusters intersection sets clusters 1 2 exists triple b c 0 unresolved topology strict consensus tree resolved topology agrees topologies 1 2 hence strict consensus 1 2 relaxedaccord local consensus 1 2 2 consequence relaxedaccord local consensus constructed time using algorithm 6 need verify tree constructed correct 62 relaxeddiscord local consensus relaxeddiscord local consensus rdlc problem require triple trees 1 2 agree must topology preserved consensus tree leave unresolved maximal set triples 1 2 disagree previously showed rdlc exists show unique construction rdlc accomplished defining set bcg set rooted triples passed algorithm aho et al 2 computes tree exists required form every triple set resolving minimum number additional triples outside set algorithm takes opn time case p 2 3 use algorithm would result running time 4 obtain speedup 2 algorithm includes verification construction relaxeddiscord tree using fact tree necessarily exists algorithm however takes advantage ideas 2 begin briefly describing algorithm works 621 assu algorithm 2 aho et al describe algorithms determine family constraints least common ancestor relations satisfied within single rooted tree describe simple algorithm give case constraints given rooted resolved triples z input algorithm works topdown figuring clusters children root recursing algorithm maintains disjoint sets initially leaves singleton sets rooted triple x z algorithm unions sets containing x indicate x must lie child root algorithm never unions sets unless forced recursive calls include constraints species entirely contained component discovered previous call species seen component either initially recursive call algorithm determines constraints cannot simultaneously satisfied simple algorithm worst case behavior opn p lca constraints underlying set n elements leaves final tree 622 improved algorithm rdlc describe algorithm solve rdlc 2 time since 1 consistent triples agree clear tree produced assu algorithm refinement tree following sense child root 1 well represents cluster union clusters represented children root let ff cluster child root 1 let fi cluster child root 2 ff fi unions clusters children root fact ff fi nonempty ff fi also union clusters children root show except one special case ff fi fact cluster exactly one child root fi z ff fi z x form triple within 1 2 hence z would lie child root thus case ff fi cluster child root case ff occur one child root 1 one child root 2 following lemma shows lemma 61 let 1 2 2 trees leaf set let ff 1 ff k clusters defined children root 1 l clusters defined children root 2 case ff occur one one j proof suppose let ff ff fi j since ff implies contradiction since fi j fi j clusters defined children root hence disjoint 2 case ff handled follows identify lca say u species similarly lca say v species gamma fi 1 clearly 2 u descendent node defining fi 1 v descendent node defining ff nodes path starting node defining fi ending node u let clusters defined children path nodes path similarily identify clusters defined children nodes path 1 starting node defining ff node v unioning pairs x whenever x lie ff fl whenever lie get partition components turn exactly clusters present children root characterization highlevel description algorithm construct given follows rdlc construction algorithm 1 pair maximal clusters ff 2 recursively compute tree ff fi make root child root 2 clusters ff fi ff compute partition recursively compute tree component partition make roots trees children root running time analysis note algorithm require explicit verification constructed tree since fact know tree exists simply computing mimicking efficiently algorithm 2 would create n recursive stages show stage implemented proving 2 bound case 2 handled time follows build graph vertices labeled species ff fi connect vertices ff fl path j vertices find connected components graph time connected component comp find homeomorphic subtrees 1 2 whose leaf set comp recurse subtrees task common cases described discussion case 1 handle case 1 important waste time empty intersections consider species turn label intersection species lies thus identify n nonempty intersections let ff fi one intersection need find homeomorphic subtree 1 ff fi leaf set show time proportional number leaves ff fi assume 1 2 preprocessed least common ancestor queries also note know lefttoright ordering leaves 1 well 2 given leaves lefttoright ordering also known one induced overall lefttoright ordering lemma 42 reconstruct topology tree linear time exactly need show one stage recursion accomplished time overall time algorithm 2 clearly case handled linear time occur one pair children 7 polynomial time algorithms arbitrary local consensus rules show section polynomial time algorithms constructing local consensus trees begin discussing case f partial local consensus function lemma 71 aho et al2 let multiset k rooted triples leaf set n determine okn log n time tree exists jt homeomorphic 2 15 algorithm given problem addressed 2 case triples resolved case faster algorithm obtained lemma 72 henzinger king warnow 15 let multiset k resolved rooted triples leaf set n determine minfok whether tree exists jfa b cg homeomorphic rooted triples triple exists theorem 71 let f arbitrary partial local consensus function set k evolutionary trees determine local consensus tree exists construct okn 3 time proof given f triple determine form f ja triples f ja restricted form okn 3 time previous lemma determine partial local consensus tree exists construct 25 time total time therefore bounded cost computing triples 2 partial local consensus trees constructed okn 3 total local consensus trees computed even faster lemma 73 kannan lawler warnow 13 given oracle answer queries form jfa b cg species set fa b cg construct 2 tree consistent oracle queries exists orn log n time tree degree bounded r theorem 72 let f total local consensus function given set k rooted trees n species construct okn 2 time flocal consensus tree f exists f always returns resolved subtrees compute f okn log n time proof implement oracle determining form homeomorphic subtree f triple b c first preprocessing trees answer least common ancestor lca queries constant time using 18 answering query needs ok time 13 need 2 queries 2 additional work total cost okn 2 general case f degree bounded r total cost okrn log n f always returns resolved subtrees f binary total cost okn log n 2 8 discussion conclusions several approaches taken handle problem resolving multiple solutions one approach find maximum subset 0 inducing homeomorphic subtrees subtree called maximum agreement subtree14 10 17 primary disadvantage approach return evolutionary tree entire species set however connection problem one local consensus methods tree produced relaxed discord local consensus method contains maximum agreement subtree homeomorphic subtree hard see approach take requires resolution inconsistencies represented single evolutionary tree entire species set classical problem area tree compatibility problem also called cladistic character compatibility problem7 8 9 tree compatibility problem says set trees compatible tree exists every triple resolves resolves problem solved linear time12 19 weakness approach practice many data sets incompatible therefore necessary able handle case pairs trees resolve triples differently approaches type strict consensus median tree problems models stated terms unrooted trees instead clusters characters ie bipartitions species set used represent trees using character encoding consensus tree measure fitness input strict consensus seeks tree characters appear every tree input median tree hand defined metric rooted trees defined cardinality symmetric difference character sets 1 2 given input trees median tree minimizes p median tree computed polynomial time nice characterization terms character encoding 4 16 6 notions related versions local consensus problem relevant local consensus trees always contain least much information trees work represented paper extended several directions noted local consensus functions local consensus tree set k trees computed time polynomial k many local consensus trees constructed okn time r design analysis computer algorithms formal theory consensus median procedure ntrees mitochondrial dna sequences primates tempo mode evolution optimal algorithms comparing trees labeled leaves optimal evolutionary tree comparison sparse dynamic programming numerical methods inferring evolutionary trees efficient algorithms inferring evolutionary trees determining evolutionary tree maximum agreement subtree set evolutionary trees metrics efficient algorithms fast algorithm constructing rooted trees constraints complexity median procedure binary trees computing maximum agreement subtree fast algorithm finding nearest common ancestors tr
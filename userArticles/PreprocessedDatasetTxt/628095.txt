enhancing disjunctive datalog constraints abstractthis paper presents extension disjunctive datalog rmdatalogveeneg integrity constraints two types strong classical integrity constraints weak constraints satisfied possible strong constraints must satisfied weak constraints express desiderata may violatedactually semantics tends minimize number violated instances weak constraints weak constraints may ordered according importance express different priority levels result proposed language call rmdatalogveenegc wellsuited represent common sense reasoning knowledgebased problems arising different areas computer science planning graph theory optimizations abductive reasoning formal definition language first given declarative semantics rmdatalogveenegc defined general way allows us put constraints top existing modeltheoretic semantics rmdatalogveeneg programs knowledge representation issues addressed complexity reasoning rmdatalogveenegc programs carefully determined indepth discussion complexity expressiveness rmdatalogveenegc finally reported discussion contrasts rmdatalogveenegc rmdatalogveeneg highlights significant increase knowledge modeling ability carried constraints b introduction disjunctive datalog datalog programs 18 15 nowadays widely recognized valuable tool knowledge representation commonsense reasoning 2 34 25 20 important merit datalog programs normal disjunctionfree datalog programs capability model incomplete knowledge 2 34 much research work done far semantics disjunctive programs several alternative proposals formulated 5 20 40 46 47 48 51 59 one widely accepted extension disjunctive case stable model semantics gelfond lifschitz according semantics 20 46 disjunctive program may several alternative models possibly none corresponding possible view reality 11 15 eiter gottlob mannila show datalog high expressive power stable model semantics language captures complexity class sigma pie allows us express every property decidable nondeterministic polynomial time oracle np paper propose extension datalog constraints particular besides classical integrity constraints call trongconstraints introduce notion weak constraints constraints possibly satisfied contrary strong constraints express conditions must satisfied weak constraints allow us express desiderata addition weak strong constraints datalog makes language call datalog c wellsuited represent wide class knowledgebased problems including eg planning problems np optimization problems abductive rea soning natural compact way example consider problem scheduling consists scheduling examinations courses want assign course exams time slots way two exams assigned time slot respective courses student common call courses ncompatible supposing three time slots available namely ts 1 ts 2 ts 3 express problem datalog c following program ts 1 assignx ts 2 assignx ts 3 coursex assumed courses pair incompatible courses specified number input facts predicate course incompatible respectively rule r 1 says every course assigned either one three time slots ts 1 ts 2 ts 3 strong constraint 1 rule empty head expresses two incompatible courses overlapped cannot assigned time slot general presence strong constraints modifies semantics program discarding models satisfy clearly may happen model satisfies constraints instance specific instance problem could way assign courses time slots without overlapping incompatible courses case problem admit solution however real life one often satisfied approximate solution one constraints satisfied much possible light problem hand restated follows approx scheduling assign courses time slots trying overlap incompatible courses express problem resort notion weak constraint shown following program p sch ts 1 assignx ts 2 assignx ts 3 coursex syntactical point view weak constraint like strong one implication symbol replaced semantics weak constraints minimizes number violated instances constraints informal reading weak constraint w 1 preferably assign courses x time slot incompati ble note two programs p sch p sch exactly models incompatible courses assigned different time slots ie problem admits exact solution general informal meaning weak constraint say b try falsify bor b preferably false etc thus weak constraints reveal powerful capturing concept preference n commonsense reasoning since preferences may real life different priorities weak constraints datalog c assigned different priorities according mportance 1 ex ample assume incompatibilities among courses may either strong weak eg basic courses common students considered strongly incompatible complementary courses give weak incompatibilities consider following problem scheduling priorities chedule courses trying avoid overlapping strongly incompatible courses first trying avoid overlapping weakly incompatible courses thenie privilege elimination overlapping strongly incompatible courses strong weak incompatibilities specified input facts predicates strongly incompatible weakly incompatible respectively represent scheduling priorities following program p ts 1 assignx ts 2 assignx ts 3 coursex strongly incompatiblex weak constraint w 2 defined tronger thanw 3 models program assignments courses time slots minimize number overlappings strongly incompatible courses among minimize number overlappings weakly incompatible courses main contributions paper following ffl add weak constraints datalog provide formal definition language datalog c semantics constraints given general way 1 note priorities meaningless among strong constraints must satisfied allows us define top existing modeltheoretic semantics disjunctive datalog ffl show constraints profitably used knowledge representation reasoning presenting several examples datalog c encoding datalog c turns general powerful able represent simple coincise way hard problems arising different domains ranging planning graph theory abduction ffl analyze computational complexity reasoning datalog c propo sitional case stable model semantics analysis pays particular attention impact syntactical restrictions datalog c programs form limited use weak constraints strong constraints disjunction negation appears strong constraints affect complexity language constraints mildly increase computational complexity indeed show brave reasoning delta p programs interestingly priorities among constraints affect com plexity decreases delta polog n delta polog n datalog c priorities disallowed complexity results may support choosing appropriate fragment language fits needs practice see section 5 ffl carry indepth discussion expressiveness complexity datalog c contrasting language datalog besides adding expressive power theoretical view point datalog c encode problems cannot represented datalog turns constraints improve also usability knowledge modeling features language indeed wellknown problems encoded simple easytounderstand way datalog c datalog encoding unusable long difficult understand even strong constraints traditionally called integrity constraints wellknown logic programming community see eg 15 10 17 33 12 knowledge first paper formally studies weak constraints proposes use knowledge representation reasoning related works considered interesting papers greco sacca 24 23 analyze extensions datalog express np optimizations problems related studies complexity knowledge representation languages carried 15 50 8 14 21 39 52 9 12 priority levels used also context theory update revision 16 22 prioritized circumscription 31 preferred subtheories approach default reasoning 6 preferred answer set semantics extended logic programs 7 paper organized follows section 2 provide syntax semantics language section 3 describe knowledge representation capabilities datalog c number examples particular show language used easily formulate complex knowledgebased problems arising various areas computer science including planning graph theory abduction section 4 analyze complexity language possibility version stable model semantics finally section 5 reports indepth discussion language draws conclusions appendix shows encoding number classical optimization problems reports proofs complexity results fragments datalog c disjunction either disallowed constrained head 2 datalog c language assume reader familiar basic concepts deductive databases 55 34 logic programming 32 describe next extension disjunctive datalog constraints 21 syntax term either constant variable 2 atom predicate terms literal either positive literal p negative literal p p atom disjunctive rule r clause form atoms disjunction 1 delta delta delta n head r conjunction body r ie head free r normal body free r positive datalog program lp finite set rules lp normal resp positive rules lp normal resp positive strong constraint syntactic form literal ie rule empty head weak constraint syntactic form literal simply program triple lp datalog program possibly empty finite set strong constraints possibly empty finite list components consisting finite set weak constraints w say w 0 tronger thanor important thanw hence last component w n strongest 2 note function symbols considered paper example 2 consider program p p sch section 1 lp p sch w p sch w 2 stronger w 3 22 general semantics program herbrand universe u p p set constants appearing p herbrand base b p p set possible ground atoms constructible predicates appearing p constants occurring u p clearly u p b p finite instantiation rules strong weak constraints defined obvious way constants u p denoted groundlp grounds groundw respectively denote instantiation p total interpretation p subset b p ground positive literal true resp wrt 2 resp ground negative literal true resp false wrt resp 2 let r ground rule groundlp rule r satisfied true wrt head true wrt ie head atom true body false ie body literal false wrt ground strong weak constraint c grounds groundw satisfied wrt least one literal appearing c false wrt otherwise c violated next define semantics datalog c general way rely specific semantical proposal datalog rather applied semantics disjunctive datalog 3 end define candidate model interpretation p satisfies every rule r 2 groundlp ground semantics p finite set candidate models p clearly every classical semantics lp provides ground semantics p example semantics presented 20 40 46 47 48 51 59 taken ground semantics define meaning program context given ground semantics need take account presence constraints end since constraints may different priorities associate component w 2 w inductively defined follows jgroundw j denotes total number ground instances weak constraints appearing w given interpretation program p denote h pm following sum products 3 note although consider total model semantics paper semantics weak constraints simply extends case partial model semantics n number ground instances weak constraints component w violated ready define notion model wrt given ground semantics definition 3 given ground semantics gamma p candidate model every strong constraint 2 grounds satisfied wrt 2 h pm minimum candidate model verifying point 1 h pn h pm thus gammamodel p minimizing h pm selects candidate models besides satisfying strong constraints minimize number unsatisfied instances weak constraints according importance minimal number violated constraints w n chosen among minimal number violated constraints w ngamma1 forth 23 stable model semantics using notion candidate model parametrized semantics datalog c programs actual semantics program p relies semantics choose lp several proposals found literature disjunctive logic programs 5 20 40 46 47 48 51 one generally acknowledged extension stable model semantics take account disjunction 20 46 next report brief discussion semantics 40 minker proposed modeltheoretic semantics positive disjunctive programs whereby positive program lp assigned set mmlp minimal models representing possible meaning lp recall model lp minimal proper subset model lp example 4 positive program g total interpretations fag fbg minimal models ie mmlp stable model semantics generalises approach programs negation given program lp total interpretation gelfondlifschitz transformation lp respect denoted lp positive program defined follows let interpretation program lp stable model lp 2 ie minimal model positive program lp denote set stable models lp smlp example 5 let fbg easy verify minimal model lp thus stable model lp 4 clearly lp positive lp coincides groundlp turns positive program minimal stable models coincide normal positive programs lp exactly one stable model coincides least model lp ie unique minimal model lp negation allowed however even normal program admit several stable models conclude section observing definition 3 provides stable model semantics datalog c program choosen ground semantics smlp set stable models lp definition 6 gammamodel program stable model example 7 consider program p sch sch section according stable model semantics lp sch many stable models possibilities assigning courses say n 3 time slots namely 3 n stable models p sch stable models lp sch satisfying strong constraint 1 two incompatible courses assigned time slot program p sch lp sch sch w sch section 1 lp sch w sch hfw 1 gi obtained lp sch replacing 1 w 1 note lp sch lp sch stable models p sch stable models lp sch minimize number violated instances w 1 number incompatible courses assigned time slots thus p sch provides different solution p sch latter admit stable model ie problem exact solution way assign different time slots incompatible courses otherwise two programs exactly stable models finally consider program p sch section 1 lp stable model lp p sch possible assignment courses time slots stable models p p sch stable models lp p sch first minimize number violated instance w 2 second order minimize number violated instances w 3 4 worth noting datalog c program p may several stable models also one modalities brave cautious reasoning used handle brave reasoning credulous reasoning infers ground literal q true p denoted brave q iff q true wrt stable model p cautious reasoning skeptical reasoning infers ground literal q true p denoted p cautious q iff q true wrt every stable model p inferences brave cautious extend sets literals usual knowledge representation datalog c section provide number examples show datalog c used easily formulate many interesting difficult knowledgebased problems among consider planning problems classical optimization problems graph theory various forms abductive reasoning show language provides natural support representation number examples reported appendixa shall see programs common structure form guess check choose best candidate solutions first nondeterministically generated disjunctive mandatory properties checked strong constraints finally solutions best satisfy desiderata selected weak constraints modular structure shows quite natural expressing complex problems makes programs easy understand 31 planning first example planning namely approx scheduling problem presented introduction example next reported example 8 project groups consider problem organizing given set employees two disjoint project groups p1 p2 wish group possibly heterogeneous far skills concerned preferable couple persons married work group finally would like members group already know consider former two requirements important latter one supposing information employees skills known married persons specified number input facts simple way solving problem given following program stronger w 1 ie gi first rule r 1 assigns employee either one two projects p1 p2 recall minimality stable model exactly one memberx p1 memberx p2 true employee x weak constraint w 1 expresses aim forming groups persons possibly already know w 2 turn expresses preference groups persons married finally weak constraint w 3 tries avoid persons 4 notational simplicity examples represent programs sets rules constraints observe also use inequality predicate 6 builtin legal inequality easily simulated datalog c skill work project easy recognize stable model possible assignment employees projects due priority weak constraints recall w 2 w 3 tronger thanw 1 stable models p proj lp minimize overall number violated instances w 2 w 3 among minimizing number violated instances instance suppose employees b c e b skill c married finally following pairs know reciprocally b c c e e case p proj two stable models 1 correspond following division project teams list atoms predicate member two models observe 1 2 violate two instances w 1 b know satisfy instances w 2 w 3 4 32 optimization graph theory example regarded weak constraints essentially desiderata conditions possibly satisfied however useful way regarding weak constraints objective functionsof optimization problems program weak constraint form b regarded modeling minimization problem whose objective function cardinality relation b perspective strong constraint b seen particular case cardinality relation b required zero suggests us use datalog c model optimization problems next show classical np optimization problems graph theory formulated language number examples found appendixa example 9 max clique given graph find maximum clique subset maximum cardinality c v every two vertices c joined edge e end define following program r 1 partitions set vertices two subsets namely c c ie guesses clique c strong constraint 1 checks guess every pair vertices c clique must joined edge finally weak constraint w 1 minimizes number vertices clique c thus maximizing size c discarding cliques whose size maximum holds stable model p cliq maximum clique g 4 coloring given graph coloring g assignment colors vertices way every pair vertices joined edge different colors coloring minimum uses minimum number colors determine minimum coloring following program used coli colx used coli first rule r 1 guesses graph coloring colx says vertex x assigned color colx strong constraints 1 3 check guess two joined vertices cannot color 1 vertex assigned exactly one color 2 finally weak constraint w 1 requires cardinality relation used col minimum ie number used colors minimum holds onetoone correspondence stable models p col minimum colorings graph g33 abduction next show important forms abduction disjunctive logic programs namely abduction prioritization abduction minimumcardinality solution preference 14 represented easy natural way datalog c general cannot encoded datalog abduction first studied peirce 43 important kind reasoning wide applicability different areas computer science particular recognized important principle commonsense reasoning reasons abduction plays central role artificial intelligence recently received growing attention also field logic programming abductive logic programming deals problem finding explanation ob servations based theory represented logic program 35 36 roughly speaking abduction inverse modus ponens given clause b observation abduction concludes b possible explanation following 13 35 36 abductive logic programming problem lpap formally described tuple hyp set ground atoms called hypotheses obs set ground literals called manifestations observations lp logic program disjunction negation allowed explanation p subset e hyp satisfies following property c e figure 1 computer network brave obs ie exists stable model lp e literals obs true general lpap may single several explanations accordance occams principle parsimony 42 states two explanations simpler explanation preferable minimality criterion usually imposed abductive expla nations two important minimality criterions minimum cardinality prioritization 14 minimum cardinality criterion states solution hyp preferable solution denotes cardinality set x according criterion acceptable solutions p restricted explanations minimum cardinality considered likely example 11 abduction consider computer network depicted figure 1 make observation sitting machine online cannot reach machine e machines offline easily modeled lpap p net hhyp net obs net lp net theory lp net hypotheses observations respectively example according intuition linebg explanation p net also linecg explanation even linec lined linee g explanation however minimum cardinality criterion lineeg solutions p net see probable onesabduction minimum cardinality represented simply datalog c given lpap prp datalog c program lp g positive literal h 2 hyp h denotes new symbol easy see stable models prp correspond exactly minimum cardinality solutions p 5 intuitively clauses g guess solution ie set hypoteses strong constraints check observations entailed weak constraints w 0 enforce solution minimum cardinality example 12 contd datalog c program network problem prp net net g net theory p net stable models lp net g satisfy strong constraints linea reachesa e encode onetoone abductive explanations p net among weak constraints w 0 select explanations minimum cardinality indeed prp net two stable models one contains lineb contains lineethe method abduction priorities 14 refinement minimality cri terion roughly speaking operates follows set hypotheses hyp partitioned groups different priorities explanations cardinality minimal lowest priority hypotheses selected solutions quality selected solutions hypotheses next priority level taken account screening 5 without loss generality assume hypothesis hyp appears head rule lp process continued priority levels pointed 14 prioritization also qualitative version probability different priorities levels represent different magnitude probabilities well suited case precise numerical values known hypotheses grouped clusters probabilities hypotheses belonging cluster basically differ compared difference hypotheses different clusters 14 example 13 contd suppose statistical data computers network figure 1 tell us b falls often e always online c sometimes offline restate lpap p net abductive problem prioritization net obs net lp net according prioritization abductive explainations ordered follows therefore foff linebg becomes preferred ie likely solution note differently convention adopted weak constraints hypotheses smallest priority level important hereby using priorities among weak constraints obtain natural encoding abduction prioritization given prp datalog c g g defined stable models prp correspond exactly preferred solutions p according prioritization example 14 contd datalog c program simulating abduction priorities network example 11 prp 0 net g recall w 3 strongest component easy see prp 0 net one stable model contains hypothesys lineb 4 complexity constraints propositional case section analyze complexity brave reasoning disjunctive datalog programs constraints since complexity independent underlying ground semantics consider section stable model semantics 20 46 widely acknowledged semantics normal disjunctive datalog programs 41 preliminaries complexity theory npcompleteness complexity theory cf 41 classes sigma p k polynomial hierarchy ph cf 53 defined follows particular denotes class problems solvable polynomial time deterministic resp nondeterministic turing machine oracle problem class c oracle replies query unit time thus roughly speaking models call subroutine evaluated unit time c complete problems instances problem 0 c solved polynomial time using oracle ccomplete problem transforming instances refer stating oracle c used notice classes c considered complete problems classes delta p refined class delta p k olog n number calls oracle computation bounded olog n n size input observe k 1 inclusion widely conjectured strict note rightmost inclusion classes contain problems solvable polynomial space allow however finer grained distinction nphard problems pspace complexity classes complete problems polynomialtime transformations involving quantified boolean formulas qbfs qbf expression e boolean expression whose atoms pairwise disjoint nonempty sets variables q alternating quantifiers f9 8g say qbf kexistential otherwise kuniversal validity qbfs defined obvious way recursion variablefree boolean expressions denote qbf k9 resp qbf k8 set valid kexistential resp kuniversal qbfs 1 given kexistential qbf phi resp kuniversal qbf psi deciding whether phi 2 qbf k9 classical sigma p k also complete problems k 2 example given formula e variables deciding whether respect hx 1 lexicographically minimum truth assignment 6 oe x oe known exist fulfills oex n cf 37 58 7 also delta p olog n complete problems k 1 example given phi odd 58 14 problems remain hard following restrictions e 1 conjunctive normal form clause contains three literals 3cnf q disjunctive normal form monom contains three literals 3dnf q 42 complexity results analyze complexity propositional case therefore throughout section assume programs query literals ground ie variablefree complexity results however easily extended data complexity 57 given program denote maxhp value h pm assumes interpretation violates ground instances weak constraints component precisely cardinality set ground instances constraints w observe maxhp exponential number components p indeed inductive definition fw see section 22 easily seen turns value maxhp exponential size input however computable polynomial time binary representation polynomial size next report detailed proofs complexity results datalog c programs full disjunction allowed proofs involved technically interesting demonstrations results disjunctionfree programs headcycle free disjunctive programs reported appendixb complexity results sumarized table 1 discussed indepth section 5 first look upper bound complexity brave reasoning datalog c end provide two preliminary lemmata lemma 15 given datalog c program positive integer n input sigma pdeciding whether exists stable model lp satisfying h pm n 6 oe lexicographically greater wrt hx false least j oex j set variablefree true formulas proof decide problem follows guess check 1 stable model lp 2 constraints satisfied 3 h pm n clearly property 2 3 checked polynomial time 1 decided single call np oracle 39 15 problem therefore sigma p 2 lemma given datalog c program positive integer n literal q input sigma pdeciding whether exists stable model lp satisfying h q true wrt proof decide problem follows guess check 1 stable model lp 2 constraints grounds satisfied 3 h q true wrt clearly property 2 3 4 checked polynomial time 1 decided single call np oracle 39 15 problem therefore sigma p position determine upper bound brave reasoning full datalog c programs theorem 17 given datalog c program literal q input deciding whether q true stable model p delta p 3 proof first call sigma poracle verify p admits stable model satisfying otherwise q cannot brave consequence compute polynomial time maxhp binary search 0k determine cost sigma stable models p polynomial number calls oracle deciding whether exists stable model lp satisfying h pm n n k2 first call oracle answers yes otherwise n set k2 k4 according standard binary search oracle sigma p 2 virtue lemma 15 observe number calls oracle logarithmic k consequence polynomial size input value k o2 jp j finally call sigma p oracle verifies q true stable model p stable model lp satisfying doable sigma p 2 lemma 16 2 next strenghten result delta pmembership completeness result class hardness proven reductions qbfs problems related stable models datalog c programs utilized disjunctive datalog programs suitable adaptations extensions disjunctive program reported next first described 12 let phi formula form 8y e e boolean expression propositional variables x g assume e 3dnf ie conjunction literals l ij define following positive disjunctive datalog program lp phi oe maps literals atoms follows intuitively x 0 corresponds x 0 j corresponds j given truth assignment oex g denote oe b lp phi following interpretation fy 0 moreover given interpretation lp phi denote oe truth assignment lemma phi formula disjunctive datalog program defined respectively onetoone correspondence truth assignments oex phi valid stable models lp phi contain atom v particular 1 phi 2 2 smlp phi contains v phi oe proof follows theorems 31 12 2 note lp phi constructible phi polynomial time ready determine exactly complexity reasoning programs theorem 19 given datalog c program literal q input deciding whether q true stable model p delta pcomplete proof theorem 17 remains prove hardness delta phardness shown exhibiting datalog c program brave reasoning solves following complete problem pi let oex g lexicographically minimum truth assignment respect hx 1 x n phi assume oe exists true oex n wlog assume e 3dnf form defined let p datalog c program lp phi positive disjunctive datalog program defined w vgi next show answer pi true iff x n true stable model p 0 let sm v lp phi denote set stable models lp phi contain v lemma know onetoone correspondence sm v lp phi set truth assignments oe make phi oe valid since phi oe valid hypothesis implies sm v lp phi 6 consequently p 0 stable models strong constraint p 0 stable model p 0 contains v v strongest constraint w 0 priorities among constraints ff x n impose total order sm v lp phi particular given two stable models 0 sm v lp phi truth assignment oe 0 greater oe lexicographically order therefore p 0 unique stable model sm v lp phi corresponding lexicographically minimum truth assignment oe phi hence lexicographically minimum truth assignment oex making phi oe valid fulfills oex n x n true stable model p 0 therefore brave reasoning delta p 3 hard datalog c 2 next show neither strong constraints negation affect complexity datalog c remains unchanged even disallow corollary 20 given datalog c program literal q input deciding whether q true stable model p delta pcomplete even strong constraints disallowed lp stratified even positive proof membership delta p 3 trivially holds theorem 17 far hardness concerned observe reduction theorem 19 datalog c program p 0 strong constraints ie logic program lp phi positive therefore stratifiedthus syntactic restrictions imposed corollary 20 decrease complexity datalog c interestingly complexity language decreases disallow priorities among weak constraints theorem 21 given datalog c program consists single component literal q input deciding whether q true stable model p delta p 3 olog ncomplete proof delta polog nmembership proceed exactly proof theorem 17 ever since w consists one component time programs priorities o2 jp j one component w weight 1 consequently number calls sigma p 2 oracle logarithmic size input logarithmic k perform binary search 0k nhardness let phi 2existential qbfs phi next reduce delta p 3 olog nhard problem deciding odd brave reasoning datalog c programs without priorities ie one component w wlog assume even 2 propositional variable appear two distinct qbfs qbfs phi proof theorem 19 lp phi defined theorem 19 apart replacing occurrence v v c weak constraints w 0 enable select stable models lp phi number valid qbfs maximum odd odd true stable model p 2 datalog c programs prioritized weak constraints complexity affected negation strong constraints corollary 22 let program w single component brave reasoning delta p 3 olog ncomplete even p subject following restrictions lp stratified even positive proof membership delta p 3 olog n comes theorem 21 hardness restriction 1 stratified programs comes hardness proof theorem 21 reduction make use priorities strong constraints utilizes stratified negation complete proof demonstrate hardness case positive programs end need eliminate negation logic program proof theorem 21 follows 1 eliminate lp 0 rules head odd rules containing nega tion 2 insert following weak constraints w even 1 m25 discussion complexity expressiveness datalog c section discuss results complexity datalog c established previous section interestingly results allow us draw useful remarks also expressive power language turns strictly powerful disjunctive datalog without constraints show also increased expressive power language relevance even practical side providing meaningful examples represented naturally datalog c disjunctive encoding impossible complex unusable table 1 complexity brave reasoning various extensions datalog constraints propositional case stable model semantics table 1 sumarizes complexity results previous section complemented results complexity programs without constraints already known literature therein column refers specific form constraints namely strong constraints constraints priorities priorities ie w one component lines table 1 specify allowance disjunction negation particular stands stratified negation 45 h stands hcf disjunction 3 see appendixb entry table provides complexity class corresponding fragment language instance entry 8 5 defines fragment datalog c allowing disjunction stratified negation far constraints concerned weak constraints priorities fw g unstratified negation strong constraints disallowed fragment languages correspond fragments 31 91 respectively full datalog c fragment 96 whose complexity reported lower right corner table corresponding entry table namely delta p expresses brave reasoning datalog c delta p 3 complete first observation datalog c strictly expressive datalog indeed former language express problems represented lat ter datalog c extension datalog moreover delta pcompleteness datalog c witnesses datalog c express delta p 3 complete problems datalog cannot unless polynomial hierarchy collapses 15 example encoding delta p 3 complete problem reported proof theorem 19 see another example consider abductive reasoning addressed section 33 hypothesis relevant logic programming abductive problem p occurs explanation minimum cardinality resp prioritized abduction relevance requires membership minimum cardinality solution resp minimal solution according prioritization results 13 14 deciding relevance delta p 3 olog ncomplete abduction minimum cardinality criterion delta pcomplete prioritized abduction fore relevance hypothesis h logic programming abduction problem cannot expressed reasoning disjunctive datalog sigma pis upper bound complexity brave reasoning datalog 15 hand translation provided section 33 easy see h relevant p iff brave consequence prp ie relevance reduced brave reasoning datalog c 8 considering datalog c linguistic extension datalog constraints turns constraints add expressive power datalog however case strong constraints seen table 1 indeed look various fragments language differ presence strong constraints note complexity constant compare column 1 2 3 4 5 6 fact stable model semantics strong constraint form b actually shorthand p b p example consider problem scheduling section 1 program p sch used express scheduling relies hcf disjunction stratified negation contains one strong constraint weak constraints occur fragment 52 problem easily formulated hcf datalog unstratified negation fragment 61 simply replacing strong constraint assignx assigny incompatiblex datalog rule p new atom 9 worth noting brave reasoning allows us simulate strong constraints negation allowed program replace strong constraint b rule p b p fresh atom require p brave consequence thus rather clear strong constraints affect complexity expressiveness language therefore increased expressive power datalog c wrt datalog due entirely weak constraints however weak constraints 8 note delta phardness disjunction allowed abductive theory lp thus example p net hard instance problem translation gave general holds also hard instances disjunction abductive theory lp 9 actually scheduling problem even formulated datalog hcf disjunction simulated unstratified negation indeed guess expressed disjunctive rule implemented following three nondisjunctive rules ts 1 ts 2 ts 3 ts 2 ts 1 ts 3 ts 3 ts 1 ts 2 cause tremendous increase computational cost mildly increase complexity see comparing column 1 columns 3 5 table 1 example add weak constraints hcf disjunction without negation see lines 46 increase complexity np delta polog n delta p depending whether weak constraints prioritized respectively note program p cliq example 9 consists weak constraint top hcf program likewise weak constraints added datalog increase complexity sigma pto delta polog n delta p depending possible prioritization weak constraints see lines 79 therefore adding weak constraints complexity language always remains level polynomial hierarchy instance np reach delta p 2 never jump sigma p 2 classes second level polynomial hierarchy clearly weak constraints impact complexity fragments admitting unique stable model see lines 1 2 remarks complexity various fragments language fol lowing first presence negation impact complexity fragments allowing disjunction see lines 4 9 second complexity free fragments full negation see line coincides hcf disjunction lines 4 6 lies one level polynomial hierarchy respect fragments based plain datalog see line 9 besides increase theoretical expressiveness ability express problems cannot represented datalog datalog c provides another even important advantage several problems represented also datalog whose complexity thus greater sigma p admit much natural easytounderstand encoding datalog c coupling disjunction constraints provides powerful elegant tool encode knowledge better appreciate simplicity readability datalog c consider problem max clique represented simply elegantly datalog c see example 9 next show encoded also datalog unfortunately resulting program tricky difficult understand technique use build datalog version max clique described 15 based modular approach first module lp 1 generates candidate solutions cliques case second module lp 2 discards satisfy certain criteria maximal cardinality disjunctive program lp 1 generates cliques sizes assumed nodes ordered relation succ provided input could also guessed another module rule r 1 guesses clique c rule r 2 enforces constraint every two nodes c must joined edge rule constraint must satisfied every stable model constraint unsatisfiable stable model exist atom counti j expresses node jth node clique c thus rule r 6 defines size number nodes c restrict maximum size cliques add lp 1 following datalog program lp 2 discards clique nonmaximal size r 0 c 0 x c 0 x nodex r 0 count1i j count1a b succa succb j c 0 r 0 c 0 sizek greatestv ertexn count1n k r 0 notgreater c r 0 c 0 x nodex notgreater r 0 1 guesses another clique c 0 notgreater true c 0 clique count1 counts elements c 0 c 0 size define size c 0 size c 0 less equal c notgreater true c 0 c 0 assigned maximum extension rules r 0 8 r 0 9 way cliques c 0 smaller c stable models collapse single stable model maximum extension c c 0 containing notgreater contrary clique c 0 bigger c stable model lp 2 contains notgreater thus rule r 0imposes every stable model contain notgreater easy recognize program onetoone correspondence stable models maximum cliques g comparing datalog program datalog c version example quite apparent advantage weak constraints provide terms simplicity naturalness programming concluding would like bring readers attention fragment datalog c hcf disjunction stratified negation 56 table 1 clear easy tounderstand semantics time allows us express several hard problems delta p complete problems natural compact fashion opinion recursion disjunction negation makes programs difficult understand perhaps datalog encoding max clique best skeptical existence datalog encoding simpler datalog c encoding example 9 r logic programming negation survey logic programming knowledge representation journal logic programming propositional semantics disjunctive logic pro grams reasoning minimal models efficient algorithms applications disjunctive semantics based upon partial bottomup evaluation nonmonotonic reasoning logical foundations commonsense preferred answer sets extended logic programs survey complexity results nonmonotonic logics generalized closed world assumption slick procedure integrity checking deductive databases adding disjunction datalog computational cost disjunctive logic pro gramming propositional case abduction logic programs semantics complexity complexity logicbased abduction disjunctive semantics updates databases disjunctive lp semantics disjunctive deductive databases computers intractability guide theory npcompleteness classical negation logic programs disjunctive databases complexity expressive power disjunctive logic pro gramming extending datalog choice weak constraints disjunctive logic programming disjunctive data bases complexity optimization problems theoremproving approach database integrity declarative fixpoint characterizations disjunctive stable models disjunctive stable models unfounded sets computing circumscription foundations logic programming constraint checking stratified databases foundations disjunctive logic programming mit press generalized stable models semantics abduction abductive logic programming generalizations optp polynomial hierarchy relationship logic program semantics nonmonotonic reasoning autoepistemic logic indefinite data bases closed world assumption computational complexity abductive inference models diagnostic problem solving abduction induction weakly perfect model semantics logic programs foundations deductive databases logic programming stable semantics disjunctive programs static semantics normal disjunctive logic programs deductive objectoriented databases modular stratification magic sets datalog programs negation expressive powers stable models bound unbound datalog queries possible model semantics disjunctive databases expressive powers logic programming semantics classifying computational complexity problems word problems requiring exponential time principles database knowledgebase systems wellfounded semantics general logic programs complexity relational query languages bounded query classes tr ctr alfredo garro luigi palopoli francesco ricca exploiting agents elearning skills management context ai communications v19 n2 p137154 april 2006 alfredo garro luigi palopoli francesco ricca exploiting agents elearning skills management context ai communications v19 n2 p137154 january 2006 rewriting efficient computation bound disjunctive datalog queries proceedings 5th acm sigplan international conference principles practice declaritive programming p136147 august 2729 2003 uppsala sweden gianluigi greco sergio greco irina trubitsyna ester zumpano optimization bound disjunctive queries constraints theory practice logic programming v5 n6 p713745 november 2005 simona perri francesco scarcello nicola leone abductive logic programs penalization semantics complexity implementation theory practice logic programming v5 n12 p123159 january 2005 francesco calimeri giovambattista ianni template programs disjunctive logic programming operational semantics ai communications v19 n3 p193206 august 2006 filippo furfaro sergio greco sumit ganguly carlo zaniolo pushing extrema aggregates optimize logic queries information systems v27 n5 p321343 july 2002 thomas eiter michael fink hans tompits knowledgebased approach selecting information sources theory practice logic programming v7 n3 p249300 may 2007 marcelo arenas leopoldo bertossi jan chomicki answer sets consistent query answering inconsistent databases theory practice logic programming v3 n4 p393424 july nicola leone gerald pfeifer wolfgang faber thomas eiter georg gottlob simona perri francesco scarcello dlv system knowledge representation reasoning acm transactions computational logic tocl v7 n3 p499562 july 2006 christoph koch nicola leone gerald pfeifer enhancing disjunctive logic programming systems sat checkers artificial intelligence v151 n12 p177212 december thomas eiter michael fink giuliana sabbatini hans tompits using methods declarative logic programming intelligent information agents theory practice logic programming v2 n6 p645709 november 2002 evgeny dantsin thomas eiter georg gottlob andrei voronkov complexity expressive power logic programming acm computing surveys csur v33 n3 p374425 september 2001
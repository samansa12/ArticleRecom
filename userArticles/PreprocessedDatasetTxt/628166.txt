nondeterministic nonmonotonic logic databases abstractwe consider paper extension datalog mechanisms temporal nonmonotonic nondeterministic reasoning refer datalog show means examples flexibility expressing queries concerning aggregates data cube also show iterated fixpoint stable model semantics combined purpose clarifying semantics datalog programs supporting efficient execution finally provide concrete implementation strategy basis design optimization techniques tailored datalog addressed b introduction motivations name datalog used paper refer datalog extended mechanisms supporting limited form temporal reasoning means temporal stage arguments relations ranging discrete temporal domain style 5 nonmonotonic reasoning means form stratified negation wrt stage arguments called xystratification 26 nondeterministic reasoning means nondeterministic choice construct 12 essentially fragment ldl 2 advocated 27 chap 10 revealed highly expressive language applications diverse areas ai planning 4 active databases 25 object databases 8 semistructured information management web restructuring 10 data mining knowledge discovery databases 15 3 11 however thorough study semantics datalog still missing provides basis sound efficient implementations optimization techniques preliminary study semantics datalog sketched 4 discussing relation declarative modeltheoretic semantics fixpoint bottomup semantics discussion however informal moreover fails achieve precise coincidence two semantics arbitrary programs found therefore motivated indepth study semantics datalog programs also explains reason missing coincidence semantics 4 proposes general condition ensures coincidence objectives contributions paper aimed 1 illustrating expressiveness flexibility datalog query language 2 providing declarative semantics datalog integrates tem poral nonmonotonic nondeterministic mechanisms justifies adoption iterated fixpoint semantics language 3 providing basis query optimization datalog thus making viable efficient implementation purpose proceed follows 1 use datalog query language discussed section 2 2 natural purely declarative semantics datalog assigned using notion stable model section 3 constructive semantics assigned using iterative procedure exploits stratification induced progression temporal argument 3 main result paper show two semantics equiva lent provided natural syntactic restriction fulfilled imposes disciplined use temporal argument within choice construct 4 basis result introduce section 4 concrete operational semantics using relational algebra operators section 5 repertoire optimization techniques especially tailored datalog particular discuss possible support efficient historyinsensitive temporal reasoning means real sideeffects iterated computation 19 material sections 2 3 based results presented compact form 9 14 material sections 4 5 new conclusion paper provides thorough account pragmatics semantics implementation datalog related work nondeterminism introduced deductive databases means choice construct original proposal 17 later revised 23 refined 12 studies exposed close relationship connecting nonmonotonic reasoning nondeterministic constructs leading definition stable model semantics choice declarative semantics choice based stable model semantics intractable general choice amenable efficient implementations actually supported logic database language ldl 20 evolution ldl 2 side stratification crucial notion introduction nonmonotonic reasoning deductive databases original idea 1 static stratification based predicate dependencies stratified negation refined deal dynamic notions case locally stratified programs 21 modularly stratified programs 22 dynamic local stratification close connection temporal reasoning progression time points yields obvious stratification programsconsider instance 1s 5 therefore natural non monotonic temporal reasoning combined several deductive database languages 18 16 however striking mismatch apparent two lines nondeterminism leads multiplicity stable models whereas stratification leads unique perfect model far comprehensive study addressed combination two lines occurs datalog requires development non deterministic iterated fixpoint proce dure notice however mentioned exception 4 approach problem sketched reference locally stratified programs augmented choice present paper present instead thorough treatment programs repair inconvenience approach 4 concerning incompleteness iterated fixpoint procedure preliminaries assume reader familiar concepts relational databases datalog language 24 various extensions considered paper datalog language unrestricted use negation body rules subset datalog consisting predicatestratified pro grams sense 1 language introduced 5 predicate may designated argument called stage argument ranging natural numbers natural number n represented term n nil 1s language datalog 1s unrestricted use negation rule bodies datalog subset 1s negation used disciplined manner according mechanisms xystratification nondeterministic choice introduced next section 2 query answering datalog datalog basis deductive databases essentially friendly syntax express relational queries extend query facilities relational calculus recursion datalogs simplicity expressing complex queries impacted database technology nowadays recursive queriesviews become part sql3 standard recursive queries find natural applications areas information systems computing transitive closures traversals issue billofmaterials queries route plan formation graph traversals however widely recognized expressiveness datalogs recur sive rules limited several extensions along various directions proposed paper address particular two directions namely nondeterministic nonmonotonic reasoning supported respectively choice construct notion xystratification introduce mechanisms means examples meant point enhanced query capabilities nondeterministic choice choice construct used nondeterministically select subsets answers queries obey specified fd constraint instance rule st adst ad majorst area facultyad area choicest ad assigns student unique arbitrary advisor area since choice goal constrains st ad relation obey fd st ad fore base relation major formed tuples fsmith db gray seg base relation faculty formed tuples fbrown db scott db miller seg two possible outcomes query st adstad either fsmith brown gray millerg fsmith scott gray millerg practical systems ldl one two solutions computed presented result thus first use choice computing nondeterministic nonrecursive queries however choice combined recursion following rules compute arbitrary ordering given relation r root fresh constant conveniently used simplify program base relation r formed k tuples k possible outcomes query ord rx namely set ford rroot root ord rroot 1 permutation ft 1 g tuples r therefore possible outcome mentioned query relation ord r total ordering tuples r double choice constraint recursive rule specifies successor predecessor tuple r unique interestingly choice employed compute new deterministic queries inexpressible datalog well pure relational calculus remarkable example capability expressing aggregates following program computes summation aggregate relation r uses arbitrary ordering r computed ord r sum rroot 0 sum ry n sum rx ord rx total sum rn sum rx n ord rx sum rxn used accumulate n summation x respect order given ord r therefore total sum reconstructed sum rx n x last tuple order notice use stratified negation purpose selecting last tuple practical languages ldl syntactic sugar aggregation used abbreviation program 26 total sum rsum x rx basis simple example sophisticated forms aggregation datacube olap functions built example consider relation salesdate department sale problem aggregating sales along dimensions date department three aggregation patterns possible corresponding various facets datacube date department former two patterns correspond aggregation sales along single dimension respectively department date obtained original relation applying method shown latter pattern obtained recursively applying method one two patterns previously computed order aggregate along remaining dimension case several dimensions along aggregate simply repeat process aggregating step along new ie still nonaggregated dimension thorough account programming nondeterminism deductive databases found 7 13 semantics choice assigned using socalled stable model semantics datalog programs concept originating autoepistemic logic applied study negation horn clause languages gelfond lifschitz 6 define notion stable model need introduce transformation h given interpretation maps datalog program p positive datalog program hp next define said stable model p sp general datalog programs may zero one many stable models multiplicity stable models exploited give declarative account nondeterminism fact define stable version program given datalog program p stable version defined program obtained p replacing references choice atom rule r h b choicex x disjunct vectors variables appear also b atom chosen r x chosen r predicate defined following rules chosen r diffchoice r definition fixed value x choice inhibits possible ones via diffchoice r stable models sv p one notice construction occurrence choice atom pair chosen diffchoice atoms thus bounding scope atom rule appears various stable models transformed program sv p thus correspond choice models original program xyprograms another notion used paper xyprograms originally introduced 26 language programs 1s admits negation body atoms unary constructor symbol used represent temporal argument usually called stage argument general definition xyprograms following xystratification set p 1s rules defining mutually recursive predicates xyprogram satisfies following conditions 1 recursive predicate distinguished stage argument 2 every recursive rule r either xrule yrule r xrule stage argument every recursive predicates r variable r yrule head r stage argument sj j variable ii goal r j stage argument iii remaining recursive goals either j sj stage argument intuitively rules xyprograms atom pj denotes extension relation p current stage present time j whereas atom psj denotes extension relation p next stage future time sj using different primed predicate symbol p 0 psj atoms obtain socalled primed version xyprogram say xyprogram xystratified primed version stratified program intuitively dependency graph primed version cycles negated edges possible obtain ordering original rules modulo stage 1 ease presentation include definition sv p case one choice atom per rule definition general case found 13 arguments consequence xystratified program also locally stratified therefore unique stable model coincides perfect model 21 let p xystratified program 0 define p stage argument head rg rxi stands r replaced x ie p set rule instances p define predicates stage argument iterated fixpoint procedure computing unique minimal model p defined follows 1 compute 0 minimal model p 2 j 0 compute j minimal model notice j 0 p j stratified definition hence perfect model j computable via iterated fixpoint procedure paper use name datalog refer language xy programs augmented choice goals 3 semantics choice constructs allowed xyprograms multiplicity stable models exists given program therefore needed clarify phenomenon combines iterated fixpoint semantics choicefree xyprograms task accomplished three steps 1 first present general result stating whenever datalog program p stratifiable hierarchy recursive cliques ie minimal sets mutually recursive rules stable model entire program p reconstructed iterating construction approximating stable models associated clique 2 second observe syntactic restriction use choice construct compromise expressiveness datalog programs naturally stratified hierarchy recursive cliques using temporal arguments recursive predicates 3 third observation 2 apply general result 1 programs thus obtaining stable models entire program computed iterative fixpoint procedure follows stratification induced temporal arguments given possibly infinite program p consider possibly infinite topological sort distinct recursive cliques q 1 oe induced dependency relation predicates p given interpretation use notation denote subset atoms whose predicate symbols predicates defined clique q following observations straightforward analogously predicates defined q i1 depend definitions consequence interpretation q i1 ignore next definition shows transform recursive clique within given topological ordering selfcontained program takes account information deduced previous cliques transformation resembles gelfondlifschitz transformation reported sect 2 definition 3 consider program p topological sort recursive cliques interpretation define defined q defined q ut idea underlying transformation remove clique q dependencies induced predicates defined lower cliques abbreviate q redi q red interpretation clear context example 1 consider program recursive cliques rg consider interpretation fs q rg q red red following lemma 1 states relation models transformed cliques models program abbreviate analogously q lemma 1 given possibly infinite datalog program p interpretation topological sorts p induced dependency relation p following statements equivalent 1 sp 2 8i 0 q red 3 8i 0 q proof sketch proof structured follows 1 3 2 3 3 1 next show sp b sp rule hp comes rule r p turn appears q model r hypothesis atom n appears r also model r model hp hence sp b 2 2 hypothesis definition sp moreover 0 readily checked 1 3 observe minfi j implies g 2 3 proceed induction base case trivial inductive case next show q b vice versa notice induction hypothesis suffices show simple case analysis b exploiting induction hypothesis igamma1 q igamma1 definition hp show induction n 8n 0 n red base case induction case n 0 2 n red exists rule b red red definition h q red exists rule q fc e l observe definition h b furthermore induction hypothesis igamma1 following fb hence definition 2 q completes innermost induction obtain 3 2 proceed way similar preceding case see suffices verify rule instance r head following property holds 8n 2 n red converse simply observe model q red result states arbitrary datalog program stable model approximating clique according given topological sort local stable model result gives us intuitive idea computing stable models approximable program means computation stable models approximating cliques notice lemma 1 holds arbitrary programs provided stratification hierarchy cliques given sense result widely applicable various notions stratified programs modularly stratified programs 22 required clique q red locally stratified contrary require clique sense stratified motivated objective dealing non determinism justifies adopt nondeterministic stable model semantics rather deterministic semantics stratified datalog programs instance perfect model semantics 21 turn attention xyprograms result instantiating clauses xyprogram p possible values natural numbers stage argument yields new program sgp stage ground precisely rule stage argument rg stable models p sgp closely related lemma 2 let p xyprogram interpretation proof sketch show induction 8nt n implies thesis base case trivial inductive case observe since p xystratified 2 n1 hpi b fb hsgp vice versa 2 n1 fb hpi ut however dependency graph sgp obviously p induce necessarily topological sort general xyprograms predicatestratified therefore lemma 1 directly applicable tackle problem distinguish predicate symbol p program fragment p predicate symbol fragments p j j 6 differentiating predicate symbols using temporal argument therefore pi x atom involved rule p modified version p x precisely introduce xyprogram p modified version sop stageout defined sop obtained program fragment p sgp extracting stage arguments atom adding predicate symbol atom similarly modified version soi interpretation defined therefore atom pi x iff atom p x soi value stage argument position relation p unsurprisingly stable models sgp sop closely related lemma 3 let p xyprogram interpretation proof sketch easy see sosgp hence least herbrand models sohsgp hsop soi coincide ut aim conclude given topological sort sop hypothesis lemma recall 0 clique sop consists rules sop stage argument heads b lemmas 1 2 3 interpretation stable model p iff constructed i0 0 stable model sop redi ie clique sop reduced substituting atoms deduced stages earlier basis b possible define iterative procedure construct arbitrary stable model p union interpretations defined follows iterated stable model procedure base case 0 stable model bottom clique sop induction case 0 stable model sop redm ie clique sop reduced respect 0 interpretation called iterated stable model p observed construction close procedure called iterated choice fixpoint 4 also following approach 13 local stable model turn efficiently constructed nondeterministic fixpoint computation polynomial time unfortunately desired result notions stable model iterated stable model coincide hold full generality sense iterative procedure complete arbitrary datalog programs giving rise inconveniences 4 mentioned introduction fact demonstrated example undisciplined use choice datalog programs may cause presence stable models cannot computed incrementally hierarchy cliques example 2 consider following simple stable version sv p p rule defining predicate p replaced chosenx qi x diffchoicex general sop composed one clique expression replaced sop however ease presentation ignore since general case trivially deduceable follows readily checked sv p admits two stable models namely fq0 first model iterated stable models therefore second model cannot computed using iterated choice fixpoint 4 ut technical reason problem free use choice construct inhibits possibility defining topological sort sop based value stage argument example 2 predicate dependency relation dependency among stage stages j dependency chosen predicate predicates q stages prevent problem suffices require choice goals refer stage argument domain associated functional dependency programs comply constraint called choicesafe following way turn program example 2 choicesafe program different semantics syntactic restriction moreover greatly compromise expressiveness query language possible simulate within restriction general use choice see 19 considerations summarized following main result paper mentioned restriction choicesafety direct consequence lemmas 1 2 3 theorem 1 correctness completeness iterated stable model procedure let p choicesafe datalog program interpretation stable model sv p iff iterated stable model p ut following example shows computation iterated stable model procedure example 3 consider following datalog version seminaive pro gram discussed 26 nondeterministically computes maximal path node graph g assume graph given eig following interpretations carried stage iterated stable model procedure 1 ag 2 bg 3 1 cg 2 dg 4 1 b 3 5 theorem 1 conclude two stable models program 2 3 clearly realistic implementation provided ldl computes non deterministically one possible stable models ut 4 operational semantics translate iterated stable model procedure concrete form using relational algebra operations control constructs following style 24 associate predicate p relation p name capitalized elementary deduction step tq translated assignment appropriate relations 0 tq ie relations defined clique q together extensional relations evalp rels denotes notation 24 single evaluation step rules predicate p respect current extension relations rels show translation datalog cliques incrementally three steps starting simple datalog programs stratified negation introducing choice construct eventually describing translate full language translation whole program trivially obtained gathering single translated cliques natural order stratified negation apply straightforwardly transformation given 24 safe stratified datalog programs negative literal referring previously computed extensional relation translated complement relation wrt universe constants translation template 1 8p defined repeat 8p defined q last 8p defined q last p translation illustrated following example 4 program translated following naive evaluation procedure eval instanced appropriate ra query repeat last last last p adding choice need translate relational algebra terms operations compose nondeterministic computation following approach 13 12 partition rules sv q stable version q three sets chosen rules diffchoice rules ie remaining rules nondeterministic fixpoint procedure computes stable models choice program represented following translation template 2 0 init 8p defined sv 1 saturation repeat 8p defined last p p 8p defined last 2 gather choices 8chosen r defined c chosen 0 3 termination test 8chosen r defined c chosen 0 4 choice execute fairly following choose chosen 0 b choose 2 chosen 0 r 5 inhibit choices 8diffchoice r defined diffchoice r evaldiffchoice r step 1 procedure tries derive possible atoms already given choices none first iteration step 2 collect candidate atoms chosen later atom ie reached fixpoint evaluation nondeterministically choose one step 4 propagate effects choice step 5 order force fd implies ready repeat process example 5 stable version studentsadvisors example seen section 2 following st adst ad majorst area facultyad area chosenst ad following translation schema obtain following procedure 0 st ad chosen diffchoice 1 st ad stad majorst area f acultyad area chosenst 2 chosen 0 stad majorst area f acultyad area diffchoicest ad 3 chosen 4c chosen chosen f st ad g 5 diffchoice diffchoice st g theta f ad g notice steps slightly modified step 1 sim plified since rule recursive modulo chosen predicate ii one choice rule step 4a becomes useless ignored iii step 5 rewritten brief readable form exactly meaning shown general schema adding xystratification analyzing evaluation procedure xy cliques q easy see step n atoms derived form stage argument syntactic form rules ensures rules refer atoms stage arguments rule serve distinguish literals computed actual stage computed previous stage gamma 1 therefore safely omit stage argument xyrecursive predicate renaming literals referring previous stage ie stage inside rule head stage 1 adding prefix old apply exitrules stage argument value significant must preserved denote q 0 resulting rules p 0 predicate obtained p example 6 program q translated new program suffices store external register j value stage evaluation fire exitrules stage argument j ii evaluate new rules q 0 stratified possibly choice described last two sections completely evaluated actual stage need store newly derived atoms p corresponding old p increment j repeat process order evaluate next stage resulting procedure following translation template 3 0 init defined q 1 fire exit rules 8exitrule 2 fire q translate following translation templates 1 2 3 update relations defined q 4 j j simply reduce evaluation xyclique iterated evaluation stage instances step 2 sequential ascending order step 4 stage instance stratified modulo choice broken subcliques step 2 translated template 1 choicefree template 2 choice resulting relations step easily obtained collecting stage j relations p 0 translating corresponding p ie adding stage argument j example 7 let g2 extensional predicate representing edges graph consider following clique q corresponding transformed clique q partitioned exitrule r 0 subclique q 0 subclique g applying translation template 3 obtain 0 j 0 old old 0 0 1 3 old old 0 4 j j notice steps 2a 2b simplified wrt translation template 1 q 0 recursive iteration cycle useless indeed would reach saturation first step exit second one 5 optimization datalog queries systematic study query optimization techniques realizable basis concrete implementation iterated stable model procedure discussed previous section sketch repertoire ad hoc optimizations exploiting particular syntactic structure programs queries way use temporal arguments first observe computations translation template 3 never terminate obvious termination condition check relations computed two consecutive stages empty purpose translation template 3 modified inserting following instruction step 2 3 8p defined q general termination condition applicable deterministic cliques assumption external calls predicates clique specify particular stages ie external calls form case termination condition simplified follows 8p defined q forgetfulfixpoint computations many applications eg modeling updates active rules 25 10 queries issued reference final stage represents commit state database queries often exhibit form intended meaning find value x p final state p implies computing next stage forget preceding states last one see 26 ii stage pi x psi unique quit computation process query satisfied instance program example 7 query deltai x deltasi computes leaf nodes maximal depth breadthfirst visit graph rooted purpose evaluating query suffices keep track last computed stage ii exit current delta empty code program example 7 optimized replacing step 3 3 old old 0 ie dropping instructions record previous stages ii insert steps 2 3 instruction old another interesting case occurs answer query distributed along stages eg interested answer query ignores stage argument case collect partial answers via gathering predicate defined copyrule instance predicate example 7 collects nodes reachable query alli x allsi amenable described optimization equivalent query delta x contrary allow fore possibly modifying program copyrules predicate apply systematically space optimized forgetfulfixpoint deltafixpoint computations already mentioned presence copy rule example 7 effect copying tuples stage next one avoid useless space occupation maintaining stage modifications applied original relation order obtain actual version example rule represents modification hence effect indeed suffices keep track additions original database requested rule realized supplementary relation containing stage new tuples produced case replace copyrule deleterule form need simply keep track negative contribution due literal qx stored relation gamma obtained integrating j method particularly effective large relation illustrate point let us assume program example 7 modified adding new exit rule relation r extensional predicate resulting code following 0 j 0 old old 1 3 old old 0 4 j j way avoid construction relation ie replication relation r stage fact reconstructed fly needed step 2a sideeffect computations direct combination previous two techniques gives rise form sideeffect computation let us consider ex ample nondeterministic ordering array performed swapping step two elements violate ordering array 1 represented relation extension a1 1 ar0 stage nondeterministically select unordered pair x elements delete array atoms ari p1 x ari p2 ap pear add new atoms arsi p1 arsi p2 x representing swapped pair query allows forgetfulfixpoint computation particular stage selected query unique definition predicate ar composed deleterules addrules means step forget previously computed stages last ii avoid copying relation ar keeping track deletions additions per formed requested update immediately performed execution proposed program boils efficient iterative computation following nondeterministic pascallike program 9i ai 6 conclusions work reported paper concerning fixpointoperational semantics optimization logic database language non deterministic nonmonotonic reasoning constitutes starting point actual implemented sys tem project currently progress basis ldl system developed ucla plan incorporate proposed optimization ldl compiler purpose evaluating effective proposed optimizations realistic ldl programs ie whether yield better performance evaluating applicable proposed optimizations realistic ldl programs ie often applied experimenting integration proposed optimizations classical optimization techniques magicsets r towards theory declarative knowledge classificationbased methodology planning audit strategies fraud detection logic totally partially ordered plans deductive database approach temporal deductive databases stable model semantics logic programming programming non determinism deductive databases query answering non deterministic non monotonic logic databases deductive data model representing querying semistructured data experiences logicbased knowledge discovery support environment semantics expressive power non deterministic constructs deductive databases effective semantics temporal integration deduction induction mining supermarket sales data els programs efficient evaluation nonstratified programs transformation els logical framework active rules nondeterminism xystratification deductive databases italian logic language data knowledge bases every logic program natural stratification iterated fix point model modular stratification magic sets datalog program negation stable models nondeterminism logic programs negation principles database knowledgebase systems active database rules transaction conscious stable model se mantics negation aggregates recursive rules ldl tr ctr christos nomikos panos rondogiannis manolis gergatsoulis temporal stratification tests linear branchingtime deductive databases theoretical computer science v342 n23 p382415 7 september 2005 fosca giannotti giuseppe manco franco turini specifying mining algorithms iterative userdefined aggregates ieee transactions knowledge data engineering v16 n10 p12321246 october 2004
deterministic builtin pattern generation sequential circuits present new pattern generation approach deterministic builtin self testing bist sequential circuits approach based precomputed test sequences especially suited sequential circuits contain large number flipflops relatively controllable primary inputs circuits often encountered embedded cores filters digital signal processing difficult test require long test sequences show statistical encoding precomputed test sequences combined lowcost pattern decoding provide deterministic bist practical levels overhead optimal huffman codes nearoptimal comma codes especially useful test set encoding approach exploits recent advances automatic test pattern generation sequential circuits unlike bist schemes require access gatelevel model circuit test easily automated integrated design automation tools experimental results iscas 89 benchmark circuits show proposed method provides higher fault coverage pseudorandom testing shorter test application time low moderate hardware overhead b table 1 illustrates huffman code example test set td four unique patterns total eighty column 1 table 1 lists four patterns lists corresponding number occurrences fi pattern xi column 3 lists corresponding probability occurrence pi given fi jtdj finally column 4 gives corresponding huffman code unique pattern note common pattern x1 encoded single 0 bit ex1 0 ex1 codeword x1 since codeword appears prefix longer codeword prefixfree property sequence encoded test vectors treated serial bitstream decoding done soon last bit codeword read property essential since variablelength codewords cannot read memory words usual fashion huffman code illustrated table 1 con structedbygeneratingabinarytreehuffmantreewith table 1 test set encoding simple example test sequence test patterns unique occur probability huffman comma patterns rences occurrence codeword codeword 100 iyengar chakrabarty murray fig 2 example illustrating construction huffman code edges labeled either 0 1 illustrated fig 2 unique pattern xi table 1 associated leaf node tree initially consists unmarked nodes huffman coding procedure iteratively selects two nodes vi vj lowest probabilities occurrence marks generates parent node vij vi vj two nodes unique procedure arbitrarily chooses two nodes lowest probabilities edges vijvi vijvj labeled 0 1 0 1 labels chosen arbitrarily affect amount compression 18 node vij assigned probability occurrence pij pi c pj process continued one unmarked node left tree codeword exi obtained traversing path root huffman tree corresponding leaf node vi sequence 01 values edges path provides exi huffman coding procedure worst case complexity om2 log thus encoding donein reasonable time average number bits per patternplh average length codeword given lh imd1 wi pi wi length codeword corresponding test pattern xi average length codeword example therefore given lh 1 05625 c 2 01875 c 3 01875 c 3 00625 168 bits next compare huffman coding equallength coding let lh le average length codeword huffman coding equallength coding since huffman coding optimal clear lh lewe next show lh le certain conditions theorem 1 unique patterns probability occurrence number unique patterns power 2 lh le proof unique patterns td probability occurrence p 1m entropy htd imd1 pi log2 pi log2 bits equallength encoding le ddlog2 power le log2 equals entropy bound therefore l dle case theorem restated general form terms structure huffman tree theorem 2 huffman tree full binary tree lh le proof full binary tree k levels 2k 1 vertices 2k1 leaf vertices therefore huffman tree full binary tree leaf vertices must power 2 number levels must log c1 follows every pathfrom root leaf vertex length log unique patterns td probability occurrence power 2 huffman tree indeed full binary tree theorem 2 therefore implies theorem 1 note theorem 2 sufficient necessary lh equal le figure 3 shows huffman tree lh le 2 even though full binary tree practical implication theorem 1 huffman encoding less useful probabilities unique test patterns similar tends happen instance ratio number flipflops number primary inputs cut denoted section 4 low theorem 2 suggeststhatevenwhen ishigh theprobabilitydistri bution unique test patterns analyzed fig 3 example nonfull binary tree l le determine statistical encoding worthwhile ever cases analyzed high statistical encoding indeed effective comma codes although huffman codes provide optimal test set com pression always yield lowestcost decoder circuit therefore also employ nonoptimal code namely comma code often leads efficient decoder circuits comma code also prefixfree derives name fact contains terminating symbol eg 0 end codeword comma encoding procedure first sorts unique patterns decreasing order probability occurrence encodes first pattern ie probable pattern 0 second 10 third 110 procedure encodes pattern addinga1tothebeginning previous codeword codeword ith unique pattern xi thus given sequence 1 1s followed 0 comma codewords unique patterns example test set section 21 listed column 5 table 1 procedure complexity om log mand simpler huffman encoding procedure comma code also requires substantially simpler decoder dc huffman code since comma codeword essentially sequence 1s followed zero decoder needs maintain count number 1s received 0 signi fies end codeword 1s count mapped corresponding test pattern given test sequence td unique patterns probabilities occurrence p1 p2 pm apverage length comma codeword given lc imd1 ipi since code nonoptimal lc lh however comma code provides nearoptimal compression ie limm1lc lh 0 td satisfies certain properties hold typical test sequences large number repeated patterns first present condition comma codes nearoptimal property td required satisfy condition binary tree leaf nodes x1 x2xm skewed distance di xi root given di 1 deterministic builtin pattern generation 101 instance huffman tree fig 2 skewed binary tree four leaf nodes theorem 3 let p1 p2 pm probabilities occurrence unique patterns td let lh lc average length codewords huffman comma codes respectively huffman tree td skewed lc lh pm limm1lc lh 0 proofpif huffman tree td skepwed lh imd11 ipi c 1pm lc imd1 ipi therefore lc lh pm also know p1 p2 pm therefore 0 pm 1m implies limm1 pm 0 hence lc lh vanishingly small skewed huffman tree comma code nearoptimal next derive necessary sufficient condition td must satisfy order huffman tree skewed theorem 4 let p1 p2 pm probabilities occurrence unique patterns td huffman tree td skewed probabilities occurrence satisfy condition xm proof prove sufficiency theorem necessity proven similarly generate huffman tree patterns x1 x2xm td whose probabilities occurrence satisfy 2 let leaf node corresponding ith pattern vi two leaf nodes vm vm1 corresponding patterns xm xm1 lowest probabilities pm pm1 first selected parent node vmm1 probability pm c pm1 generatepd pm3 pm2 andfrom2 pm3 mkdm1 pkthus pm3 pm1 c pm therefore leaf node vm2 vmm1 two nodes lowest probabilities parent vmm1m2 probability pm c pm1 c pm2 generated similarly parent vmm1i generated nodes vi vmm1ic1i 2fm31g process terminates root vmm11 generated leaf node v1 vmm12 distance d1 v1 root therefore 1 similarly di 2f23m1g leaf nodes vm vm1 equidistant root iyengar chakrabarty murray since share common parent vmm1 thus dm 1 therefore di satisfies 1 2f12mg huffman tree skewed next determine relationship jtdj number unique patterns test set huffman tree skewed show jtdj must exponential huffman tree skewed property often satisfied deterministic test sets sequential circuits large number flipflops primary inputs theorem 5 let jtdj total number patterns number unique patterns td res pectively huffman tree td skewed denotes asymptotic lower bound sense f gm implies limm1 gfm d1 proof let f1 f2 fm numbers poccurrence unique patterns td jtdjd imd1 fi know fm1 fm 1 fm2 fm 1 2 fm3 fm1 c fm 2 sim ilarly fm4 3 fm5 5 lower bounds thus form fibponacci series 3 5i therefore jtdj1c imd1si si ith fibonacci termp given si p1pic1 ic1 1 1 c 5 1 1 5 5 21 om even m1 follows jtdjd162m proof odd similar comma codes nonoptimal always yield better compression equallength codes following theorem establishes sufficient condition comma codes perform worse equallength codes theorem 6 let p1 p2 pm probabilities occurrence unique patterns td 2dlog pm mmc2 1 lc le lc le average codeword length comma equallength coding proof know le ddlog2 lc p1 c 2p2 ccmpm since p1 p2 pmlc 12 pmmm c 1dlog2 theorem follows example test set s35932 obtained using gentest 86 pm 0012 2dlog me8687 00019 hence comma codingperforms worse equallength coding test set note theorem 6 provide necessary condition lc le fact easy construct data sets lc le even though pm 2dlog following theorem provides tighter con mmc1 dition comma codes perform worse equallength codes theorem 7 let p1 p2 pm probabilities occurrence unique patterns td let lc le average codeword length comma coding equallength coding let fi mini f ppici 1 proof first note pi fipic1 pfi2 pic2 fimi pm1i since lc imd1 ipiit follows lc fim1 pm c 2fim2 pm c 3fim3 pm c cm1fipm c mpm let e defined lc e 4 get 4 5 obtain fim1fimc21cm theorem follows 1 3 simplified pm fifim12mdlofig2m1e addition mini f ppici 1 g exceeds 2 ie table 2 huffman comma code words patterns test set s444 test occur probability huffman comma pattern rences occurrence codeword codeword every data pattern occurs twice often next mostfrequent data pattern replace fi by2in 3 obtain following simpler sufficient condition comma codes perform worse equallength codes corollary 1 let p1 p2 pm probabilities occurence unique patterns td let lc le average codeword length comma coding equallength codingiffidmini f ppici 1 g 2 dlog pm 2m12m2 lc le however skewing probability distribution property theorem 4 appears easy satisfy cases probabilities occurrence patterns typical case s444 test set shown table 2 section 3 decrease compression resulting use comma codes instead optimal huffman codes compress test sets given deterministic builtin pattern generation 103 lc lh pm theorem 3 extremely small practice s444 test set pm 00005lh 12121 therefore lc 12126 compression loss one bit therefore huffman comma codes efficiently encode sequential circuit test sets 3 tgc design section illustrate methods constructing employing statistical encoding precomputed test sequences illustrate steps involved encoding decoding test set s444 benchmark circuit example huffman coding first step encoding process identify unique patterns test set codeword developed unique pattern using huffman code construction method outlined section 2 huffman tree used construct codewords patterns s444 shown fig 4 unique test patterns corresponding codewords s444 listed table 2 original unencoded test set td contains 1881 test patterns 3 bits requires bits memory storage hand encoded test set 12121 bits per codeword hence requires 2280 bits memory therefore huffman encoding td leads 5959 saving storage order well contiguity test patterns preserved encoded test set te determined applying huffman encoding procedure tditis fig 4 huffman tree test set s444 104 iyengar chakrabarty murray fig 5 illustration proposed test application technique stored onchip read one bit time test application sequence generator sg fig 1 therefore rom stores te test patterns td obtained decoding using simple finitestate machine fsm 20 tablelookup based methods typically used software implementations huffman decoding inefficient onchip hardwareimplemented decoding decoder dc therefore sequential circuit unlike combinational fullscan circuits combinational decoder used 12 22 figure 5 outlines proposed test application scheme exploit prefixfree property huffman code thus patterns decoded immediately bits compressed data stream encountered next describe state diagram fsm decoder dc using s444 example figure 6 shows state transition diagram dc number states equal number nonleaf nodes corresponding huffman tree example huffman tree fig 4 seven nonleaf nodes hence corresponding fsm fig 6 seven statess1 s2s7 fsm receives singlebit input sg produces nbitwide test patterns well singlebit control output test vec control output enabled valid test pattern cut generated decoderthis happens whenever transition made state s1 use test vec signal ensures test sequence td preserved additional test patterns applied cut hence huffman codes provide efficient encoding test patterns fig 6 state transition diagram fsm decoder s444 straightforward decoding procedure used test application tradeoff involved increase test application time since decoder examines one bit clock cycle fortunately increase directly related amount test set compression achievedthe higher degree compression lesser impact theorem 8 test application time increases lh average length huffman codeword proof state transition diagram fig 6 shows wi clock cycles required apply test pattern xi mapped codeword wi bits hence test application time number clock cycles given id1 wi jtdj total number patterns test set td tphejttdejst application time therefore increases factor id1 wi jtdjdlh average length codeword experimental results test set compression section 4 show average length huffman codeword typical test sets less 2 implies increase test application time rarely exceeds 100 since test patterns applied bist environment increase testing time acceptable little impact testing cost test quality figure 7 shows netlist decoder circuit s444 circuit generated test set obtained using gentest design simplified considerably presence large number dontcares decoder specification design automation tool exploit optimization cost onchip decoder dc reduced noting possible share decoder chip among multiple cuts encoding problem reformulated encode test sets cuts together combining test sets obtain composite test set 0 applying encoding procedure 0 obtain encoded test set figure 8 illustrates single sequence generator sg0 pattern decoder dc0 used apply test sets multiple cuts number primary inputs note sharing pattern decoder also possible cuts unequal number primary inputs sharing however effi cient difference number primary inputs small slight increase size 0 com pared te offset hardware saving obtained deterministic builtin pattern generation 105 fig 7 gatelevel netlist fsm decoder s444 decoder sharing next present upper lower bounds huffman codeword length two test sets encoded jointly theorem 9 let td1 td2 test sets two cuts number primary inputs let td0 obtained combining td1 td2 let m1 n1l1 m2 n2l2 number unique pat terns total number patterns average huffman codeword length td1 td2 respectively let l0 average huffman codeword length 0 let m0 n0 defined m0 maxfm1 m2g addition let pi qi 1 m0 probability occurrence ith unique pattern fig 8 bist sequence generator decoder circuit used test multiple cuts 106 iyengar chakrabarty murray td1td2 log flmin 1 l n0 log2 fimax c ifimax largest value fi n1 pi c smallest value fl n1 pi c n2qi n0flpi n1 pi c n2qi proofhskip10ptwe use fact htd1 l1 htd1 htd2 entropies td1 td2 respec tively probability occurrence ith unique pattern td0 n1 pi c n2qi n0 entropy td0 therefore given ht log follows theorem statement therefore n0 l1 log2 fimax c n0 l2 log2 fimax log fimax therefore l0 n1l1 c n2l2 next prove lower bound theorem statement flmin note lower bound meaningful pi requiresthat td1 td2 set unique patterns therefore m0 m1 m2 therefore htd1 l11 htd2 l21 therefore l0 htd0 n1l1 c n2l2n0 log2 flmin 1 tighter lower bound l0 given following corollary theorem 9 corollary 2 let l1 htd1 c 1 l2 htd2 c 2 let flmin defined theorem 9 special case n1 n2 12 l1 cl2 log2 example let td1 td2 test sets two different cuts five primary inputs suppose contain unique patterns shown fig 9 n1 n2 probabilities occurrencepof patterns td1 td2 satisfy 2 therefore l1 i4d1 ipi c 4p5 125 similarly l2 131 theorem 9 fimax 058 flmin 35 since n1 n2 bounds l0 given 12 l1 c l2 log2 flmin 1 therefore 103 fig 9 unique patterns probabilities occurrence example illustrating theorem 9 l0 355 patterns 0 also satisfy 2 therefore l0 4 ip0 c4p0 133 clearly lies calculated bounds p0 probability occurrence pattern xi td0 experimental results test set encoding decoder overhead section 4 show indeed possible achieve high levels compression reducing decoder overhead significantly test sets two different cuts number primary inputs jointly encoded single decoder dc0 shared among comma coding next describe test set compression test application using comma encoding illustrate encoding decoding scheme using s444 example unique patterns test set first identified sorted decreasing order probability occur rence codewords generated patterns according comma code construction procedure described section 2 comma codewords generated unique patterns s444 test set listed table 2 probabilities occurrence test patterns shown table 2 clearly satisfy 2 theorem 3 therefore encoding nearoptimal comma encoded test set 12126 bits per codeword requires 2281 bits storage increase one bit optimally huffman encoded test set described section 3 hence reduction test set compression arising use comma codes instead huffman codes example 002 slight decrease test set compression due use comma code offset reduced complexity pattern decoder dc figure 10 illustrates pattern decoder s444 circuit test set decoder constructed using binary counter combinational logic maps counter states test patterns test application scheme fig 5 huffman decoder inverted input bit used generate test vec signal ensures cut clocked 0 received test vec also gated clock cut used reset counter falling edge clock bits value 1 received sg therefore result flip flops counter clocked next state 0s terminating commas present end deterministic builtin pattern generation 107 fig 10 comma pattern decoder s444 test set state half clock cyle test pattern thus latched cut counter reset comma decoders simpler implement huffman de coders binary counters already present normal operation used reduce overhead case huffman coding theorem 8 increase testing time due comma coding equals average length codeword runlength encoding finally describe runlength encoding statistically encoded test sequence te achieve compression exploit fact sequences identical test patterns runs common test sets sequential circuits high ratio flipflops primary inputs example test set s444 runs pattern 000 occur lengths 70 huffman comma encoding exploit large number repetitions patterns test sequence without directly making use fact many contiguous identical patterns runlength encoding exploits property test sequencesit therefore complements statistical encoding huffman comma encoding transform sequence test patterns compressed serial bit stream test set occurrence test pattern 000 replaced bya0table 2 therefore long runs 0s present statistically compressed bit stream 108 iyengar chakrabarty murray table 3 distribution runs huffman encoded test set s444 circuit runs runs run runlength 0s 1s length 0s 1s compressed using runlength coding runlength coding data compression technique replaces sequence identical symbols copy repeating symbol length se quence example run 5 0s 00000 encoded 05 0101 runlength encoding used recently reduce time download test sets ate across network 23 24 improve upon basic runlength encoding scheme considering runs substantial probability occurrence statistically encoded bit stream unique symbol representing run particular length corresponding bit stored value repeating bit generated bits representing length run decoding therefore obviate need store copy repeating bit describe runlength encoding process using s444 example analysis huffman encoded test set yields distribution runs shown table 3 encoding runs would obviously expensive 4 bits would required run since instances 04 05 13 instances 15 16 17 18 exist therefore use combinations 3 bits 000 001111 encode 8 frequently occurring runs01 02 03 07 08 11 12 14 less frequently occurring runs 04 05 06 13 divided smaller consecutive runs encoding example 05 encoded 03 followed 02 figure encoding applied portion huffman encoded s444 test set encoded runs stored rom output runlength decoder runlength decoder provides single bit every clock cycle huffman comma decoder test application runlength decoder consists binary counter small amount combinational logic figure 12 illustrates runlength decoder test set bits used encode run eg 011 07fig 11a first mapped runlength bits runlength loaded counter outputs first bit run counter counts preset value 110 000 sending bit 0 example huffman decoderineveryclockcycle whenthecounterreaches 000 gate output becomes 1 enabling rom output bits representing next run since one bit received huffman decoder every clock cycle runlength decoding add testing time 4 experimental results section present experimental results test set encoding several iscas 89 benchmark circuits demonstrate saving onchip storage achieved using huffman comma runlength encoding fig 11 runlength encoding applied portion huffman encoded s444 test set 3bit encoding 8 types runs b bit stream encoded c runlength encoded data fig 12 runlength decoder s444 test set consider circuits number flipflops f considerably greater number primary inputs n denote ratio fn table 4 lists values iscas 89 circuits circuits high value shown bold circuits especially hard test relatively large number internal states primary inputs table 4 table 4 ratio number flipflops number primary inputs jtdj length hitec test sequences iscas 89 circuits cut jtdj cut jtdj deterministic builtin pattern generation 109 see circuits typically require longer sequences test patterns hand excellent candidates encoding approach several iscas 89 benchmark circuits high value therefore suitable scanbased testing proposed approach encoding nonscan test sets present results circuits however statistical encoding fullscan test sets circuits lines proposed approach recently shown effective reducing amount memory required test storage 25 performed experiments test sets single stuck line ssl faults obtained gentest atpg program well hitec gatest test sets university illinois 26 measured fault coverage test sets using proofs fault simulator 27 ensured coverage comparable bestknown fault coverage circuits next present results compression achieved using huffman comma coding four test sets table 5 compares number bits required store encoded test set required store corresponding unencoded test set td number bits required scheme moderate substantially less required store unencoded test sets reduces significantly test set shared among multiple cuts type included chip corebased dsp circuits 14 saving sg memory presented table 5 substantial cases difference compression due use comma coding instead huffman coding small table 6 show compression achieved applying runlength coding te present results runlength encoding s382 s444 circuits using gentest test set test application time required considerably less required pseudorandom testing even though number clock cycles c greater number patterns td c lhjtdj huffman coding c lcjtdj comma coding table 7 compares number test patterns applied number clock cycles required fault coverage obtained method corresponding figures reported recently two pseudorandom testing schemes 5 6 test application time required method much less pseudorandom testing method 5 also achieve higher fault coverage circuits iyengar chakrabarty murray table 5 experimental results test set compression iscas 89 circuits high value average percentage codeword length compression iscas circuit nmjtdjtbits lh lc hbits cbits ce gentest gatest n primary inputs unique test patterns tbits total bits td hbits bits huffman encoding cbits bits comma encoding acomma coding applicable test set s35932 probabilities occurrence test patterns satisfy 2 given theorem 4 table 6 percentage compression achieved runlength coding applying huffman comma encoding td number bits percentage compression iscas circuit tbits hbits cbits hrbits crbits ce hre cre hrbits bits encoded test set huffman runlength encoding crbits bits encoded test set comma runlength encoding deterministic builtin pattern generation 111 table 7 number clock cycles c required fault coverage obtained using pseudorandom testing compared corresponding figures using precomputed deterministic test sets number patterns jtdj number clock cycles c fault coverage iscas circuit 5a 6a deta 5 6 det 5 6 detb a5 6 recently proposed pseudorandom bist methods det deterministic testing using precomputed test sets bthe best fault coverage achieved precomputed deterministic testing cresults circuits reported 5 6 table 8 literal counts huffman comma decoders four test sets decoder cost literals huffman decoders comma decoders iscas circuit gen hit gat strat gen hit gat strat 28 43 s400 44 33 33 37 26 27 27 27 s526 43 47 28 27 gen gentest hit hitec gat gatest strat strategate next present experimental results huffman comma decoder implementations designed synthesized fsm decoders using epoch cad tool cascade design automation 28 low moderate decoder costs table 8 show decoding algorithm easily implemented bist scheme note largest benchmark circuit s35932 requires extremely small overhead synthe sized rom area 053 cut area decoder area 618 cut area store encoded test set decoder thus demonstrating proposed approach scalable feasible incorporate encoded test set onchip larger circuits note huffman comma encoding reduce number bits stored serialization rom may increase hardware requirements rom address generation conventional fixedlength encoding scheme size counter required rom address generation dlog2 jtdje encoded rom requires dlog2jtdjlebit counter address generation l average codeword length however since l small logarithmic increase counter size also small eg size counter change s444 increases 7 10 s35932 hardware overhead figures table 8 include small increase counter size may argued specialpurpose minimal state fsm may used produce precomputed sequence however seen overhead fsms prohibitive especially long test sequences addition specialpurpose fsm wouldbespecifictoasinglecutontheotherhand decoder dc proposed scheme shared among multiple cuts thereby reducing overall tgc overhead table 9 compares overhead proposed deterministic bist scheme overhead pseudorandom bist method 6 several circuits overhead pseudorandom method obtained 112 iyengar chakrabarty murray table 9 literal counts proposed technique compared pseudorandom testing deterministic tgc cost pseudorandom number iscas 89 decoder total tgc cost test points circuit cost cost 6 6 s526 mapping gate count figures 6 literal counts standard cells epoch library deterministic tgc requires greater area pseudorandom tgcs difference quite small thus may acceptable higher fault coverage shorter test times required note also pseudorandom method requires addition large number observability test points require gatelevel model cut well additional primary outputs routing moreover may also increase size response monitor cut outputs proposed tgcs require circuit modification thus making applicable testing corebased designs using precomputed test sequences finally present experimental results test set compression decoder overhead using single decoder test several cuts chip table 10 shows levels compression obtained combined test sets comparable obtained individual test sets fact several cases overall compression higher obtained one individual test sets percentage area overhead required decoder reduces significantly single decoder shared among several cuts note case comma decoders major part overhead contributed binary coun ters example comma decoder pair head combinational logic represents overhead counter also used normal operation system bist overhead reduce test application technique therefore clearly scalable increasing circuit com plexity decoder overhead also tends decrease increase clearly demonstrates proposed test technique well suited circuits high 5 conclusion presented novel technique deterministic builtin pattern generation sequential circuits approach especially suited sequential circuits large number flipflops relatively table 10 percentage compression test sets encoded jointly percentage huffman compression percentage comma compression circuit gen hit gat strat gen hit gat strat table 11 decoder cost literals percentage decoder overhead single decoder shared among several cuts decoder cost literals percentage decoder overhead circuit gen hit gat strat gen hit gat strat fs382 s444g 48 52 44 44 672 729 618 621 28 deterministic builtin pattern generation 113 primary inputs circuits embedded 9 ms hsiao em rudnick jh patel alternating strate cores gatelevel models available gies sequential circuit atpg proc european design shown statistical encoding precomputed test conf 1996 pp 368374 10 tmniermannandjhpatel hitecatestgenerationpack test sequences leads effective compression thereby age sequential circuits proc european design automation allowingonchipstorageofencodedtestsequenceswe conf 1991 pp 214218 also shown average codeword length 11 dg saab yg saab ja abraham automatic test nonoptimal comma code nearly equal av vector cultivation sequential vlsi circuits using genetic erage codeword length optimal huffman code algorithms ieee trans computer aided design vol 15 pp 12781285 oct 1996 test sequence satisfies certain proeprties 12 k chakrabarty bt murray j liu zhu test generally satisfied test sequences typical sequen compression builtin self testing proc int test conf tial circuits therefore comma coding nearoptimal 1997 pp 328337 practice 13 f brglez bryan k kozminski combinational profiles results show huffman comma encod sequential benchmark circuits proc int symp circuits systems 1989 pp 19291934 ing test sequences followed runlength encoding 14 msb romdhane vk madisetti jw hines quick greatly reduce memory required test stor turnaround asic design vhdl corebased behavioral age small increase testing time offset synthesis kluwer academic publishers boston 1996 high degree test set compression achieved fur 15 jp hayes computer architecture organization 3rd ed thermore testing time considerably less mcgrawhill new york ny 1998 16 g held data compression techniques applications pseudorandom methods developed efficient hardwareandsoftwareconsiderations johnwiley chichester lowoverhead pattern decoding methods applying west sussex 1991 test patterns cut also shown 17 jakobssen huffman coding bitvector compression overhead reduced using sin information processing letters vol 7 6 pp 304307 oct gle decoder test multiple cuts chip 1978 18 tm cover ja thomas elements information theory proposed technique thus offers promising bist john wiley new york ny 1991 methodology complex nonscan partialscan 19 mansuripur introduction information theory prentice circuits precomputed test sets readily hall inc englewood cliffs nj 1987 available 20 v iyengar k chakrabarty efficient finitestate machine implementation huffman decoders information processing letters vol 64 6 pp 271275 jan 1998 21 dh greene de knuth mathematics analysis r reliable computing laboratory department electrical computer engineering university illinois urbanachampaign computeraided design vlsi circuits systems verification builtin self test krishnendu chakrabarty received b indian institute technology ph engineering duke university professor electrical computer engineering boston projects embedded core testing archival journals referred conference ieee sigma xi activities ieees test technology technical council tttc murray received albion college electrical engineering duke university michigan technical staff general motors research development led projects testing systems computer architecture adjunct lecturer university michigan since currently project manager dependable embedded systems tools system safety engineering currently serves editorial board journal electronic testing theory applications tr ctr chandra k chakrabarty efficient test data compression decompression systemonachip using internal scan chains golomb coding proceedings conference design automation test europe p145149 march 2001 munich germany anshuman chandra krishnendu chakrabarty test data compression test resource partitioning systemonachip using frequencydirected runlength fdr codes ieee transactions computers v52 n8 p10761088 august anshuman chandra krishnendu chakrabarty test resource partitioning socs ieee design test v18 n5 p8091 september 2001 michael j knieser francis g wolff chris papachristou daniel j weyer david r mcintyre technique high ratio lzw compression proceedings conference design automation test europe p10116 march 0307 ismet bayraktaroglu alex orailoglu concurrent application compaction compression test time data volume reduction scan designs ieee transactions computers v52 n11 p14801489 november touba test data compression using dictionaries selective entries fixedlength indices acm transactions design automation electronic systems todaes v8 n4 p470490 october anshuman chandra krishnendu chakrabarty analysis test application time test data compression methods based compression codes journal electronic testing theory applications v20 n2 p199212 april 2004
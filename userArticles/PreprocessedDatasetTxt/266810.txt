framework balancing control flow predication predicated execution promising architectural feature exploiting instructionlevel parallelism presence control flow compiling predicated execution involves converting program control flow conditional predicated instructions process known ifconversion order effectively apply ifconversion one must address two major issues ifconverted ifconversion applied compilers use predication representation effective large amounts code ifconverted ifconversion performed early compilation procedure hand final code generated processor predicated execution requires delicate balance control flow predication achieve efficient execution appropriate balance tightly coupled scheduling decisions detailed processor characteristics paper presents effective compilation framework allows compiler maximize benefits predication compiler representation delaying final balancing control flow predication schedule time b introduction performance modern processors becoming highly dependent ability execute multiple instructions per cy cle order realize performance potential processors demand increasing levels instructionlevel parallelism ilp exposed programs one major challenges increasing available ilp overcoming limitations imposed branch instructions ilp limited branches several reasons first branches impose control dependences often sequentialize execution surrounding instructions second uncertainty branch outcomes forces compiler hardware schedulers make conservative decisions branch prediction along speculative execution generally employed overcome limitations 12 however branch misprediction takes away significant portion potential performance gain third traditional techniques facilitate exploiting ilp along single trajectory control ability concurrently execute instructions multiple trajectories offers potential increase ilp large amounts finally branches often interfere complicate aggressive compiler transformations optimization scheduling predication model instruction execution conditions solely determined branches characteristic allows predication form basis many techniques deal branches effectively compilation execution codes provides benefits compiler representation ilp processors architectural feature predicated representation compiler naddress program representation instruction guarded boolean source operand whose value determines whether instruction executed nullified guarding boolean source operand referred predicate values predicate registers manipulated predefined set predicate defining instructions use predicates guard instruction execution reduce even completely eliminate need branch control dependences instructions control dependent branch predicated using condition branch branch legally removed process replacing branches appropriate predicate computations guards known ifconversion 34 predicated representation provides efficient useful model compiler optimization scheduling removal branches code transformed contain control dependences complex control flow transformations instead performed predication domain traditional straightline code optimizations way predicated representation allows scheduling among branches performed domain without control dependences removal control dependences increases scheduling scope affords new freedom scheduler 5 predicated execution architectural model supports direct execution predicated representation 678 respect conventional instruction set architecture new features additional boolean source operand guarding instruction set compare instructions used compute predicates predicated execution benefits directly advantages compilation using predicated representa tion addition removal branches yields performance benefits executed code notable removal branch misprediction penalties particular removal frequently mispredicted branches yields large performance gains 91011 predicated execution also provides efficient mechanism compiler overlap execution multiple control paths hardware manner processor performance may increased exploiting ilp across multiple program paths another subtle benefit predicated execution allows height reduction along single program path 12 supporting predicated execution introduces two compilation issues ifconverted compilation procedure ifconversion applied first question address ifconverted specifically branches removed via ifconversion traditionally full ifconversion led positive results compiling numerical applications 13 however nonnumeric applications selective ifconversion essential achieve performance gains 14 ifconversion works removing branches combining multiple paths control single path conditional instructions however two paths overlapped resultant path exhibit increased constraints original paths one important constraint resources paths combined together must share processor resources compiler responsibility managing available resources making ifconversion decisions appropriate stopping point may identified ifconversion result increase execution time paths involved discussed next section problem deciding ifconvert complicated many factors one resource consumption second question must addressed apply ifconversion compilation procedure broadest level ifconversion may applied early backend compilation procedure delayed occur conjunction scheduling applying ifconversion early enables full use predicate representation compiler facilitate ilp optimizations scheduling addition complex control flow transformations may recast data dependence domain make practical profitable examples transformations include branch reordering control height reduction 12 branch combining 15 hand delaying ifconversion late possible makes answering first question much practi cal since many ifconversion decisions tightly coupled scheduler knowledge processor characteris tics applying ifconversion schedule time natural choice also applying ifconversion scheduling alleviates need make entire compiler backend cognizant predicated representation effective compiler strategy predicated execution must address questions ifconversion purpose paper present flexible framework ifconversion ilp compilers framework enables compiler extract full benefits predicate representation applying aggressive ifconversion early compilation pro cedure novel mechanism called partial reverse ifconversion operates schedule time facilitate balancing amount control flow predication present generated code based characteristics target processor remainder paper organized follows section 2 details compilation issues challenges associated compiling predicated execution section 3 introduces proposed compilation framework facilitates taking full advantage predicate representation well achieving efficient balance branching predication final code essential component framework partial reverse ifconversion described detail section 4 effectiveness framework context prototype compiler ilp processors presented section 5 finally paper concludes section 6 compilation challenges effective use predicated execution provides difficult challenge ilp compilers predication offers potential large performance gains efficiently utilized however imbalance predication control flow generated code lead dramatic performance losses baseline compilation support predicated execution assumed paper hyperblock framework hyperblocks issues associated forming quality hyperblocks first summarized section remainder section focuses approach forming hyperblocks early compilation procedure using heuristics technique useful exposes predicate representation throughout backend optimization scheduling pro cess however approach several inherent weaknesses solving weaknesses motivation framework presented paper 21 background hyperblock structure created facilitate optimization scheduling predicated architectures 14 hyperblock set predicated basic blocks control may enter top may exit one locations hyperblocks formed applying tail duplication ifconversion set carefully selected paths inclusion path hyperblock done considering profitability profitability determined four pieces information resource utilization dependence height hazard presence execution frequency one gain insights effective hyperblock formation heuristics understanding characteristic lead performance loss common cause poor hyperblock formation excessive resource consumption resources required overlapping execution multiple paths union resources required individual path consider ifconverting simple ifthenelse statement resultant resource consumption hyperblock combination resources required separately execute else paths path alone consumes almost processor resources resultant hyperblock would require substantially resources processor available result hyperblock formation results significant slowdown paths course calculations account benefits gained ifconversion important point resource oversubscription potential negate benefits hyperblock formation even degrade performance poor hyperblocks may also formed carefully considering dependence height ifconversion hyperblock contains multiple paths complete constituent paths completed therefore overall height hyperblock maximum original paths dependence heights consider ifconversion simple ifthen else statement path height two else path height four height resultant hyperblock maximum paths four result path potentially slowed two times compiler must weigh negative potential positive effects ifconversion determine whether hyperblock profitable form another way poor hyperblocks may formed inclusion path hazard hazard instruction set instructions hinders efficient optimization scheduling control paths two common hazards subroutine calls unknown side effects store instructions little alias information hazards degrade performance force compiler make conservative decisions order ensure correctness reason inclusion control path hazard hyperblock generally reduces compilers effectiveness entire hyperblock path containing hazard execution frequency used measure paths importance also provides insight branch behavior information used weigh tradeoffs made combining execution paths example may wise penalize infrequently executing path combining longer frequently executing path removing branch joining two 22 pitfalls hyperblock selection original approach used impact compiler support predicated execution form hyperblocks using heuristics based four metrics described previous section hyperblocks formed early backend compilation procedure expose predicate representation throughout backend compilation phases heuristic hyperblock formation shown perform well relatively regular machine models machines balancing resource consumption balancing dependence height eliminating hazards done effectively carefully crafted heuristics however experience shows several serious problems exist difficult solve approach three problems presented optimizations change code characteristics unpredictable resource interfer ence partial path inclusion optimization first problem occurs code may transformed hyperblock formation general forming hyperblocks early facilitates optimization techniques take advantage predicate representation however hyperblock formation decisions change dramatically compiler trans formations convert seemingly bad formation decision good one likewise convert seemingly good formation decision bad one figure 1a shows simple hammock considered conversion 1 taken path dependence height three cycles consumes three instruction slots ifconversion removed instruction 5 fallthrough path consists depen 1 code examples presented section simple machine model used schedules three issue processor unit latencies resource limitations processor assumed specified example assumptions reflect machine model latencies used experimental evaluation section 528 1 b 1 branch cond 2 jump figure 1 hyperblock formation seemingly incompatible paths positive results due code transformations f annotations indicate taken fallthrough path conditional branch r2 referenced outside block dence height six cycles resource consumption six instruction slots simple estimate indicates combining paths would result penalty taken path three cycles due fallthrough paths large dependence height figure 1b shows code segment hyperblock formation optimizations first optimization performed renaming eliminate false dependences 7 8 8 10 reduced dependence height hyperblock three cycles heuristic could foresee dependence height would longer issue may still choose form hyperblock due resource considerations estimate ten instructions ifconversion could made inspecting figure 1a un fortunately ten instructions needs least four cycles complete three issue machine would still penalize taken path one cycle indicating combination paths may beneficial instruction merging optimization instructions 2 6 combined 4 11 combined instruction count becomes eight final schedule consists three cycles figure 1 shows even simple cases heuristic forms hyperblocks optimizations must anticipate effectiveness optimizations order form profitable hyperblocks example optimizations could potentially done hyperblock formation renaming however others like instruction merging could addition optimizations may applied differently performed ifconversion different code characteristics result different tradeoffs resource interference second problem heuristic hyperblock formation false conclusions regarding resource compatibility candidate paths may often reached result paths seem compatible ifconversion turn incompatible problem arises resource usage estimation techniques simple ones used section even complex techniques generally assume 1 branch cond 2 jump a2 b figure 2 hyperblock formation seemingly compatible paths results performance loss due resource incompatibility resource usage evenly distributed across block prac tice however paths exhibit uniform resource utilization interactions dependence height resource consumption cause violations uniform utilization assumption gen eral paths subdivided sections either relatively parallel relatively sequential parallel sections demand large number resources sequential sections require resources two paths combined resource interference may occur parallel sections paths overlap sections demand resources likely larger available resources resulting performance loss illustrate problem consider example figure 2 processor assumed example three issue one memory instruction may issued cycle original code segment figure 2a consists two paths dependence heights three cycles resource consumption path also identical four instructions paths concluded good candidates ifconversion figure 2b shows hyperblock resulting schedule since obvious resource shortages one would expect resultant schedule hyperblock identical length schedules individual path four cycles however hyperblock schedule length turns six cycles increase due resource interference paths path parallel start sequential end addition parallel sections paths high demand memory resource one memory resource available paths sequentialized parallel sections note requirements memory resource uniformly distributed across paths problem would exist individual schedule lengths four cycles total four memory instructions however due characteristics paths resource interference results performance loss paths selected hyperblock 1 2 f branch r1 r10 jump c a2 1 jump b figure 3 efficient hyperblock formed inclusion partial path partial paths final problem current heuristic hyperblock formation paths may subdivided considered inclusion hyperblock many cases including part path may beneficial including excluding entire path ifconversion referred partial ifconversion partial ifconversion generally effective resource consumption dependence height entire candidate path large permit profitable ifconversion performance gain overlapping part candidate path paths selected inclusion hyperblock illustrate effectiveness partial ifconversion consider example figure 3 three issue processor assumed example resource limitations issue width figure 3a shows two paths compatible due mismatched dependence height however including taken path four instructions fallthrough path efficient hyperblock created hyperblock shown figure 3b notice branch instruction 2 split two instructions condition computation labeled 2 0 branch based computation labeled 2 00 schedule benefit complete removal branch instruction 2 branch instruction 2 00 characteristics orig inal however schedule benefit partial overlap paths destination branch instruction 2 00 contains code complete fallthrough path shown figure 3c theory hyperblock formation heuristics may extended support partial paths since path could divided instruction path heuristics would consider many possible selection alternatives however feasibility extending selection heuristics operate finer granularity instructions rather whole paths questionable due complex nature problem 3 proposed compilation framework compilation predicated execution challenging described section 2 create efficient code delicate balance control flow predication must created desired balance highly dependent final code characteristics resource characteristics target processor effective compilation framework predicated execution must provide structure making intelligent tradeoffs control flow predication desired balance achieved given difficulties presented section 22 forming hyperblocks early backend compilation process seemingly natural strategy perform ifconversion conjunction instruction scheduling achieved integrating ifconversion within scheduling process scheduler accurately models detailed resource constraints processor also understands performance characteristics code therefore scheduler ideally suited make intelligent ifconversion decisions addition compiler optimizations usually complete scheduling reached thus problem code changing ifconversion exist however serious problem associated performing ifconversion scheduling time restriction com pilers use predicate representation perform control flow transformations predicate specific optimizations scheduletime framework introduction predicate representation delayed schedule time result transformations targeted predicate representation must either foregone delayed transformations delayed much complexity added scheduler must already consider many issues including control speculation data speculation register pressure achieve desirable code performance ad ditionally delaying optimizations schedule time creates phase ordering cause severe difficulties compiler generally transforms profound effects one another must repeatedly applied turn achieve desirable results example transformation control height reduction 12 may subsequently expose critical data dependence edge broken expression reformu lation however control dependence height reduced profitability breaking data dependence edge compiler apply transform especially true since expression reformulation cost terms added structions net result scheduletime framework restriction use predicate representation limits effectiveness backend optimizations given ifconversion schedule time limits use predicate representation optimization given ifconversion early stage limited ability estimate final code characteristics logical look alternative compilation framework paper proposes frame work framework overcomes limitations schemes utilizing two phases predicated code manipulation support predicated execution aggressive ifconversion applied early compilation phase create predicate representation allow flexible application predicate optimizations throughout backend compilation procedure sched classical optimizations classical optimizations optimizations ilp optimizations register allocataion postpass scheduling partial reverse ifconversion integrated prepass scheduling aggressive hyperblock formation figure 4 phase ordering diagram compilation framework ule time compiler adjusts final amount predication efficiently match target architecture compilation frame work shown figure 4 consists two phases predicate manipulation surrounding classical predicate specific ilp op timizations first predicate manipulation phase hyperblock formation addressed thoroughly 14 second predicate manipulation phase adjustment hyperblocks scheduling proposed work termed partial reverse ifconversion first phase compilation framework aggressively perform hyperblock formation hyperblock former need exactly compute paths parts paths fit available resources completely compatible instead forms hyperblocks larger target architecture handle large hyperblocks increase scope optimization scheduling enhancing benefits many cases hyperblock former include almost paths generally aggressive decision resource height dependence height resulting hyperblock likely much greater corresponding heights component paths however ifconverter relies later compilation phases ensure hyperblock efficient one criteria still enforced first phase hyperblock formation avoiding paths haz ards discussed section 2 hazards reduce com pilers effectiveness entire hyperblock thus avoided facilitate aggressive optimization second phase compilation framework adjust amount predicated code hyperblock code scheduled via partial reverse ifconversion partial reverse ifconversion conceptually application reverse ifconversion particular predicate hyperblock chosen set instructions 16 reverse ifconversion originally proposed inverse process ifconversion branching code contains predicates generated block predicated code allows code compiled using predicate representation executed processor without support predicated execution scheduler partial reverse ifconversion operates identifying paths composing hyperblock paths profitable overlap remain unchanged conversely path interacts poorly paths removed hyper block particular partial reverse ifconverter decides eject certain paths parts paths enhance schedule reverse ifconverter insert branch taken whenever removed paths would executed effect dividing lower portion hyperblock two parts corresponding taken fallthrough paths inserted branch decision reverse ifconvert particular path consists three steps first partial reverse ifconverter determines savings execution time inserting control flow applying full resources machine two hyperblocks instead one second computes loss created penalty associated insertion branch finally gain reverse ifconversion exceeds cost ap plied partial reverse ifconversion may repeatedly applied hyperblock resulting code desirable strategy used compilation framework viewed analogously use virtual registers many compil ers virtual registers program variables promoted memory reside infinite space virtual registers early compilation procedure virtual register domain provides effective internal representation memory operations compiler transformations result compiler able perform effective optimization scheduling virtual register code schedule time virtual registers assigned limited set physical registers memory operations reintroduced spill code number physical registers oversubscribed framework presented paper branches virtual registers program variables branches removed provide effective internal representation compiler transformations schedule time branches inserted according capabilities target processor branches reinserted different conditions targets predictability branches originally removed result branches code benefit performance particular processor rather consequence code structure decisions made programmer key making predication control flow balancing framework effective partial reverse ifconverter mechanics performing partial reverse ifconversion well proposed policy used guide partial reverse ifconversion presented next section 4 partial reverse ifconversion partial reverse ifconversion process consists three components analysis transformation decision steps discussed turn 41 analysis manipulation analysis execution paths performed paths must identified predicated code execution paths predicated code referred predicate paths immediately hyperblock formation structure predicate paths identical control flow graph 2 1000000111111111111 000000000000111111000000000000111111000000000000000000000011111111111000000000000000000000011111111111 2 b figure 5 predicate flow graph partial dead code elimination given r3 r4 live region code hyperblock formation structure predicate paths represented form called predicate flow graph pfg predicate flow graph simply control flow graph cfg predicate execution paths also repre sented optimizations structure pfg change dramatically reasons efficiency complexity compiler used work maintain pfg across opti mizations instead generated resulting predicated naddress code synthesis pfg predicated naddress code analogous creating cfg naddress code simple example presented provide insight done figure 5 shows predicated code segment predicate flow graph predicate flow graph shown figure 5b created following manner first instruction figure 5a predicate definition definition p1 assume true falsea path created possibilities complement p1 p2 shares paths independently create new conditional outcomes predicate defining instruction 2 also creates another path case predicates p3 p4 true p1 true defining instructions predicated p1 one path cre ated creation paths determined interrelations predicates provided mechanisms addressed work 1718 rest instructions paths contain instructions determined predicate guarding execution example instruction 3 based predicate p1 therefore placed paths p1 true instruction 4 predicated therefore exists paths type predicate defines used figures paper un conditional meaning always write value 8 since value regardless predicate predicate ignored instructions destinations must placed paths paths pfg merged predicate longer used affect predicate later code however merging paths may sufficient solve 1 jump b 2 figure flow graph partial reverse ifconversion predicate p1 located instructions 1 2 b potential path explosion problems pfg number paths pfg exponentially proportional number independent predicates whose live ranges overlap fortunately happen practice code schedul ing code scheduling complete pfg large number paths may costly description partial reverse ifconverter overcomes problem located section 42 general solution path explosion problem aspects predicate code analysis currently constructed authors pfg compiler information necessary know instructions exist paths figure 5 path p1 p3 true extracted instructions would placed path would 3 4 7 instructions remain two paths seem 3 4 5 6 however inspection dataflow characteristics remaining paths reveals results instructions 3 4 used given r3 r4 live region fact makes instructions dead code context paths performing traditional dead code removal pfg instead cfg determines parts operations dead since application dead code removal indicates instructions dead certain predicate conditions process termed predicate partial dead code removal related types partial dead code removal 19 result partial dead code removal indicates instructions 3 4 would generate correct code would execute unnecessarily predicated p3 point paths identified unnecessary code removed partial dead code removal analysis possible ejection paths becomes possible 42 transformation predicate analysis partial dead code elimination completed performing reverse ifconversion point predicate requires small amount additional processing processing determines whether instruction belongs original hyperblock new block formed figure 7 simple code size reduction multiple partial reverse ifconversions applied unrolled loop square represents unroll original loop verse ifconversion figure 6 used aid discussion partial reverse ifconverted code subdivided three code segments code reverse converting branch code ejected hyperblock reverse ifconversion code remains hyperblock reverse ifconverting branch instructions location partial reverse ifconverting branch left untouched hyperblock figure 6b shows partial reverse ifconversion created p1 instructions 1 2 means instructions 1 2 left originally scheduled location reverse ifconverting branch predicated p1 scheduled immediately following location instructions branch determined pfg use pfg without experiencing path explosion problem pfgs generated scheduling done respect predicate reverse ifconverted keeps number paths control since single predicate pfg contain two paths figure 6a shows pfg created predicate reverse ifconverted p1 note partial dead code already removed described previous section instructions exist solely p1 false path 5 6 remain original block instructions exist solely p1 true path 3 4 7 moved original block newly formed region instruction exists paths must placed regions notice hyperblock conditionally jumps code removed hyperblock branch code back original hyperblock possible implemented work branching back hyperblock would violate hyperblock semantics since would longer single entry region violating hyperblock semantics may problematic since benefits hyperblock already realized optimizer prepass scheduler however postpass hyperblock scheduler may experience reduced scheduling freedom since reentries hyperblock effectively divide original hyperblock two smaller hyperblocks advantage branching back original hyperblock large reduction code size elimination unnecessarily duplicated instructions however shown experimental section code size generally problem one code size optimization performed merges targets partial reverse ifconversion branches target blocks identical resulted large code size reduction codes loop unrolling performed loop unrolled hyperblock needed reverse ifconverted likely iterations needed reverse ifconverted creates many identical copies loop body subsequent loop reverse ifconverted figure 7a shows original result repeated reverse ifconversions unrolled loop figure 7b shows result obtained combining identical targets simple method works well reducing code growth eliminate unnecessary code growth remove unnecessary code growth method jumps back hyperblock opportune location needs created 43 policy creating predicate flow graph removing partial dead code identity characteristics paths hyperblock known information compiler make decisions transformations perform decision process partial reverse ifconversion consists two parts deciding predicates reverse ifconvert deciding reverse ifconvert selected predicates determine optimal reverse ifconversion given architecture compiler could exhaustively try every possible reverse ifconversion compute optimal cycle count possibility choose one best performance unfortunately enormous number possible reverse ifconversions given hy perblock consider hyperblock p predicates n instruc tions hyperblock 2 p combinations predicates chosen reverse ifconversion reverse ifconversions locate branch n locations worst case given possibilities must scheduled measure cycle count prohibitively expensive obvi ously heuristic needed many heuristics may perform effective reverse ifconversions one studied paper heuristic may best solution applications machine models studied work achieves desirable balance final code performance implementation complexity compile time process choosing heuristic perform partial reverse ifconversion affected greatly type scheduler used since partial reverse ifconversion integrated prepass scheduler type information provided scheduler structure code various points scheduling process must matched decision ifconvert operationbased scheduler may yield one type heuristic list scheduler may yield another policy determining reverse ifconvert presented designed work within context existing list scheduler algorithm policy integrated list scheduler shown figure 8 first decision addressed proposed heuristic place predicate selected reverse ifconversion location shown generally effective rest number locations considered reverse ifconversion reduced n 1 obvious improve ment location exists assumption reverse ifconverting branch consumes resources code scheduled perfect scheduler shown number operations trip loop new cycle 6 num unsched 0 handle reverse ifconverting branches first 7 foreach ric op ric queue 8 schedule opric op cycle 9 compute location unscheduled op sched ric taken compute dynamic cycles ric taken path sched ric cycles ric hyperblock mipred ric estimate ric mispreds miss penalty 13 ric cycles sched ric hb sched ric taken 14 ric cycles ric cycles mispred ric sched ric ric cycles sched ric hb 17 place ops ric schedule location 19 unschedule opric op remove ric op ric queue handle regular operations 22 schedule opregular op cycle remove regular op ready priority queue 26 add reverse ifconverting branch ric queue figure 8 algorithm incorporating partial reverse ifconversion list scheduler better placement first cycle value predicate reverse ifconverted available predicate defining instruction 2 since insertion branch misprediction taken penalty regardless location effects favor one location another however location reverse ifconverting branch determine early paths sharing resources separated given full machine bandwidth perfect scheduler always well better full bandwidth machine divided among fewer instructions given earlier paths separated fewer number instructions competing machine resources therefore best schedule occur reverse ifconverting branch placed early possible despite fact placing reverse ifconverting branch early possible heuristic two assumptions made perfect scheduler cost reverse ifconverting branch valid general seems reason able however heuristic would well despite imperfections another consideration code size since instructions existing multiple paths must duplicated paths seperated code size reduced reverse ifconverting branch delayed depending characteristics exist machines placement branch number cycles computation condition removes mispredictions 20 machines two locations considered immediately predicate defining instruction cycle branch mispredictions eliminated code delay may cost small cost may less gain obtained reduction code size despite considerations placement partial reverse ifconverting branch early possible reasonable choice second decision addressed heuristic reverse ifconvert without heuristic number reverse conversions would need considered heuristic described 2 p way optimally determine combination reverse ifconversions yields best results try reverse ifconversion one predicate affect effectiveness reverse ifconversions interaction among predicates caused changes code char acteristecs reverse ifconversion removed instructions hyperblock context list scheduler logical heuristic consider potential reverse ifconversion topdown fashion order predicate defines scheduled heuristic used algorithm shown figure 8 desirable effect making reverse ifconversion process fit seemlessly list scheduler also desirable reverse ifconversion considered context decisions made earlier scheduling process order make decision reverse ifconversion method evaluate must employed prospective reverse ifconversion three schedules must considered code schedule without reverse ifconversion code schedule hyperblock reverse ifconverting branch inserted paths excluded code schedule paths excluded reverse ifconversion together yield total 3p schedules given hyperblock three schedules needs compared determine reverse ifconversion prof itable comparison written sched cyclesno ric sched cycles ric hb sched cycles ric taken miss penalty sched cyclesno ric number dynamic cycles schedule without reverse ifconversion ap plied sched cycles ric hb number dynamic cycles schedule transformed hyperblock sched cycles ric taken number dynamic cycles target reverse ifconversion mispredric number mispredictions introduced reverse ifconversion branch mispredric obtained profiling static estimates miss penalty branch misprediction penalty comparision computed lines 9 15 figure 8 cost savings due heuristic quite significant 3p schedules complicated machine models still quite costly reduce cost possible reuse information gathered one schedule later schedule first source reuse derived topdown property list scheduler point reverse ifconversion considered previous instructions scheduled final location lines 8 22 figure 8 performing scheduling reverse ifconversion original scenario needs start point number schedules still 3p number instructions schedule greatly reduced removal instructions already scheduled second source reuse takes advantage fact case reverse ifconversion done schedule already computed time previous predicate considered reverse ifconversion schedule computed outcome since resulting code schedule cycles already known computation necessary current predicates sched cyclesno ric source reuse takes total schedules computed 2p schedule considering unscheduled instructions point due list scheduling effect reuse implemented figure 8 lines 5 16 another way reduce total number instructions scheduled take advantage fact code purged block different else blocks control equivalent split join blocks scheduler completely scheduled else parts scheduling necessary since remaining schedules likely similar differences may dangling latencies small differences available resources boundary accurate schedules continue become identical likely occur point though guaranteed occur cases additional use detection point code size reduction point logical location branch ejected block back original hyperblock schedule reuse reduction techniques shown number times instruction scheduled usually 1 instructions depth hammock predication domain depth number predicates defined chain used compute instructions guarding predicate cost scheduling still high estimates may used stead many types scheduling estimates proposed found literature many may well machines regular structures others possible create hybrid schedulerestimator may balance good estimates compile time cost mentioned previously schedule height two paths hammock must obtained instead purely scheduling paths may costly estimating paths may inac curate part schedule part estimate may obtain accurate results lower cost context list scheduler one solution following scheduler could schedule initial set operations estimate schedule remain ing accurate results obtained scheduled portion addition estimate may able benefit information obtained schedule characteristics scheduled code may likely match characteristics code estimated experiments presented next section actual schedules used decision reverse ifconvert additional compile time acceptable 5 experimental results section presents experimental evaluation partial reverse ifconversion framework 51 methodology partial reverse ifconversion techniques described paper implemented second generation instruction scheduler impact compiler compiler utilizes machine description file generate code parameterized superscalar processor measure effectiveness partial reverse ifconversion technique machine model similar many current processors chosen machine modeled 4issue superscalar processor inorder execution contains two integer alus two memory ports one floating point alu one branch unit instruction latencies assumed match hp pa7100 microprocessor instruction set contains set nontrapping versions potentially excepting instruc tions exception branch store instructions support aggressive speculative execution instruction set also contains support predication similar provided playdoh architecture 8 execution time benchmark derived static code schedule weighted dynamic execution frequencies obtained profiling static branch prediction based profiling also utilized previous experience method run time estimation demonstrated accurately estimates simulations equivalent machine perfect caches benchmarks used experiment consist 14 nonnumeric programs six spec cint92 benchmarks 008espresso 022li 023eqntott 026compress 072sc 085cc1 two spec cint95 benchmarks 132ijpeg 134perl six unix utilities cccp cmp eqn grep wc yacc 52 results figures compare performance traditional hyperblock compilation framework new compilation framework partial reverse ifconversion hyperblocks formed graphs represent currently formed impact compilers hyperblock formation heuristic target machine hyperblocks also used input partial reverse ifconverter results obtained therefore conservative since aggressive hyperblocks would create potential better results bars represent speedup achieved methods relative superblock compilation computed follows superblock cyclestechnique cycles superblock compilation performance chosen base represents best possible performance currently obtainable impact compiler without predication 21 figure 9 shows performance hyperblock partial reverse ifconversion compilation frameworks assuming perfect branch prediction since branch mispredictions factored benchmarks exhibiting performance improvement graph show predication performed well compilation model particular compiler successfully overlapped execution multiple paths control increase ilp hyperblock compilation achieves speedup half benchmarks notably 023eqntott cmp 072sc grep wc programs hyperblock techniques successfully overcome problem superblock techniques fully utilizing processor resources hand hyperblock compilation results performance loss half benchmarks dichotomy common problem experienced hyperblocks indicates hyperblocks well often performance victim poor hyperblock selection cases partial reverse ifconversion improved upon 40 20 0 20 40 80 100 008espresso 022li 023eqntott 026compress 072sc 085cc1 132ijpeg 134perl cccp cmp eqn grep wc yacc benchmark hyperblock framework partial ric framework figure 9 performance increase superblock exhibited hyperblock partial reverse ifconversion frameworks misprediction penalty 40 20 0 20 40 80 100 008espresso 022li 023eqntott 026compress 072sc 085cc1 132ijpeg 134perl cccp cmp eqn grep wc yacc benchmark hyperblock framework partial ric framework figure 10 performance increase superblock exhibited hyperblock partial reverse ifconversion frameworks four cycle misprediction penalty matched performance hyperblock code six benchmarks partial reverse ifconversion able change loss performance hyperblock compilation gain evident 008espresso 28 loss converted 39 gain 072sc 134perl cccp partial reverse ifconversion able significantly magnify relatively small gains achieved hyperblock compilation results indicate partial reverse ifconverter successful undoing many poor hyperblock formation decisions capitalizing effective ones four benchmarks hyperblock techniques highly effective 023eqntott cmp grep wc partial reverse ifconversion large opportunity increase performance since hyperblock formation heuristics worked well deciding ifconvert useful examine performance two benchmarks closely worst performing benchmark 085cc1 frameworks result performance loss respect superblock compilation partial reverse ifconversion completely successful undoing bad hyperblock formation decisions failure due policy requires list scheduler decide location reverse ifconverting branch placement predicate defining instruction un fortunately list scheduler may delay instruction may critical path often deemed low scheduling priority delaying reverse ifconversion point negative effect code performance extent problem occurs benchmarks evident 085cc1 one best performing benchmarks 072sc program hyperblock compilation increased performance fair margin partial reverse ifconversion increased gain substantially 072scs performance gain achieved transforming single function update function superblock compilation executes 256 million cycles ever schedule rather sparse due large number data control dependences hyperblock compilation increases available ilp eliminating large fraction branches overlapping execution multiple paths control brings execution time 197 million cycles hyperblock code much better superblock code excess resource consumption paths penalizes paths partial reverse ifconverter able adjust amount ifconversion match available resources efficiently utilize processor result execution time update function reduced 168 million cycles partial reverse ifconversion 52 performance improvement superblock code figure shows performance benchmarks manner figure 9 except branch misprediction penalty four cycles general relative performance hyperblock code increased mispredicts considered fewest mispredictions relative performance partial reverse ifconversion code also increased fewer mispredictions superblock code partial reverse ifconversion inserts new branches accomplish transformation code contains mispredictions hyperblock code several benchmarks number mispredictions actually larger hyperblock partial reverse ifconversion superblock applying control flow transformations predicated repre sentation branch combining compiler actually create branches much higher mispredict rates moved additionally branches created partial reverse ifconversion may unbiased combination branches original superblock represent static code size exhibited using hyperblock partial reverse ifconversion compilation frameworks respect superblock techniques presented figure 11 fig ure use predicated execution compiler varying effects code size reason behavior tradeoff increased code size caused ifconversion decreased code size due less tail duplication superblocks tail duplication performed extensively customize individual execution paths whereas predication multiple paths overlapped via ifconversion less tail duplication required figure also shows code produced partial reverse ifconversion framework consistently larger hyper block average partial reverse ifconversion code 14 larger hyperblock code largest growth occurring yacc common benchmarks exhibit 40 30 20 10 0 10 20 30 40 50 008espresso 022li 023eqntott 026compress 072sc 085cc1 132ijpeg 134perl cccp cmp eqn grep wc yacc benchmark code growth hyperblock framework partial ric framework figure 11 relative static code size exhibited hyperblock partial reverse ifconversion frameworks compared superblock benchmark reverse ifconversions opportunities 43 443 026compress 11 56 132ijpeg 134 1021 134perl 42 401 cccp 77 1046 table 1 application frequency partial reverse ifconversion large code growth failure simple code size reduction mechanism presented earlier inspection resulting code indicates many instructions shared lower portion tailduplications created partial reverse ifconverter reason one expect benchmarks respond well sophisticated code size reduction scheme finally frequency partial reverse ifconversions performed generate performance data presented table 1 reverse ifconversions column specifies actual number reverse ifconversions occurred across entire benchmark opportunities column specifies number reverse ifconversions could potentially oc curred number opportunities equivalent number unique predicate definitions application since predicate define reverse ifconverted exactly data table static counts table shows number reverse ifconversions occur relatively small fraction opportunities behavior desirable reverse converter try minimize number branches inserts achieve desired removal instructions hy perblock addition reverse ifconverter invoked performance problem exists cases performance original hyperblock cannot improved reverse ifconversions need performed table also shows expected correlation large numbers reverse ifconversions larger code size increases partial reverse ifconversion hyperblock figure 11 6 conclusion paper presented effective framework compiling applications architectures support predicated execution framework consists two major parts first aggressive ifconversion applied early compilation process enables compiler take full advantage predicate representation apply aggressive ilp optimizations control flow transformations second component framework applying partial reverse ifconversion schedule time delays final ifconversion decisions point compilation relevant information code content processor resource utilization known first generation partial reverse ifconverter implemented effectiveness framework measured paper framework able capitalize benefits predication without subject sometimes negative side effects overaggressive hyperblock formation furthermore additional opportunities performance improvement exploited framework partial path ifconversion points demonstrated hyperblock performance losses converted performance gains moderate gains magnified expect continuing development partial reverse ifconverter surrounding scheduling infrastructure enhance performance addition framework provides important mechanism undo negative effects overly aggressive transformations schedule time backup mechanism unique opportunities introduced aggressive use transformation predicate representation early compilation process acknowledgments authors would like thank john gyllenhaal teresa johnson brian deitrich daniel connors john sias kevin crozier members impact compiler team support comments suggestions research supported national science foundation nsf grant ccr9629948 intel corporation advanced micro de vices hewlettpackard sun microsystems ncr additional support provided intel foundation fellowship r study branch prediction strategies twolevel adaptive training branch predic tion conversion control dependence data dependence predicated execution modulo scheduling isomorphic control trans formations highly concurrent scalar processing cydra 5 departmental supercomputer hpl playdoh architecture specification version 10 guarded execution branch prediction dynamic ilp processors characterizing impact predicated execution branch prediction effects predicated execution branch pre diction height reduction control recurrences ilp processors overlapped loop support cydra 5 effective compiler support predicated execution using hyperblock comparison full partial predicated execution support ilp processors reverse conversion analysis techniques predicated code global predicate analysis application register allocation partial dead code elimina tion ar chitectural support compilersynthesized dynamic branch prediction strategies rationale initial results superblock effective technique vliw superscalar compilation tr highly concurrent scalar processing cydra 5 departmental supercomputer overlapped loop support cydra 5 twolevel adaptive training branch prediction effective compiler support predicated execution using hyperblock reverse ifconversion superblock partial dead code elimination guarded execution branch prediction dynamic ilp processors height reduction control recurrences ilp processors effects predicated execution branch prediction characterizing impact predicated execution branch prediction modulo scheduling isomorphic control transformations comparison full partial predicated execution support ilp processors analysis techniques predicated code global predicate analysis application register allocation conversion control dependence data dependence study branch prediction strategies architectural support compilersynthesized dynamic branch prediction strategies ctr hyesoon kim jos joao onur mutlu yale n patt profileassisted compiler support dynamic predication divergemerge processors proceedings international symposium code generation optimization p367378 march 1114 2007 walter lee rajeev barua matthew frank devabhaktuni srikrishna jonathan babb vivek sarkar saman amarasinghe spacetime scheduling instructionlevel parallelism raw machine acm sigplan notices v33 n11 p4657 nov 1998 eduardo quiones joanmanuel parcerisa antonio gonzalez selective predicate prediction outoforder processors proceedings 20th annual international conference supercomputing june 28july 01 2006 cairns queensland australia patrick akl andreas moshovos branchtap improving performance checkpoints adaptive speculation control proceedings 20th annual international conference supercomputing june 28july 01 2006 cairns queensland australia hyesoon kim jose joao onur mutlu yale n patt divergemerge processor dmp dynamic predicated execution complex controlflow graphs based frequently executed paths proceedings 39th annual ieeeacm international symposium microarchitecture p5364 december 0913 2006 david august john w sias jeanmichel puiatti scott mahlke daniel connors kevin crozier wenmei w hwu program decision logic approach predicated execution acm sigarch computer architecture news v27 n2 p208219 may 1999 aaron smith ramadass nagarajan karthikeyan sankaralingam robert mcdonald doug burger stephen w keckler kathryn mckinley dataflow predication proceedings 39th annual ieeeacm international symposium microarchitecture p89102 december 0913 2006 john w sias wenmei w hwu david august accurate efficient predicate analysis binary decision diagrams proceedings 33rd annual acmieee international symposium microarchitecture p112123 december 2000 monterey california united states mihai budiu girish venkataramani tiberiu chelcea seth copen goldstein spatial computation acm sigarch computer architecture news v32 n5 december 2004 yuan chou jason fung john paul shen reducing branch misprediction penalties via dynamic control independence detection proceedings 13th international conference supercomputing p109118 june 2025 1999 rhodes greece spyridon triantafyllis manish vachharajani neil vachharajani david august compiler optimizationspace exploration proceedings international symposium code generation optimization feedbackdirected runtime optimization march 2326 2003 san francisco california david august wenmei w hwu scott mahlke partial reverse ifconversion framework balancing control flow predication international journal parallel programming v27 n5 p381423 oct 1999 lori carter beth simon brad calder larry carter jeanne ferrante path analysis renaming predicated instruction scheduling international journal parallel programming v28 n6 p563588 december 2000
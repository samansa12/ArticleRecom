design implementation performance evaluation detectionbased adaptive block replacement scheme new buffer replacement scheme called dear detectionbased adaptive replacement presented effective caching disk blocks operating system proposed dear scheme automatically detects block reference patterns applications applies different replacement policies different applications depending detected reference pattern detection made periodic process based relationship block attribute values backward distance frequency gathered period forward distance observed next period paper also describes implementation performance measurement dear scheme freebsd results performance measurements several real applications show compared lru scheme proposed scheme reduces number disk ios 51 percent average 23 percent response time 35 percent average 12 percent case single application executions multiple application executions results show proposed scheme reduces number disk ios 20 percent average 12 percent overall response time percent average 8 percent b introduction speed gap processor disks becoming wider vlsi technologies advance enormous rate overcome speed gap buffer caches 1 used keep main memory paper presented part usenix 1999 annual technical conference fourth ieee international workshop multimedia database management systems department computer engineering seoul national university seoul 151742 korea email choijmssrnetsnuackr symindandelionsnuackr chossrnetsnuackr z department computer engineering hongik university seoul 121791 korea email nohcshongikackr disk blocks likely accessed near future since size buffer cache limited effective scheme needed decide block kept cache end study effective block replacement focus much research systems database areas 2 3 4 5 6 7 many traditional block replacement algorithms assume past good predictor future example lru replacement algorithm assumes disk blocks referenced recently likely referenced near future referenced far back past similarly lfu replacement algorithm assumes disk blocks referenced frequently likely referenced near future referenced sparsely one common problem approaches underlying assumptions always correct since actual disk block reference patterns applications differ widely depending applications address problem number block replacement schemes recently proposed make use userlevel hints applicationcontrolled file caching 8 informed prefetching caching 9 userlevel hints schemes provide information blocks good candidates replacement allowing different replacement policies applied different applications however obtain userlevel hints users need accurately understand characteristics block reference patterns applications requires considerable effort users limiting applicability simple reference patterns sequential reference pattern heuristic method used detect pattern without userlevel hints appropriate replacement policy used improve buffer cache performance 10 also implicit ios used manage paged virtual memory reference pattern deduced compiler appropriate replacement policies used based deduced pattern 11 paper propose new replacement scheme called dear detection based adaptive replacement general file caching without help user compiler dear scheme dynamically detects reference pattern application classifies pattern sequential looping temporallyclustered probabilistic detection scheme applies appropriate replacement policy application reference pattern application may change execution dear scheme periodically detects reference pattern applies different replacement policy necessary implemented dear scheme freebsd 225 evaluated performance several real applications scheme implemented kernel level without modification system call interface applications may run asis performance measurements real applications show case single application executions dear scheme reduces number disk ios 51 average 23 response time 35 average 12 compared lru buffer management scheme freebsd multiple applications reduction number disk ios 20 average 12 reduction overall response time 18 average 8 also compared performance dear scheme applicationcontrolled file caching 8 tracedriven simulations set application traces used 8 results show dear scheme without uselevel hints performs comparably applicationcontrolled file caching traces considered rest paper organized follows section 2 explain dear scheme detail describe implementation dear scheme freebsd section 3 section 4 evaluate performance dear scheme finally conclude paper summary discussions future work section 5 2 dear scheme recent research shown applications show regular block reference patterns patterns vary depending nature application example large class scientific applications show looping reference pattern blocks referenced repeatedly regular intervals 12 hand many database applications show probabilistic reference pattern different probabilities index blocks data blocks 13 unix applications tend show either sequential temporallyclustered reference pattern 8 14 applications deal continuous media generally show sequential looping reference pattern 15 observations classify applications reference pattern one following se quential looping temporallyclustered probabilistic reference pattern proposed dear detect reference pattern based relationship block attribute values forward distance seen calculate forward distance blocks referenced update block attributes blocks update block attributes blocks referenced referenced figure 1 detection process twostage pipeline onelevel lookbehind scheme detection applications reference pattern made associating attributes blocks forward distances 1 attribute block anything obtained past reference behavior including backward distance frequency interreference gap 5 kth backward distance 3 paper consider two block attribute types backward distance time interval current time time last reference 2 frequency number past references block detection performed monitoring process invoked periodically time ith invocation denote time monitoring process calculates forward distances seen standpoint blocks referenced forward distances associated block attribute values two ordered lists one according backward distance according frequency ordered list divided fixed number sublists equal size based relationship attribute value sublist average forward distance blocks sublist block reference pattern application deduced detection block attributes blocks referenced updated next detection shown figure 1 detection process essentially twostage pipeline onelevel lookbehind since detection made based relationship block attribute values forward distance igamma1 example consider figure 2 assume detection period 10 measured number 1 forward distance block defined time interval current time time next reference block 2 paper assume virtual time incremented block reference average forward average forward average forward average forward b c backward backward backward backward backward backward distance distance distance distance distance time sublist sublist backward distance sublist sublist sublist sublist frequency bdbdbdfrfrfraverage forward average forward figure 2 example block reference pattern detection block references made associated application also assume b 6 referenced given order see figure 2b finally assume igamma1 backward distance frequency six distinct blocks b 4 15 12 25 4 20 9 6 4 5 2 1 1 respectively see figure 2 note distinct blocks forward distances 1 2 3 4 6 7 respectively seen igamma1 information block attribute values forward distance dear scheme constructs two ordered lists one according backward distance according frequency see figure 2c list divided number sublists equal size 3 sublists size 2 example various rules detecting reference patterns explained applied two lists particular example blocks higher frequency smaller forward distance allows us deduce block reference pattern given application follows probabilistic reference pattern detection rules probabilistic reference pattern reference patterns formally stated follows sequential pattern sequential reference pattern property blocks referenced one never referenced pattern average forward distance sublists 1 therefore reference pattern sequential avg fdsublist bd avg fdsublist fdsublist fdsublist sublist bd sublist fr ith sublist backward distance frequency block attribute types respectively avg fdsublist average forward distance blocks sublist looping pattern looping reference pattern property blocks referenced repeatedly regular interval pattern block larger backward distance smaller forward distance therefore reference pattern looping following relationship holds fdsublist bd fdsublist bd temporallyclustered pattern temporallyclustered reference pattern property block referenced recently referenced sooner future thus block smaller backward distance smaller forward distance therefore reference pattern temporallyclustered following relationship holds fdsublist bd avg fdsublist bd probabilistic pattern probabilistic reference pattern nonuniform block reference behavior modeled independent reference model irm 16 block b stationary probability p blocks independently referenced associated probabilities stationary independent condition expected forward distance b proportional 1p thus block higher frequency smaller forward distance therefore reference pattern probabilistic following relationship holds fdsublist fr fdsublist fr dear scheme different replacement policies used different applications depending detected reference pattern sequential looping reference patterns mru replacement policy used block smallest backward distance always selected replacement temporallyclustered reference pattern lru replacement policy replaces block largest backward distance used finally probabilistic reference pattern lfu replacement policy replaces block lowest reference frequency used 1 readwrite 2 breadbwrite 5 vfsstrategy 3 getnewbuf system call interface virtual file system buffer cache 4 newinterface unix file system network file system logstructured file system acm acm acm figure 3 overall structure dear scheme freebsd 225 3 implementation dear scheme freebsd figure 3 shows overall structure buffer cache manager dear scheme implemented freebsd 225 dear scheme applies different replacement policies different applications requires split buffer cache management module two parts one block allocation block replacement module responsible block allocation system cache manager scm one scm system module responsible block replacement application cache manager acm one acm ap plication organization similar proposed applicationcontrolled file caching 8 modules located vfs virtual file system layer collaborate buffer allocation block replacement acm allocated process process forked block referenced process associated acm called bread bwrite procedure scm 1 locate information referenced block using hash table 2 update block attribute changed current reference 3 place block linked list maintains blocks referenced current detection period 4 adjust replacement order according applicationspecific replacement policy maintain replacement order current implementation uses linked list data structure lru mru replacement policies heap data structure lfu replacement policy application k application acm application 2 send replacement request using applicationspecific block replacement policy 3 select victim block 1 request new buffer space allocate new buffer space deallocate buffer space victim block figure 4 interaction acm scm steps 14 performed check made see whether current detection period monitoring process explained previous section invoked detect applications reference pattern detected reference pattern dictates replacement policy acm none detection conditions previously explained satisfied default lru replacement policy used structure information maintained block acm vnode block backward distance frequency forward distance hp bp fp cp pointer hp used place block hash table used locate information currently referenced block pointers bp fp used place block ordered lists backward distance frequency block attribute types respectively constructed monitoring process invoked finally pointer cp used place block list blocks referenced current detection period data structure main space overhead dear scheme main time overhead dear scheme needed order blocks according block attribute value log n time complexity n number distinct blocks referenced detection period operation invoked end detection period block attribute type time overheads include needed calculate forward distance backward distance frequency blocks end detection period time complexity n number distinct blocks referenced detection period acm scm interact depicted figure 4 application misses buffer cache acm application makes request scm additional buffer space step 1 figure 4 scm free buffer space sends replacement request one acms step 2 operation performed getnewbuf procedure scm first choice acm associated application whose current reference pattern sequential application scm simply chooses acm application global lru block strategy similar one used applicationcontrolled file caching 8 selected acm decides victim block replaced using current replacement policy step 3 deallocates space scm step 4 scm allocates space acm requested space step 5 performance evaluation section present results performance evaluation dear scheme first describe experimental setup give results reference pattern detection followed performance measurement results single applications multiple applications also give results sensitivity analysis different cache sizes detection periods numbers sublists finally compare performance dear scheme applicationcontrolled file caching 8 41 experimental setup experiments conducted freebsd 225 166mhz intel pentium pc 64mb ram 21gb quantum fireball hard disk applications used described summarized table 1 cscope cscope interactive csource examination tool creates index file named cscopeout c sources answers interactive queries like searching c symbols finding specific functions identifiers used cscope kernel sources roughly 9mb size executed queries search five literals table 1 characteristics applications application description input data mb cscope csource examination tool c code glimpse information retrieval tool text files 550 utility text files 45 link unix link editor object files 25 cpp c preprocessor c code 110 gnuplot gnu plotting utility numeric data 8 postgres1 relational db system two relations 7515 postgres2 relational db system four relations 00515 glimpse glimpse text information retrieval utility builds indexes words performs fast searching text files roughly 50mb size indexed resulting 5mb indexes search done lines contain keywords multithread realtime dsm continuous media diskspace sort sort utility sorts lines text files 45mb text file used input file sorted numerically using first field key link link unix linkeditor used application build freebsd kernel 25mb object files cpp cpp gnu ccompatible compiler preprocessor kernel source used input size header files csource files 1mb 10mb respectively gnuplot gnuplot commandline driven interactive plotting program using 8mb raw data program plotted threedimensional plots four times different points view postgres1 postgres2 postgres relational database system university california berkeley postgressql version 62 relations scaledup wisconsin benchmark used postgres1 join hundredthoustup twohundredthoustup relations postgres2 join among four relations namely fivehundredup twothoustup twentythoustup twohundredthoustup sizes fivehundredup twothoustup twen tythoustup hundredthoustup twohundredthoustup approximately 50kb 150kb 15mb 75mb 15mb respectively 42 detection results seq seq loop loop loop loop seq loop loop detection result prob prob prob prob prob prob prob prob prob detection result200600100014001800 logical block number virtual time cscope1003005007000 500 1000 1500 2000 2500 3000 3500 4000 4500 5000 logical block number virtual time b cpp figure 5 block reference patterns detection results cscope cpp figure 5 shows results detection dear scheme cscope cpp applications graph xaxis virtual time increments block reference yaxis logical block numbers referenced given time detection results given top graph assuming detection period 500 references cscope dear scheme initially detects sequential reference pattern changes detection looping reference pattern sequentially referenced blocks reaccessed behavior results cscope always reading file cscopeout sequentially whenever receives query c source cpp dear scheme detects probabilistic reference pattern throughout execution since see graph blocks frequently accessed others reference pattern results characteristic cpp header files frequently referenced files figure 6 shows detection results applications although result shows dear scheme performs reasonably well applications also reveals limitation current dear scheme notably sort postgres2 applications either parallel nested reference streams indicates need proposed dear scheme address general reference patterns arbitrary control structures parallel sequence nested detection result seq seq loop loop loop loop loop seq loop detection result seq seq seq loop undetect loop50015002500 logical block number virtual time glimpse200600100014001800 logical block number virtual time b sort detection result seq seq loop loop seq loop loop loop detection result seq loop loop loop loop loop loop1003005000 500 1000 1500 2000 2500 3000 3500 4000 4500 5000 logical block number virtual time c link1003005007009000 500 1000 1500 2000 2500 3000 3500 4000 4500 5000 logical block number virtual time gnuplot detection result seq seq loop loop loop loop loop loop loop prob prob detection result prob seq prob loop prob prob undetect50015002500 logical block number virtual time logical block number virtual time f postgres2 figure reference patterns detection results applications qpppp qpppp qrppp qrppp qtppp qtppp aoeooofoooaoeooofooo deardear ffoeoe number disk ios qppqpp qrpqrp qtpqtp qvpqvp aoeooofoooaoeooofooo rtooohfi rtooohfi lrulru deardear ff oeooooeooo oeooooeooo b response time figure 7 single application performance 43 performance measurements single applications compared performance application dear scheme lru scheme built freebsd also lfu mru schemes purpose implemented dear scheme well lfu mru schemes freebsd measured number disk ios response time application 6mb buffer cache block size set 8kb dear scheme set length detection period 500 number sublists ordered lists 5 backward distance frequency block attribute types performance dear scheme different cache sizes different detection periods different numbers sublists ordered lists discussed section 45 figure 7 shows number disk ios response time four schemes values reported average three separate executions execution system rebooted eliminate effects resulting prior buffer cache contents results observe following ffl dear scheme performs almost good best three schemes applications considered also compared lru scheme freebsd number disk ios reduced 51 cscope application average 23 response time 35 also cscope application average ffl link application performance difference among four schemes input data link application small 25mb thus blocks reside buffer cache initially loaded ffl postgres1 postgres2 show much improvement response time number disk ios using dear scheme constant synchronization client psql utility provides user interface server postgres process performs query processing database management gnuplot application much time spent user mode computation thus reduction number disk ios limited impact response time ffl except three applications ratio reduction number disk ios response time consistent indicates dear scheme incurs little extra overhead schemes last point evident figure 8 response time divided three components io stall time system time user time lru scheme freebsd system time consists vfs processing time buffer cache management time disk driver processing time disk interrupt handling time data copy time buffer cache user space top dear scheme requires additional processing time time sorting blocks according block attribute values also maintaining block attribute values forward distances figure 8 notice system times two schemes comparable meaning dear scheme incurs little additional overheads 44 performance measurements multiple applications real systems multiple applications execute concurrently competing limited buffer space test dear scheme environment ran several combinations two applications buffer cache 6mb measured total number disk ios overall response time dear scheme lru scheme freebsd set length detection period 500 number sublists ordered lists 5 qppqpp lru lru dear dear lru lru dear dear lru lru dear dear lru lru dear dear lru lru dear dear lru lru dear dear lru lru dear dear lru lru dear dear aoeooofoooaoeooofooo rtooohsfi rtooohsfi ioooeoeoooioooeoeooo tmoootmooo oooooo rr oeooooeooooeoe oeooooeooo figure 8 decomposition response time qppppqpppp qrpppqrppp qtpppqtppp qvpppqvppp qxpppqxppp aoeooofoooaoeooofooo deardear number disk ios upup qppqpp qupqup aoeooofoooaoeooofooo ooeoertooohsfi ooeoertooohsfi lrulru deardear b overall response time figure 9 multiple application performance table 2 performance comparison lruseq dear schemes scheme response time seconds cssort glilink cswc gliwc lru 7096 8987 8127 8997 dear 6661 7429 6288 8236 results figure 9 show number disk ios reduced 20 cscopesortlink case average 12 overall response time 18 glimpselink case average 8 multiple application case two possible benefits using proposed dear scheme first applying different replacement policies different applications based detected reference patterns second giving preference blocks belong application sequential reference pattern replacement needed quantify two different types benefit performed experiment even lru replacement policy gives preference blocks belonging application sequential reference pattern call lruseq replacement policy table 2 shows results lruseq scheme 6mb buffer cache size case cscopesort glimpselink little difference lru lruseq schemes since reference pattern four component applications sequential steady state replacing sort link wc whose reference pattern sequential produces significant difference response time lru lruseq schemes results lruseq scheme allocating buffer space cscope glimpse replacing blocks wc application earlier usual lru order still substantial difference response time lruseq scheme dear scheme indicating benefit applying different replacement policies tailored different applications significant 45 sensitivity analysis cache size tables 3 4 compare performance dear scheme lru table 3 single application performance various buffer cache sizes application scheme response time seconds cscope dear 1699 1490 1287 1117 lru 1979 1979 1977 1977 glimpse dear 3912 3568 3373 3287 link dear 2819 2338 2338 2338 cpp dear 13294 9442 9161 9136 gnuplot dear 4354 4226 4139 4119 postgres1 dear 3837 3616 3422 3217 postgres2 dear 7457 7251 7115 6845 lru 8293 7493 7475 7393 scheme various buffer cache sizes single multiple application cases respectively results single application case show long total number distinct blocks accessed application greater number blocks buffer cache substantial difference response time dear lru schemes however number distinct blocks application smaller number blocks buffer cache blocks cached buffer cache two schemes show similar performance behavior visible link application smallest number distinct blocks 310 blocks multiple application case case total number distinct blocks accessed component applications smaller number blocks buffer cache occur dear scheme shows consistently better performance lru scheme detection period number sublists determining length detection period important design issue requires tradeoff detection period long scheme adaptive possible changes reference pattern within detection period hand period short scheme would incur much overhead table 4 multiple application performance various buffer cache sizes applications scheme response time seconds cssort dear 704 666 629 535 lru 715 709 699 673 glilink dear 791 742 716 701 lru 945 898 791 779 cppps1 dear 2222 2167 2098 2024 glips2 dear 1456 1398 1325 1283 cssortlink dear 1161 1127 1067 1018 lru 1213 1180 1128 1053 lru 2463 2453 2259 2229 table 5 effect detection period performance dear scheme single application case scheme detection response time seconds period cscope glimpse sort cpp gnuplot postgres1 postgres2 100 1285 3370 1372 9881 4092 3462 7656 dear 500 1287 3373 1360 9161 4139 3422 7115 1000 1352 3626 1388 9178 4166 3453 7241 2000 1520 3645 1577 9199 4236 3484 7253 table effect detection period performance dear scheme multiple application case scheme detection response time seconds period cssort glilink cppps1 glips2 cssortlink glisortcpp 100 6668 7354 23629 14467 10886 25154 dear 500 6661 7429 21673 13988 11273 23556 1000 6734 7499 21691 13924 11630 23870 2000 6870 8169 21938 13934 11684 24141 practical moreover period short short burst references may mislead detection example probabilistic reference pattern may mistaken looping reference pattern small number blocks repeatedly accessed two detection periods tradeoff relationship evident table 5 gives response time link application detection period varies 100 2000 exclude link application since mentioned earlier blocks fit buffer cache thus different detection periods make difference remaining applications best performance obtained detection period either 250 500 results also show even detection periods considerably smaller larger optimal values dear scheme performs better lru scheme freebsd exceptions cpp postgres2 applications detection period 100 two cases performance degradation considerably larger others detection period 100 careful inspection results revealed detection period 100 dear scheme mistakenly detects applications looping reference pattern reality part probabilistic reference pattern multiple application case shows similar effect detection period performance see table 6 sequential reference pattern use simpler detection rule checks whether referenced block numbers consecutive detection made early execution application experimented optimization table 7 shows results assuming buffer cache size 6mb experiment dear scheme early detection tries identify sequential reference pattern within 20 block references successful reverts original dear scheme detection period 500 table 7 performance early detection sequential reference patterns response time seconds dear dear early detection cscope 1287 1282 glimpse 3373 3336 cscopesort 6661 6545 glimpselink 7429 7318 cscopesortlink 11273 10819 table 8 effect number sublists detection results dear scheme application detection results number sublists 3 number number cscope seq3loop8 seq3loop8 seq3loop8 glimpse seq4loop8 seq4loop8 seq3loop9 link seq3loop5 seq3loop5 seq3loop5 cpp prob18 prob18 prob13undetect5 gnuplot seq1loop6 seq1loop6 seq1loop6 postgres1 seq5loop16 seq5loop16 seq5loop16 postgres2 prob13loop5seq2undetect1 prob12loop4seq2undetect3 prob11loop3seq2undetect5 results show case single application executions dear scheme early detection shows little improvement original dear scheme original dear scheme determine appropriate replacement policy block replacements made since blocks buffer cache 750 blocks buffer cache size 6mb block size 8kb detection period multiple application executions early detection scheme shows larger improvement since early detection sequential reference patterns allows effective buffer allocation still improvement significant number sublists used detection process affect detection results dear scheme table 8 gives detection results dear scheme number sublists increases three seven results notice number sublists hardly affects detection results although slight increase number undetected cases number sublists increases due strict detection rule remember detect reference pattern associated detection rule held sublists 46 comparison applicationcontrolled file caching compare performance dear scheme applicationcontrolled file caching acfc 8 performed tracedriven simulations set three application traces used 8 figure 10 shows miss ratio three applications lru acfc dear opt offline optimal schemes cache size increases 1mb 16mb results lru acfc opt schemes borrowed 8 dear scheme obtained simulating dear scheme detection period equal 500 number sublists ordered list equal 5 backward distance frequency block attribute types results show miss ratio dear scheme comparable acfc scheme utilizes userlevel hints guide replacement decisions small difference two schemes results misses occur dear scheme chance detect reference pattern 5 conclusions future work paper proposed new buffer management scheme called dear detection based adaptive replacement automatically detects block reference pattern applications sequential looping temporallyclustered probabilistic without user intervention based detected reference pattern proposed dear scheme applies appropriate replacement policy application implemented dear scheme freebsd 225 measured performance using several real applications results showed compared buffer management scheme freebsd proposed scheme reduces number disk ios 51 average 23 response time 35 average 12 case single application executions multiple applications reduction number disk ios 20 average 12 reduction overall response time 18 average 8 also compared performance dear scheme applicationcontrolled file caching 8 tracedriven simulations results showed dear scheme performs uu qpqp ququ sooosbcfhmbisooosbcfhmbi mooorooohei mooorooohei lrulru deardear acfcacfc optopt qrtxqv qrtxqv cscope qpqp upup sooosbcfhmbisooosbcfhmbi mooorooohei mooorooohei lrulru deardear acfcacfc optopt b linking kernel qpqp upup wpwp sooosbcfhmbisooosbcfhmbi mooorooohei mooorooohei lrulru deardear acfcacfc optopt qrtx qrtx c postgres figure 10 comparison applicationcontrolled file caching comparably applicationcontrolled file caching traces considered noted section 42 applications block reference behavior cannot characterized single reference pattern one direction future research extend current dear scheme detect complex reference patterns parallel sequence nested structures well develop appropriate replacement policies another direction future research study advanced buffer allocation strategies dear scheme simple strategy explained section 3 good buffer allocation strategy dear scheme reward applications larger reductions number disk ios preventing one application monopolizing buffer space directions future research include applying detection capability dear scheme prefetching considering block attribute types backward distance frequency r design unix operating system data cache management using frequencybased replacement lruk page replacement algorithm database disk buffering existence spectrum policies subsumes least recently used lru least frequently used lfu policies interreference gap model temporal locality program behavior generalized interval caching policy mixed interactive long video workloads flexible adaptable buffer management techniques database management systems applicationcontrolled file caching policies informed prefetching caching adaptive page replacement based memory reference behavior automatic compilerinserted io prefetching outofcore applications static analysis io characteristics scientific applications production workload characterization database access pattern analytic prediction buffer hit probability mea surements distributed file system design implementation symphony integrated multimedia file system operating systems theory tr ctr yannis smaragdakis general adaptive replacement policies proceedings 4th international symposium memory management october 2425 2004 vancouver bc canada
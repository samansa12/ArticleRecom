alternatingtime temporal logic temporal logic comes two varieties lineartime temporal logic assumes implicit universal quantification paths generated execution system branchingtime temporal logic allows explicit existential universal quantification paths introduce third general variety temporal logic alternatingtime temporal logic offers selective quantification paths possible outcomes games game system environment alternate moves lineartime branchingtime logics natural specification languages closed systems alternatingtime logics natural specification languages open systems example preceding temporal operator eventually selective path quantifier specify game system environment system strategy reach certain state problems receptiveness realizability controllability formulated modelchecking problems alternatingtime formulas depending whether admit arbitrary nesting selective path quantifiers temporal operators obtain two alternatingtime temporal logics atl atlastatl atlast interpreted concurrent game structures every state transition concurrent game structure results choice moves one player players represent individual components environment open system concurrent game structures capture various forms synchronous composition open systems augmented fairness constraints also asynchronous composition structures without fairness constraints modelchecking complexity atl linear size game structure length formula symbolic modelchecking algorithm ctl extends modifications atl structures weakfairness constraints atl model checking requires solution 1pair rabin games done polynomial time structures strongfairness constraints atl model checking requires solution games boolean combinations bchi conditions done pspace case atlast modelchecking problem closely related synthesis problem lineartime formulas requires doubly exponential time b introduction 1977 pnueli proposed use lineartime temporal logic ltl specify requirements reactive systems pnu77 formula ltl interpreted computation infinite sequence states reactive system satisfies ltl formula computations due implicit use universal quantification set computations cannot express existential possibility prop erties branchingtime temporal logics ctl ctl provide explicit quantification set computations ce81 eh86 instance state predicate ctl formula 83 requires state satisfying visited computa tions ctl formula 93 requires exists computation visits state satisfying problem model checking verify whether finitestate abstraction reactive system satisfies temporallogic specification ce81 qs81 efficient model checkers exist ltl eg spin hol97 ctl eg smv mcm93 increasingly used debugging aids industrial designs logics ltl ctl natural interpretation computations closed systems closed system system whose behavior completely determined state system however compositional modeling design reactive systems requires component viewed open system open system system interacts environment whose behavior depends state system well behavior environment models open systems csp hoa85 io automata lyn96 reactive modules ah96 distinguish internal nondeterminism choices made system external nondeterminism choices made environ ment consequently besides universal computations satisfy property existential computation satisfy property questions third question arises naturally system resolve internal choices satisfaction property guaranteed matter environment resolves external choices alternating satisfaction viewed winning condition twoplayer game system environment alternation natural generalization existential universal branching studied extensively theoretical computer science cks81 different researchers argued gamelike interpretations ltl ctl specifications open systems list four instances 1 receptiveness dil89 al93 gssl94 given reactive system specified set safe computations typ ically generated transition relation set live computations typically expressed ltl formula receptiveness problem determine whether every finite safe computation extended infinite live computation irrespective behavior environment sensible necessary compositionality require affirmative answer receptiveness problem 2 realizability pro gram synthesis alw89 pr89a pr89b given sets input output signals synthesis problem requires construction reactive system assigns every possible input sequence output sequence resulting computation satisfies 3 supervisory control rw89 given finitestate machine whose transitions partitioned controllable uncontrollable set safe states control problem requires construction controller chooses controllable transitions machine always stays within safe set satisfies general ltl formula module checking kv96 given open system modulechecking problem determine matter environment restricts external choices system satisfies approaches use temporallogic syntax developed specifying closed sys tems reformulate semantics open systems paper propose instead enrich temporal logic alternating properties specified explicitly within logic introduce alternatingtime temporal logics specification verification open systems formulation open systems con siders instead system environment general setting set sigma agents correspond different components system environment scheduling agents consider two policies state synchronous sys tem known advance agent proceeds state asynchronous system several agents may enabled unknown scheduler determines agent takes next step latter case scheduler required fair agent infinite computation agent cannot continuously enabled without scheduled set sigma agents set gamma computations state w system consider following game protagonist adversary game starts state w whenever scheduled agent set protagonist chooses next state otherwise adversary chooses next state resulting infinite computation belongs set gamma protagonist wins protagonist winning strategy say alternating time formula hhaiigamma satisfied state w hhaii path quantifier parameterized set agents ranges computations agents force game irrespective agents sigma na play hence parameterized path quantifier hhaii generalization path quantifiers branchingtime temporal logics existential path quantifier 9 corresponds hhsigmaii universal path quantifier 8 corresponds hhii par ticular closed systems viewed systems single agent sys two possible parameterized path quantifiers hhsysii hhii match exactly path quantifiers 9 8 required specifying systems depending syntax used specify set gamma computations obtain two alternatingtime temporal logics logic atl set gamma specified formula ltl restricted logic atl set gamma specified single temporal operator applied state formula thus atl alternating generalization ctl atl alternating generalization ctl alternatingtime temporal logics conveniently express properties open systems illustrated following five examples 1 multiprocess distributed system require subset processes attain goal irrespective behavior remaining processes consider example cachecoherence protocol gigamax verified using smv mcm93 one desired properties absence deadlocks deadlocked state one processor say permanently blocked accessing memory cell requirement specified using ctl formul captures informal requirement precisely ctl formula asserts always possible processors cooperate eventually read write collabora tive possibility atl formula stronger guarantees memory access processor matter processors system adversarial possibility 2 ctl formula 82 asserts state predicate invariant system component irrespective behavior components adversarial invariance atl stands hhsigma n fagii 2 states weaker requirement possible invariant component cannot violate 2 therefore system components may cooperate achieve 2 collaborative invariance invariant complex system necessary sufficient check every component satisfies atl formula a2 3 receptiveness system whose live computations given ltl formula specified 4 checking realizability program synthesis corresponds model checking atl formula hhsysii maximal model considers possible inputs outputs 5 controllability system whose safe states given state predicate specified thesis corresponds model checking formula generally ltl formula atl requirement hhcontrolii asserts controller strategy ensure satisfaction notice atl better suited compositional reasoning ctl instance component satisfies ctl formula 93 cannot conclude compound system akb also satisfies 93 hand satisfies atl formula hhaii3 akb modelchecking problem alternatingtime temporal logics requires computation winning strategies case synchronous atl games finite reachability games consequently modelchecking complexity linear size system length formula case ctl checking existential reachability corresponds iterating existential nexttime operator 9 checking universal reachability corresponds iterating universal next 8 checking alternating reachability corresponds iterating appropriate mix 9 8 governed parameterized path quantifier suggests simple modelchecking procedure synchronous atl shows existing symbolic model checkers ctl modified check atl specifications extra cost asynchronous model due presence fairness constraints atl model checking requires solution infinite games namely generalized buchi games vw86 consequently modelchecking complexity quadratic size system symbolic algorithm involves nested fixedpoint computation modelchecking problem atl much harder show complete 2exptime synchronous asynchronous cases 2 alternatingtime logic atl 21 syntax temporal logic atl alternatingtime logic defined respect finite set pi propositions finite set sigma agents atl formula one propositions atl formulas set agents atl formulas operator hh ii path quantifier next u temporal operators logic atl similar branchingtime logic ctl path quantifiers parameterized sets agents ang known write ii instead hhfa gii 22 synchronousstructure semantics formulas atl interpreted synchronous structure set propositions sigma set agents w set states r w theta w total transition relation ie every state w 2 w exists state rw w 0 function maps state w 2 w set w pi propositions true w function oe maps state w 2 w agent oew 2 sigma enabled w note precisely one agent enabled state set sigma agents denote wa w set states w oew 2 fag singleton write w instead w fag two states w w 0 rw w 0 say w 0 successor w computation infinite sequence states 0 rw refer computation starting state w 0 w 0 computation computation fl index 0 use fli fl0 denote ith state fl finite prefix fl respectively order define semantics atl first define notion strategies strategy agent 2 sigma function f w delta w w f fl delta thus strategy maps finite prefix computation possible extension compu tation intuitively strategy f suggests history fl state w enabled successor f fl delta w w strategy f induces set computations agent enforce given state w set ang agents set g strategies agents define outcomes fa w set outw fa wcomputations agents enforce cooperate follow strategies fa wcomputation fl w fa iff whenever fl visits state whose agent k 2 computation proceeds according strategy f ak formally k 2 w particular outcome set outw fa contains single wcomputation outcome set outw fa contains wcomputations turn formal definition semantics atl write w indicate state w synchronous structure satisfies subscript clear context omit satisfaction relation defined states w 2 w inductively follows ffl p 2 pi w exists set fa strate gies one agent computations exists set fa strate gies one agent computations exists index flj train train ctr gate gate request gate grant gate ctr figure 1 synchronous traincontroller system note next operator hhaii gives local con straint w exists successor w satisfies w 62 wa successors w satisfy denote w set states w w since parameterized path quantifiers hhsigmaii hhii correspond existential universal path quan tification respectively write 9 hhsigmaii 8 hhii logic ctl fragment atl interpreted structures single agent 8 dual hh ii use path quantifier hhsigma n aii ranges computations agents strategies enforce path quantifier ranges computations agents strategies avoid therefore also ctl temporal operators 3 eventually 2 always defined operator hhaiitrue u example 21 consider synchronous structure shown figure 1 structure describes protocol train entering gate railroad cross ing moment train either gate gate order enter gate train issues request serviced granted rejected controller next step grant train may enter gate relinquish grant structure two agents train controller two states structure labeled ctr controlled computation one states controller chooses next state two states controlled train chooses successor states system satisfies following specifications 1 whenever train outside gate grant enter gate controller prevent entering gate gate grant hhctr ii2out gate 2 whenever train outside gate controller cannot force enter gate gate ctr2out gate 3 whenever train outside gate train controller cooperate train enter gate gate hhctr trainii3in gate 4 whenever train gate controller force single step gate first two specifications cannot stated ctl provide information ctl gate requires existence computation train always outside gate atl formulas guarantee matter train haves controller prevent entering gate matter controller behaves train decide stay outside gate since states structure either controller states train states third specification equivalent gate 93 gate 23 asynchronousstructure semantics formulas atl also interpreted asynchronous structure pi sigma r l synchronous structure function oe maps transition r 2 r agent oer 2 sigma owns r agent 2 sigma denote r r set transitions owned two states w w 0 r w w 0 say w 0 asuccessor w note state w may none several asuccessors state w define enabled w sigma set agents exists asuccessor w write w set states w 2 enabledw synchronous structures computation infinite sequence states 0 rw given set sigma agents computation fl afair iff agent 2 index 0 exists j either 62 enabled w j r w afair computation agent continuously enabled without scheduled 1 similar synchronous case strategy agent 2 sigma function f w delta w w f fl delta r w w 0 thus agent applies strategy influences computation whenever scheduled however unlike synchronous structures known advance agent scheduled particular state encountered given state w set ang agents set g strategies agents define outcomes w fa set wcomputations agents enforce follow strategies f f scheduling policy fair respect formally computation k 2 w afair definition satisfaction atl formulas asynchronous structure synchronous case definition comes example w every agent 2 enabled w either 2 exists successor w 0 w w 0 62 asuccessors w 0 w w 0 synchronous atl fragment asynchronous atl interpreted structures state w set enabledw enabled agents singleton set sigma agents singleton synchronous asynchronous interpretations coincide equal ctl example 22 consider asynchronous structure shown figure 2 structure describes algorithms easily modified account differ ent stronger types fairness gate gate request gate grant gate train ctr train train train train ctr ctr ctr figure 2 asynchronous traincontroller system protocol train entering gate protocol similar one described example 21 requests train enter gate serviced asynchronously future step fair scheduling policy ensures request serviced granted rejected eventually four specifications example 21 hold also asynchronous system checking synchronous resp asynchronous modelchecking problem atl asks given synchronous asyn chronous structure atl formula set states satisfy measure complexity modelchecking problem two ways joint complexity model checking considers complexity terms size structure length formula structure complexity model checking considers complexity terms structure assuming formula fixed since structure typically much larger formula size common computational bottleneck structurecomplexity measure particular practical interest lp85 31 synchronous model model checking synchronous atl similar ctl model checking ce81 qs81 bcm first present symbolic algorithm manipulates state sets given synchronous structure algorithm shown figure 3 uses following primitive operations ffl function sub given returns queue sub subformulas 1 subformula 2 subformula 1 2 precedes 1 queue sub ffl function propcheck given proposition returns state set p ffl function pre given two state sets ae returns set states w either successor w w 62 ae successors w ffl union intersection difference inclusion test state sets primitives implemented using symbolic representations binary decision diagrams state sets transition relation given symbolic model checker ctl smv mcm93 pre operation needs modified checking atl 0 sub case case case case case ae false 2 6 ae ae case return figure 3 symbolic atl model checking alternatively atl modelchecking algorithm implemented using enumerative representation state set w structure subformula 0 every state w 2 w labeled 0 iff w 2 0 w labeled labeling states formulas proceeds bottomup fashion following ordering sub smaller larger subformulas 0 generated rules s1 s2 form hhaii labeling procedure straight forward labeling procedure corresponds solving reachability problem andor graph states wa ornodes remaining states andnodes need compute set nodes orplayer reach state labeled 2 staying within states labeled 1 since reachability problem andor graphs solved time linear number edges follows labeling procedure requires linear time subformula furthermore since reachability andor graphs ptimehard problem imm81 reduced model checking synchronous atl conclude following theorem theorem 31 synchronous modelchecking problem atl ptimecomplete solved time om structure transitions formula length structure complexity problem also ptimecomplete interesting compare modelchecking complexities synchronous atl ctl problems solved time om ces86 structure complexity ctl model checking nlogspacecomplete bvw94 model checking related graph reachabil ity synchronous atl model checking related andor graph reachability 32 asynchronous model consider asynchronous structure state set w formula atl synchronous case subformula 0 compute set states satisfy 0 starting innermost subformulas purpose transform asynchronous structure synchronous structure 0 follows propositions 0 propositions agents 0 agents plus new agent b called scheduler states 0 states plus every state w 2 w every agent enabled w new state q wa transition w w 0 owned agent replaced 0 two transitions one w q wa q wa w 0 propositions true states w q wa 0 true state w agent enabled state w 0 b agent enabled state q wa 0 thus synchronous structure first scheduler chooses one enabled agents chosen agent takes step consider subformula hhaii3 general formulas handled similarly evaluation formula state w 0 2 w corresponds following game protagonist ad versary game played synchronous structure starting w 0 agent enabled current state protagonist chooses successor state 0 otherwise adversary chooses next state state w satisfying visited protagonist wins game continues forever adversary wins iff resulting computation fair agent contains either infinitely many states form q wa infinitely many states w 2 w enabled state w state w 0 satisfies formula hhaii3 iff protagonist winning strategy winning condition adversary specified w w defines states enabled w 0 defines states 0 enabled buchi game set winning states adversary computed nested fixedpoint computation ae true ae 6 ae w n w 6 ae 0 od od enumerative implementation complexity solving buchi game quadratic number transitions structure vw86 transi tions 0 2m transitions thus labeling procedure subformula hhaii3 requires om 2 time subformula ii3 winning condition adversary conjunction n buchi conditions precise 2 ak w ak game transformed game single buchi condition introducing counter variable ranges set ng vw86 hence labeling procedure subformula 0 requires om 2 determine complexity evaluating subformulas define size logical connective 1 size temporal connective number agents corresponding path quantifier sizes connectives time complexity om 2 n 2 k bounded length formula finally since synchronous modelchecking problem special case asynchronous problem conclude following theorem theorem 32 asynchronous modelchecking problem atl ptimecomplete solved time om 2 2 structure transitions atl formula length structure complexity problem also ptimecomplete interesting compare modelchecking complexities asynchronous atl fairctl generalized buchi fairness constraints latter solved omk time vw86 k number buchi constraints best known algorithm former quadratic model checking related checking emptiness buchi automata asynchronous model checking related checking emptiness alternating buchi automata 4 alternatingtime logic atl logic atl fragment expressive logic called two types formulas state formulas whose satisfaction related specific state path formulas whose satisfaction related specific computation formally state formula one following propositions state formulas hhaii sigma set agents path formula path formula one following path formulas path formulas logic atl consists set state formulas generated rules similar branchingtime temporal logic ctl path quantifiers parameterized sets agents logic atl fragment atl consists formulas every temporal operator immediately preceded path quantifier semantics atl defined similarly semantics atl write fl indicate computation fl structure satisfies path subscript usually omitted satisfaction relation j defined states w computations fl inductively follows ffl state formulas generated rules s1 s2 definition j atl exists set fa strategies one agent computations state formula iff fl0 exists index 0 fli temporal operators 3 2 defined u usual example asserts agent strategy enforce whenever request continuously issued infinitely many grants given specification cannot expressed ctl atl singleagent structures degenerates ctl exponential price paid modelchecking complexity moving ctl price becomes even significant consider alternatingtime versions logics theorem 41 synchronous asynchronous cases modelchecking problem atl 2exptimecomplete cases structure complexity problem ptimecomplete proof sketch given synchronous structure state set w atl formula label states state subformulas starting innermost state subformulas state subformulas form hhaii employ algorithm module checking kv96 follows let 0 result replacing state subfor mulas already evaluated appropriate new propositions state w set fa strategies set outw fa computations induces tree obtained unwinding w pruning subtrees whose roots successors states wa chosen strategies fa construct buchi tree automaton twa accepts trees induced outw fa set fa strategies rabin tree automaton accepts trees satisfying kv96 twa jw j states es84 states 2 ojj acceptance pairs intersection two automata rabin tree automaton contains outcome trees satisfying 8 0 hence semantics atl state w satisfies hhaii iff intersection nonempty ej88 pr89a nonemptiness problem rabin tree automaton n states k pairs solved time okn 3n hence evaluating subformula hhaii single state requires time since jw j states ojj many subformulas membership 2exptime follows asynchronous case reduced synchronous case similar proof theorem 32 lower bounds use reduction realizability problem ltl 2exptimehard problem ros92 model checking synchronous atl contrast ctl model checking pspacecomplete ces86 structure complexity nlogspacecomplete bvw94 verification problem open systems corresponds modelchecking problem temporal logics corresponds case linear time realizability problem alw89 pr89a pr89b case branching time module checking problem kv96 search winning strategies regular games general involves hefty computational price logic atl identifies interesting class properties checked solving finite games demonstrates still great deal reasoning open systems performed efficiently conclude several remarks variations atl support design choices 51 agents limited memory definitions atl atl strategy agent may depend unbounded amount infor mation namely full history game current state however since involved games regular existence winning strategy implies existence winning finitestate strategy tho95 depends finite amount information history game thus semantics atl atl defined equivalently using outcomes finitestate strategies teresting strategy thought parallel composition system controller makes sure system follows strat egy appropriate definition parallel composition precisely finitestate strategies implemented using controllers synchronous structures indeed finite reachability games generalized buchi games atl suffices consider memoryfree strategies tho95 implemented control maps ie controllers without state case atl whose formulas specify winning positions games tho95 52 agents limited information models assume agents structure complete information propositions state satisfies propositions agents agent owns transitions sometimes may appropriate assume agent 2 sigma observe subset pi pi propositions strategy f pi pi must 1 depend observable part history 2 decide observable part next state undecidability results multiplayer games incomplete information follows modelchecking problem atl incomplete information undecidable synchronous yan97 asynchronous pr79 cases special case path quantifiers parameterized single agents cooperation agents different information possible decidability follows results module checking incomplete information kv97 case modelchecking complexity synchronous asynchronous atl exptimecomplete 2exptimecomplete atl structure complexity four problems exptimecomplete thus rendering reasoning agents incomplete information infeasible even severe restrictions 53 game logic module checking parameterized path quantifier hhaii first stipulates existence strategies agents universally quantifies outcomes stipulated strategies one may generalize atl atl separating two concerns strategy quantifiers path quantifiers say writing 99a 8 instead hhaii read 99a exist strategies agents example formula asserts agents strategies behavior remaining agents 1 always true possibly different behavior remaining agents 2 always true define semantics strategy quan tifiers need consider tree induced outcomes set strategies obtain three types formulas state formulas path formulas ctl atl tree formulas whose satisfaction related specific outcome tree instance state formula subformula tree formula refer general logic strategy quantifiers path quantifiers temporal operators boolean connectives game logic atl fragment game logic consists formulas every strategy quantifier immediately followed path quantifier note 99a 9 equivalent 9 another fragment game logic studied module checking kv96 one considers formulas form 99a single outermost strategy quantifier followed ctl ctl formula expressiveness viewpoint alternatingtime logics module checking identify incomparable fragments game logic formula equivalent atl formula atl formula equivalent formula single strategy quantifier kv96 shown modulechecking complexity exptimecomplete ctl 2exptime complete ctl structure complexity problems ptimecomplete applying method bottomup fashion used solve modelchecking problem game logic resulting joint complexity 2exptime structure complexity ptime thus game logic expensive atl feel however unlike state path formulas tree formulas natural specifications reactive systems 54 alternatingtime fixpoint logic temporal properties using operator defined fixed points nexttime properties closed systems gives calculus generalization temporal logics koz83 similar fashion one generalize alternatingtime temporal logics obtain alternatingtime calculus whose primitives parameterized next constructs hhaii least greatest fixedpoint operators positive boolean connectives atl proper fragment alternatingtime calculus every formula equivalent fixedpoint formula without alternation least greatest fixed points practice however designers prefer temporal operators fixed points bbg ctl ctl capture useful friendly subsets calculus specification closed system atl atl capture useful friendly subsets alternatingtime calculus specification open systems worth noting ctl parameterized next constructs sufficient use cannot specify unbounded alternating reachability property hhaii3 bvw94 hence essential atl parameterize path quan tifiers nexttime operators alternatingtime transition systems parameterized next construct hhaii different similar operators commonly written 9 interpreted agent 2 exists asuccessor rather atl formula hhaii equivalent 9 8 sigmana abstract specification open systems essential parameterized next gamelike interpretation standard modal interpretation definitions synchronous asynchronous structures approximations real concurrency models open systems synchronous eg ah96 asynchronous eg lyn96 struc tures transition corresponds step single agent models transition may result simultaneous independent decisions several agents general situation gives rise games complex individual moves captured abstractly alternating transition systems see full paper gamelike interpretation parameterized next makes atl robust respect changes definition individual moves particular results carry alternating transition systems therefore apply example reactive modules ah96 acknowledgments thank amir pnueli moshe vardi mihalis yannakakis helpful discussions r reactive modules composing specifica tions realizable unrealizable concurrent program specifications symbolic model checking 10 20 states beyond automatatheoretic approach branchingtime model checking design synthesis synchronization skeletons using branchingtime temporal logic automatic verification finitestate concurrent systems using temporal logic specifications trace theory automatic hierarchical verification speedindependent circuits branching versus linear time complexity tree automata logics programs deciding branchingtime logic liveness timed untimed systems communicating sequential pro cesses model checker spin number quantifiers better number tape cells results propositional calculus module checking module checking visited checking finitestate concurrent programs satisfy linear specification distributed algorithms symbolic model checking temporal logic programs synthesis reactive module synthesis asynchronous reactive module specification verification concurrent systems cesar control discrete event systems modular synthesis reactive sys tems synthesis strategies infinite games personal communication tr communicating sequential processes myampersandldquosometimesmyampersandrdquo myampersandldquonot nevermyampersandrdquo revisited automatic verification finitestate concurrent systems using temporal logic specifications synthesis reactive module trace theory automatic hierarchical verification speedindependent circuits automata infinite objects temporal modal logic symbolic boolean manipulation ordered binarydecision diagrams symbolic model checking ectl fragments modal myampersandmgrcalculus conjoining specifications model checker spin modalities model checking extended abstract checking finite state concurrent programs satisfy linear specification menbership problem functional multivalued dependencies relational databases alternation reactive modules automatatheoretic approach branchingtime model checking module checking jmocha distributed algorithms symbolic model checking automata infinite objects churchs problem realizable unrealizable specifications reactive systems synthesis asynchronous reactive module fair simulation relations parity games state space reduction bmyampersanduumlchi automata small progress measures solving parity games control synchronous systems control synchronous systems part ii complexity branching modular model checking extended abstract specification verification concurrent systems cesar mocha lineartime modelchecking algorithm alternationfree modal mucalculus design synthesis synchronization skeletons using branchingtime temporal logic liveness timed untimed systems trees automata games deciding branching time logic ctr xianwei lai shanli hu zhengyuan ning improved formal framework actions individual intention group intention multiagent systems proceedings ieeewicacm international conference intelligent agent technology p420423 december 1822 2006 wojciech jamroga thomas gotnes agents achieve incomplete information proceedings fifth international joint conference autonomous agents multiagent systems may 0812 2006 hakodate japan thomas gotnes wiebe van der hoek michael wooldridge logic coalitional games proceedings fifth international joint conference autonomous agents multiagent systems may 0812 2006 hakodate japan suchismita roy sayantan das prasenjit basu pallab dasgupta p p chakrabarti sat based solutions consistency problems formal property specifications open systems proceedings 2005 ieeeacm international conference computeraided design p885888 november 0610 2005 san jose ca luigi sauro jelle gerbrandy wiebe van der hoek michael wooldridge reasoning action cooperation proceedings fifth international joint conference autonomous agents multiagent systems may 0812 2006 hakodate japan krishnendu chatterjee luca de alfaro thomas henzinger complexity quantitative concurrent parity games proceedings seventeenth annual acmsiam symposium discrete algorithm p678687 january 2226 2006 miami florida van der hoek michael wooldridge dynamics delegation cooperation control logical account proceedings fourth international joint conference autonomous agents multiagent systems july 2529 2005 netherlands aleksandra nenadi ning zhang qi shi rsabased verifiable recoverable encryption signatures application certified email delivery journal computer security v13 n5 p757777 october 2005 aldewereld wiebe van der hoek johnjules meyer rational teams logical aspects multiagent systems fundamenta informaticae v63 n23 p159183 april 2004 valentin goranko govert van drimmelen complete axiomatization decidability alternatingtime temporal logic theoretical computer science v353 n1 p93117 14 march 2006 thomas henzinger games system design verification proceedings 10th conference theoretical aspects rationality knowledge june 1012 2005 singapore van der hoek alessio lomuscio michael wooldridge complexity practical atl model checking proceedings fifth international joint conference autonomous agents multiagent systems may 0812 2006 hakodate japan van der hoek mark roberts michael wooldridge knowledge social laws proceedings fourth international joint conference autonomous agents multiagent systems july 2529 2005 netherlands alur pavol ern p madhusudan wonhong nam synthesis interface specifications java classes acm sigplan notices v40 n1 p98109 january 2005 van der hoek wojciech jamroga michael wooldridge logic strategic reasoning proceedings fourth international joint conference autonomous agents multiagent systems july 2529 2005 netherlands krishnendu chatterjee thomas henzinger marcin jurdziski games secure equilibria theoretical computer science v365 n1 p6782 10 november 2006 alessio lomuscio franco raimondi model checking knowledge strategies games multiagent systems proceedings fifth international joint conference autonomous agents multiagent systems may 0812 2006 hakodate japan alur salvatore la torre p madhusudan modular strategies recursive game graphs theoretical computer science v354 n2 p230249 28 march 2006 wojciech jamroga wiebe van der hoek agents know play fundamenta informaticae v63 n23 p185219 april 2004 magdalena kacprzak wojciech penczek fully symbolic unbounded model checking alternatingtime temporal logic1 autonomous agents multiagent systems v11 n1 p6989 july 2005 van der hoek michael wooldridge logic cooperation propositional control artificial intelligence v164 n12 p81119 may 2005 yves bontemps pierreyves schobbens christof lding synthesis open reactive systems scenariobased specifications fundamenta informaticae v62 n2 p139169 april 2004 r ghica murawski ch l ong syntactic control concurrency theoretical computer science v350 n2 p234251 7 february 2006 van der hoek knowledge rationality action proceedings third international joint conference autonomous agents multiagent systems p1623 july 1923 2004 new york new york
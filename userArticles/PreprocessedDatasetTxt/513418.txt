guaranteed describe distributed memory parallel delaunay refinement algorithm polyhedral domains generate meshes containing tetrahedra circumradius shortest edge ratio less 2 long angle separating two incident segments andor facets 90 270 degrees input implementation elementwise partitioned conforming delaunay mesh restricted polyhedral domain distributed processors parallel system submeshes distributed mesh independently refined concurrently inserting new mesh verticesour algorithm allows new mesh vertex affect submesh tetrahedralizations submesh interfaces induced partitioning flexibility crucial ensure mesh quality introduces unpredictable variable latencies due long delays gathering remote data required updating mesh data structures experiments 80 latency masked computation due finegrained concurrency algorithmour experiments also show algorithm efficient practice even certain domains whose boundaries conform theoretical limits imposed algorithm algorithm describe first step development much sophisticated guaranteedquality parallel mesh generation algorithms b introduction recent trend many control systems connect distributed elements control system via shared broadcast bus instead using pointtopoint links 1 however fundamental differences shared bus pointtopoint links firstly bus shared number subsystems contention access bus must resolved using protocol secondly transmission signal data virtually instantaneous different signals able tolerate different latencies therefore fundamental need scheduling algorithms decide contention resolved way latency requirements met number existing bus technologies paper concerned controller area network 2 comparison time triggered protocol ttp 3 two buses differ way scheduled takes dynamic approach using prioritybased algorithm decide connected stations permitted send data bus ttp uses static approach station permitted fixed time slice transmit data common misconception within automotive industry good transmitting urgent data unable provide guarantees deadlines met less urgent data 3 5 case dynamic scheduling algorithm used virtually identical scheduling algorithms commonly used realtime systems schedule computation processors fact analysis timing behaviour systems applied almost 1 authors contacted via email kenminsteryorkacuk copies york technical reports cited paper available via ftp minsteryorkacuk directory pubrealtimepapers without change problem determining worstcase latency given message queued transmission paper reproduces existing processor scheduling analysis shows analysis applied order analysis remain accurate details implementation controllers must known therefore paper assume existing controller intel 82527 illustrate application analysis apply sae benchmark class c automotive systems safety critical control applications 4 extend analysis deal fault tolerance issues paper structured follows next section outlines behaviour implemented intel 82527 assumed system model section 3 applies basic processor scheduling analysis 82527 section 4 applies analysis standard benchmark using number approaches section 5 extends basic analysis deal error recovery shows revised analysis reapplied benchmark certain fault tolerance requirements finally section 6 discusses outstanding issues offers conclusions 2 system model broadcast bus number processors connected bus via interface figure 1 host cpu network controller bus figure 1 architecture data source transmitted message consisting 1 8 bytes octets message may transmitted periodically sporadically ondemand example data source road speed could encoded 1 byte message broadcast every 100 milliseconds data source assigned unique identifier represented 11 bit number giving 2032 identifiers prohibits identifiers seven significant bits equal 1 identifier servers two purposes filtering messages upon reception assigning priority message concerned closed control systems assume fixed set messages unique priority temporal characteristics rate station bus able receive message based message identifier particular host cpu needs obtain road speed example indicates identifier bus controller messages desired identifiers received presented host cpu thus message destination use identifier priority important part regarding realtime performance bus system must way resolving contention tdma bus station assigned predetermined time slot transmit ethernet station waits silence starts transmitting one station try transmit together detect wait randomly determined time period try next time bus idle ethernet example carriersense broadcast bus since station waits bus idle ie carrier sensed monitors traffic collisions also carriersense broadcast bus takes much systematic approach contention identifier field message used control access bus collisions taking advantage certain electrical characteristics multiple stations transmitting concurrently one station transmits 0 bit stations monitoring bus see 0 conversely stations transmit 1 processors monitoring bus see 1 terminology 0 bit termed dominant 1 bit termed recessive effect bus acts like large andgate station able see output gate behaviour used resolve collisions station waits bus idle ethernet silence detected station begins transmit highest priority message held queue whilst monitoring bus message coded significant bit identifier field transmitted first station transmits recessive bit message identifier monitors bus sees dominant bus collision detected station knows message transmitting highest priority message system stops transmitting waits bus become idle station transmits recessive bit sees recessive bit bus may transmitting highest priority message proceeds transmit next bit identifier field requires identifiers unique within system station transmitting last bit least significant bit identifier without detecting collision must transmitting highest priority queued message hence start transmitting body message identifiers unique two stations attempting transmit different messages identifier would cause collision arbitration process finished error would occur general observations make arbitration protocol firstly message smaller identifier value higher priority message secondly highest priority message undergoes arbitration process without disturbance since stations backedoff ceased transmission bus next idle whole message thus transmitted without interruption overheads frame amount total 47 bits including 11 bits identifier field 4 bits message length field 16 bits crc field 7 bits endofframe signal 3 bits intermission frames fields bit stuffed five consecutive bits polarity sent controller inserts extra stuff bit opposite polarity stream bit stuffing used part error signalling mechanism 47 overhead bits 34 subject bitstuffing data field message 0 8 bytes also bitstuffed smallest message 47 bits largest 130 bits number features important error recovery protocol remote transmission request messages able perform number checks errors including use 16 bit crc applied 8 bytes data provides high error coverage violation bit stuffing rule failure see acknowledge bit receiving stations station including sending station detects error immediately signals transmitting error frame consists six bits polarity causes stations detect error stations concurrently transmit error frames stations resychronised controllers automatically reenter arbitration retransmit failed message order recover single error protocol requires transmission 29 bits error frame retransmission failed message error recovery overheads bounded knowing expected upper bound number errors interval well data messages also remote transmission request rtr messages messages contentless ie zero bytes long special meaning instruct station holding data message identifier transmit message rtr messages intended quickly obtaining infrequently used remote data however benchmark 4 require rtr messages discuss types messages apply analysis particular controller since different controllers different behaviours philips 82c200 controller much worse timing performance ideal behaviour 6 controller connected host processor via dualported ram dpram whereby cpu controller access memory simultaneously perfect controller would contain 2032 slots messages given message sent simply copied slot corresponding message identifier received message would also copied corresponding slot however since slot requires least 8 bytes total least 16526 bytes memory would required automotive environment amount memory would prohibitively expensive extra 50 per station multiplied ten stations per vehicle million vehicles 5m intel 82527 makes compromise giving 15 slots one slots dedicated receiving messages remaining 14 slots set either transmit receive messsages slot mapped given identifier slots programmed receive set receive message matching identifier mask slot independently programmed generate interrupt receiving message slot sending message slot enables handshaking protocols cpu permitting given slot multiplexed number messages important controlling dedicated receive slot 15 special slot double buffered cpu time empty one buffer whilst shadow buffer available controller paper assume slots statically allocated messages slot 15 used receive messages cannot fitted remaining slots 82527 quirk messages stored slots entered arbitration slot order rather identifier hence priority order therefore important allocate messages slots correct order outline system model message passing able analyse system deemed composed static set hard realtime messages statically assigned set stations connected bus hard realtime messages typically control messages deadlines must met else serious error said occur messages typically queued software task running host cpu term task encompasses number activities ranging interrupt handlers heavyweight processes provided operating system given task assumed invoked event take bounded time queue message time bounded instead fixed variability jitter subsequent queuings message term queuing jitter purposes paper assume minimum time invocations given task time termed period 2 given task sends message every invocations task message inherits period sending task given message assigned fixed identifier hence fixed priority assume given hard realtime message must bounded size ie contain bounded number bytes given bounded size bounded rate message sent effectively bound peak load bus apply scheduling analysis obtain latency bound message assume may also unbounded number soft realtime messages messages hard deadline may lost transmission example destination processor may busy receive sent added value system ie arrive reasonable time quality aspect system improved paper discuss special algorithms send simplicity instead assume sent background traffic ie assigned priority lower hard realtime messages 3 mentioned earlier queuing hard realtime message occur jitter variability queuing times following diagram illustrates queueing window b figure 2 message queuing jitter shaded boxes diagram represent windows task host cpu queue message jitter important ignore would lead insufficient analysis example ignoring jitter figure 2 would lead assumption message could queued interval duration b fact interval b message could queued twice late course task could invoked perhaps response emergency would therefore infinite period 3 number algorithms could potentially lead short average response times soft realtime messages application algorithms bus subject ongoing research york possible first queuing window b early possible next queuing window queuing jitter defined difference earliest latest possible times given message queued reality may possible reduce queuing jitter know execution task message queued example may minimum amount computation required task could queue message therefore event b diagrams would occurs later start task work addressed 13 diagram also shows period message derived task sending message example message sent per invocation task message inherits period equal period task keep queuing jitter message small might decompose task generating message two tasks first task calculates message contents second output task merely queues message second task invoked fixed time first task first task always completed second task runs since second task little work typically short worstcase response time queuing jitter inherited message therefore small general technique discussed detail elsewhere 14 briefly discuss message handled received destination station results incoming message must made available message sporadic one ie sent result chance event task invoked message arrival case message arrival raise interrupt host cpu hence assigned slot 15 intel 82527 bus controller course possible arrival message polled task required endtoend latency small polling period may unacceptably high arrival periodic message dealt without raising interrupt message statically assigned slot 82527 picked application task task could invoked clock synchronised notional global clock message guaranteed arrived task runs seen sole requirement communications bus messages bounded latencies proceed develop analysis give clearly analysis form key part wider analysis complete system give endtoend timing guarantees endtoend analysis subject ongoing research york established basic model system able give analysis bounding timing behaviour given hard realtime message 3 analysis 82527 section present analysis bounds worstcase latency given hard realtime message type analysis almost direct application processor scheduling theory 7 8 9 however assumptions made analysis firstly deadline given message denoted must period message denoted secondly bus controller must release bus lower priority messages higher priority messages pending ie controller cannot release bus sending one message entering pending message arbitration phase note philips 82c200 controller fails meet assumption worstcase response time given message denoted r defined longest time start task queuing latest time message arrives destination stations note time includes time taken sender task execute queue message first sight curious definition measuring time queuing message latest arrival might seem better however contents message reflects results action undertaken task triggered response event desirable measure wider endtoend time associated event jitter given message denoted j inherited response time tasks host cpu tasks scheduled fixed priority preemptive scheduling related work bound time taken queue message 10 7 hence determine queuing jitter mentioned earlier operates fixed priority scheduling algorithm however message fully preemptive since high priority message cannot interrupt message already transmitting 4 work burns et al 9 allows behaviour processor scheduling work 8 bound worstcase response time given hard realtime message following r j w c term j queuing jitter message gives latest queuing time message relative start sending task term w represents worstcase queuing delay message due higher priority messages preempting message lower priority message already obtained bus represents longest time taken physically send message bus time includes time taken frame overheads data contents extra stuff bits recall section 2 message contents 34 bits overheads subject bit stuffing stuff width 5 following equation gives denotes bounded size message bytes term bit bit time bus bus running 1 mbitsec 1ms queuing delay given 4 commonly understood computing field preemption include stopping one activity start continue another 2 set hpm set messages system higher priority j period given message j j j queuing jitter message b longest time given message delayed lower priority messages equal time taken transmit largest lower priority message defined lpm set lower priority messages note unbounded number soft realtime messages indeterminate size b equal 130t bit notice equation 2 term w appears left right hand sides equation cannot rewritten terms w simple solution possible forming recurrence relation value zero w 0 used iteration proceeds convergence ie w w equations assume anything identifiers hence priorities chosen however work processor scheduling 11 8 know optimal ordering priorities deadline monotonic one task short value j assigned high priority apply analysis sae benchmark 4 4 sae benchmark sae report describes set signals sent seven different subsystems prototype electric car although car control system engineered using pointtopoint links set signals provide good example illustrate application bus complex distributed realtime control systems seven subsystems batteries battery vehicle controller vc invertermotor controller im c instrument panel display ins driver inputs driver brakes brakes transmission control trans network connecting subsystems required handle total 53 messages contain sporadic signals contain control data sent periodically periodic message fixed period implictly requires latency less equal period messages latency requirements imposed application example messages sent result driver action latency requirement 20ms response appears driver instantaneous reader referred work kopetz 3 detailed description benchmark note kopetz forced interpret benchmark specification giving sensible timing figures benchmark fails specify example latency requirement 20ms driverinitiated messages requirement imposed kopetz rather benchmark still unspecified behaviour benchmark system model assumed paper requires even sporadic messages given period representing maximum rate occur periods sporadic messages benchmark inferred kopetz implicitly assumes sporadic messages period 20ms like kopetz forced assume sensible values also hypothesise queuing jitter values following table details requirements messages scheduled total 53 messages simple periodic messages chance messages ie queued sporadically response external event signal number signal description size bits ms ms periodic ms traction battery voltage 8 06 1000 p 1000 battery vc traction battery current 8 07 1000 p 1000 battery vc 3 traction battery temp average 8 10 10000 p 10000 battery vc auxiliary battery voltage 8 08 1000 p 1000 battery vc 5 traction battery temp max 8 11 10000 p 10000 battery vc 6 auxiliary battery current 8 09 1000 p 1000 battery vc 9 brake pressure line 8 transaxle lubrication pressure 8 trans vc transaction clutch line pressure 8 trans vc traction battery ground fault 1 12 10000 p 10000 battery vc 14 hilo contactor openclose 4 01 500 50 battery vc key switch start 1 03 500 200 driver vc 19 emergency brake 1 05 500 200 driver vc motortrans temperature 2 03 10000 p 10000 trans vc 22 speed control 3 07 500 200 driver vc 26 brake mode parallelsplit 1 08 500 200 driver vc 28 interlock 1 05 500 200 battery vc 29 high contactor control 8 03 100 p 100 vc battery battery reverse 2nd gear clutches 2 05 500 200 vc trans l number signal description size bits ms ms periodic ms battery battery 34 dcdc converter current control 8 06 500 200 vc battery battery 36 traction battery ground fault test 38 backup alarm 1 09 500 200 vc brakes warning lights 7 10 500 200 vc ins 42 torque command 8 43 torque measured 8 44 fwdrev 1 12 500 200 vc im c 48 shift progress 1 14 500 200 vc im c processed motor speed 8 50 inverter temperature status 2 06 500 200 im c vc 52 statusmalfunction tbd 8 08 500 200 im c vc 53 main contactor acknowledge 1 15 500 200 vc im c simple attempt implementing problem map messages message messages generally require latency 20 ms less although kopetz gives required latency 5ms one sporadic message messages may queued infrequently example reasonable assume least 50 ms elapses brake pedal depressions benchmark give periods messages assume period 50ms sporadic messages mentioned section 2 special output task could created message job merely queuing preassembled message assume model adopted benchmark system analysed following table lists messages order priority ie j order gives worstcase latencies computed analysis previous section signal numbers bold indicate signal sporadic one symbol indicates message fails meet latency requirements ie message guaranteed always reach destinations within time required symbol indicates valid response time found message guaranteed sent next queued ie r j signal n bytes ms ms ms r r r 500kbits r signal n bytes ms ms ms r r r 500kbits r 43 1 01 50 50 4568 2284 1142 0571 44 1 12 500 200 39848 4300 2150 1075 26 1 08 500 200 8080 3032 1516 28 1 05 500 200 12868 4166 2083 signal n bytes ms ms ms r r r 500kbits r problem approach mapping signal message approach vc subsystem transmits 14 message types 82527 cannot used recall 15 slots 82527 one dedicated receive slot return problem shortly seen bus speed 125kbits system cannot guaranteed meet timing constraints see underlying reason consider following table bus speed message utilisation bus utilisation 500 kbits 398 3132 309 1mbits 199 1566 579 message utilisation calculated using number data bytes given message bus utilisation calculated using total number bits including overhead given message column headed details breakdown utilisation 12 system given bus speed breakdown utilisation largest value message periods divided system remains schedulable ie latency requirements met indication much slack system value close greater 1 indicates although system schedulable little room increasing load symbol bus speed 125kbits indicates value breakdown utilisation found since even 0 still results unschedulable system seen large difference message bus utilisations relatively large overhead message bus speed 125kbits bus utilisation greater 100 therefore surprise bus unschedulable one way reducing bus utilisation message utilisation piggyback messages sent source example consider battery subsystem periodically sends four single byte messages period 100 ms message numbers 1 2 4 6 collect single message could sent one four byte message rate would reduce overhead hence bus utilisation another advantage piggybacking number slots required bus controller reduced 14 slots available 82527 controller vc subsystem 14 signals piggyback following periodic messages new message name size bytes ms composed battery high rate 4 1000 1246 battery low rate 3 10000 3513 brakes high rate 2 50 89 im c high rate 2 50 4349 vc high rate 4 50 vc low rate 1 10000 3336 piggybacking would implemented application tasks computing message contents several signals piggybacked single message would single task created simple job queuing message periodically fewer messages send given node queuing jitter given message may slightly less note signals 29 required sent period 10ms piggybacked message vc high rate sent every 5ms thus every message sent would contain null data signals need 14 message types sent vc subsystem following table gives timing details messages new message set signal n bytes ms ms ms r r r 500kbits r 28 26 1 03 500 200 19240 6708 2626 1313 signal n bytes ms ms ms r r r 500kbits r 44 1 05 500 200 38448 11944 4516 2258 notice timing requirements met many messages simple approach also able send messages using intel 82527 controller since subsystem sends 14 message types comparison following table gives utilisations set messages breakdown utilisation system bus speed message utilisation bus utilisation 500 kbits 380 1894 412 1mbits 19 947 761 seen piggybacking messages leads reduction overheads hence reduction bus utilisation general turn leads increased realtime performance however piggybacking signals single message require signals always generated together may restrict applicability piggybacking possible piggyback signals neccesarily generated together example sporadic signals approach take send server message periodically sporadic signal sent stored memory host cpu server message sent sender task polls signals occurred fills contents message appropriately approach sporadic signal may delayed polling period plus worstcase latency server message piggyback number sporadic signals latency requirements 20ms longer server message period 10ms worstcase response time 10ms would sufficient alternatively server message period 15ms worstcase response time 5ms could used transform set messages include server messages choose server messages periods 10ms latency requirements 10ms following table lists messages system signal bytes ms ms ms r 125kbits r 250kbits r 500kbits r two sporadic signals remain implemented sporadic messages signal 14 deadline short meet polling signal sporadic sent brakes subsystem cannot therefore piggybacked sporadic signals following table gives utilisation breakdown utilisation system bus speed message utilisation bus utilisation 500 kbits 462 2111 3812 1mbits 231 1055 7082 notice breakdown utilisation figure system running 125kbits bus close 1 showing system schedulable probably cannot accommodate urgent signals notice also bus utilisation increased despite system schedulable four bus speeds although overheads higher due polling sporadics peak load system lower illustrates utilisation figure valid sizeable intervals realtime systems peak load far important independent overall bus utilisation 5 extending analysis error recovery far assumed errors occur bus however analysis section 3 easily extended handle equation 2 amended worstcase response time given equation 1 e termed error recovery overhead function gives expected upper bound overheads due error recovery could occur interval duration function determined either observation behaviour high noise conditions building statistical model paper use simple error function illustration let n error number burst errors could occur arbitrarily small interval ie n error errors could occur error residual error period ie initial n errors errors cannot occur error elapsed rate higher one every error number errors interval duration bounded error error protocol error give rise 29 bits error recovery overhead followed retransmission message messages higher priority message message retransmitted delay message station attempting retransmit lower priority message message queued lose arbitration largest messages therefore bound overheads interval hence error function given error error return sae benchmark see performs certain error conditions let n error 4 let error 10ms pessimistic assumption bit rate 1 mbits equivalent error rate 1 bit 10 000 measurements suggest typical rate 1 bit 10 5 following table gives results updated analysis applied previously schedulable message set signal bytes ms ms ms r 125kbits r r 500kbits r results show network running 125kbits cannot tolerate assumed error rate speed 250kbits system tolerate error rate note need transmit message multiple times instead rely protocol detect errors retransmit failed messages alternative fault tolerance strategy disable error recovery mechanism use replicated bus message sent buses concurrently approach taken kopetz ttp bus however see solution far less flexible using dynamic error recovery approach since bandwidth effectively wasted normal conditions assumptions rate errors used indeed system must make assumptions apply assumptions dynamic recovery approach 6 discussion conclusions analysis reported paper enables protocol used wide range realtime applications indeed use systemwide priorities order message transmissions makes ideal control network use global approach priorities also advantage wealth scheduling analysis developed fixed priority processor scheduling easily adapted use tools already exist embody processor scheduling similar tools could developed would accurately predict worst case message latencies message classes system could also used systems engineer ask questions intended application applying analysis existing benchmark assessment applicability made however benchmark illustrate advantages full flexibility provide supported priority based analysis particular sporadic messages tight deadlines long interarrival times easily accommodated also possible incorporate many different failure models predict message latencies different levels failure experienced 7 r electronic exit spaghetti junction road vehicles interchange digital information controller area network high speed communication solution automotive control system benchmark class c application requirement considerations survey known protocols guaranteeing message latencies controller area network fixed priority scheduling hard realtime systems applying new scheduling theory static priority preemptive scheduling allocating scheduling hard realtime tasks pointtopoint distributed system fixed priority scheduling deadlines prior completion complexity fixedpriority scheduling periodic realtime tasks rate monotonic scheduling algorithm exact characterisation average case behaviour analysis hard realtime communications holistic schedulability analysis distributed hard realtime systems tr construction threedimensional delaunay triangulations using local transformations parallel unstructured grid generation active messages dataparallel algorithm threedimensional delaunay triangulation implementation condition guaranteeing existence higherdimensional constrained delaunay triangulations tetrahedral mesh generation delaunay refinement mesh generation domains small angles mobile object layer simultaneous mesh generation partitioning delaunay meshes ctr daniel spielman shanghua teng alper ngr time complexity practical parallel steiner point insertion algorithms proceedings sixteenth annual acm symposium parallelism algorithms architectures june 2730 2004 barcelona spain christos antonopoulos xiaoning ding andrey chernikov filip blagojevic dimitrios nikolopoulos nikos chrisochoides multigrain parallel delaunay mesh generation challenges opportunities multithreaded architectures proceedings 19th annual international conference supercomputing june 2022 2005 cambridge massachusetts computational database system generatinn unstructured hexahedral meshes billions elements proceedings 2004 acmieee conference supercomputing p25 november 0612 2004 andrey n chernikov nikos p chrisochoides practical efficient point insertion scheduling method parallel guaranteed quality delaunay refinement proceedings 18th annual international conference supercomputing june 26july 01 2004 malo france benot hudson gary l miller todd phillips sparse parallel delaunay mesh refinement proceedings nineteenth annual acm symposium parallel algorithms architectures june 0911 2007 san diego california usa
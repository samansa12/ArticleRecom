associated types class haskells type classes allow adhoc overloading typeindexing functions natural generalisation allow typeindexing data types well turns idea directly supports powerful form abstraction called associated types available c using traits classes associated types useful many applications especially selfoptimising libraries adapt data representations algorithms typedirected mannerin paper introduce motivate associated types rather natural generalisation haskells existing type classes formally present type system includes typedirected translation explicitly typed target language akin system f existence translation ensures addition associated data types existing haskell compiler requires changes front end b introduction recent oopsla paper garcia et al compare support generic programming oered haskell ml c c java using graphmanipulation library motivating example 11 oer table qualitative conclusions haskell rated favourably respects except one access socalled associated types example may want represent arrays manner depends element type given element type e associated type array e arrays elements first two authors partly funded australian research council grant number dp0211203 permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copies bear notice full citation first page copy otherwise republish post servers redistribute lists requires prior specific permission andor fee popl05 january 1214 2005 long beach california usa extending syntax haskell data declarations might define array follows data array data array data array pairarray array array b represent array integers unboxed array array booleans bit vector array pairs pair arrays assume uintarr bitvector builtin types representing unboxed integer arrays bit vectors respectively specialised representations ecient terms space runtime typical operations typeinvariant parametric representation data types whose concrete representation depends one type parameters called type analysing 15 type indexed 18 paper shall demonstrate typeindexed types understood classlocal data type declara tions fact natural extension haskells type class overloading system example array type would expressed local data type type class array elements arrayelem class arrayelem e data array e index array e int e keyword data class introduces associated data type definitionthe type array associated class arrayelem define instances arrayelem class give instantiations array type assuming indexuintarr predefined function indexing unboxed integer arrays instance arrayelem int data array index intarray ar instance arrayelem arrayelem b arrayelem b data array pairarray array array b index pairarray ar br together associated data type array included method index indexing arrays full type index index arrayelem e array e int e signature makes functions dependence class arrayelem well associated type array ex plicit words varying instantiations element type e concrete array representation index operates varies dependence equations defining array variation substantial standard haskell type classes representation type array may change nonparametric way dierent instantiations element type e words typeindexed types permit ad hoc overloading types way standard type classes provide ad hoc overloading values summarise make following contributions introduce associated data type declarations mechanism implement typeindexed types demonstrate usefulness number motivating examples notably selfoptimising libraries sec tions 2 3 show associated data types natural extension haskells overloading system give typing rules new type system evidence translation source terms target language akin system f sections 33 4 novel aspects system confined system f translation enables straightforward integration existing haskell compilers glasgow haskell compiler great deal related work subject typeindexed types review section 6 approach particularly close relationship functional dependencies 22 review section 5 2 motivation previous array example representative whole class applications associated types namely selfoptimis ing libraries libraries depending use optimise implementationie data representation choice algorithmsalong lines determined library author optimisation process guided type instantiation arrayelem class element type determines suitable array representation shall discuss another instance representation optimisation considering generic finite maps section 21 section 22 turn sophisticated example generic graph library data representation algorithms vary dependence type parameters key feature selfoptimising libraries merely rely general compiler optimisations instead library code contains precise instructions library code specialised particular applications since introduction templates style libraries highly successful c examples standard template library 35 boost graph library 33 matrix template library 34 work generic programming haskell also illustrates need typedependent data representations 18 17 2 addition implementing selfoptimising libraries associated types also useful abstract interfaces applications functional dependencies shall discuss abstract interfaces subsection 23 21 selfoptimising finite maps nice example data structure whose representation changes dependence type parameter first discussed hinze 16 subsequently used example typeindexed types hinze jeuring loh 18 context generic haskell generalised tries generic finite maps maps change representation dependence structure key type k used index map express idea defining type class mapkey parameterised key type associated type map one components class mapkey k data map k v empty map k v lookup give two class operations empty lookup reality would many addition key type finite maps parametrised value type forms codomain map representation generic finite maps depends type k keys parametric value type v express dierent status key type k value type v making k class param although associated representation type map k v depends types assuming suitable library implementing finite maps integer trees patricia trees 31 may provide instance mapkey integer keys follows instance mapkey int data map int lookup k mi patricialookupdict k instance dierent treatment key value types obvious fix key type instance still leaving value type open words regard map k typeindexed type constructor kind described detail hinze 16 define generic finite maps arbitrary algebraic data types simply giving instances mapkey unit product sum types followsfor detailed motivation defi nition please see hinzes work instance mapkey data map nothing lookup unit mu lookup unit mu instance mapkey mapkey b mapkey b data map b lookup b mp instance mapkey mapkey b mapkey either b data map either b nothing nothing lookup left fm1 lookup fm1 lookup right b fm1 use class mapkey specific algebraic data type need map productsum representation means embeddingprojection pair 19 18 2 22 generic graphs concept traits introduced c aim reducing number parameters templates 27 since generic programming based templates traits found useful selfopti mising libraries 33 choice data representation well algorithms guided way type instantiation led investigation support style generic programming range dierent languages garcia et al 11 evaluation garcia et al based comparative implementation graph library concluded haskell excellent support generic programming exception satisfactory support associated types extension proposed paper tackles shortcoming headon inspired garcia et al also use class graphs example class graph g data edge g data vertex g outedges vertex g g edge g contrast arrayelem mapkey examples container type depended element type vertex edge type depend container type allows us define several distinct instances graphs edge vertex types dier representation algorithms working data structure two possible instances model vertexes integers edges pairs source target vertex still represented dierently adjacency matrix newtype instance graph g1 data vertex data edge maps vertexes neighbours newtype instance graph g2 data vertex data edge apart added flexibility associated types lead two distinct advantages first traits reduce number parameters class second contrast class parameters refer associated types names position argument list improves readability reduces potential confusing order arguments 23 interface abstraction previous examples used associated types selfop timising libraries specialising data representations algorithms typedirected manner entirely dierent application defining abstract interfaces unlike abstract base classes c interfaces java signatures standard ml wellknown example interface motivated haskells hierarchical standard library monad based state transformer supports mutable refer ences base interface parametrised family types follows class monad refm data instance refm io data ref io instance refm st data note type parameter associated type ref well representation type ref higher kindthat kind complete signature newref newref subtlety code definition ref io v introduces new type haskells type equality compatible ioref v however sometimes might like use existing type associated type instead introducing new type requires associated type syn onyms plan discuss future paper 3 associated section describe proposed language extension enough detail user language technical details type system deferred section 4 propose type class may define addition set methods set associated data types class declaration data types declared without definitions definitions given instance dec larations associated data type must parameterised type variables class type variables must come first order class type variables rationale restriction given section 44 associated data type introduces new type construc tor kind type constructor inferred obvious way also allow explicit kind signatures type parameters class c data b instance declarations must give single definition associated data type class definition must repeat class parameters instance additional parameters data type must left type variables following legal instance c class instance c c data instance declaration associated data types introduces new data constructors toplevel scope example data constructor introduced following type instance associated data type may use newtype declaration instead data declaration single constructor single field enables compiler represent datatype without intervening constructor runtime 31 types involving associated data types type constructor introduced associated data type declaration thought typeindexed type representation dependent instantiation pa rameters use haskells existing overloading machinery resolve types close analogy methods class associated data types methods introduce overloaded typeindexed variables associated data type declarations introduce typeindexed types expression refers overloaded identifiers requires instances available context supplied true types going back array example introduction consider f array bool bool system declares valid type signature instance arrayelem bool similarly f array e e invalid representation array e unknown make type valid supply context f arrayelem e array e e validity check programmersupplied type annotations conveniently performed part kindchecking annotations one restriction use associated type constructor wherever type constructor appears must applied least many type arguments class parameters surprising stated dierent way typeindexed type must always applied index parameters 32 associated types data declarations consistency system must support using associated types everywhere including within definition another data type however interesting conse quences consider array example suppose wish define new data type data discussed type array e valid type e must add context declaration data arrayelem e haskell supports contexts data declarations whose eect add context type data constructor makes satisfy validity principle type constructor ordinary type construc tor behaves similar way associated type whenever e appears type must appropriate context instances order deduce arrayelem e furthermore must always applied typeindexed arguments toplevel function calls overloaded functions becomes overloaded data type mentions typeindexed types becomes type indexed call typeindexed data types associated toplevel types 33 translation example important feature system explain translation explicitly typed target language akin system f give idea walk translation mapkey example section 2 recall class declaration mapkey class class mapkey k data map k v empty map k v lookup translation new data type cmapkey type dictionaries mapkey class data cmapkey k mk empty forall v mk v lookup forall v k mk v maybe v cmapkey type type parameter class type variable usual case single type variable k however also extra type parameter mk representing associated type map k instance class give dierent instantiation type map k dictionary must abstract type note mk kind type variable v still unconstrained one class type variables deed class methods empty lookup explicitly parametric polymorphic type variable first instance instance integer keys instance mapkey int data map int lookup k mi patricialookupdict k translation new datatype associated type dictionary value data mapint dmapint cmapkey int mapint lookup k mi patricialookupdict k next consider instance pairs instance mapkey mapkey b mapkey b data map b lookup b mp lookup b lookup translation new datatype dictionary function data mappair mb dmappair forall b cmapkey cmapkey b mappair mb dmappair da lookup b mp lookup db b lookup da new datatype mappair takes two additional type ar guments mb representing types map respectively instance context translation dictionary function taking dictionaries mapkey mapkey b arguments delivering dictionary value translation either instance doesnt illustrate anything new omitted instead give translation example function making use overloaded lookup translation looks like f forall v mk cmapkey mk mappair mk mapint v v note translating type map int v instances mapkey b mapkey int must con sulted must consulted infer mapkey int depends mapkey construct dictionary mapkey int value translation 34 definitions haskell class method given default definition declaration class instance omits specific definition method inherit default unfortunately cannot provide similar facility associated data types see consider arrayelem example introduction lets add hypothetical default definition array associated type class arrayelem e data array index array e int e type defaultarray constructor presumably given type defaultarray arrayelem e boxedarray e array e cannot type constructor valid instances arrayelem give specific definitions array type correct type give constructor default definition 4 type system translation section formalise type system lambda calculus including type classes associated data types extend typing rules include translation source programs explicitly typed target language akin predicative fragment system f type system based jones overloaded ml oml 20 21 associated data types change typing rules fundamental way however require substantial extension dictionary translation type classes 41 syntax syntax source language given figure 1 use overbar notation extensively notation n means sequence 1 n n may omitted unimportant moreover use comma mean sequence extension follows n an1 n1 although give syntax qualified quantified types curried way also sometimes use equivalent overbar notation thus accommodate function types 1 2 regarding curried application function type constructor two arguments thus 1 2 source language three unusual features first class declarations may contain data type signatures addition method signatures correspondingly instance declarations may contain data type declarations addition method implementations data types associated types class syntactically separated type variable type class associated type c data constructor source declarations pgm data cls inst val whole program data data data cls class class decl inst instance instance decl adata val val dsig data assoc type sig adata data data type source terms let source types qualified type type scheme constraints qualified constraint constraint scheme environments instance environment figure 1 syntax expressions types type constructors ranged rather sec ond syntactically distinguish two forms toplevel data type declaration ordinary ones toplevel associated types mention associated types righthand side see section 32 declaration associated types whether class declaration toplevel data declara tion type indexes must come first third syntax types includes saturated application associated type type indexes type arguments way 1 2 production make following simplifying assumptions reduce notational burden class exactly one type parameter one method one associated type toplevel associated type exactly one type index parameter data type single constructor furthermore rather treat case expressions assume constructor c comes projection function prj c selects ith argument constructor c treat superclasses target declarations target terms target types environments dictionary environment associatedtype environment figure 3 syntax target terms types loosening restrictions largely matter adding great many overbars typing rules introducing superclasses slightly less trivial section 45 discusses 42 type checking key feature system typing rules expressions close haskell 98 present figure 2 judgement e means type environment instance environment expression e type rules absolutely standard damasmilner type system except e former allows us abstract constraint latter allows us discharge constraint provided entailed environment latter judgement also given figure 2 also entirely standard 21 auxiliary judgement used rules e kindchecking judgement used system guesses type ensure type well kinded interests brevity however rules figure 2 elide mention kinds leaving wellformedness check distinctive system specifi cally wellformed type every associated type must context satisfies classes associatedthere one case associated toplevel data types side condition rejects cf section 31 example typing typing invalid associated type array meaningless without corresponding arrayelem con straint array simply defined types kind subset arrayelem instance akin simple form refinement kinds 9 rules class instance declarations quite standard possibility one type declarations class omit details form part elaborate rules give next however reason type wellformedness judgement specified work type schemes rather monotypes needed check validity types class methods 43 evidence translation second crucial feature system like haskell translated system f augmented data types without adding associatedtype extensions target language gave example translation section 33 formalise translation 431 evidence translation terms main judgement means environment source term e type translates target term w figure 5 rules judgement given figure 5 part wellknown elaboration rules figure target term w explicitlytyped style system f syntax given figure 3 main typing judgement derives source type whereas target term decorated target types programmer sees source types include qualified types applications associated types contrast target type mentions data types qualified types associated types appear instance environment plain typechecking rules split two components see figure 3 dictionary environment associates dictionary dictionaryproducing function constraint scheme otherwise contains information old wellformedness judgement figure 2 used rules e becomes type translation judgement translates source types target types type translation driven associatedtype environment discuss type translation section 432 returning rules terms interesting cases rules e must deal associated types rule abstract type variable stands associated type ie one directly associated class mentioned associated toplevel types need abstracted moreover need extend dictionary environment reflect constraint satisfied environment including witness hence augment typetranslation environment explain associated type called may rewritten dually rule e applies target term w1 witness type well witness term w2 witness types derived judgement witness terms derived given figure 4 432 translating types translation source types target types formalised judgement figure 4 eliminates applications associated types consulting associatedtype environment judgement relates wellformedness judgement figure 2 way typing relates e motivate rules type translations copied section 33 cmapkey mapp air mapint spec associated type var let e e e figure 2 standard type checking rules expressions tr tr tr fv associated type e associated type mono figure 4 translating types first example straightforward arises directly instance declaration mapkey int going second example class constraint translated ordinary function argument type cmapkey data type cmapkey type dictionaries class mapkey generated translating class declaration crucial point data type takes extra type parameter associated type class one correspondingly must quantify new type well type map int first translated mappair map map int applying translation scheme added translating instance declaration pairs map int translated mapint map precisely associated type class mapkey translated associatedtype environment therefore contains two kinds assumptions figure 3 first instance declaration get assumption form let e e figure 5 typing rules translation associated data type corresponding target data type example consider instances class mapkey section 33 instances int pairs augment assumptions 12 map 1 2 see details extended way discuss rule instance declarations next section second midst translating type extend local assumptions form denoted rule tr figure 4 also figure 5 example moving inside mapkey qualifier example add assumption map whenever need extend local assumptions form use judgement figure 4 judgement abstracts associated type introducing new type variable represents associated type also provides application associated type class instance corresponding dictionary type 433 data type value declarations rules typedirected translation declarations given figure 6 somewhat complex largely notational overheads much complexity also present vanilla haskell 98 real work done however whole point programmer sees haskells type system less unchanged implementation good deal paddling water implement associated types translation vanilla data type declarations easy need translate constructor argument types using auxiliary typetranslation judgement handling associated toplevel data types involved treatment closely mirrors associated types instance declarations discuss value declarations also straightforward work done figures 4 5 434 class declarations interesting cases class instance declarations may help refer back example section 33 reading rules noted class declaration class translated data type declaration also named whose data constructor called cd data type used represent dictionary class constructor class methods signature argument type suitably translated course translation uses associatedtype environment maps associated type fresh type variable data type must parameterised fresh presumably free translated method types finally must generate binding method selector function class method f rule implemented corresponding projection functions prj cd addition target declarations defining data type dictionary method selector functions rule cls produces environment giving source types class methods impose restriction method types haskell namely constraints method type must constrain class parameter lifting restriction would permit classes like one class op c constraint c constrains class variable functionaldependency setting classes like known tricky situation us paper simply exclude possibility 435 instance declarations instance declarations involved associated type class must generate fresh data type declaration implements associated type instance type data type must parameterised quantified type variables instance declaration b type variable associated type constraint instance declaration c type variables associated type parametric instances artificial example demonstrate possibilities class mk k data instance mk mk b mk b data data type arises instance declaration data td data c data r data r r c adata class data data inst td r r r r instance r data data r c c r c inst val td data inst figure declaration typing rules translation following data b mb arguments mb b may needed see example optimisation unused translated right hand side declaration omitted typeparameter list produce righthand sides c c instances associated type declarations need replace applications associated types newly introduced type parameters achieved associatedtype environment hypothesis addition promoting associated data type become fresh toplevel data type declaration rule inst also returns conclusion tiny associatedtype environment dictionary environment embody information instance declaration use rest program b tiny type environment embodies types new data constructor c concludes hard part instance declarations generation dictionary function f extension dictionary environment exactly vanilla haskell 436 tying knot final judgement figure 6 glues together judgements types classes instances value declarations rule highly recursive associatedtype environ ment produced type checking instance declara tions consumed judgement three judgements similarly four judgements produce fragment environment consumed judgements instance value declarations good reason recursion example consider data type g1 section 22 constructor mentions type vertex g1 translation type comes instance declaration practice implementation must unravel recursion somewhat new extension makes slightly harder example haskell 98 one typecheck instance declaration heads part generate top level check value declarations generate take second run instance declarations time checking method bodies instance declarations one class may needed typecheck class declaration another class associated types former appear method type signatures latter none rocket science unwelcome complication 44 associated type parameters section 3 specified type parameters associated type identical parent class plus optional extra parameters see class parameters must occur first insist associatedtype applications saturated wrt class parameters turn ensures type translation described proceed without concern partial applications without clutter arising extra could principle permit associated type permute parent class parameters one cost extra notational bureaucracy inst rule seems benefit could also principle allow associated type mention subset parent class parameters would need make extra tests ensure instance declarations overlap taking account selected class parameters ensure type translation described confluent test must made functional dependencies employed benefit seem justify cost formalisation type system evidence translation take superclasses account ie context head class declaration made simplification interest clarity formal rules nevertheless subtlety respect translation associated types classes super classes rule cls figure 6 see generated dictionary data type type argument corresponds associated type class general multiple associated types hence multiple type arguments class superclasses contain associated types associated types needs appear argument dictionary words similar dictionaries superclasses must embedded classs dictionary associated types superclasses need also embedded 46 soundness evidence translation maps programs typed source typed intermediate language expect generate well typed programs expectation met asserted formal results sketched following full details companion technical report type checking target declarations td target terms w denoted f td f w respectively target type environment target type type checking rules standard type passing lambda calculus omitted space reasons moreover lift type translation judgement pointwise translate source target environments theorem 1 given type translation environment dictionary environment type environment source term e type translates environment asf f f w proof proof proceeds rule induction target term producing translation rules tricky cases rules e abstract types associated class context supply corresponding representation types respectively moreover need make use auxiliary properties judgments figure 4 theorem 2 given source program pgm translate pgm td resulting target program well proof proof considers target declaration producing rules figure 6 turn demonstrates type environment produced source program corresponds produced target program type translation judgement theorem 2 sucient ensure soundness provides strong indication translation sound 5 comparisontofunctionaldepen dencies functional dependencies 22 experimental addition multiparameter type classes introduce functional relationship dierent parameters type class similar class parameters associated types indeed extra type parameters introduced implicitly systemf translation appear explicitly program expressed using functional dependencies example using fds one might express array example like class arrayrep e arr e arr index arr int e functional dependency e arr restricts binary relation arrayrep function element types e representation types arr instance declarations populate relation represented arrayrep words associated type provided extra argument class instead local consequently corresponding instance declarations local type definition replaced instantiation second parameter class arrayelem methods omitted instance arrayrep int uintarr instance arrayrep arr arrayrep b brr use functional dependencies describe typeindexed data types suers three serious shortcomings shall discuss next hand functional dependencies used situations associated data types cannot however appears conjunction associated type synonyms might cover major applications functional dependencies future work show whether indeed case undecidable type constraints duck et al 8 point instance pairs arrayrep b arr brr problematic type variables arr brr occur first argument b type constraint instances accepted type inference presence functional dependencies becomes undecidable pre cisely diverges certain terms rejected type incorrect jones 22 original proposal functional dependencies allow instances clutter comparative study garcia et al 11 mentioned section 22 haskell receives full marks categories except treatment associated types type classes functional dependencies essence requirement make associated types extra parameters type classes results complicated less readable code illustrated parameter arr type class arrayrep extra parameters appear signatures involving associates types quite large terms involved examples graph library discussed garcia et al lack abstraction would expect define typeindexed arrays module hide concrete array representation user module however encoding based functional dependencies allow level abstraction see case consider full type index func tion namely index arrayrep e arr arr int e avoiding use knowledge arrays integers represented would expect able define indexint arrayrep int arr arr int int however definition admissible type signature considered instance type inferred function body presence functional dependency e arr cf class declaration arrayrep fact forced use following definition instead indexint uarrint int int clearly breaks intended abstraction barrier fact suggests functional dependencies threaten usual type substitution property root problem lies deep consequence evidence translation type classes would expect system f term coerces translation indexint translation indexint however coercion exists would require nonparametric operation present system f 13 variations functional dependencies duck et al 8 propose liberal form functional dependencies recursive instances arrayrep lead nontermination however also require radically dierent form type checker based hmx 30 framework constraint handling rules stuckey sulz mann 36 introduce implementation multiparameter type class functional dependencies depend dictionary translation result avoid problems original form functional dependencies neubauer et al 28 introduce functional notation type classes single functional dependency much like parametric type classes 3 ever proposal syntactic sugar functional dependencies translate new form classes multiparameter classes functional dependency passing type checker authors ambitious second proposal 29 add fullblown functional logic language type sys tem based hmx 30 framework neubauer et al address issue suitable evidence translation means infer types compile programs 6 related work type classes significant amount previous work studies relationship type classes typeindexed functions 37 19 1 23 24 mostly purpose expressing generic functions using standard type classes alone chen et al 3 proposed parametric type classesie type classes type parametersto represent container classes overloaded constructors selectors provide type system type inference algorithm present evidence translation parametric type classes unlike type class single associated type synonym generic haskell hinze et al 16 18 propose translation typeindexed data types based type specialisation procedure eorts culminated generic haskell preprocessor translates code including typeindexed types functions haskell including type system extensions rankn types pay special attention typeindexed data types structurally defined map type section 21 automatically perform mapping standard haskell data type definitions representation based binary sums prod ucts recent work loh et al 26 elaborated original design introduced dependencystyle generic haskell fact translation associated types additional type parameters akin translation typeindexed types generic haskell associated types lightweight extension haskell miss automatic generation embedding projection pairs ml modules repeatedly observed significant overlap functionality haskell type classes standard ml modules introduction associated types increased overlap ml modules always agglomeration values types nevertheless interesting dierences type classes ml modules particular ml structures termlevel entity hence notion phase distinction 14 required separate static dynamic semantics leroy 25 proposing variant contrast type classes purely static concept part due involvement term level mls higherorder modules give rise rich design space 7 far clear dierent concepts relate type classes despite dif ferences introduction associated types shows commonality type classes ml modules may significant previously assumed hence would worthwhile investigate relationship detail intensional type analysis intensional type analysis 15 realises typeindexed types typelevel typerec construct proposed facilitate typepreserving optimisation polymorphism subsequent work 32 6 5 38 elaborated harper morrisetts seminal work already outlined relationship type classes conceptual dierence intensional type analysis type classes former based explicit runtime representation types whereas target language evidence translation standard typeerasure semantics nevertheless crary et al 6 proposed alternative view intensional type analysis based type erasure need pass method dictionaries runtime regarded implicit type representation constrained data types xi et al 39 introduce typeindexed data types annotating constructor data type declarations type pattern call guard present type system establish soundness internal language typeindexing explicit contrast approach typeindexing removed evidence translation phase call elab oration cheney hinzes 4 present slightly generalised version guarded data types permitting equational type constraints various alternatives data type decla ration approaches dier classbased approach typeindexed data types opena new class instance always addedwhereas closed data type declarations cannot extended refinement kinds section 42 said understand type constraint form restriction range variable ie ranges subset types characterised kind particular restricts term welldefined entire range associated type subkinding relationship related duggans notion refinement kinds 9 ever duggan considers typeindexed functions typeindexed types objectoriented languages mentioned section 22 associated types long standing tradition c often collected traits classes 27 garcia et al 11 compared support generic programming c standard ml haskell eiel generic java generic c exists plethora work generic programming objectoriented programming languages beyond scope paper review 7 conclusions propose include type declarations alongside value declarations haskell type classes associated types type class especially useful implementing self optimising libraries also serve implement abstract interfaces concepts functional dependencies used past case associated data types demonstrated dictionarybased evidence translation standard implementing type classes elegantly extended handle associated types particular target language aected extension source language future work hope extend mechanism associated data types associated type synonyms generalisation substantial implications due introducing additional nonsyntactic equalities type level plan investigate feasibility generic default methods 19 classes involving associated types acknowledgements thank amr sabry discussions previous version approach pointing us work garcia et al thank roman leshchin skiy detailed feedback work sharing insights generic programming c particularly thank martin sulzmann detailed constructive comments earlier drafts paper also thank dave abrahams brian mcnamara jeremy siek interesting email exchange comparing haskell type classes c classes thank robert harper greg mor risett andre pang anonymous referees feedback previous version paper 8 r generic programming extension clean approach fast arrays haskell parametric type classes flexible type analysis intensional polymorphism typeerasure semantics type system higherorder modules sound decidable type inference functional dependencies dynamic typing distributed programming polymorphic languages static semantics haskell comparative type classes haskell parametricity variants girards j operator compiling polymorphism using intensional type analysis generalizing generalized tries generic haskell applications derivable type classes fpca system constructor classes overloading implicit higherorder polymorphism type classes functional dependencies sketch polymorphic symphony scrap boilerplate practical approach generic programming manifest types traits new useful template technique functional notation functional dependencies functional logic overloading type inference constrained types fast mergeable integer maps flexible representation analysis boost graph library user guide reference manual matrix template library generic components highperformance scientific computing standard template library theory overloading guarded recursive datatype constructors tr ctr manuel chakravarty gabriele keller simon peyton jones associated type synonyms acm sigplan notices v40 n9 september 2005 louisjulien guillemette stefan monnier typesafe code transformations haskell electronic notes theoretical computer science entcs v174 n7 p2339 june 2007 derek dreyer robert harper manuel chakravarty gabriele keller modular type classes acm sigplan notices v42 n1 january 2007 martin sulzmann gregory j duck simon peytonjones peter j stuckey understanding functional dependencies via constraint handling rules journal functional programming v17 n1 p83129 january 2007 gabriel dos reis bjarne stroustrup specifying c concepts acm sigplan notices v41 n1 p295308 january 2006 manuel chakravarty roman leshchinskiy simon peyton jones gabriele keller simon marlow data parallel haskell status report proceedings 2007 workshop declarative aspects multicore programming p1018 january 1616 2007 nice france jaakko jrvi douglas gregor jeremiah willcock andrew lumsdaine jeremy siek algorithm specialization generic programming challenges constrained generics c acm sigplan notices v41 n6 june 2006 martin sulzmann manuel chakravarty simon peyton jones kevin donnelly system f type equality coercions proceedings 2007 acm sigplan international workshop types languages design implementation january 1616 2007 nice nice france james cheney scrap nameplate functional pearl acm sigplan notices v40 n9 september 2005 ralf lmmel klaus ostermann software extension integration type classes proceedings 5th international conference generative programming component engineering october 2226 2006 portland oregon usa jeremy g siek jeremy siek andrew lumsdaine essential language support generic programming acm sigplan notices v40 n6 june 2005 ronald garcia jaakko jarvi andrew lumsdaine jeremy siek jeremiah willcock extended comparative study language support generic programming journal functional programming v17 n2 p145205 march 2007 douglas gregor jaakko jrvi jeremy siek bjarne stroustrup gabriel dos reis andrew lumsdaine concepts linguistic support generic programming c acm sigplan notices v41 n10 october 2006 jaakko jrvi jeremiah willcock andrew lumsdaine associated types constraint propagation mainstream objectoriented generics acm sigplan notices v40 n10 october 2005 paul hudak john hughes simon peyton jones philip wadler history haskell lazy class proceedings third acm sigplan conference history programming languages p1211255 june 0910 2007 san diego california
specification verification synthesis concurrency control components runtime errors concurrent programs generally due wrong usage synchronization primitives monitors conventional validation techniques testing become ineffective concurrent programs since state space increases exponentially number concurrent processes paper propose approach 1 concurrency control component concurrent program formally specified 2 verified automatically using model checking 3 code concurrency control component automatically generated use monitors synchronization primitive control access shared resource multipleconcurrent processes since approach decouples concurrency control component rest implementation scalable demonstrate usefulness approach applying case study airport ground traffic controlwe use action language specify concurrency control component system action language specification language reactive software systems supported infinitestate model checker verify systems boolean enumerated udbounded integer variables code generation tool automatically translates verified action language specification java monitor translation algorithm employs symbolic manipulation techniques specific notification pattern generate optimized monitor class eliminating context switch overhead introduced result unnecessary thread notification using counting abstraction show automatically verify monitor specifications arbitrary number threads b introduction writing concurrent program error prone task concurrent programmer keep track possible values variables program also states concurrent processes failing use concurrency constructs semaphores monitors correctly results runtime errors deadlocks violation safety properties conventional validation techniques testing become ineffective concurrent programs since state space concurrent program increases exponentially number variables number concurrent processes monitors programming language construct introduced ease difficult task concurrent programming 14 structured programming languages help programmers keeping track states program variables providing abstractions procedures associated scoping rules localize variable access monitors similar mechanism structuring concurrent programs provide scoping rules concurrency since monitors integral part java recently concurrent programming using monitors gained increased attention 16 monitor consists set variables shared among multiple processes set associated procedures accessing shared variables monitor accessible outside procedures time one process allowed active monitor processes synchronize using specific operations lets wait ie sleep receive signal another process wait signal operations coordinated using condition vari ables even though monitors provide better abstraction concurrent programming compared constructs semaphores still error prone coordinating wait signal operations several condition variables among multiple processes challenging even implementation simple algorithms paper propose new approach developing reliable concurrent programs first aspect approach start specification concurrency control component program rather implementation use monitors underlying concurrency control prim itive present monitor model action language 4 action language specification language reactive software systems supports synchronous asynchronous compositions hierarchical specifications show monitors specified action language using asynchronously composed modules monitor model action language one important aspect rely condition variables semantics action language lets us get rid condition variables associated wait signal operations simplifies specification monitor significantly important component approach use automated verification tool checking properties monitor specifications action language supported infinitestate model checker verify falsify producing counterexample behaviors invariance liveness ctl properties action language specifications 6 paper focus verification monitor invariants however approach presented paper extended universal portion temporal logic ctl infinitestate systems specified action language model checking undecidable hence verifier uses various heuristics guarantee convergence produce false positives false negatives analysis inconclusive last component approach code generation algorithm synthesizing monitors action language specifications goal generating complete programs rather proposing modular approach generating concurrency control component program manipulates shared resources use case study airport ground traffic control 21 show effectiveness scalability tech nique case study uses fairly complex airport ground network similar seattle tacoma international air port model checker verify safety properties specification case study code generation tool automatically generates optimized java class terms context switch overhead would incurred multithreaded application recently several attempts adopting model checking verification concurrent programs 8 13 approaches translate concurrent java program finite model check using available model checking tools hence rely ability model checkers cope state space explosion problem however date model checkers powerful enough check implementations concurrent programs hence recent work verification concurrent programs efficient model construction concurrent programs 8 13 11 approach provides different direction creating reliable concurrent programs several advantages 1 avoids implementation details program relate property verified 2 model construction problem since specification language used model checker associated pushing verification earlier stage software development specification phase rather implementation phase reduces cost fixing bugs however approach unlikely scale generation complete programs would require specification language expressive would introduce model construction problem specification stage hence focus synthesizing concurrency control components correct construction integrated concurrent program safely another aspect approach different previous work fact using infinite state model checker rather finite state techniques using infinite state model checker verify properties specifications unbounded integer variables arbitrary number threads work review independently deng et al also presented approach combines specification synthesis verification concurrent programs 12 one crucial difference approach approach presented 12 apparent otherwise remarkably similar titles approach automated verification performed specification implementation hence approach shields automated verification tool implementation details rest paper organized follows section 2 describe case study section 3 explain concurrency control monitors implementation java section 4 using case study discuss monitors specified action language also present general template specifying monitors action language section section 5 discuss monitor specifications automatically verified using action language ver ifier also show using counting abstraction monitor specifications verified arbitrary number threads section 6 present algorithms automatically generating java monitor classes monitor specifications finally section 7 state conclusions directions future work 2 airport ground traffic control case study present airport ground traffic control case study demonstrate techniques proposed pa per airport ground traffic control handles allocation airport ground network resources runways taxiways gates arriving departing airplanes airport ground traffic control safety critical 515 hull loss accidents 1959 1996 associated airport ground operations taxi takeoff landing 1 simulations play important role airport safety since enable early prediction possible runway incursions growing problem busy airports throughout world 21 presents concurrent simulation program modeling airport ground traffic control using java threads paper demonstrate concurrency control component program formally spec ified automatically verified synthesized frame work use airport ground network model used 21 shown figure 1 similar seattletacoma international airport two runways 16r 16l runway 16r used arriving airplanes landing landing arriving airplane takes one exits c3c8 taxiing c3c8 arriving airplanes need cross runway 16l crossing 16l continue one taxiways b2 b7 b9b11 reach gates park departing airplanes use runway 16l takeoff control logic ground traffic airport must implement following rules 1 airplane land takeoff using 16r 16l airplane using 16r 16l moment 2 airplane taxiing one exits c3c8 cross runway 16r runway 16l figure 1 airport ground network similar seattle tacoma international airport runway 16l airplane taking moment 3 airplane start using 16l taking none crossing exits c3c8 occupied mo ment arriving airplanes priority departing airplanes 4 one airplane use taxiway time give action language specification airport ground traffic control system section 4 section 5 discuss used action language verifier automatically verify properties system section 6 show java monitor class synthesized action language specification 3 concurrency control monitors monitor synchronization primitive used control access shared resource multiple concurrent processes monitor consists set variables procedures following rules 1 variables monitor accessed procedures monitor execute procedures monitor time view second rule monitor mutual exclusion lock process monitor lock active monitor process calls monitor procedure acquire monitor lock executing procedure release exits synchronization provided implicitly monitor semantics hence programmer explicitly write acquire lock release lock operations monitors provide additional synchronization operations among processes based condition variables two operations condition variables defined wait signal process performs wait operation condition variable sleeps releases monitor lock awakened signal operation condition variable waiting process awakened reacquire monitor lock resumes operation waiting processes signal operation ignored forgotten ie affect processes execute wait later wait signal operations implemented using one wait queue per condition variable process executes wait operation condition variable enters corresponding wait queue signal operation condition variable removes one process corresponding wait queue resumes operation af ter reacquiring monitor lock signal continue semantics signal operation signaling process keeps monitor lock exits waits different semantics additional operations also used signaling signal wait semantics signalall operation 3 typically condition variables used execute set statements guarding condition becomes true achieve condition variable created corresponds guarding condition process execute guarded statements tests guarding condition calls wait corresponding condition variable guarding condition false process executes statement change truth value guarding condition signals processes waiting corresponding condition variable state monitor represented variables set states safe monitor expressed monitor invariant 3 monitor invariant expected hold process accessing monitor ie guaranteed hold process active within monitor procedure 31 monitors java java objectoriented programming language supports concurrent programming via threads monitors java object mutual exclusion lock monitor java implemented using object locks synchronized keyword block statements declared synchronized using lock object synchronizedo f g block executed lock object acquired methods also declared synchronized equivalent enclosing method within synchronized block using object ie synchronizedthis f g monitor object java created declaring class private variables correspond shared variables monitor monitor procedure declared synchronized method meet mutual exclusion requirement wait signal operations implemented wait notify methods java however java object one wait queue means notify call waiting process monitor wake one condition processes waiting awakened processes recheck conditions waiting note process waiting different condition awakened notify call lost prevented using notifyall method wakes waiting processes using single wait queue notifyall method one safely implement monitors java however implementation efficient get better efficiency one use objects declared members monitor class condition variables together synchronized blocks objects since object lock associated wait queue makes possible put processes waiting different conditions different queues however implies one lock used monitor addition monitor lock one lock per condition variable use multiple locks java monitor classes prone deadlocks errors 16 4 specification monitors although monitors provide higher level abstraction concurrent programs compared mechanisms semaphores still tedious difficult im plement argue action language used specify monitors higher level abstraction monitor specifications action language rely condition variables since action language action executed guard evaluates true need conditional waits figure 2 shows action language specification airport ground traffic control case study action language specification consists set module definitions module definition consists variable declarations restrict expression initial expression submodule definitions action definitions module expression semantically module corresponds transition system set states set initial states transition relation variable declarations define set states module figure 2 implemented shared resources airport ground traffic control runways taxi ways integer variables variables numrw16r numc3 denote number airplanes runway 16r taxiway c3 respectively use enumerated variables local variable pc submodule airplane encode states airplane arriving airplane one following states arflow touchdown taxitoxy taxifrxy parked state arflow denotes airplane air approaching airport state touchdown denotes airplane landed runway 16r state taxitoxy denotes airplane currently taxiway going cross runway x state taxifrxy denotes airplane currently taxiway crossed runway x finally state parked denotes airplane parked gate similarly departing airplane one following states parked takeoff depflow state parked denotes airplane parked gate state takeoff denotes airplane taking runway 16l state depflow denotes airplane air departing airport action language modular language action language specification defined terms hierarchy modules figure 2 module main submodule airplane submodule airplane models arriving departing airplanes corresponds process type thread class java submodule airplane one local boolean variable pc used keep track states airplane note instantiation module create different instantiations local variables set states restricted using restrict expression figure 2 variables numc3 numrw16r numrw16l restricted greater equal 0 initial expression defines set initial states module instance figure variables numrw16r numrw16l numc3 initialized initial restrict expressions submodules conjoined initial restrict expressions main module obtain overall initial condition restrict expression respectively behavior module ie transition relation defined using module expression module expression starts name module written combining actions submodules using asynchronous denoted andor synchronous denoted composition opera tors instance module airplane defined terms asynchronous composition actions reqland exitrw3 module main defines transition relation overall system defined terms asynchronous composition multiple instantiations submodule airplane specification figure 2 specifies system two airplane processes figure 2 asynchronous composition used atomic action action language defines single execution step action expression action primed range variables rvara denote nextstate values variables unprimed domain variables dvara denote currentstate values instance action exitrw3 module airplane indicates arriving airplane touchdown state pctouchdown taxiway c3 available numc30 next state runway 16r one less airplane numrw16rnumrw16r1 taxiway c3 used one airplane numc3numc31 airplane state pctaxito16lc3 note airplane taxiing taxiway runway 16l route continues taxiway b2 see figure 1 asynchronous composition two actions defined disjunction transition relations however also assume action preserves values variables modified formally extend action expression expa1 action a1 conjoining frame constraint exp 0 a1 denotes set difference similarly extend expression a2 expa2 exp 0 a2 define expa1 a2 asynchronous composition two modules defined similarly figure monitor invariants expect system satisfy written using spec invariant next keywords end main module action language keywords invariant eventually next synonyms ctl operators ag af ax respectively specification given figure 2 specifies solution airport ground traffic control without specifying details implementation monitor high level specification compared monitor implementation sense introduce condition variables waiting signaling operations error prone give general template specifying monitors action language figure 3 consists main module list submodules variables main module denoted varm define shared variables monitor specification currently available variable types action language boolean enumerated inte ger restriction comes symbolic manipulation module main integer numrw16r numrw16l numc3 initial numrw16r0 numrw16l0 numc30 restrict numrw16r0 numrw16l0 numc30 module airplane enumerated pc arflow touchdown parked depflow taxito16lc3 taxito16lc4 taxito16lc5 taxito16lc6 taxito16lc7 taxito16lc8 taxifr16lb2 taxifr16lb7 taxifr16lb9 taxifr16lb10 taxifr16lb11 takeoff initial pcarflow pcparked reqland pcarflow numrw16r0 pctouchdown exitrw3 pctouchdown numc30 numc3numc31 numrw16rnumrw16r1 pctaxito16lc3 crossrw3 pctaxito16lc3 numrw16l0 numb2a0 pctaxifr16lb2 numc3numc31 reqtakeoff pcparked numrw16l0 numc30 numc40 numc50 numc60 numc70 numc80 pctakeoff leave pctakeoff pcdepflow airplane reqland exitrw3 crossrw3 endmodule spec invariantnumrw16r1 numrw16l1 spec invariantnumc31 spec invariantnextnumrw16l0 notnumrw16l0 endmodule figure 2 action language specification airport ground traffic control case study capabilities action language verifier extended discuss 15 also allow declaration parameterized constants example declaration parameterized integer size would mean size unspecified integer constant ie specification constant verified verified possible values size submodule corresponds process type ie instantiation submodule corresponds process submodule set local variables varm atomic actions actm note monitor specification goal model behavior process relevant properties monitor therefore local variables varm submodule include variables relevant correctness mon itor transition relation submodule defined asynchronous execution atomic actions simplify abstraction code generation algorithms present following sections restrict form action expressions follows given action 2 actm expa written expa j l r l dsa rsa l expression unprimed local variables module l expression primed unprimed local variables dsa expression unprimed shared variables varm rsa expression module enumerated parameterized integer restrict restrictcondition initial initialcondition module integer boolean enumerated restrict initial 1 1 endmodule module mn endmodule spec monitorinvariant endmodule figure 3 monitor template action language primed unprimed shared variables example action exitrw3 figure 2 l j pctouchdown r l j pctaxito16lc3 template given figure 3 transition relation main module defined asynchronous composition submodules defines behavior overall system 5 verification monitor action language verifier 6 consists 1 compiler converts action language specifications composite symbolic representations 2 infinitestate symbolic model checker verifies falsifies ctl properties action language specifications action language compiler translates action language specification transition system consists state space set initial states transition relation r theta unlike common practices model checking infinite r may total ie maybe states 2 exist 0 0 r infinite state systems specified action language model checking undecidable action language verifier uses several heuristics achieve convergence approximations based truncated fixpoint computations widening loopclosures approximate reachability anal ysis since allow nontotal transition systems also fixpoint computations modified 6 monitor model given figure 3 state space obtained taking cartesian product domains shared variables main module varm domains local variables submodule varm instantiation transition relation r overall system defined r ijk r ijk corresponds action expression action ak instantiation j module action language parser renames local variables submodule instantiation j obtain r ijk also explained action expressions automatically transformed action language parser adding frame constraints un modified variables preserve value initial states system defined ij im denotes initial condition main module ij denotes initial condition instantiation j module composite symbolic library 15 symbolic manipulator used action language verifier combines different symbolic representations using composite model checking approach 5 generally model checking tools built using single symbolic representation bdds 17 polyhedra 2 composite model checker combines different symbolic representations improve efficiency expressiveness model checking current implementation composite symbolic library uses two basic symbolic representations bdds boolean enumerated variables polyhedral representation integers since composite symbolic library uses objectoriented design action language verifier poly morphic dynamically select symbolic representations provided composite symbolic library based variable types input specification example integer variables input specification action language verifier becomes bddbased model checker analyze system using composite symbolic library one specify initial condition transition relation state space using set composite formulas composite formula obtained combining integer arithmetic formulas integer variables boolean variables using logical connectives enumerated variables mapped boolean variables action language parser since integer representation composite symbolic library currently supports presburger arithmetic restrict arithmetic operators gamma however allow multiplication constant quantification composite formula p represented disjunctive normal form p denotes formula basic symbolic representation type ith disjunct n denote number disjuncts number basic symbolic representation types respectively composite symbolic library implements methods intersection union complement satisfiability check subset test manipulate composite representations form methods turn call related methods basic symbolic representations action language verifier iteratively computes fixpoints temporal operators using symbolic operations provided composite symbolic library action language verifier uses techniques truncated fixpoints widening collapsing operators compute approximations divergent fixpoint computations 6 however action language verifier generate false negatives false positives either verifies property generates counterexample reports analysis inconclusive achieved using appropriate type approximations fixpoints lower upper approxima tion based temporal property type input query could verify falsify 51 counting abstraction action language template monitor specifications figure 3 submodule instantiated fixed number times means specified system fixed number processes example specification figure 2 describes system specific number airplane processes hence verification result obtained specification guaranteed system specific number airplane processes section present adaptation automated abstraction technique called counting abstraction 9 verification monitor specifications action language using counting abstraction one automatically verify properties monitor model arbitrary number processes basic idea define abstract transition system local states processes abstracted away number processes local state counted introducing new integer variable local state abstraction technique work need local states submodules finite example submodule local variable unbounded integer cannot use counting abstraction note shared variables ie varm still unbounded since abstracted away consider specification figure 2 airplane process local states note general case figure 3 local state corresponds valuation local variables submodule ie set local states submodule cartesian product domains local variables submodule given module set possible valuations local variables set local states counting abstraction introduce nonnegative integer variable represent local state submodule ie submodule local state 2 module declare nonnegative integer variable example specification figure 2 introduce integer variables airplane submodule arflowc state pcarflow depflowc state pcdepflow variables represent number processes local state corresponds example arflowc 2 abstract system imply 2 processes corresponding states concrete system pcarflow holds note could one concrete state corresponds abstract state defined mapping states concrete system abstract system next thing define abstract transition relation ie translate actions original system actions abstract system consider action exitrw3 figure 2 translate action action abstract system change part expression using current next state local variables ie pctouchdown pctaxito16l3 part expression current next state shared variables ie numc30 numrw16rnumrw16r1 numc3numc31 remain since restricted local variables fi nite without loss generality assume local variables boolean variables discussed section 5 action language verifier translates enumerated variables boolean variables stated section 4 assume action expression form expa j l r l dsa rsa l boolean logic formula local domain variables r l boolean logic formula local domain variables since assuming local variables boolean need domain variables r l transform action expression set equivalent action expressions form splitting disjuncts involve local shared variables action exitrw3 l pctouchdown r l pctaxito16l3 let sd set local states module satisfy expression l translate l expression variables abstract transition system generating expression l j s2s integer variable represents local state note l indicates exists process local state satisfies l exitrw3 formula obtain simply touchdownc0 ie exists process local state pctouchdown let sr set local states module satisfy expression r l translate r l expression variables abstract transition system generating expression r l j s2s t2sr s6t 0 first disjunction enumerates possible local current next state pairs action updates counters accordingly second disjunct takes account cases local state process change action exitrw3 obtain following ex pression touchdownctouchdownc1 taxito16l3c taxito16l3c1 abstraction action exitrw3 exitrw3 touchdownc0 numc30 numc3numc31 numrw16rnumrw16r1 touchdownctouchdownc1 taxito16l3ctaxito16l3c1 generating abstract statespace abstract transition relation last component abstraction translate initial states first submodule figure 3 declare nonnegative parameterized integer constant num denotes number instances module declaring constant parameterized guarantee verified properties hold possible number instantiations submodule let init denote local initial expression submodule let init denote set local states module satisfy expression init add following constraint initial expression abstract transition system init specification figure 2 create nonnegative parameterized integer constant numairplane using initial condition submodule airplane pcarflow pcparked obtain following constraint taxito16lc3c0 taxito16lc4c0 replace initial constraint airplane submodule new constraint one show monitor invariants verified abstract specification generated counting abstraction also satisfied original monitor specification arbitrary number processes shown defining abstraction function state space original specification state space abstract specification generated counting abstraction 10 submodule declare parameterized integer num restrict expression remove local variable declarations module local state 2 module declare integer variable restrict expression replace initial expression init module set local states satisfy init action module replace l s2s set local states satisfy l replace r l s2s t2sr s6t 0 sr set local states satisfy r l figure 4 algorithm counting abstraction 52 experimental results table 1 shows performance action language verifier airport ground traffic control monitor specification given figure 2 first column denote total number processes specification ex ample results first row specification table 1 verification results airport ground traffic control specification xa xd denotes x many arriving departing airplane processes xp denotes arbitrary number airplane pro cesses p1 p2 p3 properties given figure 2 ct vt denote transition system construction time property verification time seconds respectively 8apd 395 228 154 259 pa2d 167 131 088 394 pa4d 315 242 171 509 pa8d 640 464 332 735 figure processes ct denotes time spent constructing composite symbolic representations transition relation initial states input specification including parsing time vt denotes verification time property although input infinite state system since numc3 numrw16r numrw16l unbounded variables verification time scales well due efficiency composite symbolic representation bdds partitioned transition system eliminate boolean variables done infinite state model checkers would obtained 2 64 partition classes fourth instance table 1 mapping boolean variables integers hand would created 64 integer variables increasing cost arithmetic constraint manipulation likely scale well bdds used counting abstraction verify airport ground traffic control monitor specification arbitrary number arriving departing airplanes first verified specifications fixed number arriving airplanes arbitrary number departing airplanes using counting abstraction states departing airplanes example row 4apd table 1 denotes case arriving airplanes arbitrary number departing airplanes although counting abstraction generates integer variable local state airplane process experimental results table 1 shows scales well fact case states arriving departing airplanes abstracted papd properties verified faster compared cases possibly due fact counting abstraction way simplifies system abstracting away information individual processes example abstract transition system possible determine airplane state keep track number airplanes particular state verified large number concurrent system specifications using action language verifier including monitor specifications monitors sleeping barber prob lem readerswriters problem bounded buffers experimental results reported 20 6 synthesis monitors monitor specification given figure 2 shared variables numrw16r numc3 represent resources shared among multiple processes submodule airplane specify type processes share resources goal generate monitor class java monitor specifications one given figure 2 first declare shared variables monitor specification example numrw16r numc3 figure 2 private fields monitor class hence variables accessible methods monitor class try automatically generate code threads use monitor would go modularization principle provided monitors rather leave assumption threads behave according specification proof obligation general submodule monitor specification figure specify general behavior corresponding thread equivalently specify minimum requirements corresponding thread monitor execute correctly since specifications local behavior threads generally straightforward airplane process execute exitrw3 action executing reqland think would difficult concurrent programmer take responsibility meeting specifications generate monitor method corresponding action submodule monitor specification consider action exitrw3 pctouchdown numc30 numc3numc31 numrw16rnumrw16r1 pctaxito16l3 interested expressions local variable pc submodule airplane discussed generating code monitor class access shared variables action exitrw3 removing expressions local variables leaves us expression exitrw3 numc30 numc3numc31 implement action monitor method first check guarding condition numc30 update numrw16r numc3 however guarding condition hold wait process signals condition might changed straightforward translation action monitor method would public synchronized void exitrw3 numc30 reason call notifyall method end wakeup processes might waiting condition related variable numrw16r numc3 updated action also note wait method inside loop make sure guard still holds thread wakes translation used synchronized keyword establish atomicity note atomicity java established respect methods blocks also synchronized approach work make sure shared variables modified part program synchronized establish declaring shared variables private variables monitor class making sure methods monitor class synchronized using straightforward approach translate monitor specification based template given figure java monitor class using following rules 1 create monitor class private variable shared variable specification 2 action sub module create synchronized method monitor class method action start loop checks dsa true waits put set assignments update variables according constraint rsa assignments call notifyall method exit call translation singlelock implementation monitor since uses lock monitor class 61 specific notification pattern singlelock implementation described correct inefficient 7 18 implement airport ground traffic control monitor using scheme exitrw3 action would awaken airplane threads sleeping however departing airplane threads awakened number airplanes runway 16l one taxiways c3c8 changes one variables numrw16l numc3 numc4 numc5 numc6 numc7 numc8 become zero need awakened update status runway 16r numrw16r updated entrance airplane taxiway c3 numc3 incremented using different condition variables guarding condition improves performance awakening related threads eliminating overhead incurred context switch threads need awakened 7 using separate objects wait signal separate conditions described java design pattern called specific notification pattern figure 5 shows fragment java monitor automatically generated code generator action language specification airport ground traffic control monitor given figure 2 using specific notification pat tern method action exitrw3 calls guard exitrw3 method loop till returns true returns false waits condition variable exitrw3cond action change guard exitrw3 false true notifies threads waiting condition variable exitrw3cond using exitrw3cond guard numc30 true guard exitrw3 method decrements number airplanes using runway 16r numrw16rnumrw16r1 increments number airplanes using taxiway c3 atomically returns true since executing exitrw3 change action reqlands guard false true threads waiting condition variable reqlandcond notified method exitrw3 returns action leave guard ie execution depend state shared variables mon itor hence method action leave need wait decrement number airplanes runway 16l numrw16lnumrw16l1 updating numrw16l however notifies threads waiting condition variables crossrw3cond reqtakeoffcond give algorithm generating java code monitor specifications action language using specific notification pattern stated assume action expression form expa j l r l dsa rsa l expression unprimed local variables module l expression primed unprimed local variables dsa expression unprimed shared variables varm rsa expression primed unprimed shared variables since interested local states processes use dsa rsa code generation monitor methods let guarda denote java expression equivalent dsa also assume rsa written ev expression domain variables varm let assigna denote set assignments java correspond rsa use specific notification pattern translating action language monitor specifications java monitors need associate guard action lock specific action let action guard guarda let conda condition variable associated thread calls method corresponds action wait conda guarda evaluates false thread calls method corresponds another ac tion b change truth value guarda false true notify conda hence action execution threads relevant updates performed action awakened algorithm given figure 6 generates information synchronization dependencies among different actions needed implementation specific notification pattern action submodule algorithm decides whether action guarded unguarded checking expression dsa dsa true meaning guard action marked unguarded otherwise marked guarded condition variable conda created action execution unguarded action depend shared variables hence need wait condition variable next algorithm finds actions notified action executed determine information checking action b 6 executing action dsb false result state ds b true possible condition variable created action b cond b added notification list action holds condition variables must notified action executed figure 7 shows translation guarded unguarded actions java 18 guarded action specific notification lock conda declared one private method one public method generated private method guarded executea synchronized object guard action true method executes assignments assigna returns true otherwise returns false method guarded w aita first gets lock conda public class airportgroundtrafficcontrol private int numc3 private int numrw16l numrw16r private object exitrw3cond private object reqtakeoffcond private object reqlandcond private object crossrw3cond public airportgroundtrafficcontrol exitrw3condnew reqtakeoffcondnew reqlandcondnew crossrw3condnew private synchronized boolean guardreqland numrw16r0 numrw16rnumrw16r1return true else return false public void reqland try reqlandcondwait catchinterruptedexception private synchronized boolean guardexitrw3 return true else return false public void exitrw3 try exitrw3condwait catchinterruptedexception synchronizedreqlandcond reqlandcondnotify public void leave synchronizedcrossrw3cond crossrw3condnotify synchronizedreqtakeoffcond reqtakeoffcondnotify notifications figure 5 airportgroundtrafficcontrol class using specific notification pattern action ds 6 true mark guarded create condition variable conda else mark unguarded action b st 6 b postds b expa ds b add cond b notification list figure extracting synchronization information private object new object public void guarded w aita guarded executea f try f condawaitg catchinterruptedexception e fg private synchronized boolean guarded executea f else return false public void executea fsynchronizedthis fassigna gg b figure 7 translation guarded b unguarded actions runs loop till guarded executea method returns true body loop waits conda till notified thread performs update change truth value method guarda fore guarded executea unguarded action single public method executea produced method first acquires lock object executes assignments assigna corresponding action exiting public methods guarded w aita executea executed action b notification list action note shown figure 7 automatically generated java monitor class preserve verified properties action language spec ification shown two steps 1 showing verified properties preserved singlelock implementation action language specification 2 showing equivalence singlelock implementation specific notification pattern implementation proof correctness specific notification pattern step 2 given 18 algorithm give figure 6 extracts necessary information order generate java monitor class correctly implements specific notification pattern give set assumptions monitor invariants verified action language specification monitor preserved singlelock implementation java monitor class 1 initial condition set program states immediately constructors monitor threads executed satisfy initial expression action language specification 2 atomicity observable states monitor defined program states lock monitor available ie states thread active monitor 3 thread behavior local behavior threads correct respect monitor specification 4 scheduling exists enabled action enabled action executed assuming conditions hold claim observable states singlelock implementation action language monitor specification satisfy monitor invariants verified action language verifier 7 conclusions future work think approach combining specification verification synthesis presented paper provide right costbenefit ratio adaptation automated verification techniques practice writing monitor specification three major benefits 1 higherlevel specification solution monitor implementation since eliminates need condition variables wait signal operations 2 action language specifications verified action language verifier verified monitor specifications action language automatically translated java monitor implementations correctness implementation guaranteed construction working integration automated counting abstraction algorithm action language verifier think approach applicable interesting realworld applications demonstrated case study approach applicable wider range sys tems would like extend techniques systems boolean integer arrays recursive data structures linked lists working prob lems think provide analysis arrays using uninterpreted functions analyzing specifications recursive data structures currently integrating shape analysis technique 19 composite symbolic library verification tools composite symbolic library action language verifier available httpwwwcsucsbedubultancomposite acknowledgments would like thank aysu betin help implementation automated code generation algorithm 8 r statistical summary commercial jet aircraft accidents automatic symbolic verification embedded systems concurrent programming action language specification language model checking reactive systems action language verifier specific notification java thread synchronization automatic verification parameterized cache coherence protocols deadlock detection tool concurrent java programs model checking java programs using java pathfinder operating system structuring concept library composite symbolic representation concurrent programming java symbolic model checking structured approach developing concurrent programs java shape analysis heuristics efficient manipulation composite constraints modeling airport operations using objectoriented approach tr concurrent programming structured approach developing concurrent programs java deadlock detection tool concurrent java programs composite modelchecking action language bandera monitors symbolic model checking invariantbased specification synthesis verification synchronization concurrent programs automatic symbolic verification embedded systems library composite symbolic representations heuristics efficient manipulation composite constraints constraintbased verification clientserver protocols automatic verification parameterized cache coherence protocols shape analysis action language verifier ctr robert j hall andrea zisman model interchange integration web services acm sigsoft software engineering notes v29 n5 september 2004 betincan tevfik bultan mikael lindvall benjamin lux stefan topp application design verification concurrency controllers air traffic control software proceedings 20th ieeeacm international conference automated software engineering november 0711 2005 long beach ca usa aysu betin tevfik bultan mikael lindvall benjamin lux stefan topp eliminating synchronization faults air traffic control software via design verification concurrency controllers automated software engineering v14 n2 p129178 june 2007
alldupath coverage parallel programs one significant challenge bringing power parallel machines application programmers providing suite software tools similar tools sequential programmers currently utilize particular automatic semiautomatic testing tools parallel programs lacking paper describes work automatic generation alldupaths testing parallel programs goal demonstrate extension sequential test data adequacy criteria still applicable parallel program testing concepts algorithms paper incorporated foundation delaware parallel software testing aid della pasta b introduction recent trends computer architecture computer networks suggest parallelism pervade workstations personal comput ers network clusters causing parallelism become available users traditional supercomputers experience using parallelizing compilers automatic parallelization tools shown tools often limited underlying sequential nature original program explicit parallel programming user replacing sequential algorithms parallel algorithms often needed take utmost advantage modern systems major obstacle users ensuring correctness reliability parallel software current lack software testing tools paradigm programming researchers studied issues regarding analysis testing concurrent programs use rendezvous communication known hurdle applying traditional testing approaches testing parallel prepared collaborative participation advanced telecommunicationsinformation distribution research program atirp consortium sponsored us army research laboratory cooperative agreement daal019620002 programs nondeterministic nature programs researchers focused solving problem13 15 others propose stateoriented program testing criteria testing concurrent programs14 10 hypothesis extension sequential test data adequacy criteria still applicable parallel program testing various models communication although many new parallel programming languages libraries proposed generate manage multiple processes executing simultaneously multiple processors categorized synchronization communication mechanisms message passing parallel programming accomplishes communication synchronization explicit sending receiving messages processes message passing operations blocking nonblocking shared memory parallel programming uses shared variables communication event synchronization operations paper focus applicability one major testing criteria alldupath testing16 shared memory message passing parallel programming particular examine problem finding alldupath coverage testing parallel program ultimate goal able generate test cases automatically testing programs adequately according alldupath criteria based criterion defineuse associations program covered least one test case general procedure finding dupair coverage begins finding dupairs program dupair path generated cover specific du finally test data testing path produced 27 testing procedure well established sequential programs however currently known method determining alldupath coverage parallel programs moreover issues addressed toward developing algorithms well defined present algorithms shared memory parallel programs discuss modifications necessary message passing paradigm building testing tool parallel software delaware parallel software testing aid called della pasta illustrate effectiveness usefulness tech niques della pasta takes shared memory parallel program input interactively allows user visually examine dupath test coverages pose queries various test coverages modify test coverage paths desired earlier paper focused strictly alldupath finding algorithm18 begin description graph representation parallel program used work describe testing paradigm cope nondeterministic nature parallel programs testing process discuss major problems providing alldupath coverage shared memory parallel pro grams set conditions used judging effectiveness alldupath testing algorithms current approaches alldupath coverage sequential programs closest relevance work discussed present algorithm finding alldupath coverage shared memory parallel programs combines extends previous methods sequential pro grams modification data structures algorithms parallel paradigms discussed followed description della pasta tool finally summary contributions future directions stated model notation parallel program model use paper consists multiple threads control executed simultaneously thread independent sequence execution within parallel program ie subprocess parallel process process program execution communication two threads achieved shared variables synchronization two threads achieved calling post wait system calls thread creation achieved calling pthread create system call assume execution environment supports maximum par allelism words thread executed parallel independently wait node reached thread halts matching post executed execution post always succeeds without waiting program statements formally shared memory parallel program defined threads moreover 1 defined manager thread threads defined worker threads created pthread create system call issuedt post wait pthread create loop loop begin begin dmxy uz3m figure 1 example ppfg represent control flow parallel program parallel program flow graph ppfg defined graph v set nodes representing statements program e consists three sets edges set e consists intrathread control flow edges n nodes thread set e consists synchronization edges post post post statement thread wait j wait statement thread j 6 j set e consists thread creation edges n n j n call statement thread pthread create function n j first statement thread define path p n u 1 simply p within thread alternating sequence nodes intrathread edges simply sequence nodes n uw unique node index unique numbering nodes edges control flow graph thread eg reverse postorder numbering figure 1 illustrates ppfg solid edges intrathread edges edges e e represented dotted edges diagram also shows define node variable ie use node u ie sequence begin gamma path dupair triplet var u th node thread unique numbering nodes thread program variable var defined statement represented node program variable var referenced v th node unique ordering nodes thread j sequential program single thread parallel program say node covered path denoted n 2 p p exists node n path say node parallel program covered set paths respectively simply represent set matching posts wait node set matching waits post node g use symbol oe represent relation completion times instances two statement nodes say instance node completes execution instance node b finally problem finding alldupath coverage testing shared memory parallel program stated given shared memory parallel program v prog find set paths threads 1 covers dupair var v n u oe n v 1 3 nondeterminism testing process nondeterminism demonstrated running program input observing different behaviors ie different sequences statements executed nondeterminism makes difficult reproduce test run replay execution debugging also implies given test data set may actually force intended path covered particular testing run one way deal nondeterminism perform controlled execution program separate execution control focus finding dupairs define use different threads dupairs within thread subcase mechanism ensures given sequence execution advocate controlled execution reproducing test unexpected results produced test taken approach problem automatically generating executing test cases expose errors instead advocate temporal testing stage testing briefly describe temporal testing paradigm refer reader 19 detailed description temporal testing alters scheduled execution time program segments order detect synchronization errors formally program test case tc 2tuple pr og input data program pr og whereas temporal test case ttc 3tuple pr og third component referred timing changes parameter altering execution time program segments based scheduled execution time certain synchronization instructions n represented tn changed temporal test behavior program pr og observed temporal testing used conjunction path testing ex ample temporal alldupath testing implemented locating delay points along dupaths tested goal alter scheduled execution time process creation synchronization events along dupaths delayed execution delay points achieved instrumenting program dummy computation statements testing tool used automatically generate execute temporal test cases similarly new temporal testing criteria created extending structural testing criteria temporal testing approach testing process viewed occurring follows 1 generate alldupaths statically 2 execute program multiple times without considering possible timing changes 3 examine trace results trace results indicate different paths fact executed strong indication synchronization error occurred dupath expected covered may provide clue probable cause controlled execution may used reproduce test however even dupath covered multiple execution runs temporal testing still performed generate temporal test cases respect dupaths perform temporal testing automatically examine results paper focus first step ie developing algorithm find alldupaths shared memory parallel programs results paper used generating temporal test cases respect alldupath coverage criterion noted possible path want cover executed testing run due nondeterminism using controlled execution instead use automatic multiple executions different temporal testings decrease chances intended path covered alldupath coverage section use simplified examples demonstrate inherent problems addressed finding alldu paths parallel programs list necessarily exhaustive instead meant illustrate complexity problem automatically generating alldupaths parallel programs figure contains two threads manager thread worker path coverage 1 3loop 4if 15wait 14yx 13wait 12if 10 16end begin begin 2pcreate 8end 5x3 6post 7post manager worker figure 2 dupair coverage may cause infinite wait thread figure demonstrates path coverage indeed covers dupair cover post wait matching post wait post covered matching wait program execute completion despite fact synchronization covered completely however wait covered matching post program hang particular test case example worker thread may complete execution whereas manager thread terminate successfully generated path cause loop manager thread iterate loop worker thread iterate twice shows inconsistency number loop iterations may cause one thread wait infinitely addition branch selection node also influence whether threads terminate successfully path coverage 15post 2pcreate worker 4if 12if 6post 5yx3 13wait 3loop 1begin 8end 16end manager 7wait figure 3 dupair incorrectly covered figure 3 generated paths cover define 14 use 5 nodes use node reached define node de f ine 6oe use data flow information reveals definition x worker thread indeed able reach use x manager thread attempt find path coverage test pair current path coverage accomplish 41 test coverage classification examples motivate classification alldupath coverage particular classify dupath coverage generated algorithm producing alldupath coverage parallel program acceptable unacceptable wrunnable nonwrunnable 411 acceptability dupath coverage call set paths path acceptable dupath coverage denoted path dupair de f ine use parallel program free infeasible paths sequential programming kind see later section infeasible paths following conditions satisfied 1 de f ine 2 p path use 2 p path 2 8wait nodes w 2 p path 9 post node p 2 mpw 3 9postwait 2 e de f ine oe post oe wait oe use postwait 2 p path 4 8n 2 p path n conditions ensure definition use included path postwait edge threads containing definition use involved data flow definition use included path moreover sink thread creation edge associated source thread creation edge also included path conditions violated path coverage considered unacceptable instance wait covered path coverage matching post path coverage path figure 3 define use covered reverse order shows another instance satisfies first two conditions fails satisfy third condition 412 wrunnability dupath coverage seen examples parallel program may cause infinite wait given path coverage even dupath coverage acceptable path coverage used generate test case cause infinite wait thread call path coverage wrunnable dupath coverage path wrunnable represent pathw although call path wrunnable claiming pathw free errors race conditions synchronization errors formally path wrunnable following additional conditions satisfied 1 instance wait w possibly represented node n 2 p path 9 instance post p instance wait post one execution wait post may multiple instances wait post program 2 6 9post nodes path first condition ensures instance wait path matching instance post however required every instance post matching wait covered words following condition required 8post nodes wait node w 2 mwp w 2 p path second condition ensures generated path free deadlock develop algorithms find path automatically ever utilize user interaction determining pathw difficult cases sometimes indicate user cannot guarantee execution terminate given test case ie path coverage case program still run may terminate find path report path coverage may cause infinite wait 42 infeasible paths infeasible paths graph representation program paths never executed given input data control flow graphs single thread infeasible paths due data dependencies conditionals interprocedural graph structures infeasible paths due calling function multiple points kinds infeasible paths occur sequential programs also occur parallel programs parallel program another kind infeasible path also occur due synchronization dependencies infeasible paths due synchronization dependencies cause deadlock infinite wait runtime like path finding algorithms assume paths identify feasible respect first causes regard infeasible paths due synchronizations work uses slightly different characterization paths path pathw dupath coverage algorithm finds paths way guarantee matching synchronizations included final paths finds paths path however deadlock situation could occur path coverage path pathw guarantee finding matching synchronizations currently assume matching post wait operations appear program program contains post matching wait vice versa expect compiler report warning message prior execution algorithm 5 related work context sequential programs several researchers examined problems generating test cases using path finding well finding minimum path coverage 3 11 1 methods finding actual paths focus programs without parallel programming features therefore cannot applied directly finding alldupath coverage parallel programs however found depthfirst search approach approach using dominator postdominator trees used together extension provide alldupath coverage parallel programs first look limitations providing alldupath coverage parallel programs used isolation gabow maheshwari osterweil 3 showed use depthfirst search dfs find actual paths connect two nodes sequential program applying dfs alone parallel programs claim appropriate even finding path mention pathw reason although dfs applied find set paths covering dupair approach cope well providing coverage intervening waits corresponding coverage matching posts required find path example consider situation wait nodes included completing partial path covering use node since first path completed matching post included original path first path must modified include post straightforward task becomes downfall using dfs isolation providing alldupath coverage parallel programs bertolino marr e developed algorithm call dtit uses dominator trees dt implied trees ie postdominator trees find path coverage branches sequential program 1 dominator tree tree represents dominator relationship nodes edges control flow graph node n dominates node control flow graph every path entry node control flow graph must pass n similarly node postdominates node p every path p exit node control flow graph passes dtit approach finds allbranches coverage sequential programs follows first dt built sequential program edges intersection set leaves dt defined unconstrained edges used find minimum path coverage based claim unconstrained edges covered least one path edges covered algorithm finds one path cover unconstrained edge one edge selected one subpath found dt well one node parent node dt adjacent control flow graph program users allowed define criteria connecting two nodes make path two subpaths one built using dt built using concatenated together derive final path coverage try run algorithm find alldupath coverage parallel programs need find path coverage dupairs instead alledges minor modification however approach also run problem dfs post wait reached completing path need adjust path found include matching nodes addition run another problem regarding order define use nodes covered final path instance figure 3 incorrect path coverage generated using dtit approach alone final path de f ine 6oe use thus using method alone cannot guarantee find path yang chung 20 proposed model represent execution behavior concurrent program described test execution strategy testing process formal analysis effectiveness applying path analysis detect various faults concurrent program execution viewed involving concurrent path cpath contains flow graph paths concurrent tasks synchronizations tasks modelled concurrent route croute traverse concurrent path execution building rendezvous graph represent possible rendezvous conditions testing process examines correctness concurrent route along concurrent paths concurrent programs paper acknowledges difficulty cpath generation ever actual methodologies selection cpaths croutes presented paper 6 hybrid approach section describe extended hybrid approach find actual path coverage particular dupair parallel program actually two disjoint sets nodes path used cover dupair parallel program required nodes optional nodes set required nodes includes pthread create calls well define node use node covered associated post wait partial order de f ine oe use guaranteed nodes path optional nodes partial orders among set requirements path however wait covered path matching post must covered instance figure 6 nodes 2 4 7 25 26 required nodes whereas synchronization nodes optional among required nodes partial orders uniquely identified whereas partial orders among optional nodes example acceptable include either post 3 post 4 first path coverage even include wait 1 later post 4 path dfs approach useful finding path connects two nodes whose partial order known dtit approach appropriate covering nodes whose partial order known advance therefore dfs useful finding path required nodes whereas dtit approach useful ensuring optional nodes covered algorithm consists two phases first phase called annotate phase depthfirst search dfs approach employed cover required nodes ppfg dtit approach used cover optional nodes path cover node found nodes path annotated traversal control number trn second phase called path generation phase actual path coverage generated using traversal control annotations first describe data structures utilized dupair path finding algorithm present details algorithm algorithm assumes individual dupairs parallel program found previous work computing reaching definitions shared memory parallel programs done grunwald srinivasan 5 61 data structures main data structures used hybrid algorithm 1 ppfg 2 working queue per thread store post nodes required final path coverage 3a traversal control associated every node used decide node must included final path coverage many iterations required path loop 4 reverse postorder number rpo node ppfg used selecting path loop nodes 5 decision queue per ifnode 6 one path queue per thread store resulting path 62 dupath finding algorithm describe dupath finding algorithm respect finding dupairs define use located different threads handling dupairs define use thread simplification algorithm figure 4 contains annotate graph algorithm accomplishes annotate phase traverse graph algorithm shown figure 5 traverses ppfg generates final dupath coverage describe step algorithms detail phase 1 annotating ppfg step 1 initialize working decision queues empty set trn node zero step 2 use dfs find path pthread create thread containing define node define node 2 find path cover pthreadcreate define nodes using dfs algorithm annotatethegraph output input dupair ppfg annotated ppfg 1 initialize trns decision queues working queues define node search use node using dfs 3 complete two subpaths using dtit 5 process synchronization nodes working queue empty thread working queue empty remove one node working queue nodes trn zero find path cover node 4 node complete paths increment trn one node wait add matching nodes appropriate working queues node ifnode add successor node path decision queue node complete path node wait node ifnode add matching nodes appropriate working queues add successor node path decision queue increment trn one figure phase 1 annotate graph define node use node post node found path matching wait placed next node traversed search use node continues upon returning dfs call wait traversed return matching post continuing search use node yet found step 3 apply dtit complete subpaths found step 2 complete subpath thread containing define node use dominator tree define node postdominator tree post node occurs define node subpath found similarly complete subpath thread containing use node use dominator tree matching wait post node postdominator tree use node step 4 node covered either two paths 1 increment nodes trn one indicate node traversed least 2 node wait add matching post working queue thread post located 3 node ifnode add reverse postorder num berrpo successor node within path ifnodes decision queue ensure correct branch selection phase 2 step 5 working queue empty remove one post node threads working queue find path cover node increment trn nodes path way trn identifies instances node covered particularly important finding path coverage nodes inside loops might necessary traverse loop body nodes several times ensure branches inside loop covered appropriately process wait ifnodes path step 4 algorithm traversethegraph threads current nodes trn 0 current end node add current node result dupath decrement trn current node one output dupath input annotated ppfg node thread current ifnode first node decision queue else delete first node queue current loop node else smallest nonzero rpo current successor node current figure 5 phase 2 generate dupath coverage phase 2 generating dupath thread perform following steps step 1 let n begin node thread step 2 ns trn 0 n end node add n path queue contains resulting path coverage decrement ns trn n ifnode let new n node removed ns decision queue otherwise n loop node successor smallest nonzero trn chosen new n children trn child smallest rpo chosen otherwise n ifnode loop node let new n successor n 63 examples section use two examples illustrate hybrid ap proach first example illustrates generating pathw second example illustrates generating nonpathw path examples cover dupair define x node 4 use x node 26 figure 6 example 1 generating pathw second step first phase required nodes including pthread create de f ine post 2 wait 2 use nodes included partial path identified partial path 23457 2526 third step first phase two subpaths completed using dtit approach two identified complete paths 12345789311 manager 2122232526 trn every node along two paths equals 1 step 4 except loop node 22 trn 2 node 9 reached traversal nodes 28 put working queues worker 1 worker 2 respectively node 28 taken working queue step 5 found nonzero trn thus paths added node 35 taken working queue trn zero hence path 31323334353236 found cover node 35 annotated ppfg input second phase finds final path 12345789311 manager 21 worker 2 worker worker 9 1 287 create post post wait post 341 22beginbegin begin 34n5 3loop post post 25 10 30end 2pthread 36end figure example path finding algorithm example 2 generating nonpathw second step first phase required nodes including pthread create de f ine post 2 wait 2 use nodes included partial path identified 234572526 third step first phase two subpaths completed found 12345789311 manager 2122232526 trn every node along two paths equals 1 step 4 except loop node 22 trn node 22 equals 2 node 9 reached traversal nodes 28 35 put working queues similarly fifth step first phase two paths 2122232526272822 31323334353236 found cover nodes 28 35 respectively final trns example label node figure 6 second phase finds final paths 12345789311 manager 212223252627292223252627282230 worker 1 31323334353236 worker 2 set paths wrunnable worker 1 infinite wait node 25 noted regardless path constructed user validate w property holds 64 correctness complexity given dupair parallel program de f ine node use node located two different threads show algorithm indeed terminate find path first introduce lemmas give final proof lemma 1 trn preserves number required traversals node within loop body first phase trn node incremented one time path generated includes node therefore number traversals node paths found first phase preserved trn although number traversals first phase preserved claiming nodes indeed traversed second phase number times nodes outside loop body node traversed many times trn node may need traversed many times path generation phase may reach end node trn nodes becomes zero moreover loop node program required nodes traversed many times trn indicates lemma 2 decision queue trn ifnode guarantee sequence branches selected first phase selected second phase ifnode found path first phase one branch stored decision queue time hence number branches decision queue given ifnode equal trn ifnode time ifnode traversed second phase one node taken decision queue trn ifnode decremented one therefore sequence branch selected preserved lemma 3 dfs used first phase ensures de f ine oe post oe wait oe use final generated path first phase required nodes marked dfs prior nodes graph ensures necessary branches stored decision queues first lemma 2 branches traversed first second phase hence nodes traversed correct order given relationships therefore lemma 3 valid lemma 4 working queues trn together guarantee termination dupath finding algorithm must show phases terminate phase 1 termination use mathematical induction represents total number pairs synchronization nodes covered path coverage base case one pair synchronization calls required ones included path generated dfs completion two partial paths automatically terminate since extra post waits involved integer greater 1 need show lemma 4 also true post wait traversed previously trn nodes greater zero hence included first phase generate new path cover pair post wait nodes currently trn0 pairs synchronization nodes covered induction step hence new pair synchronization calls trigger unlimited number actions therefore annotation phase terminate phase 2 termination since trn node must traversed finite integer trn decremented time traversed phase 2 traversal phase 2 iterate forever whenever node zero trn end node reached path generation phase terminates finally show proof following theorem theorem 1 given dupair shared memory parallel program hybrid approach terminates finds path proof 1 lemma 4 hybrid approach terminates 2 show path generated must show conditions described definition path satisfied lemma 1 lemma 2 lemma 3 conclude de f ine use required post wait nodes covered correct order step 1 phase 1 ensures appropriate pthread create calls covered step 5 ensures matching post node regarding wait node included path also covered therefore conditions path satisfied qed running time hybrid approach includes time spent searching required nodes time spent generating final path coverage assume dominatorimplied trees dupairs provided optimizing compiler theorem 2 given g dupair u total running time dupath finding algorithm equal o2 k jej total number post wait calls denoted k proof running time searching required nodes equal ojv complete two partial paths running time equal o2 k jv total number post wait calls denoted k finally second phase takes time o2 k jv j jej finish hence total running time equal o2 k jv jej given graph usually number edges greater nodes running time equal o2 k jej qed 7 parallel paradigms 71 rendezvous communication among researchers long clarke developed data flow analysis technique concurrent programs9 data flow analysis performed apply modified version algorithm find alldupath coverage concurrent program rendezvous communication particular need modify following 1 construction ppfg 2 definition path acceptability 3 alldupath finding algorithm first accommodate request accept operations concurrent programs achieve rendezvous communication ppfg needs include directed edge request accept node secondly since execution request synchronous second condition definition path must replaced following two conditions 2a 8accept nodes 2 p path 9 request node r 2 mra 2b 8request nodes r 2 p path 9 accept node 2 mar 2 p path set mra defined set matching requests accept node set mar defined set matching accepts request node r finally first phase algorithm whenever request accept found matching node must added working queue 72 message passing programs analyzing message passing programs data flow analysis similar interprocedural analysis sequential programs needed compute defineuse pairs across processes several researchers developed interprocedural reaching definitions data flow analysis techniques even presence aliasing c programs 12 6 although analysis may find defineuse pairs may actually occur execution program reaching definition information sufficient program testing information computed apply algorithm find alldu path coverage given c program message passing library calls message passing interfacempi4 standard library routines achieve various types interprocess communication ie synchronous asynchronous sendreceive operations find alldupath coverage message passing programs need identify type send receive operations first ie synchronous asynchronous send operation synchronous definition path must modified include send matching receive path coverage similar change made supporting rendezvouscommunication parallel programs send asynchronous need replace post send paper synchronous receive operation need replace wait receive algorithms definitions 8 della pasta tool algorithm described paper incorporated della pasta prototype tool building parallel software testing objective demonstrate process test data generation partially automated tool provide valuable information response programmer queries regarding testing current major functions tool 1 finding dupairs parallel program 2 finding alldupath coverage cover dupairs specified user 3 displaying dupath coverage graphic text mode specified user 4 adjusting path coverage desired user della pasta consists two major components static analyzer accepts file name finds dupairs well alldupath coverage dupair path handler interacts user display ppfg path coverage accept commands displaying individual dupair coverages modifying path static analyzer uses modified version grunwald srinivasan algorithm5 find dupairs parallel programs model implemented using compiler optimizer generating tool called nsharlit part suif compiler infrastructure 8 path handler built top dflo dataflow equation visualizing tool developed oregon graduate institute 2 user interface della pasta illustrated figure 7 left screen ppfg illustrated right corresponding textual source code shown user resize data flow graph desired currently selected defuse pair shown top screen corresponding dupair path coverage depicted ppfg well text highlighted nodes statements respectively clicking node ppfg pop extra window information node allow user modify path coverage example readerwriter program illustrated main thread creates three additional threads two readers one writer main thread acts one writer communicates one two readers created two pairs readerswriters work independently parallel dupair coverage shown example involves two 4 threads program currently extending della pasta use dupair coverage tool downloaded internet refer web site httpwwwcseogiedu80sparsedflohtml details figure 7 della pasta user interface information already available static analyzer answer queries following kind test case execute successfully without infinite wait caused path coverage dupairs particular path coverage cover also incorporating temporal testing techniques 17 tool order provide testing aid delayed execution addition traditional alldupath testing 9 summary future work knowledge first effort apply sequential testing criterion shared memory message passing parallel programs contributions include sorting problems providing alldupath coverage parallel programs classifying coverages identifying limitations current path coverage techniques realm parallel programs developing algorithm successfully finds alldupath coverage shared memory parallel programs showing modified message passing rendezvous communication demonstrating effectiveness implementation testing tool alldupath coverage algorithm presented paper limitations alldupath algorithm requires ppfg constructed statically ppfg cannot constructed statically represent execution model program analysis constructs dupairs may produce meaningful dupairs thus number worker threads currently assumed known static analysis time case clear operation used clear event wait issued analysis report dupairs needed testing implies indicate test cases really needed process examining limitations experimentally analyzing effectiveness fault detection parallel programs using alldupaths criterion della pasta investigating structural testing criteria testing parallel programs acknowledgements would like thank barbara ryder helpful comments preparing final paper views conclusions contained document authors interpreted representing official policies either expr essed implied army research laboratory us government r system generate test data symbolically execute programs two problems generation program test paths using mpi portable parallel programming message passing interface data flow equations explicitly parallel programs efficient computation interprocedural definitionuse chains automated software test data generation introduction suif compiler system data flow analysis concurrent systems use rendezvous model synchronization path cover problems digraphs applications program testing interprocedural defuse associations c systems single level pointers testing concurrent software structural testing concurrent programs formal framework studying concurrent program testing evaluation programbased software test data adequacy criteria challenges automated testing multithreaded programs algorithm alldupath testing coverage shared memory parallel programs path analysis testing concurrent programs tr evaluation programbased software test data adequacy criteria automated software test data generation path analysis testing concurrent programs structural testing concurrent programs data flow equations explicitly parallel programs efficient computation interprocedural definitionuse chains automatic generation path covers based control flow analysis computer programs using mpi interprocedural defuse associations c systems single level pointers algorithm alldupath testing coverage shared memory parallel programs ctr arkady bron eitan farchi yonit magid yarden nir shmuel ur applications synchronization coverage proceedings tenth acm sigplan symposium principles practice parallel programming june 1517 2005 chicago il usa c michael overstreet improving model development process model testing special case software testing proceedings 34th conference winter simulation exploring new frontiers december 0811 2002 san diego california john penix willem visser seungjoon park corina pasareanu eric engstrom aaron larson nicholas weininger verifying time partitioning deos scheduling kernel formal methods system design v26 n2 p103135 march 2005
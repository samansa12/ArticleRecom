incomplete factorization multigraph algorithm present new family multigraph algorithms ilumg based upon incomplete sparse matrix factorization using particular ordering allowing limited amount fillin much motivation multigraph comes multigrid ideas ilumg distinctly different algebraic multilevel methods graph sparse matrix recursively coarsened eliminating vertices using graph model similar gaussian elimination incomplete factorizations obtained allowing fillin generated vertex parents associated vertex multigraph numerically compared algebraic multigrid examples arising discretizations partial differential equations unstructured grids b introduction paper present new family multigraph algo rithms ilumg based upon incomplete sparse matrix factorization using carefully designed ordering allowing limited amount fillin paper focus primarily systems linear equations arising discretizations partial differential equations method formally applied general sparse matri ces particular problem class problems seems likely specialized methods making use particular features problem outperform multigraph algorithm however goal ilumg algorithm provide general robust iterative solver many different systems linear equations goal may yet achieved first version hope expectation multigraph algorithm eventually provide reasonably good rates convergence many classes problems requiring minimal input algebraic approaches multilevel methods enjoyed long history beginning algebraic multigrid amg methods brandt mccormick ruge 13 14 ruge stuben 26 black box multigrid method dendy 15 recent work found 1 3 4 12 20 19 17 well many contributions 2 work grew grid coarsening schemes developed 10 11 corresponding hierarchical basis iterations hbmg much motivation comes multigrid ideas ilumg fundamentally incomplete sparse matrix factorization multigraph method resembles approach classical sparse gaussian elimi nation graph stiffness matrix recursively coarsened first eliminating node adjacent edges adding partial set fillin edges corresponding vertex parents node thus concept levels important coarse grid problem must solved exactly however generality approach leaves open possibility introducing levels coarse graphs plan study alternatives possible ways improve convergence behavior basic method see 9 preliminary results direction size subsequent graph controlled monitoring amount numerical fillin produced since node eliminated department mathematics university california san diego la jolla ca 92093 work author supported national science foundation contract dms9706090 bell laboratories lucent technologies murray hill nj 07974 based upon graph considerations attempt made preserve integrity grid indeed information even provided rest paper organized follows section 2 provide graph theoretic interpretation construction hierarchical bases relation sparse incomplete factorizations connection multigrid multigraph described terms linear algebra section 3 section 4 implementation method discussed detail particular ordering strategy incomplete factorization procedure described finally section 5 compare multigraph amg examples arising discretizations partial differential equations unstructured grids 2 graph theoretical aspects section discuss relation construction hierarchical basis sparse incomplete lu ilu factorization within context graph theory first consider standard gaussian elimination classical ilu factorization graph theoretical point view develop graph elimination model hierarchical basis methods sequences nested meshes models interpreted special ilu decompositions generalize case general graphs begin standard definitions interested reader referred rose 25 george liu 18 complete introduction corresponding sparse n theta n matrix symmetric sparsity pattern ie ij 6 0 ji 6 0 let gv e graph consists set n ordered vertices set edges e edge connecting vertices v j edges graph g correspond nonzero offdiagonal entries stiffness matrix space continuous piecewise linear polynomials represented standard nodal basis graph g underlying triangulation domain minor modifications due dirichlet boundary conditions vertex v set adjacent vertices adjv defined degree vertex degv size set adjv clique c v set vertices pairwise connected v proper ordering vertices clique corresponds dense submatrix graph theoretic terms single step gaussian elimination transforms gv e new graph g 0 1 eliminate vertex v incident edges g set g denote resulting set edges 2 create set f fillin edges follows distinct pair v g add edge e jk f already present e 1 set since values matrix entries involved model cannot take account occurrence socalled accidental zeros graph elimination process illustrated figure 1 note set adjv g becomes clique g 0 within framework classical ilu factorization one fillin edges allowed ie f j forces matrix 0 corresponding new graph g 0 sparsity structure corresponding submatrix graph g 0 would correspond center picture figure 1 concept vertex parents first introduced allow hbmg interpreted generalized ilu procedure begin case two nested meshes fine mesh uniform refinement coarse mesh generated pairwise phi phi phi phi phi phiomega omega omega omega omega omega omega omega phi phi phi fig 1 fine grid vertex v eliminated classical gaussian elimination original mesh shown left remove v incident edges middle add fillin edges right connecting midpoints coarse grid edges usual way 7 27 21 make direct sum decomposition c set coarse grid vertices v f set fine grid vertices v c vertex unique pair vertex parents v c v midpoint edge connecting v j v k v view hbmg ilu algorithm selected fillin edges allowed algorithm vertices set v f sequentially eliminated follows 1 eliminate vertex incident edges g set g denote resulting set edges 2 let v parents v create set f fillin edges form e already present e 1 set words classical hbmg algorithm adds subset fillin edges gaussian elimination one vertices vertex parent even simple possibility use one vertex parent elimination strategy although correspond classical case hbmg studied different context partitioning scheme general graphs 23 24 elimination algorithm similar case two parents 1 eliminate vertex incident edges g set g denote resulting set edges 2 let v j 2 adjv denote parent v create set f fillin edges form e already present e 1 set however case generally fewer fillin edges added initial graph g finite element triangulation tetrahedral mesh three space dimensions graph g 0 remains finite element triangulation property maintained steps elimination process careful selection parents one two vertex parent eliminations illustrated figure 2 another straightforward extension allows possibility two vertex parents either fixed variable number limiting case allowing vertices adjv parents v result classical gaussian elimination extensions interpreted multigrid framework various multipoint interpolation schemes work consider one twovertex parent cases let triangulation f graph original stiffness matrix represented standard nodal basis either one two parents phiomega omega omega omega omega omega omega omega phi phi phi phi phi phiomega omega omega omega fig 2 fine grid vertex v eliminated hbmg ilu elimination original mesh shown left fillin pattern using two parents v 1 v 2 shown middle fillin pattern using single parent v 1 shown right vertices v f eliminated resulting graph coarse grid triangulation c however numerical values matrix elements generally different two cases special case sequence uniformly refined meshes total number edges filled graph estimated serve guide amount memory necessary store incomplete lu factorization using typical sparse matrix storage schemes eg 16 18 8 elimination process illustrated case two parents figure 3 fig 3 hbmgilu classical case using two parents fine grid vertices eliminated order v 1 v 2 v 3 total two fillin edges added interior coarse grid triangle elimination original graph approximately 3n edges 2n triangles quartet four triangles generates two fillin edges part coarse grid triangulation thus total number edges coarse grid approximately 4n repeat recursively coarser grids geometric sum 4n ae oe 16nis generated thus approximately 16n3 edges filled graph case classical hbmg method implemented block iteration fillin offdiagonal blocks explicitly stored number edges actually stored sparse data structure approximately shown 7 present study consider point iterations explicit storage edges elimination process case one parent shown figure 4 main difference case one parent one fillin edge associated quartet triangles fine grid thus total approximately edges coarse grid expect approximately 7nae oe fig 4 hbmg ilu using one parent fine grid vertices eliminated order v 1 v 3 eight generic scenarios process result one fillin edge interior coarse grid triangle total edges somewhat less case two parents also less bound 6n obtained general matching strategies twodimensional triangulations 23 fact matching strategies applied general graphs produce fillin bounded oje number edges original graph know similar bound case two parents empirically observed rapid growth fillin matching strategies made little effort control number fillin edges multigraph algorithm generalizes concept vertex parents arbitrary graphs main problem determine reasonable vertex parents vertex eliminated done eliminationunrefinementcoarsening performed graph exactly case nested meshes 3 multigraph algorithm salient features multigraph algorithm connection hbmg illustrated considering following simple example let n theta n sparse matrix arising discretization partial differential equation assembled using standard nodal basis partition 1 6 0 diagonal matrix element vertex v 1 r c vectors order n gamma 1 theta n gamma 1 matrix hierarchical basis multigrid method based change basis nodal basis hierarchical basis present context first step process involves forming matrix 2 vectors u sparse nonzeros determined vertex parents vertex classical hbmg v 1 vertex associated refinement edge endpoints g case usual unit vector jth column identity matrix restriction interpolation operators chosen geometrically reflecting fact one possible generalization choose vectors u based incomplete factorization matrix particular let v v j parents vertex v 1 scalars simply multipliers incomplete lu factoriza tion note equations well defined independent geometry mesh require v 1 results refinement edge e ij similar manner case one vertex parent sparsity patterns vectors c c since nonzeros subset nonzeros c 1 however sparsity patterns b generally matrix du typically creates fillin rows columns corresponding vertex parents precisely fillin edges illustrated figure 2 also note identity see elimination step also viewed forming rank one perturbation exact schur complement standard formulation next step hierarchical decomposition transformation form applied reduced matrix b cu l 1 au 1 actual change hierarchical basis defined implicitly recursion final hierarchical bases stiffness matrix 0 far less sparse generally better conditioned standard iterative methods effectively applied linear systems involving 0 case classical hbmg iterative method standard block symmetric gaussseidel iteration blocks defined terms refinement levels mesh see 6 7 details multigraph method ilumg replaces gaussseidel iteration incomplete factorization particular set l unit lower triangular diagonal u unit upper triangular e socalled error matrix sparsity pattern ldu defined terms elimination algorithm described section 2 precisely sparsity pattern recursively generated hierarchical transformations defined using standard ilu factorization avoid recursion hbmg time hope allowing additional fillin ilumg inherit desirable properties hbmg preconditioner 1 speaking generic terms particular taking account possible occurrence socalled accidental zeros 4 implementation multigraph algorithm divided four distinct phases analogous classical sparse gaussian elimination algorithms 1 ordering permutation matrix p computed reorder matrix pap addition vertex parents eliminated vertex defined determine fillin pattern second phase 2 symbolic factorization incomplete fillin computed using graph pap vertex parents output static data structure incompletely factored sparse matrix 3 numerical factorization numerical values l u factors computed using milu factorization 4 solution solution computed using conjugate biconjugate gradient algorithm preconditioned incomplete factorization section divided two parts first describe ordering strategy used compute p vertex parents vertex next milu factorization discussed believe present algorithms two phases optimal sense however best ones found far performance seems justify work area 41 ordering case classical sparse gaussian elimination ordering consists finding permutation matrix p reordered matrix pap desired property terms ensuing factorization normally permutation matrix p constructed based solely graph matrix eg minimum degree ordering 16 25 18 values matrix elements multigraph algorithm graph numerical values matrix used construct ordering vertex parents simplify notation describe first vertex ordered parents selected remaining vertices ordered algorithm applied inductively let fl given ae number fillin edges must added v j 2 adjv chosen vertex parent v case one vertex parent quality function defined tentative vertex parent vertex broken arbitrarily quality function q 1 v represents compromise choosing parent v j strongly connected v possible measured terms size offdiagonal matrix elements choosing v j cause little fillin possible terms factorization size parameter fl used indirectly control number fillin edges resulting ordering smaller values fl result less fillin experimentally determined good choice quality function q 2 v case two vertex parents developed similar fashion suppose v j qualities ijk given ijk ae let g ijk denote number fillin edges required fv chosen parents ijk set two parent algorithm actually offers possibility vertex zero one two parents choice parents based maximizing function q 2 v single parent case quality function q 2 v seeks compromise choosing strongly connected parents choosing parents allow low fillin experimentally determined two parent algorithm describe algorithm ordering vertices computing vertex par ents begin computing quality q p v vertex mesh using 5 case parent algorithm 7 case parent algorithm along quality function tentative parents assigned vertex cases parents assigned q p v vertices placed heap vertex highest quality root vertex say v ordered first tentative parents become actual parents update graph compute reduced matrix quality function heap position vertices updated vertices set ones potentially affected elimination v process continues inductively vertices ordered usual case remaining vertices q p v k case arbitrary order assigned remaining vertices summarize algorithm 1 initialize computing q p v tentative parents vertices heap according q p v 2 heap empty root vertex q p v order vertex v root heap update heap tentative parents v become actual parents ii eliminate v current graph add fillin edges required update partially factored matrix using milu decomposition iii update position v j heap note step ii essentially requires incomplete factorization matrix occur concurrently ordering since quality function q p updated based current state factorization makes ordering algorithm rather expensive often expensive even expensive actual solution partly factorization must use dynamic data structure rather static sparse matrix data structures employ else hand general sparse matrix calculations many cases ordering done used several factorizations solutions several interesting variations ordering algorithm merit discussion related step iii provide means partitioning matrix order formulate block iterative methods first step iii artificially set q p v parent v forces v j vertices chosen actual parents reside near bottom heap heap contains vertices q remaining vertices called coarse graph vertices eliminated fine graph vertices effectively provides two level blocking fashion quite analogous classical two level hbmg algorithm correctly reinitialize q p v compute tentative parents vertices remaining heap restart elimination process led natural multilevel blocking could form basis block incomplete factorization algorithm second step iii artificially set q p v fine graph eliminated vertices form independent set diagonal block original factored matrices corresponding set vertices diagonal reinitializing restarting elimination process would result multicolorlike ordering might interesting applications vector parallel processing either alternatives using enhanced quality function includes additional information blocking strategy eg bias q p favor producing largest number vertices fine graph set within constraints seems appropriate 42 numerical factorization implementation milu factorization defined follows let set actually compute incomplete factorization matrix making priori shift one simple way ensure existence stability factorization describe first step factorization procedure let cd sparsity pattern matrix gammacr generally coincide sparsity pattern choose allow thus set gammacr required sparsity pattern e 1 error matrix first step inductively continue factorization b e cd u matrix gammacr decomposed 1 e 1 procedure similar classical milu 22 suppose p q element c p r q allowed fillin pattern consider matrix f pq zero except four elements f pq set sum taken p q pairs falling outside allowed fillin pat tern typical milu approach although averaging diagonal entries appearing f pq nonsymmetric case bit unusual 5 numerical results section present numerical results first version multigraph algorithm compare one parent two parent versions multigraph wellknown algebraic multigrid code amg ruge stuben hempel suite six text problems constructed using pltmg package version 78 5 problem three nonuniform adaptive grids generated test case sparse matrix right hand side saved file serve input iterative solvers 2 specific definition test problem described problem superior problem simple poisson equation homogeneous dirichlet boundary conditions domain shape lake superior classical problem fairly complicated domain solution shown figure 5 generally smooth boundary singularities problem hole problem features discontinuous anisotropic coefficients domain consists three subregions inner region problem middle region equation outer region equation homogeneous dirichlet boundary conditions imposed inner hole bound ary homogeneous neumann conditions outer boundary natural continuity conditions internal interfaces solution shown figure 5 also relatively smooth singularities exist internal interfaces files available upon request problem texas indefinite helmholtz equation posed region shaped like state texas homogeneous dirichlet boundary conditions imposed length scales domain roughly 16 theta 16 problem fairly indefinite illustrated figure 6 problem ucsd simple constant coefficient convectiondiffusion equation gammar posed domain shape ucsd logo homogeneous dirichlet boundary conditions imposed seen figure 6 boundary layers formed bottom region top obstacles problems jcn 0 jcn 180 next two problems solutions current continuity equation taken semiconductor device modeling equation convectiondiffusion equation form gammar domain seven subregions upper left large lower region narrow curved band directed radially dirichlet boundary conditions imposed along bottom boundary along short segment upper left boundary respectively homogeneous neumann boundary conditions specified elsewhere solutions see figure 7 vary exponentially across domain typical semiconductor problems first problem jcn 0 convective term chosen device forward biased case sharp internal layer develops along top interface boundary second problem jcn 180 sign convective term reversed resulting two sharp internal layers along interface boundaries problems run sgi r10000 octane 256 mb memory compiled fortran f77 64 options run consisted two phases setup phase consisted performing several initialization steps multigraph al gorithms included ordering symbolic factorization numerical factorization three steps sparse ordering far dominant initialization step amg consisted determining multigrid levels constructing interpolation operators well coarse grid matrices second phase problem solved relative accuracy residual 10 gamma6 starting initial guess zero results comparison shown table 1 table 2 since little variation timings setup phase times seconds averaged problems grid size table average setup time vs problem size n amg one parent two parents fig 5 lake superior hole problems fig 6 indefinite boundary layer problems fig 7 semiconductor convectiondiffusion problems table 2 present number amg cycles multigraph solves multigraph algorithm used preconditioner composite step conjugate gradient cscg procedure symmetric problems composite step biconjugate gradient csbcg procedure nonsymmetric problems count solves rather iterations since composite steps cost twice much single steps also solves nonsymmetric problems twice expensive symmetric problems since must preconditioned digits columns refer r k residual kth iteration cycle compare methods chosen cpu time measured seconds solve problem table performance comparison amg one parent two parents cycles digits time solves digits time solves digits time superior hole 26 63 729 texas ucsd jcn timings one parent two parent versions exhibit greater linear growth function problem size conventional test problems uniform 5point grids observe log n dependence significantly better ilu methods contrast amg observed class problems however problems considered study algorithm competitive amg acknowledgments authors wish thank steve mccormick helpful comments john ruge invaluable assistance running amg code r algebraic multilevel iteration methods theory applications algebraic multilevel preconditioning methods class hybrid algebraic multilevel preconditioning methods pltmg software package solving elliptic partial differential equations hierarchical basis multigrid method general sparse elimination requires permanent integer storage hierarchical basis multigrid method incomplete lu decomposi tion towards algebraic multigrid elliptic problems second order black box multigrid algorithms data structures sparse symmetric gaussian elimination algebraic analysis hierarchical basis preconditioner computer solution large sparse positive definite systems interpolation related coarsening techniques algebraic multigrid method algebraic hierarchical basis preconditioner incomplete decompositions theory analysis multilevel graph partitioning graph theoretic study numeric solution sparse positive definite systems multilevel splitting finite element spaces tr ctr p k jimack domain decomposition preconditioning parallel pde software engineering computational technology civilcomp press edinburgh uk 2002 michele benzi preconditioning techniques large linear systems survey journal computational physics v182 n2 p418477 november 2002 randolph e bank compatible coarsening multigraph algorithm advances engineering software v38 n5 p287294 may 2007
optimal hardwarealgorithm sorting using fixedsize parallel sorting device abstractwe present hardwarealgorithm sorting n elements using either psorter sorting network fixed io size p strictly enforcing conflictfree memory accesses best knowledge first realistic design achieves optimal time performance running theta fracn log np log p time ranges n result completely resolves problem designing implementable timeoptimal algorithm sorting n elements using psorter importantly however result shows order achieve optimal time performance needed sorting network depth olog2 p example batchers classic bitonic sorting network b introduction recent advances vlsi made possible implement algorithmstructured chips building blocks highperformance computing systems since sorting one fundamental computing problems makes sense endow generalpurpose computer systems specialpurpose parallel sorting device invoked whenever services needed article address problem sorting n elements using sorting device io size p n arbitrary p fixed sorting device used either psorter sorting network fixed io size p assume input well partial results reside several constantport memory modules addition achieving timeoptimality crucial sort without memory access conflicts reallife applications number n elements sorted much larger fixed size p sorting device accommodate situation sorting device must used repeatedly order sort input following natural question arises one schedule memory accesses calls sorting device order achieve best possible sorting performance clearly question find appropriate answer power sorting device fully utilized psorter sorting device capable sorting p elements constant time computing models p sorter exist example known p elements sorted o1 time p theta p reconfigurable work supported onr grant n000149710526 nsf grants ccr9522093 ecs9626215 louisiana grant leqsf199699rda16 department computer science old dominion university norfolk va 235290162 usa z istituto di elaborazione dellinformazione cnr pisa 56126 italy x department computer science university texas dallas richardson richardson mesh 3 7 8 beigel gill 2 showed task sorting n elements n p n log n log p calls psorter presented algorithm achieves bound however algorithm assumes p inputs psorter fetched unit time irrespective location memory since general address patterns operands psorter operations irregular appears algorithm 2 cannot realistically achieve time complexity theta n log n log p unless one solve constant time addressing problem inherent accessing p inputs psorter scattering output back memory spite result 2 poses interesting open problem namely designing implementable theta n log n log p time sorting algorithm uses psorter consider algorithm sorts n elements using psorter ofn p time clear algorithm also sorts n elements using sorting network io size p ofn p time main reason task sorting p elements using network requires odt proportional depth dt maximum number nodes path input output network thus psorter operation replaced naively individual application time required sorting becomes odt delta fn p eliminate odt slowdown factor network must used pipelined fashion turn pipelining requires sufficient parallelism psorter operations identified exploited recently olariu pinotti zheng 9 introduced simple restrictive design row merge model showed model n elements sorted theta log n time using either psorter sorting network io size p achieve better sorting performance new algorithmstructured architecture must designed involves devising sorting algorithm suitable hardware implementation time architecture algorithm executed directly algorithmarchitecture combination commonly referred hardwarealgorithm major contribution article present first realistic hardwarealgorithm design sorting arbitrary number input elements using fixedsize sorting device optimal time strictly enforcing conflictfree memory accesses introduce parallel sorting architecture specially designed implementing carefully designed algorithm components architecture include parallel sorting device set randomaccess memory modules set conventional registers control unit architecture simple feasible vlsi realization show architectural model n elements sorted theta n log n log p time using either psorter sorting network fixed io size p depth olog 2 p conjunction theoretical work 2 result completely resolves problem designing implementable time optimal algorithm sorting n elements using psorter importantly however result shows order achieve optimal sorting performance psorter really necessary needed sorting network depth olog 2 p example batchers classic bitonic sorting network see exceedingly important since known implementation psorter requires powerful processing elements whereas batchers bitonic sort network uses simple comparators architectural assumptions section describe architectural framework within specify optimal sorting algorithm using fixedsize sorting device consider sequential sorting algorithm adequate case consequently assume assumption implies addressing purposes need least 2 log p bits 1 readers convenience figure 1 depicts design 9 keep figure simple control signal lines shown basic architectural assumptions sorting model include r r r r r r r r r memory modules ar ar ar ar ar ar ar ar ar sorting device control unit figure 1 proposed architecture data memory organized p independent constantport memory modules word assumed length w bits w 2 log p assume n input elements distributed evenly arbitrarily among p memory modules words address memory modules referred memory row memory module randomly addressed address register ar associated adder register ar loaded word read memory module row address broadcast cu see ii set data registers r 1 p capable storing w refer word stored register r composed word since consists three fields ffl element field w bits storing element ffl long auxiliary field log p bits ffl short auxiliary field 05 log p bits 1 remainder article logarithms assumed base 2 fields arranged element field left long auxiliary field left short auxiliary field field register r loaded independently memory module ith output sorting device broadcast cu output register r connected ith input sorting device cu memory module assume ffl constant time p elements data registers loaded address registers stored p modules addressed address registers ffl bits field register r 1 p setreset 0s constant time ffl fields data register r 1 p compared particular value individual fields set special value depending outcome comparison moreover parallel compareandset operation takes constant time iii sorting device fixed io size p form psorter sorting network depth olog 2 p assume sorting device provides data paths width w 15 log p bits input output sorting device used sort composed words combination element auxiliary fields case sorting network used sorting device assumed sorting network operate pipelined fashion iv control unit cu short consisting control processor capable performing simple arithmetic logic operations control memory used store control program well control data cu generates control signals sorting device registers memory accesses cu broadcast address element memory modules andor data registers read element data register assume operations take constant time described minimum hardware requirements architectural model case sorting network used sorting device one use halfpipelining scheme input network provided groups rows next group supplied output previous group obtained depth sorting network sorting network operate full capacity one may add additional set address resp data registers one set address resp data registers used read operations order set used write operations operations performed concurrently let us estimate vlsi area design uses hardware data memory sorting device cu word model ie assuming word length w constant exclude area taken cu highperformance computer system one processors assigned task controlling parallel sorting subsystem clearly extra area used address data registers amounts op exceed vlsi area implementation psorter sorting network io size p include vlsi area running data memory address bus width log n bits control signal lines data memory sorting device since needed architecture involving data memory sorting device pointed architecture p memory modules involving total n p 2 words control circuitry requires least omegagamma01 flog p log n area since operations performed control processor simple assume takes constant area length control memory words least log n length data memory addresses become apparent algorithms require n data memory consequently control memory words length olog n control program simple takes constant memory however n used control information stored data memory 3 extended columnsort algorithm section present extension well known columnsort algorithm 5 extended column algorithm implemented architectural model invoked repeatedly sorting large number elements two known versions columnsort 5 6 one involves eight steps seven provide extension 8step columnsort 7step version map well architecture columnsort designed sort columnmajor order matrix r rows columns classic columnsort contains 8 steps oddnumbered steps involve sorting columns matrix independently evennumbered steps permute elements matrix various ways permutation step 2 picks elements columnmajor order lays rowmajor order permutation step 4 reverse step 2 permutation step 6 amounts b rc shift elements column permutation step 8 reverse permutation step 6 8step columnsort works assumption r 5 leighton poses open problem extend range applicability columnsort without changing algorithm drastically provide extension show one additional sorting step necessary sufficient complete sorting case r ss gamma 1 extension seen trading one additional sorting step larger range applicability algorithm figure 2 step step application extended columnsort algorithm first eight steps correspond classic 8step columnsort figure 2 shows matrix r rows columns condition r satisfied first eight steps example correspond 8step columnsort algorithm produce sorted matrix adding one step step 9 elements column sorted obtain extended columnsort algorithm assume matrix r rows columns numbered 0 r gamma 1 0 gamma 1 respectively arguments rely part following wellknown gem computer science mentioned knuth 4 proposition 1 let matrix whose rows sorted sorting columns rows remain sorted following result proved 5 lemma 1 element x ends position j end step 3 x rank least following result mentioned without proof 5 lemma 2 element x ends position j end step 3 rank si proof interested determining lower bound number elements known larger equal x purpose note since end step 3 element x position known larger equal x among known smaller equal gamma j elements columns end step 1 remaining must smaller equal elements column end step 1 consequently x known smaller equal least rs elements follows rank x si sj claimed 2 later reference choose r lemma 3 element x ends column c end step 4 correct position x sorted matrix one pairs columns 1 proof consider generic element x ended position j end step 3 permutation specific step 4 guarantees x moved step 4 position corresponds sorted matrix element rank si j general correct position x however shall prove x close correct position following sense x column c end step 4 sorted matrix x must one pairs columns 1 recall virtue lemmas 1 2 combined x rank smaller si larger si sj moreover simple algebraic manipulations show consider elements z ranks si respectively number n z elements matrix lying z sorted order 2 observe equation 4 implies z must lie adjacent columns sorted matrix saw end step 4 x lies position corresponding element rank sorted matrix confirms x lies somewhere z assume x lies column c end step 4 thus correct position x one columns c gamma 1 c case z column x one columns c c column x 2 lemma 4 rows sorted end step 4 proof consider arbitrary column k 0 k gamma 1 end step 3 permutation specified step 4 guarantees first r elements column k appear positions k ks k2s column 0 next group r elements appear positions k ks k2s since columns sorted end step 3 follows rows k ks sorted end step 4 since k arbitrary conclusion follows 2 lemma 5 element x bottom half column c end step 5 correct position sorted matrix one columns c c 1 proof lemma 3 know correct position x one pairs columns 1 thus prove claim need show x cannot column c gamma 1 purpose begin observing proposition 1 lemma 4 combined rows columns sorted end step 5 suppose element x ends row b rc end step 5 x belongs column c gamma 1 sorted matrix elements matrix columns c belonging rows 0 must belong column c gamma 1 lemma 3 elements already columns 0 must belong columns 0 sorted matrix thus least additional elements must belong column c gamma 1 contradiction 2 perfectly similar way one prove following result lemma 6 element top half column c end step 5 correct position sorted matrix one columns c gamma 1 c suppose find end step 8 8step columnsort lemma 7 every item x column c end step 8 must column c sorted matrix proof begin showing element column c column proceed induction c basis trivial element column 0 lie column left assume 5 true columns less c words element ends one columns end step 8 lie column left need prove statement also holds column c see must case consider first element u lies bottom half column c end step 8 end step 5 u must either bottom half column c top half column c 1 u belonged bottom half column c lemma 6 must belong columns c c 1 sorted matrix u belonged top half column c must belong columns c c 1 sorted matrix therefore either case u cannot belong column c gamma 1 next consider element v lies top half column c end step 8 v belonged elements bottom half column c gamma 1 well elements occurring v column c must belong column c gamma 1 induction hypothesis element lies column end step 8 lie column c gamma 2 lemmas 5 6 combined element lies top half column c gamma 1 belong column c reached contradiction column must contain r elements thus 5 must hold proved element column belong column left symmetric argument shows element belongs column immediately right completing proof 2 lemma 7 one sorting step completes task thus obtained 9step columnsort trades additional sorting step larger range r versus theorem 1 extended 9step columnsort algorithm correctly sorts r theta matrix r ss gamma 1 4 basic algorithm section show sort rowmajor order using architectural model enforcing conflictfree memory accesses resulting algorithm referred basic algorithm turn first stepping stone design timeoptimal sorting algorithm basic algorithm implementation extended columnsort discussed section 3 presentation focus efficient use generic sorting device io size p mind shall keep track following two parameters become key ingredients evaluating running time algorithm ffl number calls sorting device ffl amount time required data movement tasks involve sorting assume sort rowmajor order elements memory rows case 2 perfectly similar assume without loss generality input placed order memory rows integer 0 sorted elements placed memory rows b 2 ranges overlap step 1 sort rows independently step consists following loop read ith memory row sort nondecreasing order using sorting device resulting sorted sequence parallel store x j ith word memory module j endfor endfor 2 calls sorting device op 1 data movement involving sorting step 2 permuting rows permutation specific step 2 columnsort prescribes picking elements memory row laying column column illustration consider case initial element distribution featured following matrix end step 2 permuted matrix reads careful examination permuted matrix reveals consecutive elements memory row end memory module eg elements 1 2 3 occur memory module 1 therefore order achieve desired permutation without memoryaccess conflicts one devise different way picking elements various memory rows purpose find convenient view element x stored memory module ordered triple hx rowx modulexi rowx modulex stand identity memory row memory module respectively containing x let rowxjmodulex denote binary number obtained concatenating binary representations rowx modulex details spelled following procedure procedure begin parallel read th word memory module j endfor using sorting device sort p elements nondecreasing order rowxjmodulex resulting sorted sequence parallel store x j th word memory module j endfor endfor clearly procedure involves p 1 iterations iteration p words read one memory module sorted written back memory one word per module read write memory access conflicts would seem though memory module requires arithmetic unit compute address word accessed iteration fact point arithmetic capabilities required specifically use p 1 memory rows store offsets used memory access operations example offsets beginning step 2 address registers contain 1 first iteration entries first row offset matrix added contents address registers guaranteeing correct word memory module accessed illustration referring 7 note offsets first row indicate words involved read operation found address memory module 1 address memory module 3 key observation understanding happens iterations column offset matrix 7 entry first row available subsequent elements column generated modulo 2 arithmetic architecture computation performed adder associated address register turn observation implies fact offset matrix need stored entries generated fly yet another important point note ordered triple hx rowx modulexi composed word three fields composed words sorted using combination two fields namely rowx modulex clearly modulex log p bits seems order represent rowx need log n bits actually replace rowx address offset contained offset matrix discussed since entries matrix integers larger p 1 logp bits sufficient therefore concatenation rowxjmodulex involves 15 log p bits discussion clear step 2 requires p 1 2 calls sorting device time spent data movement operations involving sorting bounded op 1 step 3 step 1 step 4 permutation step 2 performed reverse permuted set words stored rows step 5 step 1 step shifting rows shall permute elements slightly differently way specified columnsort however easy verify elements supposed end given row indeed end desired row since step 7 sorts rows order elements placed row step 6 immaterial permutation step 6 best illustrated considering particular example specifically permutation specified step 6 columnsort involving three rows shown 6 permutation bit different assume p 1 consecutive input rows stored memory starting memory row 1 addition assume memory row available us contents immaterial denoted motivation anchored observation step 7 sort memory rows elements rows sorted step 9 consequently rows sorted step 7 rows 1 details follow procedure row shift begin sigma pupsilon parallel read ith word memory module j store gamma 1th word memory module j endfor endfor important note implementation step 6 involve sorting however op 1 time spent data movement operations involve sorting step 7 step 1 step 8 simply reverse data movement step 6 step 9 step 1 summarize proved following result theorem 2 set p 3 elements stored p 1 memory rows sorted rowmajor order without memoryaccess conflicts 7p 1 2 calls sorting device io size p op 1 data movement involving sorting essentially way one prove following companion result theorem 2 theorem 3 task sorting rowmajor order set mp elements stored memory rows performed without memoryaccess conflicts 7m calls sorting device io size p om time data movement operations involving sorting remainder section present important application basic algorithm suppose wish merge two sorted sequences algorithm merging b relies following technical result lemma 8 assume n 2 e b b n 2 c1 let sequence obtained merging e n element sequence strictly larger element sequence proof begin showing 1 ne strictly larger element e assumption n 2 e b b n 2 c1 guarantees claim false element strictly larger element c k evaluate position element c k sorted sequence c observe b nc elements c come known larger equal therefore strictly larger c k consequently n even b nc elements c larger c k implying k b nc contradiction hand n odd ne b nc1 assumption b n 2 e larger therefore strictly larger c k case least ne elements c strictly larger c k follows contradicting c k belongs e next claim c larger element e since c sorted statement false c b k k k b nc1 notice elements c come b smaller equal b k therefore strictly smaller c follows contradicting c belongs completes proof lemma 2 mirror argument proves following companion result lemma 8 lemma 9 assume n sequence obtained merging element sequence 2 c strictly larger element sequence worth noting lemmas 8 9 combined show given two sorted sequences size n task merging handled follows begin splitting two sequences two sequences size n element first one strictly larger element second one separation available remains done sort two sequences independently noteworthy feature approach fits extremely well architecture 2 consider sorted sequence stored memory rows stored memory rows 1 goal merge two sequences store resulting sorted sequence memory rows r r 1 details follow procedure merge two groups begin mp use basic algorithm sort b 1 nonincreasing order c mp c store result memory rows r else use basic algorithm sort 1 nonincreasing order c mp c store result memory rows r copy memory row r row r copy memory row r gamma memory row r b endfor odd copy leftmost pe elements row r leftmost pe positions row r copy rightmost b pc elements row r rightmost b pc positions row r endif endif odd copy leftmost pe elements memory row r c leftmost pe positions row r copy rightmost b pc elements row r c rightmost b pc positions row r endif copy memory row r c copy memory row r c endfor use basic algorithm sort memory rows r r nondecreasing use basic algorithm sort memory rows r nondecreasing order obvious procedure merge two groups implemented directly architectural model one point worth discussing however specifically task sorting sequence nonincreasing order performed architecture follows signs elements sorted flipped resulting sequence sorted nondecreasing order finally signs flipped back original value correctness procedure follows lemmas 8 9 moreover procedure requires three calls basic algorithm consider task sorting collection 2mp memory rows partitioned input two subgroups consecutive memory rows use basic algorithm sort group done complete sorting using procedure merge two groups thus following result theorem 4 task sorting 2mp 2 elements stored 2m memory rows performed five calls basic algorithm om time data movement operations involving sorting 2 5 efficient multiway merge algorithm consider collection 1 sequences size p assume stored topdown order 1 consecutive memory rows multiway merge problem sort sequences rowmajor order goal section propose efficient algorithm multiway merge multiway merge problem show implemented architecture procedure multiway mergeam size p output resulting sorted sequence stored rowmajor order mp igamma2 contiguous memory rows g step 1 select sample size mp igamma2 2 retaining every pth element sequence j 1 j move dmp igamma4 discussed step 2 one call sorting device else one call basic algorithm else frecursively multiway merge sg endif igamma22 sorted version step 3 partition p igamma2 containing 2mp elements discussed move elements buckets without memory access conflicts step 4 sort buckets individually using basic algorithm procedure merge two groups step 5 coalesce sorted buckets desired sorted sequence 2 notice sample stored one memory row remainder section devoted detailed implementation procedure architecture 51 implementing step 1 step 2 convenience view matrix size mp igamma2 2 theta p tth element memory row j denoted aj element aj p termed leader memory row j goal step 1 extract sample retaining leader every memory row along identity k subsequence k leader belongs context k referred sequence index two disjoint groups dmp igamma4 consecutive memory rows set aside store sample corresponding set sequence indices remainder subsection view memory rows allocated two matrices size dmp igamma4 p intention end step 1 sx ix store yth leader sequence index respectively see step 1 implemented without memory access conflicts notice memory row leader extracted stored memory module p generic memory row j cu interchanges temporarily elements aj p aj dj p interchange undone end step 1 next dmp igamma4 parallel read operations performed followed two parallel write operations jth parallel read operation picks kth word memory module k 1 k p p elements stored jth memory row allocated second parallel write operation stores sequence indices p elements jth memory row allocated thus step 1 implemented omp igamma2 data movement calls sorting device sampling process continues recursively level reached procedure multiway merge invoked either case corresponding sample set stored one memory row sorted one call sorting device 4 case sample set stored memory rows sorted one call basic algorithm since operation sorting one row direct discuss way basic algorithm operates context conceptually process sorting samples benefits viewed one sorting concatenation sjk sample element k sequence index recall described section 2 design assumes sorting device provides data paths size w 15 log p inputs outputs implies steps 1 3 5 7 9 extended columnsort executed directly sort row r corresponding row r cu loads two parallel read operations element field short auxiliary field data register r j 1 j p sr j ir j long auxiliary field 0 let rj k rj element sequence index stored register r j let rj jk rj denote concatenation next contents data registers supplied input sorting device let received r j sorting rj 0 k rj 0 stored respectively element short auxiliary field r j two parallel write operations cu stores element field short auxiliary field register r j 1 j p sr j ir j respectively steps 2 4 6 8 basic algorithm perform permutations implementation steps 6 8 involve sorting case data movement involving sample elements corresponding sequence indices performed two companion phases specifically viewing sample set corresponding sequence index set two matrices permutation performed steps 2 4 basic algorithm involve data movement operations sorting data movement operations steps similar steps 6 8 detailed recall sorting operations steps 2 4 basic algorithm performed concatenation two auxiliary fields storing relative row number column number element hence perform two companion sorting phases one permuting sample elements permuting sequence indices clearly implemented time complexity easy confirm end step 2 procedure multiway merge sample set sorted rowmajor order furthermore viewed matrices ix sequence index sample element sx let sorted version equation 8 used step 3 partition elements buckets order leader row needs learn rank 8 next goal associate every memory row rank task carried two stages first stage using sequence index rank cu assigns row number rows every rows either exact row number extracted step 1 case leaders several rows equal rows achieves possible reassignment leaders rows details first stage spelled procedure assign row numbers presented convenience use matrix representation operations easily implemented using addresses words corresponding sx initially contains sequence indices samples procedure terminates ix contains rows corresponding procedure assign row numbers begin r k row number first memory row storing sequence k endfor 2 e endfor endfor second stage cu assigns rank memory row rows contained ix operations performed matrix representations easily implemented using addresses words corresponding sx ix since readwrite operations used procedure described total time spent operations bounded omp igamma2 52 implementing step 3 step 4 rank leader known ready partition buckets first objective construct collection buckets following conditions satisfied b1 every element belongs exactly one bucket b2 bucket contains 2mp elements b3 every j 1 strictly larger element b j presenting bucket partitioning scheme need definitions let mp igamma22 8 memory row leader b said regular respect bucket b j j notice equation 9 guarantees every memory row regular respect exactly one bucket identity bucket determined cu constant time conversely respect bucket exactly regular memory rows memory row r leader b sequence k 1 k termed special respect bucket b standing leader preceding memory row k let memory rows leaders b regular respect buckets respectively j important note equation 10 implies memory row whose leader b special respect buckets conceptually bucket partitioning scheme consists two stages first stage associating regular special rows respect generic bucket 2 obtain set c j candidate elements second stage assign elements buckets way actual elements assigned bucket b j form subset candidate set c j specifically element x memory row regular respect bucket b j assigned b j one conditions satisfied j gamma1m j gamma1m x jm whenever j elements assigned bucket virtue 11 12 longer eligible assigned buckets remainder assignment process consider element x assigned bucket respect memory row regular element x assigned exactly one buckets respect memory row containing x special assume memory row containing x special respect buckets smallest index 1 n lx one equations 11 12 holds j n place j x assigned bucket b jn next result shows buckets defined satisfy conditions b1b3 conditions b1 b2 b3 proof clearly assignment scheme guarantees every element gets assigned bucket element gets assigned one bucket thus condition b1 verified notice 9 10 combined every j 1 2 candidate set c j respect bucket b j contains 2m memory rows therefore 2mp elements moreover indicated elements actually assigned bucket b j subset c j proving b2 finally equations 11 12 guarantee element x belongs bucket b j cannot strictly larger element bucket b k k thus condition b3 holds well 2 worth noting preceding definition buckets works perfectly well even input elements identical fact elements distinct one define buckets simpler way moreover case distinct elements steps 13 procedure multiway merge simplified present implementation details assignment elements buckets write denote every j 1 2 ordered pair j gamma1m jm jth bounding pair notice equations 11 12 amount testing whether given element lies bounding pair b2 bucket contains 2mp elements motivates us set aside 2m memory rows bucket b j allocate first memory rows elements assigned b j coming regular memory rows respect b j allocate last memory rows elements assigned bucket b j reside special memory rows respect b j addition find convenient initialize contents 2m memory rows allocated b j 1s important note regular memory rows respect bucket b j naturally ordered 1 order corresponding leaders clarify last point recall 9 leaders belonging bucket b j j gamma1m1 j accordingly memory row whose leader j gamma1m1 first regular row respect b j memory row whose leader j gamma1m2 second regular row respect b j similarly fact sequence k sorted guarantees may contain one special memory row respect bucket b j case special row exists termed kth special memory row respect b j distinguish others order move elements buckets cu scans memory rows one one suppose current memory row scanned row r sequence k assume leader row r b leader row r gamma 1 using equation 9 cu establishes row r regular respect bucket b j similarly previous memory row regular respect bucket case row r first row k j 0 set 1 next elements memory row r read element fields data registers cu broadcasts registers bounding pair j gamma1m jm using compareandset register stores short auxiliary field 1 corresponding element assigned bucket b j virtue 11 12 0 otherwise say element x data register marked value short auxiliary field otherwise x unmarked clearly every element x marked end first broadcast assigned bucket parallel write operation cu copies marked elements corresponding words row allocated bucket b j done using compareandset marked elements data registers set 1 short auxiliary fields cleared cu broadcasts data registers increasing order bounding pairs buckets us follow processing specific bucket b j 0 received bounding pair data register determines whether value x stored element field satisfies 11 12 j 0 place j marks x accordingly parallel write operation cu copies marked elements corresponding words next available memory row allocated bucket b j next using compareandset marked elements data registers set 1 short auxiliary fields cleared process repeated remaining buckets respect row r special reader fail note processing row r complete elements moved bucket assigned moreover 9 10 altogether mp igamma2 regular rows mp igamma2 special rows total time involved assigning elements buckets bounded omp igamma2 calls sorting device summary step 3 implemented omp igamma2 data movement calls sorting device step 4 buckets sorted independently bucket p 1 memory rows sorted one call basic algorithm otherwise bucket partitioned two halves sorted one call basic algorithm finally two sorted halves merged using procedure groups theorem 4 task sorting buckets individually performed omp igamma2 calls sorting device omp igamma2 data movement involving sorting 53 implementing step 5 motivate need processing specific step 5 note sorting bucket individually step 4 may number 1s bucket refer elements empty memory rows consisting entirely empty elements termed empty rows memory row termed impure partly empty clear bucket may one impure row memory row contains empty elements referred pure task coalescing nonempty elements buckets mp igamma2 consecutive memory rows referred compaction easy discussion assume sorted buckets stored consecutive rows nonempty rows b 2 follow nonempty rows b 1 nonempty rows b 3 follow nonempty rows b 2 assuming empty rows removed compaction process consists three phases phase 1 let c row sequence obtained concatenating nonempty rows b j obtained step 4 multiway merge increasing order indices partition sequence c subsequences x c j contains p 1 consecutive rows c except last subsequence c x may contain fewer rows clearly x 2mp igamma3 2 use basic algorithm sort subsequences independently let sorted subsequence corresponding c c 0 empty rows eliminated future consideration let row sequence obtained concatenating rows c 0 increasing order indices partition sequence subsequences j contains p 1consecutive rows except last subsequence may contain fewer rows use basic algorithm sort subsequences independently let sorted subsequence corresponding 0 empty rows eliminated let e row sequence obtained concatenating rows 0 increasing order indices lemma 11 preceding row every impure row except last row e pure row proof notice following fact except last row every row either contains least p 1nonempty elements contains fewer p 1 nonempty elements preceding row must pure row row c contains least one nonempty element impure row generated one two conditions c j contains fewer p nonempty elements contains one row impure row nonempty elements coming p 1 impure rows c j b c j contains p nonempty elements c 0 contains one impure row preceding row pure row lemma directly follows fact 2 phase 2 phase computes set parameters used next phase let w total number nonempty rows e assume rows e located row 1 row w every j 1 stand number nonempty elements impure memory row c j first subtask phase 2 determine igamma2 consider generic impure row c j determine n j cu reads entire row c j data registers r 1 every k 1 k p c j th word memory module k read register r k long auxiliary field data register r k set k using compareandset feature cu instructs register r k reset auxiliary field gamma1 element holds 1 ie empty next data registers loaded sorting device sorted increasing order long auxiliary fields easy confirm sorting largest value k j precisely position rightmost nonempty element memory row c j therefore cu sets consequently task computing numbers calls sorting device op igamma2 readwrite operations involve sorting numbers available cu computes prefix sums oe course involves additions performed cu omp igamma2 call sorting device let e mod g define phase 3 construct row group g consecutive rows follows ff kgamma2 0 row starting row e k else row kp 1 starting row e k ending row e k row kp 1 ending row e g row w note e k e k1 may share two rows lemma 11 contains least p1p2elements last two rows contains least p elements g perform following operations sort using basic algorithm b replace fi smallest elements 1s c sort using basic algorithms ff k 0 k g eliminate last row e g perform b c let k row group obtained e k let f row sequence obtained concatenating rows increasing order indices f compaction c setting selected elements row 1s done o1 time compareandset operation example setting leftmost elements row 1s carried follows read row r cu broadcast r r compare set content 1 modified row written back memory array based lemma 10 easy verify elements f sorted order step 5 implemented omp igamma2 calls sorting device omp igamma2 data movement involving sorting 54 complexity analysis correctness multiway merge algorithm obvious turn complexity specifically interested assessing total amount data movement involving sorting required procedure multiway merge specifically let jmp stand time spent data movement tasks involve use sorting device takes o1 time case takes om time refer theorem 3 finally 4 previous discussion shows step 1 step 3 step 4 step 5 require omp igamma2 recursively jmp igamma2 time thus obtain following recurrence system easy confirm p 4 solution recurrence satisfies jmp similar analysis repeated shows total number calls sorting device io size performed procedure multiway merge merging sequences 2 bounded omp igamma2 summarize discussion state following important result theorem 5 procedure multiway merge performs task merging quences size p 2 architecture using omp igamma2 calls sorting device io size p omp igamma2 data movement involving sorting 6 sorting algorithm basic algorithm multiway merge disposal position present details sorting algorithm using sorting device fixed io size p input set sigma n items stored evenly possible p memory modules dummy elements value 1 added necessary ensure memory modules contain n e elements dummy elements removed sorting goal show using architecturealgorithm combination input sorted n log n log p time data space assume p 16 along 1 implies log equation 13 important analysis section discussion focus case sorting network io size p depth olog 2 p used sorting device 3 natural candidate network batchers classic bitonic sorting network 1 shall tacitly assume recall virtue 1 4 turn equation 14 guarantees log n log p 1 point note 14 15 combined guarantee log 2 16 write observe 14 reasons become clear later pad sigma appropriate number 1 elements way n 0 standing length resulting sequence sigma 0 important note 14 17 19 combined guarantee suggesting number memory rows used sorting algorithm bounded n show indeed case sorting algorithm consists iterations order guarantee overall running time n log n log p ensure iteration performed n see shortly sorting network used following three contexts sort individually memory rows 3 turns complexity claim holds sorting device used instead psorter ii sort individually groups consisting consecutive memory rows iii sort individually groups consisting 2m consecutive memory rows efficient implementation use simple pipelining memory rows sort input sorting network one initial overhead olog 2 p time subsequent time unit produces sorted memory row clearly total sorting time bounded olog efficient implementation ii uses interleaved pipelining let g gm groups wish sort interleaved pipelining begin running step 1 basic algorithm pipelined fashion group g 1 group g 2 words step 1 basic algorithm performed groups using simple pipelining perfectly similar fashion simple pipelining used carry step 2 basic algorithm groups g 1 strategy used remaining steps basic algorithm require use sorting device consequently total amount time needed sort groups using interleaves pipelining bounded olog efficient implementation iii relies extended interleaved pipelining let g gm groups want sort recall theorem 4 states sorting group 2m consecutive memory rows requires five calls basic algorithm extended interleaved pipelining consists five interleaved pipelining steps corresponding one five calls basic algorithm thus task sorting groups performed olog time discuss iterations sorting algorithm detail iteration 1 input partitioned n 0 groups involving p 1 memory rows using interleaved pipelining group sorted individually discussed running time iteration 1 bounded olog iteration 1 input iteration k collection n 0 ksorted sequences size p stored consecutive memory rows output iteration k collection n 0 1sorted sequences size p stored p consecutive memory rows partitioned sorted sequences n 0 consecutive sequences proceed sort group gk j call multiway merges 1 k refer call multiway merges 1 k call first level observe since n altogether n way merge calls first one group step 1 multiway merge call first level extract sample 2 k j 1 k consisting p 1 sorted sequences size p stored consecutive memory rows turn every j 1 j n sample 2 k j sorted invoking multiway merges 2 k referred multiway merge call second level step 1 multiway merge call second level extracts sample 3 k j every u 1 2 c multiway merge call level u form multiway merge step 2 call multiway merges u k multiway merge call level u1 form multiway merges u1 k let r ku denote total number rows samples u k j level u clearly r p u 13 r ku qp r even 2 recursive calls multiway merge end level b k gamma1c last call form note depending whether k odd proceed demonstrate takes k1 time showing total time required five steps multiway merge calls level u bounded ku consider particular level u step 1 multiway merge calls level u performed samples u k j increasing order j samples u1 k extracted one clearly total time operations ku perform step 3 multiway merge calls level u increasing order j partition buckets samples u k using corresponding u1 k j lemma 10 sample buckets bucket contains 2p 3 elements discussed subsection 52 task moving elements u k j buckets carried op using sorting device thus total time partitioning samples u k multiway merge calls level u bounded n 0 step 4 multiway merge call level u sorts buckets involving elements u k j obtained step 3 perform step 4 multiway merge calls level u increasing order j use extended interleaved pipelining 2 sort buckets u k j altogether n 0 2u1buckets u k js thus total time sorting buckets bounded total time sorting buckets multiway merge calls level u ku step 5 multiway merge call level u three phases discussed subsection 53 operations phase 1 phase 3 involve sorting device carried using interleaved pipelining operations phase 2 involves sorting device carried using simple pipelining clearly time complexity step 5 multiway merge calls level u bounded olog evaluate time needed perform step 2 multiway merge calls level u first consider call level b k gamma1c multiway merges b 1 sample extracted step 1 call p elements odd use simple pipelining sort samples b k use interleaved pipelining 2 sort samples b k either case time required bounded n 0 n 0 thus total time steps 1 5 multiway merge calls level b k gamma1c kb next time perform step 2 multiway merge calls level u inductively derived ku using claim total time steps 1 3 4 5 multiway merge calls level u ku hypothesis step 2 multiway merge calls level turn proves total time required multiway merge calls level u bounded ku shown time required multiway merge calls level u iteration k ku conclude total time perform iteration k k1 n iteration 2 n input elements sorted end iterations assume algorithm terminate iterations input iteration gamma 1 collection sorted sequences 2 sequence size p 2 stored p tgamma2 consecutive rows complete sorting need merge q sequences desired sorted sequence task performed call multiway mergesigma detailed implementation multiway mergesigma using sorting network sorting device analysis involved almost iteration 2 iteration different parameters used interleaved pipelining 2 used step multiway merge iterations 2 gamma 2 corresponding step multiway merge iteration uses interleaved pipelining similarly extended interleaved pipelining 2 used step multiway merge iterations 2 gamma 2 corresponding step multiway merge iteration uses extended interleaved pipelining q multiway merge call level b tgamma1c multiway merges b odd 4 recursion stops b tgamma1cth level sample set b obtained step 1 multiway merge call level b tgamma1c qp 1 odd qp elements even let r tgamma1u total number memory rows simple induction conclude multiway merge call level u 1 takes tgamma1u time running time iteration running time multiway merge call first level takes tgamma11 shown iterations multiway merge implemented time n conclude running time sorting algorithm n log n log p since psorter abstracted sorting network io size p depth o1 time complexity stands sorting device used psorter working data memory iteration simply sample size multiway merge call level u p times sample size multiway merge call level u1 since working data memory one iteration reused another iteration total data memory required sorting algorithm remains summarizing previous discussions proved main result work theorem 6 using simple architecture set n items stored n memory rows sorted rowmajor order without memory access conflicts n log n log p time data space using either psorter sorting network io size p depth olog 2 p sorting device r sorting n objects ksorter optimal sorting algorithm reconfigurable mesh art computer programming tight bounds complexity parallel sorting introduction parallel algorithms architectures arrays sorting o1 time reconfigurable mesh size n sorting n numbers n sort n items using sorting network fixed io size tr ctr classifying matrices separating rows columns ieee transactions parallel distributed systems v15 n7 p654665 july 2004 giuseppe campobello marco russo scalable vlsi speedarea tunable sorting network journal systems architecture euromicro journal v52 n10 p589602 october 2006 brian grattan greg stitt frank vahid codesignextended applications proceedings tenth international symposium hardwaresoftware codesign may 0608 2002 estes park colorado
computational study routing algorithms realistic transportation networks carry experimental analysis number shortestpath routing algorithms investigated context transims transportation analysis simulation system project main focus paper study various heuristic well exact solutions associated data structures affect computational performance software developed realistic transportation networks purpose used road network representing high degree resolution dallas fortworth urban areawe discuss experimentally analyze various onetoone shortestpath algorithms include classical exact algorithms studied literature well heuristic solutions designed take account geometric structure input instancescomputational results provided compare empirically efficiency various algorithms studies indicate modified dijkstras algorithm computationally fast excellent candidate use various transportation planning applications well related technologies b introduction transims multiyear project los alamos national laboratory funded department transportation environmental protection agency main purpose transims develop new methods studying transportation planning questions prototypical question considered context would study economic social impact building new freeway large metropolitan area refer reader tr95a website httptransimstsasalanlgov obtain extensive details transims project main goal paper describe computational experiences engineering various path finding algorithms context transims algorithms discussed new discussed operations research computer science community although extensive research done theoretical experimental evaluation shortest path algorithms empirical research focused randomly generated networks special classes networks grids contrast much work done study computational behavior shortest path related routing algorithms realistic traffic networks realistic networks differ random networks well homogeneous structured networks following significant ways realistic networks typically low average degree fact case average degree network around 26 similar numbers reported zn98 contrast random networks used pa84 cases average degree 10 ii realistic networks uniform fact one typically sees one two large clusters downtown neighboring areas small clusters spread throughout entire area interest iii empirical studies random networks edge weights chosen independently uniformly random given interval contrast realistic networks typically short links reasons specific application mind main focus paper carry experimental analysis number shortest path algorithms real transportation network subject practical constraints imposed overall system see also section 6 point peculiarities network effect intuition features network consider crucial observations rest report organized follows section 2 contains problem statement related discussion section 3 discuss various algorithms evaluated paper section 4 summarizes results obtained section 5 describes experimental setup section 6 describes experimental results obtained section 7 contains detailed discussion sults finally section 8 give concluding remarks directions future research also included appendix section 81 describes relevant algorithms finding shortest paths detail problem specification justification problems discussed formally described follows let gv e undirected graph edge e 2 e one attribute denoting weight cost edge e assume weights nonnegative floating point numbers definition 21 onetoone shortest given directed weighted graph g source destination pair find shortest respect w path p g note experiments carried shortest path pair nodes finding shortest path trees much literature experimental analysis uses second measure gauge efficiency choice consider running time oneto one shortest path computation motivated following observations 1 setting need compute shortest paths roughly million travelers highly detailed networks travelers different starting points example portland 15 million travelers 200 000 possible starting locations thus given starting location could reuse tree computation ten travelers 2 wanted algorithms extensible take account additional featuresconstraints imposed system example traveler typically different starting time hisher trip since use algorithms time dependent networks networks edge weights vary time shortest path tree different traveler second example need find paths travelers individual mode choices multimodal network formally given directed labeled weighted graph g representing transportation network labels edges representing various modal attributes eg label might represent rail line goal find shortest simple paths subject certain labeling constraints set feasible paths general criteria path selection varies much traveler traveler additional overhead reuse information unlikely pay 3 transims framework allows us use paths necessarily optimal motivates investigation fast heuristic algorithms obtain near optimal paths eg modified algorithm discussed heuristics idea bias focused search towards destination thus naturally motivating study oneone shortest path algorithms 4 finally networks anticipate deal contain 80 000 nodes around 120 000 edges networks storing shortest path trees amounts huge memory overheads 3 choice algorithms important objectives used evaluate performance algorithms include time taken computation real networks ii quality solution obtained iii ease implementation iv extensibility algorithm solving variants shortest path problem number interesting engineering questions encountered process experimentally evaluated number variants dijkstras algorithm basic algorithm chosen due recommendations made cherkassky goldberg radzik cgr96 zhan noon zn98 algorithms studied dijkstras algorithm binary heaps cgr96 algorithm proposed ai literature analyzed sedgewick vitter sv86 modification algorithm describe alluded sv86 bidirectional version dijkstras algorithm described lr89 analyzed lr89 also considered briefly recall algorithm modification proposed details algorithms found appendix underlying network near euclidean possible improve average case performance dijkstras algorithm exploiting inherent geometric information ignored classical path finding algorithms basic idea behind improving performance dijkstras algorithm sv86 hnr68 described follows order build shortest path use original distance estimate fringe vertex x ie x plus euclidean distance x thus use global information graph guide search shortest path resulting algorithm runs much faster dijkstras algorithm typical graphs following intuitive reasons shortest path tree grows direction ii search shortest path terminated soon added shortest path tree note algorithms require euclidean distance two nodes valid lower bound actual shortest distance nodes typically case road networks link distance two nodes road network typically accounts curves bridges etc least euclidean distance two nodes moreover context transims need find fastest paths ie cost function used calculate shortest paths time taken traverse link calculations need upper bound maximum allowable speed adequately account inaccuracies determine appropriate lower bound factor euclidean distance assumed delay link preprocessing step modify algorithm giving appropriate weight distance x choosing appropriate multiplicative factor increase contribution second component calculating label vertex intuitive standpoint corresponds giving destination high potential effect biasing search towards destination modification general yield shortest paths nevertheless experimental results suggest errors produced kept reasonably small 4 summary results ready summarize main results conclusions paper already stated main focus paper engineering tuning well known shortest path algorithms practical setting another goal paper provide reasons certain implementations practical standpoint believe conclusions along earlier results zn98 cgr96 provide practitioners useful basis select appropriate algorithmsimplementations context transportation networks general sultsconclusions paper summarized 1 conclude simple binary heap implementation dijkstras algorithm good choice finding optimal routes real road transportation networks specifically found certain types data structure fine tuning significantly improve performance implementation 2 results suggest heuristic solutions using underlying geometric structure graphs attractive candidates future research experimental results motivated formulation implementation extremely fast heuristic extension basic algorithm parameterized timequality tradeoff algorithm achieves setting appears quite promising 3 study suggests bidirectional variation dijkstras algorithm suitable transportation planning conclusions based two factors algorithm extensible general path problems ii running time outperform exact algorithms considered 5 experimental setup methodology section describe computational results implementations order anchor research realistic problems transims uses example cases called case studies see cs97 complete details allows us test effectiveness algorithms real life data case study concluded focused dallas fortworth dfw metropolitan area done conjunction municipal planning organization mpo known north central texas council governments nctcog generated trips whole dfw area hour period input traveler following format starting time starting location ending location 4 103 million trips 24 hours number nodes 4 roughly correct reality complicated nb97 cs97 links dallas network roughly 9863 14750 respectively average degree node network 26 route trips socalled focused network freeway links major arterials etc inside network area streets including local streets contained data base study area initially routed trips 5am 10am trips went study area retained resulting approx 300 000 trips 300 000 trips replanned iteration microsimulations details see eg nb97 cs97 3 random sample trips used computational experiments preparing network data received dfw metro number inadequacies point view performing experimental analysis corrected carrying analysis mention important ones first network found number disconnected components small islands consider pairs different components second serious problem algorithmic standpoint fact number links length less actual euclidean distance two end points cases due artificial convention used dfw transportation planners socalled centroid connectors always length 10 whatever euclidean distance cases pointed data errors case discrepancy disallows effective implementation type algorithms reason introduce notion normalized network links length less euclidean distance set reported length equal euclidean distance note take euclidean distance lower bound shortest path network recall want compute fastest path terms time taken instead shortest also make assumptions regarding maximum allowable speed network determine conservative lower bound minimal travel time points network preliminary experimental analysis carried following network modifications could helpful improving efficiency algorithms include removing nodes degrees less 3 includes collapsing paths also leaf nodes ii modifying nodes degree 3 replace triangle hardware software support experiments performed sun ultrasparc cpu 250 mhz running solaris 25 2 gigabyte main memory shared 13 cpus memory usage always 150 mb less general used sun workshop cc compiler optimization flag fast also performed experiment influence different optimization options without seeing significant differences advantage multiprocessor machine reproducibility results due fact operating system typically need interrupt live process requests processes assigned cpus experimental method 10000 arbitrary plans picked case study used timing mechanism provided operating system granularity 01 seconds 1 tick experiments performed system load exceed number available processors ie processors shared long condition violated experiment running times fairly consistent usually within relative errors 3 used subset following values measurable single specific number computations conclude reported results average running time excluding io number fringeexpanded nodes pictures fringeexpanded nodes maximum heap size number links length path software design used object oriented features well templating mechanism c easily combine different implementations also used preprocessor directives macros want introduce unnecessary run time overhead avoid example concept virtual inheritance software system classes encapsulate following elements computation network extensibility different levels detail lead small linear hierarchy plans pairs complete paths time stamps priority queue heap labeling graph using priority queue storing shortest path tree dijkstras algorithm expected approach leads apparent overhead function calls nevertheless compiler optimization detects overheads specifically earlier non templated implementation achieved roughly performance corresponding instance templated version results consistent similar observations working miniexamples explanation also confirmed outcome experiments observed reducing instruction count reduce observed running time might expected assuming would major overhead high level constructs would expect see strong influence number instructions executed running time observed 6 experimental results design issues data structures begin design decisions regarding data structures used number alternative data structures considered investigate results substantial improvement running time algorithm alternatives tested included following arrays versus heaps ii deferred update iii hash tables storing graphs iv smart label reset v heap variations vi struct arrays vs array structs appendix contains detailed discussion issues found indeed good programming practice using common sense avoid unnecessary computation textbook knowledge reasonable data structures useful get good running times alternatives mentioned find substantial improvement running time precisely differences found bigger unavoidable noise multiuser computing environment nevertheless 10 relative difference brief discussion various data structures tried found appendix analysis results plain dijkstra using static delays calculated reported free flow speeds produced roughly 100 plans per second figure 1 illustrates improvement obtained modification numbers shown corner network snapshots tell average 100 repetitions destroy cache effects subsequent runs running time particular odpair system ticks also gives number expanded fringe nodes note used different scales order clearly depict set expanded nodes overall found normalized network removed network anomalies explained faster basic dijkstras algorithm roughly factor 2 modified overdo heuristic next consider modified algorithm heuristic parameterized multiplicative factor used weigh euclidean distance destination distance source already computed tree call overdo parameter approach seen changing conservative lower bound used algorithm expected approximated lower bound experimental evidence suggests even large overdo factors usually yield reasonable paths note nice behavior might fail soon link delays directly related link length euclidean distance endpoints might expected network link lengths proportional travel times partially congested city result natural discuss timequality tradeoff heuristic function overdo parameter figure 2 summarizes performance figure xaxis represents overdo factor varied 0 100 steps 1 yaxis used multiple attributes explain first axis used represent average running time per plan attribute use log scale unit denoting 10 milliseconds depicted solid line average time taken without overdo 129 milliseconds per plan represents base measurement without taking geometric information account including time taken computing euclidean distances next overdo value 10 99 running times respectively 253 308 milliseconds hand quality solution produced heuristic worsens overdo factor increased used two quantities measure error maximum relative error incurred 10000 plans ii ticks 240 exp 6179 fr 233 ticks 064 exp 1446 fr 316 figure 1 figure illustrating number expanded nodes running dijkstra ii algorithms figures clearly show heuristic much efficient terms nodes visits graphs path outlined dark line fringe nodes expanded nodes marked dark spots underlying network shown light grey source node marked big circle destination small one notice different scales figures 9 time figure 2 figure illustrating tradeoff running time quality paths function overdoparamameter x axis represents overdo factor 0 100 axis used represent three quantities plotted log scale running time ii maximum relative error iii fraction plans relative error greater threshold value threshold values chosen 0 time figure 3 figure illustrating tradeoff running time quality paths function overdoparameter normalized network meaning axis depicted things previous figure fraction plans errors given threshold error types errors shown axis maximum relative error plot marked ranges 0 overdo factor 0 16 overdo value 99 error measure plot one curve threshold error 0 10 following conclusions drawn results 1 running times improve significantly overdo factor increased specifically improvements factor 5 overdo parameter 10 almost factor 40 overdo parameter 99 2 contrast quality solution worsens much slowly specifically maximum error worse 16 maximum overdo factor moreover although number erroneous plans quite high almost plans erroneous overdo factor 99 small relative errors illustrate note around 15 relative error 5 3 experiments graphs suggest optimal value overdo factor running time significantly improved solution quality bad experiments step trying find empirical timeperformance tradeoff function overdo parameter 4 seen figure 3 overall quality results shows similar tradeoff switch normalized network difference errors reduced given value overdo parameter 5 depicted figure 4 number plans worse certain relative error decreases roughly exponentially relative error characteristic depend overdo factor 6 also found nearoptimal paths produced visually acceptable represented feasible alternative route guiding mechanism method finds alternative paths quite different ones found kshortest path algorithms seem natural intuitively kshortest path algorithms find paths similar overall shortest path except local changes 7 counterintuitive local maximum overdo value 32 figure 3 explained example depicted figure 5 optimal length 21 overdo parameter 2 get solution length 22 node b gets inserted value 24 opposed values 29 25 c values b bigger resulting path using b path stays final overdo parameter 4 get solution length 21 stems fact c gets inserted heap value 33 b value overdo factor 30 overdo factor 20 overdo factor 15 overdo factor 12 overdo factor 11 figure 4 distribution wrong plans different overdoparameters normalized network dallas ftworth x direction change notion bad plan terms relative error direction show fraction plans classified bad current notion wrong easy see examples scaled embedded larger graphs since maximum error stems one particular shortest path question surprising encounter situation peculiarities network effect context transims needed find onetoone shortest paths observed possibly interesting influence underlying network geometric structure performance algorithms expect similar characteristics visible road networks well possibly modified existence rivers similar obstacles note network almost euclidean near homogenous justify following intuition dijkstras algorithm explores nodes network circular fashion run see roughly disc expanded nodes small ring fringe nodes nodes heap around planar near panar graphs observed heap size n high probability provides one possible explanation maximum heap sizes experiments close 500 particular even area circular number nodes reaches size network 10 000 ring fringe nodes roughly proportional circumference circular region thus roughly proportional believe homogenous almost euclidean structure also reason observations modified algorithm discussion provides least intuitive explanation special algorithms might perform better euclidean close euclidean networks figure 5 example network local maximum computed path length increasing overdo parameter edges marked euclidean distance reported length effect memory access times experiments observed changes implementation priority queue minimal influence overall running time contrast instruction count profiling done program called quantify pinpoints priority queue main contributer overall number instructions combining two facts conclude running time observe heavily dependent time takes access graph representation fit cache thus processor spends significant amount time waiting expect improvement running time concentrating memory ac cesses example making graph representation compact optimize accesses choosing memory location node according topology graph general conclusions paper motivate need design analysis algorithms take memory access latency account 7 discussion results first note running times plain dijkstra reasonable well sufficient context transims project quantitatively means following transims run iterations microsimulation planner modules shortest path finding routine one part recently begun research next case study project transims case study going done portland oregon chosen demonstrate validate ideas multimodal time dependent networks public transportation following scheduled movement initial study suggests take sectrip opposed 01 sectrip dallas ftworth case ko98 extensions important standpoint finding algorithms realistic transportation routing problems comment detail multimodal networks integral part mpos finding optimal nearoptimal routes environment therefore constitutes real problem past solutions routing networks handled ticks 010 exp 140 fr 190 figure figure illustrating two instances dijkstras algorithms high overdo parameter start origin destination respectively one really creates shown path beginning path visible cloud expanded nodes ad hoc fashion basic idea discussed detail bjm98 use regular expressions specify modal constraints bjm98 jbm98 proposed models polynomial time algorithms solve related problems next consider another important extension namely time dependent networks assume edge lengths modeled monotonic nondecreasing piecewise linear functions called link traversal functions function f associated link denotes time arrival b starting time x using appropriate extension basic dijkstras algorithm one calculate optimal paths networks preliminary results topics context transims found ko98 jbm98 portland network intending use 120 000 links 80 000 nodes simulating hours traffic network take 24 hours computing time 14 cpu chine 15 million trips network routing trips take 9 days single cpu thus less 1 day 14 cpu machine since rerouting typically concerns 10 population would need less 3 hours computing time rerouting part one iteration still significantly less microsimulation needs results constraints placed functionality requirement overall system imply bidirectional version dijkstras algorithm viable alternative two reasons algorithm extended direct way path problems multimodal time dependent networks ii running times better bidirectional variant modified much faster conclusions computational results presented previous sections demonstrate dijkstras algorithm finding shortest paths viable candidate compute route plans route planning stage transims like system thus algorithm considered even type projects need find routes onboard vehicle navigation systems design transims lead us consider onetoone shortest path algorithms opposed algorithms construct complete shortestpath tree given starting destination point well known worstcase complexity onetoone shortest path algorithms onetoall shortest path algorithms yet terms practical problem applicable first onetoone algorithm stop soon destination reached saving computer time especially trips short often case setting second since networks roughly euclidean one use fact heuristics reduce computation time even appropriate overdo parameter apperas attractive candidate regard making algorithms timedependent cases slowed computation factor two since using onetoone approach adding extensions example include personal preferences eg mode choice straightforward preliminary tests let us expect slowdowns factor 30 50 significant slowdown caused number factors including following network size increased factor 4 caused addition splitting nodes andor edges adding public transportation done account activity locations parking locations adding virtual links joining locations etc ii time dependency functions used represent transit schedules varying speed street traffic implied increased memory computational requirement initial estimates memory requirement increases factor 10 computational time increases factor 5 moreover different type delay functions used inducing qualitatively different exploration network algorithm seems prohibit keeping small number representative time dependency functions iii algorithm handling modal constraints works making multiple copies original network algorithm discussed jbm98 preliminary computational results discussed ko98 increased memory requirement factor 5 computation time additional factor 5 extrapolations results portland case study show even slowdown route planning part transims still uses significantly less computing time microsimulation finally note certain circumstances onetoone approach chosen paper may also useful applications would case customers would require customized route suggestions reusing shortest path tree another calculation may longer possible acknowledgments research supported department energy contract w7405 eng36 thank members transims team particular doug anson chris barrett richard beckman roger frye terence kelly marcus rickert myron stein patrice simon providing software infrastructure pointers related literature numerous discussions topics related subject second author wishes thank myron stein long discussion related topics earlier work motivated paper also thank joseph cheriyan ss ravi prabhakar ragde r ravi aravind srinivasan constructive comments pointers related literature finally thank referees helpful comments suggestions r design analysis computer algo rithms formal language constrained path problems presented scandinavian workshop algorithmic theory operational description transims shortest path algorithms theory experimental evaluation computational study improved shortest path algorithm route finding street maps computers people formal basis heuristic determination minimum cost paths highway research board experimental analysis routing algorithms time dependent labeled networks bidirectional shortest path algorithm good average case behavior approximation schemes restricted shortest path problem shortest path algorithm expected running time p v log v shortest path algorithms computational study c programming language using microsimulation feedback trip adaptation realistic traffic dallas experiences iterated traffic microsimulations dallas implementation efficiency moore algorithm shortest root problem shortest path algorithms complexity bidirectional searching shortest paths euclidean graphs finding realistic detour ai search techniques shortest path algorithms evaluation using real road networks transportation science tr shortest paths euclidean graphs shortest path algorithms computational study c programming language network flows approximation schemes restricted shortest path problem shortest paths algorithms design analysis computer algorithms formal language constrained path problems shortest path algorithms ctr michael balmer nurhan cetin kai nagel bryan raney towards truly agentbased traffic mobility simulations proceedings third international joint conference autonomous agents multiagent systems p6067 july 1923 2004 new york new york l fu sun l r rilett heuristic shortest path algorithms transportation applications state art computers operations research v33 n11 p33243343 november 2006
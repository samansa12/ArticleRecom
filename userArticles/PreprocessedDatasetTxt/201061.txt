combining analyses combining optimizations modern optimizing compilers use several passes programs intermediate representation generate good code many optimizations exhibit phaseordering problem getting best code may require iterating optimizations fixed point reached combining phases lead discovery facts program exposing opportunities optimization article presents framework describing optimizations shows combine two frameworks reason properties resulting framework structure frame work provides insight combination yields better results make ideas concrete article presents framework combining constant propagation value numbering unreachablecode elimination open question frameworks combined way b introduction modern optimizing compilers make several passes programs intermediate representation generate good code many optimizations exhibit phase ordering problem different facts discovered different code generated depending order optimizations executed getting best code requires iterating several optimizations fixed point reached show combining optimization passes compiler discovers facts program giving opportunities optimization shown ad hoc way previous work example wegman zadeck presented algorithm combine constant propagation unreachable code elimination 10 paper provides formal basis describing combinations shows combinations yield better results present proof simple iterative technique efficiently solves combined optimiza tions finally combine conditional constant propagation ccp global value numbering gvn get optimization sum parts 10 1 overview 21 intermediate representations describe algorithms need describe programs program represented control flow graph cfg edges denote flow control vertices basic blocks basic blocks contain set assignment statements special final statement may return empty fall program variables always written lower case letters eg x simplify presentation restrict program integer arithmetic set integers represented n assignment statements single function righthand side variable left function op small constant arity ie x aopb op may constant identity function limited kary function reasonable assumption application run work supported arpa onr grant n0001491j1989 algorithm lowlevel compiler intermediate representation k 3 call set op functions op assume program converted static single assignment ssa form 3 original program names assigned values multiple definition points ssa form name corresponds single definition point convention generate new names ssa form adding subscripts original names makes relationship textually obvious human reader wherever two definitions original variable reach merge point programs control flow oefunction inserted ssa form oefunction defines unique name merged value written since expressions occur righthand side assignments every expression associated assigned variable onetoone correlation variables expressions variable name used direct map expression defines implementation require mapping fast 1 finally define n number statements ssa form ssa form quadratic size original code communitys practical experience date ssa shown usually linear nearly linear size original code 22 monotone analysis frameworks order combine several optimizations first describe common monotone analysis framework 2 6 8 briefly monotone analysis framework ffl set inferences make program described complete lattice height arbitrary set inferences distinguished elements usually called top bottom respectively u meet operator b 2 u b u length longest chain l ffl set kary monotone functions f used approximate program defined f ff l 7 lg containing identity function closed composition pointwise meet ffl map f program primitives approximation functions generally approximation functions simple tables mapping lattice elements lattice elements 2 directly map cfg framework frameworks maintain correspondence cfg incidentally means solutions directly comparable meet paths mop solution like described kam ullman 6 value numbering solution framework fact implementation replaces variable name pointer expression defines variable performing mapping requires single pointer lookup 2 mappings take account information cfg taking notational liberty defining mapping op f correct implementation using operatorlevel instead basicblock level program dependence graph pdg ssa form 4 7 representation cfg basic blocks control information encoded inputs functions like program variable say awb u awb 6 b lattice complete u closed h lattice height largest n sequence elements l form chain x require l finite descending chain property must bounded constant problems examine quite small usually 2 3 assume compute f 2 f time ok k largest number inputs function f since k 3 implementation compute f constant time 23 monotone analysis problems applying monotone analysis framework specific program instantiates monotone analysis problem set simultaneous equations derived directly program variables equations correspond points interest program expression program defines variable associated variable single inference program analysis substitutes approximation functions chosen f using fl actual program primitive functions solves equations approximation functions effect analysis runs approximate version program design equations minimal solution called greatest fixed point gfp 2 9 3 functions f represent complete programs via composition monotonicity gives us special properties composition monotonic functions also monotonic also composition function onto l solve set equations set variable repeatedly compute propagate local solutions effect variables run downhill solution limit kary approximation functions ensures compute quickly propagate changes far bound chain length limits number forward downhill steps finite number monotonicity ensures running downhill locally cannot improve global solution means first solution find also best solution prove formally section 4 24 combining frameworks given two frameworks b framework combines yields better information solutions interact solution must rely solution must rely solution interdependent careful ordering produces answers combined framework combine two frameworks combine sets equations framework equations implicitly reference facts derived equations b viceversa make explicit implicit references equations set must prove combined equations still monotonic therefore represent monotone analysis framework combined framework still maximal solution may equal combined maximal solution individual problems fact identical combination individual solutions gained nothing combining frameworks ie profitable demonstrate ideas clearly work extended example combining simple constant propagation unreachable code elimination optimizations well known widely used wegman zadeck shown algorithm combines 10 instructive compare 3 properties described section 22 ensure existence gfp 9 systems equations solved using many techniques techniques vary widely efficiency expensive techniques solve systems equations less efficient cannot general difference efficiency led classical compilers use least expensive method solve given problem algorithm frameworkbased approach final exercise combine ccp partitionbased gvn 1 obtain new optimization strictly powerful number repetitions separate optimizations combination runs 2 time faster previous algorithm technique equations derived directly intermediate representation purposes paper intermediate representation equations use technique abstract interpretation associate approximation function chosen f every primitive function program form equations restricted see section 22 find maximal solution using iterative technique time onk 2 n number equations solve often equal n number statements program k largest number inputs one function height lattice 3 simple constant propagation simple constant propagation looks program expressions compute value executions program cast monotone analysis framework conservatively approximates programs control flow assuming basic blocks executable thus control flow explicit expression dataflow equations assignment defines expression variable inference variable holds tells us whether expression computes constant inferences use standard constant propagation lattice l c elements f integer constants g shown figure 1 meet operator u also defined figure 1 notation means c 0 equal c 1 c 0 else every primitive function program l l l c c c figure 1 constant propagation lattice l c meet operator need corresponding monotonic function f 2 f oefunctions use meet operator extend primitives handle example look corresponding function replacing op application f op instead meaning applying function undefined inputs yields undefined results opposed unknown results 4 embodies idea propagate information facts known functions zero elements use precise complex extension multiply extended figure 3 f 0 0 rather reflects intuition zero times anything zero shown figure function results monotonically decreasing 5 left right top bottom thus f monotonic function maintains information cases corresponding function without special case zero figure 4 generate equations small program ssa form every variable x program equation defining v x assignment x 0 1 generate equation v unknown values values cannot discovered compile time many unknown values typical program compiler must emit code compute values run time undefined values compiler choose value wants 5 two integers incomparable lattice thus 0 neither greater less c 0 theta c 1 figure extending functions l c f f figure extending multiply l c case 1 constant function f v x0 cumbersome write x 0 instead different uses x 0 obvious context oefunctions use meet operator function 6 n theta n 7 n returns 0 inputs equal 1 inputs equal extend 6 f 6 shown figure 2 assume loop controlling predicate pred beyond ability compiler analyze possibly keyboard read solving equations inspection yields x short new constants found program equations int x 0 figure 4 simple constant propagation example 4 finding greatest fixed point section show iterative technique works monotone analysis frameworks show initializing system monotonic equations successively solving equations eventually yields gfp start tarski 9 proved every monotone function f l 7 l gfp complete lattice l since f monotone successive applications f descend monotonically lattice bounded fixed point eventually reached cannot gfp greatest fixed point u fixed point suppose reverse situation u applications f must form descending chain falls past gfp must delta delta delta monotonicity f contradiction therefore successive applications f yield gfp need represent system monotonic equations simple monotonic function f extend lattice l tuples lattice l define l lattice whose elements ntuples l elements use notation fx refer tuple l elements define ls meet operator elementwise meet l elements x u l complete lattice finite descending chain property define monotonic function collection monotonic functions f 7 l tuple lattice regular lattice therefore f x defines system monotonic equations functions f takes nlength tuple l elements problems solving require k 0 k n elements l actually used f takes input ksized subset x unfortunately solution technique repeatedly applying f fixed point reached inefficient l lattice height ond computation f might take onk work running time 2 kd next section presents efficient technique based evaluating single variable formulation f rather f provide efficient solutions solve equations fx simple worklist iterative technique 5 sparseness equations makes algorithm efficient 1 initialize equation variables x 2 place equations worklist w 3 w empty remove equation worklist w b solve using values x variables c solution changes set x place equations use x back w functions f monotonic inputs functions drop lattice defined variable go lower lattice lattice height variable drop change times function expression program worklist per time input drops lattice okd times time function removed worklist takes time ok evaluate total evaluation time per function ok 2 total running time onk 2 simple constant propagation number equations n number statements n ssa form program k arity functions small 2 running time 5 unreachable code elimination analysis unreachable code elimination simple constant propagation seek determine code program executable either controlflow test based constant value code jumps inferences determine whether section code reachable expressed twoelement lattice l u elements fu rg u unreachable r reachable define functions similar boolean figure 5 analysis constant facts available literal constants define 6j return u inputs textually equal r otherwise u u r r r r u u u r u r figure 5 defined l u figure 6 generate equations example readability define f synonym 0 integer 0 starting statement 0 clearly reachable statement 1 reachable fall 0 reach bottom loop statement loop predicate always false remaining equations generated similar fashion equations compositions monotonic functions monotonic b pred literal constants 6j tests must return r solution straightfor ward everything reachable program equations int x 0 deltapred 6j f figure 6 unreachable code elimination example look closely example see program run x 0 set 1 ifs predicate b always false consequent test 4 never executed neither simple constant propagation unreachable code elimination discovers facts analysis needs fact discovered 6 combining analyses improve results optimization would like combine two analyses need framework allows us describe combined system reason properties answer critical questions particular would like know combined transformation correct retain meaningpreserving properties original separate transformations combination profitable discover facts improve code ways separate techniques cannot combined framework monotonic know gfp exists find efficiently combine analyses unioning set equations making explicit implicit references equations unioning equations makes bigger set unrelated equations however equations remain monotonic safe however analyses interact profit combining make analyses interact replacing implicit references functions take inputs one original frameworks produce outputs reachable equations 3 4 use variable b defined constant propagation equations instead testing b literal constant test replace 6j function l c theta n 7 l u defined figure 7 function example function mixes inputs outputs frameworks takes input c framework returns result l u framework meaning easily determined know test constant ie exit paths reachable otherwise test constant one exit path reachable first glance function looks nonmonotonic f comparable l c important question answer functions represent interactions frameworks monotonic combined framework monotonic use tools developed handle monotonic frameworks original frameworks monotonic transfer functions mono tonic combined framework monotonic combining two frameworks implementor must prove property fortunately reasoning monotonicity transfer functions harder reasoning original frameworks transfer functions use examples represented small tables determine functions monotonic inspection 61 profitability combined frameworks combined framework profitable profitable gfp solution computes value mixed function higher output lattice implicit function mixed function replaced mixed functions solution implicit functions equations using mixed function better results use implicit function means combined solution fares better implicit functions used implies combined solution better individual solutions functions framework l c framework l u viceversa simple phase ordering problem solve l c framework l u framework achieve results equal f u r u r testing predicate unreached code computes figure 7 mixed functions combined equations combined framework combined framework profitable also functions l u c combined gfp improves mixed functions results back example unreachable code always computes constant propagation equations gets explicit reference appropriate reachable variable reachable variable used input monotonic infix function defined figure 7 instead one equation per statement two equations per statement equation grown constant amount total size equations grown constant factor remains linear number statements program equations int x 0 pred deltapred f figure 8 combined example 62 example complete new equations given figure 8 solving equations straightforward tedious solution using iterative technique given section 4 presented figure 9 example boxed terms represent step 3b variable computed main points interests interactions separate analyses equations x 1 time 0 x 3 along variables initialized u time 4 x 1 meets x 0 x 3 get value 1 time constant f time 8 4 left marked unreachable u since 4 change values equation setting x 2 never placed worklist time 10 x 3 meets x 1 x 2 get value 1 since x 3 changed 1 users x 3 including x 1 go back worklist time 14 x 1 original value remains unchanged solution stabilizes statement 3 marked unreachable x 3 known constant 1 facts found individual analyses repeated applications separate analyses cannot pred 7 figure 9 solving combined example discover new facts new application starts facts first analysis however combined framework finds facts conditional constant propagation algorithm wegman zadeck discovers facts 10 improved solution knowledge derives interaction made explicit equations specifically combined framework exposes unreachable code precisely reachablity equations rely assumption made constant propagation equations viceversa assumption optimistic 6 sense justified facts hand must proven correct assumption correct equations must reevaluated light new pessimistic correct information however assumption correct something new may discovered thus reason ccp improvement simple constant propagation unreachable code elimination interactions combining frameworks implicit interactions made explicit combined framework discover addition facts case combined framework consists two independent sets equations 7 global value numbering formulate monotone analysis framework finding congruent expressions define two expressions congruent 1 ffl two expressions expression reflexivity ffl compute equivalent functions congruent inputs ffl compute constant ffl one identity function 6 wegman zadeck use term optimistic assumption functions arise direct copies input language algebraic identities addition zero merging congruent values oefunctions 7 congruence relation holds pairs expressions program size n 2 inferences 2 equations solve derive equations involving constant inferences reachable inferences congruence inferences straightforward manner equations interact benefit solving combined problem inferences whether two expressions congruent expressed twoelement lattice lj elements fj 6jg overload functions delta work lj elements usual way shown figure 5 write c xy variable determines whether expression x congruent expression x op primitive function expression x x ith input x op basic congruence equation expressions x looks like reflexive equal functions congruent inputs constant add zero add commutative merge congruent values multiply 1 tests function values ie x fixed program precomputed solve general problem equations still complex fixed number special cases one special case per kind algebraic identity number inputs equation defining c xy thus fixed constant k functions involved equation monotonic composition functions also monotonic thus use algorithm section 4 achieve running time onk 2 since constants running time 2 make gvn interact ccp modifying c xy equations use computed constants instead textual constants noting undefined values congruent anything either undefined compute constant add zero congruence equations clearly use values l c lattice add mixed functions reverse direction defining subtraction congruent values yield 0 compare congruent values yield 8 since mixed functions going lj l c elements opportunity find congruencies constants unreachable code found separate analyses figure example code solved combined problem results n 2 c xy congruencies form equivalence relation fairly obvious strategy pick one expression partition represent expressions partition build new program selected expressions dropping unreachable code using constants possible however partitions might contain expressions 7 slightly stronger notion congruence alpern wegman zadeck use allow identity functions 8 course solving equations subtract constants 5 3 yielding 2 constants considered congruent conflict instead choosing 2 0 leave subtract expression situation temporary 5 3 cannot remain congruent f int constant 1 int defined unknown int congruent z predicate 6 z know z congruent destroy constant x know x constant destroy yz congruence printfx dnnx x always 1 figure subtle congruence little dead code algebraic identities another expression partition expressions selected represent partition presence undefined variables resulting congruencies form equivalence relation define expression x congruent expressions expression x starts congruent constant 3 constant 4 x drops problem resolved equations solved x remains x undefined congruencies x 3 4 remain lead unusual behavior code figure tests x constant analysis shows print statements always reached 9 f int x x undefined figure using undefined variables language standards fail address particular aspect using undefined variable believe interpretation correct given facts hand unusual behavior avoided analysis look congruence relations form equivalence relations arbitrary congruence broken c xy variable set 6j analysis proceed another lower fixed point reached process continue equivalence relation formed worst case congruencies broken result clearly trivial equivalence relation process breaking congruencies forcing analysis choose x congruent 3 x congruent 4 9 moral story using undefined variables lead unexpected results summary paper shown combine two code improvement techniques assume original transformations encoded monotone analysis frameworks model combine two frameworks reason monotonicity combined framework solve combined framework efficiently furthermore structure combined framework shows combination produce better results repeated application original transformations equally important cannot illustrate points showed combine constant propagation unreachable code elimination derive algorithm properties similar conditional constant propagation algorithm presented wegman zadeck 10 combined framework includes transfer functions take constant values reachability reachability values back constant propagation discover constants unreachable code repeated applications original transformations finally showed combine constant propagation unreachable code elimination global value numbering open question frameworks combined profitable combine asymptotic complexity presented analysis 2 discover facts separate applications three transformations general combining two frameworks important removes phase ordering problem monotone analysis framework combined problem run onk 2 time n number equations k arity functions used equations height inference lattice r detecting equality variables programs systematic design program analysis frameworks efficient method computing static single assignment form program dependence graph use optimization flow analysis computer programs monotone data flow analysis frameworks dependence flow graphs algebraic approach program dependencies unified approach path problems latticetheoretical fixpoint theorem applications constant propagation conditional branches tr program dependence graph use optimization detecting equality variables programs efficient method computing static single assignment form constant propagation conditional branches unified approach path problems flow analysis computer programs systematic design program analysis frameworks dependence flow graphs algebraic approach program dependencies ctr rebecca hasti susan horwitz using static single assignment form improve flowinsensitive pointer analysis acm sigplan notices v33 n5 p97105 may 1998 decidability phase ordering problem optimizing compilation proceedings 3rd conference computing frontiers may 0305 2006 ischia italy joel auslander matthai philipose craig chambers susan j eggers brian n bershad fast effective dynamic compilation acm sigplan notices v31 n5 p149159 may 1996 dipanwita sarkar oscar waddell r kent dybvig nanopass infrastructure compiler education acm sigplan notices v39 n9 september 2004 alexandre lenart christopher sadler sandeep k gupta ssabased flowsensitive type analysis combining constant type propagation proceedings 2000 acm symposium applied computing p813817 march 2000 como italy bjorn de sutter bruno de bus koen de bosschere saumya debray combining global code data compaction acm sigplan notices v36 n8 p2938 aug 2001 min zhao bruce childers mary lou soffa predicting impact optimizations embedded systems acm sigplan notices v38 n7 july keith cooper alexander grosul timothy j harvey steve reeves devika subramanian linda torczon todd waterman exploring structure space compilation sequences using randomized search algorithms journal supercomputing v36 n2 p135151 may 2006 virgil palanciuc dragos badea spill code minimization technique application metrowerks starcore c compiler international journal parallel programming v32 n6 p475499 december 2004 wankang zhao baosheng cai david whalley mark w bailey robert van engelen xin yuan jason hiser jack w davidson kyle gallivan douglas l jones vista system interactive code improvement acm sigplan notices v37 n7 july 2002 sorin lerner david grove craig chambers composing dataflow analyses transformations acm sigplan notices v37 n1 p270282 jan 2002 roberto giacobazzi francesca scozzari logical model relational abstract domains acm transactions programming languages systems toplas v20 n5 p10671109 sept 1998 matthew b dwyer lori clarke jamieson cobleigh gleb naumovich flow analysis verifying properties concurrent software systems acm transactions software engineering methodology tosem v13 n4 p359430 october 2004 keith cooper li xu efficient static analysis algorithm detect redundant memory operations acm sigplan notices v38 n2 supplement p97107 february keith cooper l taylor simpson christopher vick operator strength reduction acm transactions programming languages systems toplas v23 n5 p603625 september 2001 jeffrey dean greg defouw david grove vassily litvinov craig chambers vortex optimizing compiler objectoriented languages acm sigplan notices v31 n10 p83100 oct 1996 thomas kistler michael franz continuous program optimization case study acm transactions programming languages systems toplas v25 n4 p500548 july
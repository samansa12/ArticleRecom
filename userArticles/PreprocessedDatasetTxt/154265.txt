mutation analysis using mutant schemata mutation analysis powerful technique assessing improving quality test data used unit test software unfortunately current automated mutation analysis systems suffer severe performance problems paper presents new method performing mutation analysis uses program schemata encode mutants program one metaprogram subsequently compiled run speeds substantially higher achieved previous interpretive systems preliminary performance improvements 300 reported method additional advantages easier implement interpretive systems simpler port across wide range hardware software platforms using compiler runtime support system used development andor deployment b introduction programs 1 tested executing test inputs examining resulting outputs errors intent testing process increase confidence correctness tested code however testing poorly con ducted adhoc manner confidence may misplaced poorly selected test data adequately exercise program must deemed low quality systematic testing techniques establish test data adequacy criteria seek measure quality test data used exercise given program one powerful testing technique uses adequacy criterion mutation testing 11 13 14 mutation testing test set analyzed determine quality measure called mutation adequacy score process called mutation analysis unfortunately conventional method performing mutation analysis requires interpreting many slightly differing versions pro gram significant problems automated mutation analysis systems based conventional method slow laborious build usually unable completely emulate intended operational environment software tested principle reason conventional mutation analysis systems slow interpre tive one study noted current implementations mutation tools unacceptably slow suitable testing relatively small programs 16 thus conventional systems proved useful experimentation mutation testing widespread practical use mutation analysis stymied enormous computational use word program denote software test may complete program smaller unit procedure requirements conventional systems con ventional interpretive systems also laborious build test software written specific lan guage interpreterbased systems must incorporate compilation characteristics runtime semantics language certain languages ada formidable undertaking since dialectical differences often exist degree compliance language standards becomes problem also subtle changes program behavior may occur since program test longer running intended operational environment paper presents new method performing mutation analysis suffer problems rather mutating intermediate form program must interpreted mutant schema generation msg method enables us encode mutations one sourcelevel program program compiled compiler used development executed operational environment compiledprogram speeds since mutation systems based mutant schemata need provide runtime semantics en vironment significantly less complex easier build interpretive systems well portable section 2 provide background mutation testing introduce mutant schema generation msg method section 3 present experimental results section 4 related work reviewed section 5 conclusions presented section 6 mutation testing background mutation analysis whitebox testing technique based notion quality test set related ability test set differentiate program tested set marginally different presumably incorrect alternate programs say test case differentiates two programs causes two programs produce different outputs process performing mutation analysis test set relative given program p begins running p every test case program computes incorrect result test set fulfilled obligation program must changed determining correctness results oracle problem 24 common testing techniques discussed assuming p computes correct results every test case set alternate programs pro duced alternate program p known mutant p formed modifying single statement p according predefined modification rule modification rules g called mutagenic operators mutagens 2 syntactic change called mutation original program plus mutant programs collectively known program neighborhood n p 7 mutant run test cases test case mutant produces result different original program say test case killed mutant indicating test case able detect faults represented mutant killed dead mutants run additional test cases mutants although syntactically different functionally identical original program call equivalent mutants although progress made automatically identifying mutants equivalent 4 18 remains timeconsuming manual task since test case kill equivalent mutants must removed consideration assessing test data quality ratio dead mutants remaining undifferentiated live mutants indicator test set quality mutation analysis measure used express test set quality mutation adequacy score ms percentage potentially kil lable mutants actually killed equivalent theta 100 mutants total number mutants program neighborhood subscript mutation adequacy score ms set mutagens g reflect influence number type mutants produced practice however standard set mutagens used common subscript omitted major computational cost mutation analysis incurred running mutant programs test cases number mutants generated program roughly proportional number data references times number data 2 terminology varies also sometimes called mutant operators mutation operators mutation transforma tions mutation rules 25 acree 1 uses term mutagenic biology mutagenic substance factor simply called mutagen objects 9 typically large number example 385 mutants get generated procedure newton shown figure 1 find square root using newtons method 6 epsilon 0001 7 newguess number 20 9 newguess sqrtnumbersqrt20 figure 1 newton square root procedure 3 msg method approach mutation analysis based program schemata program schema template partially interpreted program schema defined baruch katz 5 syntactically resembles program contains free identifiers called abstract entities place program variables datatype identifiers constants program state ments schema created via process ab straction schema instantiated form complete program providing appropriate substitutions abstract entities devised new form partially interpreted program schema mutant schema 23 mutant schemata used represent program neighborhoods mutant schema two com ponents metamutant metaprocedure set represented syntactically valid ie compilable constructs use mutant schemata significantly speeds mutation analysis 31 mutation analysis using mutant schemata essence new method lies creation specially parameterized program called metamutant derived program test p metamutant compiled using standard compiler used compile p runs compiledspeeds running metamutant functions alternate programs found n program neighborhood p explain metamutant represents functionality collection mutants must take closer look mutation analysis recall program p mutant p formed result single modification statement thus mutant newton differs original one mutated statement way statements altered dictated set g mutagens modification rules used discussion uses mutagenic operators defined imscu system 19 rules typical current use 2 15 consider arithmetic operator replacement aor rule states occurrence arithmetic operator replaced possible arithmetic operators operator also replaced special operators leftop rightop leftop returns left operand right ignored rightop returns right operand applying rule assignment statement line 9 newton yields following six mutations mutations generically represented arithop metaoperator abstract entity generic representation recast syntactically valid statement aorr function performs one arithmetic operation third argument 62 ex ample used identify location change point program function voked aorr example metaprocedure function corresponds abstract entity schema statement changed reflect generic form said meta mutated metamutation syntactically valid change embodies changes 9 original svr number newguess sqrt svr sqrt newguess sqrt svr newguess newguess sqrt svr epsilon newguess sqrt figure 2 newton line 9 mutations mutations produced applying standard mutagens represented metamutations figure 2 shows mutations line 9 result applying complete set imscu mutagens following statement dr embodies alternatives generating metamutant p list mutant descriptors produced list details alternate operations used change point program using list metamu tant dynamically instantiated function mutants p driver harness invokes metamutant directs mutants instantiated driver takes care administrative matters managing test case input output handling exceptions comparing mutant output original program output recording results driver also computes reports statistics current status mutants primarily mutation score common driver used metamutants metaprocedures syntactically valid representations abstract entities found mutant schemata categorized either meta operators metaoperands metaoperator procedures perform one class alternate opera tions metaoperator implemented using case structure runtime global parameter selects alternate operation perform parameters value set based information contained mutant descriptor list aorr routine example metaoperator procedure simplified version aorr function given figure 3 begin aorr case range figure 3 simplified version arithemetic operation function creating metaoperator procedures straightforward tedious task many metaoperator procedures identical form differ type declarations formal parameters return value nature number metaopera tor procedures needed function 1 g set mutagens 2 l language p sometimes 3 p program metaoperators depend g l said intrinsic languages support userdefined types fortran meta operators intrinsic generated independent particular program placed g oe mutation n substantiation ae oe instantiation p execution figure 4 model msg method static metaprocedure library metaoperators depend g l p said p derived stronglytyped languages modula2 ada allow programs userdefined types p derived metaoperators languages intrinsic metaprocedure library must augmented p derived metaoperator routines generated using information p specific program tested metaoperand procedures reference one set program variables actual variable referenced determined runtime via parameter similar metaoperator procedures meta operand procedures unique program p must generated anew program although implementation details metaoperand procedures influenced available features l scope rules type checking rules availability pointers nesting rules cases scheme using arrays used conceptual model applying msg method given figure 4 working backwards ie right left mutation adequacy score obtained result executing mutants test set mutants p obtained using list mutant descriptors repeatedly instantiate metamutant formed result substantiating ie imparting material form program neighborhood n program neighborhood obtained applying mutagens g program p 32 generating metamutants currently developing complete system perform mutation testing using mutant schemata section gives details system process generating metamutant program p begins construction decorated abstract syntax tree abstract syntax tree ast nonleaf node represents operator children node represent operands 3 decorated tree attributes type information attached nodes system attribute grammar used direct parsing program ast construc tion resulting ast decorated type information using symbol table developed parsing program semantic rules specified attribute grammar figure 5 shows statement corresponding ast mutagens expressed tree transformation procedures mutagens g applied decorated abstract syntax tree using location type information contents node children ast transformed replacing node contents metaprocedure calls leaf nodes replaced metaoperands interior nodes replaced metaoperators metaprocedure invocation site change point identified change point number mutagens cause structure tree altered example accommodate unary operator insertion mutations ast augmented creating new nodes certain arcs nodes represented hexagons rewritten ast right hand side figure 6 traversing revised ast information needed generate metamutant program obtained 4 experimental results preliminary step implementing full msg system wished establish empirically approach yielded faster mutation analysis interpretive approach manually generated metamutant newton procedure shown figure 1 abridged listing metamutant given figure 8 also manually generated list mutant descriptors using imscu muta gens 385 mutants produced additionally rudimentary library metaprocedures driver developed implemented make working msg mutation analysis system compared speed newton metamu tant testing newton mothra environmenta conventional interpretive system 15 fortran version newton prepared see figure 7 run mothra slight differences imscu mothra muta gens 364 mutants fortran version program real real real real real figure 5 statement corresponding decorated abstract syntax tree c find square root using newtons method c return end figure 7 fortran version newton using unix cshell builtin time command benchmark comparison revealed mutation analysis performed direct execution meta mutant 41 times faster interpretive ex ecution strong indication msg significantly increase performance mutation testing expect even dramatic improvement future systems 5 related work large number mutant programs must generated run early designers mutation analysis systems considered individually creating compiling linking running mutant difficult slower using interpretive system 6 8 considered likely cost compiling large numbers mutants would prohibitive interpreterbased systems developed mothra recent comprehensive 11 15 conventional interpreterbased mutation analysis systems source code translated internal form suitable interpretive execution mutation mutant mutant generator program produces patch applied internal form creates desired alternate program translated program plus collection patches represents program neighborhood run mutant test case interpreter dynamically applies appropriate patch interpretively executes resulting alternate internal form program number attempts overcome performance problem made approaches attempt limit number mutants must run selective mutation 21 subset possible mutagens used resulting fewer mutants created preliminary results suggest selective mutation may provide almost test coverage nonselective mutation certain conditions running sample oir oir oir oir oe put get get aorr figure transforming abstract syntax tree mutants 22 also suggested research determining statistically appropriate sample size continues extreme cases however necessary run almost mutants approaches use nonstandard computer architectures explored unfor tunately full utilization high performance computers requires awareness special requirements well adaptation software work done adapt mutation systems vector processors 17 simd 16 hypercube mimd machines 10 20 however fact architectures nonstandard limits appeal approaches available development envi ronments testing software designed one operational environment machine operating system compiler etc another fraught risks approaches squarely address primary factor causes conventional systems slow interpretative execution yet noted previously apparent overhead compiling many mutant programs outweighs benefit increased execution speed compilerintegrated 12 program mutation seeks avoid excessive compilation overhead yet retain benefit compiled speed execution method program test compiled special compiler compilation process proceeds effects mutations noted code patches represent mutations prepared execution particular mutant requires appropriate code patch applied prior execution patching inexpensive mutant executes compiledspeeds unfortunately crafting needed special compiler expensive undertaking modifying existing compiler reduces burden somewhat task still technically demanding moreover new computer operating system envi ronment task must repeated 6 conclusions paper presented novel way perform mutation testing using program schemata mutation analysis systems based msg method exhibit several advantages interpretive sys tems obvious advantage msg mutation systems faster interpreterbased sys tems msg systems allow mutants executed compiled speeds without recompile store mutant separately although large number metaprocedure function calls must processed mutants run compiled programs thus execute machine language speeds addition improvements execution speed msg systems significantly cheaper build interpretive systems much implementation difficulty mutation system designing intermediate language building parser building interpreter problems exacerbated languages dynamic memory fea tures userdefined types complicated control featuresindeed much reason mothra find square root using newtons method var newguess used putr target begin initialize local variables default value 0 newguess 00 epsilon 00 dr putrcrrgetr403459 number dr putroiraorroiraorroirgetr41 11 dr putrcrrgetr443761 dr putroiraorroirgetr4514oirgetr461531662 dr putroirgetr491963 6 newguess sqrt number sqrt 20 dr putroiraorroiraorroirgetr5020 oiraorroirgetr5121 oirgetr5222423524 dr ews san75 oilrorroirgetr5629 crrgetr5739933 dr putroiroirgetr58303166 11 end ews end ews san75 ews 8 ews 11 end ews end end newton figure 8 newton metamutant abridged minor initialization code getr putr metaprocedure routines omitted original statements included comments tests fortran programs fortran77 features since msg method leaves problems providing runtime semantics environment preexisting compilers runtime libraries msg systems smaller easier build allowing us quickly develop mutation tools variety languages msg systems also provide realistic testing since msg method produces compilable program language program tested testing take place using compiler environment used program test hence program tested operational environment used retains original operational behavior important advantage msg mutation systems innate portabilty msg systems operate sourcelevel easily moved machine machine compiler compiler example network computer system different architectures example sun3s sun4s could utilized simply recompiling msg system different type machine architecture independence also makes heterogeneous distributed computing implementations easier lastly since ability compile run program p provided existing llanguage compiler possible msg system incomplete yet provide partial functionality although driver must substantially com plete metaprocedures need written metamutation transformation mechanisms defined unimplemented mutagens result p source text passing compiler unaltered contrast interpreterbased system virtually entire translator runtime interpreter must finished programs executed tested characteristic schemabased systems encourages incremental implementations also allows greater freedom experiment mutagenic operators although much faster interpretive sys tems msg systems may somewhat slower compilerintegrated methods compilerintegrated systems burdened metaprocedure function call overhead execution speed mutant identical single program exhibits fault mutation feel portability ease constructing msg system far outweighs execution speed difference unless mutation systems using object code patches built compilers start modifying preexisting compilers unlikely practical interesting note msg method orthogonal many approaches discussed section 5 example schemabased mutation could performed concert compiler integrated method similarly mutant sampling strategy could used regardless underlying mutation analysis mechanism msg system could implement weak mutation addition reason believe msg systems could successfully adapted run distributed computing environment r heuristics determining equivalence program mutations partially interpreted schemas csp programming private correspondence two notions correctness relation testing design prototype mutation system program testing mutation analysis program test extended overview mothra software testing environment hints test data se lection help practicing programmer testing programs aid compiler fortran language system mutationbased software testing high performance software testing simd machines mutant unification improved vectoriza tion using compiler optimization techniques detect equivalent mutants instructive mutation system clemson uni versity system documentation mutation testing software using mimd com puter experimental evaluation selective mutation testing nontestable programs tr compilers principles techniques tools partially interpreted schemas csp programming high performance software testing simd machines fortran language system mutationbased software testing highperformance mutation testing experimental evaluation selective mutation mutationbased software testing using program schemata ctr vladimir n fleyshgakker stewart n weiss efficient mutation analysis new approach proceedings 1994 acm sigsoft international symposium software testing analysis p185195 august 1719 1994 seattle washington united states zuhoor alkhanjari martin woodward haider ali ramadhan critical analysis pie testability technique software quality control v10 n4 p331354 december 2002 yuseung jeff offutt yongrae kwon mujava mutation system java proceeding 28th international conference software engineering may 2028 2006 shanghai china jeff offutt yuseung yongrae kwon experimental mutation system java acm sigsoft software engineering notes v29 n5 september 2004 jefferson offutt ammei lee gregg rothermel roland h untch christian zapf experimental determination sufficient mutant operators acm transactions software engineering methodology tosem v5 n2 p99118 april 1996 kamel ayari salah bouktif giuliano antoniol automatic mutation test input data generation via ant colony proceedings 9th annual conference genetic evolutionary computation july 0711 2007 london england j offutt lee empirical evaluation weak mutation ieee transactions software engineering v20 n5 p337344 may 1994 z alkhanjari r woodward haider ali ramadhan n kutti efficiency critical slicing fault localization software quality control v13 n2 p129153 january 2005
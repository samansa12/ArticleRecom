admission control immediate notification admission control used online scheduler chooses whether complete individual job successfully deadline important consideration point time scheduler determines job request satisfied thus point scheduler able provide notification job owner fate request loosest model often seen realtime systems decision deferred jobs deadline passes strictest model suitable customerbased applications scheduler would required give notification instant job request arrivesunfortunately seems little existing research explicitly studies effect notification model performance guarantees scheduler undertake study reexamining problem literature specifically study effect notification model nonpreemptive scheduling single resource order maximize utilization first glance appears severely restrictive compare scheduler required give immediate notification one need give notification yet able present alternate algorithms provide immediate notification matching performance guarantees possible schedulers provide notification one case able give evidence providing immediate notification may difficult b introduction consider nonpreemptive scheduling single resource online setting job requests arrive request specifying length time resource needed well deadline job completed scheduler required complete job requests yet goal maximize resource utilization setting important consideration point time scheduler determines job request satisfied thus point scheduler able provide notification job owner fate request natural model notification varied greatly application domains traditional realtime systems example admission control used processing jobs termed firm deadlines 16 system issues job request firm deadline job necessarily need completed however completing job provides utility deadline passed setting quite natural allow scheduler take wait andsee approach request scheduler allowed defer final decision whether service request time deadline passes schedulers point view loosest possible model providing notification department mathematical computer sciences loyola university chicago research completed princeton university supported dimacs center discrete mathematics theoretical computer science national science foundation science technology center microsoft corporation research completed princeton university conversely admission control routinely used wide array customerbased applications job requests submitted individual customers company may may able meet requests given deadlines examples applications daily life might include photofinishing dry cleaning package delivery problem motivated industrial scale model requests uninterrupted connection telecommunication system used transmission text sound images video data unfortunately loosest model notification inappropriate applications customer job absolutely positively must done certain deadline unacceptable entrust job company may wait deadline approaches informing customer request completed setting consider strictest possible model notification immediately upon receiving request require scheduler either promise completion job else outright reject way request rejected customer still approach alternate provider servicing job 1 although two views represent extremes modeling notification possible define various intermediate models specifying point notification required example atm network decision whether admit request immediate yet made specific connection setup period unfortunately seems little existing research explicitly studies effect notification model performance scheduler goal undertake study starting particular scheduling problem receiving earlier notification advantage customer providing notification nothing hindrance scheduler remarkably though able give alternate algorithms provide immediate notification matching best possible performance bounds achieved schedulers provide advanced notification 10 11 exist one case able give evidence providing immediate notification may indeed strictly difficult 11 definitions following standard notation graham et al 12 consider job j triple nonnegative integers arrival release time job p processing time deadline jobs completion job j available time respect schedule oe r started oe prior time additionally say job j slack amount time jobs arrival last possible time could started still meeting deadline patience problem instance defined every job j j processing time p j slack j delta p j 11 let delta denote ratio largest smallest processing times instance gain schedule oe instance defined equal goal maximize gain assume online algorithm knowledge job release time point job parameters known furthermore assume algorithm priori knowledge value however assume algorithm knowledge value delta measure performance comparing gain gain optimal offline algorithm opt priori knowledge jobs creating schedule 7 15 20 say deterministic online algorithm ccompetitive gain opt c delta gain input instances considering randomized online algorithms competitiveness compares 1 unfortunately authors experiences often involved companies give appearance immediate notification accepting request yet later announce deadline met gain optimal schedule expected gain randomized algorithm assume worst case input algorithm chosen oblivious adversary must choose entire sequence advance 6 19 12 results primary results algorithms provide immediate notification meeting bounds performance previous algorithms provide type advanced notifica tion specifically give algorithms providing immediate notification matching following competitiveness bounds given previous algorithms without notification 10 11 ffl case job lengths equal present deterministic algorithm provides immediate notification algorithm 2competitive general 1 1 competitive 0 patience instance ffl case arbitrary job lengths allowed 0 patience instance present 2 1 competitive deterministic algorithm provides immediate notification ffl case arbitrary job lengths allowed delta 1 ratio largest smallest job lengths present 4dlog 2 deltaecompetitive randomized algorithm provides immediately notification first two results matched existing lower bounds setting advanced notification required lower bounds trivially apply stricter setting immediately notification thus results tight third result improves constant factor best known upper bound model advanced notification matched asymptotically omegagamma17 delta lower bound model 17 secondary results concern special case jobs one two distinct lengths although special case limited practical importance appears interesting theoretically able give evidence providing immediate notification may strictly difficult providing notification specifically best current results randomized competitiveness include lower bound 2 upperbound 4 model without notification 10 17 make progress towards separation competitiveness various notification models giving following results ffl give 4competitive randomized algorithm provides immediate notification ffl give 3competitive randomized algorithm without notification ffl show randomized algorithm provides immediate notification better 7competitive even improvements note yet explicit separation two notification models gaps upper lower bounds overlap previous work although understanding effect notification model admission control seems clear priority little mention issue standard literature previous work able find explicitly studies effect notification model performance involves system delivering videoondemand 4 contract results show striking difference competitiveness problem based exact model notification partial explanation lack previous work focusing notification model issue becomes moot nonpreemptive model jobs zero slack setting scheduler implicitly required make immediate decision whether begin job reject request case earliest work directly related problem study lipton tomkins introduce problem referred online interval scheduling jobs request immediate use resource 17 job lengths equal greedy online algorithm guaranteed find optimal solution model implicitly assumes scheduler priori knowledge value delta jobs one two distinct lengths authors provide randomized 2competitive algorithm matching lower bound arbitrarily many job lengths authors provide randomized olog delta 1ffl competitive algorithm lower bound log delta competitiveness randomized online algorithm adapting constructions model value delta known results lower bounds two distinct lengths omegagammad1 delta arbitrarily many lengths model lipton tomkins later generalized goldman parwatikar suri setting job explicitly specifies deadline choice 10 scheduler may flexibility start job choice notification models becomes meaningful problem defined goldman et al implicitly corresponds setting advanced notification provided scheduler setting provide tight upper lower bound 2 deterministic competitiveness jobs equal length jobs one two lengths give 4competitive randomized algorithm compared lower bound 2 lipton tomkins finally arbitrary job lengths allowed provide 6dlog 2 deltae 1competitive randomized algorithm matching theomegagammae3 delta lower bound within constant factor goldwasser considers setting goldman et al refining analysis based introduction patience instance additional parameter 11 jobs equal length goldwasser proves deterministic algorithm goldman et al shown 2competitive really bc1 competitive similarly proves case jobs arbitrary lengths simple deterministic algorithm 2 1 competitive matching lower bounds given results scheduling single resource special case general problem call control larger communication networks admission control routing issues competitiveness various call control models studied nonpreemptive 1 2 preemptive 3 9 models complete survey given plotkin 18 technique particular use work given awerbuch bartal fiat rosen solving general call control problems tree networks 2 though problems closely relate problem study introduce technique admission control termed classify randomly select jobs classified groups based individual job parameters jobs within group similar enough base algorithm competitive randomness used pick one particular class priori overall algorithm runs base algorithm selected group rejecting jobs groups overall competitiveness increases factor equal number groups results make use fact immediate notification provided base algorithm overall classify randomly select technique provide immediate notification processarivalj accept j else feasibleq fjg nextidle accept j else reject j job earliest deadline nextidle current time give resource j j completes order jobs nondecreasing deadline calculate lateststart min 1js j lateststart return true else return false figure 1 greedynotify algorithm providing immediate notification simple deterministic algorithm denoted greedy analyzed goldman et al goldwasser 10 11 algorithm keeps available jobs queue whenever resource becomes idle schedules available job earliest deadline jobs waiting queue become infeasible explicitly removed queue unfortunately point customer making job request given notification whether request eventually satisfied reason consider another natural greedy algorithm provides immediate noti fication algorithm greedynotify maintains queue accepted jobs whenever new job arrives accepts job feasibly scheduled along previously accepted jobs otherwise immediately rejects job feasibility check based classic result jackson stating absence release times earliest due date ordering jobs produce feasible schedule one exists 14 specifically given set available jobs ordered nondecreasing deadlines jobs feasibly scheduled starting time following inequality satisfied 1js complete algorithm given figure 1 31 efficient implementation algorithm presentation figure 1 clear however efficient feasibility check requires jobs sorted according deadline prefix sum processing times computed naively check time overall algorithm requires time worst case instance n job requests improve running time using better data structure maintaining set q testing feasibility theorem 1 algorithm greedynotify implemented instance n job quests runs olog n time per job request log n overall time proof maintain set q ordered nondecreasing deadlines using redblack tree 5 13 augment tree allow us perform feasibility test jobs set q given starting time make use theorem 151 text cormen leiserson rivest states extra fields added nodes redblack tree still maintaining olog n running time insertions deletions long set fields given node x computed solely information x together values fields children x 8 particular job j x stored node x maintain following two additional fields sum processing times jobs stored subtree rooted node x latestx latest possible starting time feasible scheduling containing jobs stored subtree rooted node x field totalx maintained sum p x values totallef tx totalrightx cases respective child exists value latestx equal righthand side equation 1 applied set nodes subtree rooted x claim value calculated follows x x leaf simply x gamma p x general individual term equation 1 job j depends jobs set lessor equal deadlines j therefore nodes left subtree x contribution tree rooted x tree rooted lef tx x term precisely precisely finally term associated job right subtree reduced exactly sum p x totallef tx jobs surely deadlines less equal job right subtree therefore minimum term contributed node right subtree x equal based formulas conclude jobs inserted deleted set q olog jqj time furthermore value latest stored root represents latest possible starting time feasible schedule containing jobs stored structure allows condition nextidle tested olog jqj time inserting j set q comparing nextidle value latestroot deleting j structure case infeasible overall sure job accounts one insertion structure thus one deletion since size queue never exceed n get overall running time log n 32 equal length jobs begin considering case jobs length important special case right instance atm networks packet sizes addition use algorithm designed equal length jobs base algorithm general case multiple job lengths would convenient could show greedynotify algorithm always produces identical schedule greedy algorithm considered earlier researchers 10 11 unfortunately case demonstrated instance following three jobs instance greedy produces schedule consisting j 1 followed j 3 whereas greedynotify accepts j 1 j 2 rejects j 3 prove special case job lengths equal greedynotify greedy always produce schedules gain specifically prove busy periods resource exactly schedules produced two algorithms therefore previous upper bounds performance greedy automatically apply greedynotify case theorem 2 job lengths equal greedy begins running job j time greedynotify begins running possibly different job time similarly greedynotify begins running job j time greedy begins running job time proof simplicity assumed algorithms break ties lexicographically considering jobs equivalent deadlines let oe denote schedule produced greedy algorithm schedule produced greedynotify algorithm sake contradic tion theorem true let earliest time one schedule starts running job j schedule start job consider two cases depending whether oe starts job j time starts job j time first consider case oe starts j time inductively prove existence integer k 1 sequence jobs fj g times ffl time 1 idle oe begins job j 2 x k begins job j oe begins job j x general framework shown figure 2 base case assumed oe starts j time since jobs equal length defined earliest violation theorem must remain idle time inductive step assume sequence value k prove existence k 1 n figure 2 first case theorem 2 oe runs j time n figure 3 second case theorem 2 runs j time argue job j k accepted greedynotify demonstrate feasible schedule includes j k together previously accepted jobs idle time possible modify schedule job j x scheduled time x rather 1 modified starting times respect individual jobs release times deadlines witnessed oe modification leaves idle spot starting time k could used schedule j k jobs j k j arrived time k witnessed respectively placement oe available oe time k yet greedy chose run j k time based deadlines preceding paragraph know j k arrived accepted time k yet greedynotify begins running job j time could happen case job j k run prior time k therefore define time k1 time job j k begins since assumption job must also started precisely time oe call job j k1 completing induction overall induction shows arbitrarily long sequence unique jobs created since times unique contradicts finiteness given instance must assumption flawed regarding existence time oe starts job j yet idles second case earliest violation involves starting job j time give slightly simpler symmetric argument inductively prove existence integer k 1 sequence jobs fj 1 g times ffl time 1 oe idle begins job j ffl time x 2 x k oe begins job j begins job j x general framework shown figure 3 base case assumed starts j time since jobs equal length defined earliest violation theorem oe must remain idle time inductive step assume sequence value k prove existence k 1 inductive hypotheses see jobs j k j arrived time k witnessed respectively placement oe furthermore jobs accepted greedynotify yet j k chosen run time k job j remained queue since greedy chose run j time k conclude job j k must already completed oe prior time k therefore define time k1 time job j k begins oe since assumption job must also started precisely time call job j k1 completing induction first case arbitrarily long sequence unique jobs provides contradiction completing proof following two corollaries follow trivially theorem 2 together previous analysis greedy given goldman et al 10 goldwasser 11 respectively corollary 3 jobs length greedynotify 2competitive corollary 4 jobs length problem instance patience 0 greedynotify competitive 33 arbitrary job lengths consider instances arbitrary job lengths case schedules greedy greedynotify may differ gain schedules may vary drastically consider instance three jobs j 1i greedynotify algorithm would achieve gain 2 jobs j 1 j 2 accepted however job j 3 rejected possible schedule three jobs alternatively greedy algorithm would run job j 1 0 1 time 1 would choose start j 3 achieving gain 1 delta even begin considering deterministic greedynotify algorithm goldwasser defines algorithm greedytype algorithm long resource never idle job available 11 show greedynotify indeed greedytype algorithm resource idle previously accepted jobs must already completed rejected job available idle time contradicts condition rejection starting job time provides feasible schedule together previously accepted jobs based following two results follow trivially proven greedytype algorithm goldwasser 11 theorem 5 jobs arbitrary lengths greedynotify competitive lemma 6 jobs arbitrary lengths delta equal ratio maximum minimum lengths greedynotify deltacompetitive order design competitive randomized algorithm apply lemma 6 provide base algorithm classify randomly select technique together following lemma given awerbuch et al 2 lemma 7 requests classified set p distinct groups group base algorithm guaranteed ccompetitive classify randomly select technique provides randomized algorithm cjp jcompetitive theorem 8 jobs arbitrary lengths range 1 delta give randomized algorithm immediate notification 4dlog 2 deltaecompetitive proof create dlog 2 deltae distinct groups jobs particular group guaranteed lengths within factor two run greedynotify set jobs lengths within factor two lemma 6 states algorithm 4competitive using greedynotify base algorithm classify randomly select technique results 4dlog 2 deltaecompetitive randomized algorithm according lemma 7 note greedynotify gives immediate notification classify randomly select technique immediately reject jobs selected class resulting algorithm indeed provides immediate notification note upper bound actually stronger 6dlog 1competitive algorithm provided goldman et al case without notification 10 fair case without notification goldman et al specifically sought algorithm rely classify randomly select technique technique results large variance may unappealing practice might desirable develop algorithm notification rely technique algorithm evident 4 case two distinct job lengths conclude examining randomized competitiveness case jobs one two known lengths without loss generality assume jobs length either 1 delta 1 refer groups small jobs large jobs respectively unlike previous cases give evidence immediate notification model strictly harder nonnotification model setting setting immediate notification able provide upper bound 4 competitiveness lower bound 7 previously studied model without notification improve best known upper bound 3 opposite previous lower bound 2 unfortunately gaps overlap unable definitively separate competitiveness two settings 41 immediate notification first consider case two jobs lengths setting immediate notification required provide 4competitive randomized algorithm matches best previously known bound setting notification provide lower bound 7on competitiveness randomized algorithm provides immediate notification improves upon lower bound 2 known setting notification theorem 9 jobs one two distinct lengths exists 4competitive randomized algorithm provides immediate notification proof rely classify randomly select technique time create two groups one consisting small jobs one consisting large jobs since group jobs equal length corollary 3 guarantees greedynotify 2competitive used base algorithm group thus according lemma 7 classify randomly select technique results randomized 4competitive algorithm case multiple length jobs algorithm provides immediate notification theorem 10 jobs one two distinct lengths randomized algorithm notification ccompetitive c 73 proof fix arbitrarily large delta define following four problem instances shown figure 4 ffl instance 1 consists j ffl instance 2 consists j e e 2 figure 4 four problem instances proof theorem 10 maximum possible gain given behavior instance gain opt b c 3 4 table 1 summary potential gains proof theorem 10 ffl instance 3 consists j ffl instance 4 consists j given four instances classify particular execution algorithm one exactly four disjoint behaviors ffl behavior j 1 accepted began processing time ffl behavior b j 1 accepted resource remained idle time ffl behavior c j 1 rejected j 2 accepted ffl behavior j 1 j 2 rejected table presents observations based directly instance behavior definitions given fixed randomized algorithm r let pa probability algorithm produces behavior run instance 1 define similar notation probabilities behaviors four instances since four behaviors constitute disjoint partition possible behaviors 1 4 particular times several instances indistinguishable online algorithm claim based simplify notation letting table 1 infer following lower bounds competitiveness r show possible r competitiveness strictly less 7 3 instances proving overall theorem sake contradiction assume competitiveness strictly less 7 3 four instances equation assures us pd chosen arbitrarily large similarly equation 10 assures us combining bounds knowledge equations 2 5 6 see assumption comp r 7together equation 7 rewritten show 6 similarly conclude equation 8 6 pa adding two inequalities referring equations 11 12 conclude contradicts assumption algorithm r strictly less 7 3 competitive four instances therefore oblivious adversary always able pick instance r least 7competitive 42 without notification setting notification required upper bound four achieved randomized algorithm given goldman et al 10 algorithm denoted greedytwolengths simple describe available jobs kept two queues q 1 small jobs q delta large jobs point resource idle available large jobs algorithm runs large job earliest deadline large jobs small jobs available algorithm flips fair coin taking one following actions probability 1 algorithm runs small job earliest deadline otherwise algorithm immediately rejects small job earliest deadline removing queue virtually schedules resource 1 unit time blocking small jobs running allowing large job begin one arrives analysis algorithm tight witnessed instance consisting two jobs 15i optimal gain instance 2 however expected gain greedytwolengths instance 1as probability 1it begins j 1 j blocks j k preblocks l k figure 5 definitions blocked preblocked time 0 probability 1 rejects job j 0 also virtually blocking resource 0 1 provides 4competitive bound instance making one minor modification algorithm able provide 3competitive algorithm case small jobs exist choose run job earliest deadline probability 2 thus rejecting job virtually scheduling resource remaining3 time denote algorithm greedytwolengthsmodified analysis using charging scheme adapted given goldman et al interested fixed instance let oe denote optimal schedule instance particular execution randomized algorithm greedytwolengthsmodified let oe denote schedule produced job j 2 oe let j oe denote time job j started running oe similarly define j oe j 2 oe begin following definitions diagrammed figure 5 say job j blocks job j k 2 oe j oe j oe say large job l 2 oe preblocks l k 2 oe l immediately follows completion small job oe l oe 1 single execution randomized algorithm greedytwolengthsmodified define following scheme mapping charge jobs completed oe jobs completed oe assignment rule 1 small job scheduled oe oe pays 1to assignment rule 2 small job 2 oe blocks 0 2 oe pays 1 2 0 assignment rule 3 large job l scheduled oe oe pays deltato assignment rule 4 large job l 2 oe pays 1 3 small job 2 oe blocked l assignment rule 5 large job l 2 oe preblocks large job l 0 2 oe l pays deltato l 0 assignment rule large job l 2 oe blocks large job l 3 l 0 assignment rule 7 l 2 oe yet paid delta remaining charge paid job specified rule 6 job exists lemma 11 given charging scheme job j 2 oe pays p units charge proof small job 2 oe pay 1from rule 1 1from rule 2 block one job therefore pays 1 unit large job l 2 oe need consider rules 36 rule 7 never cause overpayment rule 3 account payment delta claim rules 46 account combined payment 2delta l preblocks large job block one job maximum payout case blocked job large case deltais paid rules 5 6 l preblock large job might block ddeltae jobs one large situation 3 paid rule 4 deltais paid rule 6 considering amount charge collected particular job j 2 oe must keep mind charging scheme random process based particular execution randomized algorithm leads schedule oe however let chargej random variable represents amount charge j collects let echargej denote expected value collected charge expectation taken randomness algorithm lemma 12 job j 3 proof bounding expectation taken executions partition set possible executions distinct groups individually analyze conditional expectation taken group g executions able show e g chargej p ifor g conclude general bound analysis rely explicit knowledge relative probability execution going particular group g begin considering small job 2 oe examining three distinct cases based case s1 execution q 1 empty time witnessed placement oe job arrived time otherwise available run since q 1 empty must case removed queue earlier time either scheduled virtually scheduled based coin flip point priori probability 2that would scheduled thus received 1 2 charge rule 1 thus echarges 2 3 case case s2 execution q 1 empty time large job l begins run point interval case l blocking receive 1 3 rule 4 case s3 execution q 1 empty time small job receives consideration coin flip point interval scheduled probability 2and thus block rule 2 would apply case thus echarges 2 3 note three cases indeed form disjoint partition possible executions particular q 1 empty time either large job running small job running small job virtually scheduled next consider large job l 2 oe examining three distinct cases based case l1 execution q delta empty time witnessed placement l oe job arrived time otherwise available run since q delta empty must case l removed queue earlier time scheduled case receives deltabased rule 3 case l2 execution q delta empty time large job l begins run point interval case l blocking l l paid delta 3 according rule 6 case l3 execution q delta empty time small job receives consideration coin flip point interval based algorithm would given consideration time q delta empty yet time q delta empty let l f denote first large job arrives point considered significance l f would large job gets run case virtually scheduled consider two subcases depending deadline l f case l3a know virtually scheduled l f gains use resource arrives see l f blocks l begins time oe thus receives payment rules 67 claim l receive delta l f l uses resource oe entire interval delta cannot case l f blocks small jobs payment made rule 4 l f begins virtually scheduled thus idle period cannot technically preblock job based definition thus l f makes payment rule 5 finally need consider rule 3 happens l f l event delta charge received l alternatively l f claim l f cannot possibly scheduled oe arrives strictly time deadline strictly less therefore cannot fit oe either job l already know runs throughout interval delta since virtually scheduled probability 1and case l receives delta units sure expected charge received l case least delta 3 case l3b f although know whether becomes scheduled virtually scheduled claim l receive delta 3 units charge either case becomes virtually scheduled l f gain resource arrives case l f blocks l l receives delta 3 rule 6 alternatively becomes scheduled claim q delta still nonempty completed therefore large job begin time large job exactly satisfies conditions preblocking l reason l receive deltafrom rule 5 conclude three cases form disjoint partition possible executions particular q delta empty time large job would begin running else resource must currently scheduling appropriate large small job theorem 13 case jobs one two distinct lengths notification required greedytwolengthsmodified 3competitive randomized algorithm proof result direct consequence lemmas 11 12 given particular instance chosen oblivious adversary analyze expected performance randomized algorithm r versus gain optimal schedule instance although charging scheme depends outcome randomized algorithm bound expected amount charge paid using lemma 11 follows eoverall charge paid e lemma 12 provides bound comparing job achieved optimal schedule expected amount charge received jobs scheme summing jobs optimal schedule see gain opt finally use simple rule conservation units charge equating expectations charge received charge paid allows us conclude gain opt eoverall charge paid 3 r competitive nonpreemptive call control bandwidth allocation preemption sharing video demand symmetric binary btrees data structure maintenance power randomization online algorithms online computation competitive analysis introduction algorithms efficient online call control algorithms patience virtue effect slack competitiveness admission control optimization approximation deterministic sequencing scheduling survey dichromatic framework balanced trees scheduling production line minimize maximum tardiness competitive snoopy paging online interval scheduling competitive routing virtual circuits atm networks memory versus randomization online algorithms amortized efficiency list update paging rules tr amortized efficiency list update paging rules introduction algorithms memory versus randomization online algorithms bandwidth allocation preemption efficient online call control algorithms online computation competitive analysis online interval scheduling competitive nonpreemptive call control online scheduling hard deadlines realtime systems
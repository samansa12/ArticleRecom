faster approximation algorithms unit capacity concurrent flow problem applications routing finding sparse cuts paper describes new algorithms approximately solving concurrent multicommodity flow problem uniform capacities algorithms much faster algorithms discovered previously besides important problem right uniformcapacity concurrent flow problem many interesting applications leighton rao used uniformcapacity concurrent flow find approximately sparsest cut graph thereby approximately solve wide variety graph problems including minimum feedback arc set minimum cut linear arrangement minimum area layout however method appeared impractical required solving large linear program paper shows method might practical giving om2 log expectedtime randomized algorithm concurrent flow problem medge graph raghavan thompson used uniformcapacity concurrent flow solve approximately channel width minimization problem large scale integration randomized algorithm okminnk mnlog nlog k deterministic algorithm given problem channel width omegalog n k denotes number wires routed nnode medge network b introduction multicommodity flow problem involves shipping several different commodities respective sources sinks single network total amount flow going edge limited capacity amount commodity wish ship called demand commodity optimization version problem concurrent flow problem goal find maximum percentage z least z percent demand shipped without violating capacity constraints consider concurrent flow problem unit capacities observe case problem equivalent problem finding flow disregarding capacities minimizes maximum total flow edge congestion let n k respectively number edges nodes commodities input network paper give algorithms positive ffl find solution whose congestion 1 times minimum congestion algorithms significantly improve time required finding approximately optimal solutions one contribution paper introduction randomization technique useful iterative approximation algorithms technique enables iteration carried much quickly using known deterministic methods part motivation developing algorithms concurrent flow derives two important applications finding sparsest cuts finding vlsi routing minimizes channel width leighton rao 11 showed use solution unitcapacity concurrent flow problem find approximate sparsest cut graph consequence researchers developed polylogtimesoptimal approximation algorithms wide variety graph problems including minimum area vlsi layout minimum cut linear arrangement minimum feedback arc set 11 optimal linear higherdimensional arrangement 5 minimum chordal fill 7 singleprocessor scheduling 14 computational bottleneck method leighton rao solving unitcapacity concurrent flow problem commodities unit demand appealed linear programming techniques show problem solved polynomial time new approximation algorithm greatly improves resulting running time theorem 11 fixed ffl 0 1 fflfactor approximation unitcapacity unitdemand concurrent flow problem found randomized algorithm ok mm log expected time constant depends ffl application result substantially reduce time required leighton raos method theorem 12 olog nfactor approximation sparsest cut graph found randomized algorithm expected om 2 log time previous best running time 45 log n 18 obtained using linear programming techniques fast matrix multiplication another application approximation algorithm vlsi routing graphs raghavan thompson 13 raghavan 12 considered problem routing twoterminal nets es sentially wires graph approximately minimize channel width ie maximum number nets routed edge computational bottleneck algorithms solving unitcapacity concurrent flow problem algorithms require better constant ffl approximation concurrent flow problem fact algorithm theorem 11 fully polynomial approximation algorithm ie running time depends polynomially ffl gamma1 algorithm type running time randomized fixed ffl omk log n deterministic fixed ffl omkk log n polyn offl gamma3 mk log 2 n polyn offl gamma2 mkk log 2 n table 1 upper bounds running times algorithms actual bounds slightly better theorem 13 positive ffl 1 least inverse polynomial n unitcapacity concurrent flow problem found randomized algorithm expected time offl deterministic algorithm time application algorithm theorem 13 significant improvement time needed solve raghavan thompsons problem theorem 14 w min denotes minimum achievable channel width w min omegagamma450 routing width w min p w min log n found randomized algorithm expected time ok 32 log n deterministic algorithm time ok min fn kg log n log k algorithms compare favorably previous work concurrent flow problem formulated linear program omk variables om nk constraints see example 15 linear programming used solve problem optimally polynomial time kapoor gave method speed matrix inversions involved karmarkar type algorithms multicommodity flow problems combining technique vaidyas new linear programming algorithm using fast matrix multiplication 18 yields time bound ok 35 n 3 p unitcapacity concurrent flow problem integer demands denotes sum demands approximation problem shahrokhi matula 15 gave combinatorial fully polynomial approximation scheme unitcapacity concurrent flow problem called concurrent flow problem uniform capacities algorithm runs onm 7 ffl gamma5 time approach solving concurrent flow problems modification framework originated shahrokhi matula 15 idea use length function edges reflect congestion iteratively reroute flow long congested paths short less congested paths approach differs shahrokhi matula several ways develop framework relaxed optimality conditions allows us measure congestion local global level thereby giving us freedom choosing flow paths reroute iteration exploit freedom using faster randomized method choosing flow paths addition framework also allows us achieve greater improvement result rerouting table 1 give upper bounds running times algorithms actual bounds slightly better table given detail remainder paper note use various combinations techniques obtain slightly better bounds stated theorems 11 13 earlier version paper appeared 9 earlier version case capacities demands uniform considered separately general case capacities assumed uniform earlier version presented fast algorithm first case factor ffl gamma1 slower one general case version extend algorithm uniform demand case work general case logarithmic slowdown preliminaries definitions section define concurrent flow problem introduce notation give basic facts regarding problem concurrent flow variant multicommodity flow start giving formal definition latter multicommodity flow problem problem shipping several different commodities respective sources sinks single network obeying capacity constraints precisely instance multicommodity flow problem consists undirected graph nonnegative capacity capvw every edge vw 2 e specification k commodities k specification commodity consists sourcesink pair nonnegative integer demand di denote maximum demand max total demand number nodes n number edges number different sources k notice k n notational convenience assume n graph g parallel edges edge nodes v w edge unique assumption denote vw note vw wv denote edge flow f g node node defined collection paths associated real values let p denote collection paths g let f p nonnegative value every p p value flow thus defined total flow delivered amount flow edge vw feasible multicommodity flow f g consists flow f value di require fvw capvw every edge vw 2 e use denote total amount flow edge vw consider optimization version multicommodity flow problem called concurrent flow problem first defined shahrokhi matula 15 problem objective compute maximum possible value z feasible multicommodity flow demands z delta di every 1 k call z throughput multicommodity flow equivalent formulation concurrent flow problem compute maximum z feasible flow demands di capacities capvwz paper shall focus exclusively special case unit capacities edge capacities equal problem finding maximum throughput z reformulated special case follows ignore capacities find multicommodity flow f satisfies demands minimizes jf ffvwg maximum total flow edge multicommodity flow f satisfying demands di ffloptimal jf j factor 1 ffl minimum possible jf j approximation problem associated unitcapacity concurrent flow problem find ffloptimal multicommodity flow f shall assume implicitly throughout ffl least inverse polynomial n 110 assumptions restrictive cover practically every case interest find ffloptimal flow ffl 110 one find 110optimal flow find ffloptimal flow 1ffl greater polynomial n one run algorithm work arbitrarily small ffl however running time slower time bounds given need manipulate numbers whose size exponential input however amount accuracy desired sensible efficient use polynomial time linear programming algorithm solve problem exactly one define analogous problem directed graphs algorithms corresponding time bounds easily extend directed case replacing undirected edges directed arcs paths directed paths henceforth concentrate undirected case linear programming duality gives characterization optimum solution concurrent flow problem let r nonnegative length function nodes v w 2 v let dist v w denote length shortest path v w g respect length function path p shall use p denote length p shall use jj 1 denote vw2e vw sum length edges following theorem special case linear programming duality theorem see example 15 theorem 21 multicommodity flow f satisfying demands di length function dist furthermore multicommodity flow f minimizes jf j exists nonzero length function terms equal optimality complimentary slackness conditions given linear programming reformulated terms conditions edges paths theorem 22 multicommodity flow f minimum jf j exists nonzero length function 1 every edge vw 2 e either 2 every commodity every path goal algorithms solve approximation problem ie find multicommodity flow f length function largest term jf jjj 1 1 within 1 ffl factor smallest term dist di case say f ffloptimal note f ffloptimal clearly f ffloptimal fact multicommodity flow f ffloptimal exists length function f ffloptimal 3 relaxed optimality conditions theorems 21 22 give two apparently different characterizations exact optimality goal find flow satisfies relaxed version theorem 21 order introduce relaxed version theorem 22 complimentary slackness conditions linear programming show relaxed optimality conditions sufficient show first last terms 1 within hence flow f ffloptimal notion relaxed optimality analogous notion ffloptimality used goldberg tarjan context minimumcost flow problem 4 error parameter f multicommodity flow length function throughout section shall use ffl 0 denote ffl say path p 2 p commodity fflgood fflbad otherwise intuition flow path fflgood short either relative absolute sense ie either almost short shortest possible small fraction jj 1 use notion defining following relaxed optimality conditions respect flow f length function error parameter ffl r1 every edge first condition says every edge either length small fraction sum lengths edges almost saturated second condition says amount flow fflbad paths ie long paths contributes small fraction sum f delta next two lemmas show relaxed optimality conditions sufficient imply ffl optimality first show condition r1 implies first two terms 1 close show two conditions together imply first last terms 1 close thus conclude relaxed optimality conditions sufficient imply ffloptimality lemma 31 suppose multicommodity flow f length function satisfy relaxed optimality condition r1 vw vw jf jvw two parts first part sum terms contributed edges satisfy jf j 1 part sum clearly vw fvwvw vw edge whose contribution counted first part assumption vw ffl 0 therefore sum terms ffl 0 jf jjj 1 thus implies lemma theorem 32 suppose f ffl satisfy relaxed optimality conditions r1 r2 f ffloptimal ie jf j factor 1 minimum possible need estimate ratio terms inequality 1 theorem 21 lemma 31 estimates ratio first two terms shall use estimating ratio first last term consider penultimate term 1 break sum sum fflgood paths sum fflbad paths relaxed optimality condition us upper bound ffl 0 sum fflbad paths definition fflgood path gives us following bound sum fflgood paths dist observing minfd kdig bound sum fflgood paths dist dist observe exactly k commodities last term sums exactly gives dist combining bounds sum fflbad fflgood paths get dist middle equations theorem 21 gives bound vw2e fvwvw terms jf jjj 1 combining inequalities rearranging terms get dist combining fractions dropping low order terms get dist assumption ffl 110 implies ffl 0 170 turn implies factor 1ffl 0 less 1 ffl combine bound inequality 1 complete proof next two sections focus algorithms achieve relaxed optimality conditions rerouting section describe procedure reduce core approximation algorithms prove bounds running time given multicommodity flow f procedure reduce modifies f either f becomes ffloptimal jf j reduced given target value approximation algorithms presented next two sections repeatedly call procedure reduce decrease jf j factor 2 ffloptimal solution found basic step algorithms choosing flow path rerouting flow path better path step closely resembles basic step algorithm shahrokhi matula 15 main differences way choose paths amount flow rerouted iteration key idea measure good current flow using notion ffloptimality described previous section given flow f value ff determined later use length function defined reflects congestion edge vw words length edge depends flow carried edge given input ffl algorithms reducef ffl oe ff jf j f ffloptimal edge vw vw e fffvw call findpathf ffl find fflbad flow path p short path q endpoints p reroute oe units flow p q return f figure 1 procedure reduce gradually update f f defined formula become ffloptimal update done choosing fflbad flow path rerouting flow path much shorter path respect recomputing length function prove parameter ff definition length selected relaxed optimality condition r1 always satisfied iterative reroutings flow gradually enforce relaxed optimality condition r2 relaxed optimality conditions satisfied theorem 32 used infer f ffloptimal simplicity iof presentation shall assume value length function e fffvw edge vw computed one step fvw represented single computer word section 43 remove assumption sho sufficient compute approximation value show time required computing sufficiently good approximation change asymptotic running times algorithms procedure reduce see figure 1 takes input multicommodity flow f target value error parameter ffl flow quantum oe commodity require flow path comprising f carries flow integer multiple oe procedure repeatedly reroutes units flow fflbad path commodity shortest path need technical granularity condition oe small enough every guarantee approximate optimality achievable reroutings particular assume upon invocation reduce every commodity upon termination procedure outputs improved multicommodity flow f either jf j less target value f ffloptimal recall assumed ffl 110 remainder section analyze procedure reduce shown figure 1 first show throughout reduce f satisfy relaxed optimality condition r1 second show granularity condition satisfied number iterations reduce small third give even smaller bound number iterations case flow f offl optimal upon invocation reduce bound used section 5 analyze fflscaling algorithm presented fourth describe efficient implementations procedure findpath 41 bounding number iterations reduce lemma 41 f multicommodity flow ff 7 flow f length function relaxed optimality condition r1 7 fv w edge vw 2 e let ffl 0 denote ffl 7 observe hence e fff vw use bound ff statement lemma conclude last term least 7m ffl thus vw ffl beginning reduce ff set equal 7 long jf j value ff sufficiently large lemma 41 relaxed optimality condition r1 satisfied lucky relaxed optimality condition follows f ffloptimal show r2 satisfied make significant progress like shahrokhi matula use jj 1 measure progress lemma 42 suppose oe satisfy granularity condition rerouting oe units flow fflbad path commodity shortest path endpoints decreases jj 1 fflbad path let q shortest edges whose length changes due rerouting b decrease jj 1 also written granularity condition definition ff assumption ffl 110 imply 70 e x 140 x e gammax 140 x thus decrease least140 ffoe observe p gives lower bound of140 ffoe p p fflbad must least140 ffoe ffl seen 7ffl implies 139ffl 0 141ffoe therefore first term dominates second term thus third term gives lower bound decrease jj 1 substituting value ff using fact execution reduce jf j yields claim lemma following theorem bounds number iterations reduce theorem 43 every commodity oe satisfy granularity condition jf initially procedure reduce terminates offl iterations proof theorem 32 implies f satisfy relaxed optimality conditions ffloptimal lemma 41 relaxed optimality condition r1 maintained throughout iterations fact f yet ffloptimal implies condition r2 yet satisfied hence exists fflbad path findpath find single rerouting flow fflbad path commodity shortest path results reduction jj 1 every omax log iterations reduce jj 1 least constant factor next bound number times jj 1 reduced constant factor let f 0 denote input multicommodity flow every edge vw f 0 vw jf 0 j hence first assign lengths edges value jj 1 ffjf 0 j length every edge remains least 1 jj 1 always least therefore jj 1 reduced factor e ffjf 0 j times assumption value ff proves reduce terminated claimed number iterations theorem 44 suppose input flow f offloptimal oe satisfy granularity condition initially procedure reduce terminates omax iterations denote input multicommodity flow assumption f 0 offloptimal implies jf every multicommodity flow f therefore value jj 1 never less e 1offl theorem 43 initial value jj 1 ffjf 0 j number times jj 1 reduced constant factor offffljf log offffljf 0 choice ff theorem follows proof theorem 43 42 implementing iteration reduce shown reduce terminates small number iterations remains show iteration carried quickly reduce consists three stepscomputing lengths executing findpath rerouting flow discuss computing lengths section 43 section discuss two steps consider time taken procedure findpath give three implementations procedure first give simple deterministic implementation runs ok log n n time sophisticated implementation runs time ok n log n finally randomized implementation runs expected time algorithms use shortestpaths algorithm fredman tarjan 3 runs om n log n time deterministically find bad flow path first compute every source node length shortest path every node v takes ok mn log n time simplest implementation compute length every flow path p compare length length shortest path decide path fflbad could many flow paths consisting n edges hence computing lengths takes time decrease time required findpath find fflbad path one exists without computing length many paths observe fflbad flow path commodity longest flow path commodity must fflbad thus instead looking fflbad path p commodity suffices find fflbad path directed graph obtained taking flow paths p treating paths directed away order see fflbad path need compute length longest path directed graph facilitate computation shall maintain directed flow graph acyclic let g denote flow graph commodity g acyclic om time dynamic programming computation suffices compute longest paths every node suppose iteration reroute flow fflbad path flow graph g must first update flow graph g reflect change second update might introduce directed cycles g must eliminate cycles flow use algorithm due sleator tarjan 16 implement process sleator tarjan gave simple onm algorithm sophisticated om log n algorithm problem converting arbitrary flow acyclic flow note eliminating cycles decreases flows edges cannot increase jj 1 thus bound number iterations reduce still holds compute total time required iteration reduce follows order implement findpath must compute shortest path g longest path g every commodity time required ok rerouting must update appropriate flow graph eliminate cycles elimination cycles takes om log n time combining bounds gives ok n log nmk log n bound running time findpath fact improvement possible consider flow graphs commodities source flow quantum oe together let g voe directed graph obtained taking union flow paths treating path directed away v g voe acyclic om time dynamic programming computation suffices compute longest paths v every node g voe concurrent flow algorithm commodities demand flow quantum limit different flow graphs consider want limit number different demands decomposing demand di log di demands source sink assume demand power 2 way number different flow graphs maintain k log max lemma 45 total time required deterministically implementing iteration reduce suming exponentiation single step ok n log n mlogn next give randomized implementation findpath much faster ffl small implementation seems simple enough practical f ffloptimal relaxed optimality condition r2 satisfied thus fflbad paths contribute least 7 fraction total sum therefore randomly choosing flow path p probability proportional contribution sum least ffl 7 chance selecting fflbad path furthermore show select candidate fflbad path according right probability om time compute shortest path endpoints omn log n time enables us determine whether p fflbad path thus implement findpath offl expected time contribution flow path p sum length p times flow must choose p probability proportional value order avoid examining flow paths explicitly use twostep procedure described following lemma lemma 46 choose edge vw probability proportional vwfvw select flow path among paths edge vw probability proportional value flow carried path probability selected given flow path p proportional contribution sum select edge vw probability fvwvwb edge vw selected choose path consider commodity path choosing edge probability proportional vwfvw easily done om time order choose right probability flow path going edge need data structure organize flow paths edge maintain balanced binary tree one leaf flow path edge labeled flow value flow path internal node binary tree labeled total flow value descendent leaves number paths polynomial n ffl gamma1 therefore using data structure randomly choose flow path given edge olog n time order maintain data structure time change flow edge must update binary tree edge cost olog n time one iteration reduce flow changes edges therefore time updates log n per call findpath dominated time compute singlesource shortest paths shown relaxed optimality condition r2 satisfied probability least ffl7 find fflbad path om log n time findpath continues pick paths either fflbad path found 7ffl trials made observe given f yet ffloptimal implies condition r2 yet satisfied probability failure find fflbad path 7ffl trials bounded 1e thus case reduce terminate claiming f ffloptimal probability least 1 gamma 1e computing lengths updating flows done log n time thus get following bound lemma 47 one iteration reduce implemented randomly time ffl assuming exponentiation single step randomized algorithm stands monte carlo nonzero probability reduce erroneously claims terminate ffloptimal f make algorithm las vegas never wrong sometimes slow introduce deterministic check findpath fails find fflbad path reduce computes sum dist required precision compares jf jjj 1 determine whether f really ffloptimal loop resumes time required compute sum ok n k singlesource shortest path computations required probability check must done times single call reduce e total expected contribution running time reduce ok recall bound number iterations reduce greater turn least k since iteration carry least one shortest path computation additional time spent checking asymptotically increase bound running time reduce conclude section theorem summarizing running time reduce cases particular interest bounds running time computed multiplying appropriate time iteration reduce appropriate number iterations reduce bounds depend assumption exponentiation single step subsection 43 shall show bounds achieved without assumption shall also give efficient implementation case ffl constant theorem 48 let f oe satisfy granularity condition let hk let g following table contains running times various implementations procedure reduce assuming exponentiation single step randomized implementation deterministic implementation polyn polyn f offlopt 43 implementation details section show get rid assumption exponentiation performed single step also give efficient implementation procedure reduce case ffl fixed 431 removing assumption exponentiation performed o1 time remove assumption exponentiation performed o1 time need two things first show sufficient work edgelengths vw approximations actual lengths show computing approximate edgelengths change asymptotic running times algorithms first step note proof lemma 42 never used fact reroute flow onto shortest path need reroute flow onto sufficiently short path precisely easy convert proof lemma 42 proof following claim lemma 49 suppose oe satisfy granularity condition let p flow path commodity let q path connecting endpoints p length q ffl 0 p 2 greater length shortest path connecting endpoints rerouting units flow path p q decreases jj 1 omegagamma oe show order compute lengths paths precision given lemma need compute lengths edges reasonably small amount precision lemma 49 length path rounding error ffl 0 jf j path n edges suffice ensure edge rounding error 1 bound quantity jf j maximum flow edge hence must least large average flow edge ie jf j vw fvwm every unit flow contributes total flow least one edge hence combining previous equation get jf jd 1m jj 1 least big length longest edge ie jj 1 e ffjf j plugging bounds see suffices compute error ffl 0 edge positive length e ffjf j expressed e ffjf j ae 1 thus need compute ae error ffl 0 nm need compute ologffl gamma1 nm bits assumption ffl inverse polynomial n olog n bits using taylor series expansion e x compute one bit length function o1 time therefore compute lengths edges iteration reduce need om log n time deterministic implementation reduce iteration takes least log n time time required cycle cancelling therefore time spent computing lengths dominated running time iteration approximation depends current value jf j may change iteration crucial recomputed lengths every edge every iteration time om log n would dominate running time randomized implementation reduce recall randomized implementation cycle cancelling thus need find approximation need recomputed every iteration choose one depend current jf j hence need updated edges flow actually changes proceed describe approximation depend rather jf j throughout reduce edge length e least one edge length e ff therefore jj 1 least e ff argument deterministic case bits precision suffice throughout reduce first call reduce must spend time compute edge lengths subsequent iteration need updating edges whose length changed since iteration reduce expected take offl time compute shortest paths findpath time updating edges dominated time required findpath appears time initially compute edge lengths may dominate time spent one invocation reduce shall see section 5 whenever algorithms calls reduce least omegagammast n iterations iteration expected take time compute shortest paths findpath therefore time spent initializing lengths dominated running time reduce note describing randomized version findpath lemma 46 assumed knew exact lengths however using approximate lengths significantly change paths apparent contribution sum hence significantly reduce probability selecting bad path thus shown without assumptions reduce implemented deterministically time stated theorem 48 although randomized version additional initialization time algorithms paper initialization time dominated time spent iterations reduce theorem 410 times required deterministic implementations procedure reduce stated theorem 48 hold without assumption exponentiation single step time required randomized implementations increases additive factor offl log n without assumption 432 improvements fixed ffl section show one reduce time per iteration reduce case ffl constant first show using approximate lengths reduce time required findpath use approximate shortestpaths algorithm runs om give improved implementation details iteration reduce decrease time required parts reduce describe given lengths fflbad path p find path q endpoints q dist first discard edges length greater p never path shorter p p shortest path p fflbad path next remaining graph compute shortest paths using approximate edgelengths 2n dvw 2n e thus giving us dist approximation dist length actual shortest tpath n gamma 1 edges shortest path edge approximate length ffl 0 p actual length thus know dist since shortest path length integer multiple ffl 0 p 2n p use dials implementation dijkstras algorithm 2 compute dist implementing findpath approximate shortest path computation directly improves time required deterministic implementation reduce randomized implementation findpath approximate shortest path computation requires offl expected time order claim iteration reduce implemented amount time must handle two difficulties updating edge lengths updating edges table flow paths flow rerouted previously steps took log n time dominated time findpath reduced time findpath time steps dominates show carry steps time first step show table precomputed edge length updated constant time second step sketch threelevel data structure allows selection random flow path edge time allows constanttime addition deletion flow paths say computing length e fffvw round fffvw nearest multiple fflc constant c introduce additional multiplicative error length edge hence additional multiplicative error 1 offlc path however arguments similar previous subsection still give us sufficiently precise approximation show rounding way small enough number possible values vw compute beginning iteration reduce compute length edge simply looking value precomputed table largest value fffvw ever encounter offl gamma1 log n since concerned multiples fflc total offl gamma2 log n values ever encounter beginning iteration compute numbers precision olog n bits offl gamma2 log 2 n time computed numbers compute length edge computing fffvw truncating multiple fflc looking value vw table takes o1 time thus constant ffl spending olog 2 n address problem maintaining edge flow paths going edge henceforth describe data structure associated single edge first suppose flow paths carry amount flow ie oe case keep pointers flow paths array maintain array onequarter empty easy randomly select flow path constant expected time one randomly chooses index checks whether corresponding array entry pointer flow path select flow path try another index one delete flow paths array constant time one maintains list empty entries one also insert constant time array gets full copy contents new array twice size time required copying amortized time required insertions filled array array gets empty copy contents new array half size time required copying amortized time required deletions emptied array see example 1 detailed description data structure consider general case flow values flow paths may vary case use threelevel data structure top level paths organized according starting nodes second level paths common starting node organized according ending nodes paths starting ending nodes may assumed belong commodity hence carry amount flow thus paths organized using array described first level consists list list item specifies starting node total flow flow paths starting node pointer secondlevel data structure organizing flow paths given starting node secondlevel data structure consists list list item specifies ending node total flow flow paths ending node given starting node pointer thirdlevel data structure array containing flow paths given starting ending nodes analyze time required maintain data structure adding deleting flow path takes constant time choosing random flow path right probability accomplished time first randomly choose value 0 total flow edge scan firstlevel list select appropriate item based value next scan secondlevel list pointed item select item secondlevel list two steps takes time finally select entry thirdlevel array third level array flows oe thus accomplished o1 expected time scheme described shown constant ffl three steps procedure reduce implemented om expected time thus yielding following theorem theorem 411 let f oe satisfy granularity condition let hk let g constant ffl 0 procedure reduce implemented randomized omhk oe deterministic ohk oemlogn 5 concurrent flow algorithms section give approximation algorithms concurrent flow problem uniform capacities describe two algorithms concurrent scalingconcurrent concurrent simpler best ffl constant scalingconcurrent gradually scales ffl right value faster small ffl algorithm concurrent see figure 2 consists sequence calls procedure reduce described previous section initial flow constructed routing commodity single flow path initially set oe call reduce divide flow quantum oe 2 every commodity needed satisfy granularity condition 3 call reduce modifies multicommodity flow f either jf j decreases factor 2 f becomes ffloptimal procedure reduce set global flag indicate whether concluded f ffloptimal latter case algorithm terminate return flow see olog calls reduce suffice achieve ffloptimality theorem 51 algorithm concurrent finds ffloptimal multicommodity flow log n expected time log n log n immediately initialization jf j bound number phases need lower bound minimum value jf j observe every multicommodity flow f total amount flow network every unit flow contributes total flow concurrentg ffl fdi commodity oe di create simple path route di flow f ffloptimal every oe satisfy granularity condition call reducef ffl 2 return f figure 2 procedure concurrent least one edges hence therefore implies number iterations main loop concurrent olog theorems 43 48 procedure reduce invoked single iteration concurrent first spends om log n time initializing edge lengths executes offl gamma1 minfdkdig iterations throughout algorithm oe either equal di thetaffl 2 logmffl gamma1 every first case min fd kdig ae oe second case min fd kdig logmffl thus total number iterations loop reduce offl logmffl time spent initialization edge length dominated value halved every iteration therefore total number calls required iterations offl gamma1 k log n plus twice number required last iteration concurrent follows 4 omegagamma total number iterations loop reduce offl gamma1 k log n ffl gamma3 log n consider special case ffl constant use version reduce implemented approximate shortest path computation apply bounds theorem 411 combined proof similar theorem 51 get following result theorem 52 constant ffl 0 ffloptimal solution unitcapacity concurrent flow problem found omk log 2 n expected time randomized algorithm omk log max g log n time deterministic algorithm ffl less constant use algorithm scalingconcurrent shown figure 3 starts large ffl gradually scales ffl required value precisely algorithm scalingconcurrent starts applying algorithm concurrent concurrent repeatedly divides ffl factor 2 calls reduce initial call concurrent f 1optimal ie jf j twice minimum possible value therefore jf j cannot decreased 2 every subsequent call reduce returns ffloptimal multicommodity flow current value ffl concurrent call reduce uses largest flow quantum oe permitted granularity condition 3 f resulting flow 2 ffl ffl 0 every oe satisfy granularity condition call reducef ffl oe return f figure 3 procedure scalingconcurrent theorem 53 algorithm scalingconcurrent finds ffloptimal multicommodity flow expected stated theorem 52 call procedure concurrent takes okm log nm 2 log time returns multicommodity flow f 1 optimal hence jf j twice minimum therefore every subsequent call reduce returns ffloptimal multicommodity flow f time required one iteration dominated call reduce input flow f reduce 2ffloptimal theorems 48 410 time required randomized implementation reduce offl seen max ok ffl gamma2 log value ffl reduced factor two every iteration therefore total time required iterations twice time required last iteration last iteration takes ok proves claim consider implementation concurrent scalingconcurrent deterministic version reduce time required findpath depend ffl claim time bounded twice time required last call reduce since log ffl gamma1 iterations following theorem theorem 54 ffloptimal solution unitcapacity concurrent flow problem found deterministically time okm log 2 nk log ffl log nk n log nmlog nmin fk k log max g 6 two applications section describe two applications unitcapacity concurrent flow algorithm first application efficiently implement leighton raos sparsest cut approximation algorithm 11 second application approximately minimize channel width vlsi routing second problem considered raghavan thompson 13 raghavan 12 start reviewing result leighton rao concerning finding approximately sparsest cut graph partition nodes graph g two sets b associated cut set edges b ffi b denotes number edges cut cut sparsest ffi bjajjbj minimized leighton rao 11 gave olog napproximation algorithm finding sparsest cut graph applying algorithm obtained polylog timesoptimal approximation algorithms wide variety npcomplete graph problems including minimum feedback arc set minimum cut linear arrangement minimum area layout leighton rao exploited following connection sparsest cuts concurrent flow consider allpairs multicommodity flow g unit demand every pair nodes feasible flow f partition b nodes g total least jajjbj units flow must cross cut b consequently one edge must carry least jajjbjffia b flow sparsest cut b leighton rao prove approximate maxflow mincut theorem allpairs concurrent flow problem showing fact lower bound jf j olog n factor minimum value approximate sparsestcut algorithm makes use connection precisely given nearly optimal length function dual variables show find partition ab within factor olog n minimum value jf j hence value sparsest cut 1 computational bottleneck method solving unitcapacity concurrent flow problem demand 1 every pair nodes paper appealed fact concurrent flow formulated linear program hence solved polynomial time much efficient approach use unitcapacity approximation algorithm number commodities required 2 leighton 10 discovered technique reduce number commodities required shows graph edge connecting sourcesink pair expander graph resulting flow problem suffices purpose finding approximately sparsest cut call graph demand graph expander partition node set b jaj jbj number commodities crossing associated cut jaj therefore value jf j smaller flow problem omegagamma jajffia b since jbj n2 follows njf j omegagamma jajjbjffia b smaller flow problem essentially simulates original allpairs problem moreover leighton raos sparsestcut algorithm start length function smaller flow problem place allpairs problem thus leightons idea allows one find approximate sparsestcut solving much smaller concurrent flow problem one willing tolerate small probability error approximation one use randomly selected sourcesink pairs commodities well known randomly select node pairs high probability resulting demand graph expander theorem 52 algorithm concurrent takes expected time om 2 log 2 find appropriate solution smaller problem theorem 61 olog nfactor approximation sparsest cut graph found randomized algorithm om 2 log 2 time second application discuss approximately minimizing channel width vlsi routing often vlsi design consists collection modules separated channels modules connected wires routed channels purposes regularity channels uniform width desirable minimize width order minimize total area vlsi circuit raghavan thompson 13 give approximation algorithm minimizing channel width model problem graph problem one must route wires pairs nodes graph g minimize maximum number wires routed edge approximately solve problem first solve concurrent flow problem commodity demand 1 path needs routed optimal solution f opt fails algorithm also works edgeweighted graphs weights translate edge capacities corresponding concurrent flow problem wire routing may consist paths fractional flow however value jf opt j certainly lower bound minimum channel width raghavan thompson give randomized method converting fractional flow f opt integral flow increasing channel width slightly resulting wire routing f achieves channel width jf opt j log n 5 w min w min log n w min minimum width fact constant implicit bound quite small later raghavan 12 showed conversion method made deterministic computational bottleneck solving unitcapacity concurrent flow problem theorems 53 54 applicable yield good algorithms w min n substantially better 2 case modified version algorithm scalingconcurrent directly yields integral f satisfying 5 although bigoh constant good 13 consider procedure scalingconcurrent consists two parts first procedure concurrent called achieve 1 optimality next scalingconcurrent repeatedly calls reduce reducing error parameter ffl factor two every iteration till required accuracy achieved demands every commodity hence oe independent shall denote oe claim w omegagamma207 n oe initially 1 application need never reduced consequently remains single path flow per commodity randomized conversion method raghavan thompson becomes unnecessary show paths constitute routing width w min w min log n first suppose call concurrent terminates granularity condition becomes false point jf j2 n assumption w omegagamma54 n hence jf w min log n assume call concurrent terminates 1 optimal flow proceed scalingconcurrent terminates granularity condition becomes false point inequality 6 implies ffl flow f ffloptimal integral jf ow min bound jf j w min w min log required theorem 62 w min denotes minimum possible width w min omegagamma407 routing width w min log n found randomized algorithm expected time okm log n log k k 32 mn log n log n deterministic algorithm time ok log kk n log nmk log n shown algorithm scalingconcurrent finds required routing terminated soon granularity condition becomes false oe 1 analyze time required every throughout algorithm oe number calls reduce concurrent olog initially jf j k never gets 1 1 therefore number iterations loop reduce required 2 case interst wmin olog n error term 5 dominates wmin concurrent ok log k next proceed scalingconcurrent number iterations olog k ffl reduced factor two iteration ffl starts 1 never gets 1k iteration call reduce turn results ok iterations loop reduce time required one iteration loop deterministically ok n log n mk log total time find good routing wires ok log kk n log expected time required randomized implementation reduce om log n n total expected time required concurrent omk log k log n call concurrent ffl decreases factor two iteration follows total expected time required iterations om log n log ffl gamma1 plus twice time last call reduce last call reduce ffl k log n time required iterations okm log n log log n time dominates time required concurrent since w min omegagamma200 n implies k n acknowledgments grateful andrew goldberg tom leighton satish rao david shmoys pravin vaidya helpful discussions r introduction algorithms algorithm 360 shortest path forest topological ordering fibonacci heaps uses improved network optimization algorithms solving minimumcost flow problems successive approxi mation approximation algorithms geometric embeddings plane applications parallel processing problems fast algorithms convex quadratic programming multicommodity flows approximation multicommodity flow approximate maxflow mincut theorem uniform multicommodity flow problems applications approximation algorithms probabilistic construction deterministic algorithms approximating packing integer programs provably good routing graphs regular arrays ordering problems approximated singleprocesssor scheduling interval graph completion maximum concurrent flow problem data structure dynamic trees improved approximation algorithm concurrent multicommodity flows speeding linear programming using fast matrix multiplication tr ctr suhwen chiou combinatorial approximation algorithm concurrent flow problem application computers operations research v32 n4 p10071035 april 2005 xh jia dz du xd hu hj huang dy li optimal placement wavelength converters wdm networks parallel distributed computing systems optical networks recent advances kluwer academic publishers norwell 2001 mariechristine costa alain hertz michel mittaz bounds heuristics shortest capacitated paths problem journal heuristics v8 n4 p449465 july 2002 anil kamath omri palmon serge plotkin fast approximation algorithm minimum cost multicommodity flow proceedings sixth annual acmsiam symposium discrete algorithms p493501 january 2224 1995 san francisco california united states george karakostas faster approximation schemes fractional multicommodity flow problems proceedings thirteenth annual acmsiam symposium discrete algorithms p166173 january 0608 2002 san francisco california philip klein hsuehi lu efficient approximation algorithms semidefinite programs arising max cut coloring proceedings twentyeighth annual acm symposium theory computing p338347 may 2224 1996 philadelphia pennsylvania united states neal e young randomized rounding without solving linear program proceedings sixth annual acmsiam symposium discrete algorithms p170178 january 2224 1995 san francisco california united states david karger serge plotkin adding multiple cost constraints combinatorial optimization problems applications multicommodity flows proceedings twentyseventh annual acm symposium theory computing p1825 may 29june 01 1995 las vegas nevada united states matthew andrews kyomin jung alexander stolyar stability maxweight routing scheduling protocol dynamic networks critical loads proceedings thirtyninth annual acm symposium theory computing june 1113 2007 san diego california usa ashish goel monika r henzinger serge plotkin online througputcompetitive algorithm multicast routing admission control proceedings ninth annual acmsiam symposium discrete algorithms p97106 january 2527 1998 san francisco california united states ashish goel monika r henzinger serge plotkin online throughputcompetitive algorithm multicast routing admission control journal algorithms v55 n1 p120 april 2005 prabhakar raghavan eli upfal efficient routing alloptical networks proceedings twentysixth annual acm symposium theory computing p134143 may 2325 1994 montreal quebec canada anil kamath omri palmon serge plotkin routing admission control general topology networks poisson arrivals proceedings seventh annual acmsiam symposium discrete algorithms p269278 january 2830 1996 atlanta georgia united states lisa fleischer fast approximation scheme fractional covering problems variable upper bounds proceedings fifteenth annual acmsiam symposium discrete algorithms january 1114 2004 new orleans louisiana james aspnes yossi azar amos fiat serge plotkin orli waarts online routing virtual circuits applications load balancing machine scheduling journal acm jacm v44 n3 p486504 may 1997 tom leighton satish rao multicommodity maxflow mincut theorems use designing approximation algorithms journal acm jacm v46 n6 p787832 nov 1999 david r karger clifford stein new approach minimum cut problem journal acm jacm v43 n4 p601640 july 1996
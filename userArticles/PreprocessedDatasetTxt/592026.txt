efficient specificationbased component retrieval paper present mechanism making specificationbased component retrieval efficient limiting amount theorem proving required query time done using classification scheme reduce number specification matching proofs required process query components classified assigning features correspond necessary conditions implied component specifications show method feature assignment used approximate reusability relationships queries library components set possible classification features formally defined permitting automation classification process classification process made efficient using specialized theorem proving tactic prove feature implication retrieval mechanism implemented evaluated experimentally using library list manipulation components results indicate better response time existing formal approaches approach provides higher levels consistency automation informal methods comparable retrieval performance b introduction concept component reuse fundamental engineering disciplines components provide levels abstraction used effectively construct increasingly complex systems software engineering exception main focus providing languages methodologies help software designers create useful reusable abstractions fact software reuse recently described mili et al realistic approach meet needs software industry 23 potential software reuse limited source code includes algorithms architectures domain models design decisions program transformations documentation virtually every possible aspect software system addition benefits software reuse extend beyond design phase analysis maintenance phases development article focuses functional components methodology presented compatible software reuse artifacts refinement ordering exists specifications includes source code highlevel components 1 software architectures 9 26 program transformations 4 note also component retrieval confined library reuse also considered context integrating components generic software architectures either statically 1 dynamically 27 potential benefits software reuse far reaching practice software reuse flourished managerial technical reasons one major technical barrier providing tools automate reuse process understand reason technical difficulty automating reuse helpful decompose library reuse process three activities retrieval specifying query locating potential reuse candidates within software library evaluation determining relationship retrieved component specification desired component adaptation making changes component meet reuse requirements ideally reuse tool provide automated assistance three reuse activities activities interdependent high reuse potential retrieval indicate low reuse effort evaluation respect known adaptation methods however automation difficult activity requires different information component retrieval benefits abstract classification component function supports efficient comparison automated evaluation useful must provide designer precise relationship high level assurance therefore evaluation depends precise detailed description component behavior adaptation requires knowledge structure component functions subcomponents therefore choice component representation scheme determines software reuse activities automated effectively source code reuse main focus software reuse efforts however automation reuse processes requires understanding aspects component described source code source code provides description component performs function purposes retrieval interested precisely function difference represents semantic gap makes difficult understand function code recognize potentially reusable component source code sufficient representation support automation reuse processes therefore method required represents additional information necessary automate reuse 11 specificationbased reuse formal specification languages provide expressiveness precision necessary capture function component specification matching 35 45 applies theorem proving evaluate relationships specifications given formal definition reusability specification matching used evaluate reusability component respect requirements specification addition automated reasoning used determine changes necessary reuse component guide component adaptation 29 39 illustrate potential using formal methods assist software reuse present sample scenario designer interacting specificationbased retrieval system first designer must develop specification desired component used query library specification defines domain range precondition postcondition desired component specification abstract need complete example designer looking list decomposition methods library list manipulation components following query might used pre true post forall xe result submitting query component retrieval system list components matching necessary port substitutions matching conditions formal relationships component query specifications representing conditions component may reused matching conditions may associated set rules automated mechanisms adapting component case example retrieval system gives following results component match substitutions removefirst weak post rest 7 output removelast weak post rest 7 output split weak post left 7 output split weak post right 7 output weak post match defined formally c oc op indicates component provides solution part problems domain designer would like find component covers entire domain however case obvious happen case empty input list designer strengthen precondition query eliminate case response new query system provides following results component match substitutions removefirst weak plugin rest 7 output removelast weak plugin rest 7 output split weakpost left 7 output split weakpost right 7 output weak plugin match one several matches gives formal guarantee component provides valid solution legal inputs problem therefore removefirst removelast components safely reused solve second query 12 technical overview due overhead automated theorem proving specification matching computationally expensive test large number components acceptable amount time 7 21 43 attain practical response times specification matching must limited evaluating small number components retrieved separate mechanism alternative limiting specification matching limit expressibility specification language making retrieval efficient 31 however lowers level assurance evaluation takes account fewer aspects components behavior approaches distinguish retrieval evaluation either inefficient retrieval weak evaluation effectively separate retrieval evaluation necessary maintain consistency evaluation criteria retrieval goal specifically classification scheme used retrieval identify components match query specification respect reusability relationship evaluation based component semantics classification schemes based upon syntactical measures guaranteed consistent evaluation criteria paper presents method making specificationbased retrieval efficient using semantic information provided specifications figure 1 depicts flow design information within retrieval system diagram boxes represent data structures ovals represent computations arrows represent data flow computations references data structures system formal specifications used model problem requirements function library components specifications based abstract data types defined algebraic domain theory 14 42 section 2 present formal component specifications section 3 explains specification matching used determine component reusability component retrieval made efficient layering classification scheme specifications classification scheme consists collection formal definitions representing possible component features domain definitions control classification process place human domain expert formalizing scheme permits automated classification specifications semantic classification scheme presented section 4 output classification phase set features used query component library library retrieval mechanism returns components feature sets similar query featurebased retrieval discussed section 5 similar components passed detailed evaluation uses specification matching determine components precise relationship requirements specification retrieval system implemented using ml programming language 25 hol 12 theorem proving system section 6 evaluate response time retrieval performance experimentally compare retrieval methods section 7 compares experimental results published results section 8 discusses performance semantic classification terms effects retrieval system discuss related work conclude 2 component specifications software systems represented architectural level collection interconnected components 38 components system constituent subsystems encapsulate part systems classification scheme specification matching classification retrieval theory domain requirements specification component library component retrieval system similar components feature matching components domain modeler designer figure 1 overview specificationbased retrieval semantic classification recordlist includes record listrec introduces defined asserts 8 llistrec rrec kkey 9 r containslr krkey rkey firstlkey assumes totalorderkey introduces asserts rec partitioned key prepend first rest last contains asserts liste partitioned empty first rest appende prepende figure 2 larch shared language specification list records functionality subsystem turn composed collection subsystems resulting hierarchical system structure decomposition continues manner reaching components implemented component composition actual source code formal specifications provide benefits informal specifications source code descriptions first specifications formal provide precise unambiguous description components function second description declarative opposed operational nature meaning describes component without reference important issue reuse dependency upon unspecified unintended functionality cause problems context evolving requirements implementations formal specification broken two levels abstraction domain theories interface specifications 14 domain theory defines vocabulary used specification providing models data types operations used domain interest interface specifications define behavior system components terms domain theory 21 domain theories use algebraic specifications build domain theories algebraic specification defines set abstract data types operations example figure 2 contains larch shared language 14 specification list records recordlist specification called traits larch includes record specification parameterized list specification list specification operators defined appending component search import recordlist end search figure 3 example interface specification prepending concatenating computing list membership list length generated clause defines operators used recursively construct values type partitioned clause identifies set operators evaluated deduce equivalence two values type domain theory developed certain problem domain data types operations referenced interface specifications 22 interface specifications interface specification defines behavior component terms domain range precondition postcondition example figure 3 shows interface specification search component domain range define input output types component respectively precondition specifies set inputs components operation defined called legal inputs postcondition defines relationship must hold input valid output precondition true component begins executing component guaranteed terminate state postcondition true 13 restrictions guarantees behavior component precondition hold formally component specification p translated following predicate logic axiom dp rp domain range component p x op x z precondition postcondition respectively 3 reusability using formal specifications evaluate reusability requires formal definition relationship must exist component reused solve new problem stress point existing literature specificationbased component retrieval consistent choice evaluation conditions first consider case component completely satisfies problem query specification discuss relationships may indicate components adapted reused component completely solves problem results one problems valid outputs problems legal inputs formally component specification c satisfies problem specification p following condition holds first conjunct states component accept legal inputs problem second conjunct states valid outputs component legal problem input valid outputs problem behavior component outside legal problem inputs concern determining ability solve problem assume ignoring potential subtype substitutions subtypes supported implicitly using predicates integerx realx explicitly efficient reasoning 36 plugin weak plugin gammapsi plugin post r satisfies gammapsi weak post c oc op r gammapsi stronger weaker figure 4 lattice specification matches used evaluating reusability always case component completely satisfying problem exist library therefore desirable query match components adapted combined solve problem zaremski wing 43 45 identified collection specification matches useful comparing specifications figure 4 shows subset matches think interest determining reusability addition satisfies match 1 following zaremski wing matches arranged lattice arrow two matches indicates match base arrow stronger logically implies match head arrow formal notation abbreviated dropping quantifiers variable arguments predicates three matches leftmost path require precondition problem stronger precondition component differ set inputs require valid output postcondition relation component plugin match checks whole domain weak plugin restricts check legal component inputs satisfies restricts legal inputs problem logical relationship matches components matching plugin weak plugin match satisfies however plugin weak plugin cause disregard useful components used retrieval condition plugin post weak post matches differ others requiring legal problem inputs legal component inputs component matches problem one ways could problem inputs cause unspecified behavior component however know legal problem input also legal component input component provides valid problem output therefore components match ways used partial solution problem collection components composed provide complete solution problem matches also useful finding components nontrivial preconditions without specify precondition query 43 specification matches formally defined checked using automated theorem prover however due complexity automated theorem proving specification matching computationally expensive test large number components 7 21 43 practical specificationbased retrieval requires efficient way identify components match query specification respect reusability relationship next section presents method classifying components using semantics specifications 4 semantic classification efficiency required specificationbased retrieval achieved using featurebased classification scheme featurebased retrieval efficient relies syntactic matching attributevalue pairs features similarity two components measured number features common applying featurebased classification hand library components assigned set features domain expert retrieve set potentially useful components designer translates classifies problem requirements set features corresponding class components retrieved library queries generalized relaxing feature sets compared potential problem featurebased classification maintaining consistency classification process 24 33 effective retrieval requires domain expert developers common understanding intended semantics features would desirable systematize automate classification increase confidence classification consistent among domain experts developers automatic indexing based semantics 2 practical code reuse standpoint would require massive reengineering effort however formal component specifications provide explicit semantic representation used foundation component classification automation featurebased classification requires answering two questions 17 automatically generate features specification possible features component answer first question describing framework assigning features components way assists search reusable components discuss define set possible features used classify components 41 feature set generation classification scheme used retrieval identify components match query specification respect reuse matches identified section 3 inspection specification matches reveals general pattern case part one specification logically implies part another specification p search situations guided using necessary conditions necessary condition predicate p another predicate phi logically weaker p ie p phi two predicates p q p q every necessary condition q necessary condition therefore commonly describe p q fact logically imply phi necessary conditions used way assist search reusable components specifically identify components cannot match specification therefore undergo detailed analysis component query specifications classified based given set necessary conditions classification scheme associates feature necessary condition feature assigned component associated necessary condition logically implied components specification general result semantic classification method component feature set similar query potential reuse match hold component query conversely components features common less likely reusable therefore syntactic comparison feature sets used efficiently approximate semantic relationships components general semantic classification cannot guaranteed eliminate nonmatching components behavior system depends upon set necessary conditions used classification scheme reuse matches approximated effect approximate reasoning based feature sets unsound incomplete however considered critical flaw clear effects practical performance system 5 impact unsound incomplete classification evaluated experimentally measuring effect retrieval performance section 6 42 feature definitions classification process controlled collection feature definitions determine set necessary conditionfeature pairs used feature definitions capture knowledge domain expert would use classify components hand formally defining classification features feature assignment process classification fully automated filtert figure 5 sample feature definitions dataflow abstraction characterize aspects interface specifications features must represent abstract relationships component inputs outputs feature definitions link feature names values logical predicates specify associated concept feature definitions following format feature name provides syntactic label concept feature value type1 type2 represents data type parameters instantiated based domain range specification two components perform similar function different data types feature name different values variables x actually metavariables range set input output variables component isio predicates either isinput isoutput determine sets metavariable ranges associates type variable feature value parameters condition predicate necessary condition associated feature feature definition instantiated substituting combinations input output variables component classified instantiation restricted type checking operators used specifying condition set features used classify reuse library domain dependent necessary conditions feature definitions specified terms formal domain theory allows specific abstractions made operators provide similar functionality different types domain example containment operator contains used describe containment many different situations referencing operator feature definition draw similarities components whose function specified terms containment figure 5 shows subset features currently defined provide dataflow style abstraction list processing domain example select feature represents case output element input variable definition parameterized datatypes select possible feature whenever containment operator exists input output type set feature definitions used following example 43 classification example figure 6 shows classification search component figure 3 based first two feature definitions figure 5 first domain range interface specification substituted feature definitions create set featurenecessary conditions used classification example domain theory instantiate featuregoal pairs definitions feature proof tactic specialized feature assignment requirements specification figure 6 example featurebased classification search component select nonmember feature definitions instantiated input variables types domain input rec specification giving second fourth instantiated definitions eliminated due type checking constraints bool defined domain theory next specialized proof tactic used check necessary conditions implied specifi cation example following proof obligation generated first instantiated definition example proof term containsinput item succeeds therefore associated feature selectlistrec rec assigned component 5 retrieval given feature set representation problem wish retrieve components match problem terms formal specification matches features assigned components based necessary conditions less features component common query less likely one reusability matches holds two therefore interested components features common query identical specifications identical feature sets initial query components identical feature set problem components query generalized loosening feature comparison constraints include larger class components prototype query generalization automated continues number retrieved components reaches usersupplied threshold first step generalization weaken requirements feature value equivalence feature values represent types component operates identifies components performing similar operations different types second step reduce number problem features component must contain allows retrieval components may partial solution problem finally two types generalization combined find components features common query following sample retrieval session provides example type query generalization figure 7 shows two problem specifications set component specifications associated feature sets specifications classified using feature definitions figure 5 resulting feature sets listed specification components displayed beneath problem specifications retrieved exhibit relationship feature sets specification matches strongest match exists problem component listed component specification first example wish find record specified key within list component expected perform correctly record list two components retrieved identical feature sets find first search matches plugin therefore satisfies meaning used solve problem second binarysearch matches plugin post requires input sorted possible input list known sorted designer include information query therefore binarysearch possible use solving problem third component treesearch retrieved weakening constraint feature values must equal treesearch component select build features however different type values component may useful substituting listrec tree rec bucket second example problem specified abstractly first designer looking components take list return smaller list composed elements first list manner selecting elements new list unspecified query useful finding existing options decomposing lists first two components returned removefirst removelast match query weak plugin precondition components emptyinput required true ensure output list smaller input list technically two components query weak plugin satisfies equivalent matches preconditions logically equivalent third component split matches weak post component precondition stronger query precondition split component provides valid solution problem except case lengthinput 1 6 empirical evaluation component retrieval based brute force specification matching attempts match query every component library therefore involves many individual proof attempts fail 37 goal semantic classification eliminate components lead unsuccessful proof attempts evaluation saving time effort number matching andor nonmatching components eliminated depends upon performance retrieval system several experiments performed evaluate retrieval system performance 61 implementation semantic classification system implemented using ml programming language 25 hol 12 theorem proving system several precautions taken reduce overhead automated reasoning classification 28 first feature sets library components calculated beforehand stored index second special purpose proof tactic constructed hol solve theorems form feature implication proofs proof tactic parameterized set domain axioms applies making domain independent finally speed inference inductive proofs eliminated burying induction proofs lemmas adding lemmas domain theory precau 2problem specifications component find import recordlist end find features selectlistrecrecbuildkeyrec component specifications component subset post forall xrec import recordlist end subset features filterlistrecrec component search import recordlist end search features selectlistrecrecbuildkeyrec component binarysearch import recordlist end find features selectlistrecrecbuildkeyrec component treesearch import buckettree end find features component removefirst first rec import recordlist end removefirst features selectlistrecrecfilterlistrecrec component removelast last import recordlist end removelast features selectlistrecrecfilterlistrecrec component split post isemptyleft isemptyright import recordlist end split features splitlistrecrecfilterlistrecrec figure 7 example problem specification component specifications feature sets tions result incomplete proof procedure one goal experiments evaluate impact incompleteness retrieval performance 62 library component retrieval evaluation done using library specification list manipulation components library used experiments specificationbased component retrieval systems 37 providing opportunity direct comparison results library designed test whether specificationbased retrieval handle variation way components specified way queries posed system example 3 different specifications head component takes list returns list containing first element original list 63 evaluation method two traditional measures component retrieval performance recall precision 23 recall ratio number relevant items retrieved total number relevant items library high recall indicates relatively relevant components overlooked precision ratio number relevant items retrieved total number items retrieved high precision means relatively irrelevant components retrieved general tradeoff precision retrieval goal find practical balance two relevance condition fundamental evaluation retrieval system discussed experiments conducted two different relevance conditions also informative observe number components retrieved system number help estimate load would placed designer interpret results query interactive system similarly search space would faced adaptation system considering component compositions 28 response time system also measured determine practicality method measured quantity minimum maximum median calculated scenarios experiment 64 design experiments experiments designed compare way several factors affected performance retrieval system first foremost ability automated classification system derive classification features second interested performance retrieval context exact retrieval approximate retrieval finally nature library raised questions determining appropriate query set experimentation therefore two different query sets used 641 feature generation retrieval system whole separated classification scheme defined feature definitions classification mechanism specialized proof tactic domain theorems sense mechanism attempts implement scheme aspects retrieval system affect precision recall classification scheme affects precision size consistency component clusters affects recall scheme may always contain feature inferred relevant components incompleteness classification mechanism specialized proof tactic incomplete could cause generate fewer features subsequently retrieve fewer components intended missing components relevant lower recall precision classification mechanism sound implemented terms sound constructs hol derive implied features experiment three scenarios tested 1 signature matching 44 retrieval based component signatures 2 expected features retrieval based features would assigned complete proof procedure 3 derived features retrieval based features assigned implemented system signature matching retrieves components identical signatures library components identical signatures list list therefore performance signature matching provides profile composition library terms relevant components expected features determine performance classification scheme implemented perfectly would allow expected features determined inspection aid lattice specifications library implemented retrieval mechanism ie domain theory axioms together feature derivation tactics used generate derived features results evaluated see close comes implementing classification scheme 642 relevance conditions choice relevance condition fundamental determining significance precision recall measures 22 experiment evaluated performance system respect two relevance conditions first use satisfies match consistent standard specificationbased retrieval experiments 21 37 second consider relevant component one matches query specification respect reuse matches identified section 3 relevance condition important context adaptation relevant component one potentially adapted system 28 29 643 query set following experiments done schumann fischer 37 library components used set queries test performance system using components query set makes two assumptions 1 component specifications represent good sample queries may asked 2 queries probability posed system get results would predict performance tool realistic setting would necessary distribution queries represents tool would used study component retrieval literature would provide information library used experiment several groups functionally equivalent specifications would practice point one component raises question define unique query experiment specification component potentially many specifications therefore experiment run duplicate specifications query set without difference results two cases negligible indicating system favor components multiple specifications 28 present results experiment including equivalent queries 65 experimental results experiment involved library list manipulation components signature list 7 list library contained 63 specifications 45 functionally unique components experiment divided two parts first part classification scheme figure 5 used due limited signatures following features applied filtert second part experiment classification scheme extended extension scheme guided placing library components lattice based satisfies matching condition domain theory theorems used parameters classification mechanism shown figure 8 theorems selected observing failed proofs expected features determining normalization rules normalization implications rewrite rules expansion rules figure 8 domain theory list library experiment table 1 retrieval satisfies match using initial classification scheme scenario retrieved precision recall signature match 6300 63 63 011 002 064 100 100 100 expected features exact match 2271 3 31 020 003 074 084 005 100 relaxed match derived features exact match 2227 3 31 relaxed match 4357 12 51 012 002 065 086 010 100 theorems necessary make proofs succeed theorems mainly deal reasoning containment used define feature definitions terms list type constructors cons append 651 satisfies match results initial part experiment satisfies match shown table 1 table entries denote average value minimum maximum parenthesis retrieval mechanism comes close implementing classification scheme expected feature sets derived 61 63 specifications failed classification due use three way conditional specification supported directly domain theory domain theory could extended support conditionals however effort made overspecialize domain theory toward supporting classification application therefore extension made distribution expected feature sets library show table 2 shows classification scheme questionable job clustering components library nearly half components assigned filter feature fact 3 features independent represent generalization hierarchy route permute filter useful features specialize features would also useful orthogonal features provide better coverage library table 2 distribution feature sets initial classification scheme feature set specifications components ffilterg sometotal lasttotal12 tail13 swap idsegment idfront runmaxeq segmentnetotal id segmentfront idsingle segment swapouter swapoutertotal swaptotal permr12 runmaxbracket runeq123 runbracket12 leadtotal12 lead segmentrear segmentne permlr12 idnil elimduplr rotr12 rotrtotal123 rotltotal123 rotatetotal rotate rotl12 tailtotal12 elimdupuniquel elimdupr last head13 idrear elimdupuniquer perml12 elimdupl nodup elimdupuniquelr filter figure 9 lattice specifications list component library partialorder lattice induced satisfies match library useful aid discovering potential features lattice shown figure 9 areas covered filter permute route features shown dashed lines hoped features tend group components related lattice lattice used identify groups components closely related specifications may inspected identify logical feature share 3 example component root tree containing last head total last total head total component following specification post existsirec mem1 mem2 specification similar definition select feature select looks element output singleton list therefore definition select modified identify singleton list expected feature components useful feature identified using lattice example associating feature id nil component descendants provides coverage id segment tree also divides components filter feature roughly half fairly orthogonal manner complementary feature idnil feature nonil could defined stating component accept empty input intention component could imply features three features formalized follows added feature definitions experiment rerun inspection derived feature sets immediately obvious two problems 1 feature never derived 2 many components assigned idnil nonil intention scheme source first problem proof tactic failed handle existential goals problem solved extending tactic attempt solve goal substituting free variables goal existential variable additionally expected results wrong defined feature hold total descendants components named total total functions map empty input list empty output list case output contain element therefore specifications imply feature second problem extended scheme idnil nonil complementary thought fact nonil implies idnil case input empty assuming empty first step proving idnil allows proof idnil succeed trivially results coverage idnil feature nearly identical filter feature making useless extension taken together experiences indicate need tools support construction classification schemes discussed future work section table 3 distribution feature sets extended classification scheme feature set specifications components table 4 retrieval satisfies match using extended scheme scenario retrieved precision recall signature match 6300 63 63 011 002 064 100 100 100 expected features exact match 1364 1 23 relaxed match derived features exact match 1405 3 23 029 004 100 069 005 100 relaxed match 4357 12 51 012 002 065 086 010 100 table 5 approximate retrieval using initial classification scheme scenario retrieved precision recall signature match 6300 63 63 014 002 081 100 100 100 expected features exact match 2271 3 31 027 003 100 084 006 100 relaxed match derived features exact match 2227 3 31 028 003 100 081 006 100 relaxed match 4357 12 51 016 002 096 085 007 100 experiment run time without idnil feature expected results throughly evaluated distribution feature sets shown table 3 extended scheme better job breaking components clusters nearly 13 components initially assigned filter feature assigned additional features results evaluating system extended classification scheme shown table 4 compared results previous classification scheme noticeable drop average number components retrieved along increase precision accompanied slight decrease recall classification mechanism came close implementing classification scheme 652 approximate retrieval experiments repeated considering relevant component one matches query specification respect reuse matches identified section 3 relevance condition logically weaker satisfies match disjunction satisfies weak post relevant components query superset relevant satisfies table 6 approximate retrieval using extended scheme scenario retrieved precision recall signature match 6300 63 63 014 002 083 100 100 100 expected features exact match 1497 1 25 032 004 100 057 004 100 relaxed match derived features exact match 1405 3 23 031 004 100 054 006 100 relaxed match 4357 12 51 016 002 096 084 007 100 results experiment using initial classification scheme shown table 5 precision experiment higher retrieved components relevant recall remained indicating percentage new relevant components retrieved implementation classification scheme continues come close performance complete consistent implementation results experiment using extended classification scheme shown table 6 exact match increase precision initial scheme comparable increase seen satisfies match experiment however larger drop recall caused exact match retrieving many new relevant components means exact feature match using extended scheme approximate relevance condition well terms recall relaxed match results remain consistent experiments results indicate relaxed feature match appropriate approximate retrieval exact feature match 653 response time response time classification system experiments ranged 015 066 seconds average 035 seconds 200mhz pentiumpro processor running linux database access accounted 0025 seconds average therefore bulk time spent classifying queries well within acceptable response time interactive system 7 comparison results 71 specificationbased retrieval specificationbased component retrieval systems proof concept stage therefore evaluated sizable component library notable exception norahammr system fischer schumann 37 norahammr retrieval system set chain filters initial filter signature matching become restrictive progress final filter chain full scale specification matching norahammr system evaluated using library experiments using specifications duplicates query set intermediate filter use mace model checker several configurations select subset components library undergo specification matching using 20 second time limit model checking computation observed average recall rates 747 813 precision 185 165 comparable results achieved initial classification scheme experiments however response time 066 seconds worst case experimented several automated theorem provers specification matching final stage retrieval example using setheo prover time limit 20 seconds results recall rate 612 precision 100 high precision due fact setheos proof procedure sound loss recall due lack completeness comes technique approximating induction restricting set axioms available inference 20 second time limit lowering time limit 1 second causes recall drop 50 6 using semantic classification filter prior specification matching could reduce load specification matching allow time limit raised increasing recall 72 information retrieval methods majority component retrieval tools used practice based information retrieval methods frakes pole conducted extensive study representation methods reusable components 8 comparison retrieval performance attributevalue enumerated faceted keyword based representations relevance determination made two domain experts mention manual method used classify components recall precision measurements 3040 50100 ranges respectively methods statistical analysis showed significant difference among methods retrieval results consistent numbers benefit semantic classification provides methods consistency automation classification process uses familiar specification language familiar organization component library addition specificationbased retrieval provides precise relationship exists retrieved component query increasing utility retrieval results achieved similar performance results girardi ibrahim 10 11 evaluate method based syntactic semantic analysis natural language descriptions rosa use normalized versions precision recall formulas system returns ranked results used library 418 general purpose unix commands 20 queries derived user descriptions frequently used commands report recall values 99100 range precision values 9092 range however state relevance condition making results rather noninformative selection query set also important evaluate method less frequent cases 8 discussion 81 system wide effects retrieval performance semantic classification must considered context role retrieval system results retrieval passed evaluation phase based specification matching perfect precision recall assuming sound complete proof procedure used point relevant components cannot added removed specification matching means semantic classification acts filter sets upper bound recall combined retrievalevaluation system limiting recall shrink design space searched potentially lowering quality designs created system contrast precision retrieval phase effect precision combined system precision effects number proofs must attempted specification matching therefore effect system response time therefore recallprecision tradeoff featurebased retrieval phase translates design qualityresponse time tradeoff context entire retrieval system 82 limitations experiments major reason feature generation failure due specification broken cases based conditions supported rules domain theory specifications postcondition form prove feature implied specification form requires proof cases approach facilitate must axiom domain theory form rules domain theory support specific case decomposition used specification feature proofs cannot succeed fixed either guiding user specification use set conditions supported domain theory allowing conditional features assigned feature holds rather conditions specified feature derivation runs similar problem case partial specifications component behavior defined legal inputs feature assigned component derived terms behavior component every legal input value partial specifications logically weak allow feature derived case undefined behavior fixed 1 disallowing partial specifications 2 strengthening postcondition purposes feature generation 3 allowing conditional features described also problem two components specified way specifications cause nontermination rewriting example head component input l output specified statement used lefttoright rewrite rule rewriting system terminate one possible solution build timeout option rewriting system similar used schuman fischer 37 finally noted general specificationbased component retrieval susceptible loss recall due semantic gap component specification 22 component associated specification component correctly implements specification however gap query may fall possible component may satisfy query specification satisfy effects situation cannot evaluated experiments working specifications however noted potential limitation method 83 building classification schemes discovering features easy process formalizing abstract concept shared among several components difficult picking collection useful ones even harder several times investigation intuitive concept feature disproved system recognizing utility hierarchical complementary features good start toward building better schemes however tool support would necessary scale method larger libraries sophisticated classification schemes several ways formalized classification framework provides foundation automated tools formal definitions necessary conditions support analysis scheme example set features proven mutually exclusive disjunction tautology therefore every component would assigned exactly one features features would provide coverage similar facets faceted classification 34 also possible provide support extending classification schemes within framework example two distinguishable components classified identically may possible identify parts specifications distinguishable automatically derive new feature represents difference 84 signatures vs semantics specificationbased component retrieval systems first filter used reduce library signature matching 7 43 44 signature matching uses types components interface determine compatibility query guiding assumption types match reason examine components behavior believe two cases semantic classification potential greater recall signaturebased approaches retrieval performance signature matching degrades considering relevant components could combined adapted satisfy query standard signature matching eliminate relevant components partial matches interface allowing partial matches would allow many component match greatly decreasing retrieval precision signature matching feature definitions required constrain inputs outputs component semantic classification problem fact components retrieved provide slices appropriate behavior independent type used type information feature values used identify type substitutions evaluation using signatures suggested discover combinations components library match query signature 15 23 take semantic approach problem combining components 28 29 classification assists approach retrieving components provide pieces appropriate behavior therefore locate partial solutions even remainder solution library 9 related work use formal specifications assist software component retrieval widely proposed projects 3 37 16 21 4 zaremski wing 45 provided foundation studying general activity specification matching verification logical relationships specifications many approaches making specificationbased component retrieval efficient however methods make use semantics provided formal specifications norahammr deductive retrieval tool built fischer schumann uses series filters identify reusable components 37 tool novel use model checking one search filters running theorem prover check match condition conditions checked searching model small part specification theory since necessary model exist conditions hold components pass model checking stage need checked entire theory also use various techniques improve performance theorem prover specification matching reducing set axioms used parallel proof attempts evaluation prototype implementations libraries list manipulation functions showed encouraging results however recall retrieved componentsuseful components prototype limited signature matching notion using filters restrict search space consistent use necessary conditions eliminate nonmatching component semanticbased classification scheme provide better recall signature matching could used preliminary filter potentially increase recall inquire retrieval mechanism 32 within inscape 31 environment supports retrieval based component specifications preconditions postconditions components formulated terms given set formally defined logical predicates inference mechanism used retrieval process retrieve components provide various predicates formal predicate definitions useful unambiguous descriptions predicate vocabulary prototype implementation reported work well restricted specification language restricted language reduces inference power necessary component retrieval methodology presented uses reversed approach inscape interface specifications defined full firstorder logic formally defined features predicates assigned specifications logically implied specification case predicates complete specification component represent various aspects components function feature predicates useful specification predicates abstract allowing flexibility types similarity represented addition expressive specification language allows precise evaluation reusability deductive program synthesis 20 40 also makes use formal methods automate software reuse example amphion system 18 41 successfully uses deductive synthesis construct software subroutine library solar system geometry systems components language primitives sub routines represented mathematical functions behavior specified via axioms program synthesized proving valid input exists output satisfies specification occurrence primitive function proof constructed deductive synthesis corresponds call associated subroutine therefore component effectively retrieved corresponding axioms used proof process means domain theory axioms tactics used decomposing proofs determine components used ongoing research exploring integration architectural decomposition tactics current component retrieval system support automated component adaptation integration 28 29 30 10 conclusion software reuse formal specification two methodologies show high potential impact software productivity reliability used together permit increased automation assurance reuse process presented component reusability similarity described formally logical relationships problem specification component specification however computationally expensive formally verify relationships quantities required practical component retrieval therefore specificationbased retrieval would benefit method approximate relationships identify subset library undergo verification paper described method classifying components based formal specifications features assigned components based specific necessary conditions implied component specifications logical form specification matches determining reusability ensures components similar feature sets likely match collection necessary conditions controls classification scheme defined formally allow automated classification theorem proving required classification applied way complexity component classification much less applying multiple specification matches classified components retrieved via syntactic comparison feature sets results empirical evaluation library list components show method provide retrieval performance comparable existing methods benefits faster response time formal approaches method improves upon informal methods providing higher levels consistency automation future work focus integrating specificationbased component retrieval support automated component adaptation integration 28 longterm goal develop support runtime component integration highassurance componentbased systems 19 also investigating tools support development maintenance formal classification schemes acknowledgments would like thank bernd fischer gary leavens amy moormann zaremski ali mili santos lazzeri dale martin helpful comments development evaluation research also thank anonymous reviewers current earlier versions work suggestions presentation evaluation work support work provided part advanced research projects agency monitored wright labs raasp technology program contract number f33615 93c1316 ceenss technology program contract number f3361593c4304 notes 1 use zaremski wings method identifying reuse matches based syntactic patterns select matches based formalization intuitive notions reusability utility component retrieval 2 opposed free text indexing source code andor comments would satisfy high level assurance required application 3 noted distances lattice meaningless lattice arranged hand minimize crossing links 4 general overview component retrieval methods assisting software reuse see survey mili et al 23 r validating component compositions software system generators perlis editors software reusability concepts models program development formal activity two theses knowledge representation languages restrictions norahammr making deductionbased software component retrieval practical empirical study representation methods reusable software components formal foundations specification software architecture automatic indexing software artifacts using english retrieve software hol proof generating system higherorder logic science programming languages tools formal specification generalized behaviorbased retrieval using formal methods construct software library formal approach domainoriented software design environments fundamentals deductive program synthesis refinement based system survey software reuse libraries reusing software issues research directions another nail coffin facated controlledvocabulary component classification retrieval definition standard ml correct architecture refinement automated component retrieval adaptation using formal specifications toward automated component adaptation declarative specification software architectures inscape environment ruben prieto ruben prieto specifications search keys software libraries automated deduction formal methods norahammr making deductionbased software component retrieval practical software architecture perspectives emerging discipline derived preconditions use program synthesis deductive composition astronomical software subroutine libraries algebraic specifications software engineering introduction signature specification matching signature matching specification matching software components tr ctr david hemer semiautomated componentbased development formally verified software electronic notes theoretical computer science entcs 187 p173188 july 2007 robert g bartholet david c brogan paul f reynolds jr computational complexity component selection simulation reuse proceedings 37th conference winter simulation december 0407 2005 orlando florida sofien khemakhem khalil drira mohamed jmaiel sec search engine component based software development proceedings 2006 acm symposium applied computing april 2327 2006 dijon france brandon morel perry alexander spartacas automating component reuse adaptation ieee transactions software engineering v30 n9 p587600 september 2004
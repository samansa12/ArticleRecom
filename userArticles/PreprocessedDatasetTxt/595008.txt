constraint programming framework local search methods propose paper novel integration local search algorithms within constraint programming framework combinatorial optimization problems attempt gain efficiency local search methods flexibility constraint programming maintaining clear separation constraints problem actual search procedure neighborhood exploration performed branchandbound search whose potential pruning capabilities open door elaborate local moves could lead even better approximate results two illustrations framework provided including computational results traveling salesman problem time windows results indicate one order magnitude faster customary constraint programming approach local search competitive specialized local search algorithm b introduction local search methods operations research date back thirty years ago 13 applied difficult combinatorial optimization problems heuristic approach yields highquality solutions iteratively considering small modifications called local moves good solution hope finding better one embedded metaheuristics designed escape local optima simulated annealing tabu search successful achieving nearoptimal sometimes optimal solutions variety hard problems 8231 constraint programming cp features flexible modeling capabilities easily closely reflect various constraints problem solving reallife combinatorial optimization problems date almost invariably adopted branch andbound strategy global therefore complete search method 1 exact algorithm proves costly simple approximate algorithms often devised heuristically discarding leastpromising branches branchandbound search tree form beam search preliminary version paper appeared 18 constraint programming bring local search methods fact heuristics tend specialized particular context become drawback faced even slightly different context side constraints adapting may demand considerable time effort therefore tempting gain efficiency local search methods flexibility constraint programming paper argue local search foreign branch andbound search constraints actively involved exploration local search spaces propose clean integration local search constraint programming keeping comes naturally ie branch andbound different search space though related original one contrast practice resulting framework maintains clear separation constraints problem actual search procedure cp potential pruning capabilities open door elaborate local moves could lead even better approximate results adaptation local search constraint programming paradigm stems perception generalization conventional cp branchandbound search latter case branch variables model neighborhood degenerates whole solution space single iteration becomes sufficient since optimal solution necessarily found order lift approach local search art consists choosing representation particular neighborhood structure cp branchandbound search exploit iteration local search simply branchandbound search different search space active role modeling constraints discarding infeasible neighbors together lower bounds cost partial solutions discarding unattractive neighbors help prune tree thus reduce search effort whole neighborhood rest paper organized follows section 1 first gives overview local search methods constraint programming general framework local search cp presented section 2 implementation framework illustrated personnel scheduling section 3 singlevehicle routing section problems empirical study included latter type application finally address flexibility offered framework section 5 1 background 11 local search methods operations research local search methods involve repeatedly going one solution another local move constitutes valid local move varies according problem even within see example section 41 set solutions reachable solution local move termed neighborhood set feasible solutions neighborhood called feasible neighborhood given framework simple strategy called iterative improvement moves best feasible neighbor ie lowest cost every time improve current solution reaching local optimum several ways alleviating obvious drawback strategy proposed multistart iterative improvement achieves local optima pool solutions returns best one genetic local search builds upon previous recombining local optima fashion genetic algorithms 10 applying iterative improvement discarding leastpromising solutions repeating process stopping criterion satisfied two successful strategies try escape local optima allowing moves temporarily increase cost solution tabu search 7 moves best neighbor iteration regardless whether improves current solution avoid cycling dynamic list tabu solution attributes kept typi cally list covers recently examined solutions remain forbidden certain number iterations simulated annealing 12 randomly selects neighbor iteration improves current solution move performed otherwise performed certain probability depends cost difference also decreases time according cooling schedule strategies iterate stopping criterion satisfied one crucial aspect local search methods obviously choice neighborhood structure see example 9 ambitious neighborhoods increase chances success expensive explore methods need small neighborhoods simple fast explore may prevent us ever reaching particularly good solution could require sequence local moves opposed single one larger neighborhood every move would one selected iteration neighborhood strictly includes another induces search encounters fewer local optima thus facilitates avoidance large neighborhoods attractive several techniques developed speed exploration size neighborhood somewhat reduced either ignoring parts unlikely produce good solutions exact fashion interrupting carefully engineered exploration remainder lead worse infeasible solutions addition feasibility neighbors must assessed early example routing problems 24 describes way verify timewindow constraints constant time per neighbor though assumptions neighborhood structure must made others may perform approximate tests feasibility quickly identify promising neighbors thoroughly investigated potential risk missing best one challenge expressive neighborhoods met specialized techniques embedded local search sometimes compromises 12 constraint programming constraint programming solves combinatorial problems actively using constraints problem implicitly eliminate infeasible regions solution space algorithm heart approach implements complex logical reasoning set constraints every variable cp model associated domain value domain represents possible value variable constraints variables forbid certain combinations values picturing model network whose vertices variables whose hyperedges constraints provides insight basic algorithm used cp vertex labeled set values domain corresponding variable edge incident vertices representing variables appearing associated constraint looking locally particular edge constraint algorithm attempts modify label reduce domain incident vertices variables removing values cannot part solution would violate individual constraint local consistency step performed efficiently modification vertexs label triggers inspection incident edges turn may modify labels recursive process stops either label modifications dealt empty label obtained case solution exists overall behavior called constraint propagation since constraint propagation may stop indeterminate variables ie whose domain still contains several values solution process requires search potentially exponential cost usually takes form tree search branching corresponds fixing variable value domain thus triggering constraint propagation call variableselection heuristic value selection heuristic way one decides variable branch value try first respectively combinatorial optimization problems tree search evolves branchandbound search one branches way lower bounds tree nodes obtained looking smallest value left domain cost variable 13 local search constraint programming saw branchandbound search far popular natural solution strategy constraint programming handle combinatorial optimization problems exceptions nevertheless found literature recent survey applications constraint programming 28 describes applications local search cp loosely connected latter used preprocessing step particular heuristic employed others offer tighter connection essentially consider individually possible moves neighborhood assess feasibility cost 2232 2 costly endeavor nature local moves great number possibilities must considered solve constraint satisfaction problems abound artificial intelligence repairbased methods eg 2515 good share success viewed local search methods typically consider small neighborhood changing value one variable use iterative improvement order minimize number violated constraints 2 new combination local search cp mentioned introduction view local search sequence cp branchandbound searches given combinatorial optimization problem p call master problem initial solution solve sequence auxiliary problems using standard constraint programming techniques p described constraint programming model whose role ensure feasibility solutions auxiliary problem described another constraint programming model called neighborhood model describes local search space two types models related interface constraints definition 1 neighborhood model let n denote neighborhood structure solutions combinatorial optimization problem p set finitedomain variables usually distinct variables appearing model p together possibly empty set constraints f neighborhood model n onetoone mapping set feasible combinations values f neighbors n example let p traveling salesman problem cities consider exchange two cities solution neighborhood structure n introduce variables j ranging interval 2 constraint j solution represented sequence cities forming tour particular feasible combination values fi jg interpreted exchanging entries c c j solution obtain neighbor one easily verifies constitutes neighborhood model requirement onetoone mapping could relaxed surjective mapping though would mean neighbor may examined without constraint j example symmetry would lead identical solutions however surjectivity crucial since otherwise would miss neighbors solution space defined neighborhood model explored standard cp branchandbound search branch f also bound cost partially constructed neighbors saw section 11 heuristic algorithms based local search tabu search variations iterative improvement interested acquiring best solution neighborhood hence require manipulate whole per se therefore record cost best neighbor found far derive lower bounds partial neighbors reduce portion neighborhood explored conventional branchandbound note prescribe order select variables branching accordance common practice constraint programming community dynamic variableselection valueselection heuristics may used increase efficiency search initially model master problem stated variables model constrained extent words bound current solution local search takes place form complete neighborhood model local move restricting neighbors fixing main constraint checking interface constraints figure 1 interaction master neighborhood models branchandbound search neighborhood model different stages branchandbound search valuable information exploited order restrict set allowable values neighborhoodmodel variables search performed importantly constrain well principal modeling variables master problem may independently prune search tree propagating changes modeling constraints need know anything see figure 1 automate behavior introducing set conditional constraints 3 called interface constraints definition 2 interface constraints interface constraint form stands subset variables model p adds constraint fixed set interface constraints establishes link model p neighborhood model variables latter model fixed branchandbound search constraints generated variables neighborhood model master problem reflecting fact narrowed search see two main advantages framework flexibility genericity modeling constraints p often kept separate neighborhood model provides flexible way state instancespecific constraints independently local search especially useful lots different side constraints present problem clutter local search explicit feasibility tests often case operations research heuristics rather indirectly involved modeling variables constrained interface constraints result branching end result generic neighborhood exploration method parameterized type neighborhood structure nature modeling constraints master problem table 1 availability physicians abcde aam ppm nnight mon tue wed thu fri pn ap n apn p c pn apn n search economy strong relationship savings brought branchandbound approach ambitious neighborhood typically enlarging neighborhood means increasing degrees freedom requires greater number variables encode structure translates greater depth neighborhood search tree potentially larger gain every branch pruned 4 either lower bound particular node modeling constraints constitutes asset view current trend toward ambitious neighborhood structures freedom choosing order variables fixed values tried also contributes gain hand course price pay flexibility namely cost constraint propagation builtin backtracking attempt empirically evaluate overall efficiency approach sections 44 45 3 introductory application physician scheduling first illustration general framework hospital ward must physician duty time consequently ward schedule established staff physicians expected rules governing construction valid schedule vary one hospital next describe one context day divided three shifts pm night night shift physician simply call planning horizon typically months several rules frequency shifts covered physician 1 one shift per day 2 two consecutive shifts example mondaynight tuesdayam 3 two consecutive night shifts physicians also duties elsewhere especially ones parttime status hand form specifying shifts available table 1 gives small example five physicians horizon five days two physicians share responsibility outside ward certain day may ask least one daytime duty day finally target workload number shifts assigned physician may vary according status good schedule remain close targets let planning horizon range day 1 n let set shifts assign schedule let md represent set physicians staff k set pairs hi ji physician k available j shift day r set pairs hfk k 0 g ii physicians k k 0 cannot daytime duty day natural model problem associates distinct variable every shift assigned constraints listed expressed follows order stand target workload physician k whereas ff k stands actual workload schedule adopt leastsquares objective function local move consist changing value one slot schedule let oe represent current schedule oehi ji physician currently covering j shift day neighboring schedule oe encoded variable representing slot modified variable v representing new value slot neighborhood model cost local move replacing physician k 0 k slot simplifies target workload physicians evaluating relative merit move simply amounts looking ff k gamma ff k 0 table 2 feasible schedule left optimal schedule right mon tue wed thu fri mon tue wed thu fri table 3 partial schedule choosing one possible completion right mon tue wed thu fri mon tue wed thu fri let ffxgg denote current domain finitedomain variable x introduce following interface constraints fixed slot ha bi conditional constraint 7 fills slots value current schedule since change conditional constraint 8 binds v ab thus restricting v possible values slot forbidding current value ab constraint neighborhood model v fixed physician k conditional constraints 9 10 maintain value slots cannot possibly change whose value k already cannot take value conditional constraint 11 restricts slots may admit value k example consider simple instance five physicians scheduling horizon five days physician availabilities given table 1 uniform target workload three shifts per physician addition physicians cannot daytime duty thursday neither b c wednesday table 2 gives feasible schedule works four shifts two yielding score 2 objective function investigate possible local moves schedule cp branchandbound search neighborhood model popular variable selection heuristic would us branch variable smallest domain first case would v far trying different values v makes sense order according lower bound relative merit possible local moves introducing value starting smallest bound value look ff gamma ff x similarly values get gamma1 gamma1 gamma2 gamma1 order therefore start examining illustrated search tree left figure 2 triggers constraints 911 first two partially filling schedule illustrated left table 3 entries shown bold result elaborate reasoning mere initial unavailability shift achieved constraint propagation example shift h3 nighti filled constraint 9 constraint 3 tells us shift h4 ami cannot filled well take current value constraint 10 cannot daytime duty thursday constraint 5 shift h4 pmi also take current value e domain made correspond unassigned shifts partial schedule fh1 nighti h2 pmig combined effect constraints 11 v 6 oes branching order two branches according lower bound though identical value leftmost branch brings us terminal node changing value slot h1 nighti relative merit gamma1 conditional constraint 7 fills rest schedule since relative merit score good lower bound unexplored branches search tree rest tree pruned done see figure 2left yielding schedule right table 3 actual cost move keeps objective function 2 iteration using strategy would produce search tree right figure 2 local move cost gamma2 bringing objective function 0 would therefore optimal schedule shown right table 2 overall modifications bold small example already sufficient bring forth two advantages stressed end section 2 exploring neighborhood first fixing v runs contrary would naturally come mind first choose slot modify pick new value nevertheless probably better strategy two since search trees generated tend sparse combination variableselection heuristic valueselection heuristic constraint propagation lowerbound pruning yields neighborhood exploration efficient terms number neighbors terminal nodes actually considered advantage generic local search flexibility handle instancespecific constraints mentioned type personnel scheduling problem rules game depend c e figure 2 neighborhood search trees first left second right iterations branch labels valuelower bound terminal nodes labeled relative merit move approach different hospital contexts reflected handled master model local search 4 routing application using tabu search section provides another instance general framework described section 2 addresses wellknown problem several local search heuristics applied past traveling salesman problem time windows tsptw consists finding minimum cost usually total travel distance total schedule time tour set cities city visited exactly starts ends unique depot addition city must visited within time window early arrival allowed implies waiting time beginning window 24 showed simply deciding whether exists feasible solution instance tsptw npcomplete nevertheless full problem important applications bank postal deliveries schoolbus routing scheduling disjunctive scheduling sequencedependent processing times automated manufacturing environments subproblem vehicle routing problem time windows vrptw constraint programming model master problem tsptw presented 19 sketch emphasizing main variables referred later let ng represent set cities visit duplicate unique depot origindepot destinationdepot identified 0 tour thus becomes hamiltonian path starting 0 ending n 1 heart model variables associated cities origindepot represent successor tour domain therefore integer range valid tour assigns distinct successor city avoids subtours also define predecessor variables counterpart account scheduling component problem variables introduced represent time visit city must take value within respective time window coherent order cities appear tour taking consideration travel time cities several redundant constraints also present increase amount propagation 41 neighborhoods routing problems given inherent difficulty problem several heuristic algorithms designed among based local search briefly describe popular neighborhoods context routing problems include tsptw may allow solutions consisting set routes involve restrictions capacity constraints neighborhoods generated modifications level vertices include reinserting vertex exchanging two vertices geni generalized insertion procedure 5 directs reinsertion p 2 7 nearest neighbors interchange 17 subsets vertices selected different route swapped possibility empty subset allows simply reinserting vertices efficiency reasons rarely exceeds 2 level edges kinterchange 13 replaces k edges solution k others reconnect routes linkernighan moves 14 tsp increase k gain criterion fails consider nearest neighbors vertices exchanges oropt move 16 relocates string one two three consecutive vertices 2opt move 21 replaces two edges v different routes edges v exchanges end portion one route end cross exchange 27 goes exchanging middle portion one route middle portion replacing four edges includes two previous types moves special cases 42 orientationpreserving 3interchange neighborhood consider orientationpreserving 3interchange neighborhood provide neighborhood model let current tour represents city tour successor respectively predecessor define following binary relation cities oe j holds appears j without loss generality let oe j oe k 3interchange move deletes three edges reconnects tour introducing three new ones vertices cities orientationpreserving 3interchange move reconnects tour possible way reverse original route segments adding edges figure 3 orientationpreserving 3interchange 3 desirable scheduling component present problem time windows two segments original route swapped ordering within segment kept neighborhood defined orientationpreserving 3interchange moves encoded three finitedomain variables j k ranging 0 n interpretation one given constraint oe j oe k neighbor onetoone correspondence 3tuple values describing therefore neighborhood model ng oe j oe k associating cost c ij every edge j cost local move given total cost arcs add minus total cost ones remove smallest possible value used lower bound refined automatically constraint propagation domains j k shrink ultimately single value interface constraints used branchandbound search refer figure 3 throughout conditional constraints 1215 deal information traveling neighborhood model box right figure 1 master model box left figure 12 example try value say know initial tour segment remain new tour appropriate successor variables routing model fixed 1315 respectively address tour segments hi unchanged neighboring tour conditional constraints 16 17 reflect fact fixed allows us constrain j k j must appear current tour successor new tour corresponding addition edge must predecessor new tour corresponding addition edge similarly 18 19 restrict k given value j 20 21 restrict j given value k turn information traveling master model neighborhood model successor predecessor variables constrained master model restrict possible values j k used identify potential arcs added removed neighboring tour suppose example variable ordering search tree j k throughout depth 1 fixed conditional constraints 12 16 17 triggered depth 2 j fixed 13 19 18 triggered first two useful since value already known finally depth 3 variables fixed 14 15 worth triggering saw p j master model j k variables neighborhood model involved interface note instance time variables directly involved example consider following example wish find good tour cities fb c e f gg starting ending h two copies depot aside usual constraints master model add two others c oe g feasible tour 6 g show instancespecific constraints taken account examining neighbors shall concentrate implicit pruning infeasible neighbors constraints leave unattractive neighbors lower bounds therefore ignore cost individual arcs exploration variableselection heuristic common smallestdomainfirst lexicographic order tie breaker let current tour ha b c e f initially branching variables j k domains indicated figure 4i equal size first branch root search tree five possible values b c e tried turn complete exploration neighborhood let us jump b considered figure 4ii several things happen c e f g b c e b c e f c f e c e f g b c e b c e f c f e c e b c e e e c f e e f c e b c f e e iiiiiiiv figure 4 exploring neighborhood ffl neighborhoodmodel constraint oe j oe k triggers removal value b domain j c domain k ffl conditional constraint 12 sets b initial tour segment ffl conditional constraint 16 enforces could reduce domain j depending possible values b ffl conditional constraint 17 enforces combined action instancespecific constraint c oe g removes g ks domain since g certainly part domain p c addition f removed js domain j oe k left three possible values j ks domain move fix j suppose try figure 4iii ffl neighborhoodmodel constraint j oe k triggers removal value domain k ffl conditional constraint 13 sets c current tour segment j ffl conditional constraint 19 enforces since 6 g given instancespecific constraint f removed ks domain finally fix k possible value e figure 4iv ffl conditional constraint 14 result variable assignment since tour segment consists single city e ffl conditional constraint 15 sets f g g h remaining tour segment 43 tabu search algorithm order evaluate efficiency issues related approach used previous neighborhood structure within tabu search algorithm aim twofold evaluate efficiency branchandbound search terms proportion neighborhood explicitly visited compare execution time conventional specialized tabu search algorithm objective measuring cost constraint propagation backtracking therefore leave ad hoc constraints remain strictly within reach specialized algorithm tsptw section describes specifics algorithms random tabu tag associated pair cities arc initially set zero move performed iteration three arcs replaced tour allowed brought back tour iteration integer randomly drawn interval 5 10 drawn separately arc tabu tag thus updated tabu status move determined examining tabu tags three arcs would bring tour unless tag less index current iteration move declared tabu however aspiration criterion included according move performed anyway cost improves cost best tour met far obtain initial feasible solution use nearsighted version generalized insertion heuristic genitw 6 run 100 iterations tabu search fixed number iterations serves stopping criterion simplifies comparisons next section two versions cp tabu search algorithm implemented coined full light differ extent master model used neither includes structural tsp constraints distinct successors subtour avoidance since nature move guarantees valid tour ignoring time windows full version uses rest model outlined beginning section 4 light version omits redundant constraints keeping necessary ensure timewindow compliance noncp specialized version departs two way neighborhood exploration carried three nested loops iterate whole neighborhood feasibility neighbor explicitly assessed without resorting constraint propagation finally passive cp version also proceeds nested loops uses constraint propagation light model verify feasibility neighbors represents popular approach combining cp local search indicated section 13 actively use constraints restrict part neighborhood must explored four implementations written c cp versions use ilog solver c library implementing constraint programming combinatorial problems 11 even share code seed generation random tabu tags four executions follow identical sequences moves given instance neighborhood exploration therefore variable example end previous section variableselection heuristic branchandbound search smallestdomainfirst tiebreaker frequently needed ie light version without lowerbound pruning reduces little domain branching variables found ordering k j performed significantly better lexicographic ordering advantage identifying early backward arc introduced move k likely cause timewindow violation value selection heuristic considered several strategies first attempt imitate done physician scheduling example order values according measure cost related moves value v domain inexpensive measure gammac vv cost one arcs replaced refinements minfc vsv proved better even worse simple lexicographic ordering bench marks possible explanation whereas physician scheduling example seemed likely selected branch search tree could extended feasible move likelihood doubtful hinted next section constrainedness indicator result may find feasible neighbor thus miss opportunities prune unattractive subtrees orientationpreserving 3interchange likely feasible swaps two short tour segments ie j k close tour lexicographic order successful initial solutions happened almost follow ordering lexicographic proximity synonymous proximity tour accordingly implemented simple valueselection heuristic favoring earliest v tour outperformed average previous strategies 44 experimental results experiments considered set euclidean problems travel times cities taken distance separating fact subproblems wellknown vrptw testbed 26 original problem instances feature 100 cities distributed 0 100 theta 0 100 grid require several vehicles service obeying side constraints partition cities group may visited single vehicle yields subproblems 25 used instances rc2 class features mixture clustered uniformly distributed cities requires vehicles yielding larger routes resulting size varies 20 42 cities addition execution time introduce two indicators analyze results jfeasible neighborhoodj jneighborhoodj theta 100 table 4 constrainedness fl search effort ffl several treesearch strategies problem fl fflfull ffllight pruning pruning pruning pruning rc203 34 364 129 402 771 208 740 rc204 101 545 116 722 943 127 884 rc206 11 179 83 171 314 141 347 rc207 25 364 111 371 616 133 589 rc208 41 643 188 797 1000 173 934 indicate constrained problem instance evaluating given solution proportion neighbors feasible jsearchtree leavesj jneighborhoodj theta 100 measure effort put neighborhood exploration comparing size search tree size neighborhood fl ffl expressed percentages table 4 evaluates fl ffl benchmark problems versions explore neighborhood tree search instances aggregated according original vrptw instances rc201 rc208 since tend similar timewindow characteristics entry thus represents average 2 4 tsptw instances averaged 100 iterations tabu search second column gives percentage feasible neighbors following two groups three columns search effort full light version respectively within group column left reports plain tree search whose pruning comes constraint propagation lower bounds cost tree nodes middle column reflects addition lowerbound pruning tree search obtain branchandbound leave column right first observation practically instances exhibit constrained neighborhoods solutions considered fl averages 33 even rc204 meaningful time windows average fl 101 avoiding systematic exploration whole neighborhood therefore appears advantageous looking search effort plain tree search full version performs much better light one examining roughly half number leaves expected powerful propagation ends producing smaller ffls also slows exploration see table 5 gap search effort narrows branch andbound search lowerbound pruning common versions significant impact impact striking look difference plain tree search branchandbound search within version particularly light one variation search effort eight groups instances especially visible column six rely time windows table 5 computation times cpu seconds sun sparc 10 several treesearch strategies problem full light pruning pruning pruning pruning rc206 40652 34884 45380 2820 17679 3234 rc207 85322 51035 89336 5244 29367 6863 rc208 404444 94542 285426 9643 34757 16639 pruning reflects variation typical timewindow width groups instances aspiration criterion included tabu search algorithm prevents missing best solution found far simply move leading tabu hand requires evaluating every tabu move treesearch setting knowing internal node tabu arc involved implies every move node necessarily tabu disregarding aspiration criterion could allow pruning whole subtrees tabu moves investigated call tabu pruning time one branching variables fixed value v thus identifying break current tour tabu pruning eliminates tabu arcs two sets candidates fv w reconnect break translates removing possible values remaining branching variables columns five eight table 4 report result adding tabu pruning plain tree search without lowerbound pruning often lowers search effort though necessarily example rc208 column five rc206 last column since affects variableselection heuristic topology search tree table 5 organized previous table gives computation times turning first full version see addition lowerbound pruning significantly reduce computation time hinted reduction search effort previous table usefulness tabu pruning proven may decrease increase computation time depending instance tabu pruning also change best solution found tabu search algorithm six 25 benchmark problems showed increase solution cost ranging 01 15 hand one problem showed decrease 19 clear large powerful constraint model several redundant constraints designed standard branchandbound exact global search algorithm mind appropriate local search indeed figures light version show marked improvement one plain tree search translates decrease area one order magnitude comes surprise addition lowerbound pruning significantly hampers efficiency despite great contribution reducing search effort table 6 computation times cpu seconds sun sparc 10 four implementations tabu search benchmark problems comparative ratios problem noncp passive cp ratio light ratio light ratio passive plain plain rc204 304 26154 860 14127 465 1601 53 rc206 486 14587 300 2820 58 1088 22 rc207 522 25953 497 5244 100 1038 20 rc208 609 19932 327 9643 158 1347 22 average 405 162 40 runtime statistics reveal amount backtracking information maintained branchandbound 10 times amount plain tree search sharp drop efficiency apparently due repeated storage retrieval information major factor full version extra amount backtracking information added already significant amount associated full constraint model tabu pruning generally increases computation time attractive lightweight version setback lowerbound pruning prompted us implement explicit computation lower bounds tree nodes instead relying constraint propagation cost variable subsequently refer implementation lowerbound pruning improvement speed astonishing see next table table 6 compares computation time four tabu search implementations column two represents specialized version faster expected next comes computation time passive cp version followed comparison specialized version passive cp noncp ratio reflects sole cost constraint propagation averaging 405 two groups two columns represent lightplain lightplain lowerbound pruning versions ratios taken respect noncp version ratios lightplain combination indicate profitable proceed tree search instead systematically considering every neighbor passive cp tempering cost constraint propagation elimination subtrees neighbors yields average ratio 162 lightplain combination thus 25 times faster passive cp even outperforms latter rc208 elimination neighbors speak see table 4 triggering interface constraints various levels tree corresponds factoring common constraint propagation fragments among subsets neighbors lowerbound pruning implementation brings savings observed search effort average four times faster plain tree search ten times faster passive cp also comes within factor four specialized version figure 5 performance ratio larger neighborhood search trees1357 cpu time ratio nb cities 3interchange 4interchange experimental results clearly indicate superiority approach passive use constraint propagation local search unfortunately cost constraint propagation builtin backtracking still prevented us competitive specialized version instances therefore decided investigate larger neighborhood search trees order increase natural payoff branchandbound pruning done two ways increasing size instances number cities affects breadth neighborhood search tree considering 4interchanges instead 3interchanges increases depth search tree one previous instances fell range 2040 cities considered 20 40 60 80city instances taken 4 additional results summarized figure 5 plots ratio execution time final approach light lowerbound pruning specialized version 3 4 interchange neighborhood structures increasing problem size point average dozen instances varying time window width expected relative performance improves growth search tree especially 20 40 cities note results consistent average value variability ratios previously reported table 6 different instances 3interchanges average ratio falls 15 80 cities note particular 4interchanges drops one starting 60 cities thus perform better specialized version point even though 4interchange seldom used practice neighborhood search tree depth four would uncommon already mentioned cross exchange routing physician scheduling application section 3 changing value two slots time instead one plausible neighborhood structure would also correspond depth four 45 applying framework genius heuristic combination wellknown tsp heuristic genius 5 constraint programming routing model sketched beginning section described 20 though heuristic composed tour construction phase postoptimization phase strictly speaking local search algorithm two phases involves exploration neighborhood similar used earlier therefore good candidate framework resulting algorithm geniuscp able solve variations tsp single multiple time windows precedence constraints sequencing constraints pickup delivery problems simply adding appropriate constraints master model without modification algorithmic part genius contrast subsequent version original heuristic handle single time win dows geniustw 6 required major changes addition backtracking capabilities specialpurpose code verify feasibility adjustments algorithmic control reflect temporal flavor problem comparison geniuscp geniustw benchmark problems single time windows revealed flexibility approach cost us factor four speed 5 former often found best solution whenever solutions differed variations tsp specialized heuristic based genius existed compared close relative side family exact cp algorithm using routing model confirmed geniuscp robust several orders magnitude faster heuristic solutions obtained also often optimal generally good 5 addressing flexibility previous section provided evidence search economy achieved framework report geniuscp also displayed flexibility would like briefly return latter advantage root flexibility separation constraints problem declarative part heuristic search strategy algorithmic part particular heuristic search strategy serve different contexts without modification implementation approach presents clear advantages software engineering point view since one needs adapt model problem makes much easier faster tailor piece software reallife situations reusing algorithmic component also impact maintainability code especially additional constraints suddenly arise situation noncp approach would either modify way valid neighbors generated add feasibility tests reflect additional constraints solutions alter algorithmic component contrast cp approach add required constraints declarative component model often simply amounts expressing using variables already present model standard constraints example give constraints expression context section 4 sequencing constraints city j must visited last must immediately follow city precedence constraints city j must visited city multiple time windows city may visited 9am 5pm noon 1pm adaptation program would thus consist one additional line code per new constraint leaving rest unchanged conclusion proposed novel framework local search algorithms constraint pro gramming maintaining branchandbound search core believe cleaner natural integration achieved addition familiar pruning take place yields substantial savings number neighbors actually need considered major advantage bringing constraint programming local search methods flexibility ease additional constraints handled two examples framework given physician scheduling singlevehicle routing computational experiments latter provided estimate price constraint programming setting showed framework outperforms simpler passive use constraint propagation local search competitive specialized noncp local search algorithm also stressed lightweight master model may preferable standard branchandbound approach comes computational cost may outweigh benefit case explicit computation lower bounds proved much efficient tabu algorithm tailored optimized particular context expected perform better experimentation suggests given large enough neighborhood inordinately large implementation framework may run faster initial cost using constraint propagation turn profit combined branchandbound exploration neighborhood search space small percentage feasible neighbors encountered even proportion truly constraining time windows small indicates worth investing elimination infeasible subsets neighborhood ambitious study different especially larger neighborhoods well different combinatorial problems could serve strengthen previous claim also identify possible settings full version tabu pruning may advantageous acknowledgments financial support research provided natural sciences engineering research council canada nserc notes 1 though incomplete search methods successfully introduced constraint satisfaction community 2 neighborhood shuffle moves 2 explored tree search guided constraint propagation lies one step closer approach 3 conditional constraint p q enforces consequent q antecedent p verified use syntax var value antecedent mean verified variable var fixed value 4 granted tree remains relatively shallow potentially bushy 5 version geniuscp equipped lowerbound pruning improvement described 20 r local search combinatorial optimization disjunctive scheduling task intervals constraint logic programming approach vehiclefleet scheduling problem new insertion postoptimization procedures traveling salesman problem generalized insertion heuristic traveling salesman problem time windows heuristic integer programming using surrogate constraints e taillard de werra users guide tabu search adaptation natural artificial systems computer solutions traveling salesman problem effective heuristic algorithm traveling salesman problem solving largescale constraint satisfaction scheduling problems using heuristic repair method traveling salesmantype combinatorial problems relation logistics regional blood banking metastrategy simulated annealing tabu search algorithms vehicle routing problem view local search constraint programming exact constraint logic programming algorithm traveling salesman problem time windows geniuscp generic vehicle routing algorithm exchange heuristic routing problems time windows modern heuristic techniques combinatorial problems local search routing problems time windows new method solving hard satisfiability problems algorithms vehicle routing scheduling problem time window constraints practical applications constraint programming tr ctr michel gendreau constraint programming operations research comments operations researcher journal heuristics v8 n1 p1924 january 2002 louismartin rousseau michel gendreau gilles pesant using constraintbased operators solve vehicle routing problem time windows journal heuristics v8 n1 p4358 january 2002 simon de givry laurent jeannin unified framework partial hybrid search methods constraint programming computers operations research v33 n10 p28052833 october 2006 samir loudni patrice boizumault philippe david online resources allocation atm networks rerouting computers operations research v33 n10 p28912917 october 2006 christian blum andrea roli metaheuristics combinatorial optimization overview conceptual comparison acm computing surveys csur v35 n3 p268308 september lucas bordeaux youssef hamadi lintao zhang propositional satisfiability constraint programming comparative survey acm computing surveys csur v38 n4 p12es 2006
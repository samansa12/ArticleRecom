reducing virtual call overheads java vm justintime compiler java objectoriented language uses virtual methods support extension reuse classes unfortunately virtual method calls affect performance thus require efficient implementation especially justintime jit compilation done inline caches type feedback solutions used compilers dynamicallytyped objectoriented languages self 1 2 3 virtual call overheads much critical performance java inline cache virtual call would otherwise translated indirect jump two loads translated simpler direct jump single compare type feedback combined adaptive compilation virtual methods inlined using checking code verifies target method equal inlined onethis paper evaluates performance impact techniques actual java virtual machine new open source java vm jit compiler called latte 4 also discuss engineering issues implementing techniquesour experimental results specjvm98 benchhmarks indicate monomoprhic inline caches polymorphic inline caches achieve speedup much geometric mean 3 9 respectively type feedback cannot improve polymorphic inline caches even degrades performance programs b introduction java recently created objectoriented programming language 5 objectoriented programming language supports virtual methods allow different code executed objects dierent types call virtual method calls java incur performance penalty target calls determined runtime based actual type objects requiring runtime type resolution exam ple extra code needs generated justintime jit compiler many java jit compilers like kae 6 cacao 7 latte 8 virtual method call translated sequence loads followed indirect jump rather direct jump static method calls dynamicallytyped objectoriented languages self however virtual calls cannot implemented using simple sequences loads followed indirect jump like java 1 furthermore virtual calls much frequent java two aggressive techniques employed reduce virtual call overheads inline caches type feedback techniques virtual method call translated simpler sequence compare direct jump even inlined type checking code although techniques certainly applicable java little known performance impact since virtual method calls less frequent less costly java techniques involve additional translation overhead important evaluate technques separately since results self may apply paper evaluates techniques actual java jit compiler compiler included open source java virtual machine called although implementation techniques straightforward trade os optimization opportunities want discuss paper also provide detailed analysis performance impact java programs rest paper organized follows chapter reviews method calls java summarizes virtual method call mechanism used jvm chapter 3 describes implemented inline caches type feedback latte chapter 4 shows experimental results related work described section 5 summary follows section 6 background 21 method invocation java java programming language provides two types methods instance methods class methods 9 class method invoked based class declared via invokestatic bound statically jit compiler knows method invoked compile time instance method hand always invoked respect object sometimes called receiver via invokevirtual actual type object known runtime ie bound dynamically jit compiler cannot generally determine target compile time instance methods bound statically though examples nal methods private meth ods methods nal classes instance methods called invokespecial bytecode eg instance methods special handling superclass pri vate instance initialization 9 generally method invocation incurs overheads creating new activation record passing ar guments case dynamic binding additional overhead nding target method called method dispatching head 22 latte jit compiler virtual method table latte virtual machine able execute java bytecode includes novel jit compiler targeted risc machines specically ul trasparc jit compiler generates code good quality clever mapping java stack operands registers negligible overhead 8 also performs traditional optimizations common subexpression elimination loop invariant code motion additionally runtime components latte including thread synchronization 10 exception handling 11 garbage collection 12 optimized result performance latte competitive suns hotspot 13 suns jdk 12 production release 14 maintains virtual method table vmt loaded class table contains start address method dened class inherited superclass due use single inheritance java start address method placed oset n virtual method table class also placed oset n virtual method tables subclasses class consequently oset n translationtime constant since object includes pointer method table corresponding class virtual method invocation translated indirect function call two loads load virtual table indexing table obtain start ad dress indirect call staticallybound method calls latte generates direct jump call site inlines target method unless bytecode size huge invocation overhead would negligible inlining depth large prevent recursive calls inlined innitely 3 inline caches type feedback section review techniques inline caches type feedback describe implemen tations use example class hierarchy figure 1 throughout section classes b c subclasses additional eld well one inherited class class b inherits method getfield1 class class c overrides assembly code section sparc assembly class int field1 int getfield1 return field1 class b extends int field2 int getfield2 return field2 class c extends int field3 int getfield1 return 0 int getfield3 return field3 figure 1 example class hierachy 31 inline caches 311 monomorphic inline caches jit compiler translates objgetfield1 figure 2a cannot know version getfield1 actually called obj object class c well class b even class c exist jit compiler cannot sure whether getfield1 called class c dynamically loaded later vmt call translated sequence loadloadindirect jump shown figure 2b index means oset vmt denotes translationtime constant void dummy o0 contains object obj ld o0 g1 indexing vmt ld g1index g1 b figure 2 example virtual call java corresponding vmt sequences inline cache totally dierent method dispatching mechanism inlines address last dispatched method call site figure 3a shows translated code using monomorphic inline cache mic call site jumps system lookup routine called method dispatcher via stub stub code sets register g1 index thus method dispatcher determine called method called empty inline cache history target method yet call executed rst time method dispatcher nds target method based type receiver translates translated yet updates call site point translated method prepended type checking code 1 figure 3b shows state inline cache rst encountered receiver object class inline cache includes history one method invocation target method detailed type checking code shown gure 4 call trampolinecode mov o7 g2 mov indix g1 trampoline code translated method methoddispatcher call dispatcher translated method failhandler typechecking code bne failhandler cmp g2 avmt ld o0 g2 empty inline cache b monomorphic inline cache call agetfield1 figure 3 monomorphic inline caches receiver dierent type encoun tered state inline cache change receiver encountered fail handler operates like method dispatcher nd target method translate translated yet update call site 312 polymorphic inline caches polymorphic inline cache pic diers mic dealing failure type checking instead updating call site repeatedly creates pic stub code makes call site point stub code pic stub code composed sequence com pare branch direct jump instructions previously encountered receiver types corresponding method addresses inlined figure 5a shows status call site corresponding pic stub code call site encounters objects class class c detailed pic stub code shown figure 6 possible method multiple type checking codes due inheritance type checking code separated corresponding method body avmtvmt pointer class translationtime constant sethi hiavmt g3 load 32bit constant value g3 loavmt g3 cmp g2 g3 compare two vmt pointers bne failhandler branch failhandler code two vmts equal mov o7 g2 delay slot instruction checking code located front method body code required jumptotarget call address agetfield1 mov g2 o7 prevent returning back implementation failhandler located front code failhandler index called method vmt translationtime constant call failhandler call failhandler mov index g1 delay slot instructoin index value passed fixup function via g1 register figure 4 detailed type checking code translated method call picstub pic stub code ld o0 g1 ld g1indexg1 nop polymorphic inline cache translated method call vmt code vmt code b handling megamorphic sites figure 5 polymorphic inline caches practical pic stub code grow without limit number entries pic stub code exceeds predetermined value corresponding call site called megamorphic site use vmt style code instead since code depends index value vmt shared among many call sites figure 5b explains megamorphic sites handled although mics used self megamorphic sites vmtstyle mechanism cannot used self think vmtstyle code appropriate megamorphic sites mics since latter may cause frequent updates call site frequent icache ushes result several variations pics space tight pic stub shared among identical call sites 2 type pic called shared pic former type called nonshared pic distinction required pic stub code contain counting code type test hit reordered based frequency reduce number type tests needed nd target reordering performed pic stub reordered without counting code used called counting pic also possible reordering performed periodically pic stubs always 2 possible sets target methods call call sites identical mov o7 g1 save return address g1 register avmtvmt pointer class translationtime constant sethi hiavmt g3 load 32bit constant value g3 loavmt g3 cmp g2 g3 compare two vmt pointers bne next1 nop delay slot instruction call address agetfield1 jump agetfield1 two vmts equal mov g1 o7 set correct return address cvmtvmt pointer class c translationtime constant next1 g3 locvmt g3 cmp g2 g3 bne next2 nop call address cgetfield1 mov g1 o7 next2 call fixupfailedcheckfrompic call fixup function nop figure 6 detailed pic stub code counting code type pic called periodic pic 313 vmt vs inline caches inline caches favored vmts two reasons first vmt mechanism requires indirect jump easily scheduled modern superscalar microprocessors 3 15 16 whereas inline caches faster modern microprocessors branch prediction second vmts provide information call sites inline caches get information receivers encoun tered though mics give last one information used optimizations method inlining 32 type feedback although inline caches reduce method dispatch overhead virtual call sites call overhead 3 cost indirect jump higher ultrasparc due lack btb branch target buer still remains order reduce call overhead need inline method idea type feedback 3 extract type information virtual calls previous runs feed back compiler optimization type feed back virtual call inlined guards veries target method equal inlined method call conditional inlining 321 framework type feedback implementation type feedback based pics since provide accurate information call sites mics vmts type feedback also requires adaptive compilation framework implemented adaptive version latte selects methods aggressively optimize based method run counts method called rst time translated register allocation traditional optimizations 4 virtual method calls 4 optimize even initial translation isolate performance impact inlining fair comparison congurations experiments see section 41 within handled pics number times method called exceeds certain threshold retranslated conditional inlining also done 322 conditional inlining compiler decides whether call site inlined based status inline caches example call site gure 3b remains monomorphic site retranslation time inlined type checking code follows objvmt avmt else call site points pic stub code one target method stub code conditional inlining except time comparison based addresses receiver types example pic stub code figure 5a composed type checks class class b class class c addresses getfield1s identical inline method type check replaced address check includes access vmt two loads follows objvtmindex method getfield1 address agetfield1 loadload else frequency information type method available using counting pic improve allornothing strategy even though multiple receivers multiple target methods inline call site type test address test one case dominant among cases pic stub currently criteria value decide whether case dominant 80 count type test hits pic stub exceeds 80 total count pic stub inlined type checking code 323 static type prediction call sites located untaken execution paths initial runs information probable receiver type collected even retranslation however class object virtual call made subclass translation time easily predict receiver type would class runtime althouth java allows dynamic class loading found prediction quite accurate programs following case example inline call site even information inline cache retranslation 324 inlining heuristic single vs multiple previous section inlined method virtual call site possible call site two target methods neither dominant case might lose inlining opportunities restricting number inlineable methods call site however found case java programs use testing programs 95 virtual call sites call single callee enabling inline multiple methods call site increase number inlined virtual calls signicantly 4 experimental results section evaluate performance impact inline caches type feedback 41 experimental environment benchmarks composed specjvm98 benchmark suite 5 17 table 1 shows list programs short description benchmark description bytes compress compress utility 24326 jess expert shell system 45392 213 javac java compiler 92000 222 mpegaudio mp3 decompressor 38930 228 jack parser generator 51380 table 1 java benchmark description translated bytecode size table 2 lists congurations used experi ments lattevmt lattemic lattepic except handle virtual calls using vmts mics pics respectively lattetf inlines virtual calls using type feedback adaptive version latte initial translation identical lattepic described section 32 variations pics denoted variation surrounded 5 200 check excluded since correctness testing brackets example shared pic denoted pics counting pic picc periodic pic picp default version pic denoted pic distinction needed system description virtual calls handled vmt virtual calls handled mic virtual calls handled pic virtual calls inlined using type feedback retranslation time table 2 systems used benchmarking test machine sun ultra5 270mhz 256 mb memory running solaris 26 tested singleuser mode ran benchmark 5 times took minimum running time 6 includes jit compilation overhead garbage collection time 42 characteristics virtual calls table 3 shows characteristics virtual calls table vcall means total count virtual calls mcall means total count monomorphic calls starget means total count virtual calls target method one runtime 85 virtual calls monomophic calls 90 virtual calls one target method programs like 213 javac 227 mtrt 228 jack many call sites target method one even though multiple receiver tyeps thus expect address check inlining may eec tive programs also expect compress much aected virtual calls implemented since number virtual calls extremely small 43 analysis monomorphic inline caches table 4 shows characteristics mics table vcall means total count virtual calls pcall means total count calls called polymorphic call sites miss means total count type check misses trend miss ratios programs 209 db 228 jack low miss ratios compared v call type check misses common 202 jess 213 javac since type check miss requires invalidating part icache miss ratio greatly 6 specjvm98 benchmarks total elapsed running time comparable specjvm98 metric aect overall performance expect performance 202 jess 213 javac may worse monomorphic inline caches 44 analysis polymorphic inline caches tables 5 6 7 8 shows average number type checks pic stub conguration pics column tables divided maximum number possible entries pic stub threshold value determines reordering takes place value applied picc picp although reordering takes place former takes place periodically latter threshold value zero means counting rst glance nd numbers average type checkings small even though monomorphic sites included numbers average number calculated every inline cache including monomorphic sites number even closer 1 however counting enabled numbers less 2 every case table 5 6 clear counting pics eective reducing number type checks pic stub except 228 jack although numbers generally reduced threshold value increased unchanged even increased programs seem saturate certain values simply increasing threshold guarantee improvements 228 jack dierent characteristics programs come single polymorphic site 7 accounts half total polymorphic calls exhibit strange behavior call site switched polymorphic inline cache monomorphic inline cache newly encountered type received repetitively thousand times thereafter former type used repetitively 1 million times default pic scheme without counting better counting case also see eect inaccuracies caused sharing pic stubs table 5 6 although seems natural nonshared version would accurate shared version dierence apparent noncounting versions congu rations numbers table 5 better table 6 except 213 javac pic stubs changed vmtstyle code sharing increases number entries however dierence lower 03 cases 7 call site indexof method javautilvector class calls equals method benchmark vcall mcall starget mcallvcall stargetvcall compress 129 116 118 0897 0912 jess 34306 27718 28435 0808 0829 222 mpegaudio 10025 8781 8841 0876 0882 228 jack 17247 14094 16959 0817 0983 geomean 0854 0904 table 3 characteristics virtual calls benchmark vcall1000 pcall1000 miss1000 missvcall misspcall compress 129 13 058 0045 0433 jess 34306 6587 3201 0093 0486 222 mpegaudio 10025 1244 54 0005 0044 table 4 characteristics monomorphic inline caches tables 7 8 shown comparison tables 5 6 although periodically reordered pic hard use real implementations always incurs counting overhead involves loadaddstore sequences seen somewhat ideal cong uration terms number type checks dierence periodic version nonperiodic version lower 02 programs thus quality counting pics quite acceptable table 9 shows space overhead pics nonshared shared versions table n means number pic stubs max means possible maximum number entries pic stub overhead seems small programs except 213 javac shared version greatly reduce overhead since sharing pic stubs degrade performance severely programs shared pics useful space tight 45 analysis type feedback tables 10 11 12 show eect type feedback terms number inlined virtual calls base system four dierent pic variations pics picsc pic picc used main purpose pics providing prole information larger number maximum entries pic 10 used threshold counting pics set 1000 order aect accuracy much 8 generally number inlined virtual calls reduced retranslation threshold increased although accurate prole information available high retranslation threshold low translation threshold opportunities missed delaying retranslation seems high addition number inlined calls many programs constant regardless type pics two rea sons one possibility method big inlined case inlining method related inlining heuristic beyond scope paper possiblility single method dominant call site however case specjvm98 benchmarks shown following section programs like 213 javac 227 mtrt aected type pics used counting version preferable noncounting version call site multiple receiver types thus inlined address check inlined type check counting information available one receiver type dominant call site involves two target methods thus cannot inlined implementation inlined one method dominant 213 javac uenced eects ie amount type check inlining address check inlining increased 8 since pic reused call site method inlining done value large benchmark pic compress 1540 1480 1498 1526 1540 1540 1480 1498 1526 1540 jess 1517 1488 1507 1486 1486 1517 1488 1507 1486 1486 222 mpegaudio 2120 1359 1267 1266 1269 2120 1359 1267 1266 1269 228 jack 1209 1800 1800 1800 1800 1209 1800 1800 1800 1800 table 5 average number type checks nonshared counting pics lattepicc benchmark pic compress 1790 1693 1711 1728 1769 1790 1693 1711 1728 1769 jess 1579 1570 1578 1576 1576 1579 1570 1578 1576 1577 222 mpegaudio 2161 1358 1267 1267 1269 2161 1358 1267 1267 1269 228 jack 1051 1980 1980 1981 1981 1398 1895 1895 1895 1895 table 6 average number type checks shared counting pics lattepicsc former eect dominant 227 mtrt increase amount type checking inlining almost decrease address checking inlining 46 analysis inlining heuristic table 13 14 15 show total number inlined virtuals call dierent inlining heuristics inlining single method call site inlining possible methods call site numbers column single method inlining sum type check inlining address check inlining tables previous section numbers column method inlining obtained inlining methods encountered initial run inlined inlining rule size depth 9 expected fact 90 virtual call sites one target method little improvements terms number inlined virtual calls even though possible methods permitted inlined 213 javac op portunites improved inlining multiple methods call site think inlining method call site sucient programs many call sites still remain inlined due factors like method size inlining depth 9 counting version excluded since dierence noncounting version possible methods inlined shared version also excluded since causes code explosion 213 javac 47 performance impact inline caches type feedback table shows total running time tot program 4 congurations latte translation overhead tr also included total running time since little dierence running time dierent congurations pic tf one instance listed exact congurations like 1 pic nonshared counting pics maximum number entries 5 reordering threshold 100 2 tf based nonshared counting pics maximum number entries 10 reordering threshold 1000 retranslation threshold whole mics improve performance latte geometric mean 30 pics 90 type feedback 74 compared latte vmt pointed previous section mics exhibit poor performance 202 jess 213 javac high ratio type check misses pics expected solved problem experienced mics exposed programs without severe degradation programs improves performance almost programs compared vmts however type feedback seems eective 227 mtrt number inlined virtual calls much larger programs number benchmark pic compress 1480 1498 1526 1540 1480 1498 1526 1540 jess 1366 1366 1367 1367 1366 1367 1367 1367 222 mpegaudio 1264 1265 1267 1270 1264 1265 1267 1270 228 jack 1019 1019 1019 1020 1019 1019 1019 1020 table 7 average number type checks nonshared periodic pics lattepicp benchmark pic compress 1693 1711 1728 1769 1693 1711 1728 1769 jess 1429 1429 222 mpegaudio 1265 1266 1267 1269 1265 1266 1267 1269 228 jack 1030 1030 1030 1031 1114 1114 1114 1114 table 8 average number type checks shared periodic pics lattepicsp inlined virtual calls programs seems low compensate retranslation overhead crease translation time inlining overhead crease code size register pressure since performance type feedback depends inlining heuristic well retranslation framework carefully implemented measure eect type feedback correctly implementation could improved points however result 227 mtrt gives us expectation eect type feedback 227 mtrt getter methods getx gety getz frequent performance benchmark greatly improved inlining meth ods common coding style using accessor methods eective type feedback could 5 related work work based polymorphic inline caches type feedback polymorphic inline caches studied urs holzle et al 2 self compiler achieved median speedup 11 monomorphic inline caches type feedback proposed urs holzle david ungar 3 implemented type feedback self compiler using pics improved performance factor 17 compared nonfeedback compiler since virtual calls frequent self also since default dispatching overhead much larger vmts used java achieved larger speedup furthermore measurements compare execution time excluding translation time overhead relevant study done david detlefs ole agesen 18 also targetted java used conditional inlining proposed method test identical address test however mainly concentrated inlining rather inline caches use prole information inline virtual calls gerald aigner urs holzle 19 implemented op timizaing sourcetosource c compiler used static prole information inline virtual calls improves performance median 18 reduces number virtual function calls median factor karel driesen et al 16 extensively studied various dynamic dispatching mechanisms several modern architectures mainly compared inline cache mechanisms tablebased mechanisms employ indirect branches showed latter perform well current hardware also expected tablebased approaches may perform well future hardware olver zendra et al 20 implemented polymorphism smalleiel compiler also eliminated use vmts using static variation pics inlined monomorphic call sites however relied static type inference use runtime feedback benchmark nonshared shared compress 6 536 536 5 512 512 jess 24 2368 2648 14 1708 1988 222 mpegaudio 25 3008 3008 228 jack 19 1856 1856 12 1380 1380 table 9 size pic stub code benchmark typecheck inlining 1000 addresscheck inlining 1000 jess 12036 12036 12036 12036 table 10 inlined calls type feedback retranslation threshold based experiences c programs brad caler dirk grunwald 21 proposed using con version similiar type feedback except uses static prole information 6 conclusion future work implemented inline caches type feedback latte jit compiler evaluated techniques although programs suer frequent cache misses mics achieve speedup 3 geometric mean vmts polymorphic inline caches solve problem experienced mics without incurring overheads elsewhere achieve speedup 9 geometric mean vmts using counting pics also tested several variations pics shown characteristics pics java programs counting pics reduce average number type checks pic stub compared noncounting version achieve average number type checks close periodic version within 02 programs memory matter concern shared pics save space reasonable degradation performance eect type feedback fully shown study overall performance even worse counting pics although true programs little opportunity improve terms virtual calls result partly cannot apply optimizations selectively bene cial however performance 227 mtrt many virtual calls small methods greatly improved type feedback gives us insight performance impact type feedback coding style uses abstraction makes calls becomes dominant java programs type feedback eective study type feedback also exposed prob lems adaptive compilation method inlining avoid degradation due type feedback important estimate costs incurred retranslation inlining apply conditional inlining hotspots r latte fast ecient java vm justintime com piler java language speci kemal ebcio java virtual machine speci kemal ebcio kemal ebcio kemal ebcio java hotspot performance engine httpwww inlining virtual methods gerald aigner urs h reducing indirect function call overhead c tr
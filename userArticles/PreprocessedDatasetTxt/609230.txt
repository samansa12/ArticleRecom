formalization analysis class loading java since java security relies typesafety jvm many formal approaches taken order prove soundness jvm paper presents new formalization jvm proves soundness first model employ dynamic linking bytecode verification analyze loading constraint scheme java2 key concept required proving soundness new model augmented value typing defined ordinary value typing combined loading constraint scheme proving soundness model shown problems inside current reference implementation jvm respect model also analyze findclass scheme newly introduced java2 analysis also shows applets cannot exploit typespoofing vulnerability reported saraswat led introduction loading constraint scheme b introduction unlike predecessor c java supports platformindependent bytecodes compiled source programs written java sent network mobile codes executed java virtual machine running within local application web browser jvm links bytecodes sent network typesafe manner whose meaning follows guaranteed linking bytecodes type information consistent destroy consistency jvm state type information following requirement also satised current jvm state consistent type information next execution step still consistent java way typesafe language two requirements satised note consistency broken jvm incorrectly interprets contents pointed inner pointer references type safety jvm guarantees memory safety jvm thus plays primary role java security order show type safety property jvm akihiko tozawa masami hagiya graduate school science university tokyo japan suggestions comments article appreciated please send email fmiles hagiyagissutokyoacjp number studies made far brie summaried next subsection paper gives another formalization jvm proves soundness bytecodes running inside jvm structures classes separatedly loaded linked jvm objects called class loaders responsibility loading linking class supporting variety class loaders jvm achieves exibility class loading however exibility causing problems respect mentioned typesafety java rst contribution work developing new model jvm described section 2 paper detail model several improvements dened previous studies first includes class loaders java class loaders instances userdened class whose primary function map class names class objects however closely related jvm internally builds class environments words class environments jvm statically given lazily built dynamic evaluations class loaders model gives dynamic environments represent internal heaps jvm seems best approach model lazy linking semantics jvm class loaders since consider static language environments constructed model practical one faithfully ects jvm implementations 1998 sun microsystems released version 12 java development kit jdk12 based newly proposed design principle called java2 comes rewritten specication jvm java virtual machine specication 2nd edition 9 important feature introduced new specication loading constraint scheme originally introduced liang bracha 8 scheme x saraswats problem 13 related unique design java class loaders formalization also includes scheme second contribution work found three problems inside current ocial implementation jvm respect scheme problems trivial ones require careful analysis scheme done work formalization described section 3 third contribution work proving soundness model given section 2 key notion required soundness proof augmented value typing dened ordinary value typing combined loading constraint scheme new typing shown consistent subtype relation existence loading constraint scheme note consistency crucial soundness model problems found inside current ocial implementation jvm due violation consistency another new feature java2 findclass implementation class loading technically speaking loading constraint scheme findclass scheme give constraints dynamic class loading java constraints restrict happen future complicate lazy linking semantics java example problem found loading constraint scheme sensitive timing introducing con straints fact ects subtleties semantics constraints analysis findclass scheme section 4 fourth contribution analysis also answer old question applets cannot cause saraswats problem 13 11 related work since java security deeply relies jvm typesafety giving formal models jvm recently one major research issues network security stata abadi 15 gave jvm model including bytecode verication try grasp jvm type system bytecode verication typing rules whereby correctness jvm proved form soundness theorem work lays concept modeling bytecode verier stata abadis work words extended model cope class loaders freund mitchell worked specic problem related object initialization 4 work also based stata abadis qian rst succeeded modeling large part jvm 12 formalizations covering wider range jvm without proofs given goldberg 5 jensen et al 6 particular jensen et al dealt saraswats bug modeling class loading operational semantics saraswat 13 gave formal explanations problem dean also gave formal model class loading 2 however cannot explain type spoong problems lazy semantics class loaders yet fully modeled far know think something study modularity work cardelli 1 machine verications also applied prove type soundness java 1011 12 organization rest paper structured follows section 2 gives basic formal model jvm also soundness proof model section 3 mainly explains problems implementation jvm section 4 give discussions related findclass scheme formally answer old question applets cannot cause saraswats problem 13 section 4 also discovered new method implement loading constraint scheme eciently model soundness formal model jvm presented paper following new features compared previous studies modeling lazy class loading jvm dening loading constraints modifying value typing statement giving rigorous denition environment enough model features particular lazy class loading jvm rst modeled study note also last feature necessary dene wellformedness type type option none type env f stringstring listt class cl iface string list class instruction list lvars tvalue list list type verifyrecord f lvars string list stack string list invokevirtual string string string areturn figure 1 type denitions environment turn dened terms wellformedness various components section rst explain several basic denitions section 24 gives denition loading constraint scheme main soundness theorem described section 25 21 environments 211 denition environments environment represents internal heap jvm basic data structure formalization course every component heap cannot modeled instead give welldened set components mathematical examinations possible represented type env see denition types figure 1 environment ie element env record consisting four subsets class loader tvalue method set loc locations maps c w r meaning subset clear index note end section type env considered dependent type since map r arrow type constructed using subsets class loader tvalue method types members c v map locations appropriate denitions ie return denitions stored e references member w represents class loading r represents method resolution two maps explained later use notation em extract member environment e figure 2 abbreviations inside judgments type option denotes type composed constructor none values wrapped constructor example value ewln either none form c type list denotes type nite lists list ith element x denotes xi length lenx note classdeft denotes tuple consisting class loader tvalue method dene class classdeft separately two kinds identity classes situation happens values methods usually identify object reference state ie element statet either exeption denotes error state record consisting four elements pc method lvars stack elements verifyrecord give types local variables stack state used bytecode verication type instructions instruction dened completely sake study assume invokevirtual instruction areturn instruction type theories use type representing types env tuple considered element index set index dened follows use reference ie element loc access component en vironment course dierent ways dene identify components studies class identied tuple class name class loader two classes name loader inside single jvm model gives low level abstraction ects practical jvm im plementations implementation class identity property one various properties implicitly satised internal structure heap practice two classes name loader class loaders synchronized two threads start loading class loader time property would easily violated going implement jvm always satises properties instead extracted set properties essential soundness model called wellformedness en vironment given assumption modication update environment must preserve wellformedness wellformedness environment denoted wf e composed following properties property related classes inside environment property related methods inside environment property states methods statically veriable ie gone bytecode verication bridge safety property related loading constraint scheme properties denoted wf classe wf method e veriede bridge safee described sections 224 235 251 243 respectively 22 objects classes loaders section gives basic denitions objects classes class loaders class java actually object instance javalangclass class loader javalangclassloader unlike objects play essential roles jvm architecture refers automatically implicitly therefore appropriate dene objects classes class loaders separately 221 classes let us rst explain denition classes figure 1 class denition ie element classdeft tuple consisting class name direct super class name class loader noted assume c class reference components cs denition simply written inside judgement cname csuper ccl respectively two components c method dispatch table cmt implemented interfaces class ciface discussed later 222 class loaders java object instantiating javalangclassloader private member declared hashtable maps names classes class objects model mapping ew follows denition 21 subtyping denition 22 widening cl denition 23 normal value typing denition 24 wellformedness figure 3 predicates related classes class name resolution n l ewln results c name n associated certain class c class loader l none also say n resolved c l sense class loader name space therefore class loader also called context class c dening class loader ccl whereby every class name resolution related c done sense ccl context c throughout paper use word context class loader synonyms figure shows value uniquely refers class thus class loader say value v created context vclasscl method executed context mcccl 223 subtyping subtyping classes dened figure 3 model predicate sub represents relation class c parent class name csuper resolved c 0 context ccl c direct subtype c 0 indirect subtyping dened exive transitive closure direct subtyping 224 wellformedness classes actual class loader jvm resolve classes one following two ways class loader l denes class c whose name n sets ccl l resolves n c class loader l delegates class loading another class loader resolves n c whose ccl equal l actual class loaders therefore satisfy following statement wellformedness classes dened figure 1 since class dened rst process sets n l class c et class cname resolved c context ccl note statement immediately implies class identity property described section 213 225 object values states jvm state stateet error state exception following components method denotes method jvm processing pc program counter points certain instruction methodi lvars stack represented list values stores contents local variables local stack respectively state environment represent internal data structures jvm transitions respectively distinct independent model values found inside lvars stack objects object value v record one member vclass represents type class value 1 practice java object value may also reference array values ie eld values diculty extend model represent elds since already value heap add veld represents list value references model omits elds java getputeld instructions large part similar invokevirtual also easier handle 226 predicates respect subtyping value typing introduce two predicates respect subtyping one represents widening conversion represents typing judgment values formalizations given figure 3 widening conversion denes quasiorder 2 class names order two names dened resolved cl except case two names equal ordering follows subclass relation classes names resolved normal value typing typing judgment denotes type value v subtype n context cl also dened n already resolved cl note predicates depend context cl 23 methods section simply describes specication invokevirtual 9 practical method invocation jvm involves diculties problems remaining problems explained section 3 231 instructions dened figure 1 jvm model includes two instructions invokevirtual areturn instruction invokevirtual fundamental non 1 java null value represents uninitialized object value model simplicity 2 according denition sub cl satisfy transitivity antisymmetry course practice trivial instruction jvm used three arguments follows judgement means current jvm state process invokevirtual calls certain instance method string name name method string list desc descriptor representing type signature method argument types ie class names method desc0 return value type string classname name symbolically referenced class 9 instruction areturn one return instructions jvm returns caller holding one object value return value 232 method invocation execution invokevirtual consists following three processes method resolution looks method according three arguments invokevirtual method found process called symbolically referenced method denoted srmethod method selection looks method accessible class object top local stack method invocation calls method found method selection process assume invokevirtual inside method whose class c whose context l ccl method resolution process modeled follows look method srmethod already registered en vironment er cf section 21 given name descriptor name desc srclass symbolically referenced class result resolving classname l remember name desc srclass l abbreviates erlname desc srclass denition given end section also section 3 practically jvm remembers whether symbolic reference already resolved never resolves reference twice 3 model ects behavior method selection process dened section 3 section assume process results unique value denoted method write judgement e left hand side assume srmethod method inside right hand side denote symbolically referenced method selected method respectively srmethod method although dention value method left blank discuss implementation later examine soundness jvm ie 3 implemented internal class representation attaches ag resolvable constant pool entry remembers whether entry resolved also remembers result resolution correctness new loading constraint scheme cf section 24 provided assume lemmas 1 1 1 described sections 234 235 value srmethod identical value variable appearing predicate invv ok e dened denition 25 invokevirtual ok predicate means jvm execute invokevirtual method resolution normally succeeded ie raised exceptions unlike specied method resolution invv ok e holds ie method resolution succeeds jvm model ensures method selection method invocation also succeed method always dened case formally name desc classname srclass srmethod objectref denition invv ok e existentially quantied however situation assume invv ok e refer judgement leak denition invv ok e ie variables assumed satisfy invv ok e 233 operational semantics denition 26 describes state transition semantics invokevirtual dened accordance specication three processes invokevir tual note denotes list concatenation rst tries resolve method cannot resolved method resolved generates new state whose method selected one local variables store proper value values arguments originally stored stack must transition form point instruction areturn return instruction jvm means invoked method safely executed last stack return value top pushed onto denotes transitive closure onestep transition transitions instructions given paper see 15 7 exception denition 26 operational semantics invokevirtual exeception lvars objectref arg methodi retval retvalrest state references method cc figure 4 subtyping relations related invokevirtual 234 invocation correctness respect srmethod method following lemma con sidered lemma examined section 3 following several sections lemma assumed hold correctness invokevirtual let e environment jvm state method overrides srmethod words lemma 1 correctness invokevirtual guarantees jvm execute invokevirtual jvm safe state method whose dening class superclass class objectref invoked furthermore jvm safe state method overrides symbolically referenced method invoked second premise lemma subtyping relation objectref class srclass property invariantly satised safe execution jvm cf section 241 rst consequence lemma subtyping relation objectref class method cc derived method selection algorithm described section 311 see figure 4 method overriding relation overrides yet dened certain reasons one reason although term override often used specication jvm accurate meaning dened interpretation depends implementations paper dene predicate overrides section 311 conjunction predicate select predicate overrides satisfy following conditions lemma 1 implementation suns jdk12 inconsistent lemma 1 exposes new aw explain section 3 relation environments dened section 253 235 wellformedness methods following wellformedness property methods required mainly discussions section 4 selects srmethod predicate selects models method selection process denition found denition 31 section 311 class rt rr new rr figure 5 saraswats bug code predicate selects equivalence descriptors also hold lemma 1 24 bridge safety bridge safety jvm notion originally introduced saraswat report typespoong jdk11 13 insisted applet loaders never suers bug never break property sheng bracha devised x saraswats bug implemented jdk12 89 forces jvm check bridge safety runtime 241 typespoong jdk11 see source code figure 5 revealed bug typespoong jdk11 code nothing suspicious exist two contexts l 1 l 2 code runs l 1 delegation class loading rr dened invocation rspeakup would result serious violation type system jvm expression rspeakup complied following instruction jvm v dierent notation method descriptors represents method takes argument returns nothing respect invokevirtual objectref value top local stack equal value r comes context l 2 via invocation rrgetr l 2 symbolically referenced class srclass class current context l 1 resolves r third string invokevirtual l 1 code causes problem r l 1 dierent r l 2 invokevirtual correctly executed subtyping relation denition 27 loading constraints method overriding method resolution cl mdesci mcccl exivity cl n cl cl n cl cl 00 cl n cl 00 cl n cl 0 cl 0 n cl absolutely necessary course objectref class srclass suces recall subtyping relation second premise lemma 1 words method section 23 completely unrelated srmethod accurately bug results incompatibility dispatch tables two classes applying method index obtained srclass onto completely unrelated method table objectref class jdk11 would thus either invoke method argument values incompatible types core dump method dispatch table excluded suns specication therefore model implementation technique method selection algorithm cf section 313 242 loading constraints go back example section 241 suppose jvm already noticed invocation rrgetr method brought value type r context l 2 l 1 case check beforehand ow value acceptable may simply try check follows l 2 attempt fail since method resolution speakup r l 1 cannot evaluated ie environment e r must consider alternative ie loading constraint scheme case new scheme introduces following loading constraint r jvm remembers constraint r l 1 allowed resolved dierent class r l 2 method resolution process jvm notice possibility value ow easy un derstand related lemma 3 existence constraints described later section give rules introduce loading constraints method overrides 0 following constraint introduced respect class name n appearing descriptor method resolution nds srmethod following constraint introduced class name n appearing descriptor srmethod srmethod cl relation n dened transitive exive symmetric equivalence relation also minimal relation among satisfying conditions denition 27 formally describes predicate inductive denition shown later section 25 relation invariant ie relation environments subsumes n enables jvm incrementally construct relation n resolves method reference invokevirtual links class whose method overrides another method reason loading constraint scheme lightweight actually adopted among many solutions history saraswats problem solutions described 813 243 bridge safety predicate denition 28 denes predicate bridge safee follows environment e class loader e made resolutions classes contradict loading constraints existing inside e predicate forbids environment modication ie class loading method linking violates constraints jdk12 244 augmented value typing augmented value typing cl n dened follows another context cl 0 v type n normal sense cl 0 n also exists following constraint cl n cl 0 intent denition may obvious roughly means value v created ie instantiated n context cl 0 transfered current context cl predicate called dynamic conformity previous paper 16 noted introduction crucial proving type soundness loading constraint scheme denition one contributions study respect predicate following lemma important cl invariance augmented typing denition 28 bridge safety bridge safee def cl cl n cl cl cl 0 cl 0 denition 29 augmented value typing cl cl n cl cl 0 n list cl ns string list cl nsi let e environment n n 0 class names cl class loader bridge cl n 0 cl cl proof following fact proved examining def23 def29 def28 bridge cl n n cl 6 none cl n assume rst line lemma def22 def23 def21 cl n v cl applying e cl n cl def29 lemma proved lemma states augmented typing invariantly satised widening conversion described section 226 important statement relates runtime typing static typing ie bytecode verication proof lemma requires denition widening conversion cl n 0 force additional loadings n cl n 0cl case n 6 n 0 found two inconsistencies denition cl bytecode verication jdk12 exploiting still entirely escape additional checks newly imposed see section 3 16 detail note relatively easy show augmented typing also invariant used later soundness proof 245 constraint existence lemma 3 existence constraints states jvm safe state execute invokevirtual already exist loading constraints class name appearing descriptor invokevirtual current context context invoked method assume lemma 1 correctness invokevirtual note e cl desc cl 0 abbreviates cl desci cl 0 denition 210 verication rules rule rule invokevirtual6 6 6 6 6 6 4 istack0 mcl cname rule areturn4 lemma 3 existence constraints let e environment jvm state methoddesc method cl assume rst line lemma def27method overriding symmetry lemma 1 srmethod cl methoddesc method cl def27method rosolution def25 applying lemma 1 def27transitivity yields lemma 25 soundness section follows framework soundness proof stata abadi 15 one dierence introduction environments another treatment invokevirtual instruction exist model 251 bytecode verication one uniqueness underlying language design java found bytecode verication idea guarantee runtime welltypedness static verication allows minimum type checks runtime see denition 210 type verifyrecord represents imaginary store static class name information local variables local stacks map stores element verifyrecord instruction method bytecode verication problem nding consistent veried method denition 211 ktransition exeception kn denition 212 welltypedness veries method cl pclvars cl pcstack veried contents satisfy mcl relations imposed verication rules model consistency represented predicate veries predicate veriede states method e already veried welltypedness predicate e wt means state safe inside environment e lvars stack values typed class names recorded veries method state exception representing error state always welltyped note lvars cl pclvars abbreviates 8i cl pclvarsi interesting work yelland 17 implements bytecode verier based type inference haskell 252 soundness theorem main theorem theorem soundness environments 0 states theorem states execution step jvm preserves welltypedness intuitive meaning invariant trivial sucient guarantee correctness invokevirtual second premise lemma 1 instruction modeled paper also preserves invariant whereby correct behavior instruction guaranteed theorem divided two lemmas following sections denition 213 subenvironment relation string list et class 253 soundness environment updates denition 213 describes environments updated jvm dynamically links objects classes etc denes subenvironment relation two environments following rst lemma needed prove main soundness theorem lemma states modication environments preserves well typedness proof follows remember assuming lemmas 1 1 1 rst assume guarantees components e compatible e 0 therefore def213 def21 also def213 def23 cl cl n say relations sub cl invariant furthermore lemma 1 def213 guarantee following facts respectively imply relation n also invariant minimal among satisfy denition 27 therefore augmented cl also invariant dened def29 follows cl cl n cl 0 def212 lemma proved 254 soundness state transitions following second lemma soundness theorem lemma states every state transition xed environment e preserves welltypedness examining lemma redene state transitions described adds depth k transition obviously note 0 denotes state transition exception transition instruction invokevirtual dene paper proof lemma follows rst note following fact holds cl cl n cl 0 cl 0 expresses n invariance augmented typing easily proved examining def29 def27transitivity transitivity following fact sucient condition lemma proved induction k base case induction follows proof omitted see 15 7 detail remaining subgoal show case k1 induction hypothesis assume rst line iii state transition rule denes dened def26 induction hypothesis holds exists satises following condition cl pcstack applying def210rule invokevirtual lemma 2 obtain x0 n 1 denotes sublist x0 xn 1 n length desc assuming invv ok e lemma 1 used implies methodcl method ccname together wf classe hand lemmas 1 1 1 imply together wf methode use lemma 3 obtain methodcl method desc1 n 1 therefore lemma 2 def210rule imply methodcl 0 0lvars 0 satises 0 veries method method finally def26 implies lvars stack0 n therefore induction hypothesis iv areturn lemma 2 lead methodcl method desc0 similarly use lemma 3 obtain finally def210rule invokevirtual lemma 2 def26 def212 imply denition 31 predicate selects 3 analysis implementations another main topic paper analysis suns jvm implementation latter half section describes several aws found jdk12 respect saraswats bug loading constraint scheme describing aws let us examine lemma 1 correctness invokevirtual 31 correctness invokevirtual 311 method selection section 23 dened method invocation processes partially section denition 31 formalizes recursive procedure employed method resolution selection dene predicate selects pair key class key c selects method whose key equal key found lookup subtype tree c superclasses denition key denotes pair name desc key mkey denotes pair mname mdesc desc c selects following latter condition lemma 1 requires predicate also invariant denition denition selects selection process terminates method found inside c matter whether another method 0 found inside superclass c however case ie makes 0 invisible c say class c method mkey c selects direct superclass c selects dierent method 0 key mkey dene predicate overrides dened exive transitive closure predicate overrides faithfully follow suns specication srmethod method simply dened follows method resolution process nd srmethod satises following selects srmethod method selection process nd method satises following selects method see two denitions derive lemma 1 correctness invokevirtual simply applying premise lemma objectref class sub srclass dention overrides denitions lemma 1 method desc holds matter whether method overriding exists specication explicitly uses desc select method however implementation diers speciciation employs method dispatch table class select method long descriptor equivalence holds jvm never falls error state coredumps even though state may badlytyped reason dicult specication explain typespoong problem figure 6 describes problem graphically 312 proof lemma 1 paper show lemma 1 respect specication though must proved existing implementations rst show existence method since model method selection process always succeed assume invv ok e implies e srmethod key srclass selects srmethod also assume denition 31 implies existence method sat ises already noted relation select holds objectref class method cc obtain rst consequence lemma second consequence following method overrides srmethod proved induction sub overrides reexive transitive closure overrides objectref class sub srclass holds either method srmethod method overrides srmethod 313 method dispatch table method dispatch table list methods satises following conditions method selected class c method inside method dispatch table class cmt overriding method index overridden one ie class c superclass c 0 c index less length c 0 mt jvm incrementally build table structure class satises conditions referring table direct superclass already built suppose already method dispatch table class since srclassmt collection methods selected srclass method resolution process jdk12 searches inside srclass mt method resolution threfore dierence specication implementation method dispatch tables cannot seen outside hand method selection process implementation remarkably diers specication o1time procedure rather recursive procedure represented predicate selects method selection process follows index satises srclass selects srmethod selected method method selection process also sound also satises lemma 1 correct ness invokevirtual proof lemma sub relation necessarily used implementation equivalence descriptors desc method desc even existence method depend sub relation without relation index srclass mt meaning inside method mt exploiting inconsistency desc method desc one falsify integer value object value vice vasa method exist jvm coredumps 13 32 bytecode verier loading constraints 321 problem respect widening conversion go back saraswats bug code figure 5 section 24 suppose modication described applied original bug code original code modied code6 4 new r r load l 1 r l1 inside method resolution loaded jdk12 r l1 r r l 2 loaded violation violation jdk11 spec executing rspeakup case method even method unexpected execution continues posible method desc 6 desc worse case method may exist type confusion coredump figure type spoong chart class rr public r getr return new r originally new r assume l 2 loads class rr l 1 loads class rt invokes rrgetr also rspeakup also assumed l 1 resolves r dierently l 2 method invocation r rrgetr calls method inside class rr returns value type r type r inside context l 2 r subtype r recall check widening conversion r l2 already resolved therefore constraint r checked invocation rspeakup r l1 resolved assume conversely r l2 resolved yet even though class r l1 resolved though constraint indeed exists constraint never checked figure 6 describes happens case fact jdk12 sometimes resolve r l2 although resolution role bytecode verier 322 two inconsistencies found two inconsistencies bytecode verier jdk12 model still enables type spoong inconsistencies follows widening conversion n cl n 0 correctly checked n 0 resolved system classes veried runtime bugs brie explained 16 example codes let us emphasize signicance work problem concerned augmented typing alternative naturally dened typing since bytecode verication seemed unrelated saraswats bug designer jdk12 modify bytecode verication jdk11 however jvm requires lemma 2 cl invariance well relates welltypedness invariant bytecode verication based widening conversion model makes points clear visible 33 interfaces loading constraints addition problem bytecode verier one aw inside jdk12 implementation found analysis invokeinterface instruction excluded model far 331 invokeinterface instruction order discuss problem invokeinterface extend model able deal interfaces java thing allow class multiple parent classes throughout section class c list names implemented interfaces ciface redene subtyping relation c sub c 0 ie c direct subtype introduce new predicate classc true c pure class ie c interface though class single direct supertype previous sections fact used throughout soundness proof thus requires changes invokeinterface instruction similarly resolves selects method exactly semantics invokevirtual modication must considered predicate selects pure class c declare method required key predicate select method inside implementing interfaces c inside pure superclass c therefore redene second rule denition 31 follows classc classc 332 problem respect constraint existence question may raised code figure 7 dgetr overriding igetr accept denition overrides answer yes even though subtyping relation declaring classes two methods since class selects dgetr key representing r getr one direct supertype also selects igetr conclude dgetr overrides igetr denition override fact following code invokes method inside class safely interface r getr class r getr class c extends implements figure 7 problem invokeinterface since jdk12 fails recognize complex method overriding relations code figure 7 brings another problem loading constraint scheme overriding relation dgetr igetr recognized may constraint loaders dene respect name return type r 4 findclass scheme 41 formalization findclass scheme also one new feature java2 ie implementation class loadings findclass java2 recommends implement class loaders findclass rather old loadclass method though loadclass also accepted backward compatibility findclass scheme denes tree structure among class loaders delegation class loadings follow tree structure old version java applet loaders implemented similar manner findclass scheme also known applets never cause saraswats problem though never proved completely leads following question findclass scheme replace loading constraint scheme last theorem theorem trusted environments proved section 42 gives negative answer even follow findclass scheme class loadings may violate constraints unless delegations allowed system loaders theorem states also saraswat correctly mentioned applet loaders safe since delegate system loaders however 8 describes rst half class loaders recently increasing variety applications consider applet loader delegates another applet loader although loaders seem safe glance theorem correctly states possibly violate constraints 411 parent loaders following denitions incorporate findclass scheme model denition 41 parent loader true l vp parentdef l l vp l 0 direct parent loader loader l parent loader assume p l inductively dened predicate l vp l 0 denotes l one indirect parents l 0 denition 42 correct delegation parent loaders denition formalizes following delegation strategy java2 loader l direct parent loader l 0 class loading l rst delegated l 0 class loaded l l 0 cannot resolve class name otherwise l return class l 0 returns denition expresses loading delegation follow parent loader relation expresses two loaders parent loader relation correctly delegate class loadings according strategy second condition implies ccl vp l l already resolved cname therefore wf parente p holds loader e considered resolved classes words e represents environment possible class loadings completed ordinary environments thus considered subenvironments environments therefore use dient font e environments note wf parente p implies wf classe 412 parent environment dene relation envirnoments represents extension environments delegations parent loaders denition 43 parent environment second line denition e method loaded loader e already exist e third line states delegations allowed direct parent loader e 42 trusted environments theorem trusted environments states even follow ndclass scheme jvm never violates constraints parent loaders system loaders st dene system environments denition 44 system environment predicate denes condition system environments satisfy system classes loaded class name appearing method descriptor resolved theorem trusted environments following proposition satised 1 called trusted environment satises consequence theorem theorem states e 1 trusted environment e 2 example applet loaders inside certain e 1 applets never violate constraints prior proof theorem introduce additional relation l 0 means onestep constraint l l 0 allow method resolution method overriding symmetry deni tion 27 ignore symmetry two cases e l n l 0 holds assume wf methode section 235 method resolution l remember l context resolves classname implies wf parente p srclasscl vp l note also holds wf method e def31 generally onestep subtyping relation holds p wf parente p def21 def42 consequently subtyping relation sub also implies vp therefore wf parente p holds otherwise overrides relation case according section 3 class c selects superclass c selects 0 fact implies following one therefore def41 loader two dierent indirect direct parent load ers one direct parent cases following result respect n l 0 l vp l 0 l 0 vp l furthermore easily show following cases note l p l 0 abbreviates l vp l results theorem trusted environment proved follows proof assume given e assume l l 0 l 0 also l p l 0 def43 implies l system loader therefore ii implies note method dened system loader system method cf def43 def44 next goal prove following fact proved induction derivation loading con straint l n l 0 suppose following onestep constraint appended l n l 0 generate l n l 00 transitivity l 00 assume induction hypothesis show l 0 vp l 00 l 00 left case disjunction l 0 vp l 00 easy since vp transi tive therefore assume l 00 p l 0 case iii says exists c 0 e 1 class satises together def42 leads induction hypothesis implies implies c l 00 derived e 1 c 0 cl vp l 00 lemma iv naturally leads bridge easy show bridge safee holds make counter example violates con straints example e 1 follows loader 0 loader 0 denes class c class c method signature x satisfy systeme 1 assume class x never resolved loader 0 ie method resolved loader 0 mcl additionally loader 1 loader 1 denes class class calls method class c signature x loader 1 denes class x loader 1 delegates loader 0 classes loader 2 loader 2 denes class class extends c class method signature x loader 2 denes class x loader 2 delegates loader 0 classes assume c class c dened loader obviously loader 2 overrides therefore denition 2 however x loader 1 x 1 dierent therefore bridge hold 5 conclusion presented new model jvm explains various unique features jvm also species several conditions implementations particular model includes loading constraint scheme ndclass scheme new features jdk12 formalization could analyze extremely subtle relationship loading constraint scheme bytecode verication believe analysis possible rigorous formalization soundness proofs however model excludes many features jvm primitive types eld members array types member modiers threads instructions etc several ideas incorporate model example model easily express object class nalization jvm soundness theorem section 25 states environment updated larger environment welltypedness invariant preserved fore introduce reduced environment also preserves invariant soundness nalization guaranteed ndclass scheme showed work loading constraint scheme however also obtained method allows loading constraints omitted cooperation ndclass scheme result included paper think best solution expect schemes improved future r linking moduralization formal aspects mobile code security web browers beyond type system object initialization java bytecode language speci security dynamic class loading java formalisation new method data ow analysis java virtual machine subroutines dynamic class loading java virtual chine java virtual machine speci java light typesafe de nitely proving soundness java bytecode veri formal speci java typesafe nicht veri type system java bytecode subroutines careful analysis type spoo compositional account java virtual machine tr ctr modeling multiple class loaders calculus dynamic linking proceedings 2004 acm symposium applied computing march 1417 2004 nicosia cyprus
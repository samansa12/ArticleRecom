function pointlike measure objectoriented software present method estimating size consequently effort duration object oriented software development projects different estimates may made different phases development process according available information define adaptation traditional function points called object oriented function points enable measurement object oriented analysis design specifications tools constructed automate counting method novel aspect method flexibility organization experiment different counting policies find accurate predictors size effort etc environment method preliminary results application industrial environment presented discussed b introduction cost effort estimation important aspect management software development projects experience shows accurate estimation difficult average error 100 may considered good average error 32 outstanding vicinanza mukhopadhyay prietula 1991 methods estimating effort require estimate size software size estimate available models used relate size effort cost estimation onetime activity project initiation estimates refined continually throughout project demarco 1982 thus necessary estimate size repeatedly throughout development 2 giuliano antoniol et al accurate estimation size vital unfortunately proved difficult especially early development estimates use research estimating size dealt traditional applications traditional software development practices methods proposed object oriented software development paper presents method estimating size object oriented software development projects based adaptation classical function point method object oriented software following sections present approach measurement explain map concepts function points object oriented software describe process counting object oriented function points oofps give example results pilot study presented discussed 2 measurement perspective figure 1 shows main phases object oriented oo development process measurements obtained different points development purpose measures give project manager something estimate size effort duration project estimates revised new artifacts become available development oo analysis oo design system requirements definition implementation user designer customer figure 1 perspectives measures software development process move phases process measurement perspective changes user designer end requirement specification phase classical function point counting method applied requirements doc ument function point method takes perspective end user actually measured functions system maintex 23061999 1427 v p2 function pointlike measure objectoriented software 3 visible end user measure generally considered independent particular implementation aspects system eg graphical user interface included classical function point count nevertheless contribute final size system objective measuring functionality estimate size implementation sys tem effort duration software project aspects taken account changes perspective user customer ie organization acquires system accepts pays development costs system designer produce implementation given specifications object oriented modelling begins ie oo analysis phase measurements obtained object models oofp used place fp development proceeds gives natural shift perspective oo analysis phase elements object models still related application domain perspective still user oo design later phases object models reflect implementation choices includes aspects system specified requirements documents count oofp models thus include functionalities measurement perspective designer different size estimation models developed different stages development detailed information available system evolves abstract specification concrete implementation possible refine size estimate repeatedly long estimation process difficult since developed tools automate counting oofps recalculation easy time 3 object oriented function points practitioners found function points albrecht gaffney 1983 ifpug 1994 useful within data processing domain invented aim exploit experience obtained function points traditional software development oo paradigm adapting function points oo need map function point concepts object oriented concepts must decide handle oospecific concepts inheritance polymorphism 4 giuliano antoniol et al presentation uses notations omt method rumbaugh blaha premerlani eddy lorensen 1991 would much different booch notation booch 1991 unified modeling language rational software corporation 1997b used instead since main models views different methodologies carry similar information omt method uses three different orthogonal views describe software system object model static representation classes objects system relationships functional model data flow diagrams provide functional decomposition activities system dynamic model state machines represent dynamic control aspects system although three models provide important information objectoriented system object model important purposes usually first developed measured earliest one represents actually built sense models help completing object model functional model helps identifying designing methods control model helps identifying attributes needed maintain state information events must implemented classes methods however ongoing discussion practitioners community content role models functional model seems fallen disuse required methodologies rational software corporation 1997b dynamic model often replaced list use cases scenarios object model one present methodologies describes system using specifically objectoriented concepts reasons decided restrict attention object models traditional developments central concepts used counting function points logical files transactions operate files oo systems core concept longer related files data bases instead central concept object central analogy used map function points oo software relates logical files transactions classes methods logical file function point approach collection related user identifiable data class object model encapsulates collection data items class natural candidate mapping logical files maintex 23061999 1427 v p4 function pointlike measure objectoriented software 5 oo paradigm objects instances class oo world correspond records logical file data processing applications fp method logical files lf divided internal logical files ilfs external interface files eifs internal files logical files maintained application external files referenced application maintained applica tions division clearly identifies application boundary oo counterpart application boundary imaginary line object model divides classes belonging application classes outside application external classes encapsulate nonsystem components applications external services reused library classes directly instantiated subclassed parameterized classes classes within application boundary correspond ilfs classes outside application boundary correspond eifs transactions fp method classified inputs outputs inquiries categorization easily applicable outside data processing domain oo paradigm locus operation class methods usually finegrained level transactions since object models rarely contain information needed tell whether method performs input output dealing enquiry attempt distinguish three categories simply treat generic service requests srs issued objects objects delegate operations short map logical files classes transactions methods issues inheritance polymorphism affect structure object model model counted addressed section 4 31 related work authors proposed methods adapting function points object oriented software generally map classes files services messages transactions whitmire 1993 considers class internal file messages sent across system boundary treated transactions schoon eveldt hastings mocek fountain 1995 treat classes files consider services delivered objects clients transactions method gives similar count traditional function points one system draft proposal international function point users group ifpug treats classes files methods transactions 1995 6 giuliano antoniol et al fetcke abran nguyen 1997 define rules mapping use case model jacobson christerson jonsson overgaard 1992 concepts ifpug counting practices manual ifpug 1994 three case studies confirmed rules applied consis tently attempt made relate results metrics traditional function points lines code effort sneed 1995 proposed object points measure size oo soft ware object points derived class structures messages processes use cases weighted complexity adjustment factors closest analogue method predictive object points pops proposed minkiewicz 1997 pops based counts classes weighted methods per class adjustments average depth inheritance tree average number children per class methods weighted considering type con structor destructor modifier selector iterator complexity low average high giving number pops way analogous traditional fps pops incorporated commercial tool project estimation work differs minkiewicz several ways two respects consider information count data class well methods consider aggregation inheritance detail instead averages consider less information counting methods since distinguish method types information method type seldom available design stage automatic tools would need gather information designer might tedious task large systems reason attempt base method complexity weighting method type instead try exploit information methods signature likely present design least detailed design stage key thing new method flexibility much scope experimentation example fetcke et al 1997 define aggregation inheritance handled particular way discussed section 41 define several options one fetckes approach leave user choose written programs count oofps automatically several parameters govern counting decisions organization experiment determine parameter settings produce accurate predictors size environment thus method tailored different organizations environments moreover measurement affected subjective ratings complexity factors like introduced classical function point analysis function pointlike measure objectoriented software 7 4 measurement process oofps assumed function objects given object model might produced design stage extracted source code oofps calculated welf det denotes set objects belonging application generic object dets rets ftrs elementary measures calculated lfs srs used determine complexity complexity matrices w details given sections 41 43 figure 2 shows phases oofp computation process 1 object model analyzed identify units counted logical files four ways might done use parameter counting process step described section 41 2 complexity logical file service request deter mined w tables used map counts structural items dets rets ftrs complexity levels low average high tables varied represent another parameter counting process step described sections 42 43 3 complexity values translated numbers using another table numbers oofp values individual logical files table used also varied yet another parameter counting process 8 giuliano antoniol et al 4 logical file class annotated reused ie developed reuse another class oofp value multiplied scale factor 10 less scale factor another parameter counting process step discussed section 44 5 oofp values summed produce total oofp value det ret det ftr det ret oofp oofp oofp ilf lah lah lah gb module oo design figure 2 oofp computation process 41 identifying logical files conceptually classes mapped logical files may always appropriate count class simply single logical file however relationships classes aggregations generalization specializations particular sometimes make appropriate count group classes together logical file aggregation inheritance relationships pertain mostly implementation aspects internal organization reuse tend analysis object model may many design implementation model wholepart assemblies inheritance hierarchies identified relationships affect boundaries around logical files depends perspective chosen artifact oof ps computed analysis phase users perspective important one early take designers point view stage classes object model represent entities application user domain aggregation inheritance relationships complicate things counting single class logical file usually appropriate stage origin class matter scale factor used step 4 counting process shouild set 10 class counted full inherent value function pointlike measure objectoriented software 9 design phase object models contain much information related implementation designers perspective considering single class logical file correct choice designers implementers point view reuse makes classes easier develop oofp count intended help predict effort duration needed build system scale factor less 10 used step 4 counting process counting design object model users perspective complicated count actually perceived user system original abstractions present requirements analysis models recovered implementation details affect count might longer strict mapping single classes logical files collections classes may sometimes need counted together single logical file may many different ways identify logical files consider four defined different choices deal aggregations generalization specialization relationships 1 single class count separate class logical file regardless aggregation inheritance relationships 2 aggregations count entire aggregation structure single logical file recursively joining lower level aggregations 3 generalizationspecialization given inheritance hierarchy consider different logical file collection classes comprised entire path root superclass leaf subclass ie inheritance hierarchies merged leaves hierarchy 4 mixed combination options 2 3 insert initialize delete topofpile bottomofpile location visibility collection cards rank display discard card deck shuffle deal hand initial state draw pile draw discard pile draw figure 3 single class ilfs insert initialize delete topofpile bottomofpile location visibility collection cards rank display discard card deck shuffle deal hand initial state draw pile draw discard pile draw figure 4 aggregations ilfs insert initialize delete topofpile bottomofpile location visibility collection cards rank display discard card deck shuffle deal hand initial state draw pile draw discard pile draw figure 5 generalizationspecialization ilfs example figures 36 show different counting boundaries result four strategies sample object model 1 aggregation merging decreases number classes object model 6 5 collectionofcards merged card resulting logical file contains data members methods two classes generalizationspecialization merging projects superclass collectionofcards onto subclasses reducing number logical files 6 5 finally combining aggregation gener alizationspecialization merging first aggregates collectionofcards card projects result onto subclasses collectionofcards resulting 4 logical files conceptually makes sense merge superclasses subclasses oofp counting seems right count leaf classes full inherited structure since instantiated nonleaf classes hierarchy usually instantiated created subsequent reuse deriving subclasses exploiting polymorphism also two classes linked generalization specialization relationship intuitively less complex two separate classes subclass represents refinement superclass 1 model drawn rumbaugh et al 1991 function pointlike measure objectoriented software 11 insert initialize delete topofpile bottomofpile location visibility collection cards rank display discard card hand initial state draw pile draw discard pile draw deck shuffle deal figure 6 mixed ilfs associations may present problem nonleaf classes inheritance hierarchy participate associations replicating superclass association subclass would increase artificially number associations fact original superclass association contributes complexity superclass code implemented merging aggregations single entity oofp counting seems less intuitive objects form aggregations separate objects exist independently methods data members runtime different objects instantiated class aggregation however argued dividing useridentifiable class aggregation subclasses implementation choice point view end user function point measurement philosophy oofp value affected perspec tive aggregation structure merged single class counted single logical file whether right merge aggregations seems depend whether users designers perspective chosen hybrid solution adopted treatment aggregations considered parameter oofp counting process three options identified choice left measurer 1 merge aggregations 2 merge aggregations 3 flag design aggregations considered unique entity must merged 42 logical files considered ilfeif varies according particular ilfeif identification strategy used merging aggregations general 12 giuliano antoniol et al izations generate ilfs eifs correspond sets classes design call composite ilfs eifs distinguish consisting single class called simple ilfeif necessary compute number dets data element types rets record element types rules detret computation slightly different simple composite ilfs eifs cases one ret associated ilfeif represents user recognizable group logically related data ifpug 1994 dets rets ilf eif counted tables used classify ilfeif low average high complexity base tables given ifpug counting practices manual release 40 ifpug 1994 421 simple ilfseifs simple attributes integers strings considered dets since unique user recognizable nonrecursive field ilf eif ifpug 1994 complex attribute oo paradigm attribute whose type class models analogy complex attribute ret ie user recognizable subgroup data elements within ilf eif ifpug 1994 reference another class associations need counted well since contribute functionalitycomplexity object association usually implemented data member referencing associated objects reference used methods invoke associated objects services associations counted dets rets according car dinality singlevalued association considered det ifpug suggests counting det piece data exists user requires relationship another ilf eif maintained 1994 multiplevalued association considered ret entire group references objects maintained one attribute aggregations special case associations simple ilfs eifs treated normal associations 422 composite ilfseifs dets rets counted class within composite summed give overall total composite ilfeif dets rets counted using rules simple ilfs eifs except aggregations aggregations dealt special way composite ilfeif represent subgroup function pointlike measure objectoriented software 13 one ret counted aggregation whatever cardinality ret assigned container class practice values det ret ilfeif computed counting dets rets component class trivial simple ilfeif adding 2 43 service requests service request method class system examined abstract methods counted concrete methods counted class declared even inherited several subclasses coded method counted data types referenced classified simple items analogous dets traditional function points simple data items referenced arguments method simple global variables referenced method items analogous file types referenced ftrs traditional function points complex arguments objects complex global variables referenced method several approaches possible distinguish complex items simple ones example compiler builtin types might considered simple types complex choice might appropriate since userdefined types would counted com plex even scalar types aliases builtin types another approach regard complex item one whose type class reference another class approach used dets ftrs method counted tables used classify method low average high com plexity base tables given ifpug counting practices manual release 40 ifpug 1994 external inputs queries time signature method provides information dets ftrs sometimes especially early even known case method assumed average complexity 2 counting rules defined make detret additive exception aggregation relation handled differently simple composite ilfs however practice contribution aggregation composite ilfs corresponds considering one ret class involved aggregation structure becomes equivalent summing rets component class separately 14 giuliano antoniol et al 44 allowing reuse early count main aim capture useroriented func tionality scale factor used step 4 counting process set 10 user doesnt care class comes class counted full inherent value designers implementers point view reuse makes classes easier develop later count oofp count may intended help predict effort duration needed build system scale factor less 10 would appropriate 45 example figures 36 show four different ways classes object model might merged according four different lf identification strategies used show oofps computed variant service requests service requests methods counted immediately since counted anyway matter classes aggregated logical files signatures unknown methods example method assumed average complexity receive four oofps scored average service request 12 concrete methods model service requests contribute 12 theta oofps logical files counting procedure individual class gives dets rets shown figure 7 class card three dets two due two data items one due manytoone association collectionofcards one ret since class collection related data items collectionofcards two dets due two data items one ret due onetomany aggregation card one ret structure class one ret many dets data items depending ilf identification strategy used four different ilf variants variant merges classes together different ways resulting different total det ret counts table shows result applying ifpug 40 complexity tables variant value low rated 7 oofp according ifpug tables function pointlike measure objectoriented software 15 insert initialize delete topofpile bottomofpile location visibility collection cards rank display discard card deck shuffle deal hand initial state draw pile draw discard pile draw figure 7 detret computation lfs example system table ilf sr complexity contribution collection cards low low card low low deck low low low low hand low low low low discard pile low low low low draw pile low low low low 28 sr oofp 48 48 48 48 total oofp 90 83 83 76 highest oofp count comes class counted single ilf variants effect reducing oofp value reduce number ilfs although increase dets rets merged ilfs enough raise ilf complexity higher values 5 tools counting oofps process computing oofps automated shown figure 8 object models produced case tools translated intermediate representation intermediate representation parsed giuliano antoniol et al oofp translator toolaol tool tool output ast aol parser aol specification oofp counting rules oofp counter omtstp rational rose stp output petal output omtstpaol translator translator petalaol figure 8 oofp computation process producing abstract syntax tree ast oofp counting process applied order independent specific case tool used intermediate language called abstract object language aol devised language generalpurpose design description language capable expressing concepts available design stage object oriented software development language based unified modeling language rational software corporation 1997b superset omt notation becoming standard object oriented design since uml visual description language limited textual specifications design scratch many parts language remaining adherent uml textual specifications available figure 9 shows excerpt aol description object model depicted figure 7 output specific case tool used translated automatically equivalent aol specification one translator imple mented convert output omtstp interactive development environments 1996 aol specification translators maintex 23061999 1427 v p16 function pointlike measure objectoriented software 17 class deck operations class hand attributes operations aggregation container class collectionofcards mult one parts class card mult many generalization collectionofcards subclasses deck hand discardpile drawpile figure 9 excerpt aol specification example object model could implemented case tools rational rose rational software corporation 1997a fully supports uml represents output using language called petal aol specification parsed aol parser producing ast representing object model parser also resolves references identifiers performs simple consistency checking eg names referenced associations defined oofp counter implements oofp counting rules described section 4 oofp counter different measurement counting tools instead assuming specific counting strategy allows one several strategies chosen makes suitable experimentation tool flexible parameterizable respect rules used counting process aol parser oofp counter implemented refine reasoning systems 1990 lexyacc 6 pilot study described methodology applied industrial environment producing software telecommunications first study relationship oofp measure system final maintex 23061999 1427 v p17 giuliano antoniol et al size lines code loc measured number nonblank lines including comments eight subsystems completed application measured eight systems chosen study developed poeple environment using language c design documents final source code avail able measurements design characteristics taken design documents reverse engineered source code table ii shows numbers various design elements system table iii shows size system spreading 5000 50000 lines code table iii also shows oofp count system using four different strategies identifying logical files table ii design characteristics atr attributes aggregation es system atr ope ass agg inh cls four oofp series strongly correlated lowest pearson correlation single class mixed strategies 992 correlations range 998 shown table iii differences methods become appreciable projects large loc values high correlation four oofp series suggests essentially linear transformations case changing strategy identifying logical files might make much difference accuracy size estimation models 61 model evaluation leaveoneout crossvalidation procedure stone 1974 used measure model performance model trained function pointlike measure objectoriented software 19 table iii system sizes oofps system loc g 5807 63 63 19863 1071 1057 1057 1043 f 31011 518 403 483 368 g 47057 1142 1100 1124 1072 data set l sample size currently tested withheld datum step repeated point l accuracy measures averaged n method gives unbiased estimate future performance new data enables quite different models compared directly model error estimated crossvalidation version normalized mean squared error nmse mean squared error normalized variance sample regression based least square minimization assumes distribution errors gaussian statistical tests skewness kurtosis cause hypothesis normality rejected five distributions loc four oofp values given small size data set clear distributions really normal least squares approach sensitive outliers data points far removed data points data minimizes squared deviations outlier almost much influence regression results points combined standard boxand whisker plots identify systems outliers although system h right edge considered outlier impact influential points lessened reducing weight given large residuals example minimizing sum absolute residuals rather sum squared residuals thus another measure errors based absolute values also 20 giuliano antoniol et al considered check inconsistencies due possible influential outlier points measure normalised mean absolute error nmae jy k gammamed j mean median observed values sample l available crossvalidation estimates standard error oe residuals rsquared r 2 fit also computed even crossvalidation care needed interpreting results small sample means observations must regarded indicative rather conclusive 62 models considered several regression techniques considered model relationships loc oofp predictors loc based direct indicators oo size number classes methods design considered comparison first linear models lms table iv based minimizing sum squares residuals developed lf selection method least absolute deviation based l 1 error also applied l1s table iv method minimizes sum absolute values residuals reduce effect large error values robust regression techniques also investigated handle nonobvious outliers family mestimators see appendix considered rregs rlms table iv basic idea msmoothers control influence outliers use nonquadratic local loss function gives less weight extreme observations examples smoothers andrews bisquare fair hampel huber logistic venables ripley 1994 corresponds different weight function finally multivariate linear models developed predict loc directly numbers oo design elements shown table ii 63 results table iv shows models parameterized lf selection methods type regressor model coefficients b 0 b 1 indicated computed full data set estimated model errors nmse nmae shown model estimated rsquared measure also included linear models point concern whether intercept term b 0 included model reasonable suppose existence support code maintex 23061999 1427 v p20 function pointlike measure objectoriented software 21 table iv model performance linear regressors lms l1s robust methods rregs rlms method lma 043 066 069 8505 238 rrega 043 066 8255 240 directly related functionalities counted prediction improved term however intercept term significant nonpredictive fit data importantly fact intercept term always larger smallest system might indicate poor fit small oofp values would interesting apply bayesian procedure select intercept given priors results summarized table iv encouraging example lmg model nmse 38 meaning square error variance less half sample variance another point view models based oofps counted using generalization strategy achieve cross validation average error 47 good best model table iv rregg investigation rregg done results shown table v best predictive accuracy nmse0337 achieved rreglogisticg model tuning parameter corresponds maintex 23061999 1427 v p21 22 giuliano antoniol et al table v model performances different weighting functions mestimator rreg generalization selection method method nmse comments rregfairg 048 converged 50 steps linear predictor model close basic linear model lmg whose equation table iv suggests data set generalization strategy consistently best proven statistically though nonparametric bootstrap approach efron tibshirani 1993 used assess models null hypothesis differences errors lms lmg models cannot rejected similar results obtained models thus clear counting strategy preferred comparison multivariate linear models developed predict loc directly numbers oo design elements shown table ii poorer results obtained models example model based classes methods models based oofp perform much better pilot study conducted specific project environ ment specific organization results encouraging size estimation context issue external validity must addressed extensive studies targeting multiple organizations different projects taken first step empirical investigation needs done function pointlike measure objectoriented software 23 7 discussion results seen table complexity lf always determined low even several classes merged together true service requests tables used determine complexity based ifpug counting practices manual ifpug 1994 quite large numbers rets dets needed reach average high complexity example obtain average complexity weight lf needs det value 20 50 ret value 2 5 due data processing origins function points method doesnt seem apply well kinds systems therefore complexity tables recalibrated provide discrimination implicit assumption use tables complexity class hence size implementation effort required implement increases number complexity attributes increases similarly complexity method hence size development effort assumed implicitly increase number complexity parameters increases 3 whether assumptions true needs determined experimentally assumption seems reasonable classes whole perhaps methods works transactions traditional function points may work methods object model transactions tend much coarse grained methods analysis design stages often information method signature turns unrelated complexity size nothing go counting oofps one possibility would permit designer annotate method complexity rating would introduce subjective element process however want avoid another approach would simply count methods making attempt classify complexity promising approach would take advantage information available use cases scenarios derive complexity rating methods data available us far seems recalibration oofp tables logical files might improve accuracy oofp predictor size recalibration table methods might experimentation needed topic data systems order support experimentation tool used 3 assumptions fairly common underlie philosophy classical function point method also feature design metrics work card glass 1990 giuliano antoniol et al count oofps designed consider table entries parameters modified time pilot study suggests organization reason prefer four strategies indentifying lfs organizations may find differently although organization best size predictions appear obtained generalization strategy superiority proven statistically may accident data modifying complexity tables might make difference determining best strategy selecting lfs counting scheme chosen important applied consistently consistent counting straightforward us since tools used automate process 8 conclusions presented method estimating size object oriented software method based adaptation function points apply object models proposed method takes full advantage information contained object model eliminates ambiguities traditional function points method parameterized order take account closely characteristics specific design environment particular problem defined mapping fp concepts oo concepts described counting process tools developed automate process preliminary results pilot study industrial environment reported results pilot study show promise size estimation important since estimate size needed many effort estimation models summary shown apply concepts function points object oriented software results accurate useful industrial environment future work take several directions one investigate effect recalibrating complexity tables relationships beyond oofps code size studied oofps traditional fps oofps versus effort particular interest another avenue consider impact using design patterns gamma helm johnson vlissides 1995 structure within object models may lead strategies identifying logical ilfs function pointlike measure objectoriented software 25 acknowledgements thank referees constructive comments research funded sodalia spa trento italy contract n 346 sodalia istituto trentino di cultura trento italy work undertaken g caldiera c lokan experimental software engineering group university maryland g antoniol itcirst istituto per la ricerca scientifica e tecnologica i38050 povo trento italy r software function measuring software design quality controlling software projects introduction bootstrap mapping oojacobson approach function point analysis design patterns elements reusable object oriented software applied nonparametric regression software pictures manuals estimating size objectoriented software measuring objectoriented software predictive object points unified modeling language reasoning systems measuring size objectoriented systems estimating costs objectoriented software modern applied statistics splus applying function points object oriented software tr ctr maurizio morisio daniele romano ioannis stamelos quality productivity learning frameworkbased development exploratory case study ieee transactions software engineering v28 n9 p876888 september 2002 marjan heriko ivan rozman ale ivkovi formal representation functional size measurement methods journal systems software v79 n9 p13411358 september 2006 gennaro costagliola filomena ferrucci genoveffa tortora giuliana vitiello class point approach size estimation objectoriented systems ieee transactions software engineering v31 n1 p5274 january 2005 g antoniol r fiutem c lokan objectoriented function points empirical validation empirical software engineering v8 n3 p225254 september
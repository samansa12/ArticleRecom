data dependence analysis assembly code determination data dependences task typically performed highlevel language source code todays optimizing parallelizing compilers little work done field data dependence analysis assembly language code area growing importance eg increasing instructionlevel parallelism central element data dependence analysis case method memory reference disambiguation decides whether two memory operations may access definitely access memory location paper describe new approach determination data dependences assembly code method based sophisticated algorithm symbolic value propagation derive valuebased dependences memory operations instead addressbased dependences integrated method salto system assembly language optimization experimental results show approach greatly improves precision dependence analysis many cases b introduction determination data dependences nowadays often done parallelizing optimizing compiler systems level source code eg c fortran 90 intermediate code eg rtl 21 data dependence analysis level assembly code aims increasing instruction level parallelism using various scheduling techniques like list scheduling 6 trace scheduling 9 percolation scheduling 17 new sequence instructions constructed regard data control dependences properties target processor todays instruction schedulers determine data dependences register accesses consider memory one cell every two memory accesses must assumed data dependent thus analyzing memory accesses becomes important global instruction scheduling 3 paper describe intraprocedural valuebased data dependence analysis see maslov 14 details addressbased valuebased data dependences implemented context salto tool 19 salto framework develop optimization transformation techniques various processors user describes target processor using mixture rtl c language program written assembly code analyzed modified using interface c salto already implemented kind conflict analysis 12 approach determines addressbased dependences register accesses assumes memory one cell analyzing data dependences assembly code must distinguish accesses registers memory cases derive data dependence reaching definitions reaching uses information obtain monotone data flow analysis register analysis makes complications set used defined registers one instruction established easily registers aliases therefore determination data dependences register accesses scope paper memory references solve aliasing problem 22 whether two memory references access location see landi ryder 11 details aliasing prove two references always point location mustalias must show never refer location cannot prove would like conservative approximation alias pairs mayalias ie memory references might refer location derive possible addresses might accessed one memory instruction use symbolic value propagation algorithm compare memory addresses use modification gcd test 23 experimental results indicate many cases method accurate determination data dependences previous methods 2 programming model assumptions following assume risc instruction set memory accessed load ld store st instructions memory references following offset use scaling factor provided model addition would difficult memory accesses normally read write word four bytes global memory access address label first moved register read written using memory instruction initialization registers copying contents one register another done using mv instruction logic arithmetic operators following dest operation op executed operand src 1 operand result written register dest operand register integer constant control flow modeled using unconditional b conditional bcc branch instructions runtimememory divided three classes 1 static global memory stack heap mem ory address unequivocally references one classes simple memory reference disambiguation feasible see section 3 unfortunately easy prove address always references stack interprocedural analysis done one obtain information frame pointer approach make assumptions 3 alias analysis assembly code section briefly review techniques alias analysis memory references alias analysis leads assumption store instruction always dependent load store instruction common technique compiletime instruction schedulers alias analysis instruction inspection scheduler looks two instructions see obvious different memory referenced technique independence memory references fig 1 b proved base register different offsets used different memory classes referenced b fig 1 c shows example technique fails looking register o1 must assumed register point memory location therefore determine s3 data dependent s2 local analysis disables notice definition register o1 first statement example makes clear twofold improvement needed first need save information address arithmetic secondly need kind copypropagation provided algorithm would easy show statement s2 register o1 value fp gamma 20 therefore overlap 4 byte memory blocks starting 4 symbolic value set propagation section present extension wellknown constant propagation algorithm 23 target determination possible symbolic value sets contents register program statement subsequent step analysis information used determination data dependences storage memory accessesmeaning store load instructions calculation symbolic value sets performed data flow analysis 10 therefore model problem data flow framework l f l called data flow information set union operator f set semantic functions semantic functions monotone l forms bounded semilattice one element zero element use general iterative algorithm 10 always terminates yields least fixpoint data flow system 41 data flow information set method describes content register form symbolic values therefore define initialization points program p statement j called initialization point r ij p j load instruction defines content r call node entry node procedure finite set initialization points p given initp finite set sv symbolic values consists symbol proper symbolic values polynomials ij variable r ij symbolic value represents value stored register r initialization point r ij use value cannot make assumptions content register performing static analysis able infer direction branches taken program execu tion therefore could happen register r one symbolic value valid specific program point consequence must describe possible register contents socalled kbounded symbolic value sets limitation sets ensure termination analysis let k 2 n arbitrary fixed kbounded symbolic value set set 1 ld fp4o1 2 st o2fp8 1 ld fp4o1 2 sethi hillc0o2 3 st o3o2lollc0 1 add fp20o1 2 st o2o14 3 ld fp20o3 b c figure 1 sample code different techniques alias detection b solved instruction inspection whereas c needs sophisticated analysis following let regs stand set registers call total map ff state means data flow information set use calculation symbolic value sets given set possible states svs 42 union operator node control flow graph one pre decessor must integrate information stemming predecessors data flow frameworks joining paths flow graph implemented union operator let union operator data flow problem defined shown fig 2 union operator simple componentwise union sets additionally ensure welldefinition operator map arising sets cardinality greater k special value proven fixed k 2 n set states svs conjunction union operator constitutes bounded semilattice one element zero element 43 semantic functions control flow graph chosen analysis node stands uniquely labeled program statement therefore unambiguously assign semantic function nodes semantic function used update symbolic value sets assigned reg ister fig 3 specify semantic functions used method specification ff stands state execution semantic function ff 0 corresponding state execution semantic function execution initialization point r ij knowledge defined value register r main idea method describe register content r definition symbolic value mentioned entry nodes procedure well load instructions initialization points semantic function entry node n initializes symbolic value set register r corresponding initialization point r execution n symbolic value r stands value stored r execution procedure code semantic function assigned load instruction initializes symbolic value set register whose value defined operation similar description corresponding initialization point opposed entry nodes initialization valid initialization point safe call initialization point safe corresponding statement part loop con trast initialization point inside loop called unsafe problem unsafe initialization points value affected register may change loop itera tion therefore cannot make safe assumption initialization value obtain safe approximation case symbolic value set register set special value fig 3 use operator phi extension add operator polynomials result application phi pairwise addition terms b ensure welldefinition operator resulting sets cardinality greater k mapped one operands value operator returns proven semantic functions monotone general iterative algorithm 10 used solve data flow problem 5 improvement value set propagation without limiting cardinality symbolic value sets propagation algorithm may lead infinite sets registers whose contents could change loop iteration responsible phenomenon calculated symbolic value set registers comprises special value inaccuracy analysis cannot accepted practice therefore propose improvement symbolic value set propagation algorithm using registers 51 nsv registers section introduce concept nonsymbolic value registers hereafter called nsv registers nsv register loop g 0 register r used g 0 content figure 2 union operator symbolic value sets n entry n mv arj copy 2 z register r j 2 ff 0 r j fag n add rirjrm add value r r j store result r 2 ff n ld memrj load value address mem register r j 2 ff 0 r j ae fr jn g r jn safe initialization point figure 3 semantic functions instructions change modified propagation algorithm works follows 1 first determine nsv registers loops program sets nsv registers contain among things induction registers registers defined load instruction g 0 2 thereafter nsv register r insert additional nodes control flow graph beginning loop body attach statement n 0 unique unused statement number end loop body node control flow graph reached execution loop insert statement 3 perform symbolic value set propagation modified control flow graph inserted nodes defined semantic functions set symbolic value set r initialization point r 0 init resp setbot consider every initialization point safe improved version algorithm two advantages number iterations general iterative algorithm use data flow analysis reduced ad ditionally compare memory addresses even though depend nsv registers 52 determination nsv registers following let g 0 loop statement inside g 0 statement called loop invariant destination register r defined value loop iteration determination loop invariant statements g 0 performed two steps 1 1 mark statements loop invariant use constants operands operands defined outside g 0 2 iteratively mark untagged statements g 0 loop invariant use operands defined loop invariant statement algorithm terminates statement marked using concept loop invariants determine nsv registers loop g 0 simple way register r nsv register g 0 iff r defined statement g 0 loop invariant statement g 0 fig 4 shows results improved symbolic value set propagation simple program nsv registers loop r1 r2 r3 r4 nsv register init instruction resp setbot instructions inserted program consequence data flow algorithm terminates third iteration concept registers allows accurate analysis memory references inside loop without nsv registers value register r1 would set eventually contrast improved symbolic value propagation always leads proper values 6 data dependence analysis determination data dependences achieved different means commonly used calculation reaching definitions resp reaching uses statements described problem de termining specific statement memory location statements value memory location written last resp used last reaching definitions uses determined able infer defuse defdef usedef associations defuse pair statements indicates true dependence defdef pair output dependence usedef pair antidependence scalar variables determination reaching definitions performed wellknown standard algorithm described 1 use algorithm data dependence analysis assembly code derive mayalias information ie check whether two storage accesses could refer storage object improve accuracy data dependence analysis mustalias information needed ie check whether two storage accesses refer always storage object achieve information need mechanism checks whether index expressions two storage could represent value solve problem applying modified gcd test 23 therefore replace appearances registers x elements corresponding symbolic value sets check possible combinations whether equation solution example refer fig 4 obviously instruction 5 reaching use memory instruction 8 derived memory addresses r respectively assumption instructions executed loop iteration prove different memory addresses accessed means loopindependent data dependence two instructions instructions executed different loop erations r 112 may different values modified gcd test shows instructions may reference memory location therefore assume loopcarried data dependence instructions 5 8 7 implementation results method determining data dependences assembly code presented last sections implemented user function salto sun sparc 10 workstation running solaris 25 presently assembly code sparc v7 processor analyzed extension processors require minimal technical effort results analysis used tools salto evaluation method taken closer look two aspects 1 comparison number data dependences using method method implemented salto shows difference addressbased valuebased dependence analysis concerning register accesses 2 comparison number data dependences using addressbased valuebased dependence analysis memory accesses sample chose 160 procedures sixth public release independent jpeg groups free jpeg software package compression decompression jpeg images distinguish following four levels accuracy level 1 determine addressbased dependences register accesses memory modeled one cell every pair memory accesses assumed data dependent level 2 models memory way level 1 valuebased dependence analysis register accesses level 3 register accesses determined way level 2 analyze memory accesses symbolic value set propagation level 3 derivation dependence addressbased level 4 perform valuebased dependence analysis level 1 analysis performed salto 19 salto consider control flow two instructions assumed data dependent even cannot executed one another level 2 common technique used todays instruction schedulers eg 1 iteration 2 iteration 14 init r3 3 ld r140r3 5 ld r180r4 8 st r3r140 9 add r14r1 19 setbot r4 ble ll11 22 setbot r4 figure 4 symbolic value set propagation registers r mentioned value fr i0 g one gcc 21 one used larus et al 20 systems kind value propagation determine addressbased dependences classified level 3 section 8 closer look techniques value propagation method classified level 4 yet know method also determines valuebased dependences table contains 39 procedures improvement ie less de pendences noticeable level 3 level 4 fig 5 shows number dependences sum true anti output dependences distinguish different levels accuracy well register memory accesses fig 5 also shows two rightmost columns effect valuebased analysis addressbased analysis every procedure clear see proportion data dependences method disproves 8 related work far work done field memory reference disambiguation ellis 8 presented method derive symbolic expressions memory addresses chasing back reaching definitions symbolic register expression simplified using rules al gebra two expressions compared using gcd test method implemented bulldog compiler works intermediate level close highlevel lan guage authors inspired ellis eg lowney et al 13 bockle 4 ebcioglu et al 15 approach presented ebcioglu implemented chameleon compiler 16 works assembly code first procedure transformed ssa form 5 loops malized gathering possible register values procedure name loc level 1 level 2 level 3 level 4 improvement reg mem reg mem reg mem reg mem reg mem test3function shifting signed 33 178 38 87 38 87 31 87 22 51 29 jpeg createcompress 126 4273 1945 423 1945 423 1664 423 1619 90 3 jpeg suppress tables 74 1127 396 143 396 143 229 143 184 87 20 jpeg finish compress 144 10432 2333 1121 2333 1121 2210 1121 2197 89 1 emit byte 42 433 214 119 214 119 189 119 184 73 3 emit dqt 125 4794 1097 575 1097 575 771 575 726 88 6 emit dht 134 5219 1461 589 1461 589 980 589 870 89 11 emit sof 100 6389 1282 661 1282 661 1087 661 1077 90 1 emit sos 100 5252 1285 574 1285 574 873 574 840 89 4 marker 41 561 175 184 175 184 110 184 106 67 4 write frame header 142 4309 1368 679 1368 679 870 679 744 84 14 scan header 86 3656 626 934 626 934 486 934 459 74 6 tables 83 2495 390 716 390 716 324 716 267 71 18 jpeg abort 38 268 84 93 84 93 67 93 63 65 6 jpeg createdecompress 124 4878 1972 507 1972 507 1716 507 1659 90 3 jpeg start decompress 135 4097 902 674 902 674 860 674 856 84 1 post process 2pass 111 2583 1385 278 1385 278 907 278 878 89 3 jpeg read coefficients 113 3783 897 538 897 538 853 538 851 86 1 select file name 104 5631 1146 473 1146 473 714 473 644 92 10 jround 20 jcopy sample rows read 1 byte 48 653 84 186 84 186 70 186 67 72 4 read 2 bytes 93 3115 360 555 360 555 297 555 285 82 4 next marker 42 567 137 305 137 305 112 305 98 46 12 first marker 84 1989 259 360 259 360 197 360 187 82 5 process com 107 6901 979 1147 979 1147 697 1147 592 83 15 process sofn 75 4545 729 670 729 670 601 670 598 85 1 scan jpeg header 34 804 82 306 82 306 78 306 77 62 1 read byte 43 415 105 129 105 129 102 129 97 69 5 read colormap 67 2221 668 305 668 305 583 305 568 86 3 read non rle pixel 40 368 93 125 93 125 84 125 83 66 1 read rle pixel 80 976 289 268 289 268 280 268 279 73 1 jcopy sample rows flush packet 44 468 187 131 187 131 187 131 182 72 3 start output tga 215 12870 3272 974 3272 974 2937 974 2876 92 2 figure 5 number dependences sum true anti output dependences found four levels accuracy results divided registerbased memorybased dependences two rightmost columns show improvement valuebased dependence analysis addressbased dependence analysis technique bulldog compiler used register multiple definitions algorithm described 15 chase reaching definitions whereas concrete implementation chameleon compiler seems support comparing memory addresses makes use gcd test banerjee inequalities 2 23 results method alias information debray et al 7 present approach close use address descriptors represent abstract addresses ie addresses containing symbolic registers address descriptor instruction set mod gamma k residues denotes set offsets relative register defined instruction note address descriptor depends one symbolic register data flow system used propagate values control flow graph mod gamma k sets used bounded semilattice needed tests 64 however leads approximation address representation makes impossible derive mustalias information second drawback definitions register different control flow paths joined set mapped comparing address descriptors reduced comparison modgammak sets using dominator information handle loops cor rectly derive data dependence information 9 conclusions paper presented new method detect data dependences assembly code works two steps first perform symbolic value set propagation using monotone data flow system compute reaching definitions reaching uses register memory access derive valuebased data dependences comparing memory references use modification gcd test known approaches memory reference disambiguation propagate values memory cells remember loading memory causes destination register symbolic value compare two memory references must mind registers defined different instructions may different values even loaded memory address handle situation plan extend method propagate values memory cells software pipelining one major application present work near future family techniques overlaps execution different iterations original loop therefore requires precise dependence analysis additional information distance dependence development work entails particular discovering induction variables possible postpass soon loop invariants known coupling known dependence tests banerjee test omega test 18 considered finally extending method interprocedural analysis would lead accurate dependence analysis presently assume contents almost registers memory cells may changed evaluation procedure call first step could make assumptions use global memory loca tions could derive exact dependences acknowledgments thank referees comments helped improving paper r dependence analysis supercomputing global instruction scheduling superscalar machines exploitation finegrain parallelism efficient method computing static single assignment form experiments local microcode compaction horizontal machines alias analysis executable code compiler vliw architectures trace scheduling technique global microcode compaction monotone data flow analysis frameworks detecting conflicts structure accesses lazy array dataflow dependence analysis study number memory ports multiple instruction issue machines compilerarchitecture interaction treebased vliw processor percolation scheduling parallel compilation technique omega test fast practical integer programming algorithm dependence analysis salto system assemblylanguage transformation optimization instruction scheduling executable editing gnu instruction scheduler limits instructionlevel parallelism supercompilers parallel vector computers tr compilers principles techniques tools detecting conflicts structure accesses array expansion efficient method computing static single assignment form dependence flow graphs algebraic approach program dependencies pointerinduced aliasing problem taxonomy limits instructionlevel parallelism practical algorithm exact array dependence analysis abstract interpretation application logic programs binary translation instructionlevel parallel processing multiflow trace scheduling compiler hierarchical approach instructionlevel parallelization abstract interpretation instruction scheduling executable editing study number memory ports multiple instruction issue machines alias analysis executable code pathsensitive valueflow analysis advanced compiler design implementation dependence analysis supercomputing design analysis computer algorithms walktime techniques exact method analysis valuebased array data dependences data dependence analysis assembly code percolation scheduling parallel compilation technique bulldog ctr thomas reps gogul balakrishnan junghee lim intermediaterepresentation recovery lowlevel code proceedings 2006 acm sigplan symposium partial evaluation semanticsbased program manipulation january 0910 2006 charleston south carolina saurabh chheda osman unsal israel koren c mani krishna csaba andras moritz combining compiler runtime ipc predictions reduce energy next generation architectures proceedings 1st conference computing frontiers april 1416 2004 ischia italy patricio buli veselko gutin extended ansi c processors multimedia extension international journal parallel programming v31 n2 p107136 april
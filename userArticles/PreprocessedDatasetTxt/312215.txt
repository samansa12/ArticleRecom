local labeling resource allocation using preprocessing paper studies power nonrestricted preprocessing communication graph g synchronous reliable system scenario arbitrary preprocessing performed g sequence labeling problems solved different subgraphs g suggest preprocessing produces orientation g goal exploit preprocessing minimizing radius neighborhood around vertex data collected order determine label define set labeling problems done time complexity labeling subgraph depends topology graph g always less minchig olog n2 hand show existence graph even unbounded preprocessing allow fast solution simple labeling problem specifically shown processor needs know omegalog n log log nneighborhood order pick labelfinally derive results resource allocation problem particular show omegalog n log log n communication rounds needed resources fully utilized context define compact coloring problem orientation preprocessing provides fast distributed labeling algorithm algorithm suggests efficient solution resource allocation problem b introduction time required perform certain computations messagepassing systems depends many cases locality information ie distance information forwarded clearly within communication rounds processor get information processors located within distance study problems local ie value processor depends closeby neighborhood attracted much attention eg 13 16 12 18 11 study assumed processors knowledge network topology many common scenarios situation problem solved many times different subnetworks fixed network g might worthwhile conduct preliminary preprocessing g study labeling problems processor pick label subject restrictions labeling whole network allow arbitrary preprocessing g afterwards several instances labeling problem need solved different subnetworks g 0 g processors g participate algorithm particular subnetwork g 0 labeling processors g 0 pick labels assumed system synchronous operates rounds bound message length local computation unlimited furthermore assume system completely reliable preprocessing attempts increase locality problem ie decrease radius preliminary version paper appeared proceedings 8th international workshop distributed algorithms terschelling netherlands septemberoctober 1994 g tel p vitanyi eds pp 194208 lecture notes computer science 857 springerverlag work supported grant 920233 united statesisrael binational science foundation bsf jerusalem israel fund promotion research technion technion vpr funds 2 department computer science technion haifa 32000 israel part work hadas shachnai done ibm tj watson research center yorktown heights ny email hagitcstechnionacil hadascstechnionacil tamicstechnionacil neighborhood processor v needs know order pick label preprocessing present produces orientation assigns priorities processors later processor compute label subgraph considers processors higher priorities define parameter quantifies quality orientations denoted tg tg depends topology g always less minfg olog n 2 g define extendible labeling problems labeled graph extended independent set vertices larger labeled graph without invalidating original labels maximal independent set problem 1coloring problem extendible suggest efficient preprocessing g allows solve problems within tg rounds subgraph g also discuss distributed randomized preprocessing g takes olog n 2 rounds enables solve problems subgraph g within olog n 2 rounds gives distributed randomized algorithm compact coloring barnoy et al 6 shown algorithm provides efficient solutions resource allocation problem large class graphs introduce problem processors communicate processors nonconstant distance even unbounded preprocessing problem k dense coloring restricted coloring problem coloring kdense every vertex color c k neighbor color c validating coloring kdense requires checking neighbors ie processors distance 1 prove exists network processors must know omegagammaeir n log log nneighborhood order pick color networks even unbounded preprocessing allow solve problem locally locality distributed computations first studied cole vishkin showed 9 3coloring ring requires knowledge olog n neighborhood bound shown tight linial 12 general problem computing labels locally studied naor stockmeyer 16 case preprocessing allowed present local algorithms labeling problems whose validity checked locally also show randomization help making labeling problem local followup work mayer naor stockmeyer 15 consider amount initial symmetrybreaking needed order solve certain labeling problems less related works studied coloring maximal independent set problem graphs eg goldberg plotkin shannon 11 szegendy vish wanathan 18 panconesi srinivasan 17 another use graphtheoretic techniques local algorithms appears works sparse partition 2 14 works preprocessing applied order partition graph graphs small diameters given partition possible solve problem locally subgraph compose resulting labels see also survey linial 13 describes works locality distributed computation preprocessing helpful context ongoing problems resource allocation 7 jobs conflicting resource requirements scheduled efficiently instance problem communication graph g vertices represent processors edge pair processors may compete resource resource requirements processor may vary current requirements represented dynamic conflict graph c vertices processors waiting execute jobs edge two processors currently compete resource note c g consider restricted version resource allocation problem schedule kcompact every waiting processor p every k rounds either p runs exists conflicting neighbor p runs guarantees p delayed one conflicting neighbors running lower bound kdense coloring problem implies preprocessing enables distributed kcompact schedule within less omegagammaan n log log n rounds present distributed algorithm compact known upper bound execution time job algorithm uses preprocessing produces torientation response time algorithm degree p c resource allocation problem introduced chandy misra 7 definition known dining philosophers problem resource requirements processors static consider dynamic version problem known drinking philosophers problem several algorithms drinking philosophers problem known without preprocessing best algorithm date 5 achieves log n response time ffi degree p c ffi maximal degree c contrast using preprocessing algorithm achieves response time algorithm relies preprocessing colors communication graph induce priorities processors achieves response time offi 2 presented 8 usage preprocessing induces orientation conflict graph first considered 7 barbosa gafni 4 present theoretical results concerning maximal concurrency may achieved using orientation like algorithms papers orientation used induce priorities processors decrease waiting time processors however work quality graph orientation measured maximal directed length graph corresponds maximal waiting chain particular processor contrast measure quality orientation maximal undirected distance two processors connected directed path allows us combine orientation preprocessing local distributed labeling algorithm resulting waiting time processor bounded small constant although length maximal directed path may equal size graph rest paper organized follows section 2 give basic definitions section 3 study labeling problems derive lower bound labeling problem holds also case unbounded preprocessing allowed introduce torientation preprocessing prove preprocessing provides efficient labeling algorithms certain problems section 4 deals resource allocation problem present lower bound kcompact resource allocation distributed algorithm compact resource allocation using torientation conclude section 5 problems left open work 2 preliminaries model computation consider distributed messagepassing system processors network connecting processors modeled graph vertices correspond processors bidirectional communication link every pair adjacent processors assume system synchronous operates rounds beginning round k 1 processor receives messages sent neighbors end round k local computation processor may send message neighbors bound message length local computation unlimited graph theoretic notions consider directedundirected graph e two vertices v v undirected distance v u g note even g directed distance measured shortest undirected path g v u diameter g diamg max vu2v dv u given vertex v rneighborhood v integer r 0 subgraph g induced vertices u dv u r girth g gg length shortest cycle g set vertices independent two vertices v 0 adjacent independent set maximal contained strictly larger independent set ccoloring g partition v c independent sets equivalently ccoloring mapping specifying vertex color two adjacent vertices color chromatic number g g indicates smallest number c g ccoloring given graph g denote ffi v degree vertex v ie number vertices adjacent let delta maximal degree vertex g g directed vertex v source g incoming edges labeling problems labeling graph e alphabet sigma mapping labeling problem l set labelings intuitively set labelings satisfy certain requirements example ccoloring labeling problem requirement every edge hv ui distributed algorithm solves labeling problem l performing rounds communication processor picks label labeling graph l 3 labeling problems 31 lower bound present labeling problem prove every distributed algorithm solving problem requires least omegagammaast n log log n rounds even unbounded preprocessing problem restricted coloring problem adjacent vertices different labels addition labels close formally definition 31 coloring kdense fixed k 1 every vertex color c k neighbor color c 0 2 intuitively kdense coloring graph every vertex color c k least one neighbor smaller color relatively close c k captures maximal gap colors given labeling graph every vertex v color c validate label examining 1neighborhood label legal v neighbor label c c k v neighbor color c means kdense coloring 1checkable terminology 16 present lower bound result proof shows graph g vertex g v must pick different labels two different subgraphs g 1 g 2 g v 1 log n log log nneighborhoods g 1 g 2 proof uses graphs large chromatic number large girth existence graphs guaranteed following theorem theorem 31 erd os 10 n 1 graph g n vertices g 1log n gg 1log n log following immediate taking corollary 32 n 1 log n exists graph g n vertices g 1log n log log n k gg k log n log log n next lemma shows maximal color kdense coloring tree lower bound trees depth lemma 33 every kdense coloring tree vertex v color c vertex distance least c proof since coloring kdense v must neighbor v 1 cv 1 must neighbor v 2 cv 2 2k general must neighbor v color least c gamma ik path v extended v long therefore length path least c 1 clearly simple path since tree simple path v v c therefore dv v c proves lemma prove main theorem section theorem 34 every k 1 n 1 k 1log exists communication graph g size n subgraph g 0 g every distributed algorithm finds kdense coloring g 0 requires least 1 log n log log n rounds proof assume way contradiction exists algorithm finds kdense coloring within r rounds r 1 log n log log n clearly within r rounds vertex knows rneighborhood proposition 35 let g 1 g 2 two subgraphs g let v vertex g rneighborhood v g 1 identical rneighborhood v g 2 v picks label executing g 1 g 2 corollary 32 exists graph g size n g kr gg 2r assumption finds kdense coloring subgraph g 0 g within r rounds particular finds kdense coloring g since exists vertex v color c kr r neighborhood v g since gg 2r g 0 includes vertices distance r v follows g 0 tree clearly v rneighborhood g g 0 therefore proposition 35 v colored c also g 0 since g 0 tree lemma 33 implies vertex distance c v hence r c 1 hand since c kr k follows r c contradiction remark stating lower bound theorem 34 assume k 1 existence graph g 1 n vertices log log n1 log log n implies similar way every distributed algorithm finds 1dense coloring requires least 1log n log log n rounds 32 efficient labeling using torientation section define class labeling problems show specific preprocessing allows solve efficiently let g 0 g graph labeled clearly within diamg 0 1 rounds processor v 2 g 0 learn g 0 therefore pick label 1 intuitively 1 note g 0 connected diamg labeling problems coloring sufficient processor know connected component g 0 order pick label problems number rounds needed order label g 0 diamg 0 connected component maximal diameter g 0 labeling problems finding number processors g 0 whole graph g 0 known kind fig 1 optimal torientations graphs preprocessing presented section orients edges neighboring processors thereby assigning priorities way processor close vertices oriented ie higher priority show problems including coloring maximal independent set exists labeling algorithm processors label depends vertices higher priority allows processor communicate vertices assumption relatively close 321 torientation graphs require acyclic orientation every vertex close vertices directed path definition 32 torientation graph g acyclic orientation without directed cycles g every two vertices v u directed path v u directed graph du v orientation number graph g denoted tg smallest g torientation note every graph g topological sorting implies acyclic orientation therefore proposition 36 every graph g tg diamg however cases much better example ccoloring g implies 1orientation directing edge v u v u 1orientation since directed paths length c implies proposition 37 every graph g example orientation number ring 1 ring even length 2 ring odd length using 2coloring 3coloring respectively figure 1 includes examples optimal torientations several graphs recall definition torientation requires undirected distance two vertices u v connected directed path bounded comment proposition 37 holds also stronger definition requires directed distance u v bounded therefore expect upper bound g given proposition 37 tightened 2 simple way construct optimal torientation preprocessing collects complete graph topology node locally finds best orientation relies fact local computation power unbounded requires odiamg communication rounds following show moderate computational effort may yield optimal orientation allows us problems diamg rounds needed order label g 0 2 possible gap tg g well demonstrated clique g n vertices find orientations good sense always bounded small polylogarithm n theorem 38 every graph g size n possible find olog n 2 orientation g randomized distributed algorithm within olog n 2 rounds proof every graph partitioned olog n subgraphs diameter every connected component subgraphs olog n done randomized distributed algorithm linial saks 14 within olog n 2 rounds end algorithm every vertex knows id subgraph v belongs ids vertices belong connected component v partition used construct olog n 2 orientation g within ologn additional rounds follows every connected component every subgraph oriented acyclicly eg centralized topological sorting within olog n rounds edges whose endpoints different subgraphs oriented according ids subgraphs edge hv ui oriented clearly orientation acyclic furthermore assume directed path v u path visits subgraphs defined g strictly increasing order therefore visits subgraph since diameter every connected component subgraph olog n dv 322 extendible labeling problems define class labeling problems torientation preprocessing helpful problems labeling constructed extending part graph already labeled definition 33 let e graph extension g graph note v 0 independent set g 0 definition 34 let l labeling problem extension labeling algorithm l every graph g labeling l every extension label ffl labeling g 0 l ffl label v depends connected components g v connected labeling v independent labeling vertices v 0 components g definition 35 labeling problem extendible deterministic extension labeling algorithm argue important labeling problems extendible consider following extension algorithm labeling denoted every v neighbor proposition 39 finding maximal independent set extendible labeling problem proof let e graph legally labeled ie every vertex label v 2 f0 1g vertices independent set g let g extension g clearly extension algorithm maximal independent set problem proposition 310 1coloring extendible labeling problem proof let e graph legally colored ie every vertex label v vertices form independent set let g extension g following clearly extension algorithm problem every v 2 v define v smallest c 2 1g neighbor u v exists v ffi v neighbors therefore ffi v colors used vs neighbors thus g 0 extension algorithm labels vertex smallest color used neighbors suitable kdense coloring problem therefore proposition 311 every k 1 kdense coloring problem extendible 323 algorithm extendible labeling problems show following theorem theorem 312 given torientation graph g extendible labeling problem l distributed algorithm solves l within rounds every subgraph g proof let l extendible labeling problem let deterministic extension algorithm l describe distributed algorithm solves l subgraph g within rounds let g graph acyclic orientation let g 0 subgraph g note torientation g induces acyclic orientation g 0 consider partition g 0 layers l length longest directed path g 0 v 2 g 0 longest directed path v g 0 length note partition well defined since g finite orientation acyclic 313 layer forms independent set proof let v u neighbors g 0 v u every directed path v extended u particular longest one thus u belongs layer higher vs layer every vertex v subgraph g 0 induced v vertices g 0 directed path v v 2 g 0 partition g 0 v layers l 0 g 0 v v k length longest directed path g 0 v partition following properties ffl u v every directed path u g 0 g 0 v u g 0 v ffl particular u v longest directed path u g 0 v therefore every v l consequently u v every l v algorithm consists two stages first stage information collected specifically first rounds every vertex v 2 g 0 distributes distance fact belongs g 0 vertices g participate stage since g toriented vertex v 2 g 0 knows g 0 v within rounds second stage algorithm every vertex v 2 g 0 uses extension algorithm label g 0 v labeling computed iterations ith iteration labels v code v 2 g 0 stage appears figure 2 denote ahv application labeled graph h g 0 v extended independent set v edges connect h v g 0 iteration repeat loop additional layer g 0 v labeled denote label v u label assigned v u 2 g 0 v v executes particular label v v label v assigns alreadylabeled repeat execute aalreadylabeled v alreadylabeled alreadylabeled l g 0 v v labeled fig 2 labeling algorithm code v 2 g 0 next lemma shows labels v assigns vertices g 0 v identical labels vertices assign lemma 314 u v label u label v u proof show induction 0 label u label v u every v base case contains sources g 0 consider note label u u determined first iteration executes u every v u 2 g 0 v assigns label u first iteration executing v may vertices addition u l 0 g 0 v since label u depends connected component includes u since deterministic label u label v u induction step assume claim holds vertices l note label u u determined jth iteration u executes u u every v u 2 g 0 v assigns label v u executes v l j g 0 v connected component u v u induction assumption vertices u v labeled identically v u thus since deterministic label u label v u entire labeling g 0 consists labels label v v lemma 314 identical labeling produced applied g 0 sequentially layer layer thus l theorem 38 corollary 315 every graph g size n randomized preprocessing takes olog n 2 rounds extendible labeling problem solved every note preprocessing suggested results assume n known advance proposition 311 theorem 312 imply every graph g fixed coloring every g 0 g found distributively within rounds assuming existence torientation g particular corollary 315 randomized distributed preprocessing takes olog n 2 rounds enables find kdense coloring every g rounds note lower bound kdense coloring theorem 34 log log n since kdense coloring problem extendible theorem 34 theorem 312 imply corollary 316 let tn maximal tg among graphs size n omegagamma135 n log log n 4 resource allocation section study resource allocation prob lem problem contrast labeling problems ongoing nature repetitively solved instance however shown employ techniques results developed labeling problems instance resource allocation problem communication graph g vertices represent processors edge pair processors may compete resource resource requirements processor may vary current requirements represented formally dynamic conflict graph c vertices processors waiting execute jobs edge two processors compete resource clearly c g denote degree processor p conflict graph c ffi maximum number rounds required complete job algorithm resource allocation problem decides waiting processor use resources execute job satisfy following properties 1 exclusion two conflicting jobs executed simultaneously safety property 2 starvation request processor eventually granted liveness property response time request number rounds elapse processors request use resources executes job good algorithm minimizes response time consider also following property guarantees better exploitation resources reduces average response time definition 41 algorithm resource allocation kcompact every waiting processor p every k rounds either p runs conflicting neighbor p runs section 41 prove every k 1 efficient distributed algorithm kcompact reduction lower bound kdense coloring proved earlier specifically show lower bound ofomegagamma3 n lg lg n response time resource allocation algorithm kcompact k 1 section 42 presents compact coloring problem used later compact resource allocation section 43 present distributed compact algorithm resource allocation uses torientation preprocessing 41 lower bound kcompact resource allocation show given conflict graph c k 1 kcompact resource allocation algorithm used label c labeling k edense coloring together lower bound proved theorem 34 implies lower bound compact resource allocation let g communication graph let c conflict graph oneshot resource allocation problem schedule resources c way satisfies safety liveness conditions slow execution given set jobs execution job uses resources exactly rounds terminology borrowed rhee 19 specific algorithm consider slow execution respect oneshot resource allocation problem algorithm schedule one batch jobs needs resources running time clearly special case resource allocation problem lower bound case applies general problem let 0 first round processor starts executing job starvation property guarantees existence 0 associate processor p label p starts executing job interval interval exists starvation property hence labeling well defined 41 labeling k coloring conflict graph proof mutual exclusion property since execution slow legal coloring assume p 2 p starts executing job interval algorithm kcompact every k rounds either starts executing job exists conflicting processor p j executes job latter case conflicting processor p j starts executing job interval 1 definition p j labeled c 0 together theorem 34 implies theorem 42 every k 1 kcompact distributed algorithm resource allocation problem response time less log n log log n 42 compact coloring section introduce compact coloring problem properties next section use properties show processors joining conflict graph c different times algorithm agree colors processors c definition 42 coloring compact every vertex v color j neighbors colors note every compact coloring 1dense hand consider graph line length 4 whose vertices colored 4 1dense coloring compact given compact coloring let c denote set vertices colored since coloring compact c maximal independent set v n consider following extension algorithm labeling psi denoted c every define psiv smallest number c neighbor u v lemma 43 compact coloring extendible labeling problem next lemma claims remove vertices colored 1 c graph g obtain graph g 0 every vertex v g 0 v colored c g v colored applying c g 0 lemma 44 let e graph let compact coloring g produced c let g graph obtained deleting vertices compact coloring g 0 produced c every proof prove lemma consider algorithm iteratively executes mis extension algorithm given graph g see figure 3 recall labels vertex v 1 v neighbor lower layer labeled otherwise v labeled 0 useful studying c due following claim 45 every graph g labeling phi produced identical labeling psi produced c proof recall given acyclically oriented graph g vertex v ith layer l g longest directed path v length proof induction layers g repeat execute g produced every g empty fig 3 algorithm base case consider vertex v 2 l 0 g note l 0 g contains sources g c color every source v 1 induction step assume claim holds vertices l j let v 2 l g assume consider neighbors v lower layers end iteration k v joins mis k c v colored k v neighbors lower layers colors neighbor lower layers colored k since every iteration produces maximal independent set v neighbors lower layers mis 1 induction hypothesis implies v neighbors colored v joins mis k v neighbor lower layers mis k thus induction hypothesis v neighbor lower layer colored k c therefore needed claim 45 g particular mis 1 g set vertices g claim 45 resulting graph g 0 let phi 0 coloring produced applying g 0 consider execution g removed g first iteration execution since resulting graph g 0 remainder execution g identical execution g 0 execution g 0 identical suffix execution g starting second iteration hence v 2 mis g v 2 mis implies every 1 claim 45 every repeatedly removing set vertices colored 1 obtain corollary 46 let e graph let compact coloring g produced extension algorithm c fixed integer z 0 graph obtained deleting vertices psiv 2 compact coloring g 0 produced c every corollary used resource allocation algorithm show processors joining conflict graph c different times agree colors processors c 43 distributed compact resource allocation algorithm section describe compact distributed algorithm resource allocation problem whose response time orientation number communication graph g assume known advance processors fix running phases consisting rounds addition processors submit requests resources entrance phases consisting tg1 rounds processor wishing execute job waits beginning next entrance phase submits request adds tg1 rounds response time every request partitions rounds entrance phases running phases identical respect processors therefore processors submit requests batches two successive batches algorithm uses preprocessing finds acyclic orientation g achieves orientation number g use denote p oriented p j orientation entrance phases induce orientation dynamic conflict graph c follows edge hp resources earlier entrance phase p j p j p request resources entrance phase entrance phase processors partitioned three sets 1 idle processors need resources processors currently executing jobs 2 requesting processors request resources current entrance phase 3 waiting processors requested resources previous entrance phases still waiting running phase idea algorithm use torientation order merge requesting processors waiting processors manner delay waiting processors provides short response time new requests code processor appears figure 4 section 32 denote c p subgraph c p j 2 c p directed path intuitively algorithm proceeds follows requesting processor p transmits requests collects current state c p upon initial state c p denoted c 0 p running phase p determined compact coloring c 0 p p colored k p executes job kth running phase counting first running phase begins end current entrance phase waiting processors update conflict graph transmit requesting processors beginning entrance phase updated state c p obtained previous one deleting set processors begin executing jobs next first prove every requesting processor p learns processors may influence color entrance phase lemma 47 requesting processor p tg beginning entrance phase proof proof induction entrance phase base case consider processor p requests resources first entrance phase directed paths p contain processors request resources first entrance phase since g toriented distance processor c p p tg therefore p knows c p tg rounds induction step let p processor requests resources rth entrance phase r 1 let directed path p c algorithm processor enters p directed processor earlier entrance phase thus ae divided two parts request resources strictly rth entrance phase every entrance phase need resources next transmit neighbors messages receive order execute job next round receive neighbors part c p consists processors made requests previous entrance phases next tg rounds distribute part c p request transmit neighbors messages receive construct c p combining old part already know parts received last tg rounds use c find compact coloring c p colored k execute job kth running phase every p j colored k p j executes job kth running phase waiting update c p remove processors start executing job next rounds according compact coloring remove processors connected anymore distribute c p neighbors next tg rounds transmit neighbors messages receive fig 4 distributed algorithm code p request resources rth entrance phase two successive entrance phases separated rounds therefore inductive hypothesis p joins p k already knows path algorithm p l receives p k part ae first round rth entrance phase since graph toriented p receives messages vertices rounds reconstruct ae next lemma states every p assignments running phase p j done p p j identical p j colored k compact coloring c 0 p p j going execute job kth running phase counting first running phase begins end p entrance phase lemma 48 every requesting processor p every p running phase assigned p j p k p j executes job phase k proof proof induction entrance phase base case consider processor p requests resources first entrance phase since p j c 0 p submits requests first entrance phase lemma 47 p within rounds lemma 43 compact coloring problem extendible therefore claim 314 refers algorithm c assigns color k p assigns color k p j c 0 p since p start counting round running phases counted identically implies lemma induction step assume induction hypothesis holds processors request resources rth entrance phase let p processor submits requests rth entrance phase algorithm first round phase r every waiting processor p l removes c p l processors start executing jobs entrance phase r according compact coloring calculated p l c p l includes processors request resources rth entrance phase thus induction hypothesis updates reflect correctly current state c p l fact together lemma 47 implies p obtains p within rounds consider processor p two cases case 1 p j processor requests resources entrance phase r definition c p c 0 p j p using claim 314 p j assigns color k p assigns color k p j c 0 p case 2 p j processor requests resources entrance phase r 0 note p include processors request resources p let x ratio length one entrance phase length one running phase denote number first running phase begin rth entrance phase let 0 denote number first running phase begin r 0 th entrance phase assume p j assigns color c 0 entrance phase r 0 algorithm p j execute job running phase addition r gamma r 0 entrance phases r 0 r p j removes c p j processors start executing jobs period formally processors colored p j removed c p j induction hypothesis implies updated c p j beginning rth entrance phase contains processors still waiting corollary 46 compact coloring updated c p j assigns color p claim 314 implies p assigns color c p j c 0 p thus p determines p j executes job running phase number completes proof prove main properties algorithm lemma 49 safety every two processors p p j need p p j run simultaneously proof need neighbors c assume without loss generality legally different colors c p lemma 48 running phase p determines p j identical running phase p j determines therefore belong different running phases thus algorithm p p j run simultaneously show schedule becomes compact 2tg processor initiates request resources lemma 410 every waiting processor p first every rounds either p runs conflicting neighbor p runs proof algorithm every waiting processor p coloring c p compact thus p colored c neighbors colors therefore least one neighbor p runs running phases 1 first running phase count running phases begins 2tg rounds request initiated p hence round schedule compact response time processor p consists three components first p waits beginning next entrance phase takes tg entrance phase p collects c 0 p lemma 47 takes rounds finally p waits running phase compact property lemma 410 p waits ffi running phases taking rounds implies theorem 411 exists algorithm resource allocation problem whose response time remark algorithm ffi captures number processors issued competing resource requests simultaneously p processor delayed processors request resources note general mean algorithm guarantees fifo ordering thus processor issued request later p may execute job earlier p still waiting happens p needs popular resource requested p j 44 discussion presented algorithm assumes system syn chronous local computing power processors unlimited first remark algorithm easily changed work asynchronous systems employing simple synchronizer ff 1 since algorithm rely synchronization neighboring processors synchronizer ff allows run algorithm correctly details straightforward omitted second remark local computation performed algorithm fairly moderate consuming step computation compact coloring done repeated application turn greedily assigns colors nodes furthermore computation integrated collection information neighboring nodes way compact coloring computed iterations overlap iterations information collected local computation node reduces choosing color based colors neighbors 5 conclusions open problems work addressed power unrestricted preprocessing particular torientation preprocessing several open questions remain 1 derive lower bound number communication rounds needed kcompact resource allocation lower bound number communication rounds needed resource allocation algorithm guarantees safety liveness properties 2 lower bound kdense coloring depends k upper bound problem values k bounds tightened particular algorithm kdense coloring whose complexity depends k 3 show torientation preprocessing helps labeling problems helpful types preprocessing 4 show tg olog n 2 every graph g size n exists graph g size n tg omegagamma368 n log log n upper bound reduced ologn log log n particular distributed algorithm achieves better orientation nonrandomized distributed algorithm achieves good orientation 5 nphard determine tg given graph acknowledgments would like thank roy meshulam bringing erdos theorem attention pointing existence graphs omegagamma1 n log log n also thank amotz barnoy helpful discussions anonymous referee provided many comments improved presentation r complexity network synchronization sparse partitions dining philosophers algorithm polynomial response time concurrency heavily loaded neighborhoodconstrained sys tems distributed resource allocation algorithms chromatic sums distributed resource allo cation drinking philosophers problem efficient fault tolerant algorithms distributed systems deterministic coin tossing accelerating cascades micro macro techniques designing parallel algorithms graph theory probability parallel symmetrybreaking sparse graphs distributive algorithmsglobal solutions local data decomposing graphs regions small diameter local computations static dynamic graphs computed locally improved distributed algorithms coloring network decomposition problems locality based graph coloring efficiency partial synchrony tr
ownership types object encapsulation ownership types provide statically enforceable way specifying object encapsulation enable local reasoning program correctness objectoriented languages however type system enforces strict object encapsulation constraining allow efficient implementation important constructs like iterators paper argues right way solve problem allow objects classes defined module privileged access others representations show inner classes approach allows programmers express constructs like iterators yet supports local reasoning correctness classes class inner classes together reasoned module paper also sketches use variant ownership types enable efficient software upgrades persistent object stores b introduction ability reason locally program correctness crucial dealing large programs local reasoning allows correctness dealt one module time module specication describes expected behavior goal prove module satises research supported part darpa contract f306029810237 nsf grant iis9802066 ntt permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copies bear notice full citation first page copy otherwise republish post servers redistribute lists requires prior specific permission andor fee popl03 january 1517 2003 new orleans louisiana usa acm 1581136285030001 500 specication using specications code modules way complexity proof eort formal informal kept control local reasoning approach sound separate verica tion individual modules suces ensure correctness composite program 43 28 key sound local reasoning objectoriented languages object encap sulation consider example stack object implemented using linked list local reasoning correctness stack implementation possible objects outside directly access list nodes ie list nodes encapsulated within paper presents variant ownership types specifying statically enforcing object encapsulation ownership types program declare owns list nodes type system statically ensures list nodes encapsulated within type system enforces strict object encapsulation ever constraining 55 allow ecient implementation important constructs like iterators 48 32 consider example iterator abovementioned stack object iterator encapsulated within cannot used outside iterator encapsulated within cannot directly access list nodes hence cannot run eciently previous ownership type systems either constraining support constructs like iterators 22 21 permissive support local reasoning 20 14 11 example allowed objects outside abovementioned stack object temporarily get direct access list nodes paper argues right way solve problem provide special access privileges objects belonging classes module show inner classes 50 38 variant ownership types allows inner class objects privileged access representations corresponding outer class objects principled violation encapsulation allows programmers express constructs like iterators using inner classes yet supports local reasoning correctness classes system supports local reasoning class inner classes reasoned together module paper also describes variant ownership types enables ecient software upgrades persistent object stores interest software upgrades led us work ownership types paper shows ownership types used ensure code upgrading objects observe broken invariants interfaces unknown time written makes possible programmers reason correctness upgrades paper organized follows section 2 discusses object encapsulation section 3 describes variant ownership types enforcing object encapsulation section 4 presents formal description type system section 5 shows ownership types used enable modular upgrades section 6 discusses related work section 7 concludes object encapsulation object encapsulation important provides ability reason locally program correctness reasoning class objectoriented program involves reasoning behavior objects belonging class typically objects point subobjects used represent containing object local reasoning class correctness possible subobjects fully encapsulated subobjects accessible within containing object condition supports local reasoning ensures outside objects cannot interact subobjects without calling methods containing object therefore containing object control subobjects however full encapsulation often needed encapsulation required subobjects containing object depends 43 28 d1 object x depends subobject x calls methods furthermore calls expose mutable behavior way aects invariants x thus stack object implemented using linked list depends list items contained list code outside could manipulate list could invalidate correctness stack implementation code outside safely use items contained doesnt call methods depends identities items identities never change similarly set immutable elements depend elements even invokes aequalsb ensure two elements b set equal elements immutable local reasoning class possible objects class encapsulate every object depend strict object encapsulation constraining 55 prevents efcient implementation important constructs like iterators example run eciently iterator abovementioned stack object needs access list nodes provide access allow objects like iterators violate encapsulation local reasoning still possible provided violations encapsulation limited code contained mod ule example stack iterator imple o1 every object owner o2 owner either another object world o3 owner object change time o4 ownership relation forms tree rooted world figure 1 ownership properties world figure 2 ownership relation mented module still reason correctness locally examining code module 3 ownership types encapsulation ownership types 22 20 14 11 provide statically enforceable way specifying object encapsulation idea object subobjects depends thus preventing accessible outside section presents ownership type system system similar one described 20the main dierence support constructs like iterators type system 20 allows temporary violations encapsulation disallow violation instead support constructs like iterators using inner classes key type system concept object owner ship every object owner owner either another object special owner called world type system statically guarantees ownership properties shown figure 1 figure 2 presents example ownership relation draw arrow x x owns gure special owner world owns objects o1 o5 o6 o1 owns o2 o4 o2 owns o3 o6 owns o7 ownership allows program statically declare encapsulation boundaries capture dependencies d2 object objects depends system enforces encapsulation inside encapsulation boundary z x outside x cannot access object x accesses object x pointer methods x obtain pointer figure 2 o7 inside encapsulation boundary o6 o1 outside o1 cannot access o7 object allowed access objects owns 2 ancestors ownership tree objects globally accessible objects namely objects owned world 1 thus o1 access objects gure except o3 o7 1 note analogy nested procedures proc p1 fvar x2 class tstackstackowner towner 6 new tnodethis townervalue head 9 pop return value 14 16 class tnodenodeowner towner tnodenodeowner towner next value19 tnodet v tnodenodeowner towner n 22 value return value tnodenodeowner towner next return next class 28 class tstackclient 29 void test new tstackthis new tstackthis world new tstackworld world new tstackworld 34 figure 3 stack objects s1head s1headnext s2head s2headnext s3head s3headnext s1headvalue s2headvalue s1headnextvalue s2headnextvalue s3headnextvalue s3headvalue world figure 4 ownership relation tstacks s1 s2 s3 31 owner polymorphism present type system context javalike language augmented ownership types every class definition parameterized one owners rst owner parameter special identies owner corresponding object owner parameters used propagate ownership information parameterization allows programmers implement generic class whose objects dierent owners parameterization similar parametric polymorphism 54 16 1 61 except parameters owners types owner instantiated world another owner parameter objects owned encapsulated objects cannot accessed outside objects owned world accessed anywhere proc p2 fvar x3 proc p3 fggg say xn1 pn1 children pn pn access 1 pn children 2 ancestors pn children global variables procedures class ccowner sowner towner sowner towner 3 tstacksowner towner figure 5 using clauses constrain owners figure 3 shows example 2 tstack stack ob jects implemented using linked list tstack class parameterized stackowner towner stack owner owns tstack object towner owns objects contained tstack code species tstack object owns nodes list therefore list nodes cannot accessed outside tstack object type tstack s1 instantiated using owner parameters means tstack s1 owned tstackclient object created objects s1 tstack s2 owned tstackclient object objects s2 owned world tstack s3 owned world objects s3 ownership relation s1 s2 s3 depicted figure 4 assuming stacks contain two elements dotted line indicates every object directly indirectly owned world 32 constraints owners every type hx1 xni multiple owners type system statically enforces constraint x1 x f1ng recall figure 1 ownership relation forms tree rooted world notation z means descendant z ownership tree notation z means either z descendant z ownership tree thus type tstack s4 figure 3 illegal world 6 constraint 20 however extend parameterized methods well method object type hx1 xni restriction x1 x 2 f1kg constraints needed provide encapsulation presence subtyping 11 illustrates point example check ownership constraints modularly sometimes necessary programmers specify additional constraints class method parameters example figure 5 type legal sowner towner allow programmers specify additional constraints using clauses 25 54 type system enforces constraints example figure 5 class c species sowner towner instantiation c satisfy constraint illegal 33 subtyping rule declaring subtype rst owner parameter supertype must subtype addition course supertype must satisfy constraints owners rst owners match 2 example shows type annotations written explicitly however many automatically inferred see section 43 details class tstackstackowner towner 3 4 tstackenumenumowner towner elements 5 enumowner towner 6 return new tstackenumenumowner towner 8 class tstackenumenumowner towner 9 implements tenumerationenumowner towner 11 tnodetstackthis towner current13 tstackenum current tstackthishead 15 getnext current null return null 19 return 22 return current null class tstackclient 28 void test 29 tstackthis world new tstackthis world interface tenumerationenumowner towner 36 boolean hasmoreelements figure tstack iterator special corresponding objects thus tstackhstackowner towneri subtype objecthstackowneri thtowneri subtype objecthworldi rst owners match 34 inner classes inner classes similar member inner classes java inner class denitions nested inside classes figure 6 shows example inner class tstackenum implements iterator tstack elements method tstack provides way create iterator tstack tstack code otherwise similar figure 3 recall owner instantiated world another owner parameter within inner class owner also instantiated cthis c outer class feature allows inner object access objects encapsulated within outer objects figure 6 owner current eld intstackenum instantiated tstackthis current eld accesses list nodes encapsulated within outer tstack object inner class parameterized owners like regular class system outer class parameters automatically visible inside inner class inner class uses outer class parameter must explicitly include outer class parameter declaration figure 6 tstackenum declaration includes owner parameter towner outer class towner therefore visible inside tstackenum tstackenum declaration class tstackstackowner towner 3 4 class tstackenumenumowner towner 5 implements tenumerationenumowner towner 7 tnodetstackthis towner current 8 9 getnext writesthis readststackthis 12 14 interface tenumerationenumowner towner boolean hasmoreelements readsthis figure 7 tstack iterator eects include stackowner therefore stackowner visible inside tstackenum note example elements method parameterized enumowner allows program create different iterators dierent owners elements returns iterator type tstackenumhenumowner towneri type legal must case enumowner towner requirement captured clause note also tstackhstackowner towneritstackenum henumowner towneri declared subtype tenu merationhenumowner towneri allows tstackclient create unencapsulated iterator e2 encapsulated tstack program pass e2 objects outside tstackclient general inner classes used implement wrappers 32 expose limited interface outer object program create wrapper around encapsulated subobject pass wrapper object outside encapsulation boundary 35 encapsulation theorem system provides following encapsulation property theorem 1 x access object owned 1 2 x inner class object proof consider code class chf ho g variable type ho declared within static scope class c owner therefore either 1 2 world 3 formal class parameter 4 formal method parameter 5 c 0 c 0 outer class show rst four cases constraint holds rst two cases constraint holds trivially last two cases f f constraint holds fth case c 0 therefore object x class c access object owned rst four cases 2 x inner object fth case class intvector 3 int size reads return elementcount 4 void addint x writesthis elementcount 5 6 8 class intstack 9 intvector new intvector vecaddx 11 figure 8 reasoning aliasing side eects 36 discussion variant ownership types supports local reasoning provided programmer declares dependedon objects owned theorem implies owned objects accessed inside owner inner ob jects therefore ownership captures depends relation described section 2 local reasoning correctness class possible class inner classes together reasoned module ownership types also expressive allow ecient implementation constructs like iterators wrappers 32 furthermore also allow programs create wrappers used contexts underlying object inaccessible ability illustrated figure 6 iterator e2 used globally even though tstack iterating used tstackclient rst ownership type system support constructs like iterators generally accessible wrappers also ensuring local reasoning discuss section 6 37 eects clauses system also contains eects clauses 49 useful specifying assumptions hold method boundaries enable modular reasoning checking programs use eects ownership types enable modular upgrades describe section 5 system allows programmers specify reads writes clauses consider method species writes wn reads r1 rm method write object x call methods write x 2 f1ng method read object call methods read w r j f1mg thus allow method read write objects named writes clause figure 7 shows tstack iterator uses eects otherwise similar tstack iterator figure 6 example hasmoreelements method reads object getnext method reads objects owned tstackthis writes reads object defn class cnhformali extends c constr body body finnerclass eld methg owner formal j world j cnthis constr owner owner j owner 6 owner innerclass defn meth mnhformaliarg eects constr feg eects reads owner writes owner eld fd formal f e new c j xnew c j x j let arge feg j class names eld names method names xy 2 variable names figure 9 grammar eects clauses used conjunction subtyping eects overridden method must subsume eects overriding method sometimes makes dicult specify precisely eects method example dicult specify precisely read eects getnext method tenumeration class tenumer ation expected supertype subtypes like tstack enum tenumeration cannot name specic objects used getnext methods subtypes accommodate cases allow escape mechanism method include world eects clauses ownership types eects used locally reason side eects method calls consider example code figure 8 shows intstack implemented using intvector vec adopted example 44 example method receives two arguments intstack intvector v condition assert statement true v aliased svec example method uses clause specify v 6 6 v since ownership relation forms tree see figure 1 constraint implies v cannot aliased svec furthermore intvectorsize declares reads objects owned intvector intstackpush declares writes reads objects owned intstack therefore possible reason locally vsize spush cannot interfere thus condition assert statement must true 4 type system section presents formal description type system simplify presentation key ideas describe type system context core subset java 33 known classic java 31 add inner classes classic java augment type system ownership types approach however extends whole java similar languages 41 type checking figure 9 presents grammar core type system set rules reasoning typing judgment fieldsoncep class cnhf1n extends c 0 constr ficlass eld methg 2 c constr env owner world world owner formal owner class cnhf1n constr 2 cnhfi 6 9xy method declared class cnhf1n f meth g 2 c method inherited field declared class cnhf1n f eld g 2 c field inherited eld world exp ref assign figure 10 type checking rules judgment meaning defn wellformed class class c owner constraint constr satised eect x subsumed eect wellformed type subtype 2 typing environment e wellformed class c declaresinherits eld class c declaresinherits meth eld eld wellformed eld meth meth wellformed method eects e subsumed rw figure typing judgments p program checked included provide information class denitions e environment providing types free variables e r w must subsume read write eects e type e dene typing environment r w o1n dene type system using judgments figure 11 present rules judgments figure 10 rules use number predicates shown figure 12 predicates based similar predicates 31 simplicity sometimes treat outermost classes rules inner classes class also sometime use cnhfi denote 42 soundness type system type checking rules ensure program welltyped program respects properties described figure 1 complete syntactic proof 63 type soundness constructed dening operational semantics extending operational semantics classic java 31 proving welltyped programs reach error state generalized subject reduction theorem holds welltyped programs subject reduction theorem states semantic interpretation terms type invariant reduction proof straightforward tedious omitted 43 type inference although type system explicitly typed principle would onerous fully annotate every method extra type information instead use combination inference wellchosen defaults signicantly reduce number annotations needed practice 14 11 describe intraprocedural type inference algorithm default types use similar approach 14 11 one thirty lines code changed express java programs ownership type system emphasize approach inference purely intraprocedural infer method signatures types instance vari ables rather uses default completion partial type specications cases minimize required anno tations approach permits separate compilation meaning wfclassesp cycles class hierarchy declared twice p contains two inner classes name either declared inherited fieldsoncep class contains two elds name either declared inherited contains two methods name overriding methods return type parameter types methods overridden read write eects overriding method must superseded overridden methods figure 12 predicates used type checking rules 44 runtime overhead system described purely static type system ownership relations used compiletime type checking preserved runtime consequently programs runtime overhead compared regular java programs fact one way compile run program system convert regular program type checking removing owner parameters constraints owners eects clauses language like java however purely staticallytyped java allows downcasts checked runtime suppose object declared type objecthoi downcast vectorhoei since result operation depends information available runtime type checker cannot verify compiletime e right owner parameter even assume object indeed vec tor safely support downcasts system keep ownership information runtime similar keeping runtime information parameterized types 54 61 10 describes eciently ownership keeping runtime information objects potentially involved downcasts types multiple parameters 5 upgrades persistent object stores section shows ownership types eects clauses used enable modular reasoning correctness upgrades persistent object store desire achieve reasoning motivation work ownership types encapsulation persistent object store 46 5 9 17 18 29 56 contains conventional objects similar one might nd objectoriented language java applications access persistent objects within atomic transactions since necessary ensure consistency stored objects transactions allow concurrent access mask failures upgrades needed system improve object implementations correct errors even change interfaces face changing application requirements includes incompatible changes interfaces new interface support methods old one providing satisfactory solution upgrades persistent object stores longstanding challenge upgrade persistent object store dened set classupgrades one class whose objects need change classupgrade triple holdclass newclass tfi indicates objects belonging oldclass transformed use transform function tf provided programmer objects newclass tf takes oldclass object newly allocated newclass object initializes newclass object oldclass object upgrade infrastructure causes newclass object take identity oldclass object objects used point oldclass object point newclass object upgrade executed transforming objects whose classes replaced however transforms must interfere application access store must performed eciently space time addition must done safely important persistent state corrupted previous approaches 4 7 29 45 56 57 provide satisfactory solution challenges either stop application access database running upgrade keep copies database limit expressive power transforms eg transform functions allowed make method calls system provides ecient solution performs upgrades lazily object transformed application accesses application transaction interrupted run transform function transform runs transaction transaction commits application transaction resumed system also allows later upgrades run parallel earlier ones object several pending transforms run one another upgrade order furthermore transform transaction encounters object pending transform upgrade interrupted like application run pending transform continues execution pending transform commits details found 13 12 47 51 ownership types safe upgrades upgrade system ecient expressive delay application transactions avoids use versions copies objects limit expressive power transform functions also needs support modular reasoning correctness transform functions possible transform function encounters object interfaces invariants existed upgrade started even though reality transform function might run much later application transactions transform transactions use variant ownership types enable modular reasoning correctness transform functions system checks statically whether transform functions satisfy following constraint using ownership eects declarations eects clauses state objects tfs access s1 tfx accesses objects x owns directly transitively transform functions often satisfy s1 ownership frequently captures depends relation discussed section 2 typically transform functions access depended objects discuss 13 support modular reasoning transform functions s1 hold implementation also ensures following s2 object x aected upgrade x accessed object owned x ensure s2 using two mechanisms owned object encapsulated within x type system guarantees x accessed rst owned object shared inner class object x system causes x accessed inner class object rst used upgrade latter mechanism described detail 13 s1 holds prove outororder processing transforms cause problems particular show applications interfere transform functions transform functions unrelated objects interfere transform functions related objects run predetermined order namely object transformed owned subobjects proofs given 13 thus s1 holds ensure transform functions encounter expected interfaces invariants supports modular reasoning transform function reasoned extra method old class 6 related work euclid 41 one rst languages considered problem aliasing 37 stressed need better treatment aliasing objectoriented programs early work islands 36 balloons 3 focused fully encapsulated objects subobjects object access accessible outside object universes 53 also enforces full encapsulation except readonly references however full encapsulation signicantly limits expressiveness often needed work escjava pointed encapsulation required subobjects containing object depends 43 28 escjava unable always enforce encapsulation 61 ownership types encapsulation ownership types provide statically enforceable way specifying object encapsulation proposed 22 formalized 21 systems enforce strict object en capsulation signicantly limiting expressive ness require subtype owners supertype tstackhstackowner towneri cannot subtype objecthstackowneri moreover support iterators prfj 14 scj 11 joe 20 extended ownership types support natural form subtyping without violating encapsulation joe introduces constraint every type multiple owners rst owner owners result joe program create pointer object x object owned prfj scj allow object contain pointers subobjects owned dierent object eects clauses prevent program following point ers systems eectively enforce encapsulation object elds however support constructs like iterators allow method local variables violate encapsulation therefore support local reasoning aliasjava 2 uses ownership types aid program standing like ownership type systems aliasjava allows programmers use ownership information reason aliasing aliasjava also exible ownership type systems however unlike ownership type systems aliasjava enforce encapsulation properties illustrated example 11 ownership types extended inner classes 19 2 however systems enforce property stated section 35 support local reasoning ownership types also used enforce prop erties parameterized racefree java prfj 14 uses based type system prevent data races multithreaded programs safe concurrent java scj 11 extends prevent data races deadlocks systems combined approach enforce object encapsulation well prevent data races deadlocks 11 sketches way recent work 15 59 combines region types 60 24 35 type system statically ensure object encapsulation safe regionbased memory management 62 related type systems linear types 62 unique pointers 51 also used control object aliasing linear types used low level languages support safe explicit memory deallocation 24 track resource usage 26 27 linear types unique pointers orthogonal ownership types two used conjunction provide expressive systems prfj 14 rst system combines ownership types conventional unique pointers recent work 23 proposes better approach allows program specify unique external pointer object internal pointers object subobjects eects clauses 49 useful specifying assumptions must hold method boundaries eects enable modular checking programs prfj 14 rst system combine eects ownership types statically prevent data races 11 20 also combine eects ownership preventing deadlocks program understanding paper uses eects ownership enable lazy upgrades data groups 42 44 used name groups objects eects clause write modular specications presence subtyping ownership types provide alternate way writing modular specications ownership types also used name groups objects eects clause name owner used name objects transitively owned owner figure 8 presents example 44 expressed using ownership types data groups implemented using theorem prover principle exible however pivot uniqueness 44 imposes drastic restrictions pivot elds ownership types impose restrictions require owner object unique 44 owner exclusion constraint hard coded system programmers specify arbitrary constraints owners using clauses owner exclusion used default systems tvla 58 pale 52 roles 40 specify shape local object graph detail ownership types tvla verify properties input program tree output also tree pale verify data structures expressed graph types 39 roles verify global properties participation objects multiple data structures roles also support compositional interprocedural analysis contrast systems take exponential time verication ownership types provide lightweight practical way constrain aliasing conclusions object encapsulation enables sound local reasoning program correctness objectoriented languages ownership types provide way specifying statically enforcing object encapsulation however type system enforces strict object encapsulation constraining allow ecient implementation important constructs like iterators paper argues right way solve problem allow objects classes dened module privileged access others representations show inner classes variant ownership types allows objects inner classes privileged access representations corresponding objects outer classes principled violation encapsulation allows programmers express constructs like iterators wrappers using inner classes system also allows wrappers used global contexts objects wrap yet system supports local reasoning correctness classes class inner classes reasoned together module thus paper describes rst ownership type system expressive enough support iterators wrappers also supporting local reasoning addition paper describes application technique enable modular reasoning upgrades persistent object stores ownership types used purposes well preventing data races deadlocks safe regionbased memory management since ownership types require little programming overhead type checking fast scalable provide several benets oer promising approach making objectoriented programs reliable acknowledgments thank daniel jackson viktor kuncak greg nelson martin rinard alexandru salcianu useful discussions comments earlier drafts paper r adding type parameterization java language alias annotations program understanding balloon types controlling sharing state data types scalable recoverable implementation object evolution pjama 1 platform design issues persistent java typesafe representation independence semantics implementation schema evolution objectoriented databases jps distributed persistent java system safe runtime downcasts ownership types ownership types safe programming preventing data races deadlocks ownership types safe lazy upgrades objectoriented databases lazy modular upgrades persistent object stores parameterized type system racefree java programs making future safe past adding genericity java programming language gemstone data management system shoring persistent applications object ownership containment ownership encapsulation disjointness type e simple ownership types object containment ownership types exible alias protection external uniqueness typed memory management calculus capabilities subtypes vs clauses constraining parametric polymorphism enforcing highlevel protocols lowlevel software adoption focus practical linear types imperative programming wrestling rep exposure story o2 classes mixins design patterns elements reusable objectoriented software java language speci objectoriented eects system islands aliasing protection objectoriented languages geneva convention treatment object aliasing graph types role analysis report programming language euclid data groups specifying modi data abstraction information hiding beyond schema evolution database reorganization providing persistent objects distributed systems safe lazy software upgrades objectoriented databases towards aliasfree pointers pointer assertion logic engine parameterized types java iterators encapsulation object design inc class modi solving shapeanalysis problems languages destructive updating parametric polymorphism java approach translation based ective features linear types change world syntactic approach type soundness tr semantics implementation schema evolution objectoriented databases class modification gemstone objectoriented dbms gemmyampersandndashstone data management system polymorphic effect systems beyond schema evolution database reorganization islands graph types design patterns syntactic approach type soundness shoring persistent applications subtypes vs clauses regionbased memory management parameterized types java adding type parameterization java language classes mixins solving shapeanalysis problems languages destructive updating ownership types flexible alias protection data groups making future safe past typed memory management calculus capabilities confined types typebased race detection java parametric polymorphism java abstraction mechanisms clu enforcing highlevel protocols lowlevel software pointer assertion logic engine role analysis representation independence confinement access control extended abstract parameterized type system racefree java programs adoption focus using data groups specify check side effects regionbased memory management cyclone java language specification ownership types safe programming ownership encapsulation disjointness type effect alias annotations program understanding story o2 objectoriented effects system providing persistent objects distributed systems simple ownership types object containment scalable recoverable implementation object evolution pjama1 platform towards aliasfree pointers iterators encapsulation ctr pradeep kumar modal logic ownership types uniting three worlds companion 21st acm sigplan conference objectoriented programming systems languages applications october 2226 2006 portland oregon usa david l heine monica lam practical flowsensitive contextsensitive c c memory leak detector acm sigplan notices v38 n5 may ana milanova precise identification composition relationships uml class diagrams proceedings 20th ieeeacm international conference automated software engineering november 0711 2005 long beach ca usa alex potanin james noble robert biddle generic ownership practical ownership control programming languages companion 19th annual acm sigplan conference objectoriented programming systems languages applications october 2428 2004 vancouver bc canada yin liu ana milanova ownership immutability inference umlbased object access control proceedings 29th international conference software engineering p323332 may 2026 2007 alex potanin james noble dave clarke robert biddle featherweight generic confinement journal functional programming v16 n6 p793811 november 2006 adrian birka michael ernst practical type system language reference immutability acm sigplan notices v39 n10 october 2004 protecting representation effect encapsulation acm sigplan notices v41 n1 p359371 january 2006 ana milanova composition inference uml class diagrams automated software engineering v14 n2 p179213 june 2007 matthew tschantz michael ernst javari adding reference immutability java acm sigplan notices v40 n10 october 2005 pratibha permandla michael roberson chandrasekhar boyapati type system preventing data races deadlocks java virtual machine language 1 acm sigplan notices v42 n7 july 2007 yu david liu scott f smith interactionbased programming classages acm sigplan notices v40 n10 october 2005 weingan chin florin craciun shengchao qin martin rinard region inference objectoriented language acm sigplan notices v39 n6 may 2004 nathanael schrli andrew p black stphane ducasse objectoriented encapsulation dynamically typed languages acm sigplan notices v39 n10 october 2004 derek rayside lucy mendel daniel jackson dynamic analysis revealing object ownership sharing proceedings 2006 international workshop dynamic systems analysis may 2323 2006 shanghai china tian zhao jens palsberg jan vitek typebased confinement journal functional programming v16 n1 p83128 january 2006 alex potanin james noble dave clarke robert biddle generic ownership generic java acm sigplan notices v41 n10 october 2006 chandrasekhar boyapati alexandru salcianu william beebee jr martin rinard ownership types safe regionbased memory management realtime java acm sigplan notices v38 n5 may david naumann observational purity encapsulation theoretical computer science v376 n3 p205224 may 2007 chandrasekhar boyapati barbara liskov liuba shrira chuanghue moh steven richman lazy modular upgrades persistent object stores acm sigplan notices v38 n11 november david naumann mike barnett towards imperative modules reasoning invariants sharing mutable state theoretical computer science v365 n1 p143168 10 november 2006 peter mller arnd poetzschheffter gary leavens modular invariants layered object structures science computer programming v62 n3 p253286 15 october 2006
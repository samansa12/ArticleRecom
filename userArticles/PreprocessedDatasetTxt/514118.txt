deriving simulation input generator coverage metric formal specification paper presents novel uses functional interface specifications verifying rtl designs demonstrate simulation environment correctness checker functional coverage metric created automatically single specification additionally process exploits structure specification written simple style rules methodology used verify largescale io design stanford flash project b introduction 11 motivation verification engineer start simulating rtl designs must write three verification aids input testbenches stimulate design properties verify behavior functional coverage metric quantify simulation progress would much easier three automatically derived interface protocol specification save great deal work also result fewer bugs test inputs checking properties mechanically derived verified specification motivated advantages developed methodology three aids automatically generated specification furthermore demonstrate specification structured certain style rules allows memory efficient simulation runs primary contributions paper permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copies bear notice full citation first page copy otherwise republish post servers redistribute lists requires prior specific permission andor fee dac 2002 june 1014 2002 new orleans louisiana usa presentation bus protocol specification used simulation automatically generate general set legal input sequences design produce properties check interface protocol conformance define new functional coverage metric bias inputs increase probability hitting uncovered cases new input generation scheme greatly reduces size bdd binary decision diagram 1 used dynamically selecting relevant constraints cycle bycycle basis translating entire specification bdd extracting pure constraining logic discarding conditional logic guard building bdd report successful application methodology verify fabricated working design description new bugs found 12 background many todays digital circuit designs depend tight integration multiple design components components often designed different engineers may divergent interpretations interface protocol glue components together consequently designs may incompatible behave incorrectly combined thus functional interface specifications pivotal successful module integration accordingly solid precise however specifications widely use today still written informally forfeiting opportunity automated analysis logical clarity many cases specifications standard bus protocols buggy ambigu ous contradictory problems resolved formal specification development advantages formal specifications seem clear nonetheless avoided due perceived costvalue problem often considered costly benefits promise specif ically criticized lengthy development time need formal verification training many value correct specification justify costs precious resources allocated pressing design needs thus counter disincentives developing formal specification methodology attacks costvalue problem two angles cost side earlier papers 9 8 project focus first half problem minimizing cost making specification process easier directed attention signallevel specification compiler compiler compiler input generator coverage generated one specification correctness checker design verification simulation done three tools used together simulation correctness checker coverage input generator figure 1 trio verification aids bus protocol descriptions aim since important challenging specify using pci peripheral component bus protocol intel r itaniumtm processor bus protocol examples developed specification style produces correct readable complete specifications less effort freeform ad hoc methods syntactic structuring used methodology languageindependent applied many specification languages smv 6 verilog reflection belief methodology opposed tool language development key achieving stated goal value side latest work series paper focuses second angle costvalue problem increase value formal specification beyond role documentation based idea correct wellstructured specification developed exploited way haphazard incomplete specification cannot particular investigate ways use specification directly generate inputs check behavior monitor coverage goal verify large designs common industry methodology specifically tailored simulationbased verification 13 problem approach given hdl hardware description language component design verify engineer needs various additional machinery fig ure 1 right 1 input logic must logic drive inputs design one method uses random sequences guaranteed comply protocol consequently difficult gauge correctness design inputs may correct focused method directed testing input sequences manually written timeconsuming write difficult get correct 2 output check logic determine correctness components behavior needed manual scrutiny cumber methodology presented scope correctness checking limited interface protocol conformance cannot check higherlevel properties whether output data one port correctly corresponds another ports input data 3 coverage metric complete coverage possible input sequences tested possible must metric quantifies progress verification coverage verification engineer would like know whether functionalities design thoroughly exercised interesting cases reached open area research currently practitioners resort methods little theoretical backing approach foundation methodology unified framework approach three tools generated single source specification figure 1 possible three fundamentally based interface protocol con sequently interface specification used automatically create three current practice verification aids written scratch requires tremendous amount time effort write debug eliminating step methodology enhances productivity shortens development time also thoroughly debugged solid specification invariably leads correct input sequences checking properties coverage met rics correctness core document guarantees correctness derivatives contrast current methods verification aid needs individually debugged advantages pronounced standard interfaces correctness effort concentrated standards committee duplicated among many implementors furthermore change made protocol frequent occurrence indus try one change protocol specification sufficient reflect verification aids regenerated revised document otherwise engineer would determine manually effect change tool derivation behavioral checker straightforward three checker onthefly simulations flags error soon component violates protocol addressed first paper9 specification written form close checker furthermore specification guaranteed executable style rules described section 21 translation hdl checker requires minimal changes 9 bulk current work addresses issue automatically generating input sequences method produces input generator dynamic reactive generated inputs depend previous cycle outputs design verification ad dition inputs always obey protocol generation onepass process mechanism relies solving boolean constraints building traversing bdd structures every clock cycle although input generation using constraint solvers novel approach first use exploit complete structured specification finally new simulation coverage metric introduced automatic input biasing based metric also described although experiments needed validate metrics ef fectiveness main advantage currently specificationbased saves time extra work needed write metric pinpoint interesting scenarios gleaned directly specification document previous works clarke et al also researched problem specifications generators 3 methodology closely related simgen project described 1999 paper 11 yuan et al simgen work focusing practical methods used existing complex designs within framework mainly two features differentiate approach simgen first simgen software uses staticallybuilt bdd represents entire input constraint logic contrast framework dynamically builds appropriate bdd constraint every clock cycle results dramatically smaller bdd two reasons one small percentage protocol logic relevant cycle corresponding bdd always much smaller static bdd representing entire protocol two bdd contains designs input variables contain state variables designs outputs thus pci ex ample instead bdd 161 variables bdd 15 variables order magnitude difference consequently input generation uses exponentially less memory reduction based observation sole role state variables designs outputs determine parts protocol relevant thus required bdd particular cycle otherwise variables needed calculate inputs believe two reasons smaller bdds would hold many interfaces therefore allow input generation large interface may otherwise hindered bdd blowup second difference simgen unlike framework requires users provide input biases unique contribution work automated process determining biases noted advantages possible method exploits structure stylized specification whereas simgen applicable general specifications 2 methodology 21 specification style specification style introduced 9 summarized reader based using multiple constraints collectively define signalling behavior interface constraints short boolean formulas follow certain syntactic rules also independent rely state variables historic information anded together define exactly correct behavior similar using linear branching time temporal logic describing behavior however methodology allows requires basic operators writing constraints aims complete specification opposed ad hoc list properties hold true decomposition protocol multiple constraints many advantages one specification easier maintain constraints added removed independently modified also believed easier write debug since existing naturallanguage specifications already written list rules translation type specification requires less effort results fewer opportunities errors debugging symbolic model checker easily used explore states allowed constraints style rule 1 first style rule requires constraints written following form prevsignal signal signal n logical symbol implies antecedent expression left boolean expression containing interface signal variables auxiliary state variables consequent expression right contains interface signal variables allowed operators negation prev construct allows value signal state state machine cycle ex pressed constraints written implication past expression antecedent current expression con sequent essence past history satisfies antecedent expression requires current consequent expression true otherwise constraint activated interface signals obey consequent current cycle way activating logic constraining logic separated example pci protocol constraint prevtrdystop stop means signals trdy stop true previous cycle activating logic stop must true current cycle constraining logic true signal asserted false signal deasserted separation identifies relevant ieactivated constraints particular cycle also allows bdd expression purely constraining logic explained next section 221 used generating used verified spec 0 spec 1 spec 2 1have implemen tations implementation verified interface three components defined interface input formula active active every clock cycle active a03 c03 antecedent consequent step 3a output component 0 time partial input component 2 find solution figure 2 input generation algorithm style rule 2 second style rule separability rule requires constraint constrain behavior one component equivalently constraining part isolated activating part due first style rule rule requires consequent contain outputs one component style rule 3 third rule requires specification dead state free rule effectively guarantees output satisfying constraints always exists long output sequence far violated constraints universal test verify property specification using model checker following computation tree logic2 property checked constraints violations pinpoint dead state agall constraints true f ar exall constraints true although abiding style rules may seem restrictive promises many benefits furthermore style still powerful enough specify signallevel pci intel r itaniumtm processor bus protocols 22 deriving input generator 221 basic algorithm based following algorithm input vectors generated structured specification figure 2 1 group constraints according interface component specify possible style rule 2 separability rule n interface components n groups 2 remove group whose constraints component verification needed groups constraints 3 group constraints following every clock cycle simulation run goal choose input assignment next cycle constraint evaluate antecedent half antecedent values determined internal state variables observed interface signal values antecedents evaluate true corresponding constraints marked activated b within group together consequent halves activated constraints form input mula result one input formula interface component formulas disjoint support rule 2 greatly reduces complexity finding satisfying assignment c boolean satisfiability solver used determine solution input formulas bddbased solver used instead satbased one order control biasing input variables since specification nondeterministic allows range behaviors likely multiple solutions section 23 discuss solution chosen interesting simulation runs generated chosen solutions form input vector cycle go back step 3a next clock cycle significance style rules become clear al grotihm activating constraining division key allowing dramatically smaller expression consequent halves solve rule 1 separability rule also allows smaller expressions enforcing strict orthogonality specification along interface components rule 2 finally lack dead states guarantees existence correct input vector assignment every clock cycle rule 3 222 implementation compiler tool reads specification outputs corresponding input generation module designed im plemented two parts input generator verilog module acts frontend c module backend figure 3 verilog module contains antecedents constraints based inputs components outputs internal state variables determines constraints activated clock cycle indices activated constraints passed backend c module c module return input assignment satisfies activated constraints verilog module output component verification choice verilog frontend allows many designs used framework c module contains consequent halves constraints forms conjunctions ands activated consequents solves resulting formula returns assignment verilog module initialized array bdds bdd corresponds constraint consequent every clock cycle activation information passed forms one bdd per interface component performing repeated bdd operations activated consequents group resulting bdd represents aggregated constraint next state inputs one component traversing bdd 1true terminal node reached assignment found assignment determined interface component complete input assignment component verification es tablished cudd colorado university decision diagram package 10 version 231 used bdd representation manipulation verilogxl used simulate setup 23 biasing inputs 231 coverage metric use specification define corner cases scenarios required actions complex states problematic component implementations thus simulations drive component scenarios consequently whether verilog module component verification module indices activated constraints assignment input generator interface specified figure 3 implementation details input generator corner case reached used measure simulation progress missed corner cases used determine direction simulations first order approximation corner cases antecedents constraints used antecedent clause true implementation comply constraint clause example consider pci constraint master must raise irdy within 8 cycles assertion frame antecedent counter starts counting assertion frame reached 7 irdy still asserted consequent irdy asserted unless antecedent condition happens simulation compliance constraint cannot completely known simulation run triggered 10 antecedents 10 constraints checked implementation sense number antecedents fired simulation run rough coverage metric one major drawback using metric coverage problem intimately related general relationship implementation specification process design every state designer chooses action choices offered nondeterministic specification create deterministic implementation result implementation cover full range behavior allowed specification thus antecedents specification never true implementation precludes paths state unless verification engineer familiar implementation design cannot know whether antecedent missed lack appropriate simulation vectors structurally impossible 232 deriving biases missed corner cases reach interesting corner cases verification engineers often apply biasing input generation problematic states caused certain inputs true often engineer programs random input generator set variable true n instead neutral 50 time example verify component reacts environment delays response env response engineer set biasing input env response true 5 time 0 used may cause interface deadlock prevailing methods user needs provide biasing numbers random input generator requires expert knowledge design biases must determined hand contrast targeting antecedents interesting biasing derived automatically algorithm works follows 1 gather constraints specify outputs component verified goal antecedents constraints become true simulation runs 2 set biases input signals neutral 50 true input generator described section 22 exactly done explained following subsection 2 true b 98 true c 2 true biasing 2 98 zero one 2 c 2 98 2 98 2 98 50 50 50 50 50 50 50 50 50 50 figure 4 biased bdd traversal 3 run simulation number cycles 4 determine antecedents fired far 5 pick one missed antecedent use determine variable biasing example antecedent abc true set following biases true 2 time b 98 c 2 6 rerun simulation repeat step 4 continue antecedents considered number interesting conclusions first although effort invested determining optimal bias numbers exactly biases simply allowed signal true false often sufficient empirically interpreting often 49 50 times seems work well second antecedent expression contains interface signal variables also counter values variables cannot skewed directly skewing input variables antecedent primary biasing refined secondary biasing done dependency analysis done manually example many hardtoreach cases states counter reached high value dependency analysis biases allow counter increment frequently without resetting determined 233 implementing biasing actual skewing input variables done bdd traversal stage input generation input formula bdd component built structure traversed according biases variable b biased true 49 50 times branch taken 49 50 times figure 4 choice branching forces expression evaluate false ie traversal inevitably leads zero leaf algorithm backtrack else branch taken result even b biased true 49 50 occurrences protocol logic force b false time guaranteed biasing scheme whenever b allowed true constraint likely true extra step added input generation algorithm accommodate biasing variables need reordered biased variables top bdd truth value determined variables figure 5 variable c intended true time however since c buried towards bottom bdd chosen c one zero c 50 50 50 50 2 98 figure 5 incorrect ordering forced false satisfy constraint contrast c top bdd true branch taken long variables set accordingly example 1 fortunately since number bdd variables kept small reordering purpose lead bdd blowup problems compared biasing technique used simgen biasing used framework coarse simgen branching prob abilities take account variable ordering calculated desired biases contrast method directly uses biasing branching probabilities requires calculations compensates possible distortions reordering although implementing simgen calculations difficult advantages achieving precise biasing clear examples attempted 3 experimental results demonstrate methodology meaningful design chose io component stanford flash 5 project verification io unit along rest project extensively debugged fabricated tested part working system operation methods evaluated pci interface component design described 8000 lines verilog contains 283 variables range 1bit 32bit variables complexity renders straightforward model checking unsuitable approximate model checking used govindaraju et al 4 verify design bugs found design inputs overly constrained small state space explored simpler flexible simulationbased checking proved effective finding new bugs setup formal pci specification used constrain inputs check outputs pci interface design simulation checker flags pci protocol violations generated specification using compiler tool written ocaml 7 compiler tool modified output constrained random simulation generator controls pci interface inputs io unit io unit design verification checker input generator connected simulated together results viewed using vcd value change dump file inputs skewed different configurations simulation run order produce various extreme environments stress io unit verification results using 70 assertions provided interface specification nine previously unreported bugs found io unit due incorrect state machine de sign example one bug manifested violating protocol constraint trdy asserted must stay asserted completion data phase incorrect path state machine cases design would assert trdy completion data phase deassert trdy deadlock bus counterparty infinitely waits assertion trdy bug easily corrected removing problematic likely unintended path setup makes env design a0 c0 a2 c2 spec spec useful useful figure two types simulation coverage metric effectiveness verification process much easier process finding signallevel bugs nearly automated effort focus reasoning bug found coverage results unfortunately original intended use coverage metric proved fruitless experiment using antecedents constraints specify component meaningless flash pci design conservative implements small subset specification example design initiates single data phase transactions never initiates multiple data phase transactions thus antecedents remained false structurally impossible become true however using metric ensure environment maximally flexible proved much powerful motivation ensure design compatible component complies interface protocol design stimulated general set inputs using missed antecedents constraints specify environment figure 6 a0 a1 determine biases extremely fruitful design bugs unearthed biasings performance results performance issues speed memory usage pose problems free focus generating interesting simulation inputs however demonstrate scalability method larger designs performance results tabulated simulations run 4 processor sun ultra sparcii 296 mhz system 128gbytes main memory specification provided 63 constraints model environment constraints required 161 boolean variables activating constraining logic separation technique 15 needed bdds consequently bdds used small peak number nodes simulation 193 peak amount memory used 4mbytes furthermore speed slightly sacrificed order achieve space efficiency execution times different settings listed table 2 constraint solving inputs randomly set simulation takes 064s 12000 simulator time steps input generator used execution time increased 57 100s debilitating increase inputs guaranteed correct table also indicates progressively adding signal value dumps correctness checker module coverage monitor modules adds execution time 4 future work better coverage metrics probably deduced speci fication straightforward extension would see whether pairs antecedents become true simulations exploiting structured formal specification uses also interest perhaps incomplete designs automatically augmented specification constraints simulation purposes useful synthesis information extracted specification also experiments determine whether designs big simgentype al number boolean vars spec 161 boolean vars bdd 15 constraints env 63 assertions design 70 peak nodes bdd 193 bdd memory use 4 mbytes bugs found design 9 table 1 interface specification based generation details flash example settings user time system time total random 053s 011s 064s constrained 077s 023s 100s dump 077s 026s 103s monitor 133s 029s 162s coverage 154s 025s 179s table 2 time performance methodology flash example 12000 simulator time steps gorithms handled would validate method ology furthermore extensive experiments quantify speed penalty dynamic bdd building done acknowledgement research supported gsrc contract sa220623106pg2 5 r synthesis synchronization skeletons branching time temporal logic stanford flash multiprocessor specification methodology collection compact properties applied intel itanium processor bus protocol modeling design constraints biasing simulation using bdds tr graphbased algorithms boolean function manipulation stanford flash multiprocessor modeling design constraints biasing simulation using bdds counterexampleguided choice projections approximate symbolic model checking executable protocol specification esl monitorbased formal specification pci specification methodology collection compact properties applied intelmyampersand174 itaniumtm processor bus protocol design synthesis synchronization skeletons using branchingtime temporal logic ctr serdar tasiran yuan yu brannon batson using formal specification model checker monitor direct simulation proceedings 40th conference design automation june 0206 2003 anaheim ca usa yunshan zhu james h kukula generatorbased verification proceedings ieeeacm international conference computeraided design p146 november 0913 youngsu kwon youngil kim chongmin kyung systematic functional coverage metric synthesis hierarchical temporal event relation graph proceedings 41st annual conference design automation june 0711 2004 san diego ca usa jun yuan ken albin adnan aziz carl pixley constraint synthesis environment modeling functional verification proceedings 40th conference design automation june 0206 2003 anaheim ca usa serdar tasiran yuan yu brannon batson linking simulation formal verification higher level ieee design test v21 n6 p472482 november 2004 ed cerny ashvin dsouza kevin harer peihsin ho tony supporting sequential assumptions hybrid verification proceedings 2005 conference asia south pacific design automation january 1821 2005 shanghai china ansuman banerjee bhaskar pal sayantan das abhijeet kumar pallab dasgupta test generation games formal specifications proceedings 43rd annual conference design automation july 2428 2006 san francisco ca usa jun yuan carl pixley adnan aziz ken albin framework constrained functional verification proceedings ieeeacm international conference computeraided design p142 november 0913 smitha shyam valeria bertacco distanceguided hybrid verification guido proceedings conference design automation test europe proceedings march 0610 2006 munich germany shireesh verma ian g harris kiran ramineni interactive presentation automatic generation functional coverage models behavioral verilog descriptions proceedings conference design automation test europe april 1620 2007 nice france alessandro pinto alvise bonivento allberto l sangiovannivincentelli roberto passerone marco sgroi system level design paradigms platformbased design communication synthesis acm transactions design automation electronic systems todaes v11 n3 p537563 july 2006 annette bunker ganesh gopalakrishnan sally mckee formal hardware specification languages protocol compliance verification acm transactions design automation electronic systems todaes v9 n1 p132 january 2004
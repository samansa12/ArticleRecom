compositional programming abstractions mobile computing abstractrecent advances wireless networking technology increasing demand ubiquitous mobile connectivity demonstrate importance providing reliable systems managing reconfiguration disconnection components design systems requires tools techniques appropriate task many formal models computation including unity adequate expressing reconfiguration disconnection therefore inappropriate vehicles investigating impact mobility construction modular composable systems algebraic formalisms calculus proposed modeling mobility paper addresses question whether unity statebased formalism foundation temporal logic extended address concurrent mobile systems process examine new abstractions communication among mobile components express reconfiguration disconnection composed modular fashion b introduction unity 1 approach concurrency influential study distributed systems large part emphasis design aspects programming process rather simply serving tool veri fication technique used derive concurrent algorithms wide range problems specify verify correctness even large software systems 2 ever essentially static structure computations expressed standard unity suitable tool addressing problems faced designers mobile computing systems cellular telephone networks paper addresses problem modeling dynamically reconfiguring distributed systems extension unity methodology refer mobile unity formal models capable expressing reconfiguration explored algebraic perspective 3 denotational perspective 4 5 statebased models naturally express reconfiguration com ponents also algebraic models calculus may adequate expressing reconfiguration clear handle issue disconnection recent work recognized importance introducing location failures concepts mobile process algebras 6 7 8 authors primarily concerned modeling mobile software agents effect host failures systems directly p mccann lucent technologies naperville illinois email mccapresearchbelllabscom gc roman department computer science washington university st louis missouri email romancswustledu address disconnection components continue function correctly independently addition directly modeling reconfiguration dis connection mobile unity attempts address design issues raised mobile computing issues stem characteristics wireless connection nature applications services demanded users new technologies broadly speaking mobile computing leads systems decoupled context dependent brings new challenges implementing illusion locationtransparency examining trends applications services currently implemented system designers hope gain insight fundamentals new domain outline opportunities extensions models computation unity decoupling low bandwidth frequent disconnec tion high latency wireless connection lead decoupled style system architecture disconnections may unavoidable host moves new location may intentional laptop powered conserve battery life systems designed work environment must decoupled opportunis tic decoupled mean applications must able run disconnected weakly connected servers opportunistic means interaction accomplished connectivity available aspects already apparent working systems filesystems databases relax consistency disconnected hosts continue operate 9 10 decoupling corresponds issue modularity system design although case mobility modularity taken new extreme user demands components must continue function even disconnected services used also components must ready interface whatever services provided current location notion component statically composed fixed set services must abandoned separation interfaces component implementations long advocated programming language community notions need revisited dynamic perspective mobile computing context dependencies addition weakly connected mobile computers change location frequently leads demand context dependent services simple example location dependent world wide web browser voelker et al 11 system allows user specify locationdependent queries information current surroundings services available general point view evidenced 12 notes application behavior might depend ieee transactions software engineering vol xx x month 1998 tality current context including current location nearness components like identity nearest printer group individuals present room dynamic nature interaction among components brings unprecedented challenges analogous open software systems components must function correctly myriad configurations might oc cur must also continue function components reconfigured mobile unity although interaction specified basis usually conditioned proximity two components model general express interaction conditioned arbitrary global predicates willingness two components participate interaction presence components presence interference noise wireless link also given collection pairwise interactions compose naturally produce compound interactions may span many components location transparency systems mobileaware require explicit reasoning location context applications naturally make use locationtransparent messaging example mobile ip 13 attempts provide context ternet illustrative mobility management issues must addressed designers previous work 14 modeled mobile ip mobile unity location registration schemes also dealt mally example calculus 15 standard unity 16 although latter work similar application unity mobility deals mainly part algorithm running fixed network indirectly communication mobile nodes fixed network perspective formal modeling location registration provides rich source problems use ex amples mobility management algorithms show even goal transparent mobility designers protocol must face issues brought mobil ity explicit reasoning location location changes required argue given protocol properly implements location transparency also location registration protocols may form basis location contextdependent services might make use location information purposes routing remainder paper organized follows section ii presents brief introduction standard unity modifications made express contextdependent interactions last part section gives proof logic accommodates changes section iii makes use new notation express new abstraction communication called transient sharing section iv continues introducing formally expressing new communication mechanism called transient synchroniza tion concluding remarks presented section v ii mobile unity notation previous work 17 presented notation logic interactions among mobile components pairwise limitation simplified aspects discussion instance sideeffects assignment limited components directly interacting component containing assignment however proof logic presented complex operational sometimes relying sequencing operations define precise semantics paper present simpler expression transient interactions focuses attention implications component mobility basic atomicity assumptions made system model provide proof logic much concise earlier work process generalize interactions include multiple participants new model developed context lowlevel wireless communication order focus essential details transient interaction among mobile com ponents key concept introduced section reactive statement allows modular specification farreaching contextdependent side effects statement one component may using primitive others basis subsequent sections present highlevel language constructs may specified reasoned standard unity recall unity programs simply sets assignment statements execute atomically selected execution weakly fair mannerin infinite computation statement scheduled execution infinitely often two example programs one called sender receiver shown figure 1 program sender starts introducing variables uses declare section abstract variable types sets sequences used freely initially section defines allowed initial conditions program variable referenced section initial value constrained type heart unity program assign section consisting set assignment statements execution program sender weaklyfair interleaving two assignment statements assignment statements single assignment statements general may multiplevalued assigning different righthand expressions several lefthand vari ables statement could written x e x commaseparated list variables e commaseparated list expressions righthand side expressions evaluated current state assignment variables made execution unity program nondeterministic fair infinite interleaving assignment statements produces atomic transformation program state infinite execution selected infinitely often program sender example takes variable bit infinite sequence 1s 0s next value assigned bit chosen mccann roman compositional programming abstractions mobile computing 3 program sender declare initially assign program receiver declare sequence boolean initially assign history fig 1 two standard unity programs nondeterministically neither value may forever excluded program receiver two variables one sequence boolean values contains one assignment statement statement uses notation history delta bit denote sequence resulting appending bit end history expression evaluated righthand side assigned history left hand side essentially growing history sequence one bit execution note yet introduced notion composition two programs considered completely separate entities a1 proof logic rather dealing directly execution sequences formal semantics unity given terms program properties proven text fair interleaving model leads natural definition safety liveness properties based quantification set assignment statements choose use simplified form definitions presented 18 19 operators co transient operator may applied simple nontemporal state predicates constructed variable names constants mathematical operators standard boolean connectives example p q state predicates safety property p co q means program state satisfying p next state assignment executed must satisfy q proof property involves universal quantification statements showing establish q executed state satisfying p notation fpgsfqg standard hoaretriple notation 20 addition quantification also obligated show p q effect takes special statement skip nothing part quantification without qualification cases co would true safety properties could violated execution action nothing example co consider property clearly property holds program sender every statement started state bit 1 0 leaves bit state satisfying 1 0 property example special case co left righthand sides identical property may abbreviated operator stable stable 1 initial conditions satisfy predicate ie invariant written invariant clear context program property applies specified explicitly invariant progress properties expressed notation transient p states predicate p eventually falsified unitys weak fairness assumption defined using quantification transient denotes existence statement executed state satisfying p produces state satisfy p example property transient 0 proven program sender statement sets bit 1 transient operator used construct liveness properties reader may familiar ensures operator unity really conjunction safety liveness property ensures q transient p q ensures operator expresses property program state satisfying p remains state unless q established addition remain forever state satisfying p q ensures express simple progress properties established single computational step proofs complicated progress properties often require use induction show program moves whole sequence steps order achieve goal notion captured leadsto operator written 7 informally property p 7 q means program state satisfying p eventually state satisfying q although may happen one step property p may falsified meantime 4 ieee transactions software engineering vol xx x month 1998 example consider property receiver 1 states receiver ever state length history sequence 3 eventually state length 5 meantime however length sequence may take value 4 satisfies neither side relation proofs leadsto properties carried inductively ensures base case formally rules inference summarized basis p ensures q set predicates rules written hypothesisconclusion form assumption line deduction line basis rule instance allows one conclude p 7 q p ensures q transitivity rule could used proof equation 1 taking p formula q formula r formula 5 disjunction rule useful breaking complicated proof cases proof rules introduced come standard unity also part mobile unity ever notion basic state transition different two models mobile unity express location contextdependent state transitions typify mobile computing although means basic hoare triple must redefined rest unity inference toolkit including rules carrying highlevel reasoning shown preserved a2 composition giving new composition mechanisms mobile unity first describe standard unity mechanisms program composition basic composition mechanism known program union use unity union operator construct new system denoted sender receiver operationally new system consists union program variables ie variables name refer physical memory union assignment statements executed fair atomic interleav ing intersection initial conditions communication sender receiver thus takes place via shared variable bit sender writes infinite sequence 1s 0s variable fairly inter leaved receiver occasionally reads variable build history sequence note receiver may see every value written sender execution fair interleaving turntaking also resulting history generated receiver may duplicate entries assignment statements sender may excluded execution finite amount time another way compose systems use superposition combines components synchronizing statements rather sharing variables superposition underlying program f proceeds adding new statements variables f new statements assign original underlying variables f new statements synchronized statement f allows 1 maintenance history variables change behavior underlying program needed certain kinds proofs 2 construction layered systems underlying layers aware higher layer variables example receiver instead composed via program union could used superposition synchronize assignment history assignments sender update bit thus ensuring would receive exact history values written bit however superposition limited communication take place one direction also like program union essentially static form composition provides fixed relationship components also would require single statement program receiver broken two statements one recording 1s recording 0s challenge mobile computing model system modular fash ion receiver know internal workings sender allows receiver temporarily decoupled sender periods disconnection towards end must investigate novel constructs expressing coordination among compo nents instance receiver get exact history sequence components connected may lose information disconnected major contribution 1 examination program derivation strategies using union superposition basic construction mechanisms purely theoretical standpoint natural ask whether rethink two forms program composition reconsidering fundamentals program interaction abstractions used reasoning composed programs b system structuring two programs sender receiver represent mobile components software running mobile hardware appropriate represent resulting system static composition sender receiver mobile computing systems exhibit reconfiguration disconnection components would like capture essentially new features model composition standard unity union would share variable bit throughout system execution would prohibit dynamic reconfiguration disconnection components section introduce syntactic structure mccann roman compositional programming abstractions mobile computing 5 makes clear distinction parameterized program types processes components sys tem radical departure standard unity isolation namespaces individual processes assume variables associated distinct processes distinct even bear name example variable bit sender earlier example longer automatically shared bit receiver thought distinct variables fully specify process variable name prepended name component appears example senderbit receiverbit separate namespaces programs serve hide variables treat internal default instead universally visible components facilitate modular system specifications impact way program interactions specified situations programs must communicate figure 2 shows system senderreceiver embodies concepts system senderreceiver program sender program receiver components receiver 0 sender 0 interactions fig 2 example system notation system starts declaring name case senderreceiver set programs given structured like standard unity program details elided new feature programs addition program variable stands current location program could placed declare section program vari ables promoted line program name emphasize importance reasoning mobile computations precise semantics location variable discussed section iic assume internals program given figure 1 figure 2 programs really type declarations instantiated components section general program types may parameters bound instan tiations example receiver could declared receiver might instantiated receiver1 1 whole range receiver could instantiated way transient interactions among program instances given interactions section constructs used specifying interactions unique mobile unity introduced section iid leave details section blank developed capture location contextdependent aspects communication components c location mobile computing systems must operate conditions transient connectivity connectivity depend current location components therefore location part model standard unity constrain types program variables place restrictions type location variable may discrete continuous single multidimensional might correspond latitude longitude physically mobile platform may network memory address mobile agent process may explicit control location model assignment new value variable modeling location instance mobile receiver might contain statement newloc function newloc returns new location given current location general assignment could compute new location based arbitrary portions program state current location physically moving system statement would need compiled physical effect like actions mo tors instance mobile code agents scenario statement would effect migrating executing program new host even process exert control location still model movement internal assignment statement occasionally selected execution restrictions movement component reflected statement also may still appear righthand side assignment statements locationdependent behavior internal program interactions disconnected components behave ex pected means components must made aware programs interface sender example must depend presence receiver transmits value unrealistic sender block receiver present however constraints two programs must satisfy connected wish express constraints programs composed cluttering individual components way must aware dependent existence programs argues development coordination language sufficiently powerful express interactions preserve modularity single program running isolation see sections follow composition mechanism certain aspects common unity union traits characteristic superposition new constructs presented although 6 ieee transactions software engineering vol xx x month 1998 primarily motivated need manage contextdependent coordination components interactions section really orthogonal system structur ing one put standalone unity programs well fact formal proof logic abstracts away structuring conventions assumes flat set program variables properly qualified name program appear assignment statements however present construct give example may used interactions section system senderreceiver d1 extra statements suppose sender receiver communicate location wish express fact senderbit copied receiverbit true might begin interactions section receiverbit senderbit kind interaction treated like extra program statement executed interleaved fashion existing program statements predicate following treated like guard statement read statement written copies value senderbit receiverbit two programs location loca tion taken mean programs communicate general predicate may take account arbitrary factors distance components presence components note interaction alone guaranteed propagate every value written sender receiver simply another interleaved statement fairly selected execution pool statements therefore sender may write several values bit extra statement executes even programs colocated receiver may course move away assigning new value receiver value copied also construction receiverhistory necessarily accurate account history bits written receiverbit execution historyrecording action completely unconstrained respect extra statement interleaved fair arbitrary order d2 reactions reactive statement provides mechanism making certain every value written senderbit also appears receiverbit statement would appear interactions section receiverbit senderbit reactsto operationally reactive statement scheduled execute whenever predicate following reactsto true sense statement higher priority statements system general may reactive statements implementing interactions informally reactive statements equal priority executed interleaved fashion much like standard unity program set reactive statements sometimes denoted symbol r continues execute statement would effect executed formally known fixed point r note particular statement idempotent interference reactive statements reaches fixed point one execution section iie show construct captured axiomatic semantics propagation occurs every step either component effectively presents readonly shared variable abstraction receiver program two components colocated later show generalize notion variables shared readwrite fashion multiple components modeled gen eral reactive statements allow modeling side effects given nonreactive statement may executed given context particular arrangement components space d3 inhibitions note even reactive propagation updates senderbit receiver still construct accurate history values appear receiverbit nondeterministic interleaving statements several values may written receiverbit executions statement updates receiverhistory real wireless communication system closely synchronized clocks timing considerations would ensure values read proper moment omit duplicate bits sequence inhibitor provides mechanism constraining unitys nondeterministic scheduler execution statement would undesirable certain global context adding label statement lets us express inhibition modular way without modifying original statement example consider new sender program given figure 3 two statements carry program sender declare initially assign fig 3 new version program sender counts bits label refer first senders0 second senders1 also updates integer counter mccann roman compositional programming abstractions mobile computing 7 flect number bits written far counter serves abstraction realtime clock virtual actual may running program sender assume statement program receiver labeled read example read history history delta bit might add following set clauses interactions section inhibit senders0 sendercounter lengthreceiverhistory sendercounter lengthreceiverhistory inhibit receiverread lengthreceiverhistory sendercounter net effect inhibit p strengthening guard statement conjoining p thus inhibiting execution statement p true inhibitions given constrain execution receiver reads exactly one bit every bit written sender note constraint applies equally well components disconnected unrealistic assume realtime clocks remain roughly synchronized even disconnection even though reactive propagation values cease reactive statements must inhibited d4 transactions reactive propagation inhibitions given execution system append values receiverhistory even two components disconnected thus subsequences receiverhistory containing redundant copies last value written sender actual wireless transmission system receiver indication receipt transmission would build history depended timing constraints model might represented extra third state taken wireless transmission medium assume bit component therefore declared initialized means simply transmission currently taking place transmission bit sender involves placing value communications medium returning quiescent state receiver may reactively record value written transaction provides form sequential execution used statements sender write new values senderbit transaction consists sequence assignment state ments enclosed angle brackets separated semi colons must scheduled specified order nonreactive statements interleaved assignment statements standard unity may viewed singleton transactions note reactive statements allowed execute fixed point semicolon end transaction lets us write new receiver program shown figure 4 first program receiver declare sequence boolean initially assign flag history reactsto bit 6 flag flag 0 reactsto bit fig 4 new version program receiver reacts transactions reactive statement records values written shared bit variable flag added make reactive recording idempotent another reactive statement added reset flag communications medium returns quiescent state transactions may inhibited may reactive e proof logic give logic proving properties programs use constructs execution model assumed nonreactive statement fairly selected execution executed inhibited set reactive statements denoted r allowed execute reaches fixed point next nonreactive statement scheduled addition r allowed execute fixed point substatements transaction reactively augmented statements thus make basic atomic state transitions model denote nonreactive statement denote set nonreactive statements including transactions n thus definitions basic co transient properties become transient even though really possibly inhibited statement augmented reactions still use hoare triple notation fpgs fqg denote executed state satisfying p terminate state satisfying q hoare triple notation appropriate terminating computation first deal statement inhibition following rule holds nonreactive statements whether 8 ieee transactions software engineering vol xx x month 1998 transactions singleton statements fpgs fqg 2 define disjunction predicates inhibit clauses name statement thus first part hypothesis states inhibited state satisfying p q must true state also notation r denotes statement extended execution reactive statement set r singleton nontransactional statements frgs r fqg deduced frgs r fqg 3 h may computed strongest postcondition r respect guessed appropriate take frgsfhg hypothesis standard hoare triple nonaugmented statement notation fp r denotes fixedpoint predicate set reactive statements determined text r must added proof termination carried text reactive statements ignoring statements system accomplished variety standard unity techniques statements consist multiple steps trans action rule w may guessed derived r q appropriate represents sequential composition reactivelyaugmented prefix transaction last subaction equation 3 applied base case rule may seem complicated represents standard axiomatic reasoning ordinary sequential pro grams substatement predicate transformer functionally composed others notation proof logic presented provide tools reasoning concurrent mobile systems apart redefinition basic notion atomic transitions keep rest unity inference toolkit allows us derive complex properties terms primitives following sections show programming notation used construct systems mobile components exhibit much dynamic behavior could easily expressed standard unity iii transient sharing previous sections presented notation logic reasoning systems mobile components section section iv attempt build higher level abstractions lowlevel primitives contribute design systems decoupled contextsensitive successful abstractions familiar designers take account realities mobile computing implementable strong underlying formal foundation obvious starting point communication mechanisms standard unity namely shared variables statement synchro nization section examines variant sharing suited mobile computing systems gives underlying semantics terms notation already developed mobile setting variables two independently moving programs always connected reflected model isolation names paces case senderbit receiverbit earlier example however addition reactive propagation statement interactions section two variables took qualities shared variable two components lo cation value written sender immediately visible receiver semantics reactive statements guarantee propagation happens atomic step statement senders0 senders1 sharing may also appropriate abstraction communication coarser granularity example one might think two mobile hosts communicating via virtual shared packet instead single shared bit realistic lower level protocols exponential backoff providing serialized access communications medium even coarser abstract level might data structures replicated host access serialized distributed algorithm implementing mutual exclusion course algorithm continue guarantee mutual exclusion progress presence disconnection far informal notion transiently shared variable require consistency disconnected follows package notions coordination construct formally specified reasoned running example consider queue documents output printer assume laptop computer connected wireless communication medium wandering range printer maintains local cache queue laptop range printer updates queue atomically propagated expressed transient sharing queue may denoted expression operations queue could include laptop appending deleting items queue printer deleting items head queue finishes job relationship defined formally terms reactive statements propagate changes sharing bidirectional slightly complexity earlier example single reactive statement could propagate values one direction present case need mechanism detecting changes selectively propagating new values therefore add mccann roman compositional programming abstractions mobile computing 9 additional variables program model previous state queue program laptop variable called q printerq program printer variable called reactive statements detect propagate changes printerq printerq laptopq laptopq printerq laptopq laptopq laptopq reactsto laptopq 6 laptopq printerq laptopq laptopq printerq printerq laptopq printerq printerq printerq reactsto printerq 6 printerq laptopq execute history variable different current value variable tracking components connected statement updates history variables well remote copy queue thought echo cancellation remote copy kept history vari able reverse reaction kept disabled addition add statements simply update history vari ables without propagating values components disconnected laptopq printerq laptopq reactsto laptop 6 printer printerq laptopq printerq reactsto printer 6 laptop statements reflect fact disconnection may take place moment one component cannot know change actually propagate remote component local behavior update history variable must exactly cases although reactions given may meet informal expectations shared variable connection continuous subtle issues arise disconnection reconnection allowed instance disconnection takes place laptop printer separate identical copies queue changes made independently instance laptop adds items printer deletes items inconsistent state arises may present problem upon connection semantics given well defined case whichever component makes first assignment reconnected queue copy propagated component may undesirable documents already printed may reinserted queue documents added laptop disconnected may lost instead wiping changes would like integrate according programmerspecified policy inspiration look filesystems databases like 9 10 operate disconnected mode program variables would replicated files records database update propagation possible connectivity available systems also provide way programmer specify reintegration policies indicate values variables take connectivity reestablished period disconnection call engage value programmer may also wish specify values variable upon disconnection call disengage values exam ple print queue example may extended following laptopq printerq laptop engage laptopq delta printerq disengage ffl printerq engage value specifies upon reconnection shared queue take value constructed appending printerq laptopq disengage construct contains two values first assigned laptopq second assigned printerq upon disconnection values given empty laptopq leave printerq untouched justified queue would realistically reside printer periods disconnection laptop would access however documents appended queue laptop appended print queue upon reconnection formally construct would translate reactions take place change connection status detected add auxiliary history variable time record status connection denoted status laptopqprinterq engagement add laptopq printerq status laptopqprinterq laptopq integrates values connection status changes disengagement add laptopq printerq status laptopqprinterq ffl printerq false reactsto status laptopqprinterq printer 6 laptop assigns different values variable connection status changes absence interference statements executes disabled systems like 9 10 definite notion reintegration policies like engage values client reconnects fileserver two replicas come contact specification disengage values may less practical significance unless disconnection predicted advance although feasible rapidly reconfiguring systems like mobile telephone networks may fact good abstraction file hoarding policies 9 carried user prepares take laptop home end workday instance predictable disconnection possible every situa tion example try model directly mobile telephone system users travel base stations without warning also operating system wireless laptop may attempting hide mobility construct description definition readonly transient sharing ax read ax axby ax ax ax reactsto ax 6 axby p axby ax reactsto p readwrite transient sharing engageax p value e engagement 1 ax status axby e e true disengageax p value disengagement 2 ax status axby 1 2 false reactsto status axby p transient sharing notational constructs users written way handle sudden unpredictable disconnection system would also robust network failures directly related location well known results impossibility distributed consensus presence failures 21 providing engage disengage semantics settings possible probabilistic sense may adequate consider instance phenomenon metastable states 22 almost every computing device use today subject probability failure due metastability probability low almost never considered reasoning systems similarly robust implementation engage disengage may possible however basic semantics imply distributed consensus fact implementable transient sharing construct given relationship two variables compositional natural way instance suppose would like distribute print jobs among two different printers could accomplished simply adding another sharing relationship form printerq printer2q true specifies queue shared printer2 always printer would atomic access shared queue could remove items head printed reactsto statements executed fixed point change one three variables propagated two laptop colocated printer transitivity major factor contributing construction modular systems allows statement one component farreaching implicit effects specified explicitly program code component summary notation developed section appears table also breaks construct two unidirectional sharing relationships general combined arbitrary ways remember proofs correctness require proof r terminates every construction correct example cycles sharing relationship two different variables given cycle set distinct values assignment statement possible prove termination analagous unitys restriction statement assigns unique value lefthand variable also termination r may difficult prove engagement disengagement values cause predicates change value transient sharing abstraction presented shown promise way manage complexity con current mobile systems based familiar programming paradigm shared memory provides mechanism expressing highly decoupled contextdependent sys tems abstraction apparently good one lowlevel wireless communication mutual exclusion protocols implement abstraction coarser level granularity may simple generalizations existing repli cation transaction consistency algorithms section presented formal definition concept facilitates reasoning systems make use iv transient synchronization previous section presented new abstractions shared state among mobile components sharing necessarily transient location dependent components involved execute asynchronously ever synchronous execution statements also central part many models distributed systems section investigate new highlevel constructs synchronizing statements system mobile components trying generalize synchronization mechanisms existing nonmobile models example csp 23 provides 1 engagement used without corresponding disengagement extra reaction must added reset status axby false p becomes false similarly disengagement used without corresponding en gagement extra reaction must added set status axby true p becomes true mccann roman compositional programming abstractions mobile computing 11 general model computation carried static set sequential processes communication cluding pure synchronization accomplished via blocking asymmetric synchronous twoparty interactions called putoutput commands io automata model 24 communication via synchronization named output action possibly many input actions name statement synchronization also part unity model provides methodology proving properties systems expressed history variables construction layered sys tems synchronous composition also used refinement process 25 although emphasis composition mobile programs rather refinement unity synchronous execution expressed via su perposition new system constructed underlying program collection new statements goal preserve properties underlying program new system new statements must assign values variables underlying program way execution behaviors allowed underlying program executing isolation also allowed new superposed system properties underlying program mention underlying variables proven text underlying program preserved augmented statements may used keep histories underlying variables present abstraction underlying system service higher layer environment unity superposition excellent example synchronization used part design methodology distributed systems also shows important distinction notion synchronization construction new atomic statements two simpler atomic statements executing par allel notion synchronous computing system model characterized bounded communication computation delays 26 latter important component current understanding distributed systems many circumstances perhaps prerequisite implementation former focus rather examine mechanisms allow us compose programs combine group statements new one parallel execution idea statement coexecution inspired unity superposition however superposition limited two important ways first superposed system statically defined synchronization relationships fixed throughout execution system continuing theme modeling mobility kind transient program composition would like ability specify dynamically changing location dependent forms synchronization participants may enter leave synchronization relationships computation evolves static forms statement synchronization limited discussed 27 second superposition asymmetric relationship subsumes one program another disallows communication superposed underlying program source strong formal results program properties restriction may appropriate mobile computing domain two programs may desire make use others services carry bidirectional communication making use abstraction synchronization inspired unity superposition combines statements new atomic actions explore synchronization mechanisms mobile computing main take form coordination constructs involving statements two separate programs informally idea allow programmer specify two statements combined one atomic action given condition true exam ple consider two programs b contains integer x b contains integer assume statement named increment program aincrement increment bincrement increment let us assume programs mobile contains variable communicate colocated also assume counters represent value must incremented simultaneously two hosts together might use following notation interactions section specify coordination aincrement ed bincrement note prohibit statements executing independently programs co located correctness criteria state counters must remain synchronized times could add following two inhibit clauses interactions section inhibit aincrement inhibit bincrement distinct standard unity superposition ed construct mechanism synchronizing pairs statements rather specifying transformation underlying program also interaction transient location dependent instead static fixed throughout system execution reason formally transient statement synchro nization must express using lowerlevel primitives basic idea statement react selection execution executed atomic step accomplish separating selection statement actual execution assume example statement form asdriver phase go phase idlei asactionkas f false reactsto phase f true reactsto phase idle 5 phase auxiliary variable hold value set fgo idleg asaction actual assignment must take place note asaction reacts value go phase f simultaneously set false action executes phase returns idle flag f reset true cycle occur nonreactive statement asdriver selected fairly along nonreactive statements asaction reacts transaction net effect asaction listed simple nonreactive state ment however expressing statement three lines gives us access control key parts statement selection execution process im portantly provide statement synchronization simply sharing phase variable two statements assuming statements form given equation 5 define ed ed bt r delta whenever one statements selected execution executing asdriver btdriver corresponding phase variable propagate statement reactive execution btaction asaction pro ceed also transitive multiway sharing give us transitive multiway synchronization note wish disable participants executing inhibit must sure inhibit participants level named driver transactions inhibit may still fire reactively ed used synchronize statements inhibited call ed operator coselection represents simultaneous selection statements execution used interactions section sys tem embodies assumption statement execution controlled phase variable equation 6 semantics equations 5 6 really guarantee simultaneous execution statements sense unity k rather statements executed interleaved order r many cases equivalent simultaneous execution neither statement evaluate variables assigned however may cases desire statements evaluate right handsides old state without using values set statement cases add another computation phase equation 5 models evaluation righthand sides separate step assignment lefthand variables asdriver phase load phase store phase idlei asloadkas lf false reactsto phase load lf asstorekas sf false reactsto phase store sf reactsto phase idle 7 phase variables may hold values set fload store idleg original asaction split two statements one evaluating one assigning asload assumed evaluate righthand side asaction store results internal variables given explicitly asstore assumed assign values lefthand variables asaction way statements still synchronized sharing phase variables equation 6 statements evaluate righthand sides load phase assign lefthand variables store phase reset two flags idle phase prevents interference two synchronized statements even two connected indirectly long chain synchronization relationships even variables assigned statements shared indirectly example return increment example consider following set interactions aincrement ed bincrement statements aincrement bincrement syn chronized variable ax indirectly shared variable via intermediate variable cz predicate r true increment statements form given equation 5 changes one variable may inadvertently used computing incremented value variable seems violate intuitive semantics simultaneous execution con trast increment statements form given equation 7 separate load phase computing righthand sides assignment statements shared variables assigned phase assignment shared variables associated reactive propagation values reserved store phase isolates assignment statements one another prevents unwanted communication may situations however wish two statements communicate synchronized exe cution strategy central models like csp io automata communication occurs along synchronized execution statements csp channel used communicate value single sender single receiver io automata pass arbitrary parameters output statement samenamed input mccann roman compositional programming abstractions mobile computing 13 statements example give construction expresses io automatastyle synchronization recall automaton set input actions set internal actions set output actions execution action may modify state machine belongs addition execution output action takes place simultaneously execution input actions name machines assume output actions form similar equation 5 important addition asdriver params exp phase go phase idlei asactionkas f false reactsto phase f true reactsto phase idle 8 added assignment params exp first statement transaction assignment models binding output parameters list auxiliary variables params exp assumed vector expressions may reference program variables example assume moment function aincrement statement earlier example increment variable value e function current state assume also bincrement must increment amount two colocated value could modeled parameter aincrement p synchronization aincrement would form given equation 8 aincrementdriver hincrement p e increment phase go increment phase idlei x increment p kas f false reactsto phase f true reactsto phase idle bincrement could also form perhaps different expression e increment value could express sharing parameter interaction aincrement synchronization statements aincrement ed bincrement thus either statement may execute driver transaction first phase assigns value parameter propagated component second phase triggers execution statements third resets flags associated statement easily make use guards statements specify many different interesting forms synchronization use appropriately tailored inhibit clauses example addition definition coselection defined equations 5 6 specify notion coexecution added meaning colocated statements may execute guards enabled might defined coexecuteas bt r phase bt phase r inhibit asdriver r asguard btguard inhibit btdriver r asguard btguard still allows statements execute isolation colocated contrast might require statements may execute isolation disconnected call exclusive coexecution could specified xcoexecuteas bt r phase bt phase r inhibit asdriver r asguard btguard inhibit btdriver r asguard btguard similar notion exclusive coselection could defined ignore guards statements xcoselectas bt r phase bt phase r inhibit asdriver r inhibit btdriver r constructions could generalized pass parameters sender receiver general driver statements form specified equation 8 either statement may bind parameters propagate long sharing specified bidirectional driver statement inhibited semantics transaction mean finish another allowed begin ambiguity statement currently executing conflict assigning parameters synchronized execution also could used statements form equation 7 instead equation 5 provide truly simultaneous access instead interleaved access shared variables might referenced assigned various actions contrast symmetric forms synchronization considered far coordination actions models io automata csp asymmetric model actions divided input output classes parameters passed output actions input actions two models differ number participants synchronization io automata capable expressing onetomany synchronization styles csp emphasizes pairwise rendezvous output actions input actions synchronization styles expressed mobile unity appropriate use transactions variable sharing inhibitions example onetomany synchronization parameter passing simulated 14 ieee transactions software engineering vol xx x month 1998 quantified set oneway variable sharing relationships output statement executes transaction input statements simply reactive rendezvous style synchronization phase variable must propagated one input action ensured flag set first nondeterministically chosen reactive statement prevents propagations taking place course aspects csp dynamic creation deletion terms could easily captured unitystyle model fundamental differences underlying approaches similarly discussion io automata assumed acceptable model whole set ioa actions one parameterized unity action may appropriate every case even modeling basic synchronization mechanisms two models mobile unity useful exercise point examining many different forms synchronization show versatility broad applicability model field mobile computing new cannot predict highlevel abstractions become dominant gain acceptance research community however believe examples show mobile unity least formalize direct generalizations mobile setting existing mechanisms synchronous statement execution models nonmobile concurrency good reason believe capable expressing new constructs may proposed future v discussion mobile unity notation logic presented paper result careful reevaluation implications mobility unity took starting point notion mobile components modeled programs explicit addition auxiliary variable representing location interactions components modeled form dynamic program composition addition coordination constructs unitystyle composition including union super position led new set basic programming constructs amenable dynamic mobile setting previous work extended unity proof logic handle pairwise forms interaction paper presented modular compositional construction transient sharing synchronization allowed multiparty interactions among components applied constructs lowlevel communication task attempt show basic notation useful realistic specifications involving discon nection seemingly strong reactive semantics matched well need express dynamically changing sideeffects atomic actions finally explored expressive power new notation examining new transient forms shared variables synchronization mostly natural extensions comparable nonmobile abstractions interprocess communicationindeed others may propose radically different communication abstractions mobile computing notation able express formally extensions considered promises useful research tool investigating whatever new abstractions may appear plans future work include application mobile unity distributed databases consistency semantics capable continuing operation presence disconnection problems recently received attention engineering research community formal reasoning important role play communicating understanding proposed solutions well assumptions made vi acknowledgements paper based upon work supported part national science foundation united states grant numbers ccr9217751 ccr9624815 opinions findings conclusions recommendations expressed paper authors necessarily reflect views national science foundation r parallel program design foundation formal derivation concurrent pro grams example industry calculus mobile processes foundations actor semantics actors model concurrent computation distributed systems asynchronous model locality fail ure process mobility distributed processes location failures experience disconnected operation mobile computing environment managing update conflicts bayou weakly connected replicated storage system mobisaic information system mobile wireless computing environment contextaware computing applications ip mobility support mobile unity coordination constructs applied packet forwarding mobile hosts algebraic verification mobile network specification proof algorithm location management mobile communication devices mobile unity reasoning specification mobile comput ing logic concurrent programming safety logic concurrent programming progress axiomatic basis computer programming impossibility distributed consensus one faulty process anomalous behavior synchronizer arbiter circuits communicating sequential processes introduction putoutput automata fundamentals objectoriented specification modeling collective behaviors minimal synchronism needed distributed consensus dynamic synchrony among atomic actions tr ctr gruiacatalin roman amy l murphy rapid development dependable applications ad hoc networks acm sigsoft software engineering notes v25 n1 p7778 jan 2000 gian pietro picco amy l murphy gruiacatalin roman developing mobile computing applications lime proceedings 22nd international conference software engineering p766769 june 0411 2000 limerick ireland gruiacatalin roman christine julien jamie payton modeling adaptive behaviors context unity theoretical computer science v376 n3 p185204 may 2007 camelia zlatea tzilla elrad design methodology mobile distributed applications based unity formalism communicationclosed layering proceedings eighteenth annual acm symposium principles distributed computing p284 may 0406 1999 atlanta georgia united states cecilia mascolo gian pietro picco gruiacatalin roman finegrained model code mobility acm sigsoft software engineering notes v24 n6 p3956 nov 1999 l murphy gc roman g varghese exercise formal reasoning mobile communications proceedings 9th international workshop software specification design p25 april 1618 1998 gian pietro picco amy l murphy gruiacatalin roman lime linda meets mobility proceedings 21st international conference software engineering p368377 may 1622 1999 los angeles california united states gruiacatalin roman peter j mccann notation logic mobile computing formal methods system design v20 n1 p4768 january 2002 guido menkhaus architecture supporting multidevice clientadaptive services annals software engineering v13 n14 p309327 june 2002 tore fjellheim stephen milliner marlon dumas julien vayssire processbased methodology designing eventbased mobile composite applications data knowledge engineering v61 n1 p622 april 2007 cecilia mascolo gian pietro picco gruiacatalin roman codeweave exploring finegrained mobility code automated software engineering v11 n3 p207243 june 2004 k gupta p k srimani adaptive core selection migration method multicast routing mobile ad hoc networks ieee transactions parallel distributed systems v14 n1 p2738 january gruiacatalin roman jamie payton principled exploration coordination models theoretical computer science v336 n23 p367401 26 may 2005 peter j mccann gruiacatalin roman modeling mobile ip mobile unity acm transactions software engineering methodology tosem v8 n2 p115146 april 1999 ichiro satoh building selecting mobile agents network management journal network systems management v14 n1 p147169 march 2006 gianluigi ferrari c montangero l semini semprini mark reasoning kit mobility automated software engineering v9 n2 p137150 april 2002 michel wermelinger jos luiz fiadeiro graph transformation approach software architecture reconfiguration science computer programming v44 n2 p133155 august 2002 gian pietro picco gruiacatalin roman peter j mccann reasoning code mobility mobile unity acm transactions software engineering methodology tosem v10 n3 p338395 july 2001 michel wermelinger jos luiz fiadeiro algebraic software architecture reconfiguration acm sigsoft software engineering notes v24 n6 p393409 nov 1999 wolfgang emmerich cecilia mascolo anthony finkelstein implementing incremental code migration xml proceedings 22nd international conference software engineering p397406 june 0411 2000 limerick ireland amy l murphy gian pietro picco gruiacatalin roman lime coordination model middleware supporting mobility hosts agents acm transactions software engineering methodology tosem v15 n3 p279328 july 2006 dianxiang xu jianwen yin yi deng junhua ding formal architectural model logical agent mobility ieee transactions software engineering v29 n1 p3145 january p ciancarini f franz c mascolo using coordination language specify analyze systems containing mobile components acm transactions software engineering methodology tosem v9 n2 p167198 april 2000 gruiacatalin roman gian pietro picco amy l murphy software engineering mobility roadmap proceedings conference future software engineering p241258 june 0411 2000 limerick ireland
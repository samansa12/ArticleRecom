highly available local leader election service abstractwe define highly available local leader election problem generalization leader election problem partitionable systems propose protocol solves problem efficiently give performance measurements implementation local leader election service proven useful design implementation several failaware services partitionable systems b introduction leader election problem 1 requires unique leader elected given set processes problem widely studied research community 2 3 4 5 6 one reason wide interest many distributed protocols need election protocol subprotocol example atomic broadcast protocol processes could elect leader orders broadcasts correct processes deliver broadcast messages order highly available leader election problem defined 7 follows point time exists one leader leader time within time units new leader elected highly available leader election service first defined synchronous systems correct processes connected communicate timely manner recently research faulttolerant systems investigating asynchronous partitionable systems 8 9 ie distributed systems set processes split disjoint subsets due network failures excessive performance failures ie processes messages timely see section iii details like many authors call subset parti tion example processes run different lans become partitioned bridge network connects lans fails slow see figure 4 one reason research partitionable systems primary partition approaches 10 allow processes one partition make progress increase availability services one often wants services make progress partitions recent design membership 11 clock synchronization service partitionable systems 12 indicated need leader election service different department computer science engineering university california san diego la jolla ca 92093gamma0114 email cfetzercsucsdedu flaviucsucsdedu httpwwwcsucsdeducfetzer research supported grants f4962093 f4962096 air force office scientific research earlier version paper appeared proceedings sixth ifip international working conference dependable computing critical applications dcca6 information see httpwwwcsucsdeducfetzerhall properties partitionable systems synchronous systems first problem encountered specify requirements local leader election ser vice ideally service elect exactly one local leader partition however always possible elect leader partition example processes partition suffer excessive performance failures one cannot enforce exists exactly one local leader partition approach problem define partitions local leaders elected introduce therefore notion stable partition informally processes stable partition connected ie two processes stable partition communicate timely manner processes stable partition required elect local leader within bounded amount time election service might able elect local leader unstable partition ie partition stable guaranteed local leader unstable partition call process unstable part unstable partition stable partition local leader election service elect exactly one local leader unstable partition service might able elect exactly one local leader advantageous split unstable partition two logical partitions one local leader enables processes logical partitions communicate timely manner see figure 1 explain note definition stable partition require processes partition connected implies connected relation partition transitive partition unstable example connected relation become nontransitive three processes fp q rg network link p r fails overloaded links p q q r stay correct see figure 2 specific circumstances local leader service splits unstable partition two logical partitions one leader service makes sure timely communication two processes logical partition possible however sometimes communication go via local leader case two processes r logical partition connected local leader q see figure 2b informally logical partition created local leader service set processes local leader logical partition communicate timely fashion processes logical partition scenario depicted figure 1 one situ ation two logical partitions one leader created however logical partitions created ieee transactions software engineering appear 1999 connected local leader logical partition q u r fig 1 local leader election service permitted split unstable partition fpqruvwg two logical partitions fpqrg fuvwg done trivially particular prohibit case local leader service simply elects unstable processes local leaders example unstable trio consists two processes p r connected third process q connected one three processes permitted become local leader see figure 2 note want two local leaders p r even two processes indirectly connected q see figure 2g intuition behind restriction election local leader l supported processes connected l since p q cannot get support p one two processes allowed become leader local leader illegal connected r r r r r r r r b c fig 2 trio p q r unstable since p r connected local leader election service must elect one process trio local leader derive paper formal specification highly available local leader election service specification implies local leader service creates logical partitions 1 logical partitions never overlap 2 stable partitions subsets logical partitions 3 two local leaders always two separate logical partitions 4 logical partitions processes one partition connected local leader logical partition paper propose efficient protocol implements highly available local leader election service use protocol failaware group membership service 11 failaware clock synchronization service partitionable systems 11 give performance measurements implementation network workstations ii related work many publications solutions leader election problem synchronous asynchronous systems 1 13 2 3 4 5 6 election problem first defined solved 1 many election algorithms based message extinction principle first introduced 13 process r rejects message requests process q become leader whenever r knows process p wants become leader p lower id q many papers leader election address masking failures election election new leader previous one fails aware specification local leader election service partitionable systems implementation election service contains novel aspects first instead using message extinction use independent assessment protocol 14 11 approximates set processes stable partition typically ensures one process l stable partition requests become leader processes ls stable partition support ls election local leader renew leadership roundbased fashion ensures crash local leader stable partition results replacement within bounded amount time stable partition n processes protocol sends one broadcast message unicast messages per round second use communication time ensure logical partitions never overlap use mechanism similar lease 15 make sure processes point time one logical partition protocol option allows us use protocol elect either local leaders one global leader protocol forced create logical partitions contain majority processes since logical partitions never overlap time exist one majority partition thus one global leader system local leader used maintain consistency amongst processes partition global leader used maintain consistency amongst processes example local leader used ensure mutual exclusion processes one partition global leader used ensure mutual exclusion processes group membership services partitionable systems 16 17 18 used elect local leaders example strong membership protocol 16 three round protocol 18 used elect local leaders local leader disjoint partition however local leader service said basic membership service sense 1 membership service partitionable systems typically elects local leaders create new groups eg see 16 2 implementation local leader service need stronger properties provided group membership service agreement history groups iii timed asynchronous system model timed asynchronous system model 19 abstraction properties distributed systems encountered practice built set workstations connected lan wan timed model makes fetzer cristian highly available local leader election service 3 assumptions system hence almost practical distributed systems described timed asynchronous systems since makes weak assumptions solution problem timed model used solve problem practical distributed sys tem timed model however sufficiently strong solve many practically relevant problems clock synchronization highly available leadership membership atomic broadcast availability management 19 timed model describes distributed system finite set processes p linked asynchronous datagram service datagram service provides primitives transmit unicast broadcast messages oneway timeout delay ffi defined transmission delays messages although guarantee message delivered within oneway timeout chosen make likelihood message delivered within ffi timeouts suitably high 20 say process receives message timely manner iff transmission delay ffi transmission delay greater ffi say suffered performance failure late 20 assume exists constant ffi min denotes minimum message transmission delay message sent two remote processes transmission delay least ffi min time units remote mean message sent via network asynchronous datagram service omis sionperformance failure semantics 20 drop message fail deliver message timely manner probability delivers corrupted messages negligible broadcast messages allow asymmetric perfor manceomission failures process might receive broadcast message timely manner another process might receive late asynchronous datagram service satisfies following requirements ffl validity process p receives message q time indeed exists earlier time sent p ffl noduplication process receives message ie message delivered process q time exists time 6 datagram service delivers q process management service defines scheduling timeout delay oe meaning process likely react trigger event within oe time units see 19 p takes oe time units react trigger event suffers performance failure say p timely interval iff point p crashed p suffer performance failure assume processes crashperformance failure semantics 20 suffer crash performance failures processes recover crashes two processes said connected 18 iff timely message sent gamma ffi delivered timely manner see figure 3 denote p q connected using predicate connectedpqst real time fig 3 timely processes p q connected iff messages sent gamma ffi delivered within processes access local hardware clocks bounded drift rate correct hardware clocks display strictly monotonically increasing values denote local hardware clock process p h p simplicity assume paper neglect granularity hardware clock eg clock resolution 1s smaller hardware clocks proceeding within linear envelope realtime drift rate correct hardware clock h p bounded priori given constant ae interval important assumption hardware clock noncrashed process correct informally require neglect probability drift rate hardware clock noncrashed within gammaae ae whether failure probability negligible depends stochastic requirements application 20 21 noncritical applications use simple counter connected quartz oscillator appropriately chosen ae provide sufficiently close approximation crash failure semantics ie one neglect probability clock failure except clock crash failures occur safety critical applications implementation might sufficient however one use multiple oscillators counters make sure probability clock failure except clock crash failure becomes negligible 22 simplicity assume hardware clock recover crash hardware clocks synchronized deviation h hardware clocks h p h q assumed bounded quartz clocks available modern computers maximum hardware clock drift rate ae order 10 gamma4 10 gamma6 since ae small quantity follows neglect terms order ae 2 higher particular equate 1 ae process measures length interval error measurement within iv communication partitions timeliness requirement specification local leader problem based notion stable partition however many possible reason 4 ieee transactions software engineering appear 1999 able definitions stable partition one put different constraints kind communication possible processes two stable partitions strongest definition would require communication possible two stable partitions see definition predicate stable 18 weakest definition would place constraints communication partitions timeliness requirement local leader problem demand local leader elected stable partition within bounded amount time therefore weaker definition stable partition stronger timeliness requirement since protocol required elect leader harder condi tions paper use formalization notion stable partition two extremes deltapartition see protocol propose based deltapartitions definition local leader problem largely independent actual definition stable partition however assume processes stable partition connected introduce generic predicate sta blepartition denotes definition assumed implementation local leader service stableparti tionspst true iff set processes sp stable partition interval section introduce one possible definition stable partition let us motivate two lans connected network see figure 4 processes run one lan communicate processes lan via network network provides fast communication two lans want one leader lans since network become overloaded processes two lans become logically disconnected sense communication slow one leader two lans case want local leader two lans overloaded network communication slow connected k l fig 4 two lans connected network processes two lans become partitioned network fails slow two processes p q disconnected 18 interval iff message sent two processes arrives destination paper introduce weaker predicate call deltadisconnected intuition behind predicate use fail aware datagram service 23 classify messages either fast slow service calculates upper bound transmission delay message delivers bound greater given delta message classified slow otherwise message classified fast constant delta chosen calculated upper bound messages sent two connected pro cesses ie messages transmission delay ffi delta one choose delta ffi since one determine upper bound exact transmission delay message able calculate upper bound transmission delay message delivers failaware datagram service 23 maintains process q array ts ts contains process p receive send time stamps message n q received p see 23 details failaware datagram service piggybacks unicast message sends q p time stamps n send stamp computation upper bound uses time stamps roundtrip n transmission delay greater duration p sending n receiving since q received n sent one use several techniques improve upper bound becomes close realtransmission delay upper bound calculation similar reading error computation probabilistic clock reading 24 process p deltadisconnected process q given time interval iff messages p receives q transmission delay time units see figure 5 use predicate delta disconnectedpqst denote p deltadisconnected q real time fig 5 process p deltadisconnected q messages p receives q transmission delay delta note q might receive messages p delay less delta say nonempty set processes sp delta partition interval iff processes sp mutually connected processes sp deltadisconnected processes see figure 6 v specification section derive formal specification local leader problem main goal local leader service elect one local leader per stable partition ever specification also constrain behavior fetzer cristian highly available local leader election service 5 dpartition partition pqr nected connected disconnected fig 6 processes deltapartition communicate timely manner messages outside partition transmission delay delta processes stable partitions approach problem require local leader service creates logical partitions 1 logical partition one leader 2 stable partition included logical partition local leader election problem defined using three predicates one constant instantiated implementation local leader service sta blepartition leader supports constant predicate deltapartitionspst defined section iv one possible definition stablepartition predicate leader p true iff process p local leader time specification based idea process p collect support eg votes p become leader vote process q process p restricted lifetime ie q say vote p valid certain amount time specification local leader problem independent actual way protocol implements voting achieve introducing notion process q supporting process p q supports p time mean q voted ps election local leader vote still valid time formally expressed predicate supports pq defined true iff p supports qs election local leader time require point time process support one process local leader l supported processes connected l particu lar leader p stable partition sp must supported processes sp since processes stable partition definition connected define predicates leader supports associated proposed local leader election protocol section ix specification local leader problem consists four requirements bi ls timeliness requirement requires stable partition local leader elected time units see figure 7 allow local leader service implement rotating leader schema see figure 8 first local leader elected stable partition require process stays local leader long partition remains stable instead require interval length set processes sp stable partition exist least one point time exists local leader sp timeliness requirement formally ex real time true false leader stable partition pqr fig 7 stable partition fp q rg forms time gamma guaranteed local leader p elected within time units pressed follows set processes sp stable partition exists process p 2 sp time p local leader time real time u leader r leader leader leader fig 8 rotating leader schema transfers leadership periodically processes schema proven useful implementation atomic broadcast services require point time process r support one process formally state support one requirement follows time process r would support process p process q p q process connected local leader illegal r r r support bi support ls r r fig 9 requirement requires process support one process time ls leader supports thus trio fp q rg exist one leader whenever solsbi satisfied already mentioned trio three processes p q r p q q r connected see figure 2 want one three processes local leader therefore introduce two requirements leader self support requirement ls bounded inconsistency requirement bi requirement bi requires local leader p 6 ieee transactions software engineering appear 1999 connected process q least time units q must support p terms process connected two leaders time units bounded incon sistency example two stable partitions merge new stable partition time units one local leader new stable partition bi process p local leader time p connected least time units process q supports p timely process always connected hence requirement bi implies timely local leader support within time units becoming local leader strengthen special case requiring local leader always support particular local leader l support soon becomes local leader even l slow show section vi requirements ls ensure one local leader logical partition ls local leader always supports let us explain three requirements solsbi imply trio fp q rg pq q r connected least time units must one leader see figure 9 p q leaders time would support ls p would support local leader q p q connected bi however p allowed support one process time thus p q cannot leaders point time p r would leaders time q would required support p r bi would violate requirement therefore one process fp q rg leader r l supports created leader local logical partition fig 10 supports predicate partitions set processes vi logical partitions show supports predicate creates logical partitions partitions contains one leader furthermore leader stable partition sp logical partition lp contains sp ie intuitively logical partition lp contains process p contains process q exists finite undirected path supportsgraph p q see figure 10 undirected mean path ignores direction supports predicate formally define logical partitions relation support reflexive symmetric transi l closure supports r logical partition r l leader local fig 11 support relation reflexive symmetric transitive closure supports closure creates fully connected subgraphs isolated tive closure supports see figure 11 definition support equivalence relation partitions set processes completely connected subgraphs say two processes p q logical partition time iff support p q true since support reflexive process logical partition two logical partitions lp 1 lp 2 either non overlapping equal symmetry transitivity support supports local leader exluded condition ls fig 12 requiring leader supports guarantee undirected path supportsgraph contains one local leader let us show logical partition lp one local leader intuition requiring local leader supports split path cycle two local leaders could exist supports graph satisfy ls two paths one local leader see figure 12 precisely prove contradiction exists one leader per logical partition let us assume would exist time logical partition lp contains two local leaders p q see figure 13 since definition support p q holds fore exist finite undirected path supportsgraph p q since time process supports one process leader support ls p q two ends exist two processes k l support p q respectively processes k l supported two processes argument applied recursively show path would infinite length hence cannot exist finite path two leaders therefore logical partition contains one local fetzer cristian highly available local leader election service 7 leader l local leader due ls excluded condition supports fig 13 two leaders p q would logical partition would exist finite undirected path p q since p q two ends path ls would exist process supports two processes since processes stable partition mutually con nected bi implies within time units stable partition sp formed local leader sp supported processes sp see figure 14 thus time units one leader per stable partition point time process supports one process stable partition pqr leader local stable partition supports partition stable fig 14 leader stable partition formed least time units ago supported processes partition exists stable partition formed later time local leader sp time processes sp support p see figure 15 hence two processes u v 2 sp exists undirected path u p v implies u v logical partition note logical partition lp strict superset stable partition sp allowed process n outside sp support process sp hence n logical partition lp contains sp partition stable local leader supports r logical partition l fig 15 logical partition fp q ng strict superset stable partition fp q rg stable partition sp forms time tgamma time units could exist one local leader leaders previous partitions demoted first see figure 16 note even though might exist one local leader stable partition bounded amount time local leaders logical partition local leader real time false false leader true true leader fig 16 two stable partitions merge new partition might exist multiple local leaders stable parti tion duration inconsistent behavior however bounded requirement bi demands local leader p supported processes connected p least units requirement ensures two parallel local leaders p q elected good reason see figure 17 supporters p cannot connected q longer supporters q connected p longer supports partition logical local leader connected exclude bi fig 17 requirement bi prohibits supporter local leader p connected another local leader q time units vii protocol overview idea proposed protocol local leader election service following processes send messages failaware datagram service 23 classifies messages delivers either fast slow process p uses independent assessment protocol 11 approximate set processes deltapartition set call aliveset p set contains processes p recently received fast message independent assessment protocol send messages uses messages sent services like local leader election service update alivesets stores process pair p q receive time stamp recent fast message q received p process p id smaller ids processes aliveset broadcasts sending pe 8 ieee transactions software engineering appear 1999 riodic electionmessages request processes support election local leader process q supports election requests process p p process smallest id qs aliveset q process q deltapartition sp sufficiently long time aliveset contains processes sp messages receives processes outside sp slow hence sufficient keep processes qs aliveset particular process broadcasting election messages since ps id smaller id process aliveset since process q 2 sp connected p q receives ps election messages fast messages includes p aliveset process ps id smaller id qs aliveset ie qs aliveset contains processes sp contain p due ps periodic election messages thus processes sp implicitly agree support election p reply ps election messages thus p includes processes sp aliveset ie p gets fast supportive replies processes aliveset p becomes leader since processes sp support ps election process p succeeds becoming leader new deltapartition sp forms time processes sp support process within time units process q supports election process bounded amount time enables q support another process within bounded amount time example q supports process r support another process p support r expires process r becomes leader support q ensure r demoted support q expires protocol achieves timely demotion even r slow r leader long hardware clock shows value smaller value expi rationtime calculated rs election note q support different process p support r expired without exchange messages q r important property q learn r demoted crashed would impossible decide asynchronous system supports different process protocol require connected relation transitive successful election local leader see section x aliveset process p approximates set processes connected p process p gets support processes aliveset p become leader even two processes aliveset connected viii protocol pseudocode protocol local leader election service given figures 30 31 messages sent delivered failaware datagram service 23 allows receiver message detect transmission delay fast slow ie units delta time units respec tively failaware datagram service provides primitive send unicast messages denoted faunicast one broadcast messages denoted fabroadcast deliver message clock time rectime sent process p q service generates event denoted fadelivermpfastrectime destination process q boolean flag fast set true fast otherwise false process p maintains set processes called aliveset p p received fast message last say expires clock time units determine value constant expires later aliveset process maintained two procedures updatealiveset purgealiveset procedure updatealiveset inserts sender fast message aliveset stores receive time stamp array called lastmsg procedure purgealiveset uses array lastmsg remove process r aliveset myid executing process myid process myid received fast message r expires clock time units let us assume ids processes totally dered function purgealiveset also returns first point clock time given respect local hardware clock myid could smaller id process aliveset process receive messages processes smaller ids returned bound tight calculated bound used optimize broadcasts electionmessages process p starts broadcasting periodic electionmessages soon id becomes smaller id process aliveset p timely broadcasts least every ep clock time units electionmessage ep elec tion period priori given constant scheduling broadcasts performed help alarm clock call aliveac process p set alarm clock method setalarm setalarmt requests wakeup event generated ps hardware clock shows value timely process p awakened within time units hardware clock h p showing scheduling timeout delay oe priori defined constant process cancel alarm operation cancel electionmessage sent process p contains ffl unique time stamp denoted request detect replies correspond request p become leader ffl aliveset p time ps hardware clock showed value request process p sends electionmessage stores request time stamp variable called lastrequest able identify replies message process p also stores current aliveset variable targetset resets variable replyset empty set p insert replyset ids processes p gets fast reply supports ps election process q replies fast electionmessages ignores slow messages replymessage identifies request q replying also contains flag indicates q supporting ps election fetzer cristian highly available local leader election service 9 flag true say supportive reply sending q guarantees send another supportive reply next locktime clock time units process q achieves guarantee storing ps id request id variable lockedto sum receive time plus locktime variable lockeduntil electionmessages arrive q use variables lockedto lockeduntil determine still supporting p ie q still locked p determine value constant locktime section ix say process q locked process denote q cannot send supportive reply process p q sends supportive reply p say q locks p let us consider process q receives election message p containing time stamp request ps aliveset denoted alive process q locks p ffl fast message q ignore election requests outside deltapartition ffl q locked process ensures point time process locked one process ffl ps id smaller qs id ffl p process minimum id qs aliveset two processes r q deltapartition sp implicitly agree process support since explain following condition holds minaliveset r minaliveset q minsp process p receives fast supportive reply process q last electionmessage p inserts q replyset 2delta realtime units could units due drift ps hardware checks become leader renewed leadership calling function checkifleader case p already leader p tests able renew leadership soon p received replies processes targetset ie soon replysettargetset process p becomes leader see function checkifleader iff ffl p aliveset time p sent electionmessage see proof requirement bi section ix ffl p received fast supportive reply processes current aliveset necessary make sure p supported processes p connected ffl p minimum id replyset p makes sure supports p becomes leader sets local variable im leader true calls procedure newleader notify client leader ps hardware clock shows clock value expirationtime determined section ix process p schedules broadcast next electionmessage time expirationtime2delta1 ae renew election leadership expires protocol provides boolean function leader checks calling process p local leader function leader reads hardware clock time leader flag imleader true case p succeed become local leader received least one supportive reply p broadcasts releasemessage let processes locked know lock another process process q receives releasemessage p last election message q locked q releases lock ix correctness show section proposed local leader protocol satisfies requirements tsobils first define predicates stablep artition leader p supports since protocol designed deltapartitions define deltapartitionspst let us denote value process ps variable varname time varname predicate leader p defined leader process becomes leader sets variable sup portset set processes sent supportive reply process q supports process p time iff p leader time q ps support set supports q p formally express property process q locked process p predicate locked q p defined follows see section viii figure 31 explanation variables lockedto lockeduntil locked q long q crash locked one process time q always checks last lock expired locks new process recall timed asynchronous system model allows crashed processes recover assume process q crashes stays least lockt ime clock time units enables q lock process p immediately q recovers crash without waiting first least lockt ime clock time units make sure lock q issued crashed expired note initial waiting time would otherwise ie without assumption required make sure process locked one process simplify exposition use phrase process action clock time denote pro cess p action point realtime ps hardware clock h p shows value ie h p supports one see requirement satisfied ie process q supports one process p time let us consider scenario shown figure 18 process p sends electionmessage clock time lastrequest p q receives q sends supportive reply u process q locked p least lockt ime clock units ie hardware clock shows value process p becomes leader time w q ps support set assigns variable expirationt ime p clocks drift apart 2ae ps hardware clock shows qs hardware clock shows due positive transmission delay ps hardware clock shows value expirationt ime p qs hardware clock shows ime see figure 18 hence whenever process q supports p q locked p since q locked one process time follows q supports one process time leader locktime locktime electionmessage replymessage fig 18 process q sends supportive reply n ps election message locked p locktime clock units p demoted q releases lock p b leader self support ls becoming leader process p checks received supportive reply see condition replysetmin procedure checkifleader thus leader always supports protocol therefore satisfies requirement ls c timeliness timeliness condition hold make sure protocol constants expires locktime well chosen constant expires states long process p stays aliveset process without arrival new fast message p hence derive lower bound expires make sure processes deltapartition remove local leader aliveset derive lower bound constant expires let us consider situation timely process p tries become leader sending periodic electionmessages see figure 19 goal p stays aliveset process q connected p q stays alive set p therefore constant expires chosen two successive election messages 1 sent p q receives clock times respectively condition expires holds similarly p receives qs replies n 1 n 2 times u v respectively distance two receive events expires expires therefore derive upper bounds assumption p q connected duration two successive broadcasts ep clock time units realtime duration thus ep 1 ae difference transmission delays 1 2 expires since clock time transmitting 1 2 ep maximum difference roundtrip times expires bounded min replymessage electionmessagen min 1rdd fig 19 constant expires chosen p stays qs aliveset q stays ps aliveset u v typically one set constant expires small multiple lower bound one late election message omission failure electionmessage remove sender aliveset processes implementation defined constant four times lower bound achieved excellent stability sense measurements minimum process removed alivesets unless crashed process partitioned system constraining show processes deltapartition sp implicitly agree process minimum id sp let us consider sp forms time stays stable least time figure 20 message process q 2 sp receives process r outside sp ie r 2 transmission delay delta hence failaware datagram service delivers slow message q therefore update array lastmsg aliveset r expires clock time units time outside sp removed alivesets processes sp thus smaller id process aliveset process ps alivetimer generate timeout event later time delta since process sets alivetimer generates timeout event within oe time units ps id becoming smaller id aliveset hence p broadcast first electionmessages 1 later time first election request fail ps target set necessarily contain ps id processes sp receive fast 1 later delta hence include p alivesets later time u time u process sp lock process p since p minimum id alivesets processes sp reply p p fetzer cristian highly available local leader election service 11 get replies fast messages since p connected processes sp hypothesis process p therefore include processes sp aliveset time u delta ps aliveset consists processes sp ie aliveset electionmsg replymessage locktime expires fig 20 process deltapartition sp forms takes expiresoe clock time units send first election message 1 send second ep later show p succeeds become leader 2 even process q would locked another process u time p broadcast least every ep clock units electionmessage note p timely p hypothesis deltapartition hence sends next electionmessage 2 later time figure 20 constrain lockt ime even q would locked another process u q released lock receives 2 w processes sp send supportive replies ffl process sp locked another process anymore ffl p minimum id alivesets processes sp ffl processes sp receive 2 timely message process p become leader later time v 2delta protocol satisfy requirement therefore constrain follows c2 constraining locktime timely process p broadcasts electionmessage time p receives replies connected processes within units releasetimer therefore set ae factor 1 takes care drift ps hardware clock ensure process becomes leader positive time quantum locktime chosen ps leadership expire actually starts since 1 p stays leader lockt sending election message see figure 18 2 takes 2delta1 time units ps releasetimer timeouts sending make sure lockt thus assume following lower bound locktime lockt ime derive upper bound constant locktime goal process q locked process receiving 1 q release lock q receives next message 2 p see figure 21 p become leader 1 schedules next request ep clock time units due scheduling imprecision timely p actually send 2 units drift rate ps hardware clock within gammaae ae thus realtime duration two send events least ep gamma ae realtime duration reception q least ep gammaoe1gammaaegammadeltaffi min difference transmission delays 1 2 therefore constant locktime locktime 1ae epoe1aedeltaffi min protocol set locktime upper bound ie choose locktime big possible given ep real time min message election locktime min s1rdd fig 21 process q locks receiving 1 process r p release lock receives next election message 2 p bounded inconsistency bi show protocol satisfies requirement bi consider two processes p q become connected time stay connected time see figure 22 let p smaller id two pro cesses ie p q show time x x p leader x q supports p x let us consider 0 last electionmessage p sent 1 first p sends two processes become connected process p includes aliveset p receives timely election reply message broadcast 0 could result timely reply message n 0 consequence could include aliveset receive time stamp h send another electionmessage 1 expires clock time units p remove aliveset note p removed aliveset p target set first election request p fail p needs target set become leader see function checkifleader hence p sends first electionmessage election request fail however qs reply 1 force p get supportive reply successive election requests words p receives n 1 become leader support q long p q stay connected p sends first electionmessage election successful even without support q p checks become leader soon received reply processes target set however ps leadership expire within locktime12ae clock time units due election without qs support thus requirement bi satisfied 2delta1aeexpireslocktime12ae note bound smaller previously derived bound satisfy timeliness condition see section locktime12 r expires uelectionmsg replymsg fig 22 processes p q become connected p include q aliveset time v thus electionmessage p sends v requires supportive reply q allow p become leader x protocol properties proposed protocol elects within time units deltastable partition sp process minimum id local leader process stay leader long sp stays stable p becomes leader reduces timeouts broadcasting electionmessages ep locktime12ae2delta1 ae makes sure long sp stays stable p renew election leadership expires locktime12ae local leader p always knows logical partition lp note definition supports give protocol see section ix states process r supports another process q q leader r qs support set hence protocol process r cannot support process q leader local leader know rs support way protocol actually exclude situations like depicted figure 10 logical partition contains processes support process local leader since logical partitions overlap point time support sets local leaders overlap support set basis implementation membership protocol 11 process p piggybacks support set next election message provide processes logical partition current members logical partition proposed protocol guarantees stronger timeliness requirement one required specification in0 65712 1411 9connected supports logical partition fig 23 protocol elects maximum connected set least process minimum id local leader particular connected relation transitive guarantee local leader elected within say set processes cs maximum connected set iff ffl two processes p q cs either connected deltadisconnected ffl two processes p q cs exists path connectedgraph p q ffl process cs deltadisconnected processes outside cs protocol succeeds elect minimum process maximum connected set within time units see figure 23 behavior protocol maximum connected set cs described graph algorithm see figure 24 initially set contains processes cs process cs marked ie set ms empty set local leaders ls empty algorithms iteratively computes minimum process l set l processes connected l marked ie set ms l included set local leaders ls intuition process marked marked process already locked another process processes connected l marked included set ms algorithm terminates becomes empty algorithm terminated ls contains exactly set local leaders proposed local leader election protocol elect maximum connected set cs protocol configured guarantees exists one leader time ie safety property conventional leader election problem satisfied let n denote maximum number processes participating election protocol ie setting constant minnumsupporters n1 e process get support half processes become leader see function checkifleader figure 31 thus local leader logical partition n2 processes logical partitions overlap one leader time modified protocol satisfies requirements tsolsbi however define predicate stablepartition following way fetzer cristian highly available local leader election service 13 ms 6 l min p 6 l connectedlp ms ms ms endif ms fig 24 algorithm computes set local leaders ls proposed local leader election protocol elects maximum connected set cs e xi performance measured performance local leader election protocol dependable systems lab ucsd 8 sun ipx workstations connected 10 mbits ethernet messages send failaware datagram service 23 classifies message delivers either fast slow service calculates posteriori upper bound transmission delay message calculated bound greater given threshold delta classified fast otherwise classified slow failaware datagram service guarantees validity nonduplication requirements hold see section iii threshold delta fast messages 15ms timeout scheduling delay oe 30ms election period ep 50ms typical behavior protocol exactly one process p periodically broadcasting election messages processes replying unicast messages p measured election times ie time transmitting election message process p time p becomes leader reflects typical behavior see figure 25 measurements based 100000 successful elections election time increases linearly number processes participating election average election time 99 election time ie process succeeds 99 probability become leader within time shown figure 26 also measured time takes elect new leader system splits one two partitions see figure 27 graph based 12000 measurements performed using leader election protocol part membership protocol 11 process p removes process q aliveset p received fast message q expires230ms words system splits takes processes one partition 230ms remove processes 3ms 4ms 5ms 6ms 7ms25007500no elections process 6 processes fig 25 distribution election time 1 8 processes participating election smaller difference 1 2 processes due fact local replies sent 1 nodes election time avg time t99 time fig 26 average election time 99 election time 1 7 participating processes partition alivesets however expires could reduced 50ms see section ix c however use larger value 230ms minimize number parallel local leaders case temporary instabilities first election attempt system becomes partitioned typically fails alivesets processes two newly formed partitions uptodate yet second election attempt however general succeed elect new local leader linear increase election time number participating processes mainly due fact process receives replymessages election message less fact ethernet overloaded one possible enhancement protocol would use aliveset provided election message build nary tree use tree collate replies see figure 28 1 process leaves tree replies parent node 2 process inner node waits replies children replies parent node 3 root becomes leader received replies children reducing election time enhancement would complicate protocol since handle case process q tree crashes slow hence root would get message children q 14 ieee transactions software engineering appear 1999 50ms 150ms 250ms 350ms100300500700900 partition splits election time exclusion time fig 27 left graph shows measured time l takes removes processes partition aliveset time l waits attempts become local leader right graph shows measurement time needed elect new leader l partition split4 6 reply 0 fig 28 aliveset root process 0 used define 3ary tree used collate replies processes aliveset 0 processes outside aliveset 0 reply directly 0 implemented tree based collation replies compare effect election time system eight processes three processes directly replied new leader l 3 processes reply another process q q replied l improvement 8 processes sufficient justify increased complexity see figure 29 however systems processes enhancement could decrease election time significantly xii conclusion ideal goal local leader service elect exactly one local leader communication partition goal however always achievable failure frequency communication partition might high processes partition able elect local leader paper derive specification approximates ideal goal exaclty one local leader per communication partition also show specification implementable timed asynchronous systems ie distributed systems without upper bounds transmission scheduling delay processes access local hardware clock bounded drift rate 60ms 65ms 70ms 75ms 80ms100300500700 elections direct replies collated replies fig 29 comparison tree based collation replies direct replies leader two graphs based 10000 elections local leader problem requires implementation creates nonoverlapping logical partitions elects one leader per logical partition logical partition created local leader service set processes local leader logical partition communicate timely fashion processes logical partition connectedrelation changes eg process becomes disconnected leader local leader service adapt logical partition new connectedrelation stable partition communication partition processes connected therefore local leader service create stable partition sp logical partition includes sp elect leader l sp within bounded amount time sp formed specification local leader service efficiently implemented timed asynchronous systems introduce paper roundbase local leader election protocol leader elected maximum duration update leadership next round periodic update necessary able adapt logical partitions changes connected relation example current local leader l crashes disconnected remaining processes elect new leader within bounded amount time since l demoted known amount time stable partition n processes protocol sends one broadcast datagram unicast datagrams per round local leader service proven useful design implementation failaware membership service failaware clock synchronization service asynchronous partitionable systems fetzer cristian highly available local leader election service 15 import const myid const const const const const ae time const expires time function newleaderdemotedat time procedure procedure const locktime minnumsupporters integer init var releaseac alarm clock imleader boolean init false expirationtime time init 0 supportset set init aliveset set init replyset set init targetset set init lastmsg lockeduntil time init 0 lastrequest time init 0 msg request time function nominbefore p 2 aliveset lastmsgpexpires else myid p lastmsgpexpires nominbefore return nominbefore procedure updatealivesetsender p fast boolean rectime time fast lastmsgsender rectime endif procedure checkifleader minnumsupporters supportset replyset imleader true expirationtime lastrequest newleaderexpirationtime else replyset endif lastrequest fig 30 part 1 pseudocode local leader service return task leaderelection import rectime begin loop select event fagammadeliverelection request alive sender fast rectime updatealivesetsender fast rectime support support endif fast sender 6 myid alivesize 1 sender rectime else support request lastrequest fagammadeliverrelease request sender fast rectime fagammadeliverreply request support sender fast rectime updatealivesetsender fast rectime fast request lastrequest support checkifleader endif endif aliveacwakeupt lastrequest replyset targetset aliveset lastrequest else releaseacwakeupt checkifleader select loop fig 31 part 2 pseudocode local leader service xiii appendix sym sec meaning alivesetp vii independent assessment view p bounded inconsistency requirement connected iii timely message exchange possible oneway timeout delay delay threshold used classify messages deltadisconnected iv weak form disconnected deltapartition iv stable partition ep viii election period expires viii expiration time aliveset entries fast iv upper bound fast message delta hp iii hardware clock process p leader locktime viii support time leader p iii set processes pqr processes ae iii maximum drift rate hardware clock u v realtime values oe iii scheduling timeout delay slow iv upper bound slow message delta support one requirement stablepartition v formalization stable partition supports v supportsrelation support vi closure supportsrelation timeliness requirement r distributed systems towards formal approach elections distributed computing sys tem election asynchronous complete networks intermittent link failures optimal asynchronous agreement leader election algorithm complete networks byzantine faulty links design analysis dynamic leader election protocols broadcast networks leader election presence link failures reaching agreement processorgroup membership synchronous distributed systems transis approach high availability cluster communication totem faulttolerant multicast group communication system process group approach reliable distributed computing failaware membership service failaware clock synchronization improved algorithm decentralized extremafinding circular configurations processes tandem global update protocol leases efficient faulttolerant mechanism distributed file cache consistency processor group membership protocols specification design implementa tion processor membership asynchronous distributed systems agreeing processorgroup membership asynchronous distributed systems timed asynchronous distributed system model understanding faulttolerant distributed systems failure mode assumptions assumption coverage building faulttolerant hardware clocks failaware datagram service probabilistic clock synchronization tr ctr andrew hume scott daniels ningaui linux cluster business proceedings freenix track 2002 usenix annual technical conference p195206 june 1015 2002 flaviu cristian christof fetzer timed asynchronous distributed system model ieee transactions parallel distributed systems v10 n6 p642657 june 1999 christof fetzer flaviu cristian failawareness approach construct failsafe systems realtime systems v24 n2 p203238 march ying zhao wanlei zhou jiumei huang shui yu e j lanham selfadaptive clock synchronization computational grid journal computer science technology v18 n4 p434441 july richard john anthony autonomic election algorithm based emergence natural systems integrated computeraided engineering v13 n1 p322 january 2006
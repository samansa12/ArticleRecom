modelbased analysis configuration vulnerabilities vulnerability analysis concerned problem identifying weaknesses computer systems exploited compromise security paper describe new approach vulnerability analysis based model checking approach involves formal specification desired security properties example property ordinary user overwrite system log files abstract model system captures securityrelated behaviors model obtained composing models system components file system privileged processes etc verification procedure checks whether abstract model satisfies security properties produces execution sequences also called exploit scenarios lead violation properties important benefit modelbased approach used detect known asyetunknown vulnerabilities capability contrasts previous approaches used cops satan mainly address known vulnerabilitiesthis paper demonstrates approach modelling simplified version unixbased system analyzing system using modelchecking techniques identify nontrivial vulnerabilities key contribution paper show automated analysis feasible spite fact system models infinitestate systems techniques exploit latest techniques modelchecking constraintbased implicit representation statespace together domainspecific optimizations appropriate context vulnerability analysisclearly realistic unix system much complex one modelled paper nevertheless believe results show automated systematic vulnerability analysis realistic systems feasible near future modelchecking techniques continue improve b introduction system configuration vulnerabilities traced back classic problems software engineer ing unexpected interactions different system modules violation hidden assumptions instance consider vulnerability existed early versions fingerd service servicing query finger user program needs read file named plan home directory user fingerd service runs root privileges earlier versions unix used open plan root presence symbolic links creates following vulnerability user u could symbolically link file f hisher plan even u read access f user u read f simply running finger u vulnerability arises due interaction way finger server operates way symbolic links implemented second example consider vulnerability involving mail notification program comsat waits reports incoming mail user prints first lines message terminal user logged terminal determined file etcutmp used configured worldwritable written user level time login malicious user modify etcutmp substituting etcpasswd place terminal heshe logged user send mail self containing line starts root00 means root empty password upon receiving mail comsat overwrite password file message user login root without providing password 11 approach formal methods good choice address software engineering problems arise due unexpected interactions among system components 9 paper describe approach analyzing system configuration vulnerabilities using techniques drawn formal methods research approach involves construction highlevel models system components order detect kind vulnerabilities described would start abstract models capture behavior unix file system comsat mailer programs model user behavior currently developing abstract models manually future expect model extraction process machineassisted employing program analysis techniques formal statement desired securityrelevant properties composite system vulnerabilities viewed flaws system configuration exploited violate certain security objectives overall system detect vulnerabilities need formal statement security properties one example property ordinary user overwrite system log files another example password file cannot modified except superuser using password changing program automated analysis system model check deviation desired security properties configuration vulnerabilities identified analyzing overall system behavior ob tained composing models developed determining violates desired security properties use modelchecking 6 7 16 analysis important benefit model checking property violated model checker provides counterexample shows property violated paper demonstrates approach modelling simplified version unixbased system discovering nontrivial configuration vulnerabilities system automated analysis clearly realistic unix system much complex one modelled paper nevertheless believe results show automated analysis realistic systems feasible near future especially since faster techniques modelchecking developed although use modelchecking examined related contexts verification cryptographic protocols network vulnerabilities 20 first attempt using modelchecking system configuration vulnerability analysis one principal difficulties context system models tend possess infinite number states need model aspects system file names nested directory structures ability create destroy infinite number files traditional modelchecking techniques employed 20 limited finitestate models key contribution paper show nontrivial vulnerabilities discovered using automated modelbased analysis spite fact system models infinitestate shows known techniques model abstraction constraintbased representations employed tackle infinitestate modelchecking problems arise vulnerability analysis rest paper structured follows section 12 describe previous approaches vulnerability analysis summarize main advantages modelbased approach section 2 describe approach modelling simplified subset unix analysis technique described section 3 results analysis presented section 4 finally concluding remarks appear section 5 12 related work research vulnerability analysis focused primarily identification configuration errors improper file permission settings existing works 2 11 23 employ set rules enumerate known causes vulnerabilities call works collectively rulebased widely used tools cops satan search occurrences known vulnerabilities 11 however generation rules relies expert knowledge interactions among many components system experts complete understanding interactions among components modern computer system issues race conditions many possible interleavings hidden assumptions etc 3 make hard humans come rules modelbased approach suffer disadvantages human involvement needed primarily develop models individual system components problem hard human reasoning namely reasoning interactions among system components relegated mechanical procedure advantages modelbased approach identification known unknown vulnerabilities analysis formal models identify known asyetunknown vulnerabilities contrast rulebased approaches limited examining system known vulnerabilities modularity effort required add new system components eg new privileged programs significant software upgrades determined new components added models existing components need changed contrasts rulebased approaches new rules need added capture interactions among new components also interactions new old components generating patterns misuse intrusion detection vulnerabilities identified analysis may sometimes able rectify times may immediate fix may require changes vendorprovided software since changes may interfere legitimate functionality system second line defense vulnerable systems misuse intrusion detection system use monitored order detect known exploitations exploit scenarios usually specified expert process detection exploits automated approach outlined paper enables automation first task well since counter examples generated modelchecking technique correspond exploits mechanically translate exploits patterns misuse intrusion detection system automatic generation rules checking vulnerabilities specific configurations proposed approach detect system vulnerabilities even information provided initial system configuration modelchecking technique produces exploit scenarios conditional upon unspecified initial configuration conditions capture potential vulnerability checked using rule main benefit using rules potentially checked economically terms time memory usage running model checker paper builds preliminary results modelbased vulnerability analysis reported earlier 17 since ritchey ammann 20 suggested promising approach automating network vulnerability analysis approach starts higher level models models capture known exploits individual systems eg given version web server contains vulnerability allows remote user gain access local user certain host running version server model checking used check exploits strung together achieve greater degree access obtained individual exploits contrast approach aimed discovering individual exploits models legitimate behaviors systems another important difference models finite enables use widely available model checking tools smv 8 spin 13 perform vulnerability analysis contrast need deal infinite state systems finite models cannot capture components file systems files added renamed removed bound many times operations may repeated modelling securityrelated behaviors systems section first describe model small subset unixbased system subset captures simplified view file system operating system facilities sufficient uncover nontrivial vulnerabilities analysis process begin short description language use modelling described enough detail understand models complete description language relevant purposes paper hence include 21 modelling language describe model using modelling language similar csp 12 extended objectoriented capabilities since underlying model checker based prolog language many features modelling language similar prolog addition syntactic features similar used promela modelling language used spin 13 verification system language system modelled collection concurrently executing processes communicate process viewed object internal state encapsu lated cannot accessed processes communication among processes takes place via method invocations method invocation synchronous causes invoking process block method invocation completed return values sent back objects instances classes class definition consists definition encapsulated state definitions externally visible methods definitions local methods otherwise known private methods helper functions single inheritance supported language thus class definition form class classnamedatamembernames baseclassnamedatamembernames1 fmethoddefng object created invoking class name parameters corresponding data mem bers using syntax methods defined using following syntax like predicates prolog language method invocations language always return boolean value addition arguments method may get instantiated result invoca tion feature used communicate return values use convention return parameters appear input parameters method invocations language supports basic data types booleans integers floats strings usual operations types also supported used construct complex expressions values variables basic types language also supports compound types based algebraic type system similar provided prolog types used represent structured data file names file contents contents entire file system two common compound types tuples lists assume different processes execute concurrently language uses interleaving semantics determine result concurrent executions lowest level operations assignment performed atomically method body consists sequence operations operations return boolean value value true denoting successful completion operation false denoting failure method invocation begins execution first operation sequence operation succeeds next operation executed operations sequence succeed say entire sequence succeeds otherwise sequence fails returning value false case method invocation returns false indicating failure operations either primitive compound primitive operation either method invocation application predefined predicate equality relational opera tions note equality predicate semantics prolog particular bind values variables compound operation constructed primitive operations using following constructs atomic execution atomic opseq semantics opseq except operations within opseq executed atomically ie execution interleaved execution processes alternation opseq1 jj opseq2 succeed either opseq1 opseq2 succeeds wise fail note opseq2 executed opseq1 fails parallel composition opseq1 j opseq2 result concurrent execution operations opseq1 opseq2 either sequences succeed entire construct succeeds ifthenelse opseq1 opseq2 else opseq3 result execution opseq1 succeeds opseq2 executed success failure determine success failure ifconstruct opseq1 fails opseq3 executed success failure determine success failure ifconstruct guarded command g1 opseq1 jj g2 opseq2 jj jj gn opseqn following semantics one guards evaluate true say gk chosen arbitrarily corresponding operation sequence opseqk executed sequence fails alternative guard evaluates true chosen operation sequence corresponding guard executed none operation sequences corresponding guards evaluate true succeed guarded construct fails otherwise succeeds simplicity restrict guards contain predefined operations equality checking cannot contain method invocations loop construct loop operationsequence construct meaning operationse quence executed repeatedly precisely behavior specified using recursive definition loop semantics operation failure similar prolog failure occurs execution backtracks point alternative execution path could taken variable bindings made point point failure undone execution proceeds alternate path note implies operation may succeed many times possibly different variable bindings b operation opseq1 jj opseq2 possible opseq1 succeed subsequent operation follows alternation may fail case execution may backtrack alternation construct point opseq2 may tried additional details language provided together examples 22 model file system state file system modelled set tuples form filename owner group permissions content file name represented list name abc would represented abc owner group represented integers permission field captures usual unix permission information files file content represented normalc normal files whose content given c linkf symbolic links another file f simplify presentation representing directories files however directory structure captured implicitly way files named effect means information directory level permission cannot represented directly must propagated represented permission files contained directory file system behavior captured filesystem class shown note use prologstyle convention variable names start capital letter constant class function names start lower case letter file system supports operations read write files write operation also used file creation remove operation provided file deletion file attributes ownership permission changed using operations chmod chgrp chmod file system model capture hard links symbolic links created using symlink operation file operations make use helper function called resolve first resolves symbolic links real file names performs permission checking class filesystems public methods chownfugo resolvefugrootf1 chngownerf1o number helper functions getcontent updatefile used methods definition helper functions straightforward provide definition getcontent omitting others interest conserving space getcontentf c memberfugpnormalc helper function resolve nontrivial provide definition parameters file name f resolved user group identifiers u g respect permission checking needs done option argument opt returns resolved name f1 fifth parameter resolve method fail either file name exist permission check fails memberf2og1pnormalc check tuple present set permission checks root check user u file owner resolvelinkf f1 options omitted else resolve method uses helper function resolvelink latter recursive function keeps following symbolic links normal file name identified checking file named f present file system note state file system captured list member predicate used search specified element list f present resolvelink fails otherwise content f form linkf2 resolvelink invoked recursively follow link otherwise must normal file hence f returned resolved name note definition resolvelink correctly captures fact permission checking done symbolic links symbolic links resolved resolve proceeds check file permissions note checking done userid u corresponds root otherwise permission check proceeds based value option opt option read write execute corresponding permissions checked option owner permission check operation needed one checking userid provided parameter file owner 23 model unix processes unix processes modelled using base class called unixproc captures behaviors common processes plus derived class per program wish model state unixproc object characterized real effective usergroup identifiers plus information groups known system addition contains reference file system object values command line arguments provides helper functions correspond roughly system calls class unixprocuid euid gid egid arglist fs usergroups definition several similar methods omitted corresponds forkexecf unix fsresolvefeuidegidexecf1 fsresolvef1euidegidsetuidf2 fsgetownerf1 euid1 else fsresolvef1 euid egid setgidf3 fsgetgroupf1egid1 else fsgetcontentf1 programc f1 must contain program createc uid euid1 gid egid1 arglist1 fs usergroups create language construct results creation new object belonging class first argument state object correspond exactly parameters supplied create methods omitted subclasses unixproc define externally accessible methods make use methods provided unixproc class also need provide main function gets executed soon process created process terminates object destroyed main function terminates based unixproc define lpr class follows level file system lpr either copies file printed spool directory links symbolically depending upon command line option addition usual process parameters lpr takes 2 arguments name file printed option indicates file copied spool directory printing symboliclinked spool directory class lpru eu g eg file opt fs ug atomic n used create temporary name spool file readvarspoollpcount n fsresolvefileugreadf1 accessiblity file checked u subsequent operations symlinkvarspoollpn file performed root privilege else readfilec similar manner define behavior highly simplified mail receiversender follows mail server operates storing every incoming email message spool directory corresponding recipient simplicity model act storing way loses previous contents spool file class mailerfs ug unixprocroot root sys sys fs ug sendu writevarspoolmailu finally model action comsat mail notifier program looks file etcutmp identify terminal user logged whenever new message received user comsat prints message users terminal represent content etcutmp list records add additional helper functions file system model support writing reading structured files particular interest helper function called readrec allows access specific record whose first component specified argument readrec class comsatfs ug unixprocroot root sys sys fs ug main loop readvarspoolmailrcvr msg readrecetcutmp rcvr tty writetty msg loop construct indicates operations inside loop executed forever process killed operations make use unbound variable rcvr variables treated existentially quantified operationally amounts binding variable arbitrary value domain thus comsat nondeterministically chooses file mail directory corresponding user logged printing message users terminal datanondeterminism captured use unbound variables key mechanism simplifies models develop model user users behavior also highly nondeterministic nature heshe selects arbitrary file system may read file overwrite arbitrary content user may also run arbitrary commands send arbitrary message arbitrary user arbitrary choice data values captured using unbound variables arbitrary choice among commands captured guarded command construct within loop guarded command construct within loop indicates user keep performing actions indefinitely class userugfsug unixprocuuggfsug main loop true readf1 c true writef1 c true runlpr args true mailersendu1 m1 finally put classes defined far single system model using class called init note use j operator denotes parallel composition multiple processes class initfs ug main mailerfs ug comsatfs ug useru g fs ug detecting system vulnerabilities approach use model checking techniques analyze behaviors system model simplest case security properties invariants properties must hold every state system instance simple model described previous section model legitimate ways modify password file eg passwd hence constancy password file desired system invariant section 33 describe complex temporal properties depend order events specified one important features model checking techniques ability generate counter examples sequences states lead violation given property ap plication counterexamples correspond steps attacker use exploit system vulnerabilities however current model checking tools cannot used since many components system model described section 2 infinitely many reachable states eg states file system current model checking tools work mainly finitestate systems hence developed prototype model checker based closely xmc system 18 system developed one authors paper xmc handle certain classes infinitestate systems using implicit representation state space using constraints xmc system implemented using xsb tabled logic programming system 22 casting model checking problem query evaluation problem tabling provides stronger termination properties xsb comparison untabled logic programming systems particular computations solving equations using iterative procedures eg fixpoint iteration programmed easily thus making xsb ideal platform rapid implementation program analyzers modelcheckers xmc transition relation system model treated external database verification problem solved running reachability queries database prototype follows approach significant difference reachability queries made infinite transition system case vulnerability analysis infiniteness handled exploiting following features xsb system following xmc represent states system model using terms difference prototype terms may contain logical unbound variables represent unknown data system models use constraints terms relate states system model finitestate case handled xmc states represented ground ie variablefree terms relation states simple table prototype relate states represented possibly nonground terms using equality constraints among variables use power tabling xsb identify similar states case states differ names bound variables reuse computations state similar one encountered earlier seen implementation translate highlevel model system prolog database set facts represents systems transition relation noted section 2 modelling language resembles prolog many ways factor considerably simplifies translation al gorithm fact translation similar described 10 translating processes described valuepassing process algebra logic program rules representing transition relation although translation algorithm conceptually simple implementation still requires significant effort given small scale models found easier perform translation manually following first assume property verified specified formula temporal logic 14 describe notion intentions model see section 33 eliminates need encode complex security properties temporal logic model checking procedure implemented reachability query evaluated using xsb system 31 model checking infinitestate systems infiniteness state space system arises two factors data nondeterminism finite branching factor execution histories infinitely long paths handled using different feature model checker infiniteness due data nondeterminism handled term constraints recall data nondeterminism arises unbound variables system model term constraints capture possible values variables succinctly constraints represented manipulated xsb system need programming instance consider problem verifying whether etcpasswd overwritten system model section 2 observe example system evolve arbitrary user chooses perform write action file user sends mail logicprogrammingbased model checker neither user message needs bound particular value represent logical variables unification backtracking automatically generate cases interest binding variables values lead vulnerabilities instance user sends mail process comsat enabled sends notification using write destination specified etcutmp note point neither contents permissions etcutmp known model checker tries case turn binding variables needed set values etcutmp unreadable required entry destination notifying incoming mail found notification sent system reverts back original state hand destination notification present etcutmp write issued since contents etcutmp unknown note left variable destination etcpasswd indeed possible change password file model thus model checking algorithm concludes etcutmp specifies etcpasswd one notification destinations possible violate system security infinite execution sequences handled abstracting sequences finite possibly peating segments certain kind particular importance abstraction bounds lengths sequences capturing unknown dontcare values variables automatically abstract infinite execution sequences instance consider user write action arbitrary file system model section 2 constitute progress since enable state change impossible lack progress easily captured term con straints state write operation arbitrary file f files content represented variable say c f state write operation files content changed c 0 f simply variant ie identical modulo variable renaming original content effect write operation known say new content new state instance ie subsumed old state hence new transitions possible thus see progress seen change modulo term subsumption scenario assumed nothing known initial state system files contents relevant permissions etc systems initial state least par tially known users write action changes system state instance constraint etcutmp reference etcpasswd may longer true arbitrary write action done access permissions etcutmp allow write action succeed thus state system arbitrary write action different initial state sys tem model checker explore system evaluation state conclude potential vulnerability long etcutmp modified arbitrary user variable abstraction alone insufficient general employ approximations lose information either ignoring state changes thus pruning execution sequences ignoring conditions state changes thus repeating execution sequences note abstraction may incomplete sense vulnerabilities original model may present abstract model however limitation reasonable case assume system vulnerabilities exploited human attackers using intuition expertise come attack scenarios implies sequence actions would perform achieve intrusion typically short sequence thus may acceptable miss vulnerabilities require long sequences actions based assumption method uses search procedure iterative deepening stopping search predetermined depth search procedure uses programming tabling capabilities xsb 32 generating counterexamples counterexample traces produced model checker correspond directly attack scenarios hence set counterexamples used drive intrusion detection note even finitestate case infeasible enumerate possible counterexamples overcome problem avoid explicit enumeration counter examples instead choosing represent using finitestate automaton automaton represents set c counterexamples example c 2 c corresponds path automaton automata representation succinct used directly intrusion detection moreover automaton constructed inspecting memo tables built model checking table entries form states automaton dependencies entries form transitions automatabased representation counterexamples extends naturally case infinite state systems well case state automaton associated set variables transitions specify conditions values automata ability represent generic counterexamples parameterized respect specific system configura tions generate counterexamples leaving initial state system unbound using data nondeterminism lazily binding state variables explained earlier comsat example automata representing generic examples instantiated particular system configuration parameters check vulnerabilities thus automata generic respect configurations however automata must regenerated systems capabilities change eg new services added note general infinitestate systems may finite representation set counterexamples however note abstractions use bound length counter example sequences thereby making possible find finite representation set counter examples 33 beyond invariant properties comsat example explained earlier property interest invariant general however one would interested path properties instance may password changing program passwd system allows user modify hisher password thus change contents password file clearly execution paths password file changed passwd program system administrator correspond vulnerabilities path properties encoded temporal logic 14 eliminate degenerate paths superuser changes password file changed passwd pro gram done adding antecedents original safety property violated degenerate paths problem arises context vulnerability analysis description degenerate paths tends become large since many degenerate cases instance may many different ways superuser change password file overwriting using editor using passwd command etc enumerating degenerate paths impractical since temporal logic formula becomes large difficult understand hence likely contain errors address problem propose following approach original safety property left unchanged order eliminate degenerate paths develop second model called intentions model intentions model captures intended outcome executing every program intentions stated terms files may written executed course executing program system model vulnerabilities contains paths unsafe states exists corresponding path intentions model example intention model mail daemon would writes files directory usrspoolmail intention model lpr would writes files directory usrspoollp intention model passwd program would writes etcpasswd file intention model default refer normalized file names correspond absolute file names symbolic links would appropriate case mail daemon lpr situations symbolic links permitted made explicit intentions model instance intention model cp program state overwrite file provided argument regardless whether symbolic link intentions model used model checker must disregard intended paths ie paths every action also intentions model simple way leave model checker unchanged prune away paths counterexample automaton clearly efficient techniques eliminate intended paths developed topic current research 4 analysis results current implementation finds vulnerabilities expressed violations invariant properties reporting violations distinguish value initial system configuration parameters sequence events leads violation present results scenario condition specifies configuration parameters exploit path leads violation 41 vulnerabilities due comsat given simple model unix system described section 2 current implementation identifies following vulnerabilities would ultimately enable password file overwritten vulnerabilities found using query check reachability writeetc passwd state arbitrary process writes etcpasswd first vulnerability identified trivial one corresponds case password file worldwritable even though obvious vulnerability nevertheless interesting discovery given model even mention file etcpasswd use data nondeterminism models implementation using termconstraints enables us derive scenario fsresolveetc passwdu1g1writef1 scenario useru1g1fsugwriteetc passwd way read follows exists file etcpasswd writable user u1 belonging group g1 user write password file arbitrary data second vulnerability identified comsat vulnerability described introduction happens user u1 permission write theetcutmp file note vulnerability identified even model checker provided information original state system virtue way term constraints handled modelchecker able infer appropriate relationships must hold contents etcutmp file password file well file permissions must hold vulnerability exploited fsresolveetc utmpu1g1writef1 scenario useru1g1fsugwriteetc utmp u2 etc passwd useru3g3fsug invokes mailersendu2 mailerwritevar spool mail u2 comsatreadvar spool mail u2 comsatreadrecetc utmp u2 etc passwd comsatwriteetc passwd scenario read follows first step user u1 writes file etcutmp record u2 etcpasswd next step user u3 invokes mailer program send message user u2 causes mailer write message spool file varspoolmailu2 fourth step comsat program reads spool file fifth step comsat reads record etcutmp indicates u2 logged terminal etcpasswd record written first step scenario overwrites etcpasswd mail message note although scenario mentions three users u1 u2 u3 three existentially quantified variables means user third vulnerability similar second one user directly overwrites spool file instead using mailer update spool file order user must write permission spool file extra condition captured condition fsresolveetc utmpu1g1write fsresolvevar spool mail u2u3g3write scenario useru1g1ugwriteetc utmp u2 etc passwd useru3g3ugwritevar spool mail u2 comsatreadvar spool mail u2 comsatreadrecetc utmp u2 etc passwd comsatwriteetc passwd another attack scenario interesting variation previous attack require write permission etcutmp brings together two known exploits one involving use symbolic links comsat vulnerability mentioned although developed models realized model contained vulnerability noteworthy spite simplicity models used model checking procedure identified vulnerabilities unknown us fsresolvevar spool mail u2u1g1writef1 scenario useru1g1fsugsymlinkvar spool mail u2 etc utmp useru3g3fsug invokes mailersendu2 u4 etc passwd mailerwritevar spool mail u2 u4 etc passwd useru5g5fsug invokes mailersendu4 mailerwritevar spool mail u4 comsatreadvarspoolmailu4 comsatreadrecetc utmp u4 etc passwd comsatwriteetc passwd scenario user u1 first symbolically links spool file varspoolmailu2 etcutmp second step user u3 invokes mailer send message user u2 message body consists single record u4 etc passwd third step mailer writes record onto spool file varspoolmailu2 since spool file linked etcutmp file first step record actually written etcutmp file note step happens mailer blindly overwrites spool file corresponding user u2 without checking whether user particular u2 write permission file b whether symbolic link rest steps exploit identical previous vulnerability 42 vulnerabilities due lpr analysis abstracted system model lpr making temporary spool file name constant ie making counting modulo 1 instead 1000 combination symbolic links standard spool file naming convention introduces following vulnerability fsresolvef1u1g1writef2 fsresolveetc passwdu2g2readf3 scenario useru1g1fsugwritef1c1 useru2g2fsugrunlpr useru3g3ugrunlpr f1 since start initial state corresponds unbound variable files printed initial state scenario shows file created later read also requires read permission password file concluding remarks paper presented new modelbased approach analyzing configuration vulnerabili ties whereas previous approaches relied expert knowledge codify causes configuration vulnerabilities step necessary approach consequently approach identify previously exploited vulnerabilities also discover new ones never exploited examples demonstrate capability discover vulnerabilities knowledge vulnerabilities never encoded system model analysis able detect vulnerabilities even identified vulnerabilities whose presence system model unknown us results analysis used many ways first obvious use reconfiguring system eliminate vulnerabilities identified modelbased analysis reconfigured system reanalyzed ensure vulnerabilities eliminated second use feed counterexamples generated analysis intrusion detection system intrusion detection system identify attempts exploit vulnerabilities identified analysis may able prevent succeeding third way use analysis begin minimal information initial state system case analysis generates assumptions initial system lead vulnerabilities assumptions correspond vulnerability causes encoded configuration checkers cops satan main challenge using approach presented paper one scale although model checker easily handle models described paper realistic system models much larger making significantly harder perform accurate analysis however believe temporary difficulty authors paper well number researchers developing better better model checkers able handle larger larger systems second challenge effort required developing models investigating source code analysis techniques help automate model generation process r taxonomy security faults rule based analysis security checking checking race conditions file access critical analysis vulnerability taxonomies tabled evaluation delaying general logic programs design synthesis synchronization skeletons using branchingtime temporal logic automatic verification finitestate concurrent systems using temporal logic specifications computer aided verification96 state art future directions optimizing compiler efficient model checking cops security checker system model checker spin temporal logic reactive concurrent systems specifi cation communication concurrency specification verification concurrent systems cesar xmc logicprogrammingbased verification toolset efficient modelchecking using tabled resolution using model checking analyze network vulnerabilities oldt resolution tabulation xsb logic programming system v2 tr communicating sequential processes automatic verification finitestate concurrent systems using temporal logic specifications old resolution tabulation temporal logic reactive concurrent systems tabled evaluation delaying general logic programs formal methods model checker spin communication concurrency optimizing compiler efficient model checking specification verification concurrent systems cesar efficient model checking using tabled resolution symbolic model checking design synthesis synchronization skeletons using branchingtime temporal logic using model checking analyze network vulnerabilities rule based analysis computer security ctr wei li rayford b vaughn yoginder dandass approach model network exploitations using exploitation graphs simulation v82 n8 p523541 august 2006 gordon thomas rohrmair gavin lowe using dataindependence analysis intrusion detection systems theoretical computer science v340 n1 p82101 13 june 2005 xinming ou sudhakar govindavajhala andrew w appel mulval logicbased network security analyzer proceedings 14th conference usenix security symposium p88 july 31august 05 2005 baltimore md peng ning dingbang xu learning attack strategies intrusion alerts proceedings 10th acm conference computer communications security october 2730 2003 washington dc usa peng ning dingbang xu hypothesizing reasoning attacks missed intrusion detection systems acm transactions information system security tissec v7 n4 p591627 november 2004
bit section instruction set extension arm embedded applications programs manipulate data subword level ie bit sections within word common place embedded domain examples applications include media processing well network processing codes applications spend significant amounts time packing unpacking narrow width data memory words execution time memory overhead packing unpacking operations greatly reduced providing direct instruction set support manipulating bit sectionsin paper present bit section extension bsx arm instruction set selected arm processor research one popular embedded processor also used basis building many commercial network processing architectures present design bsx instructions encoding arm instruction set incorporated implementation bsx simplescalar arm simulator michigan results experiments programs various benchmark suites show using bsx instructions total number instructions executed runtime many transformed functions reduced 426 2727 code sizes reduced 127 2105 b introduction programs embedded applications frequently manipulate data represented bit sections within single word need operate upon bit sections arises applications often involve data smaller word even byte moreover also characteristic many applications point data maintained packed form multiple data items must packed together single word memory fact cases input output application consists packed data input consists packed data application typically unpacks processing output required packed form application computes results explicitly packs generating output since packing unpacking data characteristic application domain reflected source program work assume programs written c language widely used language embedded domain c programs packing unpacking data involves performing many bitwise logical operations shift operations important applications manipulate subword data include media processing applications manipulate packed narrow width media data network processing applications manipulate packets typically embedded applications receive media data data packets transmission medium therefore order make best use communication bandwidth desirable individual subword data item expressed natural size expanded 32 bit entity convenience however data deposited memory either upon arrival input prior transmission output clearly exists packed form processing packed data typically involves unpacking data generation packed data typically involves packing data require execution additional instructions carry shift logical bitwise operations instructions cost cycles also increase code size examples given taken adpcm audio gsm speech applications respectively first example illustration unpacking operation extracts 4 bit entity inputbuffer second example illustrates packing 5 bit entity taken larc2 3 bit entity taken larc3 unpacking packing addition generation extra instructions packing unpacking data consequences packing unpacking additional memory locations registers required hold values packed unpacked form increase register pressure results increase memory requirements cache activity finally factors influence total energy comsumption vital concern paper present bit section extension bsx arm processors instruction set bit sections subword entities manipulated programs selected arm processor research one popular embedded processor also used many commercial network processing architectures built today present design bsx instructions encoding arm instruction set newly designed instructions allow us specify register operands bit sections 32 bit values contained within registers result data stored packed form directly accessed manipulated thus need performing explicit unpacking operations eliminated similarly computed results stored directly packed form eliminates need explicit packing operations incorporated implementation bsx simplescalar arm simulator michigan results experiments programs various benchmark suites show using bsx instructions number instructions executed programs significantly reduced functions bsx instructions used observed reduction dynamic instruction counts ranges 426 2727 code sizes functions reduced 127 2105 remainder paper organized follows section 2 describe design bit section specification methods incorporation various types instructions also show new instructions encoded using unused encoding space arm instruction set section 3 describes approach generating code makes use bsx instructions section 4 describes experimental setup results experiments related work instruction set design compiler techniques taking advantage instructions discussed section 5 concluding remarks given section 5 2 bit section extensions bsx 21 bit section descriptors subword level data entities called bit sections bit section sequence consecutive bits within word bit section vary 1 bit long 32 bits long specify bit sections use bit section descriptors bsds specify bit section within word two options one way specify starting bit position ending bit position within word another way specify starting bit position bit section length either way takes 10 bits specify single bit section 5 bits starting position 5 bits length ending position use form specifies length bit section analyzing mediabench commbench programs found many operations involve multiple bit section operands size therefore one instruction involves multiple bit section operands share bit section length specification lengths multiple bit sections used instruction often specified ending bit position bit sections often different thus unlike length ending position specification cannot shared 22 bit section addressing modes two different addressing modes bit section descriptors specified position many bit sections within word boundary determined compile time position bit sections determined run time therefore need two addressing modes specifying bit sections bit section operand specified immediate value encoded within instruction bit section specified register cannot expressed immediate constant number bit section operands used various instructions vary one three 221 immediate bit section descriptors immediate bit section descriptor encoded part struction let us assume r register operand instruction specified using 4 bits arm contains 16 registers r0r15 operand bit section within r whose position within r known fixed immediate bit section descriptor associated register follows rstart len refers bits startstart len 1 r constant start 5 bits starting position bit section may vary bit 0 bit 31 len also 5 bits number bits bit section include bits 031 register note valid bit section descriptors start len 1 never greater 31 immediate bit section descriptors used either instruction one bit section operand two bit section operands two bit section descriptors need specified len specification hence shared two descriptors shown r1start1 r2start2 len refers bits start1start1 len 1 r1 bits start2start2 len 1 r2 222 register bit section descriptors operands instruction well result bit sections three bit section descriptors need specified even though three bit sections share length possible specify three bit sections immediates enough bits available instruction carry task therefore cases specification bit section descriptors stored register rather immediate value instruction another reason specifying bit section descriptors registers situations positions lengths bit sections within register fixed rather determined runtime program case bit section descriptor immediate value specified part instruction rather descriptor computed register specified part instruction register specifies bit section descriptor may specify one two three bit sections one two three possibly different registers shown register r contains bit section descriptors appropriate operand registers r1 r3 contents r organized shown figures 1 2 3 len figure 1 bit section descriptor 1 bit section len start115 figure 2 bit section descriptor 2 bit sections len start21520 start1 figure 3 bit section descriptor 3 bit sections 23 bit section instructions encoding next describe arm instructions allowed use bit section operands principle possible allow existing arm instruction register operands access bit sections within register operands cannot allow instructions flexibility would many new variations instructions enough space encoding arm instructions accommodate new instructions therefore choose selected subset instructions likely involved bit section operations developed variations benchmarks studied possible operations related data processing therefore eight data processing instructions chosen version 5t arm instruction set include six alu instructions add sub eor orr rsb well compare move cmp mov instructions selection instructions based studying number multimedia benchmarks determining type instructions commonly needed figure 4 shows percantage total executed instructions fall category instruction types selected supporting bit section operands see selected instructions account significant percentage dynamic instruction counts adpcmdecoder adpcmencoder jpegcjpeg g721decode g721encode castdecoder castencoder frag thres bilint histogram convolve softfloat dh 0 10 20 30 40 50 70 80 90 100 percentage selected instructions counts figure 4 dynamic frequency selection instructions 231 instructions immediate bsds instructions provide three variations immediate bit section operands used version 5t arm instruction set encoding space prefix 11110 undefined use remaining 27 bits space undefined instruction deploy new instructions 27 bits three bits used distinguish eight operations involved let us discuss three variations alu instruc tions first variation fv alu instructions corresponding instructions two bit section operands therefore one operands acts source operand destination variants cmp mov instructions slightly different require two operands unlike alu instructions require three operands cmp two bit section operands source operands mov one operand source destination cannot allow three operands bit section operands time three bit section operands need least 32 bits specify encoding instructions shown prefix 11110 bits 31 27 indicates presence bsx instruction three bits encode eight operations bits 24 26 bit 23 0 indicates first variation instruc tion remaining bits encode two bit section descriptors rdrds len rmrms lenopcode1 1 1 1 rd rds rm len 28 27 26 24 23 22 19 rms figure 5 first variation alu instructions second variation sv instructions three operands one destination register bit section one source register bit secion third operand bit section operand variation operation done bit section zero extended specify variation bit 23 must 1 bit 14 must 0 instruction format encoding shown 28 27 26 24 23 22 19 rms figure instructions cmp mov slightly different need two operands bit 15 flag indicate whether bit section treated unsigned signed entity 0 unsigned zero extended operation 1 bit section signed therefore first bit bit section extended operation 28 27 26 24 23 22 19 rms figure 7 cmp mov instructions rms figure 8 third variation alu instructions third variation tv one 8 bit immediate value one operands one bit section descriptor represents second operand latter bit section also serves destination operand specify variation bit 23 must 1 bit 14 must 1 instruction format encoding shown 232 instructions register bsds instructions three variations register bit section operands used variations differ number bit section operands found another undefined instruction space prefix 11111111 encode instructions version 5t arm instruction set encoding instructions follows bits 19 21 contain opcode bits 17 stand number bit section operands instructon therefore 01 10 11 correspond presence 1 2 3 bit section operands bit specifies whether bit section contains unsigned signed integer format encoding instructions given rn figure 9 alu instructions register bsds figure 10 cmp mov instructions register bsds rms rns figure figure 12 setup specifier instructions cmp mov little bit different two bit section operands therefore bits 17 01 10 bits 8 11 specified bit section descriptor contains several bit sections therefore setup costs bit section descriptor register high therefore introduce new instructions opcode setup set bit section descriptors efficiently instructions set multiple values bit section descriptor simultaneously format encoding instructions given figures 11 12 instruction setup rd rns rms len set value rns rms len fields bit section descriptor held rd simultaneously 6bit setup specifer describes field set setup specifier bit 5 1 bits 0 4 represent immediate value field setup copying immediate value bit 5 0 bit 4 0 bits 0 3 used specify register field setup copying last five digits register rns specifier bit 5 0 bit 4 1 rns valid bit section specifier must ignored general since three values rns rms len registers need read registers implement instruction one cycle however practice never encountered situation need read three registers 24 bsx implementation implement bsx instructions two approaches possi ble one approach involves redesign register file bit section directly supplied register file read write operation logic inside register file ensures appropriate bits register read written alternative approach require modification register file reads writes entire register read entire register read logic provided relevant bit section selected generate bit section operand instruction similarly write update bits register cycle immediately cycle write back operation occur contents register partially overwritten read value read made available instruction write back stage relevant bit section first updated written register file extra dedicated read port provided perform extra read associated write operation advantage first approach energy effi cient even though requires redesign register file also quite simple second approach energy efficient requires greater number register reads also somewhat complex implement 3 generating bsx arm code approach generating code uses bsx instructions take existing arm code generated programs using unmodified compiler postpass selectively replace use arm instructions bsx instructions generate optimized code optimizations aimed packing unpacking operations context bit sections compile time fixed dynamically varying positions 31 fixed unpacking unpacking operation involves merely extracting bit section register contains packed data placing bit section lower order bits another register example illustrates unpacking extracts bit section 47 inputbuffer places lower order bits delta higher order bits delta 0 shown arm code requires two instructions shift instruction however single bsx instruction takes bits 4 7 zero extends places register sufficient perform unpacking arm code mov r3 r8 asr 4 r12 r3 15 0xf bsx arm code mov r12 r844 general transformation optimizes unpacking operation takes following form arm code instruction extracts bits register ri places register rj extracted bit section placed rj used possibly multiple times transformed code instruction eliminated use rj replaced direct use bit section ri transformation also eliminates temporary use register rj therefore transformation legal compiler must ensure register rj indeed temporarily used value register rj referenced following code fragment transformation rj ri masksl inst1 use rj instn use rj precondition bit section ri remains unchanged instn rj dead instn transformation inst1 use risl instn use risl 32 fixed packing arm code bit section extracted data word must perform shift operations operations eliminated bsx instruction used directly reference bit section situation illustrated example given c code takes bits 04 larc2 concatenates bits 24 larc3 first two instructions arm code extract relevant bits larc3 third instruction extracts relevant bits larc2 last instructions concatenates bits larc2 larc3 see bsx arm code two instructions first instruction extracts bits larc3 zero extends stores register r0 second instruction moves relevant bits larc2 register r1 places proper position register r0 arm code mov r0 r0 lsr 2 r0 r0 7 r2 r1 31 orr r0 r0 r2 asl 3 bsx arm code mov r0 r023 mov r035 r105 general transformation eliminating packing operations characterized follows instruction defines bit section places temporary register ri need place bit section temporary register ri arises bit section possibly used multiple times eventually bit section packed another register rj using orr instruction optimized code bit section defined directly computed position placed packing operation rj uses bit section directly reference bit section rj therefore need temporary register ri eliminated packing orr instruction eliminated transformation legal compiler must ensure register ri indeed temporarily used value ri referenced code fragment transformation ri bit section definition whole register inst1 use ri use register instn use ri use register orr rj rj ri pack bit section precondition bit sections ri rj remain unchanged orr ri dead orr transformation define pack inst1 use rj use bit section instn use rj use bit section 33 dynamic unpacking situations extraction bit sections carried position bit section determined run time example number lower order bits number equals value variable size extracted put buffer zero extended placed back put buffer since value size known compile time immediate value cannot used specify bit section descriptor instead first three arm instructions shown used dynamically construct mask used instruction extract required value put buffer optimized code bit section descriptor setup register r3 used mov instruction extract require bits place r7 arm code mov r3 1 mov r3 r3 lsl r5 sub r3 r3 1 r7 r7 r3 bsx arm code setup r3 0 r5 mov r7 r7r3 general form transformation shown arm instructions construct mask replaced single setup instruction instruction replaced mov bit section whose descriptor found register set setup instruction arm code mov ri 1 mov ri ri lsl rj sub ri ri 1 rd rn ri precondition value ri dead instruction bsx arm code setup ri rj rj mov rd rnri 34 dynamic packing packing bit sections together whose sizes known till runtime cost several instructions c code given extracts lower order p bits higher order bits n packs together arm code operation involves many instructions first required masks n generated next relevant bits extracted using masks finally packed together using orr instruc tion contrast bsx arm code uses far fewer instructions since ps value known compile time must use register bit section descriptors n arm code mov r12 1 r1 r1 r2 lsl r3 n1 16 p 1 r0 r0 r12 m1 p 1 bsx arm code setup r12 0 r3 descriptor ms bit section rsb r2 r3 16 setup r2 r3 r2 descriptor ns bit section relevant bits r0 relevant bits r0 general transformation optimizing dynamic packing operations described follows two bit sections whose positions lengths unknown compile time extracted registers currently reside put separate registers respectively mask constructed instruction used perform extraction finally packed togehter one register using orr instruction optimized code bit section setup register bit section descriptor first move bit section final register bit section descriptor directly result orr instruction removed using setup instruction simultaneously setup several fields bit section descriptor reduce number instructions comparison instruction sequence used create masks original code different types instruction sequences used create mask thus always possible identify sequences current implementation handle commonly encountered sequences arm code instruction sequence create mask1 ra rb mask1 instruction sequence create mask2 rc rd mask2 orr rm ra rc bsx arm code setup register bit section descriptor 1 move bit section 1 rm using bit section descriptor 1 setup register bit section descriptor 2 move bit section 2 rm using bit section descriptor 2 4 experimental evaluation 41 experimental setup present results experiments describe experimental setup includes simulator arm optimizing compiler set relevant benchmarks processor simulator started port cycle level simulator simplescalar 1 arm available university michigan version simulates five stage pipeline described preceding section intels sa1 strongarm pipeline 8 found example sa110 icache configuration processor 16kb cache size 32b line size 32way asso ciativity miss penalty 64 cycles miss requires going chip timing model validated rebel netwinder developer workstation 16 developers system michigan extended simulator number important ways research first modified simplescalar use system call conventions followed newlib c library instead glibc currently uses made modification newlib developed use embedded systems 10 second incorporated implementation bsx instructions purpose evaluation addition also incorporated thumb instruction set simplescalar however feature relevant paper optimizing compiler compiler used work gcc compiler built create version supports generation arm thumb well mixed arm thumb code specifically use xscaleelfgcc compiler version 29xscale programs compiled o2 level optimization use o3 level optimization function inlining loop unrolling enabled clearly since code size important concern embedded systems want enable function inlining loop unrolling translation arm code optimized bsx arm code carried optimization postpass frequently executed functions program involve packing unpack ing use bit section data translated bsx arm code remainder program modified seen transformations preceding section temporary registers freed optimizations may possible improve code quality making use registers time due limitations implementation representative benchmarks benchmarks use taken mediabench 12 commbench 21 netbench 14 bitwise 18 suites representative class applications important embedded domain also added image processing application thres following programs used adpcm encoder encode jpeg cjpeg frag cast decoder encoder image processing thres bitwise bilint histogram convolve softfloat dh 42 results next present results experiments measure improvements code quality due use bsx instructions measured reductions instruction counts cycle counts bsx arm code comparison pure arm code results given tables 1 2 results provide percentage improvements functions modified well improvements total counts entire program reduction instruction counts modified functions varies 426 2727 net instruction count reductions entire programs lower range 045 879 expected subset functions programs make significant use bsx struction reductions cycle counts modified functions varies 066 2727 net cycle count reductions entire programs range 039 867 table 5 reductions code size functions transformed make use bsx instructions given code size reductions range 127 2105 finally also studied usage bsx instructions transformations used benchmarks table 3 show types bsx instructions used benchmarks particular indicate whether fixed bsds used instructions dynamic bsds used fixed bsds also indicate three variations bit section referencing instructions used benchmark dynamic bsds also indicate use setup instruction see fixed bsds commonly used situations involving three variations bit section operands arise table 4 show kind transformations found applicable benchmarks packing unpacking involving fixed dynamic bsds see optimization every bsx instruction used program results tables 3 4 indicate fixed bsd instructions included bsx appropriate useful results register bsds negative found instances positions bsds vary runtime able develop appropriate compiler transformations effectively take advantage situations using instructions one benefits using bsx instructions often number registers required reduced multiple subword data items simultaneously reside single register longer separate hold different registers performance data presented based upon bsx arm code take advantage additional registers may become available registers used one expect additional performance gains problem global register allocation subword data beyond scope paper related paper 19 shown register requirements reduced 12 50 functions take advantage bsx instructions 5 related work wide variety instruction set support developed support multimedia network processing applications extensions exploiting subword 5 super word 11 parallelism instruction set extensions proposed yang lee 22 focus permuting subword data packed together registers network processor described 15 also supports bit section referencing paper carefully designed extension consisting small subset flexible bitsection referencing instructions showed easily incorporated popular embedded arm processor compiler research subword data divided two cat egories first work done automatically identify narrow width data second techniques automatically pack narrow width data perform register allocation instruction selection generation simd parallel instructions carried several complementary techniques identifying subword data stephenson et al 18 proposed bitwidth analysis discover narrow width data performing value range analysis budiu et al 2 propose analysis inferring individual bit values used narrow width data tallam gupta 19 propose new type dead bits analysis narrowing width data analysis zhang et al 7 aimed automatic discovery multiple data items packed program variables works packing narrow width data discovery include following davidson jinturkar 3 first propose compiler optimization exploits narrow width data proposed memory coalescing improving cache performance program zhang gupta 23 proposed techniques compressing narrow width pointer data improving cache performance techniques explored context general purpose processors change data layout memory packing aggressive packing scalar variables registers studied 19 mentioned earlier register allocation technique combined work paper improve performance another work register allocation presence bit section referencing wagner leupers table 1 reduction dynamic instruction counts benchmark instruction count savings function arm bsx arm adpcmdecoder adpcm decoder 6124744 5755944 602 total 6156561 5787760 599 adpcmencoder adpcm encoder 7097316 6654756 624 total 7129778 6687534 620 jpegcjpeg emit bits 634233 586291 756 total 15765616 15694887 045 g721decode fmult 47162982 43282495 823 predictor zero 9293760 8408640 952 step size 1468377 1320857 1005 reconstruct 2628342 2480822 561 total 258536428 253180667 207 g721encode fmult 48750464 44367638 899 predictor zero 9293760 8408640 952 step size 2372877 2225357 622 reconstruct 2645593 2498073 558 total 264021499 258163419 222 castdecoder cast encrypt 41942016 37850112 976 total 109091228 103209100 540 castencoder cast encrypt 41942016 37850112 976 total 105378485 99496358 558 frag cksum 26991150 25494952 554 total 37506531 36010318 399 threshold coalesce 3012608 2602208 1362 memo 3223563 2814963 1268 blocked memo 2941542 2531826 1393 total bilint main 87 79 920 total 496 488 161 histogram main 317466 301082 516 total 327311 310857 503 convolve main 30496 30240 084 total 30799 30542 083 softfloat float32 signals nan 132 96 2727 addfloat32sigs 29 23 2070 subfloat32sigs 29 23 2070 float32 mul float32 div rem 28 23 1786 total 898 819 879 dh nn digitmult 153713163 141768387 777 total 432372762 419604191 295 table 2 reduction dynamic cycle counts benchmark instruction count savings function arm bsx arm adpcmdecoder adpcm decoder 6424241 6202961 344 total 6499880 6278786 340 adpcmencoder adpcm encoder 7958088 7515456 556 total 8035001 7592761 550 jpegcjpeg emit bits 1047235 999163 459 total 19611965 19535002 039 g721decode fmult 63914793 60034237 607 predictor zero 12834446 11949382 690 step size 1564728 1269752 1885 reconstruct 2601534 2454014 567 total 347037906 341531879 159 g721encode fmult 65798336 61415518 666 predictor zero 12834447 11949327 690 step size 2630082 2335106 1122 reconstruct 2636030 2488439 560 total 353610636 347605462 170 castdecoder cast encrypt 46557053 40674664 1263 total 141113081 133440304 544 castencoder cast encrypt 46557174 40674817 1263 total 135572465 127900147 566 frag cksum 32698919 31205099 457 total 57745393 56207197 266 threshold coalesce 4355796 3937458 960 memo 4725060 4307735 883 blocked memo 22092904 21683166 185 total 181425566 180186381 068 bilint main 887 808 891 total 5957 5878 132 histogram main 481531 462532 395 total 496650 477807 379 convolve main 40215 39949 066 total 44945 44803 032 softfloat float32 signals nan 132 96 2727 addfloat32sigs 324 247 2377 subfloat32sigs 675 595 1185 float32 mul 577 513 1109 float32 div 397 380 428 rem 453 314 3068 total 10255 9366 867 dh nn digitmult 236874768 224929644 504 total 578187905 565434086 221 table 3 bsx instruction usage benchmark fixed bsds dynamic setup adpcmdecoder yes yes adpcmencoder yes yes jpegcjpeg yes yes yes g721decode yes yes g721encode yes yes castdecoder yes yes castencoder yes yes frag yes thres yes bilint yes histogram yes yes convolve yes softfloat yes yes yes dh yes yes table 4 transformations applied benchmark fixed bsds dynamic bsds pack unpack pack unpack adpcmdecoder yes adpcmencoder yes yes jpegcjpeg yes g721decode yes g721encode yes castdecoder yes yes castencoder yes yes frag yes thres yes bilint yes histogram yes convolve yes softfloat yes yes dh yes table 5 reduction code size benchmark code size reduction function arm bsx arm adpcmdecoder adpcm decoder 260 248 462 adpcmencoder adpcm encoder 300 284 533 jpegcjpeg emit bits 228 216 526 g721decode g721encode fmult 196 176 102 predictor zero 92 84 87 step size 76 72 526 reconstruct 96 92 417 castdecoder castencoder cast encrypt 1328 1200 964 frag cksum 108 88 1852 threshold coalesce 148 136 811 memo 296 284 405 blocked memo 212 200 566 bilint main 352 320 909 histogram main 316 312 127 convolve main 652 648 061 softfloat addfloat32sigs 348 324 690 subfloat32sigs 396 372 606 float32 mul 428 400 654 float32 div 544 520 441 rem 648 628 309 float32 sqrt 484 464 413 dh nn digitmult 112 104 714 20 work exploits bit section referencing context variables already contain packed data carry additional variable packing compiler techniques carrying simd operations narrow width data packed registers found 4 11 6 conclusions presented design bit section extension bsx arm processor easily encoded free encoding space arm instruction set found bit sections frequently manipulated multimedia network data processing codes therefore bsx instructions used quite effectively improve performance benchmarks addition reductions code size register requirements also result bsx instructions used incorporated implementation bsx simplescalar arm simulator michigan results experiments programs various benchmark suites show using bsx instructions number instructions executed programs significantly duced future work focus integrating use bsx instructions register allocation techniques aggressively pack subword variables single registers acknowledgements work supported darpa award f296010010183 national science foundation grants ccr0220334 ccr0208756 ccr0105355 eia0080123 university arizona 7 r simplescalar tool set version 20 bitvalue inference detecting exploiting narrow width computations memory access coalescing technique eliminating redundant memory accesses compiling simd within register data alignment subword parallelism dsp arm system architecture representation bit section based analysis optimization sa110 microprocessor technical reference manual intel xscale microarchitecture technical summary exploiting superword level parallelism multimedia instruction sets tool evaluating synthesizing multimedia communications systems 160mhz 32b 05w cmos risc microprocessor benchmarking suite network processors new network processor architecture high speed communications httpwww arm architecture reference manual bitwidth analysis application silicon compilation bitwidth aware global register allocation c compiler design industrial network processor commbench telecommunications benchmark network processors fast subword permutation instructions using omega flip network stages data compression transformations dynamically allocated data structures tr memory access coalescing mediabench simplescalar tool set version 20 bidwidth analysis application silicon compilation exploiting superword level parallelism multimedia instruction sets compiler design industrial network processor arm architecture reference manual arm system architecture netbench compiling simd within register bitvalue inference representation bit section based analysis optimization data compression transformations dynamically allocated data structures fast subword permutation instructions using omega flip network stages ctr sriraman tallam rajiv gupta bitwidth aware global register allocation acm sigplan notices v38 n1 p8596 january bengu li rajiv gupta simple offset assignment presence subword data proceedings international conference compilers architecture synthesis embedded systems october 30november 01 2003 san jose california usa ranjit jhala rupak majumdar bit level types high level reasoning proceedings 14th acm sigsoft international symposium foundations software engineering november 0511 2006 portland oregon usa
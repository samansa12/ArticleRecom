task scheduling networks scheduling set tasks set machines yield efficient schedule basic problem computer science operations research research problem incorporates potentially unrealistic assumption communication different machines instantaneous paper remove assumption study problem network scheduling job originates node network order processed another node must take time travel network nodeour main contribution give approximation algorithms hardness proofs fully general forms fundamental problems network scheduling consider two basic scheduling objectives minimizing makespan minimizing average completion time makespan prove small constant factor hardnesstoapproximate approximation results average completion time give logsquared approximation algorithm general form problem techniques used approximation fairly general several applications example give first nontrivial approximation algorithm minimize average weighted completion time set jobs related unrelated machines without network b introduction scheduling set tasks set machines yield efficient schedule basic problem computer science operations research also difficult problem hence much research area incorporated number potentially unrealistic assumptions one assumption communication different machines instantaneous many application domains however network computers set geographicallyscattered repair shops decisions move tasks critical part achieving efficient resource allocation paper remove assumption instantaneous communication traditional parallel machine models study problem network scheduling job originates node network order processed another node must take time travel network node work network scheduling problems either loose 2 4 approximation algo rithms main contribution give approximation algorithms hardness proofs fully general forms fundamental problems network scheduling upper bounds robust depend general characteristics jobs underlying network particular algorithmic techniques optimize average completion time yield results first nontrivial approximation algorithms combinatorial scheduling question minimization average weighted completion time unrelated machines first approximation algorithm problem motivated satellite communication systems differentiate network scheduling models traditional parallel machine models refer latter combinatorial scheduling models results yield insight network scheduling problem also demonstrate contrasts complexity certain combinatorial scheduling problems network variants shedding light relative difficulty instance network scheduling problem consists network nonnegative edge lengths define max maximum edge length vertex v network machine also given set n jobs j job j j originates time 0 particular origin machine processing requirement define p max max 1jn p j job must processed one machine without interruption job j j available processed machine 0 time dm length shortest path g k assume either identical every machine unrelated j j takes time p ij may different unrelated machines setting define p identical unrelated machine models fundamental traditional parallel machine scheduling relatively well understood 3 10 11 12 15 17 25 unless otherwise specified paper machines network assumed identical alternative view network scheduling model job j j release date time unavailable processing previous work traditional scheduling models jobs release date defined machines network model characterized allowing job j j release date different different machines j j release date k dm one generalize consider problems jobs release date chosen arbitrarily machines need reflect network structure almost upper bounds apply general setting whereas lower bounds apply release dates network structure study algorithms minimize two basic objective functions one makespan maximum completion time schedule would like jobs finish earliest time possible second average completion time define ffapproximation algorithm polynomialtime algorithm gives solution cost ff times optimal 11 previous work problem network scheduling received attention mostly distributed setting deng et al 4 considered number variants problem special case edge network unit length job processing times machines identical showed offline problem p hard see problem npcomplete jobs allowed different sizes give offline ologm max approximation algorithm also give number results distributed version problem network topology completely connected ring tree awerbuch kutten peleg 2 considered distributed version problem novel notion online performance subsumes minimization average maximum completion time give distributed algorithms polylogarithmic performance guarantees general networks also characterize performance feedbackbased approaches addition derived offline approximation results similar deng et al 2 20 alon et al 1 proved lower bound performance distributed scheduler trying minimize schedule length fizzano et al 5 give distributed 43approximation algorithm schedule length special case network ring work differs papers focusing centralized offline problem giving approximations higher quality addition approximation algorithms work general setting unrelated machines 12 summary results first focus objective minimizing makespan give 2approximation algorithm scheduling jobs networks unrelated machines algorithm gives performance guarantee identical machines special case 2approximation algorithm matches best known approximation algorithm scheduling unrelated machines underlying network 17 thus natural ask whether addition network combinatorial scheduling problem actually makes problem harder resolve question proving introduction network problem scheduling identical machines yields qualitatively harder problem show network scheduling problem polynomialtime algorithm better factor 4 3 times optimal unless even network edges length one comparing polynomial approximation scheme hochbaum shmoys 10 parallel machine scheduling see addition network indeed make problem harder although 2approximation algorithm runs polynomial time may rather slow 21 thus explore whether simpler strategy might also yield good approximations natural approach minimizing makespan construct schedules unforced idle time strategies provide schedules length small constant factor times optimal minimal computational cost variety scheduling problems 6 7 15 24 call schedules busy schedules show network scheduling problem quality degrades significantly much anomega log log factor longer optimal schedule striking contrast combinatorial model graham showed busy strategy yields 2approximation algorithm 6 fact even release dates introduced identical machine scheduling problem jobs release date machines busy strategies still give approximation guarantee 8 9 result shows combinatorial network min makespan identical machines ff min makespan identical machines log log log log busy schedules min makespan unrelated machines 32 min avg completion time unrelated machines n min avg wtd completion time unrelated machines release dates ff olog 2 n figure 1 summary main algorithms hardness results notation x ff means approximate problem within factor unless problem within factor x unreferenced results new results found paper release dates jobs allowed different different machines busy scheduling degrades significantly scheduling strategy provides evidence introduction network makes scheduling problems qualitatively harder however busy schedules quality show length factor log log longer optimal analysis gives better bound olog max bound previously known approximation algorithms identical machines network 2 4 20 turn nphard problem minimization average completion time major result optimality criterion olog 2 napproximation algorithm general setting unrelated machines formulates problem hypergraph matching integer program approximately solves relaxed version integer program find integral solution relaxation employing subroutine techniques plotkin shmoys tardos 21 combinatorial scheduling schedule minimum average completion time found polynomial time even machines unrelated techniques average completion time algorithm fairly general yield olog 2 napproximation minimizing average weighted completion time special case result olog 2 napproximation algorithm nphard problem minimizing average weighted completion time unrelated machines network previous approximation algorithms known even special case machines different speeds 3 15 another special case first olog 2 napproximation algorithm minimizing average completion time jobs release dates unrelated machines previous approximation algorithms known even special case one machine 15 technique also used give approximation algorithm problem motivated satellite communication systems 18 26 also give number results including polynomialtime algorithms several special cases abovementioned problems 5 approximation variant network scheduling job origin also destination summary upper bounds hardness results appears figure 1 line research quite different yet still similarity spirit started papadimitriou yannakakis 19 modeled communication issues parallel machine scheduling abstracting away particular networks rather describing communication time two processors one networkdependent constant considered scheduling precedenceconstrained jobs infinite number identical machines model issues involved sorts theorems proved quite different results although algorithms polynomialtime algorithms tend rather inefficient rely work 21 subroutine result discuss running times explicitly rest paper makespan section study problem minimizing makespan network scheduling problem first give algorithm comes within factor 2 optimal show nearly best hope nphard approximate minimum makespan within factor better 4 3 identical machines network hardness result contrasts sharply combinatorial scenario polynomial approximation scheme 10 2approximation algorithm computationally intensive consider simple strategies typically work well parallel machine scheduling another sharp contrast parallel machine scheduling show performance strategies degrades significantly network setting prove anomega log log lower bound performance algorithm also show greedy algorithms performance guarantee namely log log log finally consider variant problem job origin also destination give 5 approximation algorithm 21 2approximation algorithm makespan section describe 2approximation algorithm minimize makespan set jobs scheduled network unrelated machines bound identical machines follows special case let u instance unrelated network scheduling problem optimal schedule length assuming know show construct schedule length 2d converted via binary search 2approximation algorithm problem given 10 optimal schedule length know sum time job spends travelling processed bounded thus job j j may run machine optimal schedule words length optimal schedule altered allow job j j run machines 1 satisfied formally given job j j denote qj j set machines satisfy 1 restrict j j run machines qj j length optimal schedule remains unchanged combinatorial unrelated machines scheduling problem z follows optimal schedule unrelated network scheduling problem length optimal solution unrelated parallel machine scheduling problem 2 use 2approximation algorithm lenstra shmoys tardos 17 assign jobs machines following theorem easily inferred 17 theorem 21 lenstra shmoys tardos 17 let z unrelated parallel machine scheduling problem optimal schedule length exists polynomialtime algorithm finds schedule length 2d property job starts time theorem 22 exists polynomialtime 2approximation algorithm minimize makespan unrelated network scheduling problem proof given instance unrelated network scheduling problem shortest schedule length form unrelated parallel machine scheduling problem z defined 2 use algorithm 17 produce schedule length 2d schedule immediately correspond network schedule jobs may scheduled run release dates however allocate units time sending jobs machines run allocate 2d units time run schedule immediately get schedule length 3d network problem careful create schedule length 2d network problem schedule machine assigned set jobs let js j sum processing times jobs let max job largest processing time machine call processing time p max theorem 21 fact last job run machine longer longest job run know js denote set jobs form schedule machine running job max time jobs 0 schedule jobs assigned machine clearly finish time 2d remains shown jobs routed proper machines time need run job must start time conditions 1 2 guarantee arrives time remaining jobs need arrive time conditions 1 2 guarantee well thus produced valid schedule length 2d observe approach fairly general applied problem characterized condition 2 consider example following general problem call generalized network scheduling costs addition usual unrelated network scheduling problem time takes job j j travel edge dependent endpoints edge also job cost c ij associated processing job j j machine given schedule job j j runs machine j cost schedule given target cost c define sc minimum length schedule cost c theorem 23 given target cost c polynomial time find schedule generalized network scheduling problem makespan 2sc cost c schedule cost c exists proof use similar techniques used theorem 22 first modify condition 1 ddelta delta depends job well use generalization algorithm lenstra shmoys tardos unrelated machine scheduling due shmoys tardos 25 given target cost c finds schedule cost c length twice shortest schedule cost c schedule returned also property job starts time proof theorem 22 goes use algorithm place algorithm 17 22 nonapproximability theorem 24 npcomplete determine instance identical network scheduling problem schedule length 3 even network proof see appendix corollary 25 exist ffapproximation algorithm network scheduling problem even network proof algorithm ff 43 would give exact answer problem schedule length 3 since approximation 4 would high relative error hard see via matching techniques polynomialtime decidable whether schedule length 2 show case machines network unrelated lenstra shmoys tardos proved npcomplete determine schedule length 2 traditional combinatorial unrelated machine model 17 allow multiple machines one node proof proves theorem 26 zero length edges allowed ie machine forced different network node proof work give different proof hardness include paper theorem 26 exist ffapproximation algorithm unrelated network scheduling problem ff 32 unless even network 23 naive strategies algorithms section 21 give reasonably tight bounds approximation schedule length although algorithms run polynomial time may rather slow 21 thus explore whether simpler strategy might also yield good approximations natural candidate busy strategy construct busy schedule time idle machine idle job j j job j j started time busy strategies variants analyzed large number scheduling problems see 15 quite effective many combinatorial identical machine scheduling graham showed strategies yield section analyze effectiveness busy schedules identical machine network scheduling part interest analysis lies reveals relative hardness scheduling without underlying network namely introduction underlying network make simple strategies much less effective problem 231 lower bound construct family instances network scheduling problem demonstrate instance busy schedule omegagamma log log longer shortest schedule instance network e consists levels nodes level nodes node level connected every node level edge length 1 machine levels ae jobs size 1 time 0 machines level initially receive jobs optimal schedule length instance 2 achieved machine level taking exactly one job level gamma 1 call instance see figure 2 main idea lower bound construct busy schedule machine always processes job originated job available greediness prevents scheduler making much larger assignment jobs machines time 2 job assigned machine one level away construct busy schedule use algorithm b step constructs subschedule time step phase 1 machine processes one job originated jobs remain call jobs local machine r r r r r level 1 level 2 level l figure 2 lower bound instance theorem 28 circles represent processors numbers inside circles number jobs originate processor time 0 levels completely connected optimal schedule length 2 achieved shifting job unique processor one level right phase 2 consider bipartite graph g one vertex representing job unprocessed phase 1 time contains one vertex representing machine job assigned phase 1 step x 2 job x originated distance gamma 1 machine complete construction time processing jobs machines based maximum matching g clear busy apply algorithm b instance behavior follows welldefined pattern phase 2 step 2 unprocessed jobs originated level processed distinct processors level phase 2 step 3 unprocessed jobs originated levels processed machines levels continues step additional gamma 1 levels pass jobs higher levels jobs processed continues either level 1 passes jobs processes jobs characterize behavior algorithm formally following lemma lemma 27 let ji number local jobs processor still unprocessed phase 2 step let levi level number processor times 2 ae proof prove lemma induction phase 2 step 2 edges graph g connect levels gamma 1 ae gamma1 nodes level ae gamma2 ae gamma 1 remaining jobs local machines level gamma 1 matching assigns unprocessed jobs level level machines level 1 process local jobs phase 1 result neighbors machines levels 1 busy phase 1 cannot process jobs local machines phase 2 number local jobs machines therefore decreases 1 thus base case holds assume lemma holds greater b well show ji 0 level bx ae bxgamma1 processors level ae delta ae bxgammat 0 local jobs remaining 0 2 enough machines level b x process remaining jobs local level b another highestnumbered levels local jobs completed time 0 thus time 0 since assumed sufficiently large initial workloads processors levels induction hypothesis machines levels less distance local jobs remaining time assigned local job phase 1 step 0 therefore machines levi jobs higher levels ji 0 depending relative values ae either machine level 1 processes jobs originated jobs processed machines highernumbered levels balancing two cases get following theorem theorem 28 family instances identical machine network scheduling problem defined exist busy schedules length log log longer optimal proof first case 3 apply level 1 1 inequality hold 2 hold 2 schedule length 2 ae 2 jobs level 1 totally processed level takes ae time therefore makespan min ae given total number machines calculation reveals minc ae maximized log log thus busy schedule length log log longer optimal note example shows several natural variants busy strategies scheduling job machine finish first scheduling job closest available processor also perform poorly 232 upper bound contrast lower bound previous subsection prove busy schedules quality given instance network scheduling problem define c length shortest schedule c length schedule produced algorithm causes confusion drop use notation c definition 29 consider busy schedule instance identical machines network scheduling problem let p j number units job j j remaining processed schedule time w total work remaining processed schedule time lemma 210 w ic proof partition schedule consecutive blocks happens block schedule optimal schedule length c instance consider job j j started time c schedule let j machine job j j processed schedule means block b 1 machine j busy units time job j j slot schedule period time job j j processed machine j schedule hence every job j j started block equal amount unique work identify processed block b 1 implying wc max successive applications argument yields w ic proves lemma 2 obtain stronger bound w ic increase amount processed work identify unstarted job choose 3 consider job j j unstarted schedule start block b i1 namely time ic assume sake simplicity every block b k schedule one job processed job j j slot time job j j would processed block b k schedule assume also job exactly size job j multiple jobs processed argument essentially let j r job took job j j slot block b r r 2 show j j could processed j r slot block b 2 figure 232 illustrates network structure used argument assume job j j originated machine job j r originated machine job j j processed machine j schedule dm since job j j processed machine j schedule dm j rc since job j r processed job j j slot block b r thus dm consequently j j could run job j r slot blocks b focus block b since j j processed schedule busy job must processed job j r slot block identify work job j note work ever identified one job consider igamma2 different jobs processed j j slot blocks consider jobs processed slots b see job j j unstarted time ic uniquely identify units work processed block r r figure 3 j r takes j j slot b r machine j j originates distance r r machine j r runs thus j j could run j r slot block slots full block b job j j would started one including work processed job j j slot block b obtain corollary 211 time ic max m2i machines completely busy proof w 0 mc therefore lemma 210 w ic machine completely busy time ic c work time therefore m2i machines completely busy get stopping point recurrence require following lemma lemma 212 busy schedule time remaining unprocessed jobs originated machine schedule longer let one machine remaining local jobs let w amount work machine done machine optimal schedule clearly equals amount work originated machine work left originated machines machine process least w work machine next c steps c steps work originating machine done finished otherwise machine processed less w work time means work take therefore c steps jobs originated machine started job longer c suffices finish jobs started ready prove upper bound theorem 213 let busy scheduling algorithm instance identical machine network scheduling problem c log log c proof machine ever falls idle local work must started otherwise would process remaining local work thus corollary 211 lg time number processors local work remaining reduced 1 lemma 212 number processors remaining local work one constant number extra blocks suffice finish 24 scheduling origins destinations subsection consider variant unrelated machine network scheduling problem job processed destination machine must travel specif ically addition origin machine job j j also terminating machine j begins machine travels distance dm machine j machine gets processed proceeds travel dm j units time machine j call problem pointtopoint scheduling problem theorem 214 exists polynomialtime 5 approximation algorithm minimize makespan pointtopoint scheduling problem proof construct unrelated machines scheduling problem proof theorem 22 setting condition job j j run machine depends time j j get time processed time proceed destination machine thus characterization job j j able run machine optimal schedule given job j j define qj j set machines satisfy 4 form combinatorial unrelated machines scheduling problem follows approximately solve problem using 17 obtain assignment jobs machines pick machine let j set jobs assigned machine theorem 21 know sum processing times jobs j except longest partition set jobs j three groups place job lowest numbered group appropriate 1 j 0 contains job j longest processing time 2 j 1 contains jobs dm 3 j 2 contains jobs dm sum processing times jobs group j k 2 noted always schedule j 1 block consecutive time steps call b first pj 1 steps taken jobs j 1 last pj 2 steps taken jobs j 2 note may idle time interior block consider two possible scheduling strategies based relative sizes pj 1 case 1pj 1 case first run long job j 0 condition 4 finishes time run block b time 2d since pj 1 jobs j 1 finish time 3d2 condition 4 reach destinations time 5d2 definition j 2 job j scheduled complete processing time 2d arrive destination time 5d2 case 2 pj 1 first run block b time d2 3d2 start long job j 0 time 3d2 condition 4 arrives destination time 5d2 since pj 2 machine need start processing job j 2 hence guaranteed arrived machine time definition j 1 jobs available time d2 straightforward condition 4 jobs arrive destinations time 5d2 also show analysis algorithm tight algorithms assign jobs processors using linear program defined 17 using processing times specified equation 5 let length optimal schedule construct instances schedule length least 52d gamma 1 consider set k1 jobs particular machine specify largest jobs size origin destination machine specify k jobs size dk distance origin destination machines combinatorial unrelated machines algorithm may certainly assign jobs clear schedule adopted machine competion time least 5 2k 3 average completion time 31 background turn network scheduling problem objective minimize average completion time given schedule let c j time job j j finishes running average completion time 1 whose minimization equivalent minimization throughout section assume without loss generality n noted section 1 network scheduling model characterized set set release dates r ij j j available time r ij noted generalization traditional notion release dates r refer latter traditional release dates unmodified phrase release date refer general r ij minimization average completion time jobs release dates polynomialtime solvable 3 12 even unrelated machines solution based bipartite matching formulation one side bipartition jobs side machine position pairs matching j j corresponds scheduling j j kthfromlast position edge weighted kp ij j j contribution average completion time j j kth last release dates incorporated scheduling model seems difficult generalize formulation clearly generalized precisely arbitrary release dates since even one machine version problem minimizing average completion time jobs release dates strongly nphard 3 intuitively even approximate generalization formulation seems difficult since jobs available time 0 ability j j occupy position dependent jobs precede release dates associated network structure contain traditional release dates subclass even one machine npcompleteness network scheduling problem follow immediately combinatorial hardness results however surprisingly minimizing average completion time network scheduling problem npcomplete theorem 31 network scheduling problem objective minimum average completion time npcomplete even machines identical edge lengths 1 proof see appendix follows develop approximation algorithm general form problem follow basic idea utilizing bipartite matching formulation however need explicitly incorporate time formulation addition rest section consider general optimality criterion average weighted completion time j j associate weight w j goal minimize algorithms handle general case addition allow nm release dates r ij arbitrary necessarily derived network structure 32 unitsize jobs consider first special case unitsize jobs theorem 32 exists polynomialtime algorithm schedule unitsize jobs network identical machines objective minimizing average weighted completion time proof reduce problem minimumweight bipartite matching one side bipartition node job j j 1 j n side node described edge included j j available time inclusion edge matching represent scheduling j j time 1 release dates included model excluding edge available time determine necessary sets observe advantage unforced idle time since job one unit long reason make wait job higher weight released clear therefore setting would suffice since job would need scheduled n time later release date reduced omit details sake brevity excluding edges give job j j enough time travel machine runs destination machine j prove similar theorem pointtopoint scheduling problem defined section 24 theorem 33 exists polynomialtime algorithm solve pointtopoint scheduling problem objective minimizing average weighted completion time unitsize jobs 33 polynomialsize jobs turn difficult setting jobs different sizes unrelated machines minimization average weighted completion time setting strongly nphard many special cases example minimization average completion time jobs release dates one machine strongly nphard 16 approximation algorithms known special case say nothing parallel identical unrelated machines weighted completion times release dates namely jobs available time 0 minimization average weighted completion time nphard parallel identical machines small constant factor approximation algorithm known problem 14 approximation algorithms known general cases machines different speeds unrelated machines introduce techniques yield first approximation algorithms several problems well discuss section 35 approximation algorithm minimum average completion time begins formulating scheduling problem hypergraph matching problem set vertices union two sets j set hyperedges denoted f j contain n vertices j j one job contain mt vertices upper bound number time units needed schedule instance time units range g node machine time pair denote node corresponds machine time hyperedge e 2 f represents scheduling job j j machine time 1 2 including nodes j cost edge e denoted c e weighted completion time job j j scheduled manner represented e one edge hypergraph feasible scheduling job machine exclude edges would violate release date constraints problem finding minimum cost matching hypergraph phrased following integer program use decision variable x e 2 f0 1g denote whether hyperedge e matching minimize e subject x it2e two considerations suggest formulation might useful formulation polynomial size input size addition following theorem suggests calculating approximate solutions integer program may difficult theorem 34 consider integer program form derived instance network scheduling problem identical machines c e allowed arbitrary exists polynomialtime algorithm approximate within factor unless proof arbitrary instance network scheduling problem construct hypergraph matching problem edge weight w n corresponds job completed later time 3 give edges weight 1 schedule length 3 minimum weight hypergraph matching weight n otherwise weight least w therefore ffapproximation algorithm ff w would give polynomialtime algorithm decide schedule length 3 network scheduling problem theorem 24 would imply order overcome obstacle need seek different kind approximation hypergraph matching problem typically approximate solution feasible solution ie one satisfies constraints whose objective value best possible look different type solution one satisfies relaxed set constraints show turn solution satisfies relaxed set constraints schedule network scheduling problem introducing bounded amount error quality approximation assume p max n 3 implies size program polynomial input size later show dispense assumption size p max via number rounding scaling techniques begin turning objective function constraint use standard technique applying bisection search value objective function hence remainder section assume c optimal value integer program given construct approximate solutions following integer linear program j it2e e integer program packing integer program shown raghavan 22 raghavan thompson 23 plotkin shmoys tardos 21 possible find provably good approximate solutions polynomial time briefly review approach 21 yields best running times plotkin shmoys tardos 21 consider following general problem packing problem 9x 2 p ax b theta n nonnegative matrix b 0 p convex set positive orthant r n demonstrate fast algorithms yield approximately optimal integral solutions linear program algorithms require fast subroutine solve following problem separation problem given mdimensional vector 0 find x 2 p subroutine solve problem called separating subroutine approximate solution packing problem found considering relaxed problem approximating minimum true value characterizes slack inequality constraints goal minimize slack integer program easily put form packing problem equality constraints 7 define polytope p inequality constraints 89 make ax b quality integral solutions obtained depends width p relative ax b defined also depends smallest integer solution returned separating routine guaranteed integral multiple 1 applying equation 10 compute ae polytope p defined 7 yields value least n create matchings feasible schedules whose cost average completion time much greater c optimal average completion time fact many packing integer programs considered 21 also first formulated large width order overcome obstacle 21 gave several techniques reduce width integer linear programs discuss use one technique namely decomposing polytope n lowerdimensional polytopes smaller width intuition nonzero variables equation form 7 associated one particular job thus able decompose polytope n polytopes one job able optimize individually polytope use inequality constraints 8 9 describe relationships different jobs procede detail say polytope p decomposed product n polytopes coordinates vector x partitioned polytope decomposed way solve separation problem polytope p l apply theorem 21 give approximately optimal solution polynomial time particular let optimum value j following theorem specialization theorem 211 21 problem describes quality integral solutions obtained integer programs theorem 35 21 let ae l width p l let fl number constraints ax b let log fl given polynomialtime separating subroutine p l exists polynomialtime algorithm j gives integral solution show reformulate j able apply theorem polytope indeed decomposed n different polytopes equality constraints include j j order keep width p j small also include definition p j constraint x edge e includes j j c e c increase optimal value integer program integrate new constraints appropriate polytope p j decompose consists components x represent edges include j j words p l defined j l 2e e yields following relaxation l subject it2e e apply theorem 35 must 1 demonstrate polynomialtime separating subroutine ae fl decomposition p n separate polytopes makes task much easier separating subroutine must find x l 2 p l minimizes cx l however since vector 1 eth component 0 components p l e j l 2 e c e c separating routine reduces merely finding minimum component c e 0 c returning vector 1 position e 0 0 everywhere else immediate consequence 1 recall well assumption p max n 3 implies fl upper bounded polynomial n hard see ae 1 therefore aed log flaed logflnd employing binary search c knowledge optimal solution obtain invalid schedule many jobs scheduled one time p max polynomial n polynomialtime algorithm therefore proven following lemma lemma 36 let c solution integer program assume jm j bounded mn 4 exists polynomialtime algorithm produces solution x j2e x it2e x e x x relaxed solution valid schedule since olog n jobs scheduled one time however converted valid schedule use following lemma lemma 37 consider invalid schedule set jobs release dates unrelated parallel machines jobs assigned machine time w average weighted completion time exists schedule average weighted completion time w one job assigned machine time proof consider job j j scheduled let completion time c schedule jobs machine order completion times never starting one release date resulting schedule 1 j j started earlier release date 2 j j finishes time c statement 1 true design algorithm statement 2 true since c work jobs complete later c schedule jobs run simultaneously schedule run backtoback intermediate idle time expanded schedule therefore job j j started time c completed time c combining last two lemmas observation p max n 3 implies jm j mn 4 yields following theorem theorem 38 polynomialtime olog 2 napproximation algorithm minimization average weighted completion time set jobs machinevarying release dates unrelated machines assumption maximum job sizes bounded p 34 large jobs since p ij input binary general need polynomial n technique last section applied directly instances since would yield superpolynomial size formulations therefore must find way handle large jobs without impacting significantly quality solution standard technique combinatorial scheduling partition jobs set large jobs set small jobs schedule large jobs scaled polynomially bounded range schedule small jobs arbitrarily show net contribution significant see eg 24 minimization average weighted completion time however must careful since small jobs may large weights scheduled arbitrarily employ several steps increases average weighted completion time small constant factor care could reduce constants introduced step however since overall bound olog 2 n dispense precision sake clarity exposition basic idea characterize job minimum value taken machines release date processing time machine group jobs together based size minimum jobs group scaled polynomial size thus construct schedule scaled versions group scale schedules back correct rounding error show affect quality approximation constant factor apply lemma 39 see show makespan kept short simultaneously resulting schedules scheduled consecutively however since kept makespan growing much upper bound start time subsequent schedule thus show net disturbance initial schedules latter schedules minimal proceed greater detail let mj g note n nonempty j one n jobs employ following lemma order keep makespan growing large lemma 39 schedule j k converted polynomial time schedule makespan 2n k1 c proof remove jobs complete later time n k1 starting time n k1 schedule arbitrarily machine run quickly take n k1 time therefore rescheduled job j j satisfies c turn problem scheduling j l bounded guarantee average completion time lemma 310 exists olog 2 napproximation algorithm schedule j l addition schedule j l makespan 2n l1 proof let algorithm referred theorem 38 use find approximately optimal solution l j l applied directly j l since sizes jobs involved may exceed n 3 apply scaled version j l j j j 2 j l set p 0 c r 0 c note least one machine job j j p 0 use obtain approximate solution scaled version j l average weighted completion time w although p 0 may still large lemma 39 indicates restricting hypergraph formulation constructed allow completion times later time affect quality approximation factor 2 therefore jm j number machine time pairs omn 3 note p 0 ij may 0 still important include edge hypergraph formulation job size 0 argue interpreting solution scaled instance solution original instance j l degrade quality approximation constant factor conversion scaled instance original instance carried multiplying p ij impact quality approximation adding r ij p ij residual amount lost due floor operation additional residual amounts release dates contribute total n lgamma1 time makespan schedule since jr therefore entire contribution makespan bounded n theta n similar argument entire contribution residual amounts processing times makespan bounded n lgamma1 conversion p ij add 2n lgamma1 makespan schedule j l however n lgamma1 lower bound completion time job j l therefore even additional time added completion time every job restoration residual amounts r ij p ij degrades quality approximation average completion time constant factor finally satisfy makespan constraint apply lemma 39 construct two schedules e consecutively schedule e consecutively schedule sake clarity schedule time length 2n i1 dedicated even jobs lemma 311 let j set jobs scheduled j e set jobs scheduled e average weighted completion time within factor olog 2 n best possible similarly e j e proof subschedule set j scheduled e begins time since j scheduled j igamma2 j makespan j l 2n l1 since n igamma1 lower bound completion time job j combined schedule e job completes within small constant factor completion time combine e superimposing time slots creates infeasible schedule sum completion times sum completions times may two jobs scheduled simultaneously use lemma 37 combine e obtain schedule ff jobs whose average weighted completion time within factor olog 2 n optimal theorem 312 polynomialtime olog 2 napproximation algorithm minimization average weighted completion time set jobs machinevarying release dates unrelated machines 35 scheduling periodic connectivity hypergraph formulation scheduling problem model timevarying connectivity jobs machines eg job processed certain times machine section show apply techniques scheduling problems periodic connectivity modest assumptions length period job sizes definition 313 periodic scheduling problem defined n jobs unrelated machines period p time unit p specification jobs allowed run machines time theorem 314 let instance periodic scheduling problem p max polynomial n let optimum makespan l exists polynomialtime algorithm delivers schedule makespan olog nl proof assume l known advance use binary search complete algorithm construct integer program it2e lg include edge formulation valid respect connectivity conditions use theorem 38 produce relaxed solution satisfies j2e x it2e x x let length relaxed schedule l l l construct valid schedule length concatenating olog n blocks length l end block wait start next period begin next block hence obtain overall bound olog nl note assuming entire connectivity pattern p input explicitly input compressed form must assume p polynomial n one motivation problems domain satellite communication systems 18 26 one given set sites earth set satellitesin earth orbit site generates sequence communication requests request potentially different duration may require communication one satellites site transmit certain satellites certain times based satellite orbit connectivity pattern communication opportunities periodic due orbiting nature satellites goal satisfy communication requests quickly possible use hypergraph formulation technique give olog napproximation algorithm problem assumption p j bounded polynomial since rounding techniques generalize setting acknowledgments grateful phil klein several helpful discussions early research david shmoys several helpful discussions especially upper bound average completion time david peleg baruch awerbuch explaining offline approximation algorithm us perry fizzano reading earlier draft paper r lower bounds competitive ratio mobile user tracking distributed job scheduling competitive distributed job scheduling deterministic load balancing computer networks job scheduling rings bounds certain multiprocessor anomalies bounds multiprocessing anomalies bounds naive multiple machine scheduling release times deadlines approximation schemes constrained scheduling problems using dual approximation algorithms scheduling problems theoretical practical results polynomial approximation scheme machine scheduling uniform processors using dual approximation approach minimizing average flow time parallel machines reducibility among combinatorial problems worst case bound lrf schedule mean weighted flowtime problem rinnooy kan rinnooy kan mobile satellite communication systems toward global personal communications towards architectureindependent analysis parallel algo rithms private communication fast approximation algorithms fractional packing covering problems probabilistic construction deterministic algorithms approximating packing integer programs randomized rounding technique provably good algorithms algorithmic proofs improved approximation algorithms shop scheduling problems scheduling parallel machines costs mobile satellite services travelers tr ctr dekel tsur improved scheduling rings journal parallel distributed computing v67 n5 p531535 may 2007 cynthia phillips r n uma joel wein offline admission control general scheduling problems proceedings eleventh annual acmsiam symposium discrete algorithms p879888 january 0911 2000 san francisco california united states muthukrishnan rajmohan rajaraman adversarial model distributed dynamic load balancing proceedings tenth annual acm symposium parallel algorithms architectures p4754 june 28july 02 1998 puerto vallarta mexico martin skutella convex quadratic semidefinite programming relaxations scheduling journal acm jacm v48 n2 p206242 march 2001
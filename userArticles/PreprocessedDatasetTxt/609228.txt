per model secure information flow sequential programs paper proposes extensional semanticsbased formal specification secure informationflow properties sequential programs based representing degrees security partial equivalence relations pers specification clarifies unifies number specific correctness arguments literature connections forms program analysis approach inspired deterministic case equivalent use partial equivalence relations specifying bindingtime analysis thus able specify security properties higherorder functions partially confidential data also show per approach handle nondeterminism firstorder language using powerdomain semantics show probabilistic security properties formalised using probabilistic powerdomain semantics illustrate usefulness compositional nature security specifications presenting straightforward correctness proof simple typebased security analysis b introduction 11 motivation received program untrusted source let us call company promises help optimise personal financial invest ments information stored database home computer software limited time condition permit logfile containing summary usage program automatically emailed back developers program claim wish determine commonly used features tool program safe use program must allowed access personal investment information allowed send information via logfile back sure obtaining sensitive private financial information cunningly encoding contents innocentlooking logfile example problem determining program secure information flow information sensitive highsecurity data able propagate lowsecurity output log file traditional methods access control limited use since program legitimate access database paper proposes extensional semanticsbased formal specification secure informationflow properties sequential programs based representing degrees security partial equiv department computer science chalmers university technology university goteborg fandreidavegcschalmersse alence relations 1 specification clarifies unifies number specific correctness arguments literature connections forms program analysis approach inspired equivalent use partial equivalence relations specifying bindingtime analysis hs91 thus able specify security properties higher order functions partially confidential data eg ones financial database could deemed partially confidential number entries deemed confidential even though entries show approach extended handle nondeter minism illustrate various choices powerdomain semantics affects kinds security properties expressed ranging terminationinsensitive properties corresponding use hoare partial correctness pow erdomain probabilistic security properties obtained one uses probabilistic powerdomain 12 background study information flow context systems multiple levels confidentiality pioneered denning den76 dd77 extension bell lapadulas early work bl76 den nings approach apply static analysis suitable inclusion compiler basic idea security levels represented lattice example two point lattice publicdomain topsecret aim static analysis ensure information inputs variables processes given security level flows equivalence relation symmetric transitive necessarily reflexive puts variables processes assigned higher equal security level semantic foundations information flow analysis order verify program analysis specific proof programs security one must formal specification constitutes secure information flow value semanticsbased specification secure information flow contributes significantly reliability confidence activities used systematic design analyses many approaches denningstyle analyses including original articles contain fair degree formalism arguably lacking rigorous soundness proof volpano et al vsi96 claim give first satisfactory treatment soundness den nings analysis claim rests dissatisfaction soundness arguments based instrumented operational eg rb95 denotational semantics eg ms92 axiomatic approaches define security terms program logic ar80 without models relate logic semantics programming lan guage problem instrumented semantics security logic definition subject mathematical justifica tion mclean points mcl90 related discussion non languagespecific bell lapadula model one problem lapadula security properties constitute possible implementation security rather abstract specification secure systems must satisfy concerning particular controls files inside computer rather limiting relation input output make harder reason criticism points abstract extensional notions soundness based example idea noninterference introduced gm82 semanticsbased models information flow problem secure information flow non interference quite mature many specifications exist literature see mcl94 tutorial overview many approaches phrased terms abstract sometimes rather ad hoc models computation recently attempts made rephrase compare various security conditions terms wellknown semantic models eg use labelled transition systems bisimulation semantics fg45 paper consider problem informationflow properties sequential systems use framework denotational semantics formal model compu tation along way consider relations specific static analyses security lambda calculus hr98 alternative semantic condition secure information flow proposed leino joshi lj98 13 overview rest paper organised follows section 2 shows perbased condition soundness binding times analysis also model secure information flow show provides insight treatment higherorder functions structured data section 3 shows approach adapted setting nondeterministic imperative language appropriate use powerdomainbased semantics show choice powerdomain upper lower convex affects nature security condition section 4 focuses alternative semantic specification due leino joshi modulo technicalities show leinos condition family similar conditions agreement represented using form specification section 5 considers problem preventing unwanted probabilistic information flows programs show solved framework utilising probabilistic semantics based probabilistic powerdomain jp89 per model information flow section introduce way partial equivalence relations pers used model dependencies programs basic idea comes hunts use pers model construct abstract interpretations strictness properties higherorder functional programs hun90 hun91 particular use model dependencies bindingtime analysis hs91 related ideas already occur denotational formulation live variable analysis nie90 21 binding time analysis dependency analysis given description parameters program known partial evaluation time called static arguments bindingtime analysis must determine parts program dependent solely known parts therefore also known partial evaluation time safety condition binding time analysis must ensure dependency dynamic ie nonstatic arguments parts program deemed static viewed way binding time analysis purely analysis dependencies 2 dependencies security security field property absence unwanted dependencies often called noninterference gm82 many problems security come forms dependency analysis example case confidentiality aim show outputs program deemed low confidentiality dependence 2 unfortunately perspective partial evalua tor bta purely matter dependencies hs95 shown pure dependency models lau89 hs91 adequate ensure safety partial evaluation inputs higher degree confidentiality case integrity trust one must ensure value trusted data depend untrusted source intuitions information flow let us consider program modelled function input domain output domain consider following simple functions mapping inputs outputs snd theta e e sets domains e shift test functions n theta n n defined suppose h l pair h high security information l low public main information without knowing actual values h l might know result applying function snd low value case pair num bers result applying shift pair high second component low first component note function test enjoy security property snd since although produces value constructed purely lowsecurity components actual value dependent first component input known indirect information flow den76 rather natural think properties security types high theta low low high theta low high theta low test high theta low high notion type interpretation high low formalise intuitive type statements interpreting types sets values adequate model high low track degrees dependence inputs outputs need dynamic view type degree variation must vary parts input observe parts output vary application confidentiality want determine possible information leakage high level input parts output intended visible low security observer detect observing whether low parts output vary way vary high input simple properties functions snd shift described captured formally following formulae indeed kind formula forms core correctness arguments security analyses proposed volpano smith et al vsi96 sv98 also extensional correctness proofs core slamcalculus hr98 high low equivalence relations show interpret security types general partial equivalence relations interpret highfor values equivalence relation low relation x x 0 3 x function f binary relations iff binary relations p q define relation security property snd described 1 captured 2 given 22 equivalence relations pers seen equivalence relations may used describe security properties high low turns exactly interpretations given notions dynamic static given hs91 means bindingtime analysis higherorder functional language also read security informationflow analysis connection security binding time analysis already eg thi97 comparison particular security type system particular bindingtime analysis drh95 shows incorporation indirect information flows dennings security analysis improve binding time analyses worth highlighting pertinent ideas hs91 beginning equivalence relations id describe high low respectively two important extensions basic idea order handle structured data types higherorder functions ideas handled analysis hs91 rather straightforwardly extends launchburys projectionbased bindingtime analysis lau89 higher types extent hs91 anticipates treatment partiallysecure data types slam calculus hr98 use logical relations proof noninterference structured data useful refined notions security high low would like able model various degrees security example may list records containing namepassword pairs assuming passwords considered high might like express fact although whole list cannot considered low considered low theta highlist constructing equivalence relations represent properties straightforward see hs91 examples adapted directly launchburys work hun91 general treatment finite lattices bind ing times recursive types represent security properties higherorder functions use less restricted class relations equivalence relations partial equivalence relation per set binary relation symmetric transitive p per let jp j denote domain p given note domain range per p equal jp j x 2 x p x p x p restriction p jp j equivalence relation clearly equivalence relation per reflexive equivalence relations various applicative structures used construct models polymorphic lambda calculus see example ap90 far aware first use pers static program analysis presented hun90 given set let perd denote partial equivalence relations perd meet semilattice meets given setintersection top element given pers p 2 perd q 2 pere may construct new per e 2 perd e defined p per write x p mean x 2 jp j notation definition p q consistent notation used previously since note even p q total ie equivalence relations p q may partial simple example know given high input f returns low output constant function x42 prop erty clearly functions satisfy 23 observations strictness termination properties interested security properties functions denotations programs scottstyle denotational semantics termination issues address formulation security properties given sensitive termination consider example following clearly argument high result must high consider security properties function g ffi f g constant function might like consider g low however function application considered strict ml g hence function g ffi f security type high low semantic interpretation correct since termination application function low observer learned value high argument nonzero specific security analysis eg smith volpano sv98 termination sensitive enforced rather sweeping measure branching condition may involve high variable hand type system slam calculus hr98 termination sensitive gen eral due fact based callbyvalue semantics indeed composition could considered security type corresponding high low correctness proof noninterference carefully avoids saying anything nonterminating executions perhaps worth noting chosen nonstrict semantics application typesystem would yield termination sensitive security properties might say lazy programs intrinsically secure strict ones phenomenon closely related properties parametrically polymorphic functions rey83 3 type polymorphic function one predict certain properties behaviour socalled free theorems type wad89 however strict language one must add additional condition order theorems hold functions must bottomreflecting 3 forgetting use pers static analysis inspired part abadi plotkins per model polymorphic types ap90 side condition added make eg type system slamcalculus terminationsensitive make observation precise introduce one constructor pers r 2 perd also let r denote corresponding per without explicit injection elements elements write r denote relation perd naturally extends r r precise properties g strict callbyvalue interpreta expresses g constant function modulo strictness informatively say expresses g nonbottom constant function straightforward express per properties subtype system compositional rules although dont claim system would sense complete pleasantly expected subtyping rules sound types interpreted pers subtyping relation interpreted subset inclusion relations abstract interpretation presented hs91 already undertaken eg jensen jen92 hankin le metayer hl94 3 nondeterministic information flow section show per model security extended describe nondeterministic computations see nondeterminism important feature arises naturally considering semantics concurrent language al though treatment concurrent language remains outside scope present paper order focus essence problem consider simplified setting analysis commands simple imperative language containing nondeterministic choice operator assume discrete ie unordered domain st states might viewed finite maps variables discrete values simply tuple values 31 secure commands deterministic setting deterministic setting take denotation command c written jck function st mean set strict continuous maps domains e note could equally well take set functions st st isomorphic suppose state simple partition highsecurity half lowsecurity half set states product st high theta st low might define command c secure information high part state leak low part c secure equivalent saying jck theta since consider strict functions note imply jck terminates imply termination behaviour influenced values high part state easy see sequential composition secure commands secure command since firstly denotation sequential composition commands functioncomposition denotations sec ondly general functions r 2 perf easy verify soundness inference rule 32 powerdomain semantics nonde standard approach giving meaning nondeterministic language example dijkstras guarded command language interpret command mapping yields set sults however defining ordering results order obtain domain tension internal order state subset order powerset resolved considering suitable powerdomain structure plo76 smy78 idea define preoreder finitely generated subsets 4 terms order elements quotienting equiv alent sets one obtains partial ordering depending different view sets values considered equivalent consider following three programs example plo81 hoare partial correctness interpretation first two programs considered equal since ignoring nontermination yield sets outcomes view motivates definition hoare lower powerdomain p l st smyth total correctness interpreta tion programs 2 3 considered equal equally bad neither guarantee outcome general case view motivates smyth upper powerdomain p u st smy78 eglimilner interpretation leading convex plotkin powerdomain general case three programs considered distinct denotations three powerdomains built domain starting finitely generated fg subsets nonempty subsets either finite contain preorder sets quotienting fg sets using associated equivalence relation yields corresponding main give construction turn give idea corresponding discrete powerdo main pst ffl upper powerdomain upper ordering fg sets u v given case induced discrete powerdomain isomorphic set finite nonempty subsets st together st ordered superset inclusion induced discrete powerdomain p l st isomorphic 4 set infinite must contain powerset st ordered subset inclusion means domain st isomorphic subsets st theta st ie relational semantics u l v also known egli milner ordering resulting powerdomain isomorphic fg subsets basic properties definitions pow erdomains needed powerdo main constructor pgamma define orderpreserving takes element 2 powerdomain equivalence class singleton set fag function exits unique extension f denoted f f unique mapping particular setting denotations commands worth noting jc 1 k would given k 33 pers powerdomains give one discrete powerdomains pst need logical way lift per p per perpst definition 1 r 2 perd choice power domain pgamma let pr denote relation pd given easy check pr per particular pid henceforth shall restrict attention semantics simple commands hence three discrete powerdomains pst proposition 1 f 2 st r 2 perst easily follows following inference rule sound 34 security condition investigate implications security condition powerdomain terpretations let us suppose state partitioned high part low part high theta st low respect particular choice powerdomain let security type high theta low high theta low denote property case say c secure explore implications definition possible choices powerdomain 1 lower powerdomain security condition describes weak sense termination insensitive information flow example program h high part state considered secure interpretation termination behaviours influenced h fail terminate 2 upper powerdomain nontermination considered catastrophic interpretation seems completely unsuitable security unless one considers programs totally correct ie must terminate intended domain otherwise possible nonterminating computation path mask insecure behaviours term might exhibit means program c program c 8 loop secure 3 convex powerdomain gives appropriate generalisation deterministic case sense termination sensitive shortcomings upper powerdomain interpretation 4 relation equational characterisation section relate perbased security condition proposal leino joshi lj98 following approach assume simplicity programs two variables h l high low secrecy respectively assume state simple pair h refers first projection l second projection lj98 security condition program c defined stands semantic equality style semantic specification left unfixed hh program assigns h arbitrary values aka havoc h refer equation equational security condition intuitively equation says cannot learn anything initial values high variables variation low security variables postfix occurrences hh side mean interested final value l prefix hh lefthand side means two programs equal final value l depend initial value h relating equational security condition pers must first decide upon denotation hh run potential problems since necessary lj98 hh always terminates nevertheless exhibits unbounded nondeterminism although appears pose problems lj98 fact goes without mention handle would need work noncontinuous semantics powerdo mains unbounded nondeterminism instead sidestep issue assuming domain h st high finite secondly must find common ground semantic interpretation style semantic definition important viz operational vs denotational vs axiomatic rather interpretation nondeterminism leino joshi consider two styles interpretation different treatments nondeterminism relational interpretation corresponding choice lower powerdomain wlpwp seman tics corresponds convex powerdomain interpretation leino joshi claim considering relational semantics security condition equivalent notion used elsewhere lit erature shall see relational semantics interpretation security condition allows programs leak information via termination haviour observation entirely correct 41 equational security projection analysis first observation equational security condition strikingly similar wellknown form static analysis functional programs known projection analysis wh87 given function f projection analysis aims find projections continuous lower closure operators domain ff fi generalised strictness analysis dead variable analysis one given fi ff determined binding time analysis lau89 forwards analysis problem given ff one must determine fi strict functions eg denotations commands projection analysis readily ap plicable however convex powerdomain hh rather projectionlike since effectively hides information high variable fact embedding upper closure operator connection rather close 42 equational security condition subsumed per security conditio hunt hun90 showed projection properties form fi could expressed naturally per property equivalence relations derived ff fi relating elements get mapped point corresponding projection using idea show per based security condition subsumes equation specification similar manner establish following theorem 1 command c iff high theta low high theta low idea associate equivalence relation function hh generally command c let kerc kernel c denote relation pst define extension kerc ker c b jck recall per interpretation type signature c high theta low high theta low observe theta id since proof theorem based observation following two facts let us first prove latter fact proving general statement similar proposition 315 hun91 correspondence projections peranalysis note use specifics convex powerdomain semantics proof valid three choices powerdomain theorem 2 let us say command b idempotent iff jb jbk commands c idempotent command b proof jb c dks 1 thus 1 implies since jbks 1 idempotence implies corollary since jhh k idempotent conclude remains establish first fact theorem 3 pall theta proof suppose pall theta need show jhh k bottomreflecting direction assume jhh k jhh k b thus equational per security conditions simple case equivalent 5 probabilistic security conditio still weaknesses security condition interpreted convex powerdo main comes consideration nondeterministic programs usual terminology information flow considered possibilistic information flows probabilistic nature implementation may allow probabilistic information flows secure programs consider program program secure convex powerdomain interpretation since regardless value h value l value range 99g reasonably fair implementation nondeterministic choice randomised signment clear runs program fixed input value h could yield rather clear indiction value observing possible final values l might reasonably conclude value h 2 counter problem consider probabilistic powerdomains jp89 allows probabilistic nature choice reflected semantics programs hence enables us capture fact varying value h causes change probability distribution values l possibilistic setting denotation command c function st probabilistic case given input c keep track possible outputs also probabilities appear thus need consider domain e st distributions evaluations st denotation c going function st let us first present general construction probabilistic powerdomain inductively complete partial order ipo short lubs directed subsets countable probabilistic powerdomain evaluations e built follows evaluation function 0 1 e set evaluations partially ordered iff 8d 6 define pointmass evaluation j x ae 0 otherwise series theorems jp89 proves ipo directed lubs defined pointwise least element lift function f define extension f structure e j x kleisli triple thus canonical way composing probabilistic semantics two given programs lifted composition g ffi f computed one kleisli triple laws g ffif next step towards security condition define pers work probabilistic powerdo mains recall definition pers powerdo mains introduced section 3 r 2 reld lift pers e need consider definition takes consideration whole requivalence class one go define per relation e r e 2 r usual stands rgammaequivalence class contains naturally example consider eall theta id two distributions theta id 0 1 equal probability given low value l lefthand distribution given h h l equal probability right hand distribution namely make sure built stronger security model let us prove eglymilner power domain security condition follows probabilistic powerdomain one words theorem 4 suppose r equivalence relations command c r e implies jck c proof b 2 let deduce r b e need prove r b jck c p c jck c b assume r b let us show take x 2 jck c observe x 0 since x possible output program c run data probability getting output must greater 0 therefore e must exist 2 x 0 thus possible output program c run data b 2 jck c b 2 x implies let us derive probabilistic powerdomain security condition case two variables h l domain c secure iff l l e low h 02st high command c secure iff h2st high h2st high l h l intuitively equation means vary h distribution low variables sums provide forgetting highs change let us introduce probabilistic powerdomain semantics definitions language constructs omit esubscripts mean probabilistic semantics given two programs jc 1 composition two program semantics defined semantics uniformly distributed nondeterministic choice defined consult jp89 get full account define semantics language constructs example recall program let us check security condition take lefthand side whereas righthand side security condition hold program must rejected recently became aware probabilistic security typesystem due volpano smith vs98 soundness proof based probabilistic operational semantics although security condition use correctness argument directly comparable due fact consider parallel deterministic threads noncompositional semantics easily turn examples nondeterministic sequential programs probabilistic behaviours seems although checked details examples verified using security condition 6 conclusions many possible extensions ideas sketched also many limitations consider multilevel security problem handling lattices security levels rather simple highlow distinction one cannot expect assign intrinsic semantic meaning lattices security levels since represent social phenomenon external programming language semantics presence multiple security levels one must simply formulate conditions security considering information flows levels pairwise fashion although course specific static analysis able something much efficient downgrading trusting operations natural consider cannot modelled obvious way extensional framework one operation downgrading information high low without losing information example representing secure encryption high level information seems impossible since encryption operation lose information value yet type high low functions type high low constant func tions analogous problem arises rbaek palsbergs trust primitive try use pers model integrity analysis p97 operational semantics particularly married denotational perspective programming language semantics also interesting operational formulations pers higherorder language based partial bisimulations hope investigate constructing program analyses although model seems useful compare formali work needed show assist systematic design program analyses concurrency handling nondeterminism viewed main stepping stone formulating languagebased security condition concurrent languages remains topic work r per model polymorphism recursive types axiomatic approach information flow programs secure computer systems unified exposition multics interpretation lattice model secure information flow semantic foundations bindingtime analysis imperative programs classification security properties process algebra security policies security models slam calculus programming secrecy integrity binding time analysis new perspec tive semantic model binding times safe partial evaluation pers generalise projections strictness analysis abstract interpretation functional languages theory practice abstract interpretation logical form probabilistic powerdomain evaluations projection factorisations partial evaluation semantic approach secure information flow specification modeling computer security models security flow control algorithm denotational semantics correctness proof powerdomain con struction pisa notes types abstraction parametric polymorphism journal computer systems sciences secure information flow multithreaded imperative language university nottingham submitted publication probabilistic noninterference concurrent language sound type system secure flow anal ysis theorems free projections strictness analysis tr ctr kyung goo doh seung cheol shin detection information leak data flow analysis acm sigplan notices v37 n8 august 2002 pablo giambiagi mads dam secure implementation security protocols science computer programming v50 n13 p7399 march 2004 stephen tse steve zdancewic translating dependency parametricity acm sigplan notices v39 n9 september 2004 sebastian hunt david sands flowsensitive security types acm sigplan notices v41 n1 p7990 january 2006 nick benton peter buchlovsky semantics effect analysis exceptions proceedings 2007 acm sigplan international workshop types languages design implementation january 1616 2007 nice nice france aslan askarov andrei sabelfeld localized delimited release combining dimensions information release proceedings 2007 workshop programming languages analysis security june 1414 2007 san diego california usa anindya banerjee roberto giacobazzi isabella mastroeni lose leak information leakage declassification policies electronic notes theoretical computer science entcs 173 p4766 april 2007 gilles barthe leonor prensa nieto formally verifying information flow type systems concurrent thread systems proceedings 2004 acm workshop formal methods security engineering october 2929 2004 washington dc usa nick benton simple relational correctness proofs static analyses program transformations acm sigplan notices v39 n1 p1425 january 2004 roberto giacobazzi isabella mastroeni abstract noninterference parameterizing noninterference abstract interpretation acm sigplan notices v39 n1 p186197 january 2004 mads dam decidability proof systems languagebased noninterference relations acm sigplan notices v41 n1 p6778 january 2006 torben amtoft anindya banerjee logic information flow analysis application forward slicing simple imperative programs science computer programming v64 n1 p328 january 2007 steve zdancewic andrew c myers secure information flow via linear continuations higherorder symbolic computation v15 n23 p209234 september 2002 heiko mantel andrei sabelfeld unifying approach security distributed multithreaded programs journal computer security v11 n4 p615676 01012004 andrew c myers andrei sabelfeld steve zdancewic enforcing robust declassification qualified robustness journal computer security v14 n2 p157196 january 2006 anindya banerjee david naumann stackbased access control secure information flow journal functional programming v15 n2 p131177 march 2005
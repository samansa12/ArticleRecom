kleene algebra tests introduce kleene algebra tests equational system manipulating programs give purely equational proof using kleene algebra tests commutativity conditions following classical result every program simulated program simulated program one loop proof illustrates use kleene algebra tests commutativity conditions program equivalence proofs b introduction kleene algebras algebraic structures operators delta 0 1 satisfying certain axioms arise various guises many contexts relational algebra ng 1984 tarski 1941 semantics logics programs kozen 1981 pratt 1988 automata formal language theory kuich 1987 kuich salomaa 1986 design analysis algorithms aho et al 1975 iwano steiglitz 1990 kozen 1991 many authors contributed development kleene algebra anderaa 1965 archangelsky 1992 backhouse 1975 bloom esik 1993 boffa 1990 cohen 1994a conway 1971 gorshkov 1989 kleene 1956 kozen 1981 1990 authors address computer science department cornell university ithaca ny 148537501 email kozencscornelledu support national science foundation grant ccr9317320 gratefully acknowledged permission make digitalhard copy part material without fee granted provided copies made distributed profit commercial advantage acm copyrightserver notice title publication date appear notice given copying permission association computing machinery inc acm copy otherwise republish post servers redistribute lists requires prior specific permission andor fee c 1994 krob 1991 kuich salomaa 1986 pratt 1990 redko 1964 sakarovitch 1987 salomaa 1966 semantics logics programs kleene algebra forms essential component propositional dynamic logic pdl fischer ladner 1979 mixed boolean algebra modal logic give theoretically appealing practical system reasoning computation propositional level syntactically pdl twosorted logic consisting programs propositions defined mutual induction test formed proposition intuitively acts guard succeeds side effects states satisfying fails aborts states satisfying semantically programs modeled binary relations set states interpreted subset identity relation consisting pairs true state practical point view many simple program manipulations loop unwinding basic safety analysis require full power pdl carried purely equational subsystem using axioms kleene algebra however tests essential ingredient since needed model conventional programming constructs conditionals loops define section 2 variant kleene algebra called kleene algebra tests reasoning equationally constructs cohen studied kleene algebra presence extra boolean commutativity conditions given several practical examples use kleene algebra program verification lazy caching cohen 1994b concurrency control cohen 1994c also shown kleene algebra extra conditions form remains decidable cohen 1994a shown using result berstel 1979 see also gibbons rytter 1986 kozen 1996 continuous kleene algebra presence extra commutativity conditions form even atomic p q undecidable section 3 give complete equational proof classical folk theorem harel 1980 mirkowska 1972 states every program simulated another program one loop approach take mirkowska 1972 gives set local transformations allow every program transformed systematically one one loop transformation give purely equational proof correctness result illustrates use kleene algebra tests commutativity conditions program equivalence proofs section 41 observe universal horn theory continuous kleene algebras recursively enumerable therefore finitely axiomatizable follows construction berstel 1979 see also gibbons rytter 1986 lemma 71 kozen 1991 resolves open question kozen 1994 2 kleene algebra defined kozen 1994 kleene algebra algebraic structure satisfying 115 usual omit operator delta expressions writing pq p delta q order precedence operators kleene algebra tests delta 3 parsed unary operator defined q refers natural partial order k instead 14 15 might take equivalent axioms axioms 111 say structure idempotent semiring delta 0 1 remaining axioms 1217 say essentially behaves like kleene star operator formal language theory reflexive transitive closure operator relational algebra see kozen 1994 introduction kleene algebra said continuous satisfies infinitary condition r 18 supremum respect natural order think 18 conjunction infinitely many axioms pq infinitary horn formula presence axioms continuity condition 18 implies 14 17 strictly stronger sense exist kleene algebras continuous kozen 1990 true identities regular expressions interpreted regular sets strings derivable axioms kleene algebra kozen 1994 au thors experience two useful identities simplifying expressions call sliding denesting rules respectively example derive identity p q reason equationally follows p q 21 kleene algebra tests accommodate tests introduce following variant kleene algebra kleene algebra tests twosorted algebra unary operator defined b kleene algebra boolean algebra elements b called tests reserve letters arbitrary elements k b c e tests pdl test would written b since using different symbols tests omit sequential composition operator delta acts conjunction applied tests choice operator acts disjunction intuitively test bc succeeds iff b c succeed b c succeeds iff either b c succeeds follows immediately definition b 1 b 2 b tempting define tests arbitrary kleene algebra set fp 2 k 1g approach taken cohen 1994a approach restrictive feel less desirable two important reasons 1 although makes sense algebras binary relations ng 1984 tarski 1941 work kleene algebras example consider min kleene algebra theory algorithms see kozen 1991 consisting set fx 2 r j x 0g f1g operations min x 7 0 1 0 kleene algebra operations delta 0 1 respectively algebra p 1 p idempotence law fails set fp 2 k form boolean algebra approach every kleene algebra extends kleene algebra tests delta 5 trivially kleene algebra tests taking twoelement boolean algebra f0 1g course interesting models well 2 even algebras binary relations forces us consider elements tests including conditions practice would normally considered testable example may programs p whose inputoutput relations side effects ie p 1 associated test succeeds iff p halts general undecidable intend tests viewed simple predicates easily recognizable immediately decidable given state whose complements therefore also immediately decidable explicit boolean subalgebra allows 22 programs results section 3 work pascallike programming language sequential composition p q conditional test b p else q looping construct b p programs built inductively atomic programs tests using constructs called programs take sequential composition operator lower precedence conditional test loop parenthesizing b parsed begin b p end q b begin occasionally omit else clause conditional test considered abbreviation conditional test dummy else clause 1 true constructs modeled kleene algebra tests follows b p else b b see kozen tiuryn 1990 discussion relationtheoretic semantics programs tests semantic justification definitions 23 commutativity conditions also reasoning presence commutativity conditions form arbitrary element kleene algebra b test practical significance conditions become apparent section 3 intuitively execution program p affect value b stands reason p affect b neither affect b indeed case lemma 231 kleene algebra tests following equivalent proof symmetry suffices show equivalence 1 3 assuming 1 conversely assuming 3 therefore course pair tests commute ie axiom boolean algebra conclude section pair useful results fairly evident intuitive point view nevertheless require formal justification lemma 232 kleene algebra tests note case bq lefthand side 0 righthand side 1 proof prove three inequalities equivalence bqb expressions follows 19 first inequality suffices axiom 15 show b bq bq bq b boolean algebra commutativity assumption second inequality follows b 1 monotonicity kleene algebra operators last inequality suffices 14 show note last argument use fact b test theorem 233 kleene algebra p generated set elements commute q p commutes q proof let p expression language kleene algebra assume atomic subexpressions p commute q proof induction structure p basis inductive cases except subexpressions form r straightforward inductive case induction hypothesis need argue qr q kleene algebra tests delta 7 inequality one direction given argument last paragraph proof lemma 232 uses 14 direction symmetric argument using 15 3 folk theorem section give purely equational proof using kleene algebra tests commutativity conditions classical result every program simulated program one loop provided extra boolean variables allowed theorem subject treatise folk theorems harel 1980 notes commonly erroneously attributed bohm jacopini 1966 argues justification known kleene version stated originally due mirkowska 1972 gives set local transformations allow every program transformed systematically one one loop consider similar set local transformations give purely equational proof correctness result illustrates use kleene algebra tests commutativity conditions program equivalence proofs seems commonly held belief result purely schematic ie propositional uninterpreted proof harel 1980 proofs hirose oya 1972 mirkowska 1972 reported harel 1980 use extra variables remember certain values certain points program either program counter values values tests since remember values seems unavoid able one might infer recourse introduce extra variables along explicit assignment mechanism assigning values thus argument goes proofs theorem cannot purely propositional disagree conclusion purpose extra variables preserve values across computations treatment need preserve values certain tests b certain computations p handle purely equationally follows suppose need preserve value b across p introduce new test c commutativity condition intuitively says computation p affect value c insert appropriate place program new atomic program intuitively regard assigning value b new boolean variable tested c although explicit mechanism uninterpreted atomic program symbol however language programs b c else c insures b c boolean value execution 31 example illustrate technique consider simple program else begin value b preserved p could rewrite program simply formally assumption value b preserved p takes form commutativity condition 231 also language kleene algebra equivalence 21 22 becomes equation identity established simple equational reasoning bpr commutativity assumptions b preserved p situation seems call boolean variable remember value b across p explicit assignment mechanism set value variable however approach much less drastic introduce new atomic test c atomic program along commutativity condition intuitively modeling idea c tests variable modified p insert program give purely equational proof equivalence two programs else begin using axioms kleene algebra tests commutativity condition fact even away atomic program two programs equivalent without precomputation certainly equivalent removing leading expressing two programs language kleene algebra equivalence problem becomes using distributive laws 8 9 laws boolean algebra simplify lefthand side 23 follows righthand side 23 simplifies similar fashion expression commutativity assumption used second step kleene algebra tests delta 9 32 normal form theorem program normal form form q 24 p q free subprogram p called precomputation normal form approach folk theorem takes following form theorem 321 every program suitably augmented finitely many new subprograms form bc equivalent program normal form reasoning kleene algebra tests certain commutativity assumptions theorem 321 proved induction structure program programming construct accounts one case inductive proof case give transformation moves inner loop outside equational proof correctness inductive construction performed inside ie smaller subprograms first statement theorem 321 deliberately vague insert subprograms bcbc commutativity assumptions need assumed made explicit better done context construction 33 conditional first show deal conditional containing programs normal form else clauses consider program b begin else begin introduce new atomic program test c assume c commutes assumptions show programs b begin else begin c p 1 else c q 1 else q 2 equivalent note two programs else clauses 25 normal form 26 normal form argued section 31 away precomputation removing rewriting 25 language kleene algebra obtain reduces distributivity boolean algebra similarly 26 becomes subexpression cd 1 28 equivalent propositional reasoning used familiar propositional equivalence de morgan law subexpressions 28 simplified using distributivity boolean algebra obtain using distributivity broken sum four terms commutativity assumptions lemma 232 implies 31 32 vanish remaining two terms 30 33 sum two terms exactly 27 34 nested loops next consider case perhaps interesting denesting two nested loops construction particularly remarkable commutativity conditions thus extra variables needed compare corresponding transformations hirose oya 1972 mirkowska 1972 reported harel 1980 use extra variables show program b begin c q kleene algebra tests delta 11 equivalent program b begin c q else p end construction transforms pair nested loops single loop inside conditional test commutativity conditions assumed proof transformation loop taken outside conditional using transformation section 33 part require commutativity condition dummy normal form 0 1 supplied missing else clause note program inside block 34 normal form resulting program normal form surprisingly key property used proof denesting property 20 equates regular expression depth two another depth one translating language kleene algebra 34 becomes bpcq c b 36 35 becomes b 37 nonexistent else clause outermost conditional 35 starred subexpression 37 simplified using basic laws kleene boolean algebra b equivalent bc de morgan law making transformations 37 obtain unwinding outer loop 36 using 12 distributing b resulting sum obtain applying sliding rule 19 expression gives removing b bp bc expression 38 suffices show instance denesting rule 20 eliminating postcomputations wish show postcomputation occurring loop absorbed loop consider program form b assume without loss generality b test loop commutes postcomputation q introduce new test c commutes q along atomic program intuitively sets value c b loop loop body claim two programs begin c begin equivalent allows us replace 40 41 commutativity assumption holds purposes arguing 40 41 equivalent omit occurrences leading occurrences omitted argued section 31 occurrences inside loops assumed part p two trailing occurrences q omitted well making modifications writing programs language kleene algebra need show using sliding rule 19 sides becomes distributivity boolean algebra sides reduce easily bcp bc assumption b q commute show 39 equivalent program b q else b begin b q end note p q free 42 consists program normal form inside conditional transformed normal form using construction section 33 written language kleene algebra 39 becomes bp bq 43 42 becomes unwinding one iteration 43 using 12 distributing bq resulting sum obtain kleene algebra tests delta 13 eliminating term bq sides suffices prove starting righthand side sliding 19 36 composition composition two programs normal form b 1 b 2 q 2 transformed single program normal form actually already done work needed handle case first use result section 35 absorb whilefree program p 2 first loop also ignore since absorbed precomputation resulting normal form done therefore suffices show transform program b c q normal form p q free argued section 35 assume without loss generality test b commutes program q introducing new test necessary since b also commutes c boolean algebra theorem 233 b commutes entire second loop allows us use transformation section 35 absorbing second loop first resulting program looks like b c q else b begin b c q end substituted c q q 42 point apply transformation section 33 inner subprogram b c q using dummy normal form omitted else clause giving two nested loops else clause 47 transformation section 34 else clause 47 finally transformation section 33 entire resulting program yielding program normal form transformations sections 3336 give systematic method moving loops outside programming construct applying transformations inductively innermost loops outward transform program program normal form none arguments needed explicit assignment mechanism boolean variables dummy program something unspecified often omitted actual proof guard says b c somehow obtained boolean value course real implementation might assign value test b new boolean variable tested c play role equational proofs point significant exactly boolean values preserved across computations rather preserved purposes formal verification fact completely captured commutativity assumption thus justified claim given purely equational proof theorem 321 4 related results 41 decidability undecidability difficult reasoning kleene algebra commutativity assumptions qp words hard determine whether universal horn formula holds kleene algebras continuous kleene algebras e finite set equations form turns problem undecidable general continuous kleene algebras however conditions form test problem pspacecomplete kleene algebras tests continuous kleene algebras tests thus difficult reasoning without extra conditions undecidability result general commutativity assumptions continuous kleene algebras follows undecidability result berstel 1979 see also gibbons rytter 1986 regular sets partially commutative monoids result relating continuous kleene algebras regular sets kozen 1991 lemma 71 p 35 direct proof also given cohen private communication 1994 see kozen 1996 reduction valid absence continuity reasons explained section 42 decidability result conditions form pb bp follows fact conditions equivalent conditions form cohen 1994a shows kleene algebra conditions reduces efficiently kleene algebra without conditions kozen smith 1996 result extended kleene algebra tests thus reasoning presence commutativity conditions form used section 3 harder reasoning without extra conditions 42 finite axiomatizability berstels result establishes undecidability constructions berstel 1979 see also gibbons rytter 1986 cohen see kozen 1996 employ reductions core complete sets namely emptiness problem kleene algebra tests delta 15 turing machines complement posts correspondence problem respec tively implies universal horn theory continuous kleene algebras recursively enumerable therefore finitely axiomatizable fact theory pi 1 1997 universal horn theory kleene algebras finitely axiomatizable axiomatization given section 2 thus two theories coincide answers question kozen 1994 43 completeness complexity kozen smith 1996 show equational theory continuous kleene algebras tests complete relational models admits consisting sets guarded strings models analogous regular sets strings finite alphabet kleene algebra without tests using technique based kozen 1994 also shown kozen smith 1996 equational theories kleene algebras tests continuous kleene algebras tests coincide results analogous completeness result kozen 1994 kleene algebras without tests results imply equational theory kleene algebras tests reduces pdl therefore decidable exponential time shown different methods problem actually pspacecomplete cohen et al 1996 thus harder equational theory kleene algebras known pspacecomplete stockmeyer meyer 1973 acknowledgments thanks ernie cohen neal glew david gries david harel greg morrisett vaughan pratt fred b schneider frederick smith dave walker anonymous referees valuable comments indebted ernie cohen kind permission include previously unpublished result earlier version article kozen 1996 theorem 4 r design analysis computer algorithms algebra regular expressions new finite complete solvable quasiequational calculus algebra regular languages closure algorithms starheight problem regular languages transductions contextfree languages une remarque sur les systemes complets didentites rationnelles hypotheses kleene algebra lazy caching complexity kleene algebra tests regular algebra finite machines propositional dynamic logic regular programs decidability problems rational subsets free partially commutative monoids rational data structures applications folk theorems general theory flowcharts semiring convex polygons zerosum cycle prob lems representation events nerve nets finite automata induction vs kleene algebras closed semirings design analysis algorithms completeness theorem kleene algebras algebra regular events kleene algebra tests commutativity conditions complexity reasoning kleene algebra kleene algebra tests completeness decidabil ity logics programs complete system brational identities kleene parikh theorem complete semirings algorithmic logic applications relation algebras transitive closure action logic pure induction defining relations algebra regular events kleenes theorem revisited formal path kleene chomsky trends two complete axiom systems algebra regular events word problems requiring exponential time calculus relations revised november tr kleene parikh theorem complete semirings kleenes theorem revisited decidability problems rational subsets free partially commutative monoids kleene algebras closed semirings dynamic algebras wellbehaved fragment relation algebras semiring convex polygons zerosum cycle problems action logic pure induction logics programs design analysis algorithms complete systems inlineequation f scbscf inlineequationrational identities completeness theorem kleene algebras algebra regular events two complete axiom systems algebra regular events folk theorems flow diagrams turing machines languages two formation rules semirings automata languages kleene algebra withtests commutativity conditions kleene algebra tests induction vs continuity complexity reasoning kleene algebra word problems requiring exponential timepreliminary report complexity kleene algebra tests ctr hubie chen riccardo pucella coalgebraic approach kleene algebra tests theoretical computer science v327 n12 p2344 25 october 2004 dexter kozen results dynamic model theory science computer programming v51 n12 p322 may 2004 riccardo pucella logical verification equational verification acm sigact news v36 n2 june 2005 klausdieter schewe bernhard thalheim conceptual modelling web information systems data knowledge engineering v54 n2 p147188 august 2005 dexter kozen jerzy tiuryn substructural logic partial correctness acm transactions computational logic tocl v4 n3 p355378 july therrezinha fernandes jules desharnais describing data flow analysis techniques kleene algebra science computer programming v65 n2 p173194 march 2007 sorin lerner todd millstein erika rice craig chambers automated soundness proofs dataflow analyses transformations via local rules acm sigplan notices v40 n1 p364377 january 2005 dexter kozen hoare logic kleene algebra tests acm transactions computational logic tocl v1 n1 p6076 july 2000 bernhard mller georg struth algebras modal operators partial correctness theoretical computer science v351 n2 p221239 21 february 2006 klausdieter schewe bernhard thalheim aleksander binemannzdanowicz roland kaschek thomas kuss bernd tschiedel conceptual view webbased elearning systems education information technologies v10 n12 p83110 january 2005 j von wright towards refinement algebra science computer programming v51 n12 p2345 may 2004 bernhard mller kleene getting lazy science computer programming v65 n2 p195214 march 2007 maarten marx conditional xpath acm transactions database systems tods v30 n4 p929959 december 2005 jules desharnais bernhard mller georg struth kleene algebra domain acm transactions computational logic tocl v7 n4 p798833 october 2006 klausdieter schewe bernhard thalheim personalisation web information systems term rewriting approach data knowledge engineering v62 n1 p101117 july 2007 fairouz tchier demonic fixed points acta cybernetica v17 n3 p533555 january 2006
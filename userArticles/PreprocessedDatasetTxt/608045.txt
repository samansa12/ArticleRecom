verifying lossy channel systems nonprimitive recursive complexity lossy channel systems systems finite state automata communicate via unreliable unbounded fifo channels known reachability termination verification problems decidable systems article show problems cannot solved primitive recursive time b introduction channel systems also called finite state communicating machines systems nite state automata communicate via asynchronous unbounded fo channels boc78 bz83 figure 1 displays example labels cx cx mean message x letter sent respectively read channel c channel systems natural model asynchronous channel c 1 b b channel c 2 c figure 1 channel system two automata two channels communication protocols constitute semantical basis iso protocol specication languages sdl estelle channel systems turing powerful verication method general fully algorithmic years ago abdulla jonsson identied lossy channel systems interesting model lossy channel systems messages lost transit without notication systems close completely specied protocols independently introduced finkel showed decidability termination abdulla jonsson showed reachability safety properties traces eventuality properties states decidable lossy channel systems decidability results fin94 cfp96 aj96b fundamental since lossy systems natural model faulttolerant protocols communication channels supposed reliable see akp97 abj98 aab99 applications lossy channel systems aforementioned decidability results lead algorithms whose termination rely higmans lemma see cjt00 fs01 examples phe nomenon complexity bound known eg abdulla jonsson stated aj96b could evaluate cost algorithm article show abovementioned decidable problems nonprimitive recursive complexity ie cannot solved algorithms running time bounded primitive recursive function input size puts problems among hardest decidable problems proof relies simple construction showing lossy channel systems weakly compute fast growing numbertheoretic functions related ackermanns function inverses 1 weakly computing f mean starting x values 0 fx obtained notion used rabin proof equality reachability sets petri nets undecidable proof based weak computability multivariate polynomials see hac76 petri nets weakly compute n functions see mm81 cannot weakly compute inverses 1 n lossy channel systems exist families systems weakly compute n 1 lossy counter machines may00 reset nets dfs98 djs99 construction easily adapted show systems decidable problems like termination controlstate reachability nonprimitive recursive finally let us observe exist many uncontrived problems shown decidable primitive recursive eld verication aware one instance nite equivalence problem petri nets 1 introduced mayr meyer mm81 problem given two petri nets decide whether set reachable markings set nite equivalence undecidable without niteness assumption argued verication termination reachability lossy channel systems less contrived problem channel systems perfect lossy channel system usually combines several nitestate automata communicate several channels without loss generality assume systems one 1 see jan01 general proof nite equivalence problems petri nets nonprimitive recursive automaton uses several channels fo buers formally channel system tuple nite set control states nite set channels nite alphabet messages q c f g q nite set transition rules see conguration tuple denoting control currently state q channels c 1 c k contain words w transition rules state move conguration another mally perfect step hq w 0 31 rule q c written tail c 32 rule q c read head c steps called perfect message lost well known assuming perfect steps channel systems faithfully simulate turing machines quadratic time bz83 single channel enough replace turing machine work tape reading writing middle channel requires rotating content channel positioning reasons hence quadratic overhead thus interesting verication problems undecidable systems perfect channels even restricted singlechannel systems 21 lossy systems elegant convenient way model lossy channel systems see channel systems altered notion steps aj96b write u v v u subword v ie u obtained deleting number including letters v eg abba v abracadabra indicated underlining subword ordering extends congurations hq w lemma hig52 gives wellquasiordering lemma 21 every innite sequence congurations contains innite increasing subsequence write 0 say may evolve 0 losing messages steps lossy channel system congurations 0 ie losses may occur perfect step performed note perfect step special case lossy step run sequence chained lossy steps perfect run run uses perfect steps use 0 denote existence nite run resp perfect run goes interested following two problems given channel system initial conguration 0 runs reachability given channel system two congurations 0 f run 0 theorem 22 fin94 aj96b termination reachability decidable lossy channel systems remaining note show theorem 23 termination reachability lossy channel systems nonprimitive recursive complexity theorem 23 also applies verication problems known decidable lossy channel systems indeed termination instance inevitability shown decidable aj96b reachability easily reduced controlstate reachability shown decidable aj96b finally termination reduced simulation nitestate system 2 shown decidable ak95 cjt00 thus entitled claim verifying lossy channel systems nonprimitive recursive complexity note exist many undecidable problems lossy channel systems ak95 cfp96 aj96a may00 abpj00 sch01 3 main construction 31 ackermanns function let following sequence functions natural numbers z times 2 2 thus n followed 3 4 tower k 2s 4 n monotonic expansive following sense n 2 dene inverse functions observe 1 n partial functions another way understand functions notice z times exists many versions ackermanns function one possible denition ackn n 2 wellknown ackn dominates primitive recursive function n thus follows classical complexitytheoretic results halting problems turing machines running time space bounded ackn n size input cannot decided primitive recursive time spaces terminates simulationequivalent simple loop 32 weakly computing n expanders construct family expanders channel systems weakly compute 2 k 3 k illustrated fig 2 e n nth expander uses n channels c 1 output channel c n channel c n 1 channel c 1 figure 2 interface expander e n channel system write result n k c n input channel argument k read channels c 2 c n 1 used store auxiliary results e n one starting one ending state called n f n respectively systems use simple encoding numbers k 2 n encoded string dke alphabet 0 eg formally dke k e made k letters 1 surrounded one begin one end marker example channels fig 2 contain respectively d0e d0e d4e explaining construction expanders describe simple transferring devices illustrates way encodings dke numbers used n dened fig 3 start state n end state x n transfered contents channel c 1 channel c n assuming c 1 contains least d1e fig 3 future constructions sometimes omit depicting intermediate states names required proof figure 3 n channel system transferring c 1 c n n 1 formally lossy behaviors n characterized proposition 31 n 2 1 proof omitted note design n ensures blocks c 1 contains d0e property used proof lemma 34 move expanders internals e n given fig 4 figure 4 expanders subsystems e n implements equation 2 every time 1 consumed c n run result transfered applied easy convince oneself perfect nonlossy behavior e n compute n following formal sense indeed n 2 perfect run following form congurations displayed vector d0e d0e dke d1e d0e dke d1e d0e eb d1e d0e eb d0e d1e eb d0e d1e eb d0e eb d0e eb d0e eb d0e eb d0e d0e perfect behavior assumed e n still computes n time weak sense according following statement proposition 32 n 2 1 n k proof direction easy consequence 9 detailed proof direction found appendix underlying idea simple first 1s lost time computation nal result end smaller monotonicity properties 5 b e marker lost system never recover fail reach conguration channels contain encodings numbers note dierence 9 10 come replacement n k n k 9 guarantees w encodings numbers assumes 33 weakly computing 1 n folders folder systems f channel systems weakly compute 1 channel c 1 input channel c n output channels c 2 c n 1 store auxiliary results denition f n given fig 5 based 7 uses transferring systems 0 systems variants n move contents channel c n channel c 1 instead way around possibly lossy behaviors considered f n weakly computes 1 n following formal sense proposition 33 n 2 figure 5 folders f proof prove direction appendix omit easier direction one additional property construction useful following lemma 34 e n f n innite run regardless initial conguration proof rst deal e n induction n e 2 terminates since loop consumes c 2 n 2 run e n cannot visit q n innitely often would consume innitely c n ind hyp cannot contain innite subrun obviously n 1 part must terminate f n rst observe using induction n c 1 contains least one 1 run 0 n f 0 removes strictly 1s writes back finally traversing must move 1s c 1 lose 4 hardness results expander folder systems used prove theorem 23 41 hardness reachability lets consider turing machine tm started blank work tape size never goes beyond allocated workspace one build channel system simulates using workspace channel c 1 initially lled b1 e describe construction since follows standard simulation tms channel systems bz83 3 since never goes beyond allocated workspace 3 since tms really required could replaced perfect channel systems preserve size channel contents transition rules always write exactly many messages read loss occurs channel always contains number letters resulting system two types runs perfect runs simulated faithfully lossy runs really simulate messages irremediably lost order know whether accepts space remains provide enough workspace look runs message lost exactly done n depicted fig 6 expander e n provides potentially large dme channel c 1 folder f n used check message lost simulation using c 1 bounded workspace start accept figure simulating turing machine huge workspace thus run n form hs perfect must visit hstart dackne hence proposition 41 hs accepts space ackn therefore since n size jm j reachability lossy channel systems least hard termination tms running ackermann space hence corollary 42 reachability lossy channel systems nonprimitive recursive complexity 42 hardness termination second hardness result uses slight adaptation previous construction relies following simulation fig 7 0n lls two channels dackne c 1 used working space c 0 used countdown ensures termination simulation every time one step simulated 0n consumes one 1 c 0 accepting state reached moves 0 n uses f n check c 1 contain dackne ie simulation faithful check succeeds 0n enter loop therefore run 0n terminates simulation perfect accept ackn steps proposition 43 0n innite run hs n accepts time ackn proof clearly 0n reach nal loop simulation faithful halts ackn steps remains show unfaithful lossy behaviors deals e n f n part 0n duplication gadget tween f n start obviously terminates solve problem simulation part programming way rotation tape necessary simulating duplicating c 1 c 0 start loop simulation using c 1 bounded workspace c 0 bounded time accept figure 7 0n another simulation huge workspace tm cannot induce nontermination one way 4 achieve use two copies one positive one negative tm alphabet mode simulation reads letters writes back twin actual tm step performed 0n mode mode vice versa details found section 5 trick used shows termination lossy channel systems least hard termination tms runnings ackermann time hence corollary 44 termination lossy channel systems nonprimitive recursive complexity 5 systems one channel construction used several channels clarity necessity result still holds restrict lossy channel systems one channel one application slogan lossy systems k channels encoded lossy systems one channel encoding given aj96a section 45 preserves existence runs visit given control state innitely often give another encoding preserves termination reachability uses standard techniques eg study tms k tapes original aspect lossy behavior systems consider system uses channels c simulate system uses one single channel c without loss generality assume dierent subalphabet used every channel ie partitioned disjoint alphabets encoding uses larger alphabet k markers added every letter comes two copies positive negative one formally pair x shortly x occurrence x c means one x c polarity used bookkeeping purposes 4 alternative solution would use c0 countdown channel system steps rather tm steps prop 43 would reworded clumsy way ktuple hw k encoded polarity used label letters example hab ddci coded positive polarity fig 8 shows two example rules lefthand side encoded 0 righthand side gure four loops marked provide rotation contents c cx cx cx cx figure 8 encoding k channels one change polarity shorthands several loops indicated x comment state q gives rise two copies q q positive letters writes negative letters thus preventing nontermination induced rotation loops q converse 0 changes polarity time step simulated w v encodings hw g extends lossy behaviors terminates hq w note equivalences hold w v correct encodings ktuples q q 0 original states q 0 behaviors correspond behaviors sense 12 eg gets blocked new states loses one markers corollary 51 reachability termination lossy singlechannel systems nonprimitive recursive complexity 6 conclusion exist several constructions literature problem p shown undecidable lossy channel systems simulating turing machine way faithfulness simulation ensured checked rewarded way construction uses similar tricks since rst builds nonprimitive recursive number messages later checks none lost still number new aspects construction explains rst complexity result decidable problems lossy channel systems acknowledgements grateful alain finkel brought topic attention petr jancar suggested major improvements earlier draft anonymous referee helped us improve section 5 appendix proof prop 32 diculty direction prop 32 consider lossy behaviors need respect logic e n systems designed however restrict attention behaviors lose b e markers managing problem becomes feasible start following lemma lemma a1 run hs every w contains one b one e every w form b1 e ie encodes number holds run ht proof since systems always write b e consumed one saying every contains one b one e means losses concern markers therefore remains prove pattern b1 e respected even 1s lost consume da 1 e da 2 e writes c 1 c 2 encodes number even losses reasoning applies channels c 1 c n n channels untouched losses respect b1 e pattern proceed induction n c n observe n consumed replaced d0e channels c 1 c n 1 contain number run rst reaches q n since lemma holds remains case every time run revisits q n eventually reaches f n channels contain encodings numbers ready prove 1 n k induction n base case left reader simple inspection e 2 shows weakly computes 2 n 2 consider run isolate congurations 14 visits q n f n 1 writing form since b e markers lost 14 state w n formk eb resp 1 eb since transition leaving q n n 1 consumes one 1 c n one sees implying k finally reached consuming e c n concludes proof part concerns c n consider channels c 1 c n 1 proof lemma a1 shows encodings numbers furthermore satisfy z times 1e w j 2 prove induction j base case w 0 consequence assumption 14 one shows w j entails v j1 using prop 31 finally one proves using one concludes proof h n observing k wm entail right hand side h n monotonicity expansion properties n stated 5 appendix proof prop 33 direction proceed proof prop 32 start result mimicking lemma a1 lemma b1 run hs 0 every w contains one b one e every w encodes number proof omitted prove induction n base easy see n 2 consider run isolate congurations visits writing form start contents c n w n form eb1 k resp eb1 k 0 transition q 0 n 0 one 1 c n l n deduce l n consider contents channels w j v j encode numbers using h 0 shows induction w j writing monotonicity n 1 z l times nally leaving q 0 consumes d1e c n 1 entail n n completing proof r symbolic veri reasoning probabilistic lossy channel systems undecidable veri verifying programs unreliable channels decidability simulation bisimulation lossy channel systems improved search strategy lossy channel systems finite state description communication protocols reset nets decidability undecidability decidability termination problem completely speci well structured transition systems everywhere equality problem vector addition systems undecidable ordering divisibility abstract algebras undecidable problems unreliable computations complexity bisimulation undecidable equivalences lossy channel systems tr unreliable channels easier verify perfect channels undecidable verification problems programs unreliable channels complexity finite containment problem petri nets communicating finitestate machines algorithmic analysis programs well quasiordered domains nonprimitive recursive complexity undecidability petri net equivalence wellstructured transition systems everywhere bisimulation undecidable equivalences lossy channel systems improved search strategy lossy channel systems boundedness reset pt nets reset nets decidability undecidability undecidable problems unreliable computations symbolic verification lossy channel systems reasoning probabilistic lossy channel systems decidability simulation bisimulation lossy channel systems finite state systems extended abstract onthefly analysis systems unbounded lossy fifo channels ctr giorgio delzanno constraintbased automatic verification abstract models multithreaded programs theory practice logic programming v7 n12 p6791 january 2007 alexander rabinovich quantitative analysis probabilistic lossy channel systems information computation v204 n5 p713740 may 2006 p abdulla n bertrand rabinovich ph schnoebelen verification probabilistic systems faulty communication information computation v202 n2 p141165 1 november 2005 blaise genest dietrich kuske anca muscholl kleene theorem model checking algorithms existentially bounded communicating automata information computation v204 n6 p920956 june 2006 roberto amadio charles meyssonnier decidability control reachability problem asynchronous calculus nordic journal computing v9 n2 p70101 summer 2002 grard cc alain finkel verification programs halfduplex communication information computation v202 n2 p166190 1 november 2005 antonn kuera philippe schnoebelen general approach comparing infinitestate systems finitestate specifications theoretical computer science v358 n2 p315333 7 august 2006 antonn kuera petr janar equivalencechecking infinitestate systems techniques results theory practice logic programming v6 n3 p227264 may 2006
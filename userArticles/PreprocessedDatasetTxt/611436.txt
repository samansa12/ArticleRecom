approaches zerotree image video coding mimd architectures wavelet transform widely used image video compression one best known algorithms image compression set partitioning hierarchical trees algorithm involves wavelet transform today parallelisation wavelet transform sufficiently investigated work deals parallelisation compression algorithm next step two competitive approaches presented one direct parallelisation uses altered algorithm suits better parallel architecture b introduction image video coding methods use wavelet transforms successful providing high rates compression maintaining good image quality generated much interest scientic community competitors dct based compression schemes context mpeg4 jpeg2000 standardisation processes video compression algorithms rely 2d based schemes employing motion compensation techniques hand ratedistortion ecient 3d algorithms exist able capture temporal redundancies natural way 10 5 4 16 1 unfortunately 3d algorithms often show prohibitive computational memory demands especially realtime applications therefore mimd architectures seem interesting choice algorithm signicant amount work already done parallel wavelet transform algorithms sorts high performance computers nd various kinds suggestions 1d 2d 3d algorithms mimd computers decomposition 8 19 15 13 3 6 well connection image compression schemes 9 2 zerotree based coding algorithms eciently encode approximations wavelet coecients encoding collections neglectable insignicant coecients single symbols collections called zerotrees treelike arrangement wavelet coecients exploits wavelet transforms selfsimilarity property parallelisation ezw algorithm important zerotree coding scheme presented 2 two approaches proposed one straightforward parallelisation performs ezw algorithm locally processing element pe distinct blocks makes resulting bitstream bs incompatible sequential algorithm approach reserves one pe collection symbols encoded pe performs reordering symbols encodes approach similar approaches presented work far author understands compatible sequential ezw improvement ezw spiht algorithm set partitioning hierarchical trees 14 well known fast ecient algorithm also used 3dvariant video compression 5 however algorithm makes use lists coecients makes hard parallelise means although consecutive list entries initially point neighbouring wavelet transform coecients algorithm jumbles entries thus easy data driven parallelisation approach packetise spiht algorithm presented 17 similar rst approach 2 output several executions spiht spacial blocks multiplexed based rate allocation technique approximates distortion reduction fast spihtspecic statistics however resulting bitstream bs compatible sequential spiht work concentrates parallelisation spiht algorithm presents two competitive approaches rst direct parallelisation ie sequential algorithm mapped parallel architecture without alteration sequential algorithm several tricks found overcome involved parallelisation diculties second approach introduces variant spiht involves spacially oriented coecient scan order thus avoids problems rst approach similar algorithms proposed 18 11 12 although breadthrst scan order trees coecients 18 psnroptimal depthrst scan order 11 12 preferred better spacial separability 11 parallel wavelet transform fast wavelet transform eciently implemented pair appropriately designed quadrature mirror filters qmf consisting lowpass highpass lter decompose original data set two frequencybands subbands downsampled 2 procedure recursively applied coarse scale lowpass ltered subband 2d case consecutive ltering rows columns produces four subbands eight 3d case one ltered lowpass lter dimension decomposed called pyramidal wavelet transform perform wavelet transform parallel data distributed among pes way work data splitted slices time domain ltering performed parallel local data border data exchanged decomposition step neighbouring pes due lter length transformed data found distributed shown figure 1 contrast parallelisation wavelet transform presented previous paper7 parallel wavelet transform used dispenses video data distribution well collection transformed data initial data distribution necessary input performed parallel ie pe reads part video data note speedups reported work include io operations io viewed part algorithm another advantage drop hostnode paradigm extra single pe responsible data distribution likewise collection transformed data necessary data passed coding part algorithm also performed parallel redistribution data required see section 22 32 2d case b 3d case figure 1 distribution coecients list entries parallel wavelet transform dierent colours indicate dierent pes 12 zerotrees zerotree based algorithms arrange coecients wavelet transform treelike manner figure 2 ie coecient certain number child coecients another subband mostly 4 2d 8 3d case use following notations op direct ospring coecient p ie coecients whose parent coecient p descp descendants coecient p includes op oop parentp parent coecient p p 2 oparentp furthermore zerotree subtree entirely consists insignicant coecients signicance coecient relative threshold plays important role spiht algorithm statistical properties transformed image video data selfsimilarity ensures existence many zerotrees sets insignicant coecients encoded eciently help zero trees see sometimes root coecient subtree even direct ospring insignicant zerotrees viewed collection coecients approximately equal spacial position fact implies coecients signicances statistically related exploited spiht algorithm also means zerotrees local objects corresponding data distribution produced parallel wavelet transform see figure 2 exploited parallelisation zerotree algorithms see section 22 32 parallelisation without algorithm alteration 21 spiht algorithm although spiht algorithm suciently explained original paper14 helpful context reformulate algorithm figure 2 parallel decomposition data distributed way zerotree resides single pe threshold lis lip approximation subband set lsp empty renement step threshold threshold 2 process lis process lip process lsp pseudo code lis lip lsp coefficients process process process bs sig sign refbits sig sign b data ow graph figure 3 spiht algorithm signicance information represented three lists lis list insignicant set pixels entry list two types type type lip list insignicant pixels lsp list signicant pixels lis basically contains zerotree roots entry type corresponds insignicant subtree without root entry type b corresponds insignicant subtree without root roots direct ospring lip contains insignicant coecients part zerotree lis lsp contains signicant coecients lis lip lsp bs initialisation reading separator processing separator end lis lip lsp bs lis lip lsp bs lis lip lsp bs figure 4 functionality separators four states three lists bitstream processing lis algorithm shown coarse level figure 3 initially threshold greater coecients thus lis lip lled approximation subbands coecients lsp empty entry list tested change signicance result test encoded bit bitstream bs instance type entry lis turns insignicant precise descendants zero bit written bitstream entry deleted lis inserted type b entry end lis direct ospring inserted end lip entries inserted end list also processed renement step entries left figure 3b shows data ow graph renement step decoding process performs algorithm however evaluate signi cance list entries simply reads information bitstream approximates value corresponding coecient good 22 spiht parallelisation parallelising spiht algorithm face problem uses lists coecient positions therefore inherently sequential reason hard perform general list operations distributed lists nevertheless set distinct list operations involved spiht algorithm limited enables us develop ecient way manage distributed lists coecients 221 separators basic operations algorithm moving iterator list deleting elements iterator position appending elements end list aim distribute list pelocal entry corresponds local coecient coecients distributed among pes shown figure 1 simple task initial distribution however coecients appended end lists one provide mechanism indicate parts list belong pe pes view sequence local coecients ends parts another pes list inserted work done separators see figure 4 idea insert separator end part list entirely belongs single pe initially approximation subband split equal slices slice assigned single pe pe local lists lis lip lled coecients pes local slice separator appended end list sequential algorithm performed locally one exception time iterator meets separator separator copied end destination list destination list list entries potentially inserted current list processing see figure 3b applying principle lists l pe split separators parts l ij assembled list identical list sequential algorithm would produce true bitstream enables parallel algorithm assemble bitstream correctly pe encoded part wavelet coecients important question processing list ie renement step completed essentially procedure stop processed last nonseparator entry list unfortunately guarantee pe produces number separators however necessary condition correctness parallel algorithm wise correct order listparts would lost therefore global maximum number separators calculated unfortunately synchronises pes lists lled separators algorithm continues next renement step fact even processing list matter fact number separators grows exponentially number renement steps often separators appear row together list avoid unnecessary memory demands consecutive separators kept together single entry associated counter means separator entry containing counter inserted end list separator entry also containing counter already sitting counters simply added 222 algorithm termination another problem termination whole algorithm sequential case process terminates required number bits written bitstream parallel case test global test executed end renement step thus parallel algorithm potentially generates much bits course decreases speedup inconvenient cases necessary super uous bits simply cut assembling bitstream due nature spiht algorithm procedure assembling bitstream collecting pelocal bitstreams sequential part algorithm unfortunately gets complicated therefore consumes calculation time number pes increased result signicant decrease speedup 223 parallel spiht decompression note reverse algorithm reconstruction video data bitstream methods described applicable although part work shortly outline ideas implement parallel spiht decoder first whole bitstream copied pes also pe process bits bitstream independent whether belong local coecients therefore global lists kept pe speedup potentials adjusting nonlocal coecients involves oating point operations threshold descp offp figure 5 predicates used algorithm keeping consecutive nonlocal list entries entries belonging nonlocal coecients together single entry associated counter similar separators possible position information needed nonlocal entries although seems simple approach imply necessity process synchronisation contain sequential part 3 parallelisation algorithm alteration approach described reveals drawbacks eg complicated bitstream handling additional communication needs nonneglectable sequential code parts direct consequence fact spiht algorithm inherently sequential therefore modify sequential algorithm although resulting bitstream compatible spiht parallelisation altered algorithm course compatible sequential version basic idea substitute lists coecient positions involved algorithm bitmaps indicating membership coecient certain list result list iteration used frequently process list entries turned normal scan coecients follows certain spacial direction thus data driven parallelisation performed easily loop parallelisation coecient scan 31 zerotree compression signicance maps sm following use three logical predicates ap bp cp dened figure 5 ap simply denotes signicance coecient p bp true least one ps descendants signicant cp denotes include direct ospring p visualised figure 5 state signicance given set coecients described predicates terms zerotrees corresponding predicates use mappings b c essentially represent b c dierence b c immediately change values threshold changed therefore implemented functionprocedure used programming language b c updated explicitly therefore implemented array boolean values call b c signicance maps sm substitute lists coecients see section 21 algorithm responsible equality b c b c respectively processall threshold set b c false renement step threshold threshold 2 p approximationsubband c p renep else p ap q op figure based zerotree coding algorithm threshold successively decreased factor 1 2 done avoiding evaluation b c far possible following idea spiht algorithm result evaluation encoded bitstream one bit allow decoder reproduce decisions encoder made algorithm obeys rules shown figure 6 outer loop renement loop divides threshold 2 iteration exactly original algorithm within loop algorithm navigates set coecients along trees coecients depthrst manner major dierence sm based algorithm spiht starting set coecients contained approximation subband accomplished recursive procedure processcoe coecient p state b c checked one another p ap evaluated p false transition true 7 false possible p ap true sign p encoded well p already true procedure rene called endecodes another bit coecients value rene decoded approximation p bp evaluated b p false cp evaluated c p false b p true last recursion child coecients performed b p true obvious reason decoding algorithm looks exactly dierence instead encoding results evaluation b c information read bitstream together sign renementbits enough information enable decoder perform steps encoder approximate coecients error threshold note algorithm encodes information fact bits spiht algorithm order bits dierence means end renement step compression performance equal spiht order bits written bitstream crucial bits dierent eect decoded image thus important encode bits greater eect rst figure 7 shows comparison psnrperformance wellknown lenaimage 2d case algorithm shows major drawbacks respect original spiht nevertheless almost overcome scanning set coecients several passes rst pass process coecients part zerotrees signicant subsequent passes check state zerotree roots process coecients emerge decomposed zerotrees method denoted sophisticated figure 7 nevertheless improvement algorithm used work parallelisation investigations psnr bpp sm simple sophisticated figure 7 psnr sm based algorithm compared original spiht 32 parallelisation contrast original spiht algorithm parallelisation sm based algorithm easy based fact parallel wavelet transform data distributed way zerotrees local objects see figure 2 parallelise inner loop procedure processall reads p approximationsubband according data distribution approximation subband see figure 1 computations within renement step localised ie pelocal computations depend data neighbouring pes communication required within renement step pe produces one continuous part bitstream renement step end parts collected single pe assembled properly ie alternating way direct spiht parallelisation major bottleneck however number bitstream parts reduced signicantly speed bitstream assembly termination problem see section 22 pes synchronise end renement step determine global number bits produced far sucient however synchronisation dropped termination condition bitstream size xed number renement steps 4 experimental results experimental results conducted cray t3e900lc edinburgh parallel computing centre using mpi video data size always 864 frames 88 72 pixels video sequence used upart grandma wavelet transform performed level 3 note data size limited memory constraints case number pes 1 single pe hold video data number frames high enable uniform data distribution parallelisation well downscaling wavelet transform output bpp overall coding figure 8 sequential speedup sm based algorithm respect spiht thus frame size small realworld scenario however frame size bigger reason frame size scalability dicult measure nevertheless linear scalability assumed due authors experiences fact execution time coding part depend video data size number output bits first look sequential performance sm based algorithm slower original spiht parallelisation would make sense however figure 8 shows outperforms original spiht especially higher bitrates hand means even harder get reasonable speedups figure 9 shows speedups xed compression rate 014 bpp bits per pixel pixels dierent frames counted dierent pixels fact speedup curves smooth ie discontinuities 54 caused divisibility 864 length video sequence determines size local data subsets note due depth wavelet transform 3 size divided 8 resulting number divided number pes always possible without remainder sequential bitstream assembly takes execution time higher numbers pes share execution time gets higher 50 coding part note point particular hardware implementation bitstream assembly integrated output module separated actual coding speedups two dierent algorithms shows complicated bitstream assembly main problem direct spiht parallelisation could solved eciently dominant problems pe synchronisation sequential code parts present approaches however sm based algorithm expected gain lower parallelisation eciency two reasons owns communication overhead sequential algorithm faster less potential positive caching eects parallelisation optimal cache utilisation due spacially oriented coecient scan supposed main reason sm based algorithm faster overall spiht overall coding b sm based algorithm figure 9 speedups varying pe xed compression rate 014 bpp fact parallelisation eciency strongly suggests bitstream assembly parallel sm based algorithm ecient figure shows speedup curves xed pe varying compression rate course execution time wavelet decomposition depend compression rate reason speedup breakdowns certain compression rates termination problem parallel algorithm see section 222 parallel algorithm optimal compression rates achieved end renement step note although speedup coding part increases bitrate overall speedup remains constant drops slightly share execution time coding part increases bitrate problem unevenly distributed complexity illustrated figure 11 approximately rst half video sequence substituted carphone sequence contains much motion grandma sequence causes bigger coecient values higher frequency subbands complex video parts thus coecients processed within renement step makes algorithm consume computation time load balancing problem consequence one clearly see necessity process synchronisation several points algorithm leads increase idle times pes waiting pes figure 12 shows speedups compared figure 9 slightly reduced problem conclusions seen inherently sequential zerotree coding algorithm parallelised although speedups overwhelming presented way parallelisation prevents necessity perform coding sequentially thus reasonable speedups possible higher numbers processing elements whole range compression rates two methods parallelisation either use called separators output bpp decomposition overall spiht spiht 8 pes26100004 output bpp decomposition overall coding b sm based 8 pes5150004 output bpp decomposition overall spiht c spiht output bpp decomposition overall coding sm based output bpp decomposition overall spiht output bpp decomposition overall coding figure 10 speedup decomposition coding overall speedup varying compression rate evenly distributed complexity13579 b unevenly distributed complexity figure execution scheme decomposition spiht coding 10 pes time horizontal axis measured milliseconds nearly vertical black lines indicate data transfer horizontal grey bars indicate calculation phases515253510 20 overall spiht figure 12 speedups video unevenly distributed complexity xed compression rate 014 bpp rewriting algorithm better parallel architecture signicance map based algo rithm rst method complicated guarantees compatibility original spiht bitstreams second method shows similar speedup results better execution times although unevenly distributed imagemotion complexity decrease speedup potential eect seems keep within limits acknowledgments authors would like acknowledge support european commission tmr grant number erb fmge ct950051 tracs programme epcc author also supported austrian science fund fwf project p13903 r image coding using parallel implementations embedded zerotree wavelet algorithm scalability 2d discrete wavelet transform algo rithms embedded wavelet video coder using threedimensional set partitioning hierarchical trees spiht parallel algorithm twodimensional discrete wavelet transform hardware software aspects 3d wavelet decomposition shared memory mimd computers optimization 3d wavelet decomposition multiprocessors parallelization 2d fast wavelet transform space lling curve image scan video compression using 3d wavelet transforms listless zerotree coding color images 3d listless zerotree coding low bit rate video scalability 2d wavelet transform algorithms analytical experimental results coarsegrain parallel computers vector parallel implementations wavelet transform multirate 3d subband coding video image compression without lists parallel discrete wavelet transform paragon mimd machine tr scalability 2d discrete wavelet transform algorithms hardware software aspects 3d wavelet decomposition shared memory mimd computers embedded wavelet video coder using threedimensional set partitioning hierarchical trees spiht ctr roland norcen andreas uhl high performance jpeg 2000 mpeg4 vtc smps using openmp parallel computing v31 n1012 p10821098 october december 2005
finding regular simple paths graph databases consider following problem given labelled directed graph g regular expression r find pairs nodes connected simple path concatenation labels along path satisfies r problem motivated observation many recursive queries relational databases expressed form implementation query language bf g based observation show problem general intractable present algorithm runs polynomial time size graph regular expression graph free conflicts also present class languages whose expressions always evaluated time polynomial size graph expression characterize syntactically expressions languages b introduction much success relational model data attributed simplicity makes amenable mathematical analysis easy users comprehend latter respect availability nonprocedural query languages great asset however fact queries especially useful new application domains expressible traditional query languages led proposals powerful query languages logicbased language datalog 23 query language g original proposal relational model included two query languages equivalent expressive power relational calculus relational algebra 7 languages used yardstick bywhich query languages classified query language said relationally complete least expressive power relational calculus however notion completeness questioned since shown certain reasonable queries finding transitive closure binary relation cannot expressed calculus 3 4 particular limitation overcome languages datalog ability express recursive queries design g based observation many recursive queries arise practiceand literatureamount graph traversals example 1 12 19 g view database directed labelled graph pose queries graph patterns answer query set subgraphs database match given pattern useful applications language found systems representing transportation networks communication networks hypertext documents prototype implementation queries drawn workstation screen database query results also displayed pictorially example 1 let g graph describing hypertext document nodes chunks text edges links crossreferences readers read document following links context one might interested query way get section 31 section 52 conclusion without reading node corresponding g query shown figure 1 lefthand box figure contains pattern graph righthand box contains summary graph specifies preliminary version sections paper appeared proceedings 15th international conference large data bases amsterdam netherlands august 2225 1989 pages 185193 computer systems research institute university toronto toronto ont m5s 1a4 canada z department computer science university cape town rondebosch 7700 south africa ae ae ae conc link ae ae conc fig 1 query test existence simple path hypertext document ae ae ac ae ae fig 2 query find pairs cities connected air canada flight output presented user nodes case labelled constants matched database edges pattern graph labelled regular expressions case desired expression link representing nonzero sequence links regular expression used match edge labels along simple paths g thereby satisfying original request example 2 let g graph representing airline flights nodes g denote cities edge labelled city b city c means flight b c airline assume want find pairs cities connected sequence flights least one flight air canada ac b city visited query expressed graph pattern figure 2 pattern graph example comprises two nodes time labelled variables edge labelled regular expression ac underscore matches edge label g ac regarded single symbol fact simple paths matched query evaluation ensures desired answer computed although queries g lot general exemplified two examples special case suggested example 2 challenging enough algorithmic point view want process queries efficiently problem addressed paper given regular expression r graph g find pairs nodes g connected simple path p concatenation edge labels comprising p language denoted r trying find efficient solution problem incorporate implementation g somewhat surprised discover queries examples 1 2 fact npcomplete using results 11 17 show x2 certain fixed regular expressions r example 2 problem deciding whether pair nodes answer query npcomplete making general problem nphard first attacked problem determining language r makes problem hard x3 present class languages query evaluation solvable time polynomial length regular expression size graph characterize languages syntactically terms regular expressions denote finite automata recognize characterization assumes knowledge concerning structure graph queried x4 consider extensions given constraint cycles input graph known satisfy knowledge allows us characterize potentially larger classes queries solved polynomial time designed general algorithm presented x5 correct arbitrary graphs queries guaranteed run polynomial time size graph regular expression graph free conflicts sense defined precisely section special cases query free conflicts acyclic database graph restricted expression query free conflicts arbitrary graph since cannot restrict prototype work conflictfree queries graphs expensive test conflictfreedom beforehand quite convenient single algorithm works cases fact incorporated algorithm x5 implementation 2 intractability results section prove negative results regarding complexity finding certain types simple paths particular class directed graphs begin defining graph structures well class queries structures interested definition 1 database graph dbgraph short directed labelled graph n set nodes e set edges incidence function mapping e n theta n note multiple edges pair nodes permitted dbgraphs labels g drawn finite set symbols called alphabet edge labelling function mapping e definition 2 let finite alphabet disjoint fffl g regular expression r defined follows 1 empty string ffl empty set 2 regular expressions 2 b regular expressions regular expressions 3 nothing else regular expression expression ab called alternationof b ab called concatenation b called closure use underscore denote alternation elements also denotes aa positive closure language lr denoted r defined follows 1 ffflg 2 3 4 lbg 5 lbg 6 regular expressions r 1 r 2 equivalent written r 1 length regular expression r denoted jrj number symbols appearing string r definition 3 let g n e dbgraph path necessarily simple path g call string e 1 path label p denoted p 2 let r regular expression say path p satisfies r p 2 lr query qr dbgraph g defined set pairs x simple path x g satisfies r x 2 qr g x satisfies qr naive method evaluating query qr dbgraph g traverse every simple path satisfying r g exactly penalty algorithm takes exponential time g exponential number simple paths nevertheless see general cannot expect algorithm perform much better since prove particular regular expressions problem deciding whether pair nodes answer query npcomplete hand refinements lead guaranteed polynomial time evaluation conditions studied following two sections consider following decision problem regular simple path instance dbgraph regular expression r question g contain directed simple path x p satisfies r e equivalent asking x 2 qr g instance comprises dbgraph refer problem fixed regular pathr fixed regular pathr measure complexity terms size dbgraph first prove certain regular expressions r fixed regular pathr npcomplete refer following two decision problems instance directed graph e nodes x 2 n question directed simple path even length even number edges x instance directed graph e two pairs distinct nodes w x z 2 n theta n question pair disjoint directed simple paths g one w x z following theorem uses two decision problems prove npcompleteness fixed regular pathr two particular regular expressions theorem 1 let 0 1 distinct symbols fixed regular pathr r either 1 00 2 0 10 npcomplete proof 1 17 even path shown npcomplete reduce even path fixed regular pathr given instance g x even path construct dbgraph h isomorphic g except every edge h labelled 0 even simple path x g simple path x h satisfies r easy see fixed regular pathr np conclude fixed regular pathr 2 fact disjoint paths npcomplete follows immediately results 11 reduce disjoint paths fixed regular pathr given instance g w x z disjoint paths construct dbgraph h isomorphic g except every edge h labelled 0 add new edge x labelled 1 h simple path w z satisfying r h disjoint simple paths w x z g conclude fixed regular pathr also npcomplete corollary 1 regular simple path npcomplete proof nphardness follows theorem 1 show regular simple path np observe arbitrary regular expression r given simple path x g path label w check polynomial time lengths r w whether w lr 2 interesting note g undirected even path disjoint paths solved polynomial time even path solved polynomial time using matching techniques 17 polynomial time algorithm disjoint paths given 20 two npcompleteness results theorem 1 generalized first generalize regular expression 00 expressions form w w 2 jwj 2 use following npcomplete problem 17 used show npcompleteness even path path via node instance directed graph e nodes x question directed simple path x via theorem 2 fixed regular pathr r w w 2 proof membership np easy demonstrate reduce path via node fixed regular pathr using variation construction 17 given instance g path via node construct dbgraph 1 f 2 f f proof divides two parts depending whether w even odd length rather introducing additional nodes structure believe would obscure proof allow edges labelled strings symbols length path length concatenated edge labels assume 1 two copies edge types 1 labelled w 1 w 2 edges type 3 labelled w 2 edges type 4 labelled w 1 claim simple path x g simple path x 1 2 satisfying r h path p x g let p 1 subpath p x p 2 subpath p let u predecessor p 1 v successor p 2 h traverse simple path x 1 u 2 satisfies w 1 followed edges labelled w 2 w 1 u 2 v 1 respectively followed simple path v 1 2 satisfies w overall path thus satisfies w 1 w 2 guaranteed simple assume simple path p x 1 2 h satisfies r strings lr length mn even path x 1 2 pass must length kn k odd conclude p must pass h hence simple path x via g consider case one copy edge type 1 h labelled 0 2n one copy edge type 2 labelled w 1 w 2 type 3 edges labelled w 1 type 4 edges labelled w 2 easy see simple path x via g must simple path satisfying r h direction suffices note simple paths h x 1 2 pass length m2n pass length k2n also lengths strings lr two never equal n 0 conclude simple path x 1 2 h satisfying r must simple path x via g generalize npcompleteness result fixed regular pathr let also denote alternation elements theorem 3 let r regular expression form wt subsets w addition assume either 1 w appears neither 2 symbols b 2 c 2 neither appears w fixed regular pathr npcomplete proof fixed regular pathr obviously np use essentially reduction disjoint paths fixed regular pathr theorem 1 general case given instance g w x z disjoint paths construct dbgraph h isomorphic g except two copies edge h made one labelled b 2 one labelled c 2 case 2 b c symbols mentioned statement theorem case 1 choose b 6 c 6 assume add along path e labelled disjoint simple paths w x z g easy see must simple path w z satisfying r h assume simple path p w z satisfying r h p must form p 1 pw p 2 since cases 1 2 pw contains edge label appears nowhere else h appear path h satisfying r conclude must disjoint simple paths w x z h hence g theorems 2 3 rather negative results since imply queries might require time exponential size dbgraph regular expression evaluation thus regular expressions theorems 2 3 certainly would expect evaluation algorithm run polynomial time one example air canada query used example 2 long alphabet contains least two symbols results however function particular regular expression rather nature language denoted regular expression class languages regular simple path p subject next section 3 restricted regular expressions section characterize class queries regular simple paths evaluated polynomial time first introduce terminology definitions definition 4 nondeterministic finite automaton ndfam 5tuple finite set states input alphabet ffi state transition function maps theta ffflg set subsets 0 2 initial state f set final states extended transition function ffi defined follows 2 2 w 2 ndfa accepts w language lm accepted set strings accepted deterministic finite automaton dfa ndfa state transition function mapping theta definition 5 let ndfa transition graph associated directed labelled graph 2 edge e em confusing representations sometimes say transition state state successor 2 ffi path 2 ffi w ae ff phi 0ae ff phi 1ae ff phi 2fig 3 transition graph dfa definitions apply dfa definition 6 given ndfa pair states 2 define language denoted l st set strings take state state state set states define language denoted l st st particular state 2 suffix language denoted l sf short set strings take final state clearly definitions apply dfa given regular expression r fflfree lr constructed polynomialtime 2 assume ndfas fflfree example 3 figure 3 shows transition graph dfa state 0 initial state states final denoted double circle show reject states path initial state final state lm denoted regular expression 0 1 0 suffix language state 1 1 regular expressions subsequent analysis useful refer ndfa accepts language lr 1 r 2 construction ndfa defined follows definition 7 let ndfa call transition graph intersection graph 1 2 saw previous section certain regular expressions r unlikely find algorithm evaluating qr arbitrary graph g always run time polynomial size g one regular expression 0 10 however turns regular expression specified instead qr evaluable polynomial time dbgraph g reason arbitrary path node x node g satisfies r simple path x satisfying r case need restrict looking simple paths g instead look path satisfying r define corresponding decision problem regular path instance dbgraph regular expression r question g contain directed path necessarily simple p satisfies r e lemma 1 regular path decided polynomial time ae x ae ff phi z ae fig 4 graph containing nonsimple path proof given dbgraph g along nodes x g view g ndfa initial state x final state construct intersection graph g ndfa accepting lr path x satisfying r path x 0 f f 2 f done polynomial time 14 22 tarjan provides polynomialtime algorithm constructing regular expression represents set paths two nodes given graph alternative procedure one could decide polynomial time whether path x g satisfying r first using tarjans algorithm construct regular expression r xy representing paths x g determining whether intersection lr lr xy nonempty using ndfas results previous section show unlikely polynomialtime analogue tarjans algorithm exists describing set simple paths two nodes definition 8 let g dbgraph ndfa intersection graph g call node x 0 initial node node f final node interested conditions regular simple path appropriate semantics reduced regular path following lemma states one condition lemma 2 regular simple path decided polynomial time acyclic db graphs proof follows immediately lemma 1 fact every path acyclic graph simple suppose want characterize class regular expressions guarantee regular simple path solvable polynomial time assume know nothing structure dbgraphs ensure regular expression r whenever string w lr every string obtainable w removing one symbols must also lr otherwise xay lr xy lr 2 x 2 construct graph g comprising single simple path u v passing z loop z labelled path u z labelled x path z v labelled see figure 4 nonsimple path u v g satisfies r simple path u v satisfying r definition 9 abbreviation string w string obtained w removing one symbols w 6 looking class regular expressions denote languages closed abbreviation consider following definition class restricted regular expressions definition 10 2 denote regular expression done grep utility unix 1 example given regular expression r let r 0 regular expression obtained replacing occurrence symbol 2 r r restricted r j r 0 r 0 obtained r defined note definition restricted regular expressions semantic rather syntactic two significant consequences one hand able prove equivalence theorem theorem relating restricted regular expressions languages automata recognition problem restricted regular expressions becomes difficult corollary 3 example 4 regular expression 0 1 0 restricted equivalent 0 1 0 recall theorem 1 fixed regular pathr npcomplete restricted r restricted since r 0 written 0 1 equivalent 0 10 definition 11 dfa exhibits suffix language containment property containment property short pair 2 path 0 final state successor l sf l tf following result although used elsewhere provides interesting restrictions structure dfas exhibit containment property proposition 1 let exhibits containment property 1 every state path 0 state f final 2 minimum dfa exhibits containment property 3 minimum every cycle loop proof 1 every final state accepts ffl transitivity every state path 0 state f must also accept ffl hence must final minimum dfa equivalent state 0 represents set equivalent states assume 2 0 represents fs transition transition equivalent 3 consider cycle loop let two states cycle since u v every pair consecutive states cycle conclude transitivity j minimum contradiction example 5 consider regular expression dfa accepting whose transition graph given figure 3 verify exhibits containment property noting 2 denoted 0 obviously easy check 1 note also proposition 1 state final since minimal every cycle loop fact exhibits containment property r restricted coincidence demonstrate theorem 4 let r regular expression accepting lr following three statements equivalent 1 r restricted regular expression 2 lr closed abbreviations 3 exhibits containment property 1 unix trademark att proof proof use ndfa e constructed regular expression r lmr detailed 2 ffltransitions usually present onetoone correspondence nonffltransitions mr occurrences symbols r makes sense refer transition mr corresponding occurrence symbol r vice versa furthermore replacing occurrence r equivalent including ffltransition source state target state transition mr corresponding occurrence assume r restricted lr closed abbreviations symbol 2 strings x 2 xay 2 lr xy 62 lr consider mr let set states mr reading x since lmr r hand xay 2 lmr state p 2 0 q 2 p 2 q since r restricted adding ffltransition p q leaves lmr unchanged longer equal lr contradiction conclude lr closed abbreviations prove contrapositive assume 6 pair reachable states ffi 2 string 2 2 62 let x 2 string ffi follows xay 2 lm xy 62 lm since lm conclude lr closed abbreviations prove contrapositive assume r restricted atransition mr adding ffltransition alters string 2 string 2 62 r r 2 consider dfa assume must state q ffi p q 2 q however 62 p otherwise xy 2 lm would mean lm exhibit containment property theorem 5 regular simple path decided polynomial time restricted regular expressions proof let dbgraph g regular expression r r restricted constitute instance regular simple path lemma 1 sufficient show whenever path x g satisfies r simple path x satisfying r assume nonsimple path g since p nonsimple assume j lr path label p 0 abbreviation p theorem 4 lr closed abbreviations hence p 0 removing cycles p leave simple path x satisfies r thus class restricted regular expressions one query evaluation performed efficiently show even though classes restricted regular expressions regular languages closed abbreviations subclasses regular counterparts least closed regular operators theorem 6 let alphabet class regular languages closed abbreviations also closed alternation concatenation closure proof let l 1 l 2 regular languages closed abbreviations immediate closed abbreviations let w 2 abbreviation w clearly string abbreviation w since l 1 l 2 closed abbreviations algorithm compute suffix language containment relation dfa input output pair 2 whether 1 mark od 2 ordered pair distinct states 3 2 ffis ffi marked 4 mark 5 recursively mark unmarked pairs list lists pairs marked step else pair ffis ffi marked 6 2 7 put list ffis od od fig 5 computing suffix language containment relation dfa l allowing us conclude l closed abbreviations let l regular language closed abbreviations since ffl 2 l regular languages closed abbreviations also closed concatenation l must closed abbreviations corollary 2 class restricted regular expressions closed alternation concatenation closure example 6 one simplest restricted regular expressions 0 since class restricted regular expressions closed alternation concatenation closure 0 0 1 0 already seen restricted hand restricted expressions also sometimes built expressions restricted examples include already seen 00 given query qr would like test whether r restricted order know safe use polynomial time evaluation algorithm adapting algorithm minimize number states dfa 13 compute suffix language containment relation pairs states dfa suffix language containment relation used subsequent sections also provides obvious method testing whether regular expression r restricted using theorem 4 algorithm computing suffix language containment relation algorithm shown figure 5 lines 3 7 algorithm taken directly algorithm 13 algorithm marks pairs inequivalent states considers unordered pairs states lines 1 2 algorithm altered appropriately order consider ordered pairs states marked algorithm 6 n states algorithm runs 2 assuming constant alphabet 13 alternative almost lineartime algorithm given 2 since construction dfa accepting lr may take exponential time size r using algorithm test whether regular expression restricted efficient however important stress trying avoid possibility spending exponential time size dbgraph answering query also turns determining whether r restricted hard problem consider following result proposition 2 21 determining whether regular expression alphabet f0g denote 0 npcomplete use result show problem deciding whether regular expression alphabet restricted nphard first prove following theorem 7 let r starred regular expression alphabet f0g deciding whether r restricted npcomplete proof first show problem np r restricted lr closed abbreviations theorem 4 thus string 0 lr considering dfa accepting lr seen must jrj 0 n 62 lr nondeterministic polynomial time algorithm verify r restricted first guessing binary representation n testing whether path transition graph ndfa accepting lr length n final state latter step done deterministically time polynomial length r 21 reduce problem proposition 2 present problem showing r restricted r denote 0 already shown r restricted lr 6 0 conversely assume r denote 0 let x shortest string 0 lr since r starred lr infinite string xy 2 lr 6 ffl x abbreviation xy hence theorem 4 r restricted corollary 3 deciding whether regular expression alphabet restricted nphard 4 constrained cycles dbgraphs instances knowledge cyclic structure dbgraph g allows us determine without consulting g particular query qr evaluated polynomial time g already shown extreme case g acyclic qr always evaluable polynomial time let us assume know cyclic structure g constrained regular expression c every cycle label g lc definition 12 let c regular expression dbgraph let set cycle labels g namely cycle gg say g complies c ae lc regular expression c called cycle constraint cycle constraint c defines class dbgraphs whose cyclic structure satisfies c example way define classes bipartite graphs loopfree graphs acyclic graphs specifying regular expressions respectively 2 class dbgraphs unconstrained cycles defined expression denotes continuing need introduce terminology regarding properties intersection graph dbgraph transition graph definition 13 let intersection graph dbgraph graph say path 2 recall underscore shorthand dbsimple v words p dbsimple v simple path g addition call simplicial whenever path dbsimple path v first components nodes form subset first components nodes p definition lemma 1 clear intersection graph dbgraph transition graph corresponding regular expression r simplicial qr evaluated polynomial time size following theorem characterizes simplicial intersection graphs presence cycle constraints theorem 8 let c cycle constraint query qr let accepting lr transition graph every dbgraph g complying c intersection graph g simplicial whenever path reachable state satisfying c proof dbgraph complying c nonsimple path satisfying r g hence path q v notational simplicity let w w complies c w assume ffi path satisfying c path v hence assumption string w 3 p satisfies r w 3 2 well follows w 1 w 3 2 lr therefore satisfies r process repeated obtain dbsimple path q 0 v first components q 0 form subset first components q conclude simplicial assume path p satisfies c constraint c cannot otherwise p would satisfy c since reachable string w 1 ffi cannot otherwise let w 3 string w 2 path label p string w 2 cannot ffl since p must length greater zero construct dbgraph comprising single nonsimple path e 1 complies c since cycle g labelled w 2 lc path q lr hence path v however path satisfy r since w 1 w 3 62 lr otherwise w 3 would consequently dbsimple path v conclude simplicial result depend particular dfa accepting lr consider two accepting lr let 2 2 pair states string x ffi g complies cycle constraint compatible r r restricted g acyclic fig 6 relationship regular expression r dbgraph g query qr lm 1 must case words fact theorem 8 true independent particular dfa chosen consequence myhillnerode theorem states language accepted dfa union equivalence classes rightinvariant equivalence relation finite index 13 leads us following definition definition 14 let r regular expression transition graph dfa accepting lr say r compatible cycle constraint c whenever path reachable state satisfying c theorem 8 generalizes previous results case g acyclic c path satisfies c result holds vacuously words every regular expression compatible cyclic structure g unconstrained c denotes every path satisfies c must contain pairs reachable states corresponds case restricted regular expressions regular expression r compatible c c denotes r restricted relationship among properties shown figure 6 appealing result lemma 1 obtain following corollary theorem 8 corollary 4 let c cycle constraint g dbgraph complies c query qr g evaluated polynomial time size r g r compatible c simple algorithm testing whether regular expression compatible cycle constraint given figure 7 constructs dfas regular expressions r c algorithm take exponential time length r c however deciding whether r c compatible nphard since deciding whether r restricted special case testing compatibility theorem 9 given regular expression r cycle constraint c deciding whether r c compatible nphard example 7 let r 00 dfa mr accepting lr shown figure 8a 6 b know r restricted fact saw theorem 1 deciding x 2 qr g npcomplete dbgraphs general however qr evaluated polynomial time bipartite graphs already seen regular defines class bipartite graphs dfa mc accepting lc shown figure 8b intersection graph mr mc given figure 9 paths satisfying c start node containing initial state mc end node containing final state mc b b since b b corollary 4 tells us qr evaluated polynomial time bipartite graph given query qr dbgraph g know g complies cycle constraint c test whether r compatible c using algorithm use polynomial time algorithm evaluate qr g hand know cyclic structure g seems might resort exponential algorithm testing whether regular expression compatible cycle constraint input regular expression r cycle constraint c output whether r compatible c 1 construct dfas accepting lr accepting lc 2 compute suffix containment relation mr algorithm x3 3 construct intersection graph mr theta mc 4 compute transitive closure 5 edge otherwise answer fig 7 testing whether regular expression compatible cycle constraint ae ae ae ae ae ae b fig 8 dfas mr bb ae ae ad ae ae ae bd fig 9 intersection graph mr mc figure 8 ae ff phi aae ff phi bae ff phi ff phi omega psi ae ff phi omega psi ae ae omega omega omega omega omega omega ae ae omega omega omega omega omega omega oe j j b fig 10 dfa dbgraph g time algorithm r restricted next section however describe evaluation algorithm runs polynomial time size g g happens comply cyclic constraint r compatible 5 evaluation algorithm section describe algorithm evaluating query qr dbgraph g expected results x2 algorithm run polynomial time general however run polynomial time sufficient conditions identified x3 x4 namely g acyclic r restricted g complies cycle constraint compatible r fact show algorithm runs polynomial time g r conflictfree condition implied evaluation algorithm traverses paths g using dfa accepting lr control search marking nodes visited must record state node visited since must allow node visited different states correspond distinct nodes intersection graph g order avoid visiting node twice state would like retain state markings nodes long possible unfortunately following example shows general requiring answer nodes connected simple paths g retaining state markings lead incompleteness query evaluation example 8 consider query qr accepting lr dbgraph g shown figure 10 note similarity automaton figure 3 x3 assume start traversal node g follow path b c nodes b c marked states b b respectively answers c found since b final state cannot mark c state c b c dc nonsimple path backtrack node c resulting answer e found node still marked b shown figure 10 backtrack c however cannot mark b state c b c b nonsimple path backtrack find e g r conflictfree g complies cycle constraint compatible r r restricted g acyclic fig 11 relationship regular expression r dbgraph g query qr already marked state b consequently search terminates without answer b found turns safe retain markings g acyclic r restricted however structure particular dbgraph g might case retain markings evaluate qr polynomial time even g acyclic r restricted definition 15 let intersection graph dbgraph g dfa path path form v initial path p conflictfree 1 p dbsimple 2 p q delta v q conflictfree v appears q v q v q case conflict v every simple initial path conflictfree said conflictfree 3 g r obvious g acyclic conflictfree matter regular expression r appears qr also r restricted theorem 4 exhibits containment hence conflictfree irrespective structure g finally g complies cycle constraint compatible r theorem 8 g r conflictfree show qr evaluated polynomial time conflictfree hence conflict freedom another weaker sufficient condition qr polynomial time evaluable see figure 11 result following lemma used evaluation algorithm lemma 3 let intersection graph dbgraph accepting lr initial path p conflictfree 1 p dbsimple 2 p q delta v q conflictfree v appears q first v q proof direction trivial assume p conflictfree dbsimple furthermore assume p q delta v q conflictfree v appears q prove induction number occurrences v q v first occurrence v q basis v occurs q trivial assume inductive hypothesis true fewer n occurrences v q let p q delta v since p conflictfree know definition v r q r inductive hypothesis example 9 consider dfa dbgraph g example 8 shown figure 10 intersection graph g shown figure 12 recall markings retained answer b would found however conflict initial path via b b c 6 c 3 strictly weaker definition conflictfreedom given 18 cc ae ba ae cb ae bc gammapsi r fig 12 intersection graph dbgraph g dfa figure 10 algorithm c evaluation query dbgraph input dbgraph query qr output qr g value qr g 1 construct dfa accepting lr 2 initialize qr g 3 node v 2 n set cm v pm v 4 test pair states 5 node v 2 n call searchv v 0 conflict see figure 14 b reset pm w marked node w 2 n fig 13 evaluation query dbgraph algorithm c detects conflicts unmarks nodes backtracking enabling answer b found proceed description algorithm c shown figure 13 algorithm uses dfa accepting lr control depthfirst search db graph g line 1 two reasons dfa rather ndfa used first ensure conflicts encountered r restricted second reason avoid detecting unnecessary conflicts ndfa 6 might case state q q ffi node v g first marked following cycle v satisfying l st traversed conflict would registered unnecessary since v would subsequently marked q simple path v satisfying would found q algorithm c traverses transition graph dbgraph g simultaneously effect performing depthfirst search intersection graph g often refer trees depthfirst search forest generated algorithm c line 5a tree forest rooted initial node final node reached line 8 adds appropriate pair nodes g qr g lines 9 10 force algorithm consider paths g satisfy r paths traversal restricted simple paths necessarily restricted dbsimple paths prove safe traverse nondbsimple paths procedure search u v var conflict u v nodes dbgraph state dfa dbcycle boolean flag 6 conflict false 7 cm v cm v fsg 8 2 f qr g 9 edge g v w label 11 firstcm 12 conflict true else cm 13 search u w newconflict 14 conflict conflict newconflict od 15 cm v cm 16 conflict pm v pm v fsg fi fig 14 search procedure query evaluation absence conflicts nodes g marked states visited two sets markings used node v 1 set current markings cm v indicates states v associated current path stack procedure lines 7 15 2 set previous markings pm v represents earlier markings v excluding current path line 16 current markings used avoid cycles detect conflicts previous markings used possible prevent node g visited state single execution line 5a function first applied marking set cm v returns first state marking v current path false marking node w visited state previous markings w either w currently unmarked cm w empty first state marking q v current path q conflict q lines 10 13 note may fact conflict later marking v current path affect correctness algorithm demonstrate lines 6 11 12 implement conflict detection conflict true conflict states q node w conflict set true line 12 lines 14 15 16 ensure marking node stack time conflict detected removed node unstacked conflict occurs path rooted v added previous markings v line 16 proofs follow often say v example stack procedure search variables v refer middle two parameters search correspond node v corresponding intersection graph reason excluding two parameters search u first remains unchanged execution line 5a always concerned value conflict b b b c e b c c c c b b c b c c c b c c c b c b fig 15 two possible depthfirst search trees also sometimes exclude conflict referring particular invocation search example searchu v proving correctness algorithm c demonstrate behaviour means example example 10 consider intersection graph figure 12 two possible depthfirst search trees dfsts traversed algorithm c shown figure 15 note nodes dfst repeated unmarking example node b appears three times figure 15a dotted edges figure lead nodes search called either conflict node already marked via either cm pm b latter edges correspond forward back cross edges conventional dfst 2 assume algorithm c starts traversal node searcha called line 5a order traversal according dfst figure 15a since initially nodes b c current marking line 11 evaluates false search called successively b c b b b final state c added qr g line 8 although c already current marking namely b fact b c means line 11 evaluates false search called c c first marking b 6 c conflict registered line 12 algorithm backtracks removing current markings line 15 assigning previous markings line 16 considering b c c b gives rise conflict algorithm tries path via e b note b c c longer marked revisited giving rise conflict time algorithm backtracks nodes unmarked dbsimple path b c finally found b added qr g path b c via e b chosen first algorithm c figure 15b conflicts would detected resulting previous markings kept b e traversing path c b line 10 would ensure b c b revisited conflicts registered lemma 4 conflict false line 16 searchu v algorithm c performed entire depthfirst search node v proof proof proceeds induction length longest simple path p v p length zero result follows trivially assume result holds nodes longest simple path length longest simple path length n conflict false line 16 searchu v must successor w v either 1 2 pm w line 10 2 newconflict must false line 14 case 1 conflict must false line 16 searchuw order added pm w case 2 conflict must false line 16 searchuw newconflict false line 14 since longest simple path w must length less equal n gamma 1 conclude inductive hypothesis entire depthfirst search w performed algorithm c clearly lines 9 10 consider every successor v result follows definition 16 node v depthfirst search tree called conflict predecessor successor w v w appears ancestor v first occurrence root say w q case q 6 words conflict q w lemma 5 consider execution searchu v dfs tree state added pm v line 16 descendant v conflict predecessor proof added pm v line 16 conflict must false hence lemma 4 entire depthfirst search v must performed conflict predecessor node w successor appear successor w thus conflict predecessor appear descendant v descendant v conflict predecessor conflict false descendants hence v thus added pm v line 16 dbgraph r regular expression let accepting lr intersection graph g algorithm c correct algorithm c adds u z qr g dbsimple path u 0 z f f 2 f simple path u z g satisfying r proof algorithm c clearly terminates since line 10 ensures simple paths considered simple path initial node considered algorithm adds u z qr g must traverse depthfirst search tree rooted u 0 simple path p u 0 z r r 2 f assume p dbsimple dbnode v appears p let first occurrence v p inode v last occurrence v thus first state added cm v order searchu v called line 13 line 11 must ensured hence path p 0 v z q q 2 f sequence dbnodes p 0 identical path v z r p since v v first last occurrences respectively v p path u 0 z q q 2 f dbsimple respect v simple induction number repeated dbnodes p shows dbsimple path u 0 z f assume dbsimple path p u 0 z f f 2 f obviously algorithm traverses p done assume let v last node p traversed w successor v p reason w visited cannot conflict since p dbsimple must case line 10 lemmas 4 5 entire depthfirst search v must performed since path v z f searchu z f must called case u z would added qr g line 8 theorem 11 absence conflicts algorithm c runs amount time bounded polynomial size dbgraph proof essential point absence conflicts algorithm c performs normal depthfirst search intersection graph polynomial size dbgraph detailed analysis time complexity algorithm follows let qr query r length g dbgraph n nodes e edges although many o2 states dfa accepting lr constant terms size g nevertheless assume q states include q analysis time complexity algorithm c since intersection graph g oqn nodes oq 2 e edges line 1 algorithm c done oq 2 time line 2 requires constant time line 3 takes time line 4 oq 2 time line 5 executed n times execution node visited conflictfree v stacked added cm v line 10 ensures v cannot restacked v unstacked added pm v line 16 removed pm v present execution line 5a terminated line 10 ensures v cannot revisited present execution 5a constant time needed lines 6 12 14 dbnode v cm v implemented stack access bottom element function first hence lines 7 11 15 performed constant time line 16 since fsg pm v disjoint line 10 line 8 implemented take oq time pair u v added qr g final state pm v line 10 also done oq time lines 9 10 inspect edge leaving node since node revisited search called times call takes oq time single execution line 5a takes oq 3 e time single execution line 5b takes time total time spent line 5 onq 3 e consequently algorithm c runs terms size g algorithm c runs one time assumption edges isolated nodes relationship depicted figure 11 obtain following corollary 5 algorithm c evaluates qr g time polynomial size g 1 r restricted 2 g acyclic 3 g complies cycle constraint compatible r even presence conflicts algorithm c run polynomial time size g case example r free regular expression let q length r r free finite number strings lr length longest string q also upper bound length longest dbsimple path hence q dbsimple paths even algorithm c traverses every dbsimple path exactly worst case still runs polynomial time size g number circumstances identified lead polynomialtime solutions example certainly queries evaluated polynomialtime arbitrary dbgraphs whose regular expressions restricted one class regular expressions form wa w string fixed length unfortunately dbgraphs algorithm c takes exponential time evaluate associated queries clearly much scope investigation additional classes queriesdb graphs polynomialtime evaluation possible identified appropriate general evaluation algorithms developed algorithm c could enhanced reacts sophisticated manner detecting conflict one possibility flag source conflict unmark nodes algorithm backtracks flagged node 6 conclusions addressed problem finding nodes labelled directed graph connected simple path satisfying given regular expression study motivated observation many recursive queries relational databases expressed form implementation query language based observation began describing naive algorithm might evaluate queries although algorithm runs exponential time worst case showed cannot expect better since evaluation problem general nphard using fact associated problem paths general opposed simple paths solvable polynomial time characterized class restricted regular expressions whose associated queries evaluated polynomial time considered restrictions structure regular expressions turned attention cyclic structure graphs queried introduced notion cycle constraint showed graph g complied cycle constraint compatible regular expression r qr g could evaluated polynomial time finally presented algorithm evaluating arbitrary expressions arbitrary graphs algorithm runs polynomial time regular expression restricted closure free b graph complies cycle constraint compatible regular expression special case graph acyclic c regular expression graph conflictfree difficult say often conditions encountered practice show class restricted regular expressions closed regular operators good starting point investigation larger classes expressions graphs polynomialtime evaluation algorithms would attempt identify class expressions graphs conflictfree algorithm c runs polynomial time emphasis paper identifying circumstances regular simple path problem solved polynomial time rather designing efficient algorithm cases believe topic future research example would interesting see whether techniques used sparse graphs 16 could employed algorithm order improve efficiency sparse graphs point analysis paper implementation assume graph entirely stored main memory reasonable assumption many cases especially intended applications query language g graph often fraction database presented visually natural way relaxing assumption provides interesting area study researchers investigating similar algorithms transitive closure claimed amenable efficient secondary storage implementation 15 finally note research done expressive power graphbased query languages restriction simple path semantics dropped one language captures exactly queries computable nondeterministic logarithmic space presented 8 online algorithms regular path finding given 5 survey many results found 24 r alpha extension relational algebra express class recursive queries design analysis computer algorithms universality data retrieval languages completeness query languages relational databases data structure arc insertion regular path finding relational completeness data base sublanguages graphlog visual formalism real life recursion graphical query language supporting recursion directed subgraph homeomorphism problem efficient evaluation subset recursive queries introduction automata theory equivalence efficient transitive closure algorithms efficient algorithm transitive closure linear worstcase complexity result class sparse graphs evenpath problem graphs digraphs finding regular simple paths graph databases practical approach supporting recursive applications polynomial solution undirected two paths problem word problems requiring exponential time fast algorithms solving path problems implementation logical query languages databases tr ctr kemafor anyanwu amit sheth operator discovering ranking associations semantic web acm sigmod record v31 n4 december 2002 kemafor anyanwu amit sheth operator discovering ranking associations semantic web acm sigmod record v31 n4 december 2002 dan c stefanescu alex thomo lida thomo distributed evaluation generalized path queries proceedings 2005 acm symposium applied computing march 1317 2005 santa fe new mexico weighted path queries semistructured databases information computation v204 n5 p679696 may 2006 gsta grahne alex thomo regular path queries approximate semantics annals mathematics artificial intelligence v46 n12 p165190 february 2006 phillip g bradford language constrained graph problems microcosm engineering research development proceedings 2nd wseas international conference computer engineering applications p7176 january 2527 2008 acapulco mexico makoto murata extended path expressions xml proceedings twentieth acm sigmodsigactsigart symposium principles database systems p126137 may 2001 santa barbara california united states frank neven thomas schwentick expressive efficient pattern languages treestructured data extended abstract proceedings nineteenth acm sigmodsigactsigart symposium principles database systems p145156 may 1518 2000 dallas texas united states taesun chung hyoungjoo kim xml query processing using document type definitions journal systems software v64 n3 p195205 15 december 2002 serge abiteboul victor vianu regular path queries constraints proceedings sixteenth acm sigactsigmodsigart symposium principles database systems p122133 may 1115 1997 tucson arizona united states gsta grahne alex thomo query containment rewriting using views regular path queries constraints proceedings twentysecond acm sigmodsigactsigart symposium principles database systems p111122 june 0911 2003 san diego california partially ordered regular languages graph queries journal computer system sciences v70 n1 p125 february 2005 sergio flesca filippo furfaro sergio greco graph grammars based framework querying graphlike data data knowledge engineering v59 n3 p652680 december 2006 yaron kanza yehoshua sagiv flexible queries semistructured data proceedings twentieth acm sigmodsigactsigart symposium principles database systems p4051 may 2001 santa barbara california united states sangwon park hyoungjoo kim sigdaq enhanced xml query optimization technique journal systems software v61 n2 p91103 march 2002 gsta grahne alex thomo algebraic rewritings optimizing regular path queries theoretical computer science v296 n3 p453471 14 march ravi kumar prabhakar raghavan sridhar rajagopalan andrew tomkins extracting largescale knowledge bases web proceedings 25th international conference large data bases p639650 september 0710 1999 george mihaila louiqa raschid anthony tomasic locating accessing data repositories websemantics vldb journal international journal large data bases v11 n1 p4757 august 2002 ravi kumar prabhakar raghavan sridhar rajagopalan sivakumar andrew tompkins eli upfal web graph proceedings nineteenth acm sigmodsigactsigart symposium principles database systems p110 may 1518 2000 dallas texas united states yannis papakonstantinou victor vianu dtd inference views xml data proceedings nineteenth acm sigmodsigactsigart symposium principles database systems p3546 may 1518 2000 dallas texas united states elisa bertino mohandsad hacid farouk toumani retrieval semistructured web data intelligent exploration web physicaverlag gmbh heidelberg germany stephen dill ravi kumar kevin mccurley sridhar rajagopalan sivakumar andrew tomkins selfsimilarity web acm transactions internet technology toit v2 n3 p205223 august 2002 stephen dill ravi kumar kevin mccurley sridhar rajagopalan sivakumar andrew tomkins selfsimilarity web proceedings 27th international conference large data bases p6978 september 1114 2001 finegrained access control system xml documents acm transactions information system security tissec v5 n2 p169202 may 2002 mohandsad hacid farouk toumani ahmed k elmagarmid constraintbased approach semistructured data fundamenta informaticae v47 n12 p5373 january 2001 kemafor anyanwu amit sheth queries enabling querying semantic associations semantic web proceedings 12th international conference world wide web may 2024 2003 budapest hungary elisa bertino ahmed k elmagarmid mohandsad hacid ordering path constraints semistructured data journal intelligent information systems v20 n2 p181206 march serge abiteboul paris c kanellakis object identity query language primitive journal acm jacm v45 n5 p798842 sept 1998 dennis shasha jason l wang rosalba giugno algorithmics applications tree graph searching proceedings twentyfirst acm sigmodsigactsigart symposium principles database systems june 0305 2002 madison wisconsin
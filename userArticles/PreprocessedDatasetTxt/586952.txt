randomized timework optimal parallel algorithm finding minimum spanning forest present randomized algorithm find minimum spanning forest msf undirected graph high probability algorithm runs logarithmic time linear work exclusive read exclusive write erew pram result optimal wr work parallel time first provably optimal parallel algorithm problem measures also give simple general processor allocation scheme treelike computations b introduction present randomized parallel algorithm find minimum spanning forest msf edge weighted undirected graph erew pram kr90 algorithm runs expected logarithmic time linear work size input bounds also hold high probability size input result optimal respect work parallel time first provably optimal parallel algorithm problem measures brief summary related results following lineartime sequential msf algorithm karger klein tarjan kkt95 building came linearwork parallel mst algorithms crcw pram ckt94 ckt96 erew pram pr97 best crcw pram algorithm known date ckt96 runs logarithmic time linear work time bound known optimal best erew pram algorithm known prior work result poon ramachandran runs olog n log log linear work algorithms randomized recently chong han lam chl99 presented deterministic erew pram algorithm msf runs logarithmic time linear number processors hence work om n log n n number vertices edges input graph observed poon ramachandran pr98 algorithm pr97 could speeded run olog n delta 2 log n time linear work using algorithm chl99 subroutine modifying contract subroutine pr97 paper improve running time algorithm pr97 pr98 olog n best possible improve algorithm ckt96 achieving logarithmic time bound less powerful erew pram part work supported texas advanced research program grant 00365800291999 seth pettie also supported mcd fellowship algorithm simple 2phase structure makes subroutine calls chonghan lam algorithm chl99 fairly complex outside subroutine calls made simplest version algorithm chl99 steps algorithm quite straightforward addition first timework optimal parallel algorithm msf algorithm used simpler alternative several parallel algorithms 1 crcw pram replace calls chl algorithm calls simple logarithmic time linearprocessor crcw algorithm one as87 resulting algorithm runs logarithmic time linear work considerably simpler msf algorithm ckt96 2 modified crcw pram algorithm simpler linearwork logarithmictime crcw algorithm connected components given gaz91 3 algorithm improves erew connectivity spanning tree algorithms hz94 hz96 since compute minimum spanning tree within time work bounds algorithm simpler algorithms hz94 hz96 following use notation denote union sets use e denote set formed adding element e set say result holds high probability whp n probability fails hold less 1n c constant rest paper describes analyzes algorithm organized follows section 2 gives highlevel description algorithm works two phases section 3 describes details phase 1 algorithm main procedure phase 1 findkmin given section 34 section 4 gives phase 2 whose main procedure findmsf section 5 gives proof algorithm runs expected logarithmic time linear work section 6 extends result highprobability bounds section 7 addresses issue processor allocation various steps algorithm section 8 discusses adaptability algorithm realistic parallel models like bsp val90 qsm gmr97 paper concludes section 9 2 highlevel algorithm algorithm divided two phases along lines crcw pram algorithm ckt96 phase 1 algorithm reduces number vertices graph n nk vertices n number vertices input graph perform reduction algorithm uses familiar recursion tree depth log n ckt94 ckt96 pr97 gives rise o2 log n recursive calls time needed per invocation algorithm well olog n2 log n thus total time phase 1 olog n accomplish requiring phase 1 find subset msf contracting subset msf obtain graph onk vertices phase 2 uses algorithm similar one pr97 needs recursion due reduced number vertices graph thus phase 2 able find msf contracted graph olog n time linear work assume edge weights unique always uniqueness forced ordering vertices ordering identically weighted edges end points highlevel description algorithm use log r n denote log function iterated r times log n denote minimum r st log r n 1 phase retain lightest k edges edgelistv g 0 contract edges g appearing phase sample edges g 0 prob 1 log 2 n theorem 21 high probability highlevelg returns msf g olog n time using processors following sections describe analyze algorithms phase 1 phase 2 present proof main theorem expected running time obtain high probability bound running time work analyzing performance algorithms phase 1 phase 2 use timework framework assuming perfect processor allocation achieved high probability within constant factor using loadbalancing scheme hz94 requires superlinear space linearspace scheme claimed hz96 discuss processor allocation section 7 point simple scheme similar one hz94 takes linear space qrqw pram gmr94 slightly stronger model erew pram usefulness qrqw pram lies fact algorithms designed model map generalpurpose models qsm gmr97 bsp val90 well erew pram describe performance msf algorithm qsm bsp phase 1 goal contract input graph g graph onk vertices identifying certain edges minimum spanning forest g contracting connected components formed edges challenge identify edges logarithmic time linear work phase 1 achieves desired reduction number vertices constructing kmin forest defined similar algorithm ckt96 however algorithm considerably simpler show kmin forest satisfies certain properties exploit properties design procedure boruvkaa keeps sizes trees contracted various stages phase 1 small total time needed contracting processing edges trees olog n2 log n phase 1 also needs filter subroutine removes kmin heavy edges show use msf verification algorithm small trees construct perform step overall algorithm phase 1 findkmin uses two subroutines achieve stated reduction number vertices within desired time work bounds 31 kmin forest phase 1 uses familiar sample contract discard edges framework earlier randomized algorithms msf problem kkt95 ckt94 ckt96 pr97 however instead computing minimum spanning forest construct kmin tree ckt96 vertex log 2 n 2 contracting edges kmin trees produce graph onk vertices understand kmin tree consider dijkstrajarnikprim minimum spanning tree algorithm choose arbitrary starting vertex v repeat contains mst g choose minimum weight edge b st 2 b 62 edge set kminv consists first k edges chosen algorithm started vertex v forest f kmin forest g f msfg v 2 g kminv f set edges path x tree let maxweightfag maximum weight set edges forest f g define edge b g f heavy weighta b maxweightfp f bg f light otherwise b tree f b flight let kmin tree v define weight v w maxweightfpm v wg w appears maxweightfkminvg define edge b kminheavy maxfweight b weight b ag kminlight otherwise 31 let measure weight v w defined respect k range 1n weight v w maxweightfpmsf v wg proof two cases w falls inside kmin tree v falls outside w inside kminv weight v w maxweightfpmsf v wg since kminv msf suppose w falls outside kminv weight v w maxweightfpmsf v wg must path v w msf consisting edges lighter maxweightfkminvg however step dijkstrajarnikprim algorithm least one edge pmsf eligible chosen step since w 62 kminv edge weight maxweightfkminvg never chosen contradiction 2 let k vector n values range 1n vertex u associated value denoted k u define edge u v kminlight weightu v maxfweight u v weight v ug weight u v weight v u defined respect k u k v respectively lemma 31 let h graph formed sampling edge graph g probability p expected number edges g kminlight h less np k proof show edge kminlight g also f light f msf h lemma follows sampling lemma kkt95 states expected number f light edges g less np let us look kminlight edge v w 31 weight v w maxweightfpmsf v wg measure used determine f lightness thus criterion kminlightness maxfweight v w weight w vg must also less equal maxweightfpmsf v wg restating v w kminlight must f light well 2 use property kmin forest develop procedure findkming l takes input graph g suitable positive integer l returns kmin forest g runs logarithmic time linear work next sections describe basic steps procedures used findkmin present analyze main procedure phase 1 phase 1 concerned kmin tree vertex suffices retain lightest k edges incident vertex hence stated first step phase 1 algorithm highlevel section 2 discard lightest k edges incident vertex since need phase 2 step performed logarithmic time linear work simple randomized algorithm selects sample size jlj adjacency list l sorts sample uses sorted list narrow search kth smallest element list size ojlj 34 32 boruvkaa steps basic boruvka step bor26 vertex chooses minimum weight incident edge inducing number disjoint trees trees contracted single vertices useless edges discarded call edges connecting two vertices tree internal others external internal edges useless multiple external edges join two trees lightest useless algorithm phase 1 uses modified boruvka step order reduce time bound olog n per step vertices classified either live dead modified boruvka step vertex vs parent pointer edge minimum weight incident v addition vertex threshold keeps weight lightest discarded edge adjacent v algorithm discards edges known kmin tree vertex threshold variable guards vertices choosing edges may msf dead vertex v useful property shown edge b kminv weighta b weightv pv thus dead vertices need participate boruvka steps wellknown boruvka step generates forest pseudotrees pseudotree tree together one extra edge forms cycle length 2 algorithm assume boruvka step also removes one edges cycle generates collection rooted trees following three claims refer tree resulting modified boruvka step proofs straightforward omitted 32 sequence edge weights encountered path v rootv monotonically decreasing 33 consists edges path v rootv furthermore weight v pv greater edge dminv 34 minimumweight incident edge u u v kminu kminv tree induced boruvka step let 0 subtree e minimum weight incident edge minimum weight incident edge 0 either e edge proof suppose contrary minimum weight incident edge 0 e 0 62 let v v 0 end points e e 0 inside consider paths p v 0 root claim 32 edge weights encountered p p 0 monotonically decreasing two cases 0 contains p 0 e 0 must lie along p 0 contradiction 0 contains p 0 p edge e 00 2 p adjacent procedure boruvkaah l f given returns contracted version h number live vertices reduced factor l edges designated parent pointers guaranteed msf h returned f initially repeat log l times log l modified boruvka steps live vertex v choose min weight edge v w 1 weightv w thresholdv v becomes dead stop else tree induced edges f 0 one two types root dead 2 every vertex becomes dead claim 34 contains live vertices 3 depthv k v becomes dead claim 33 contract subtree made live vertices resulting vertex live parent pointer keeps smallest threshold constituent vertices lemma 32 boruvkaa designates vertex dead kmin tree already found proof vertices make transition live dead lines indicated number assumption discard edges cannot kmin tree vertex lightest edge adjacent vertex discarded know kmin tree already found covers line 1 correctness line 2 follows claim 34 since v pv lightest incident edge v kminv called dead since root tree dead vertices depth one dead implying vertices depth two dead validity line 3 follows directly claim 33 vertex finds depth k kmin tree lies along path vertex root 2 lemma 33 call boruvkaah k tree vertex subset f proof lemma 32 dead vertices already satisfy lemma single modified boruvka step set parent pointers associated live vertices induce number trees let v tree containing v assume inductively dlog ie modified boruvka steps tree vertex original graph found clearly true live vertex v let x minimum weight edge st x 2 v 62 v inductive hypothesis gamma 1min trees v subsets v respectively first external edge v chosen dijkstrajarnikprim algorithm starting v every edge gamma 1miny lighter x subset chosen dlog ie th modified boruvka step subset v dlog ie modified boruvka steps thus steps kmin tree vertex found 2 lemma 34 b modified boruvka steps length edge list bounded k k b proof true assuming lemma holds modified boruvka steps length edge list many steps k k since contract trees height k length edge list b steps 2 shown next section algorithm deals graphs result olog modified boruvka steps hence maximum length edge list k k olog costliest step boruvkaa calculating depth vertex minimum weight edge selection process root induced tree broadcast depth depth 1 vertices turn broadcast depth 2 vertices etc vertex knows depth may stop letting descendents infer depth k interleaved round broadcasting processor allocation step account cost separately section 7 lemma 35 let g 1 1 edges call boruvkaag 1 l f executed time ok olog processors proof let g 1 result b modified boruvka steps lemma 34 maximum degree vertex th modified boruvka step current call boruvkaa k k bi let us look required time th modified boruvka step selecting minimum cost incident edge takes time log k k bi time determine depth vertex k delta log k k bi summing log l modified boruvka steps total time bounded p log l noted algorithm performs olog modified boruvka steps graph hence time k olog work performed modified boruvka step linear number edges summing log l steps dividing number processors arrive second term stated running time 2 33 filtering step filter forest concurrent modified boruvka step maintain filter forest structure records vertices merged together time edge weights involved structure appeared first king97 v vertex original graph new vertex resulting contracting set edges corresponding vertex oev filter est boruvka step vertex v becomes dead new vertex w added filter forest well directed edge oev w weight v pv live vertices contracted live vertex v vertex oev added filter forest addition directed edges weights edges v shown king97 heaviest weight path u v msf heaviest weight path oeu oev filter forest path hence measures weight v w easily computed following way let p f x path x filter forest oev oew filter tree weight weight w v w filter tree let weight 36 maximum weight path oev rootoev maximum weight edge rminv r proof rootoev height h result h boruvka steps assume claim holds first h boruvka steps number contractions vertex v original graph represented current graph v c let vc tree induced th boruvka step contains v c let e minimum weight incident edge vc inductive hypothesis maxweightfp f oev oet vc shown proof claim 35 edges path v c edge e weight weighteg edges v c pv c e corresponding edge filter forest namely oev c poev c oet vc poet vc since edges path oev poet vc maxweightfp f oev poet vc thus claim holds filter step call filterh f findkmin examine edge e h weighte maxfweight v w weight w vg order carry test use olog n time om work msf verification algorithm kprs97 modify algorithm case x tree test pairs oex rootoex oey rootoey delete e pairs identified deleted computation take time olog r r size largest tree formed procedure filter discards edges cannot kmin tree vertex discards edge b updates threshold variables b thresholda weight lightest discarded edge adjacent minimum weight edge ever heavier thresholda kmina already found becomes dead graph formed sampling edge h probability p f kmin forest h 0 call filterh f returns graph containing kmin forest h whose expected number edges np proof vertex v claim 36 states maxweightfp f oev minv value k v building vector k values one vertex able check kminlightness using filter forest follows lemma 31 expected number kminlight edges h less np need show kminlight edge h removed filter step suppose edge u v kmin tree u h removed filter v k u min tree u wrt h 0 edge u v heaviest edge cycle could msf much less kmin tree v k u min tree u wrt h 0 weightu v maxweightfk u minug meaning edge u v could picked first k steps dijkstrajarnikprim algorithm 2 34 finding kmin forest ready present main procedure phase 1 findkmin recall initial call given section 2 findkming log n g graph obtained g removing k lightest edges adjacency list findkminh sample edges h c prob 1log igamma1 n 2 h graph vertices possibly marked dead parameter indicates level recursion determines number boruvka steps performed sampling probability lemma 36 call findkming log n returns set edges includes kmin tree vertex g proof proof induction base returns f lemma 33 contains kmin tree vertex induction step assume inductively findkminh igamma1 returns kmin tree h consider call findkminh induction assumption call findkminh returns kmin tree vertex h claim 37 call filterh c f returns h f set edges contains kmin trees vertices h c finally inductive assumption set edges returned call findkminh f contains kmin trees vertices contains log igamma1 nmin tree vertex h findkminh returns returns edges kmin tree vertex h 2 38 following invariants maintained call findkmin number live vertices h nlog n 4 expected number edges h mlog n 2 n number edges vertices original graph proof clearly hold initial call log n lemma 33 contracted graph h c nlog igamma1 n 4 live vertices since h derived sampling edges probability 1log igamma1 n 2 expected number edges h mlog igamma1 n 2 maintaining invariants first recursive call lemma 31 expected number edges h f nlog igamma1 n 2 log igamma1 n 4 number vertices h c invariants maintained second recursive call35 performance findkmin lemma 37 findkming log n runs expected time olog n work om n proof since recursive calls findkmin proceed sequential fashion total running time sum local computation performed invocation aside randomly sampling edges takes constant time work linear number edges local computation consists calls filter boruvkaa given invocation findkmin number boruvka steps performed graph h sum boruvka steps performed ancestral invocations findkmin ie p log n olog 3 n bound maximum length edge lists lemma 34 infer size tree filter forest k k olog 3 n thus time needed modified boruvka step filter step k olog 3 n summing steps total time required olog n work required filter procedure boruvka step linear number edges number edges given invocation omlog n 2 olog n boruvka steps performed invocation work required invocation om log n recall parameter indicates depth recursion since 2 log ngammai invocations depth parameter total work given p log n log ngammai om log n om4 phase 2 recall phase 2 portion overall algorithm highlevel number vertices g nk g sample edges g 0 prob 1 log 2 n procedure filterg f kprs97 returns f light edges g procedure find described finds msf g 1 time om 1 log n log 2 n 1 number edges g 1 graphs g g f expected log 2 n edges since g derived sampling edge probability 1 k sampling lemma kkt95 expected number edges g f mk1 k call findmsf graphs expected size om log 2 n call takes olog n time 41 findmsf procedure procedure findmsfh similar previous randomized parallel algorithms except uses recursion instead separate base case algorithm used place recursive calls also use slightly different boruvka steps order reduce work modifications inspired pr97 pr98 respectively basecase use simplest version algorithm chong et al chl99 takes time olog n using mn log n processors guaranteeing called graphs expected size om log 2 n running time remains olog n processors findmsfh h sample edges h c prob call boruvkab graph h c log 4 n vertices since h derived sampling edges h c probability 1 log 2 n expected number edges first basecase call om log 2 n sampling lemma kkt95 expected number edges second basecase call log 4 n1 log 2 n thus total time spent subcalls olog n assuming size h conforms expectation om log 2 n calls filter boruvkab also take olog n time described boruvkabh l f procedure returns contracted version h oml vertices uses simple growth control schedule designating vertices inactive degree exceeds l determine vertex inactive performing list ranking edge list log l time steps computation stopped much time edge list length l boruvkabg repeat log l times vertex let inactive edge list l edges active otherwise active vertex v choose min weight incident edge e using edgeplugging technique build single edge list induced tree o1 time contract trees inactive vertices last step takes olog n time steps take olog l time deal edge lists length ol consequently total running time olog l iteration main loop work linear number edges assuming graph conforms expected size om log 2 n total work linear edgeplugging technique well idea growth control schedule introduced johnson metaxas jm92 5 proof main theorem proof theorem 21 set edges returned findkmin subset msf g contracting edges produce g 0 msf g given edges together msf g 0 call filter produces graph g f removing g 0 edges known msf thus msf g f msf g 0 assuming correctness findmsf set edges f constitutes msf g f thus f msf g earlier shown step highlevel requires olog n time work linear number edges next two sections show whp number edges encountered graphs algorithm linear size original graph 2 6 high probability bounds consider single invocation findkminh h 0 edges n 0 vertices want place likely bounds number edges recursive call findkmin terms 0 first recursive call edges h sampled independently probability 1log igamma1 n 2 call sampled graph h 1 applying chernoff bound probability size h 1 less twice expectation analyzing second recursive call recall sampling lemma kkt95 states number f light edges conforms negative binomial distribution parameters sampling probability f msf h 1 saw proof lemma 31 every kminlight edge must also f light using observation analyze size second recursive call terms f light edges conclude bounds attain apply equally kminlight edges bound likelihood twice expected number edges f light probability sequence 2n 0 p flips coin probability p heads coin comes heads less n 0 times since edge selected coin toss heads goes msf sampled graph applying chernoff bound expgammaomegagamma n 0 particular instance findkmin n 0 mlog igamma1 n 4 probability fewer 2mlog igamma1 n 2 edges f light given single invocation findkminh bound probability h 2 log ngammai mlog n 2 edges expgammaomegagamma mlog n 4 follows applying argument used invocation findkmin initial call current call depth log summing recursive calls findkmin total number edges thus total work bounded p log n probability phase 2 uses om work omit analysis similar analysis phase 1 probability bounds time total work performed algorithm fail hold exponentially small input size however assumes perfect processor allocation next section show probability work fails distributed evenly among processors less 1m 1 thus overall probability failure small algorithm runs logarithmic time linear work whp 7 processor allocation stated section 2 processor allocation needed algorithm performed fairly simple algorithm given hz94 takes logarithmic time linear work uses superlinear space involved algorithm claimed hz96 runs logarithmic time linear work space show simple algorithm similar spirit one hz94 runs logarithmic time linear work space qrqw pram gmr94 qrqw pram intermediate power erew crcw pram allows concurrent memory accesses time taken accesses equal largest number processors accessing single memory location assume total size input n processors group q processors qr groups size r log n make initial assignment log n elements group initial assignment made element choose group randomly expected number elements group r log n chernoff bound whp log n elements group vertices assigned group collected together array group olog n time work space using qrqw pram algorithm multiple compaction given gmr96 runs logarithmic time linear work high probability need full power algorithm gmr96 since know ahead time group c log 2 n elements whp suitable constant c hence suffices use heavy multiple compaction algorithm gmr96 achieve bounds logarithmic time linear work space simple analysis using chernoff bounds shows new graph encountered computation group receives either log n elements within constant factor expected number elements whp hence olog log n erew pram steps processor within group assigned 1log n elements group processor reallocation scheme takes olog log n time per stage linear space overall high probability achieves perfect balance within constant factor total number processor reallocation steps needed algorithm o2 log n delta k log log log n hence time needed perform processor allocation steps olog n whp note probability processors allocated optimally within constant increased 1 gamma n gamma1 increasing group size r since perform olog 2 n 3 processor allocation steps r set high n 1log 2 n 3 without increasing overall olog n running time thus high probability bound number items group log n becomes 1gamman gamma1 shown gmr96 heavy multiple compaction algorithm runs time olog n log log log time whp 0 choosing log log n log n obtain olog n running time initial step probability also overall probability bound processor allocation 8 adaptations practical parallel models results imply good msf algorithms qsm gmr97 bsp val90 models realistic models parallel computation pram models theorem 81 given follows directly results mapping erew qrqw computations qsm given gmr97 theorem 82 follows qsm bsp emulation given gmr97 conjunction observation slowdown emulation due hashing occur algorithm since assignment vertices edges processors made processor allocation scheme achieves effect theorem 81 msf edgeweighted graph n nodes edges found og log n time ogm using om n space qsm simple processor allocation scheme g gap parameter qsm theorem 82 msf edgeweighted graph n nodes edges found bsp ol g log n time whp using processors om n space simple processor allocation scheme g l gap periodicity parameters bsp 9 conclusion presented randomized algorithm msf erewpram provably optimal time work algorithm works within stated bounds high probability input size good performance popular parallel models important open question remains obtain deterministic parallel msf algorithm provably optimal time work recently optimal deterministic sequential algorithm msf presented pr00 intriguing aspect algorithm function describing running time known present although proven pr00 algorithm runs within small constant factor best possible parallelizing optimal sequential algorithm topic worth investigating r new connectivity msf algorithms shuffleexchange networks pram jistem problemu minimaaln im moravske p parallel time complexity undirected connectivity minimum spanning trees linearwork parallel algorithm finding minimum spanning trees finding minimum spanning trees logarithmic time linear work using random sampling note two problems connexion graphs qrqw pram accounting contention parallel algorithms efficient lowcontention parallel algorithms sharedmemory model serve bridging model parallel computation theory computing systems optimal randomized logarithmic time connectivity algorithm erew pram optimal randomized erew pram algorithms finding spanning forests basic graph connectivity problems connected components olog 3 simpler minimum spanning tree verification algorithm randomized lineartime algorithm find minimum spanning trees optimal erew pram algorithm minimum spanning tree verification parallel algorithms sharedmemory machines randomized linear work erew pram algorithm find minimum spanning forest private communication optimal minimum spanning tree algorithm bridging model parallel computation shortest connection networks generalizations tr ctr aaron windsor nc algorithm finding maximal acyclic set graph proceedings sixteenth annual acm symposium parallelism algorithms architectures june 2730 2004 barcelona spain vladimir trifonov olog n log log n space algorithm undirected stconnectivity proceedings thirtyseventh annual acm symposium theory computing may 2224 2005 baltimore md usa david bader guojing cong fast sharedmemory algorithms computing minimum spanning forest sparse graphs journal parallel distributed computing v66 n11 p13661378 november 2006 guojing cong david bader designing irregular parallel algorithms mutual exclusion lockfree protocols journal parallel distributed computing v66 n6 p854866 june 2006
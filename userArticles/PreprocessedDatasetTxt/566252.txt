weak bisimilarity finitestate systems bpa normed bpp decidable polynomial time prove weak bisimilarity decidable polynomial time finitestate systems several classes infinitestate systems contextfree processes normed basic parallel processes normed bpp best knowledge first polynomial algorithms weak bisimilarity problems involving infinitestate systems b introduction recently lot attention devoted study decidability complexity verification problems infinitestate systems 33125 consider problem weak bisimilarity certain infinitestate processes finitestate ones motivation intended behavior process often easy specify finitestate system real implementation contain components essentially infinitestate eg counters buffers recursion creation new parallel subprocesses aim leave institute informatics technical university munich supported alexander von humboldt foundation grant agency czech republic grant 201000400 supported daad postdoc grant d9828804 preprint submitted elsevier preprint 8 november 2000 check finitestate specification infinitestate implementation semantically equivalent ie weakly bisimilar concentrate classes infinitestate processes definable syntax bpa basic process algebra normed bpp basic parallel pro cesses systems bpa processes also known contextfree processes seen simple sequential programs due binary operator sequential composition recently used solve problems dataflow analysis optimizing compilers 13 bpp 8 model simple parallel systems due binary operator parallel composition equivalent communicationfree nets subclass petri nets 36 every transition exactly one inputplace 11 process normed iff every reachable state terminate via finite sequence computational steps although syntax bpa bpp allows define simple infinitestate systems practical point view also important give compact definitions finitestate processes ie size bpabpp definition finitestate process f exponentially smaller number states f see next section verification algorithms polynomial size bpabpp definition potentially verify large processes thus results also seen way overcome wellknown problem statespace explosion state art baeten bergstra klop 1 proved strong bisimilarity 35 decidable normed bpa processes simpler proofs given later 2014 even polynomialtime algorithm 17 decidability result later extended class necessarily normed bpa processes 10 best known algorithm doubly exponential 4 decidability strong bisimilarity bpp processes established 9 associated complexity analysis yield elementary upper bound although deeper examination might principle show algorithm elementary strong bisimilarity bpp shown conphard 28 however polynomialtime algorithm subclass normed bpp 18 strong bisimilarity normed bpa normed bpp also decidable 7 result even holds parallel compositions normed bpa normed bpp processes 22 recently even generalized class normed paprocesses 16 weak bisimilarity much less known semidecidability weak bisimilarity bpp shown 11 15 shown weak bisimilarity decidable bpa bpp processes totally normed process totally normed terminate moment via finite sequence computational steps least one steps must visible ie noninternal decidability weak bisimilarity general bpa bpp open problems might decidable surely intractable suming p 6 np weak bisimilarity normed bpa pspacehard 38 np lower bound weak bisimilarity bpp shown stribrna 38 result improved pi p hardness mayr 28 recently pspacehardness srba 37 moreover pspace lower bound weak bisimilarity bpp 37 holds even normed bpp situation dramatically different consider weak bisimilarity certain infinitestate processes finitestate ones study motivated fact intended behavior process often easy specify finitestate system real implementation contain components infinitestate eg counters buffers recursion creation new parallel subprocesses shown 26 weak bisimilarity bpp finitestate processes decidable general result recently obtained 21 shown many bisimulation like equivalences including strong weak ones decidable pad finitestate processes class pad 3130 strictly subsumes bpa bpp also pa 2 pushdown processes result 21 obtained general reduction modelchecking problem simple branchingtime temporal logic ef decidable pad 30 modelchecking problem ef hard example known pspacecomplete bpp 26 pspacecomplete bpa 3927 yield efficient algorithm contribution show weak hence also strong bisimilarity decidable polynomial time bpa finitestate processes normed bpp finitestate processes best knowl edge first polynomial algorithms weak bisimilarity infinitestate systems moreover algorithm bpa first example efficient decision procedure class unnormed infinitestate systems polynomial algorithms strong bisimilarity 1718 work normed subclasses bpa bpp respectively due aforementioned hardness results symmetric case compare two bpa two normed bpp processes know results cannot extended direction recent work 29 shows strong bisimilarity pushdown processes proper superclass bpa finitestate ones already pspacehard furthermore weak bisimilarity remains computationally intractable dphard even processes onecounter nets finitestate processes 23 onecounter nets computationally equivalent subclass petri nets one unbounded place thus also seen simple pushdown automata hence result bpa rather tight question whether result normed bpp extended class necessarily normed bpp processes left open also noted simulation equivalence finitestate process conphard bpabpp processes 25 exptimecomplete pushdown processes 24 polynomial onecounter nets 24 basic scheme constructions bpa normed bpp processes main idea weak bisimilarity bpa normed bpp processes finitestate ones generated finite base small size certain infinite subsets bpa bpp statespace symbolically described finite automata contextfree grammars respectively detailed intuition given section 3 interesting point construction works although weak bisimulation congruence wrt sequential composition left congruence section 4 propose natural refinement weak bisimilarity called terminationsensitive bisimilarity congruence also decidable bpa finitestate processes polynomial time result demonstrates technique used weak bisimilarity actually wider applicabilityit adapted many bisimulation like equivalences finally note aim show mentioned problems although compute degrees bounding polynomials explicitly analysis quite simple rough moreover presented algorithms could easily improved employing standard techniques see final section comments use process rewrite systems 31 formal model processes let act countably infinite sets actions process constants respectively class process expressions e defined const special constant denotes empty expres sion intuitively sequential composition k parallel composition distinguish expressions related structural congruence given following laws k associative k commu tative unit k process rewrite system 31 specified finite set rules delta form e act const delta act delta denote sets process constants actions used rules delta respectively note sets finite process rewrite system delta defines unique transition system states process expressions const delta act delta set labels transitions determined delta following inference rules remember k commutative ef ekf extend notation e f elements act standard way f reachable e e w sequential parallel expressions process expressions contain k operator respectively finitestate bpa bpp systems subclasses process rewrite systems obtained putting certain restrictions form rules finitestate bpa bpp allow single constant lefthand side rules single constant sequential expression parallel expression righthand side respectively set states transition system generated finitestate bpa bpp process delta restricted const delta set sequential expressions const delta set parallel expressions const delta respectively example g process rewrite system see delta bpa system part transition system associated delta reachable z looks follows z iz iiz iiiz z replace occurrence operator k operator obtain bpp system generates following transition system draw part reachable z z z z z z z z z process normed iff every reachable state successfully terminate via finite sequence computational steps bpa bpp process equivalent condition constant x 2 const delta underlying system delta w 2 act x w call constants x property normed semantical equivalence interested weak bisimilarity 32 relation distinguishes observable internal moves compu tational steps internal moves modeled special action denoted convention follows consider process expressions const delta delta fixed process rewrite system definition 2 extended transition relation defined e binary relation r process expressions weak bisimulation iff whenever 2 act f ffl f e weakly bisimilar written e f iff weak bisimulation relating weak bisimilarity approximated family relations defined follows following conditions hold f e worth noting equivalence 1 transitive possible approximate weak bisimilarity different way approximations equivalences see 21 however need purposes gamma finitestate system n states f g 2 const gamma easy show problem whether f g decidable 3 time first compute 3 time transitive closure transition system wrt transitions thus obtain new system old system suffices decide strong bisimilarity f g new system done 2 log n time using partition refinement techniques 34 sometimes also consider weak bisimilarity processes different process rewrite systems say delta gamma formally delta gamma considered single system taking disjoint union section prove weak bisimilarity decidable bpa finitestate processes polynomial time let e bpa process underlying system delta f finitestate process underlying system gamma const delta const wlog e 2 const delta moreover also assume f g 2 const gamma 2 act f 6 g 6 f implies f gamma transitions missing gamma add safely adding transitions change weak bisimilarity relation among states order suffices compute cubic time transitive closure gamma wrt transitions extra transitions influence complexity estimations always consider worst case gamma possible transitions condition 6 want add new transitions form f proof weak bisimilarity would immediately work termination sensitive bisimilarity defined end section use uppercase letters denote elements const delta lowercase letters f denote elements const gamma greek letters ff used denote elements const delta size delta denoted n size gamma measure complexity algorithm n set const delta divided two disjoint subsets normed unnormed constants remember x 2 const delta normed iff x w w 2 act note decidable 2 constant normed set normed constants delta denoted normed delta constructions also use processes form fff seen bpa processes underlying system delta gamma intuition proof divided two parts first show greatest weak bisimulation processes delta gamma finitely repre sentable finite relation b size onm 2 called bisimulation base pair weakly bisimilar processes generated base technique first used caucal 6 show bisimulation base computed polynomial time take sufficiently large relation g surely subsumes base refine refinement technique used 1718 size g still onm 2 step refinement procedure possibly deletes elements g nothing deleted found base hence need steps refinement step formally introduced definition 9 compute expansion currently computed approximation base intuitively pair processes belongs expansion iff move one component move component resulting pair processes generated current approximation b overcome two problems 1 set pairs generated b approximations infinite 2 set states reachable given bpa state one move infinite employ symbolic technique represent infinite sets similar one used 3 taking advantage fact simple reg ular structure encoded finitestate automata see theorem 6 12 allows compute expansion polynomial time relation k wellformed iff subset relation g defined const gamma theta const gamma const delta theta const gamma const gamma theta const gamma const gamma note size wellformed relation onm 2 g greatest wellformed relation one wellformed relations special importance definition 4 bisimulation base delta gamma denoted b defined follows weak bisimilarity left congruence wrt sequential composition generate b new pairs weakly bisimilar processes substitution worth noting weak bisimilarity right congruence wrt sequencingto see suffices define x z generation procedure defined wellformed relation follows definition 5 let k wellformed relation closure k denoted least relation satisfies following conditions contains unnormed constant fffi g fffih g 2 every fi 2 const delta h 2 const gamma note clk contains elements two forms ff g fff g consists pairs immediately derived clk rules 26 definition 5 although closure wellformed relation infinite structure sense regular fact precisely formulated following theorem theorem 6 let k wellformed relation g 2 const gamma finitestate automaton g size onm 2 constructible onm 2 proof construct regular grammar size onm 2 generates mentioned language let g const gammag fug const delta const gamma ffl ffi defined follows h 2 k add rule h f h 2 k add rules h f h 2 k add rules x h 2 k add rule h x x unnormed also add rule h xu x 2 const delta f 2 const gamma add rules u xu u x proof g g indeed generates mentioned language routine translate g g g see eg 19 note size g essentially size g g g nondeterministic contain rules follows immediately wellformed relation k membership problem clk decidable polynomial time another property clk specified lemma clk similarly fi f 2 proof give proof first claim second one similar let fff g 2 clk induction immediately apply rule 3 5 definition 5 remember ff ffl induction step let fff g 2 clk i1 three possibilities cf definition 5 r fff r 2 k induction hypothesis know fffih r 2 due rule 3 definition 5 ii r hypothesis flfih r 2 clk hence also flfih r 2 clk rule 5 definition 5 iii contains unnormed constant fl ffifih g 2 clk last rule definition 5 importance bisimulation base clarified following theorem says clb subsumes greatest weak bisimulation processes delta gamma theorem 8 ff f g ff g iff ff g 2 clb fff g iff proof part obvious cases b contains weakly bisimilar pairs rules definition 5 produce pairs weakly bisimilar part cases easily proved induction length ff show first proof second one similar g 2 b rule 6 definition 5 obtain fi g 2 clb normed fi w w 2 act g must able match sequence w fi g 0 substitution obtain g 0 g induction hypothesis hence due rule 4 definition 5 next definition formalizes one step refinement procedure applied g compute b intuition start g approximation b refinement step pairs deleted current approximation refinement step pairs deleted found b next definition specifies condition given pair deleted refinement step currently computed approximation b definition 9 let k wellformed relation say pair x g k expands k iff following two conditions hold ffl x ff g ffl g x ff ff expansion pair form f g f g g k defined wayfor move left component must move right component resulting pair processes belongs clk vice versa note set pairs k expand k denoted expk notion expansion sense compatible definition bisimulation intuition formalized following lemma k wellformed relation clk weak bisimulation proof prove every pair ff g fff g clk property move one component move component resulting pair processes belongs clk consider pairs form fff g case similar induction claim follows directly definitions ffl induction step let fff g 2 clk i1 three possibilities h fff let fff flf note ff empty case consider moves form f done similar way fff h 2 clk use induction hypothesis conclude h distinguish two cases h g 2 k obtain due lemma 7 hence g use move g g transition h see beginning section h g 2 k induction hypothesis know g due lemma 7 let g h g 2 k h clk distinguish two possibilities use move fff 6 h 6 h 0 h fff fff handled way flf h 0 hence also flf g 0 2 clk lemma 7 ii h h g 2 k fif let fif flfif h g 2 k use induction hypothesis conclude g fif obtain flfif let g h g 2 k induction hypothesis know h match move g two possibilities flh flh immediately flfif clk transition h h h h done immediately fi h g 0 fi needed 6 h 0 6 h transition h fif due induction hypothesis know fif fif handled way flf h 0 fif iii contains unnormed constant fi g 2 clk let ff ffi fi g 2 clk due induction hypothesis clearly contains unnormed constant hence ffifl last rule definition 5 let g fi g 2 clk fi ffi contains unnormed constant hence ff due last rule definition 5 notion expansion allows approximate b following way theorem 11 j 2 n bounded onm 2 proof exp viewed function complete lattice wellformed relations monotonic hence greatest fixedpoint exists must reached onm 2 steps size g onm 2 prove first let us realize immediately definition 4 definition 9 theorem 8 inclusion proved simple inductive argument clearly definition expansion fact expb j know clb j weak bisimulation due lemma 10 thus processes every pair b j weakly bisimilar words b obtained g onm 2 refinement steps correspond construction expansion thing remains shown expk effectively constructible polynomial time employ symbolic technique allows represent infinite subsets bpa statespace elegant succinct way theorem 12 x 2 const delta 2 act delta finitestate automaton xa size 2 constructible 2 time proof define leftlinear grammar g xa size 2 generates mentioned language grammar converted xa standard algorithm known automata theory see eg 19 note size xa essentially size g xa first let us realize compute 2 time sets consisting 2 const delta const deltag fsg intuitively index indicates whether action already emitted const delta ffl ffi defined follows add production x ffi x also add production delta every transition delta every 1 test whether z j case add ffi productions delta every transition delta every 1 following test whether z j case add ffi productions z test whether z every case add ffi productions fact g xa generates mentioned language intuitively clear formal proof easy size g xa 2 delta contains basic transitions length crucial part algorithm refinement step presented proof next theorem complexity analysis based following facts let nondeterministic automaton rules let total number states transitions ffl problem whether given w 2 sigma belongs la decidable ojwj delta time ffl problem whether decidable ot time theorem 13 let k wellformed relation relation expk effectively constructed proof first construct automata g theorem 6 every g 2 const gamma takes onm 3 time construct automata xa theorem 12 x takes 4 time furthermore also compute set pairs form f g g belong clk done om 2 time show pair k decide expands k pairs form f g g easy handle states f 0 f states g 0 g hence need check om 2 pairs verify first consequently also second condition definition 9 pair checked constant time set pairs f g g belong clk already computed beginning let us consider pair form g first need verify ff g h ff h 2 clk requires onm tests whether ff 2 length ff size h onm 2 test done 2 hence need total second condition definition 9 need find whether g h x ff simply test emptiness size product automaton 3 need perform om tests hence 3 suffices pairs form f g handled similar way first condition definition 9 problem interested moves left component let g existence good move f verified testing whether one following conditions holds ffl f f conditions checked 3 required analysis fact done k contains onm 2 pairs total time needed compute expk 4 5 bpa process e introduced beginning section element const delta compute b perform computation expansion onm 2 times see theorem 11 gives us following main theorem theorem 14 weak bisimilarity decidable bpa finitestate processes 5 4 terminationsensitive bisimilarity already mentioned previous section weak bisimilarity congruence wrt sequential composition major drawback equivalence considered behavioral prop erty propose solution problem designing natural refinement weak bisimilarity called terminationsensitive bisimilarity relation respects main features sequencing overlooked weak consequently congruence wrt sequential composition also show terminationsensitive bisimilarity decidable bpa finitestate processes polynomial time adapting method previous section noted right beginning aim design new fundamental notion theory sequential processes properties terminationsensitive bisimilarity studied detail want demonstrate method applicable larger class bisimulationlike equivalences relation termination sensitive bisimilarity provides hopefully convincing evidence might interesting useful opinion reasonable model sequential behaviors able express distinguish following basic phenomena sequencing ffl successful termination process currently executed system continue execute next process queue ffl unsuccessful termination executed process deadlock models severe error causes whole system get stuck ffl entering infinite internal loop cycling difference successful unsuccessful termination certainly significant need distinguish termination cycling also recognized practice major examples come eg theory operating systems bpa processes natural model recursive sequential behaviors successful termination modeled reaching also hidden syntactical tool model deadlocknote definition bpa systems x 2 const delta delta contain rule form x us call constants undefined state xfi models situation executed process reaches deadlockthere transition computational step xfi process stuck easy see safely assume delta contains one undefined constant ones simply renamed x denoted ffi convention 2 note ffi unnormed definition states form ffiff called deadlocked case finitestate systems distinguish successful unsuccessful termination similar way deadlock modeled distinguished undefined constant ffi undefined constants model successful termination note definition weak bisimilarity represents successful termination definitely want define promised relation terminationsensitive bisimilarity need clarify meant cycling intuitively situation process enters infinite internal loop words forever without possibility anything else terminate either successfully unsuccessfully definition 15 set initial actions process e denoted ie defined fg process e cycling iff every state f reachable e satisfies note easily decidable quadratic time whether given bpa process cycling case finitestate systems need linear time definition say expression e normal iff e cycling deadlocked successfully terminated binary relation r process expressions terminationsensitive bisimulation following conditions hold ffl one expressions e f cycling also cycling ffl one expressions e f deadlocked either normal also deadlocked ffl one expressions e f successfully terminated either normal also successfully terminated f ffl f e terminationsensitive bisimilar written e f iff terminationsensitive bisimulation relating terminationsensitive bisimilarity seems natural refinement weak bisimilarity better captures intuitive understanding sameness sequential processes distinguishes among phenomena mentioned beginning section still allows ignore internal computational steps large extent example deadlocked process still equivalent process deadlocked yet necessarily deadlocks finite number transitions example also explains first three conditions definition stated carefully family approximations defined way case weak bisimilarity difference 0 relates exactly processes satisfy first three conditions definition 16 following theorem follows immediately definition theorem 17 terminationsensitive bisimilarity congruence wrt sequential composition technique used previous section also works terminationsensitive bisimilarity theorem terminationsensitive bisimilarity decidable bpa finitestate processes 5 proof first assumptions delta gamma mentioned beginning section 3 also safe wrt terminationsensitive bisimilarity note would true also assumed existence loop f every f 2 const gamma see assumptions gamma formulated carefully thing modified notion wellformed relation defined way addition require processes every pair contained wellformed relation k related 0 easily shown processes pairs contained clk also related 0 words take care first two requirements definition 16 constructions anymore everything works without single change previous proof indicates method section 3 adapted bisimulationlike equivalences see final section comments 5 normed bpp processes section prove weak bisimilarity decidable polynomial time normed bpp finitestate processes basic structure proof similar one bpa key weak bisimulation problem decomposed problems single constants interaction particular normed bpp process finite wrt weak bisimilarity iff every single reachable process constant finite wrt weak bisimilarity hold general bpp thus construction carry general bpp example 19 consider unnormed bpp defined following rules process x 1 wrt bisimilarity every subprocess eg x 3 kx 4 kx 7 every single constant x infinite wrt bisimilarity even normed bpp solve additional problems bisimulation base closure simpler due normedness assumption symbolic representation bpp statespace problematic see set states reachable given bpp state one move longer regular sense represented cfgrammar algorithm use facts emptiness cf language decidable polynomial time cf languages closed intersection regular languages let e bpp process f finitestate process underlying systems delta gamma respectively assume wlog e 2 const delta elements const delta denoted x elements const gamma set parallel expressions const delta denoted const deltaomega elements greek letters ff size delta denoted n size gamma constructions represent certain subsets const deltaomega finite automata cf grammars problem elements const deltaomega considered modulo commutativity however finite automata cf grammars course distinguish different permutations word classes regular cf languages closed permutation problem important want clarify distinction ff possible linear representations define ff set linff follows permutation set f1 delta example linxky xg also assume linff contains unique element called canonical form linff important canonical form chosen need make constructions deterministic example fix linear order process constants let canonical form linff sorted order constants ff relation k wellformed iff subset const delta fg theta const gamma bisimulation base delta gamma denoted b defined follows definition 21 let k wellformed relation closure k denoted least relation satisfies family clk approximations defined way section 3 lemma 22 let ff f 2 clk proof let ff f 2 clk induction immediately apply rule 2 3 definition 21 ffl induction step let ff f 2 clk i1 two possibilities x r 2 k fl 2 clk rks f clearly rkskg h hence also skg induction hypothesis flkfi due second rule definition 21 note rkt h ii ff r 2 clk 2 k rks f rkskg h rkg induction hypothesis obtain ffkfi due third rule definition 21 closure bisimulation base greatest weak bisimulation processes delta gamma theorem 23 let ff 2 const const gamma ff f iff proof part obvious part proved induction lengthff delta normed xkfi f w v 2 act x process f must able match sequences w v entering weakly bisimilar statesthere const delta fi g x h consequently also f gkh need fact weak bisimilarity congruence wrt parallel operator clearly induction hypothesis hence xkfi f 2 definition 21 closure wellformed relation sense represented finitestate automaton stated next theorem construction first need compute set ffkg hg consider parallel composition finitestate system ie states system form fkg let new system union system old system new system size om 2 states form fkg h apply usual cubictime partition refinement algorithm decide bisimilarity new system see section 2 gives us set theorem 24 let k wellformed relation g 2 const gamma finitestate automaton g size onm constructible onm time following conditions hold ffl whenever g accepts element linff ff g 2 clk accepts least one element linff proof design regular grammar size onm lg g mentioned properties let g const gamma fsg const delta ffl ffi defined follows x f 2 k add rule xf f 2 k add rule f delta f const gamma x 2 const delta x r 2 k f rks add rule xf delta f const gamma r 2 k f rks add rule delta add rule g first claim follows observation whenever ff 2 linff fff sentence g g ff f 2 clk easily proved induction length derivation fff second part suffices prove ff f 2 clk ff 2 linff fff sentence g g done straightforward induction important realize ff g 2 necessarily accept elements linff example const const gamma g accepts string xy z string xzy generally g cannot repaired see beginning section however actually need repairs g following nice property lemma 25 let k wellformed relation b k ff g automaton g proof theorem 24 constructed k accepts elements linff proof let g g grammar previous proof first prove const gamma const deltaomega fl r skr f derivation flf g g every fl 2 linfl induction lengthfl pair r belongs b hence f definition g g form xkfi fi 2 linfi xkfi r delta normed u v 2 const gamma x u fi v ukv r hence also skukv f thus const gamma x u pair x u belongs b definition g g fi v vkt f use induction hypothesis conclude fif hence xfif required let ff g delta normed r 2 const gamma r hence definition g g clearly rkg g due proved property r ffg every ff 2 linff rule g g obtain set states reachable given x 2 const delta one move longer regular sense represented cf grammar theorem 26 x 2 const delta 2 act delta contextfree grammar g xa 3gnf greibach normal form ie 2 variables right hand side every production size 4 constructible 4 time following two conditions hold ffl g xa generates element linff x xa generates least one element linff proof let g const delta ffl ffi defined follows delta rule x added ffi transition delta add rule add rule transition delta add rule also add rule 2 const delta add rule fact g xa satisfies mentioned conditions follows directly construction note size g xa 2 moment transform g xa 3gnf standard procedure automata theory see 19 done 4 time size resulting grammar 4 notion expansion defined different way compared one previous section definition 27 let k wellformed relation say pair x f 2 k expands k iff following two conditions hold ffl x ff f ff 2 la g ff canonical form linff ffl f g language pair f 2 k expands k iff f implies f 2 la g set pairs k expand k denoted expk theorem 28 let k wellformed relation set expk computed 11 8 time proof first compute automata g theorem 24 g 2 const gamma takes onm 2 time compute grammars g xa theorem 26 x 2 const delta 2 act takes 6 time show decidable f k expands k first condition definition 27 checked 3 time transitions x states g f g pair ff g verify whether ff 2 canonical form linff membership test done 2 time size ff size g onm second condition definition 27 expensive test emptiness first construct pushdown automaton p recognizes language p om control states total size 5 furthermore rule px qff p property lengthff 2 g xa 3gnf transform automaton equivalent cf grammar wellknown procedure described eg 19 size resulting grammar 5 3 emptiness thus checked construction performed om times hence need pairs form f handled similar less expensive way k contains onm pairs computation expk takes previous theorem actually straightforward consequence definition 27 next theorem says exp really need theorem 29 let k wellformed relation clk weak bisimulation proof let ff f 2 clk prove ff fi f fi g 2 clk vice versa induction distinguish following two possibilities let x fi definition 27 f fi 2 fi 2 linfi hence fi g 2 clk due first part theorem 24 let f g definition 27 string w 2 let w 2 linfi x due first part theorem 26 due theorem 24 let f g hence g 2 clk due theorem 24 ffl induction step let ff f 2 clk i1 two possibilities x r 2 k fl 2 clk rks f let xkff fi action emitted either x ff distinguish two cases ffikfl x r 2 k x ffi r ffi r 0 rks f r f r 0 ks g sum ffi r 0 ks g hence ffikfl g 2 clk due lemma 22 xkae fl 2 clk fl ae ae 0 rks f f rks g due lemma 22 obtain xkae g 2 clk let f g rks f r x r 0 ks 0 g x r 2 k fl 2 clk x x ae ffi r 0 ffikae g 2 clk due lemma 22 ii ff r 2 clk 2 k rks f proof completed along lines approximate compute bisimulation base way section 3 theorem j 2 n bounded onm proof suffices show const delta ff show x f expands b proof pair f similar let x fi x f f fi g let fi canonical form linfi due lemma 25 let f g x f x g due theorem 26 fi 2 linfi fi 2 lg xa moreover fi 2 due lemma 25 hence follows directly theorem 29 theorem 31 weak bisimilarity normed bpp finitestate processes decidable 12 9 time proof theorem 30 computation expansion theorem 28 costs 11 8 time done onm times 6 conclusions proved weak bisimilarity decidable bpa processes finitestate processes 5 7 time normed bpp finitestate processes 12 9 time may possible improve algorithm reusing previously computed information example sets reachable states exponents would still high whole bisimulation basis constructed get efficient algorithm one could try avoid note however constructed b bpanbpp system delta finitestate system gamma automaton g theorem 6theorem 24 const gamma decide weak bisimilarity bpanbpp process ff delta process const gamma time ojffjit suffices test whether f accepts ff observe substantial difference f g except initial state technique bisimulation bases also used strong bisimilarity 1718 however bases different design way generate new bisimilar pairs processes rely additional algebraic properties strong bisimilarity full congruence wrt sequencing allows unique decompositions normed processes wrt sequencing parallelism etc main difficulty proofs show membership closure defined bases decidable polynomial time main point proofs use symbolic representation infinite subsets bpa bpp statespace would also like mention proofs easily adapted bisimulationlike equivalences notion bisimulationlike equivalence one 21 concrete example terminationsensitive bisimilarity section 4 intuitively almost every bisimulationlike equivalence algebraic properties needed construction bisimulation base symbolic technique statespace representation also adapted see 21 details r decidability bisimulation equivalence processes generating contextfree languages process algebra reachability analysis pushdown automata application model checking elementary decision procedure arbitrary contextfree processes infinite results graphes canoniques des graphes algebriques decidability decomposition process algebras bisimulation decidable basic parallel processes bisimulation equivalence decidable contextfree processes petri nets decidability model checking infinitestate concurrent systems automatatheoretic approach interprocedural dataflow analysis short proof decidability bisimulation normed bpa processes bisimulation trees decidability weak bisimulations bisimulation equivalence decidable normed process algebra polynomial algorithm deciding bisimilarity normed contextfree processes polynomial algorithm deciding bisimulation equivalence normed basic parallel processes introduction automata theory actions speak louder words proving bisimilarity contextfree processes deciding bisimulationlike equivalences finitestate processes effective decomposability sequential behaviours efficient verification algorithms onecounter processes simulationchecking sequential systems simulation preorder simple process algebras weak bisimulation model checking basic parallel processes strict lower bounds model checking bpa complexity bisimulation problems basic parallel processes complexity bisimulation problems pushdown automata decidability model checking temporal logic ef process rewrite systems infinite results three partition refinement algorithms concurrency automata infinite sequences petri net theory modelling systems complexity weak bisimilarity regularity bpa bpp hardness results weak bisimilarity simple process algebras model checking ctl properties pushdown systems tr three partition refinement algorithms communication concurrency process algebra short proof decidability bisimulation normed bpaprocesses decidability bisimulation equivalence process generating contextfree languages bisimulation equivalence decidable contextfree processes polynomial algorithm deciding bisimilarity normed contextfree processes process rewrite systems effective decomposability sequential behaviours decidability model checking temporal logic ef petri net theory modeling systems introduction automata theory languages computation elementary bisimulation decision procedure arbitrary contextfree processes simulation preorder simple process algebras bisimulation equivanlence decidable normed process algebra efficient verification algorithms onecounter processes deciding bisimulationlike equivalences finitestate processes reachability analysis pushdown automata bisimulation equivalence decidable basic parallel processes infinite results automatatheoretic approach interprocedural dataflow analysis weak bisimulation model checking basic parallel processes model checking ctl properties pushdown systems concurrency automata infinite sequences complexity bisimulation problems pushdown automata petri nets commutative contextfree grammars basic parallel processes simulationchecking sequential systems complexity bisimulation problems basic parallel processes ctr richard mayr weak bisimilarity regularity contextfree processes exptimehard theoretical computer science v330 n3 p553575 9 february 2005 antonn kuera richard mayr simulation preorder simple process algebras information computation v173 n2 p184198 march 15 2002 antonn kuera complexity bisimilaritychecking onecounter processes theoretical computer science v304 n13 p157183 28 july antonn kuera petr janar equivalencechecking infinitestate systems techniques results theory practice logic programming v6 n3 p227264 may 2006
asynchronous group key exchange failures group key exchange protocols allow group servers communicating asynchronous network pointtopoint links establish common key adversary fully controls network links group members cannot learn key currently known group key exchange protocols rely assumption group members participate protocol single server crashes server may terminate protocol paper propose first purely asynchronous group key exchange protocol tolerates minority servers crash solution uses constant number rounds makes suitable use practice furthermore also investigate provide forward secrecy respect adversary may break servers observe internal state show group key exchange protocol among n servers tolerates tc 0 servers crash provide forward secrecy adversary breaks less n 2tc servers propose group key exchange protocol achieves bound b introduction group key exchange gke protocols allow group servers communicating complete network pointto point links establish common session key anyone outside group observe network traffic permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copies bear notice full citation first page copy otherwise republish post servers redistribute lists requires prior specific permission andor fee july 2528 2004 st johns newfoundland canada cannot learn key session key later used achieve cryptographic goals like example multicast message confidentiality multicast data integrity hence gke protocols essential applications secure video teleconferencing collaborative applications model environments like internet one assumes asynchronous network scheduling messages determined adversary servers access common clock main goals gke protocol ensure secrecy session key ensure every member group eventually terminates protocol computes session key far gke protocols designed meet goals long members group follow protocol specification 8 26 3 7 solutions drawback single server crashes member group terminate protocol makes protocols specifically vulnerable denial service attacks execution time protocol determined slowest member group one way solve problem explored amir et al 2 base gke viewbased group communication system gcs provides abstraction currently live nodes servers consistent way chockler et al 15 provide survey gcs since gcs detect crashes among servers also execution gke proto col protocol react accordingly gcss rely timeouts detect crashed participants approach leads solutions purely asynchronous subject timing attacks however paper propose first gke protocol purely asynchronous model terminates every member long least majority participants remain optimal model solution conceptually simple efficient makes suitable practice particu lar consists following two stages first stage group members exchange keying information using two communication rounds total 2 messages n denotes size group second stage execute consensus protocol select contributions first stage session key computed protocol may use randomized asynchronous consensus fully asynchronous model consensus protocol asynchronous model augmented failure detector 14 latter case approach yields modular solution gke model gcsbased protocol mentioned comparing efficiency construction efficient solution gke without failures 8 shows price pay tolerating failures lies consensus protocol executed second stage also show communication complexity construction nearly op timal particular show given optimal solution consensus construction yields solution gke uses 2 messages o1 communication rounds average optimal solution gke failures following approach steiner 27 analyze security protocol framework asynchronous reactive systems proposed pfitzmann waidner 23 particular first specify target behavior gke protocol terms idealized service show protocol inputoutput behavior idealized service approach benefit guaranteeing com posability ie security application relying ideal service gke remains real protocol used implement ideal service first prove security construction socalled corruption model failures adversary may schedule observe network crash servers break server observe internal state show model protocol tolerates tc n2 servers crash optimal setting investigate provide forward secrecy strong corruption model adversary additionally allowed break servers observe internal state breakins compromise security session keys generated attack keys generated previously afterwards first show gke protocol tolerates tc 0 servers crash tolerate strictly less n 2tc breakins show build gke protocol optimal resilience construction also practical uses one execution consensus protocol additionally 2 messages three rounds related work one classify previous work gke along two dimensions assumptions made communication links framework used proving security along first dimension one distinguish gke protocols assume authentic network 19 8 26 24 27 gke protocols rely apriori distributed public private keys example provided publickey recent paper katz yung 21 closes bridge two approaches showing gke protocol built authentic network compiled gke protocol insecure network apriori distributed public private keys compilation adds one additional communication round 2 messages respect framework used proving security one identify two approaches one approach taken bresson et al 7 katz yung 21 extend framework modeling twoparty key exchange proposed bellare et al 5 nparty case another approach taken steiner 27 work use general framework modeling asynchronous reactive systems one pfitzmann waidner 23 one canetti 12 define prove security therein advantage using framework security preserved modular composition abovementioned works 3 26 24 7 also address dynamic case gke servers may join leave group session key must updated whenever occurs recently amir et al 1 showed dynamic join leave protocols steiner et al 26 integrated viewbased gcs maintain common group key later used encrypt communication among group group key updated whenever underlying gcs detects change group structure accomplished outlined 2 ie running corresponding dynamic gke protocol whenever servers join leave case gcs detects nested leaves ie detects leaving servers execution dynamic gke protocol protocol aborted basic gke protocol run scratch among remaining servers establishing key case nested leaves also seen crashtolerant gke note tc servers crash one one approach leads tc sequential executions basic gke protocol basic gke protocol steiner et al 26 used results otcn messages otcn rounds furthermore gcss rely timeouts detect crashes approach purely asynchronous subject timing attacks organization next section introduce system model give formal definitions gke consen sus section 3 present construction gke failures weak corruption model elaborate op timality section 4 first introduce strong corruption model adjust definition gke model prove upper bound number breakins one tolerate gke failures strong corruption model finally show build gke protocol optimal resilience 2 preliminaries 21 framework computational model parameterized security parameter k function k called negligible c 0 exists k0 k 1 k c k k0 two ensembles fvar k gk 2 n fvar 0 k gk2n random variables probability distributions called computationally indistinguishable every algorithm distinguisher runs probabilistic polynomialtime first input following quantity negligible throughout paper abbreviate saying var k var k 0 indistinguishable write var k var k 0 study protocols framework universally composable asynchronous reactive systems pfitzmann waidner 23 sketch simplified version model overview model protocol collection n probabilistic polynomialtime turing machines n called servers communicate authentic network net modeled ppt itm call collection fnet n g real system protocol network net denote sys real n model protocolspecific input output server terms messages occur input output connections respectively call set inputoutput connections servers interface 1 sys real n 1 readers familiar 23 interface corresponds specified ports model execution protocol network net run real system sys real augmented two ppt itms user h adversary real call collection fsys real real g real configuration user h represents higherlevel application builds top servers may interact servers interface subset thereof may also communicate real arbitrary points protocol real may attack servers schedule network model attacks server terms special messages may occur designated input connection cor also part interface consider weak corruption model available attack adversary crash server happens server halts ie participate protocol anymore section 4 discuss strong corruption model also breakins allowed describe security properties terms service f corresponding real system sys real guarantee interface formally define service f terms ideal system sys idealf n ideal system interface real system comprises single ppt itm called trusted host th f n serves interface also runs configuration user h adversary ideal modeled ppt itm ideal may communicate th f n arbitrary points protocol allows model nondeterminism ideal service f may controlled adversary security protocol defined requiring whatever happen arbitrary user h real system sys real could also happen user ideal system sys idealf cannot distinguish ideal configuration real one case say sys real n secure sys idealf n standard argument prove notion security constructive one specifically one shows construct user h adversary real ideal adversary ideal h cannot distinguish corresponding real configuration ideal configuration framework also allows modular composition protocols describing protocol runs top ideal service g model hybrid system sys hybrid g consisting real system sys real ideal subsystem sys idealg n hybrid system servers access sys idealg n user sys tem important property framework real system sys real n secure sys idealg real system sys real n servers access sys real instead sys idealg n secure sys hybrid g add details elaborate treatment framework refer 23 ideal real configurations abstract level real ideal configuration seen set ppt itm called machines connected communication tapes 18 may interact every communication tape exactly one machine write tape another machine read tape also call communication tape connection figure 1 shows example configuration real ideal system protocol service f respectively shows connections denoted arrows interface connections cross dashed lines configurations executing configuration execution configuration called run defined follows 2 beginning run every machine initialized security parameter k run proceeds steps first step designated machine called master scheduler activated configurations paper master scheduler adversary every step currently active machine may read communication input tapes perform computation possi bly involving random choices write message one communication output tapes either halts terminates activation either case machine read tape written activated proceeds next step machine halted message written tape master scheduler activated instead process continues master scheduler halts network network net provides authentic communication among servers scheduling determined adversary connects every server connections net net connects adversary real connections adv net adv net works follows server send message sending message connection net net happens net stores j collection sends tuple j connection adv net ad versary similarly real schedule message delivered j sending connection adv net happens outputs receives say adversary delivers messages among end run collection contain tuples message interface interface real ideal system comprises connections cor n first two connections used invoke provided systems receive servicespecific output systems respectively connections cor used model attacks adversary server connections part interface attacks servers affect service system provides describe weak corruption model adversary may crash server modeled message crash sent connection cor see section 4 strong corruption model also breakins allowed happens real configuration outputs crash cor halts happens ideal configuration th f outputs crash adv th connections trusted host th n also connects ideal connections adv th adv th connections used model nondeterminism 2 model execution described general model described original work 23 sufficient purpose real netin net sys real corin corin corout netin netout netout corout ideal th th sys n corin corin figure 1 configurations real ideal systems protocol service f respectively ideal service f may controlled ad versary furthermore every server connects real connections cor connections used model effects attack eg section 4 use connections revealing server internal data adversary result breakin ready state definition real system sys real n secure ideal system sys idealf n purpose let v real nha real denote probability distribution view h internal state h messages h sees run sys real n security parameter k configured h real let v idealf nha ideal k defined analogously say sys real n secure sys idealf users h real adversaries real exists ideal adversary ideal distribution ensembles nha real kgk2nand fv idealf nha ideal kgk2n computationally indistinguishable composition framework allows describe protocols modular way ie protocol may build subprotocol composition modeled real system sys real comprising two systems sys real n sys real servers sys real access subsystem sys real n user system ensure attack server also affects subsystem assume connection cor server linked connection cor server outputs crash cor receives crash cor subsystem may also ideal system case call entire system hybrid following composition theorem important property framework 23 theorem 1 composition theorem 23 hybrid system sys hybrid g n consisting real system sys real n subsystem sys idealg n secure ideal system sys idealf n real system sys real n secure ideal system sys idealg real system sys real n consisting sys real n subsystem sys real n least secure ideal system sys idealf n complexity measures measure complexity protocol terms expected message complexity expected round complexity r first measure represents bandwidth required protocol defined follows let ha real denote upper bound expected number messages servers send across network run sys real configured h real expectation taken random choices servers maximum ha real users h adversaries real round complexity measures running time pro tocol define assign round numbers messages sent servers across network follows note server sends message across network response input user response message 0 network first case assign round number 0 second case assign round number r 1 r round number 0 let r ha real denote upper bound expected highest round number assigned message run sys real configured h real expectation taken random choices servers r maximum r ha real users h adversaries real 22 ideal system group key ex change ideal system sys idealgke n group key exchange models n servers repeatedly establish session key particular say server starts session tag id input start id occurs id arbitrary bit string represents unique identifier session similarly say server finishes session tag id output nish id key occurs trusted host th gke n models traditional security properties one expects gke protocol particular guarantees session key every session id generated independently random property sometimes also called freshness furthermore guarantees mutual key authentication means every server computes key session id definition 2 captures ideas formally yet address forward secrecy becomes issue adversary break server learn internal state discuss model section 4 definition 2 ideal system sys idealgke n group key exchange consists trusted host th gke given following transition rules init system initialization sets f start server starts session tag id trusted host adds id set outputs message id adversary adversary inputs nish id id 2 first adds id set f next random f0 1g k finally outputs deliver id id recall goal build gke protocol secure also guarantees terminate every server even tc servers crash captured following definition tc resilient group key exchange protocol definition 3 call protocol tc resilient group key exchange protocol sys real n secure sys idealgke n every run configuration sys real n tc servers crash following holds noncrashed servers start session id finish session id provided adversary delivers messages among noncrashed servers 23 ideal system consensus consensus protocol every server receives input bit string length lk produces output bit string length lk goal servers output bit string bit string corresponds input least one server give ideal system consensus serve building block construction gke pro tocol models n servers repeatedly concurrently agree bit strings length lk every consensus instance identified tag id model server starts consensus instance tag id input v message propose id v occurs happens also say server proposes v id similarly model server terminates consensus tag id value v 0 message decide id v 0 occurs case say server definition 4 ideal system sys idealcons n consensus consists trusted host th cons given following transition rules init system initialization th cons sets id id propose server proposes v id th cons n adds tuple set p id outputs proposeid v adversary decide th cons receives decide idiv ad versary verifies consulting p id id server proposed value id least one server proposed v id server decided another value id checks succeed sets id v outputs decide id v user need consensus protocol secure also guarantees terminate every server even servers crash following definition captures formally definition 5 call protocol tc resilient consensus pro tocol sys real n secure sys idealcons n every run configuration sys real n tc servers crash following holds noncrashed servers propose value id decide value id provided adversary delivers messages among noncrashed servers bestknown randomized asynchronous tc resilient consensus protocol derived protocol canetti rabin 13 actually solves harder problem byzantine agreement servers may crash behave arbitrarily unconditionally secure consensus protocol derived described 4 section 1432 uses expected number 3 mes sages proceeds expected o1 rounds resilience assuming trusted dealer initializes system working realistic model computationally bounded adversary exist cryptographic protocols due cachin et al 10 9 nielsen 22 use 2 messages o1 rounds average optimal resilience mentioned introduction also possible implement consensus failuredetector model 14 efficient protocols exist failure detector local module available every server periodically outputs list servers suspects crashed usually based timing assumption pursue focus fully asynchronous model note certain practical settings protocols might actually efficient fully asynchronous protocols mentioned 3 implementation 31 describe protocol gke builds subsystem consensus semantically secure encryption scheme 17 k elements f0 1g k keygeneration algorithm k encryption algorithm e decryption algorithm following computations done f 2 k indicated otherwise server starts session tag id first chooses contribution randomly f0 1g k goal compute session key set g n tc servers runs k generate pair public keyprivate every server server receives public key p j another server j sends contribution value encrypted server j received contribution values servers like computes differences d1 yu 1 proposes sequences consensus subsystem cs arbitrary constant string note difference pair contribution values may leaked adversary since information contribution values remain secret server decides two sequences hu un c h consensus instance idjcs computes session key follows first chooses arbitrary received um notice exists received least n tc values j point holds tc n2 computes session key um detailed protocol given algorithm 1 algorithm description make convention l l n c u l u l n c n tc l 2n easy see every server terminates also easy verify every server computes session key regardless chooses finally since upon initialization upon input start id choose uniformly random f0 1g k send enc every server upon receiving enc send key part id z ij server j z ij ep j upon receiving key part id z ji server j propose upon deciding idjcs choose um sk um output algorithm 1 protocol server implementing gke crashes contribution values remain secret argued holds session key technique faulttolerant abstraction gke protocol burmester desmedt 8 protocol publickey encryption scheme instantiated elgamal scheme servers choose way jointly compute values g generator multiplicative group prime order q session key derived values one contribution value j prove following theorem next section theorem 2 tc resilient consensus protocol real system sys real n consisting sys real n subsystem sys real n tc resilient group key exchange protocol improvements repeatedly generating session keys faster way running protocol every session idea use family pseudorandom functions 16 function maps bit strings used session tags id bit strings length k pseudorandom function families property one cannot distinguish id value randomly chosen knowing index allows servers repeatedly generate session keys running protocol get secret index session key session tag id simply computed sid remark construction secure weak corruption model adversary cannot break server learn index 32 security analysis establish theorem 2 prove security protocol show tc resilient consensus protocol sys real n secure ideal system sys idealgke sys real n live ie servers u crash run sys real start session id servers u finish session id provided tc servers crash messages among noncrashed servers delivered show liveness sys real n argue follows assumption tc servers crash follows every server u receives n tc contribution values j proposes values id jcs assumption resilient consensus protocol every server therefore also decides sequences hu idjcs construction every server knows step different values fy j g tc n2 follows every server exists least one index knows contribution value um hence servers u able compute key finish session id show security sys real n consider hybrid system sys hybrid cons n consisting real system sys real n ideal subsystem sys idealcons n consensus note suffices show sys hybrid cons n secure sys idealgke since security sys real follows composition theorem assumption secure consensus protocol show sys hybrid cons n secure sys idealgke using constructive argument particular provide every user h every adversary hybrid hybrid system sys hybrid cons n construction adversary ideal ideal system views h run ideal hybrid system configured h ideal hybrid respectively computationally indistinguishable recall view h run hybrid system also comprises messages exchanges hybrid order ensure messages distribution messages h exchanges ideal run ideal system construct ideal using technique called blackbox simulation specifically assume given hybrid adversary hybrid blackbox construct ideal simulator sim given blackbox hybrid idea simulator feeds black box hybrid simulated view run hybrid system sim must compute view based information receives th gke simulated view indistinguishable hybrid adversary would see corresponding hybrid run use outputs blackbox hybrid simulate messages exchanged h construction illustrated figure wlog show build ideal configuration h interacts ideal system th th ideal hybrid th cons th cons th corin corin gke corout corout net nn figure 2 construction ideal black box access hybrid simulator usual blackbox simulations construct simulator sim combination simulated user h simulated hybrid system sys hybrid cons n h interacts th gke n adv th adv th simulated hybrid system sys hybrid cons entire interface sys hybrid cons interacts hybrid connections adv net adv net adv th cons adv th cons cor j h provides inputs sys hybrid cons n h provides th gke moreover schedules th gke n whenever server cons outputs session also outputs session key id precisely h works follows upon receiving started id th gke send start id cons upon receiving deliver id k cons send nish id th gke upon receiving crash th gke send crash cons comparing views show every h hybrid view h run hybrid system sys hybrid cons configured h hybrid indistinguishable view h run ideal system sys idealgke configured adversary ideal suffices show joint view h hybrid hybrid ideal run respectively indistinguishable note construction ideal joint view welldefined ideal run argue inductively steps runs base case ie indistinguishability initial states follows construction remains show joint view h hybrid hybrid run step l 0 indistinguishable view ideal run step l induction hypoth esis holds step l inductive step first note joint view h hybrid changes one either sends message receives message first case inductive step follows directly induction hypothesis second case argue follows protocol specification messages received h hybrid different sessions statistically independent hence suffices show probability distributions received messages associated single session ideal hybrid run respectively indis tinguishable first investigate distribution ideal run let denote values computed cons run values contained messages received h hybrid including run subset un c ig subset linear combination values y1 y2 y2 denote values random variable v ideal k notice may ignore index vectors proposed servers determined scheduling hybrid thus identically distributed ideal hybrid run distribution v ideal k follows r ideal hybrid run h hybrid receive messages different distribution particular session key drawn random f0 1g k sum specifically distribution v hybrid k received messages hybrid run follows r u l let uk denote uniform distribution f0 1g k show v ideal k sufficient show ideal k one compute values following holds mod un c 2 values computed follows let denote value mod n1 v ideal k let un c 1 u1 furthermore value u note every value computed follows one compute u 1 sk remaining values computed follows easy verify computed values 2 furthermore 3 holds uniformly distributed f0 1g k finally 4 holds semantic security encryption scheme used 33 efficiency analysis analyze expected message round complexities construction generating single session key first paragraph give complexities two concrete instantiations consensus protocols found literature second paragraph show construction almost optimal sense given optimal consensus protocol construction yields almost optimal gke protocol concrete efficiency let denote gke protocol subprotocol consensus recall r denote expected round message complexities respec tively protocol cf section 21 easy see best known solution terms round complexity gke without failures 8 proceeds two rounds uses 2nn 2 mes sages hence price pay tolerating crashes essentially single consensus execution give asymptotic complexities known protocols consensus specifically consider consensus protocol cr93 canetti rabin 13 consensus protocol cks00 cachin et al 10 simplified according remark section 23 r resilience dealer optimality construction investigate optimality protocol terms round message complexities particular let opt denote optimal protocol gke let opt denote optimal protocol consensus optimal either round complexity message complexity respectively depending context let opt denote gke protocol subprotocol opt con sensus want know close efficiency opt efficiency opt show r opt opt argue follows construction protocol r opt substituting 5 6 gives hence suffices show optimal consensus protocol opt uses 6 rounds 6n 2 messages average optimal solution opt gke show constructive argument specifically show build given gke protocol 0 consensus protocol 0 uses average 6 communication rounds 6n 2 messages single execution 0 assumption opt roundoptimal follows r opt assumption opt messageoptimal follows opt holds gke protocol 0 also holds opt implies 7 8 derive protocol 0 protocol coin pro posed cachin et al 10 based protocol coin common coin common coin protocol provides every server random bit unpredictable ad versary consensus protocol coin invokes coin twice average proceeds expected 62 rcoin rounds expected message complexity 6n main idea behind protocol 0 modify coin follows beginning servers execute gke protocol get secret key sk follow original protocol coin except instead invoking coin get ith random bit c use ith bit sk k random bits used servers also use sk seed pseudorandom generator derive random bits remains show coin tc resilient consensus protocol holds result follow composition theorem show common coins derived 0 unpredictable adversary holds common coins derived coin follows directly definition th gke n guarantees adversary cannot predict single bit session key even seeing bits key 4 thestrongcorruptionmodel section investigate gke presence stronger adversary may also break servers observe internal state first formally describe attacks desired security requirements gke model prove upper bound number breakins gke protocol tolerate describe implementation protocol optimal resilience 41 modeling breakins forward secure model breakin message break sent connection cor represents arbitrary bit string real system sys real n protocol server receives message computes variable state sends done state cor real happens also say adversary breaks variable state comprises internal data explicitly erased including string received break mes sage ensures protocol built subprotocol adversary learns internal state receives system model cor every message break state outputs cor hence outputs internal state adversary desired security requirement gke protocol model called forward secrecy means breaking server reveals session keys currently computed server nothing previously computed session keys define threshold version forward secrecy ie require gke protocol forwardsecure long adversary break different servers formally capture notion security terms ideal system sys idealfs gke containing trusted host th fs gke b trusted host works exactly th gke cf definition 2 except maintaining additional set b containing indices brokeninto servers initialized following additional transition rule breakin adversary breaks server th fs gke adds set b chooses every id 2 si id random f0 1g k key defined yet computes set k keys revealed follows finally outputs keys k adversary note adversary adaptive sense may break server point run beginning computation definition secure gke protocol model follows definition 6 call protocol tc b resilient group key exchange protocol sys real n secure sys idealfs gke every run configuration sys real n tc servers crash following holds noncrashed servers start session id finish id provided adversary delivers messages among noncrashed servers 42 upper bound number breakins given gke protocol tolerates tc servers crash investigate many breakins one prove protocol secure th fs gke proving protocol secure ideal service f one show construct every user h every adversary real sys real n adversary ideal sys idealf n h cannot distinguish corresponding ideal configuration real one difficulty constructing ideal ensure communicates h way real cur rently known way done constructing ideal using technique blackbox simulation section 32 argue tc 0 protocol proven tc b resilient gke protocol using blackbox simulation words show n 2tc upper bound number breakins one tolerate building forwardsecure gke see assume toward contradiction exists resilient gke protocol show build particular user h real adversary real ideal adversary ideal based blackbox access real following holds joint view h real run real configuration efficiently distinguishable joint view h real run ideal configuration contradicts initial assumption tc b resilient gke protocol construct real user invokes single session id follows adversary real runs two stages first stage chooses arbitrary set n tc servers runs protocol arbitrary way ensuring messages sent among servers delivered message delivered either sent sent server server crashed broken every server finished session id first stage ends second stage real crashes tc arbitrary servers breaks remaining n 2tc servers continues run protocol arbitrary way ensuring server crashed broken messages sent among noncrashed servers delivered every noncrashed server finished session id second stage ends adversary halts notice assumption tc b resilient gke protocol stages terminate moreover every server finishes session id outputs key let sk denote key let state j denote internal state server j end stage one let denote set messages sent yet delivered servers first stage fact servers interact first stage server implies session key sk efficiently computable states fstate j g servers otherwise server could compute sk output key second stage suppose want build adversary ideal ie want build simulator provides blackbox adversary real simulated information seen real run based information received th fs gke definition th fs gke nt b real simulator receive information session key sk 0 trusted host outputs user hence information simulator feeds real comprising fstate j g statistically independent sk 0 therefore defines key sk real run key sk defined information always equal key sk 0 user ceives conclude joint views h real run ideal real configuration respectively efficiently distinguishable 43 implementation optimal silience describe tc b resilient gke protocol fs derived first explain forwardsecure describe necessary modifications derive fs protocol server continues participate protocol outputting session key sk specifically still responds arriving enc key messages sending back encrypted contribution necessary ensure every noncrashed server eventually computes session key result adversary breaks server server output sk access servers contribution may compute key sk contradicts forward secrecy requires adversary must learn information sk breaking b servers output key sk ensure forward secrecy server could simply erase local data outputting key however resulting protocol would live anymore slowest servers might never receive enough contributions servers compute key ensure forward secrecy without compromising liveness extend follows addition computing session key sk every server also computes share sk set b shares reveal information sk whereas set b shares allows efficiently compute sk server computed share session key outputs key erases local data except share ensures forward secrecy continues send share every server requests ensures every server eventually receives enough information compute session key hence ensures liveness compute shares sk use polynomial secret sharing proposed shamir 25 shares secret sk computed first choosing random polynomial f degree b computing every share technique requires every server derives share session key sk using polynomial f ensured generating parallel defining polynomial session key sk defined generating parallel done modifying protocol server choose single contribution value contribution vector using vector instead throughout protocol op erations additions encryptions simply applied componentwise result servers compute desired form vector sk 2 f0 1g k could also used single session key sk conjunction pseudorandom function f g i2f01g k derive coefficients polynomial sk sk 2 could proven secure adaptive adversary reason one adjust server sends contribution another server j noncommitting way 11 done follows server j receives server public key p chooses random vector r ij encrypts componentwise p get ij sends c ij server upon receiving c ij server derives server j upon receiving message server j computes modifying protocol outlined yields desired forwardsecure protocol fs uses one execution consensus protocol additionally 3n 2 messages 3 communication rounds security proof protocol fs derived modifying proof protocol accordingly 5 r secure group communication using robust contributory key agreement exploring robustness group key agreement new multiparty authentication services key agreement protocols distributed computing fundamentals authenticated key exchange secure dictionary attacks key agreement conference key agreement provably authenticated group diffiehellman key exchange secure efficient conference key distribution system secure efficient asynchronous broadcast protocols extended abstract random oracles constantinople practical asynchronous byzantine agreement using cryptography adaptively secure computation universally composable security new paradigm cryptographic protocols fast asynchronous byzantine agreement optimal resilience unreliable failure detectors reliable distributed systems group communication specifications comprehensive study construct random functions probabilistic encryption knowledge complexity interactive proofsystems conference key distribution system authenticated multiparty key agreement scalable protocols authenticated group key exchange threshold pseudorandom function construction applicatoins model asynchronous reactive systems application secure message transmission study group rekeying share secret key agrement dynamic peer groups secure group key agreement practical secure faulttolerant conference key agreement protocol tr construct random functions knowledge complexity interactive proof systems fast asynchronous byzantine agreement optimal resilience adaptively secure multiparty computation random oracles constantipole key agreement dynamic peer groups share secret distributed computing provably authenticated group diffiehellman key exchange group communication specifications key agreement conference key agreement secure efficient asynchronous broadcast protocols threshold pseudorandom function construction applications authenticated multiparty key agreement practical securefaulttolerant conferenckey agreement protocol study group rekeying universally composable security exploring robustness group key agreement model asynchronous reactive systems application secure message transmission secure group communication using robust contributory key agreement ctr jonathan katz ji sun shin modeling insider attacks group keyexchange protocols proceedings 12th acm conference computer communications security november 0711 2005 alexandria va usa emmanuel bresson olivier chevassut david pointcheval provably secure authenticated group diffiehellman key exchange acm transactions information system security tissec v10 n3 p10es july 2007
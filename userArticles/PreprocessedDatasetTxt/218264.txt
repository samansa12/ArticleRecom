genetic algorithms operators dna fragment assembly study different genetic algorithm operators one permutation problem associated human genome projectthe assembly dna sequence fragments parent clone whose sequence unknown consensus sequence corresponding parent sequence sortedorder representation require specialized operators compared traditional permutation representation require specialized operators two representations associated operators compared problems ranging 2k 34k base pairs kb edgerecombination crossover used conjunction several specialized operators found perform best experimentssemi operators solved 10kb sequence consisting 177 fragments manual intervention natural building blocks problem exploited progressively higher levels macrooperators significantly improves performance b introduction computational problems posed human genome project challenging complex involve large quantities data human genome project plans identify exact sequence base pairs called map entire human genome consists approximately 3 billion base pairs many different components project problem involves combining partial information sequences dna fragments consistent map accounts known pieces explore application genetic algorithm problem dna fragment assembly draw parallels familiar permutation problem traveling salesman problem lawler rinnooy kan shmoys 1985 explicate interesting features problem source possibly useful heuristics specifically find use specialized operators provides good performance data sets 10kb size two specialized op erators transposition inversion macrooperators transform individual based groups fragments opposed single fragments groups fragments called contigs natural building blocks fragment assembly problem found adding macrooperators operate directly building blocks significantly increased performance genetic algo rithm throughout course run genetic algorithm assembles larger larger building blocks contigs macrooperators thus operate higher higher level progression explicit example implicit behavior described buildingblocks hypothesis accuracy various sequencing processes constrain laboratory approaches dna sequencing howe ward 1989 hunkapiller kaiser hood 1991 hunkapiller et al 1991 churchill et al 1993 currently strands dna longer approximately 500 base pairs cannot routinely sequenced accurately con sequently large strands dna broken smaller pieces sequencing shotgun sequencing method work applies dna first replicated many times individual strands double helix broken randomly smaller fragments produces set fragments short enough sequence however process retain either ordering fragments parent strand dna strand double helix particular fragment came paper addresses first problems hereafter referred fragment assembly problem relying previously developed methods addressing alignment strand assignment problems staden 1980 kececioglu 1991 huang 1992 churchill et al 1993 largescale shotgun sequencing projects require automated solutions recreate manual processes complexity assembly process grows exponentially size project several complicating factors considered designing computational solutions first large amount experimental error frequently quoted rates 01 10 chen hunkapiller 1992 repeated dna sequences much longer individual sequence fragments finally reagents experimentalists time valuable resources important objective computational system monitor progress sequencing determine strategies need applied target parent size many upcoming sequencing projects cosmid size 40000 base pairs denoted 40kb experimentalists use coverage sequencing redundancy particular point along parent dna least 5 7 compensate effects sequencing errors using figures assumed average fragment length 500 base pairs leaves ordering problem approximately 600 fragments ordering problem nphard 1 approximate method required determine reasonable layout fragment assembly packages use greedy algorithm form candidate typically greedy algorithm candidate solution presented researcher must massage obtain biologically plausible final result simulated annealing applied ordering step fragment assembly problem churchill et al 1993 burks et al 1994 genetic algorithms applied problem authors parsons forrest burks 1993 related ordering problem map assembly others fickett cinkosky 1993 next section paper contains detailed explanation flow information fragment assembly problem general computational approach follow section 3 details genetic algorithm explored paper results appearing section 4 explore answers questions pose additional questions final section 2 fragment assembly problem fragment assembly one step overall process building basepair map unknown segment dna steps process influence fragment assembly several ways affect overall quality information used assembly influence quality final solution introduce conflicting information errors process overview process shown figure 1 see also churchill et al 1993 burks et al 1994 detailed explanation sequencing process laboratory sequencing process provides set fragments frag ment base pair sequence fragment 2 fragments come either antiparallel strands parent dna orientation fragment relative parent known assembly stage information available sequence bases thus ordering fragments must rely primarily similarity fragments overlap particularly important aspect general sequencing problem precise determination relationship orientation fragments complicating factor overlap computation frequent occurrence repeated sequences ranging length several bases several thousand bases 3 dna fragment assembly method based sequence similarity bound misled dna repeats confusing fragments similar originate location parent sequence fragments similar share repeat pattern fragments ordered final consensus sequence generated ordering process includes detailed alignment step must account insertion deletion errors potentially present data shown figure 2 steps raw sequence data random sequencing project consensus sequence follows churchill et al 1993 burks et al 1994 g c g c dna replication shotgun produces fragments sequence fragments reassemble consensus sequence cgt ctgatac gtca gtagtac cg atga gtcatca tgcg gatga tatccagtatcat figure 1 overview dna mapping process 1 compute compare pair fragments determine similarity resulting overlap strength alignment relative orientation two fragments possible orientation tried two fragments overlap orientation alignment chosen maximize similarity fragments 2 totally order fragments ordering algorithm computes fitness figure merit candidate ordering examining overlap information addition fragment ordering particular layout results contigs staden 1980 contig layout gaps gaps occur neighboring fragments overlap 3 determine initial alignment use alignment offset orientation information first step ordering second step determine initial alignment fragments 4 determine detailed alignment fragments also known multiple sequence alignment starting initial alignment bases within fragments examined determine places insertion deletion errors likely occurred account errors gaps inserted fragments bring corresponding bases back alignment see waterman 1989 discussion multiple sequence alignment 5 generate consensus sequence column detailed alignment examined determine consensus base position yielding consensus sequence contig original fragment set pairwise comparison candidate ordering multiple sequence alignment c c g c g c g g c g figure 2 overview sequence assembly process ordering step must find total ordering given fragments results consensus sequence accurately reflecting parent sequence fragment must accounted ordering fragment appear one place ordering previously solved sequences parent sequence known judge quality ordering closely final consensus sequence corresponds known parent practice however fragment sets generated find parent sequence thus criteria must used evaluate ordering although small number contigs one goal orderings metric usable objective function many individuals vastly different orderings fitness value using metric preventing genetic algorithm distinguishing exploiting building blocks examine two objective functions described section 31 use pairwiseoverlap information basis evaluating fitness layout 21 fragment assembly traveling salesman problem relationship ordering step general class permutation ordering problems clear probably best known problem class traveling salesman problem tsp lawler rinnooy kan shmoys 1985 many others fragment assembly problem quite similar tsp notable differences first solution tsp circular tour cities endpoints tour therefore irrelevant fragment assembly prob lem however endpoints represent fragments opposite ends parent sequence many solutions equivalent tsp thus inequivalent context second cities tsp assumed relationship distances ordering final solution problem fragment assembly problem ordering referred beads string intermediate step solution process layout process uses overlap data position bases within fragments relative frequently two fragments overlapping layout several different orderings fragments produce equivalent results layout phase shown figure 3 additionally many algorithms tsp rely triangle inequality holding distance relation assumption made overlap strengths errors overlap strength computation due sequencing errors chimeric fragments dna repeat sequences tend invalidate simplifying assumptions made relationships frag ments another distinguishing feature fragment assembly problem fragments drawn strands dna orientation fragment relative parent lost sequencing process c figure 3 different fragment orders produce equivalent consensus sequence genetic algorithms permutation problems universally successful successful examples primary problem faced genetic algorithms context representing solutions way allows genetic operators produce legal solutions simple representation solution permutation represented list fragments labeled unique numbers order appear however standard genetic operators closed space legal solutions space illegal solutions quite large probability operator forming legal solution relatively small three obvious approaches representation problem 1 choose representation standard operators closed legal solutions 2 choose specialized operators guarantee legal solutions 3 penalize illegal solutions fitness function chose explore third approach search space sparsely populated legal solutions much time would wasted generating recognizing illegal solutions addition fitness functions already costly compute clear kind penalty function apply whether legal blocks within individuals would useful building blocks studied remaining two approaches first trying sortedorder representation solutions map legal permutation order syswerda 1989 bean 1992 studied performance simple permutation representation combination two specialpurpose recombination operators edgerecombination starkweather et al 1991 order crossover davis 1985 addition recombination explore bit position mutation sortedorder representation permutation representation study position swaps block moves transpositions block inversions operators representations described next section along data sets used testing 3 genetic algorithms applied fragment assembly genetic algorithms operate population candidate solutions called individuals holland 1975 goldberg 1989 forrest 1993 typically population initialized random individuals individuals deleted reproduced population basis relative fitness new individuals formed applying various operators existing population individuals see successive population individuals called generation processing within genetic algorithm typically follows steps individual evaluated determine fitness individuals reproduced copied differentially based fitness different genetic algorithms use different methods implement idea differential reproduction generational ga used new population created generation completely replacing previous population individuals average fitness population low probability copied next generation individuals high fitness high probability multiple copies next generation 4 crossover two individuals selected population substrings corresponding positions within individuals exchanged one new individuals inserted population next generation purpose operator allow partial solutions evolve different individuals combine produce sometimes better solu tion crossover operators described report crossover rate specifies average percentage new individuals formed generation crossover mutation mutation alters one individual changing primitive element individual eg flipping one bit mutation rate controls probability component individual changed resulting individual replaces parent mutation mutation believed effective two reasons explores search space near existing individuals local search prevents solution components completely eliminated population selection fixation lost successive generations genetic algorithm begins random population cycle se lection crossover mutation repeated many generations genetic algorithm used produce results reported implemented modifying genesis grefenstette 1984 software package although controversy well genetic algorithms actually perform perform well common explanation average fitness population likely increase successive gener ations good partial solutions combine form even better composite solutions process creating good solutions described terms combination building blocks portions solutions high fitness context fragment assembly problem building block portion ordering representing several fragments form contig considering different representations genetic algorithms important consider likely building blocks might combined form complete solution 31 fitness functions choice fitness function crucial success genetic algorithm particular problem fragment assembly problem choice efficient reliable measure fitness complicated several factors including errors sequence information insertions deletions etc repeated sequences beads string model studied two closely related fitness functions first natural analog fitness function tsp let ordering fragments f denotes fragment j appears position ordering fitness individual first fitness function f1 w ij pairwise overlap strength fragments j fitness function examines overlap strengths directly adjacent fragments ordering takes time compute individual optimization process attempts find layout maximizes function second fitness function accounts additional information exploited subsequent passes assembly processing churchill et al 1993 addition examining overlap strengths adjacent fragments considers overlap strengths among pairs fragments penalizing layouts fragments strong overlap far apart specific fitness function f2 uses absolute value distance fragments layout weight overlap strength pair fragments layout positions optimization process searches layouts minimize function function complexity 2 pairs fragments must considered 32 representations genetic algorithms appealing largely domain independent problem specifics isolated fitness function mapping individual problemlevel solution perspective first solution problem representing permutation problemsa representation guaranteeing legal solutionsis appealing second using type representation provides isolation problemspecific information genetic algorithm derives generality reason chose try sortedorder representation schaffer et al 1989 syswerda 1989 also referred randomkey representation bean 1992 sortedorder representation provides rather complex mapping individual permutation ordering two requisite properties legal ordering fragments present ordering duplication ordering properties ensured use sort hence name sortedorder specifically consider fragment set f individual b bit find permutation specified b first convert bit string n key values k bits sort key values key value position j individual appears position sorted list fragment f j ith position permutation specified individual b 5 fragment identified position individual j fragment placed bit string key values start position start position figure 4 sortedorder representation fragment assembly problem consider bit string produces following integers 2 fragment layout represented individual 1 5 4 2 3 intermediate shifting ordering 3 1 5 4 2 lowest key value individual 1 appears third position individual first fragment intermediate layout 3 next lowest value 2 first position individual therefore second fragment layout 1 last key represents starting position 2 first key permutation ordering 1 1 appears second position intermediate layout final layout continues position wraps beginning permutation based position sort order key j bit string represents legal permutation represent fragment assembly problem closely opposed tsp circular solution introduced modification sortedorder repre sentation individual add k bits end designates starting point permutation order value participate sort mapping described instead allows shifting ordering allow alternate starting positions figure 4 illustrates mapping also studied straightforward permutation representation together suite specialized operators representation bit string long k bits represents one fragment labeled 0 position fragment individual designates position fragment occupies layout although representation vastly simplifies mapping bit strings permutations operators must complex ensure legal individuals enter population 33 recombination operators used uniform twopoint crossover methods sortedorder rep resentation found uniform crossover perform well problem report results based standard twopoint crossover two points randomly selected bits positions exchanged 1989 sortedorder representation closed standard genetic operators additional processing required find legal permutation two specialpurpose crossover operators successful permutation problems edge recombination starkweather et al 1991 order crossover davis 1985 different crossover operators emphasize preservation different kinds information parents thus success different operators different permutation problems likely tied ability crossover operator preserve valued information parents crossover least three kinds information might important permutation ordering absolute position relative ordering eg precedence relations scheduling applications adjacency tsp particularly due circular nature relevant information probably adjacency information fragment assembly problem issue less clear adjacency information total ordering important however given linear nature layout definite end points overlapping nature fragments ordering relative position may also important chose experiment two crossover operators order crossover edge recombination order crossover preserves relative ordering cases absolute position ordering edge recombination emphasizes adjacency information simplicity explana tion crossover operators described terms integer bit values order crossover twopoint crossover two random points selected however instead exchanging information points information first parent copied positions offspring shown figure 5 starting beginning second parent beginning offspring fragments second parent placed offspring fragment already placed offspring skipped second parent thus fragments first parent retain position relative ordering fragments second parent retain relative ordering edge recombination complicated operator detailed explanation operator implemented appears starkweather et al 1991 general crossover attempts preserve adjacencies parents particular adjacencies common parents neither options possible random selection made example edgerecombination operator works shown figure 5 whitley reported additional modifications edgerecombination operator give even better results tsp whitley 1993 yet tested modifications 34 operators sortedorder representation allows use simple bitmutation operator goldberg 1989 small probability bit individual altered however permutation representation point mutation guaranteed produce illegal solution consequently use point mutation original individuals 972orderbased crossover edge recombination adjacency list edgerecombination key adjacent keys2468789 497 figure 5 order crossover edge recombination illustrates order crossover individuals 2 edge recombination offspring begins first fragment first parent 1 examining 1s adjacencies select 8 shared adjacency list others shared adjacency 3 placed next shared adjacency 6 chosen next followed 4 4 next fragment 2 placed individual remaining adjacencies process continues end 5 placed yet placed yielding individual 1 8 3 6 4 2 9 7 permutation representation however tried suite mutationlike operators simplest swap two positions ordering selected random fragments positions swapped create new individual churchill et al 1993 operator restricted form 4opt transformation lin kernighan 1973 using tsp terminology used two operators rely domainspecific informa tion two operators inversion transposition move blocks fragments specifically contigs ordering although random locations selected individual operators location simply indicates contigs operation applied inversion reverses order fragments selected contig goldberg 1989 operator useful since fragments come strands dna total ordering forces orientation data inverting contig may extended since contig may oriented opposite direction adjacent fragments ordering restrict inversion operate contigs within layout instead general inversion operator randomly selects area invert transposition moves contig position two adjacent contigs may allow extension contig operator allows smaller contigs form anywhere along individual transpositions correct relative positions clusters yielding improved solution transposition also restricted form 4opt restriction focusing selection edges break edges replace contigs natural building blocks problem transposition inver sion design disrupt building blocks instead allow evolution larger contigs treating smaller contigs primitive elements meaning rates mutation specialized operators different mutation used sortedorder representation rate specifies probability bit individual selected mutation given genera tion thus find probability individual altered rate must multiplied length individual specialized operator rate quoted probability individual affected thus rate 02 implies 20 probability individual selected alteration operator 35 data sets implementation environment fragment data sets report results artificially generated actual dna sequences parent dna sequence replicated program fragmented random locations derive fragment set representative data sets produced sequencing laboratories generator genfrag engle burks 1993 allows fragment sets different sizes error con tent coverage generated approach allowed us study different factors affect performance genetic algorithm baseline testing proved useful identifying particularly successful unsuccessful configurations representations operators population sizes etc completed control experiments beginning tackle experimentally derived dna fragment sets three dna sequences served basis experiments human brain dna sequence humatpk01 sverdlov et al 1987 accession number m55090 2026 base pairs long human mhc class iii region dna fibronectin typeii repeats hummhcfib matsumoto et al 1991 accession number x60189 3835 bases long human apolopoprotein humapobf carlsson et al 1986 accession number m15421 bases long also working two longer sequences 20kb se quence amcg initial 40 bases lamcg complete genome bacteriophage lambda accession numbers j02459 m17233 sanger et al 1982 data set designated seto experimental data set made available testing sequencing algorithms seto koop hood 1993 results obtained using fragment sets first three parent sequences experimented coverages ranging 3 7 mean fragment length 300 500 bases addition fragment sets experimental errors rate 10 mismatch errors 5 insertion deletion errors used determine robust algorithm table 1 presents information specific fragment sets tested algorithm table 1 information data sets names atpk humatpk01 cfib hummhcfib pobf data set amcg lamcg seto experimental data set bases number base pairs known consensus sequence coverage average number fragments covering base parent gaps areas parent coverage cfib5 cfib10 errors introduced fragment sets specified rate 5 10 bases 2026 3835 3835 3835 10089 20100 34475 fragments 26 36 24 39 48 68 68 48 127 177 352 829 gaps overlap computation uses technique allows setting cutoff value overlap scores value considered zero churchill et al 1993 cutoff set twenty provides one filter spurious overlaps introduced experimental error 4 results described earlier difficult identify single best measure performance problem case consensus sequence data known correctness ordering determined performing final steps assembly process comparing resulting sequence known consensus sequence goal complete match also important consider time reach solution table 2 summarizes results using match parents number contigs solution number function evaluations generations used genetic algorithm remainder section explores overall performance achieved genetic algorithm experiments performed analyze different components genetic algorithm fitness function representation operators final section draws conclusions data discusses future directions research genetic algorithm performs quite well appropriate representation operator set terms speed solution quality figure 6 shows mean best fitness improves cfib data set genetic algorithm solves smaller two data sets finding singlecontig solution representing consensus sequence completely matches parent sequence result however startling fragment sets relatively small fragment assembly systems data sets size errors produce results close enough correct small amount manual intervention produces correct table 2 genetic algorithm performance fragment assembly problem data set name includes coverage parentheses num gens number generations num trials number fitness function evaluations genpop trials since individuals change generation num contigs number contigs ga solution greedy number contigs greedy solution num sorted previous results using sorted order representation indicates experiment performed sorted order parameter settings crossover rate 03 specialized operator rate 07 pointswap rate 02 inversion rate 04 transposition rate 04 scaling factor 20 parent match computed single contig solutions computed entire region parent data set pop num num num parent num num name size gens trials contigs match greedy sorted solution even smaller data sets however correct representation crucial performance genetic algorithm using representation suite operators exploit conceptual building blocks problem able construct genetic algorithm good performance problem results pobf data set 10kb parent interesting smaller data sets 177 fragments sevenfold coverage data set manual intervention genetic algorithm produces singlecontig solution whose consensus sequence completely matches parent yet solve fully remaining two large data sets amcg data set 20kb parent seto data set consensus sequence 34kb table 2 presents results data sets date exhaustive testing involved cfib data set seen table 2 fragment sets included significant amounts error data sets contained gap ga found correct singlecontig solution data sets without gaps errors case data set 10 mismatch errors ga finds singlecontig solution 97 match parent although mismatch errors 10 base pairs fragment set fivefold coverage postprocessing multiple sequence alignment consensus generation algorithms correctly reproduced 97 bases generation 42 fitness best indiv population population mean figure 6 population mean best fitness plots typical run cfib7 data set cfib data set gap errors solution found existing two contigs matched base pairs covered solution 41 comparison greedy approach many standard assembly packages use form greedy algorithm find appropriate ordering staden 1980 huang 1992 evaluate performance genetic algorithm compare results found greedy algorithm greedy algorithm use similar used huang 1992 examines overlap strengths picks strongest overlap connects yet unplaced fragment contig constructed table 2 includes solutions found greedy algorithm greedy algorithm never uncovers best solution except small cfib data set gap find optimal solution pobf data set looked solution found greedy algorithm fitness values data set shown table 3 results f2 function penalizes solutions ignore significant overlap particularly informative large difference f2 scores greedy solution genetic algorithm solution provides indication much manual editing would required convert greedy solution workable solution work even greater difference 1 7 contigs initially indicates table 3 comparison greedy algorithm genetic algorithm pobf sevenfold coverage data set f1 score f2 score contigs greedy 42 fitness functions critical part design genetic algorithm selection appropriate fitness function fragment assembly selection complicated processing required fragmentordering step previous work parsons forrest burks 1993 compare detail two fitness functions described section 31 results reproduced table 4 experiments sortedorder representation showed quadratic fitness function f2 marginally superior performance linear function f1 ran small set experiments two functions using permutation representation edgerecombination operator case linear function performs better results appear table 4 atpk data set although argued objective function ideal fragment assembly problem computational results show function adequate compared f2 based results achieved far nevertheless consider design appropriate fitness function important area continued research 43 comparison representations results experiments show application edgerecombination operator conjunction permutation representation full suite operators quite successful final column table 2 reproduced parsons forrest burks 1993 gives results sortedorder repre sentation summarizing prior results sortedorder representation disruptive building blocks fragment assembly problem useful context permutation representation edgerecombination operators specialized operators able exploit building blocks powerful way 44 comparison operators using permutation representation section describes several experiments performed analyze effectiveness various operators examine way interact table 4 ga test results two fitness functions best score best individual followed score individual function contigs number contigs layout specified best individual data set atpk coverage 7 parameters different random seeds crossover rate 085 07 point swap 003 parent best f1 f2 score contigs best f2 f1 score contigs cfib510 3873 162581 7 100179 3333 8 43 7128031 13582 28 first compared two crossover operators order crossover edge recombination described section 33 table 5 summarizes results obtained using order crossover comparing results table 5 table 2 clearly demonstrates even attempting tune genetic algorithm parameters representation edgerecombination superior order crossover table 5 genetic algorithm performance using order crossover operator trials number f1 fitness function evaluations num contigs number contigs found best solution 5 runs population num xover swap inversion transposition num size trials rate rate rate rate contigs next ran several experiments applying operators various rates particular results worth noting genetic algorithm relatively successful solving smaller data sets traditional parameter settings crossover rate 07085 rates specialized operators 00501 9ever significantly better performance occurs much lower crossover rates much higher rates specialized operators rates increased efficiency genetic algorithm small data set allowed genetic algorithm solve larger data set runs reported used crossover rate 0203 special operator rate 07085 eliminating one operators either crossover one specialized operators tended give poorer results synergistic effect among various operators finding appropriate solutions results experiments summarized table 6 tracked change fitness values table 6 ga performace cfib data set fivefold coverage population 300 250000 trials run completely converged 50000 iterations xover swap trans inv contigs application operator course several runs figure 7 shows efficacy different operators life twenty different runs lowpass filter applied smooth variations data graph shows utility pointwise swap decreases run progresses inversion transposition remain useful throughout computed genealogy best individuals population determine operators contribute creation good individuals mix changes population changes specifically every 100 generations examined history 5 best individuals recorded often operator occurred history last 100 generations crossover consistently contributing creation best individuals course run 5 discussion conclusions one interesting questions raised work relates way specialized operators exploit building blocks problem way generation1000300050007000d averaged fitness improvement crossover swap transposition figure 7 average change fitness operator smoothed using low pass filter operations improved fitness considered full operator suite interacts improve genetic algorithms performance performance suffers operator removed suite although high enough rate transposition reduces impact loss crossover operator however one examines mechanics crossover operator two individuals similar result surprising transposition mimics kind crossover operation genealogy best individuals shown figure 8 highlights importance crossover operator creation good solutions even low rate applied described earlier low rate crossover best found tuning genetic algorithm parameters one conclude however low rate indicates crossover unimportant solution power genealogy information tells different story although average fitness improvement operator declines run remains active participant creation improved individuals behavior crossover transposition inversion change run swap operator remains transposition inversion affect contigs early run contigs likely quite small frequently contain one fragment thus early generations specialized operators act similarly decrease effectiveness pointwise swap later generations consistent building block hypothesis late run changes required improve individual tend larger scale obtained single swap ie improvements tend require movement contigs conceptual building blocks problem rather movement individual fragments fitness crossover swap transposition figure 8 operator frequency 100 generation intervals five best individuals population cfib sevenfold data set operators displayed order appear legend many genetic algorithms significant problem premature convergence operator suite tends prevent convergence 668 generations cfib sevenfold coverage run population close converged traditional sense although almost positions data set 50 individuals fragment position none positions 60 individuals fragment value thus ga still searching improved solutions two factors contribute significantly effect first permutation representation alphabet position much larger binary alphabet traditionally used genetic algorithms second importantly operators used genetic algorithm tend quite disruptive terms values particular position towards end run consider inversion operation inverts contig entire block positions within individual changed operation operator worst creates individual equal fitness towards end run convergence issue contigs quite large meaning many fragment positions altered effects operators coupled high rates applied counterbalances strong convergence seen genetic algorithm applications features fragment assembly process aid performance genetic algorithm results shown table 2 pobf data set runs number iterations represents onethird fewer generations larger data set size population taken account one would expect increasing problem size 35 perspective optimizer must order 177 fragments instead 127 would make problem difficult however 177 fragment problem genetic algorithm time finds onecontig solution solution 127 fragment problem appears stuck sixcontig solution increase coverage fivefold sevenfold corresponding increase number essentially equivalent solutions precise ordering becomes less critical characteristic search space highercoverage problem another indication genetic algorithm appropriate approach genetic algorithms tend find nearoptimal solutions relatively easily difficulty refining solutions high degree redundancy search space also present sortedorder representation many different combinations numbers would map permutation ordering however redundancy search space sufficient overcome disruption solution building blocks caused operators see parsons forrest burks 1993 details work far demonstrates feasibility using genetic algorithms sequencing problems parent sequence order 10kb coverage sufficient sevenfold since sequencing labs use coverages level higher coverage range restriction still working parents range 20kb 35kb range however problems phases analysis ordering depends become pronounced addition dramatic increase size search space obvious problem dna repeats longer parent sequences tend repeat sequences regions repeats high overlap since repeat sequences generally quite similar 90 homology uncommon lengthy thus fragments different sections dna repeats show overlaps examination sequence overlap information indistinguishable overlaps result fragments drawn section dna using overlap information additional information must provided program attempting sequence dna repeated segments allow repeatinduced overlaps distinguished true overlaps auxiliary data mapping information available objective function redesigned take new information account success specialized operators representations exploit conceptual building blocks may influence solution permutation problems using techniques genetic algorithms example burks et al burks et al 1993 successfully incorporated inversion transposition operators simulated annealer impressive performance improvements generally many interesting questions raised experiments particularly relating role solution space redundancy synergistic effects among various operators acknowledgments authors wish thank l davis engle r hightower mathews j sims c soderlund p stolorz whitley assistance project project initiated map assembly workshop santa fe institute sponsored santa fe institute theoretical division los alamos national laboratory work performed part auspices united states department energy contract w7405eng36 cb supported doeoher genome project erwf137 r moyzis pi rp supported part los alamos directors fellowship sf supported national science foundation grant iri9157644 sandia university research program grant ae1679 notes 1 nphardness follows straightforward reduction hamiltonian path 2 dna double helix comprised two complementary strands polynucleotides nucleotide consists purine pyrimidine base attached sugarphosphate moiety sugarphosphate constant throughout entire strand bases vary four bases found dna adenine guanine g cytosine c thymine computational viewpoint strand dna viewed character string alphabet four letters two strands complementary sense corresponding positions always paired ts cs gs although letters appear either strand pairs complementary bases referred base pairs 3 different families repeat sequences different characteristic lengths degree conservation among family members repeat sequences arise due duplicated genes example 4 used elitist policy sigma scaling cutoff value 2 5 ties sort broken arbitrarily use left right ordering r genetics random keys sequencing optimization stochastic optimization tools dna assembly integration physical map sequence data stochastic optimization tools genomic sequence assembly analysis human apolipoprotein b gene investigation dna mapping genetic algorithms preliminary results sequence accuracy large dna sequencing projects assembling dna sequence fragments shuffling simulated annealing applying adaptive algorithms epistatic domains artificially generated data sets testing dna fragment assembly algorithms genetic algorithms principles natural selection applied computation genetic algorithms search addison wesley publishing company genesis system using genetic search procedures adaptation natural artificial systems nucleic acids sequencing practical approach contig assembly program based sensitive detection fragment overlaps exact approximation algorithms dna sequence reconstruction university arizona traveling salesman problem new york john wiley sons effective heuristic algorithm travelingsalesman problem cluster fibronectin typeiii repeats found human major histocompatibility complex class iii region shows highest homology repeats extracellular matrix protein genetic algorithms dna sequence assembly nucleotide sequence bacteriophage lambda dna study control parameters affecting online performance genetic algorithms function optimization experimentallyderived data set constructed testing largescale dna sequence assembly algorithms new computer method storage manipulation dna gel reading data comparison genetic sequencing operators family human na uniform crossover genetic algorithms mathematical methods dna sequences personal communication tr ctr zongben xu kwongsak leung yong liang yee leung efficiency speedup strategies evolutionary computation fundamentals fastgas applied mathematics computation v142 n23 p341388 10 october jacques cohen bioinformaticsan introduction computer scientists acm computing surveys csur v36 n2 p122158 june 2004
computation networks passively mobile finitestate sensors explore computational power networks small resourcelimited mobile agents define two new models computation based pairwise interactions finitestate agents populations finite unbounded size fairness condition interactions define concept stable computation function predicate give protocols stably compute functions class including boolean combinations thresholdk parity majority simple arithmetic prove stably computable predicates nl uniform random sampling pairs interact define model conjugating automata show counter machine o1 counters capacity simulated high probability protocol population size n prove predicates computable high probability model p rl several open problems promising future directions discussed b works network architecture designdistributed net works network communications network topology wireless communication f11 computation abstract de vices models computation f12 computation supported part nsf grants ccr9820888 ccr 0098078 cse0081823 cns0305258 onr grant n000140110795 permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copies bear notice full citation first page copy otherwise republish post servers redistribute lists requires prior specific permission andor fee july 2528 2004 st johns newfoundland canada abstract devices modes computationparallelism concurrency probabilistic computation e1 data data structuresdistributed data structures general terms theory algorithms performance keywords diuse computation finitestate agent intermittent com munication mobile agent sensor net stable computation 1 scenario flock birds suppose equipped bird particular flock sensor determine whether birds temperature elevated wish know whether least 5 birds flock elevated temperatures assume sensors quite limited sensor constant number bits memory respond global start signal two sensors communicate suciently close scenario sensors mobile control move passively mo bile initially assume underlying pattern movement guarantees fairness condition interac tions every pair birds flock repeatedly come su ciently close sensors communicate assumptions simple protocol ensuring every sensor eventually contains correct answer global start signal sensor makes measurement resulting 1 elevated temperature 0 elevated temperature counter hold values 0 4 two sensors communicate one sets counter sum two counters one sets counter 0 two counters ever sum least 5 sensors go special alert state copied every sensor encounters output sensor 0 alert state 1 alert state wait sucient interval issue global start signal retrieve correct answer sensors consider question whether least 5 birds flock elevated temperatures protocol answer question sense without assumptions size flock section 3 show protocol exists generally interested fundamental questions computational power related models interactions among members distributed population finitestate agents 2 wider view work distributed algorithms assumes agents system computationally powerful capable storing nontrivial amounts data carrying complex calculations systems consisting massive amounts cheap bulkproduced hardware small mobile agents tightly constrained systems run resources available agent may severely limited limitations crippling system designer fine control interactions agents even finitestate agents regimented cellular automata computational power equivalent linear space turing chines system designer cannot control teractions clear computational limits sensor networks prime example phenomenon sensing unit selfcontained physical package including power supply processor memory wireless communication capability one sensors capable recording information local environment unit constraints cost size translate severe limitations power storage processing communication sensing units designed deployed large groups using local lowpower wireless communication units transmit information sensors back base station central monitoring site research sensor networks begun explore possibilities using distributed computation capabilities networks sensors novel ways reduce communication costs aggregation operations count sum average extrema median histogram may performed sensor data network relayed base station 12 13 flexible groups sensors associated targets spatial target tracking conserve resources inactive portions tracking area 7 17 though sensors usually assumed stationary nearly permitting strategies based relatively stable routing assumption universal sensornetwork literature example assumption random mobility packet relay dramatically increases throughput possible communication sourcedestination pairs wireless network 9 flock birds scenario illustrates question characterizing computations possible cooperative network passively mobile finitestate sensors assumptions make motion sensors passive control sensors sufficiently rapid unpredictable stable routing strategies infeasible pair sensors repeatedly close enough communicate using lowpower wireless signal global start signal transmitted base station sensors simultaneously initiate computa tion receive global start signal sensors take reading one finite number possible input val ues attempt compute function predicate sensor values provides snapshot sensor values rather continuous stream sensor values commonly considered sensors communicate pairs unique identifiers thus update states based strictly pair current states role plays interactionone acting initiator responder section 3 define model computation pairwise interactions population identical finitestate agents assuming fairness condition interactions define concept stable computation function predicate population protocol section 4 consider question predicates stably computed interactions occur pairs agents give protocols thresholdk parity majority simple arithmetic functions well closure results allow us define useful expression language captures subset power model also show every predicate computable model nondeterministic log space open problem give exact characterization computational power stable computation model section 5 show allpairs case weakest stably computing predicates showing simulated population cannot separated noninteracting subpopulations questions additional predicates computed reasonable restrictions interactions properties underlying interaction graph stably computed population open section 6 obtain model conjugating automata adding uniform sampling condition interactions assumption interactions enabled pairs agents allows us consider computations correct high probability address questions expected resource use show model sucient power simulate high probability counter machine o1 counters capacity show boolean predicates computable high probability model p rl gives partial characterization set predicates computable machines finding exact characterization still open section 7 describe related work section 8 discuss many intriguing questions raised models 3 formal model define model generalizes flock birds scenario section 1 31 population protocols population protocol consists finite input output alphabets x finite set states q input function x q mapping inputs states output function mapping states outputs transition function states p transition define 1 p simple illustration formalize version counttofive protocol section 1 six states q0 q5 input output alphabets 0 1 input function maps 0 q0 1 q1 output function maps states except q5 0 state q5 1 transition function q q j defined result q5 q5 result q ij q0 population protocol runs population finite size n population p consists set n agents together irreflexive relation e interpret directed edges interaction graph e describes agents may interact computa tion intuitively edge u v e means u v able interact u playing role initiator v playing role responder interaction note distinct roles two agents interaction fundamental assumption asymmetry model symmetrybreaking therefore arise problem within model though present paper concerns case e consists ordered pairs distinct elements give definitions appropriate general e population configuration mapping c q specifying state member population let c c population configurations let u v distinct agents say c goes c via encounter denoted c e say c go c one step denoted c c sequence configurations c c i1 0 k case say c reachable c computation finite infinite sequence population configurations c0 c1 c2 computation fair every pair population configurations c c c c c occurs infinitely often computation c also occurs infinitely often computation 32 computation population protocols nondeterministic turing machines define notion input output capture inputoutput behavior population protocols relations unlike turing machines population protocols halt obvious fixed time view output population rather say output computation stabilizes reaches point agent subsequently change output value matter computation proceeds thereafter stability global property population configuration individual agents general know stability reached however suitable stochastic assumptions rate interactions occur possible bound expected number interactions output stabilizes explore approach section 6 input assignment function x x describes inputs population protocol let x denote set input assignments inputs represented input configuration cx ixw w naturally extend mapping input assignments configurations writing cx words x assigns input symbol agent u agent us state configuration ix output assignment function describes outputs population protocol let denote set output assignments given configuration c let yc denote corresponding output assign ment yc naturally extend mapping configurations output assignments writing words agent u state q configuration c agent us output symbol output assignment oc oq configuration c said outputstable oc oc c reachable c note require outputs equal infinite computation outputstabilizes contains outputstable configuration c case say stabilizes output oc immediate infinite computation stabilizes one output output finite computation output last configuration output infinite computation stabilizes output output undefined computation stabilize output nondeterminism inherent choice encounters initial configuration may lead dierent computations stabilize dierent outputs population protocol running population p stably computes inputoutput relation ra follows x x rax holds fair computation beginning configuration ix stabilizes output special case ra singlevalued 1 write say stably computes partial function continuing counttofive illustration assume agents u1 u6 interaction graph complete 2 let input assignment x described vector 0 1 0 1 1 1 assigning input symbols agents u1 u6 der corresponding input configuration leads following possible computation configurations reachable last one five agents assigned q0 one agent assigned q4 outputs equal 0 0 0 0 0 0 therefore r0 1 0 1 1 1 0 0 0 0 0 0 holds r inputoutput relation computed protocol fact r singledvalued write relation r singlevalued xyzrxyrx z intersection graph complete u v directed edge agents u v u v example could designed protocol configurations stopped changing illustrates fact require outputs stop changing next section show irrelevance agent identities computation general phenomenon 33 functions domains defined section 32 population protocols compute partial functions x order use population protocols compute functions domains need suitable input output encoding conventions functions multiple arguments let f function domain x n agentbased input convention assumes ordered set n agents gives th argument th agent 1 n depending interaction graph output conventions particular ordering chosen agents might might aect function computed predicates x predicate x regarded function x 0 1 predicate output convention assumes requires every agent agree output population protocol stably computes predicate inputoutput relation singlevalued input assignments x predicate true x fa x output assignment maps every agent otherwise fax output assignment maps every agent 0 formal counttofive protocol described stably computes predicate x true x assigns 1 least 5 dierent agents generalizes easily functions x set output symbols require final outputs agents equal correct value function integer functions partial function integer vectors integer input output values represented diusely across population rather stored locally individual agents describe encoding convention represent o1 integers absolute values bounded population protocol n agents let set generally take either x q kplace integer encoding convention mapping z k thus associates kvector integers element extend mapping summing agents define ua u maps agent kvector sum agents obtain vector represented integer input kvector encoded kplace encoding convention x input set x integer output vector encoded place encoding convention output set internal computation maintain mvector encoded q state set q using encoding conventions say stably computes f following conditions hold 1 every r z k domain f exists x x x 2 every x x x x domain f exists ra x holds 3 every x x ra x holds note stably compute integer function f even though ra single valued might happen exam ple example integer function describe population protocol compute function integer quotient 3 let input output encoding functions identity thus input assignment x represents number agents assigned 1 similarly output assignments states ordered pairs j integers state encoding function also identity input map maps 1 state 1 state 0 0 output map maps state j j transition function defined follows transitions defined leave pair states unchanged transitions first type accumulate two 1s 2 leave sum first coordinates states unchanged transitions second type reduce sum first coordinates states 3 increase sum second coordinates 1 eventually transitions first type possible sum second coordinates integer quotient 3 de sired output map changed identity protocol would compute ordered pair consisting remainder modulo 3 integer quotient 3 4 allpair interactions section restrict attention populations interaction graph complete assump tion stably computable inputoutput relations invariant renaming agents permutation ra x ra xy case predi cates output assignment constant function implies output determined multiset input symbols therefore stably computable predicates symmetric population protocols depend states agents names define standard agent set 1 n size n let pn population size n consisting complete interaction graph let fn family boolean functions fn 0 1 n 0 1 n 1 population protocol stably computes family fn every n 1 run population pn stably computes function fn agentbased input convention agent gets ith argument predicate output convention eventually every agent agrees correct output discussion every stably computable family boolean functions symmetric generally consider languages predicates x set finite strings input symbols say population protocol stably computes l every run population pn stably computes characteristic function l restricted strings length n agentbased input predicate output conventions l stably computable contains every permutation elements 41 stably computable predicates begin considering families boolean functions stably computable closure properties let fn gn families boolean functions stably computable population protocols b complementing output map family negations f stably computable complementing input map family functions hn hn equal fn inputs complemented stably computable product constructions b yield population protocols stably compute conjunction disjunction outputs fn gn formally lemma 1 let fn gn families boolean func tions fn gn stably computable thus addition predicates least 5 ones compute predicates fewer 5 ones least 5 zeros 5 zeros exactly 5 ones exactly 5 7 9 ones though immediately obvious parity majority also stably computable population protocols parity value parity 1 odd number 1s input 0 even number 1s input note computing parity function predicate output convention dierent computing remainder modulo 2 integer output encoding conven tion predicate output convention eventually agents must correct output symbol construction parity uses state consisting two bits data bit live bit initially data bit equal input bit live bit 1 state output bit equal data bit two agents whose live bits 1 one sets live bit 0 sets data bit mod 2 sum data bits agent live bit 0 meets agent live bit 1 former copies data bit latter protocol mod 2 sum product live bit data bit agents population invariant equal mod 2 sum inputs even tually exactly one agent live bit set 1 point data bit correct output single live bit set 1 eventually every agent copies correct data bit agent live bit ensures treestructured computation aggregating data bits final result root tree generalizes computation product input values commutative semigroup thus symmetric regular languages stably computable eg deciding whether number 1s constants majority value majority function 1 1s 0s input otherwise 0 states protocol consist live bit counter values set 1 0 1 initially live bit 1 counter 1 input 0 1 input 1 output 1 counter 1 otherwise 0 two agents live bit equal 1 meet sum counters set 1 0 1 set counters sum one agents sets live bit 0 otherwise nothing agent live bit equal 0 meets agent live bit equal 1 former copies counter value latter protocol sum counters agents live bit equal 1 invariant equal number 1s minus number 0s input eventually remain one live bits equal 1 combinations possible means associated single value 1 0 1 indicating number 1s input less equal greater number 0s input respectively point every agent copy common counter value outputs also correct generalization counters capable holding integer values k k inclusive determines whether least fraction 1k1 inputs 1s demonstrating existence population protocol detect whether least 5 flock birds elevated temperatures claimed section 1 arithmetic functions recall section 33 distributed representation o1 integers absolute value example protocol divide 3 using similar encodings ideas population protocols compute sum two integers product integer constant integer quotient integer constant value integer modulo constant constant function equal k inputs given stable inputs protocols outputstabilize thus composed freely stably computable expression language putting together base functions closure results define expression language expressible predicates stably computable population protocols gives lower bound set stably computable predicates whether every stably computable predicate expressible open problem expressions defined follows input symbol x variable n representing number agents assigned symbol input assignment constants nonnegative integers term con stant variable sum two terms product constant term integer quotient term nonzero constant remainder term modulo nonzero constant atomic expressions formed two terms one predicates expression either atomic expression negation expression conjunction two expressions disjunction two expressions expression either true false given input assignment usual semantics example counttofive problem expressible 5 parity problem n1 mod 1 majority problem n1 n0 question whether number 1s 15 20 total population expressed idea extends predicates nonbinary input alpha bets express predicate number bs cs equal expression theorem 2 predicate expressed language described stably computable already noted whether converse holds open problem proof sketch set stably computable predicates closed complementation union tersection suces show terms atomic expressions language described stably computable given term language use distributed representation integers allocate component state subterm expression including variables constants input map places value n component allocated subterm expression subprotocol operating parallel others compute value correct component state generally function values computed components use protocols sum multiplication constant division constant remainder modulo nonzero constant constant functions eventually stabilize correct outputs atomic expressions suces consider t1 t2 stably computable predicates closed negation intersection union use method computing values subterms expression run also parallel protocol compare values t1 t2 propagate results agents protocol similar majority protocol described note passing exact relationship expression language semilinear sets fix ordering 1 k input alphabet define parikh map x n k number occurrences x using ginsburg spaniers characterization semilinear sets defined presburger arithmetic 8 straightforward beyond scope paper show semilinear sets n k precisely images predicates expressible language defined thus may rephrase one open problems stably computable predicates whose corresponding subsets n k semilinear 42 predicates stably computable theorem 2 gives partial characterization stably computable predicates population model pairs enabled know characterization com plete however obtain upper bound set predicates stably computable model showing contained complexity class nl stably computable predicates model symmetric sucient represent population configuration multiset states assigned agents since q possible states population consists agents population configuration thus represented q counters log n bits population protocol step simulated drawing two elements multiset applying transition function returning resulting two elements multiset population protocol stably computes language l x nondeterministic turing machine accept l space olog n accept input x turing machine must verify two conditions configuration c reachable ix states output 1 configuration c reachable c state output 0 first condition verified guessing checking polynomiallength sequence multiset representations population configurations reaching c second condition complement similar reachability condition nondeterministic olog n space class closed complement 11 follows theorem 3 predicates stably computable model pairs enabled class nl open problem characterize exactly power model stable computation concretely conjecture predicates number 1s power 2 number cs product number number bs stably computable population protocols intuition model lacks ability sequence iterate computations suspect pumping lemma form exists model 5 restricted interactions interaction graphs may permit powerful computations population protocols example population whose interaction graph directed line easily simulate linearspace turing machine section prove complete interaction graph assuming sense weakest structure stably computing predicates weaklyconnected interaction graph simulate theorem 4 population protocol exists population protocol every n stably computes predicate p standard population pn p population agents 12 n weaklyconnected interaction graph stably computes p proof sketch key idea interaction choose nondeterministically swapping states two interacting agentswhich eventually brings two simulated agents togetheror simulating interaction details simulation involve implementing nondeterministic choice deterministic transitions state space augmented add two batons initiator r respon der move somewhat independently simulated agents presence two batons used control eect interaction interaction involves batons swaps states interaction involves one baton moves baton interaction involves batons simulates transition mechanism assumes n least 4 give room move batons way smaller n values handled separate protocol running parallel overrides output main protocol detects n 3 state space default initial state baton field marks initiator baton r marks responder baton marks blank absent baton writing ordered pairs q using simple concatenation eg qd q transition function given x range states q represents nond baton first group transitions consumes initial ba tons producing least one least one r baton second group eventually reduces set nonblank batons exactly one one r remaining groups implement baton movement b state swapping c atransitions note atransitions also swap batons done allow r batons pass narrow graphs may necessary bring duplicates together initial stage simulated execution obtained ignoring batons agent order proof correctness involves showing fairness holds simulation state reachable infinitely often reached infinitely often done showing atransition simulated finite sequence transitions involving moving relevant states adjacent agents using state swaps may require additional transitions move batons edge states endpoints swapped moving r batons onto adjacent agents triggering atransition 6 randomized interactions conjugating stability probably strong enough guarantee practical situations best oer given fairness condition make stronger guarantees must put constraints interactions members population let us add probabilistic assumption next pair interact chosen many assumptions would reasonable study consider one simplest ordered pair interact chosen random independently uniformly ordered pairs corresponding edges interaction graph interaction graph complete model conjugating automata inspired models introduced diamadi fischer study acquisition propagation knowledge trustworthiness populations interacting agents 4 random pairing sucient guarantee fairness probability 1 protocol stably computes predicate g fair model computes g probability 1 every input corresponding randompairing model assuming run population however probabilities also allow us consider problems compute correct answer high prob ability describe expected number interactions protocol converges given function f mapping x population protocol input x define probability computes f input x probability computations beginning ix stabilize output fx example parity protocol expected number interactions computation one live bit equal 1 n 2 expected number interactions every member population interacted unique member live bit equal 1 log n thus expected total number interactions output correct n 2 log n general interested protocols accomplish tasks expected number interactions polynomial n population size 3 generalizing argument obtain following structural induction theorem 5 let p predicate defined language section 41 randomized population protocol computes p probability 1 population converges correct answer expected total number interactions okp n 2 log n kp constant depending p 61 benefits leader simulating counters allowed designate leader input con figuration one agent starts distinguished state leader organize rest population simulate counter machine o1 counters capacity high probability assume throughout section interaction graph complete use representation described section 33 integers arithmetic computations simulation k counters counter take maximum value n state mapped ktuple nonnegative integers 0 c1 0 ck sum component population gives current contents counter assume inputs counter machine supplied designated counters leader simulates finitestate control counter machine 3 note protocols terminate final remain capable resuming indefinitely decrement counter leader waits encounter agent component state greater zero decrements incrementing counter similar component must less maximum value c operations happen probability 1 assuming pos sible however testing counter zero dierent leader must attempt decide whether agents component greater zero give method correct high probability ability make possibly incorrect decisions enables eective sequencing iteration computations model leader initially labels one agent timer special mark leader waits one two events 1 interaction agent nonzero component consecutive interactions timer event type 1 occurs first simulated counter certainly zero event 2 low probability occurs first probability high leader encountered every agent meantime may small probability error conclude value simulated counter zero parameter k controls probability error expense increasing expected number interactions lemma 6 leader marks one agent timer expected total number interactions leader encounters timer k times row n k1 proof sketch let k number encounters involving leader leader encounters timer k times row k leader must first encounter timer k1 times row happens another agent encountered leader probability n1 timer case must start solving recurrence relation k get expands n k since probability leader involved given encounter 2n result follows rather sum error bounds individual counter op erations analyze error associated macro operations counters lemma 7 suciently large k operations zeroing counter zeroing counter adding contents one counters performed expected total number interactions n k1 o1n k1 log n probability error holds operations multiplying constant integer quotient constant remainder modulo constant proof sketch show bounds number interactions probability error zeroing counter fundamental operation leader marks one agent timer waits one following two events 1 encounter agent nonzero component case agents component set zero 2 k consecutive encounters timer case leader concludes zeroing operation com plete bound expected number interactions follows directly lemma 6 calculate probability error note failure occurs leader encounters timer k times row encounters every agent nonzero component probability leader encounters timer k times row given members population nonzero component want compute f0 solving recurrence eventually deriving simplified show f0 1 probability error bounded p n o1n k1 log n achieve operations elaborate zeroing operation follows 1 increment collection counters decrement source counter copy source value destinations 2 increment another counter c times decrement source counter multiply source counter c 3 increment another counter c decrements source counter divide source counter c simultaneously find value modulo c analysis interaction error bounds similar elect leader unique leader input configura tion possible establish one using ideas live bit parity majority protocols section 41 timer mark section 61 global start signal every agent receives input remembers duration com putation sets live bit equal 1 clears timer mark indicating timer agent whose live bit equals 1 begins initialization phase marks first nontimer agent encounters timer attempts initialize every agent uses event encountering timer k times row determine end initialization phase course first every agent attempting run initialization phase general chaos whenever two agents live bit equal 1 encounter one loser sets live bit 0 winner keeps live bit 1 loser already marked timer winner waits encounters timer turns back nontimer proceeding winner restarts initialization phase creating another timer already released one initialized agents live bit equal 0 revert state representing input live bit retain timer status agent live bit equal 1 completes initialization phase begins computation eg simulating counter machine preceding section computation encounters another agent live bit equal 1 two proceed indicated one setting live bit 0 restarting initialization phase appropriate housekeeping ensure retrieval extra timer period unrest lasting expected n 2 inter actions one agent live bit equal 1 interaction eliminating last rival lucky winner succeed initializing agents high probability one timer popu lation proceed computation unique leader counter machine halts unique leader propagate fact along output function one output computed agents errors final sim ulation output every configuration rest computation correct shown carry operations counter machine high probability using standard construction due minsky 15 simulate randomized logspace turing machines high probability corollary 8 let fx function randomized log space input x represented unary fixed c population protocol n mem bers computes fx x n probability error c expected time polynomial n 62 simulating randomized population protocol section show either deterministic polynomial time randomized logarithmic space sucient recognize predicates computable probability least 12 population protocol random pairing suppose population protocol computes predicate probability least 12 p computed polynomialtime turing machine assume string x symbols x represents input assignment x n represents input length population size input x polynomialtime turing machine construct matrix representing markov chain whose states multiset representations population configurations reachable ix since n q solving stationary distribution states turing machine determine set configurations probability greater 12 output must correct turing machine writes common output output tape halts also assumptions p computed randomized turing machine probability 12 using space olog n randomized turing machine simulates population protocol using finite number olog nbit counters keep track number members population state using coin flips simulates drawing random pair population members updating counters according transition function running simulation long enough randomized turing machine almost certain terminal strongly connected component states markov chain point turing machine halts writes output current configuration output tape wait suciently long randomized turing machine allocates counter clog n bits flips coin simulated interaction adding 1 counter heads clearing counter tails simulation stopped counter overflows least n c consecutive heads gives expected number simulated interactions termination least 2 n c shown theorem 9 set predicates accepted randomized population protocol probability 12 contained p rl 7 related work petri net finite collection tokens may occupy one finite set places transition rules specify tokens may move place place 4 viewing states population protocol places population members tokens models also interpreted particular kinds petri nets randomized petri nets introduced volzer 16 using transition rule depend number tokens input place case conjugating automata chemical abstract machine berry boudol 2 abstract machine designed model situation components move system communicate come contact based metaphor molecules solution governed reaction rules concept enforced locality using membranes confine subsolutions allows machines implement classical process calculi concurrent generalizations lambda calculus ibarra dang egecioglu 10 consider related model catalytic p systems show purely catalytic systems one catalyst define precisely semilinear sets also explore models equivalent power vector addition systems relationships models intriguing topic brand zafiropulo 3 define model communicating processes consisting collection finite state machines communicate via predefined fifo message queues focus general properties protocols defined model possibility deadlock loss synchronization milners bigraphical reactive systems 14 address issues modeling locality connectivity agents two distinct graph structures work primary focus upon expressiveness models whereas consider issues computational power resource usage 8 discussion open problems addition open problem characterizing power stable computation many intriguing questions directions suggested work one direction explored 1 define novel storage device urn contains multiset tokens finite alphabet functions auxiliary storage finite control input output tapes analogous pushdown work tape traditional models access tokens urn uniform random sampling making similar model conjugating automata primarily considered case complete interaction graph shown theorem 9 provides least computational power weaklyconnected interaction graphs stable computation model question characterizing power stable computations particular restricted interaction graphs remains open also consider interaction graph part input ask interesting properties underlying graph stably computed population protocol problem may applications analyzing structure deployed sensor networks interesting restriction model consider oneway communication two agents teraction transition function restricted 4 see 5 6 surveys petri nets change state responder interaction keeping state initiator although still protocols decide whether number 1s input least k condition appears restrict stably computable predicates severely models paper assume snapshot inputs taken global start signal received model accommodating streaming inputs typically assumed sensor networks would interesting assumed uniform sampling pairs interact applications may make sense consider sampling rules one idea weighted sampling population members sampled according weights possibly depending current states conjecture reasonable restrictions weights weighted sampling yields power uniform sam pling sampling rules might based accurate models patterns interaction populations interest interaction rules consider deterministic specify pairwise interactions happens rules nondeterministic specify interactions larger groups allow interaction increase decrease population give bounds expected total number interac tions resource measures may appropriate applications many applications interactions happen parallel total number interactions may well correlated wallclock time defining useful notion time challenge alternatively consider number interactions least one state changes might correlated energy required computation bounds finite even stable computation model expected bounds smaller conjugating automata model 9 acknowledgments authors wish thank richard yang valuable advice regarding ideas david eisenstat parity construction discussions anonymous reviewers thoughtful comments suggestions 10 r urn automata chemical abstract machine communicating finitestate machines simple game study trust distributed systems decidability complexity petri net problemsan introduction decibility issues petri nets survey lightweight sensing communication protocols target enumeration aggregation mobility increases capacity ad hoc wireless networks systems nondeterministic space closed complementation directed di tag tiny aggregation service adhoc sensor networks bigraphical reactive systems basic theory computation finite infinite machines randomized nonsequential processes collaborative signal information processing information directed approach tr nondeterministic space closed complementation chemical abstract machine communicating finitestate machines directed diffusion mobility increases capacity ad hoc wireless networks randomized nonsequential processes decidability complexity petri net problems introduction lightweight sensing communication protocols target enumeration aggregation catalytic p systems semilinear sets vector addition systems ctr david pritchard santosh vempala symmetric network computation proceedings eighteenth annual acm symposium parallelism algorithms architectures july 30august 02 2006 cambridge massachusetts usa dana angluin james aspnes david eisenstat stably computable predicates semilinear proceedings twentyfifth annual acm symposium principles distributed computing july 2326 2006 denver colorado usa
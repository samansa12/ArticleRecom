relating communicating processes different interfaces present implementation relation intended formalise notion system built communicating processes acceptable implementation another base target system event two systems different interfaces treatment clear applicability software development process interface implementation component may expressed different level abstraction interface relevant specification componenttechnically processes formalised using hoares csp language standard failuresdivergences model implementation relation formulated terms failures divergences implementation target processes interface difference modelled endowing implementation relation parameters called extraction patterns intended interpret implementation behaviour target behaviour suitably constrain former connection wellformedness deadlock propertieswe extend results previous work replace implementation relations previously presented single improved scheme also remove restrictions previously placed upon target processes two basic kinds results obtained realisability compositionality latter means target composed several connected systems may implemented connecting respective implementations former means target implementation fact interface implementation relation satisfy collapses standard implementation preorderwe also show represent processes extraction patterns manner amenable computer implementation detail graphtheoretic restatement conditions defining implementation relation algorithms automatic verification easily derived b introduction software development process often involves refining highlevel specification lowerlevel concrete implementation process algebraic context 8 16 18 specification implementation may represented processes notion process q implements process p based idea q deterministic equivalent p terms chosen semantics following shall also refer specifications target base systems jburton mkoutny gpappalardo process refining target implementation also permits control structure latter changed case q said implement p twofold sense q describes internal structure p concrete detailed manner still ii new structure conceptually hidden q p exhibit behaviour external interface assumed indeed standard notions refinement 8 16 18 interested behaviour observable interface processes require interfaces specification implementation facilitate comparison yet deriving implementation specification often wish implement abstract highlevel interface actions lower level detail concrete manner example channel connecting q another component process may unreliable may need replaced pair channels one data one acknowledgments q may liable fail behaviour may replicated new component communication channels avoid single channel becoming bottleneck 13 scenario one major historical motivations behind current work 11 15 may simply case highlevel action p rendered concrete hence implementable form result interface implementation process may exhibit lower dierent level abstraction specification process process algebraic context dealing phenomenon interface dierence necessitates development rensink gorrieri 17 termed vertical implementation relation correctly capture nature relationship holding specification implementation whose interfaces dier collapse standard horizontal one whenever interfaces happen coincide within fd failuredivergence model csp 9 pioneered approach works like 11 12 15 whose results present one introduces major advances argued conclusions treatment deals interface dierence using notion extraction pattern device interprets behaviour system level communication traces relating behaviour set channels implementation behaviour specific channel specification addition allows behaviour implementation suitably constrained connection eg wellformedness input traces deadlock properties set extraction patterns relating interface implementation process specification appears formal parameter implementation relation develop consider potential applications approach outlined ver ification order deduce two light natural restrictions must placed upon sensible vertical implementation relation indeed met presented work suppose specification system form set events synchronization among p components takes place correspondingly let implementation system q general communication relating communicating processes 3 interface need p q assumed coincide q p result would possible verify directly using standard horizontal relation whether q implements p however wish verify q implements p using compositional ap ie verifying q two related motivations choice begin gives us means tackle state explosion problem furthermore allows us verify correctness individual components isolation without needing know advance structure network deployed hence first requirement implementation relation ie compositional said sense introduce second requirement remark q component established implement respective p composition q known compositionality implement p according implementation relation introduced new relation meaningful q also implement p standard horizontal sense recall interfaces q p words require implementation relation collapse standard horizontal implementation relation event specification implementation processes interface approach means communication channels implementation uninterpreted call property accessibility realisability following addition presenting implementation relation meets criteria set also detail graphtheoretic restatement implementation relation conditions derive algorithms automatic verification paper organised follows next section introduce basic notions used throughout paper section 3 first introduce extraction patterns central notion defining interface implementation section 4 presents implementation relation section 5 details may represent extraction patterns manner amenable computer implementation develops results allowing automatic verification implementation relation section 6 summarises results compares related works proofs included appendix preliminaries represented paper using failuresdivergences model communicating sequential processes csp 9 18 formal model description concurrent computing systems csp process regarded black box may engage interaction environment atomic instances interaction called actions must elements alphabet process trace process finite sequence actions process observed engage paper structured actions form bv used v message b communication channel every channel b b message set b 4 jburton mkoutny gpappalardo set v bv valid action define b alphabet channel b assumed b always finite nonempty following notations similar 9 u 1 2 traces b disjoint sets channels set actions nonempty sets traces trace whose ith element length n trace obtained appending u set traces actions including empty trace set traces denotes prefix relation traces u u u prefixclosure prefixclosed tb trace obtained deleting actions occur channels b sequence traces strict f use model csp process p triple p p p nonempty finite set actions p failures subset p pp p divergences subset p moreover denotes traces p conditions imposed components csp process given csp1 p nonempty prefixclosed set csp2 r p r p csp3 r p p satisfy p r p csp4 p u r p u p r p associate p set channels p stipulate alphabet p p thus shall able identify p triple p p p lieu p p p fundamental device compare csp processes failuresdivergences semantical model refinement order defined q p q p q p intuitively means q least good perhaps better p actual deployment conceivable environment assume base processes nondiverging csp processes restriction placed upon base processes treated using implementation relation presented section 4 csp operators purposes neither syntax semantics whole standard csp needed essential parallel composition processes hiding communication set channels examples also use deterministic choice p q nondeterministic choice p q renaming channels p b b prefixing p see 9 18 also appendix parallel composition pq models synchronous communication processes way free engage independently relating communicating processes 5 action others alphabet engage simultaneously actions intersection alphabet formally parallel composition commutative associative use p 1 p n denote parallel composition processes p 1 p n let p process b set channels p pb process behaves like p actions occurring channels b made internal formally pb df hiding associative pbb networks processes processes p 1 p n form network channel shared two define p process obtained taking parallel composition processes hiding interprocess communication ie process p 1 p n b b set channels shared least two dierent processes p network composition commutative associative result network obtained first composing processes subnetwork composing result remaining processes moreover order processes composed matter failure model csp process p identified pair p p former property hold whence need complicated divergence model partition channels process p input channels p output channels p assumed two processes network common input channel common output channel input output channel preserved network composition diagrams representing processes outgoing arrows indicate output incoming arrows indicate input channels 1 3 extraction patterns section first explain basic mechanism behind modelling behaviour abstraction provide formal definition extraction patterns examples deliberately simple order better convey basic ideas rather demonstrate wider applicability approach noted input output channel process general purely syntactic notion semantic properties therefore inferred 6 jburton mkoutny gpappalardo snd buf c e snd buf c r b snd buf c r c fig 1 two base processes implementations consider pair base processes snd buf shown figure 1a snd generates infinite sequence 0s infinite sequence 1s depending signal 0 1 received input channel c beginning execution buf buer process capacity one forwarding signals received input channel terms csp snd df buf df snd suppose signal transmission two processes implemented using two channels r shown figure 1b transmissions duplicated two copies sent along r snd sends duplicated signal buf accepts single copy signal passes ignoring one simple scheme clearly works buf suppose transmission signals imperfect two types faulty behaviour occur snd 1 df snd stop df snd snd communication channel blocked words snd 1 break completely refusing output signals snd 2 fail way although channel dead r still transmit signals 2 since 1 buf follows snd 2 much better implementation snd process snd 1 analyse dierences behavioural properties two processes time introduce informally basic concepts used subsequently start observing output snd 2 thought adhering following two rules transmissions r consistent wrt message content set traces r satisfying property denoted dom reliable guarantee output produced snd 1 satisfies first rule fails satisfy second one behaviour allows channels blocked express could used model following situation order improve perfor mance slow channel replaced two channels highspeed yet unreliable channel slow reliable backup channel r relating communicating processes 7 dierence formally need render two conditions form precise notation capture relationship traces snd snd 2 employ extraction mapping extr trace r returns corresponding trace example keeping mind duplicates signals ignored receiving process s1 r1d1 s1 r1 s0d1 d1 notice extraction mapping need defined traces satisfying r1 ie dom observe view r2 traces dom may regarded incomplete example s1 r1 s0 trace since channel r reliable duplicate s0 ie r0 bound eventually oered transmission set traces dom ie principle may complete denoted dom 3 example dom contain traces dom transmission overtaken r 4 although play central role extraction mapping alone sucient identify correct implementation snd presence faults since one also needs ability relate refusals snd 1 snd 2 possible refusals base process snd however much harder relating traces suppose attempted extract refusals snd 2 using extr would s0 snd 2 extr snd indicates crude extraction refusals going work need sophisticated device case comes form another mapping ref constraining possible refusals process exhibit channels hidden composed system q given trace precisely sender process admit refusal disallowed ref extracted trace extrt admits target process refusal communication corresponding channel moreover trace complete ie dom example hand roughly amounts stipulating unfinished communication cannot time refuse r0 r1 3 general dom pref dom meaning interpretable trace least theory chance completed 4 another example whole sequence events a1 ak extracted single event ie a1 k a1 ak consider transmission complete unless whole sequence a1 ak transmitted 8 jburton mkoutny gpappalardo finally stressed ref gives refusal bound sender side precisely process implements sender target process enough since want rule deadlock communication sender receiver localised set channels possible stipulate receiver side refusal combined refusal allowed ref yield whole alphabet channels used transmission networks processes clarity intuition behind detail implementation relation presented section 4 detailed description extraction patterns presented respect notion constraining refusal bounds gleaned considering specification implementation systems discussed section 1 considered specification system implementation system wish ensure r q implies r p relating traces technically dicult using extraction mapping introduced however ensure implication holds dicult general must find component failures q may contribute failure composed system q components contribute failure q union refusal sets contains actions hidden composition get q obviously dicult check local failures property problem use refusal bounds deals general two component processes keep refusals within bounds specified ensure composition always able execute least one action channels composed state reached always unstable due fact internal action enabled none local failures contribute failure composed process local failure may contribute global failure q local failure must correspond way local failure corresponding specification component general approach taken say comparison take place behaviour implementation component complete sense behaviour complete refusal bounds may breached meaning local failures behaviour complete cannot play role forming failure system q sensible anyway since fact behaviour incomplete implies implementation highlevel action begun completed obviously wish allow system deadlock middle implementing action atomic highlevel general refusal bounds may thought ensuring kind liveness progress sets channels upon composition occur implementation components composed get full system q since channels composed upon hidden progress enforced manifests final system occurrence internal transition leads instability states internal transitions enabled relating communicating processes 9 means states contribute failure q may able force progress complete behaviour ensure progress possible corresponding channel specification component lack progress internal channels leads stability fact relevant state give rise failure p 31 another example previous example thought modelling failstop communication two processes failstop channel next example dierent employs fault tolerant mechanism based message retransmission used illustrate point implementations forced preserve intuitive direction transfer messages suppose communication implemented using two channels r r data channel feedback channel used pass acknowledgments moreover assumed given message sent twice since retransmission always succeeds leads simple protocol incorporated suitably modified original processes resulting implementation processes shown figure 1c snd buf given snd df buf snd buf auxiliary processes defined thus df buf df df may observed snd one way showing would compose two pairs processes prove equality using eg csp laws 9 would straightforward snd buf less snd least hand however results paper allow us proceed compositionally show snd buf implementations respective base processes according suitable extraction patterns derive desired relationship using general results developed section 4 32 formal definition notion extraction pattern introduced 11 12 slightly modified well simplified 5 relates behaviour set channels implementa 5 define basic extraction pattern terminology 11 12 also allowed sets target channels moreover one also use partial inverse extraction mapping jburton mkoutny gpappalardo tion process channel target process two main functions interpretation behaviour necessitated interface dierence encoding correctness requirements extraction pattern tuple ep df satisfying ep1 b nonempty set channels called sources b channel called target ep2 dom nonempty set traces sources prefixclosure denoted dom ep3 extr strict monotonic mapping defined traces dom every extrt trace target ep4 ref mapping defined traces dom every dom ref nonempty subsetclosed 6 family proper subsets b b dom r ref r ref already mentioned mapping extr interprets trace source implementation process terms trace channel b target process defines functionally correct ie terms traces behaviour source channels way domain mapping ref used define correct behaviour terms failures gives bounds refusals execution particular trace sequence source channels dom contains traces dom communication b may regarded complete processes may violate constraint refusals given ref traces extraction mapping monotonic receiving information cannot decrease current knowledge transmission b ref useful unfinished communication allow sender refuse possible transmission second condition ep4 rendering terms extraction patterns condition imposed csp processes impossible events always refused see csp3 various components extraction patterns annotated eg subscripted avoid ambiguity unless stated otherwise dierent extraction patterns disjoint sources distinct targets moreover lift three notions introduced set extraction patterns ep df df dom ep dom ep set traces channels respectively tb dom tb dom every n every ta dom ep b extr ep ta df extr ep u possibly empty u extr tb u note u well defined since extr monotonic finally mapping ref dom denote ref set x b every ref 6 family sets x subsetclosed x x implies x relating communicating processes 11 uninterpreted channels identity extraction patterns channels require extraction pattern interpret behaviour shall call channels uninterpreted channels called interpreted tuitively channels interface implementation specification uninterpreted channel c identified special degenerated extraction pattern df extraction mapping id identity c ref component left unspecified another extraction pattern order demonstrate snd buf implementations respectively snd buf need extraction pattern twice also observe channel c identity channel described ep twice extraction pattern b source channels b df target channel moreover ack nak remaining components defined follows dom u dom dom df extrt dv extrt intuitively extract d1 following two sequences communi cations r0 sack r0 snak r0 similarly d1 thus valid trace dom one concatenation series complete segments kind possibly followed initial fragment one trace latter true incomplete belongs dom dom otherwise belongs dom 4 implementation relation suppose intend implement base process p using another process q possibly dierent communication interface correctness implementation expressed terms two sets extraction patterns former sources q targets p used relate communication input channels p q latter serve similar purpose output channels let p base process figure 2 every df extraction pattern b b denote set first extraction patterns ep jburton mkoutny gpappalardo bm bmn bm bmn fig 2 base process p implementation q remaining n extraction patterns moreover df idch denote set uninterpreted channels b take process q input channels b 1 bm output channels bm1 bmn shown figure 2 thick arrows represent sets channels process denote set traces q belong domall dom q dom q sets failures q trace component belongs domall domall respectively intuitively dom q subsequently referred domain q set traces q actual interest consequently dom q set failures actual interest given failure r dom q say interpreted channel b blocked denote b blockedt r note cases signifies refusal bound imposed ref breached call q implementation p wrt sets extraction patterns denoted q p following hold dp trace q tin q dom dom q ge sequence dom q extr also sequence lc r dom q b blockedt r tb dom r dom q extr blockedt r r idch p interpret conditions following way dp expresses domain preservation property says trace q projected input channels interpreted must possible interpret projection output channels note condition simple relyguarantee property sense 7 df interpreted divergence freedom within domain q recall csp divergences signify totally unacceptable behaviour simply states applying trace extraction domain q yields traces p ge states unboundedly growing sequence traces domain q sequence traces unboundedly growing extraction notice however place restriction relative growth sequences means relating communicating processes 13 going outside bounds allowed refusals indicates communication given interpreted channel may seen locally completed notice also communication uninterpreted channel always seen locally com pleted finally states condition refusal extraction means trace locally completed channels blocking interpreted channel p q transformed refusal whole alphabet p moreover refusals uninterpreted channels q matched 41 realisability compositionality direct comparison implementation process q corresponding base process p possible dierence communication interfaces communication interpreted exactly way corresponds situation channels q p unin terpreted case simply denote q p directly compare semantics two processes question observed channels uninterpreted df states reduces theorem 1 realisability implementation relation collapses standard csp refinement event channels uninterpreted next result demonstrates implementation relation compositional sense preserved network composition operation taken realis ability result met requirements stated introduction means compositional verification event corresponding specification implementation component processes dierent interfaces theorem 2 compositionality let k l two base io processes whose composition nondiverging figure 3 x c def g h let epx set extraction patterns whose targets channel set x epgeph l k l f g fig 3 base processes theorem 2 14 jburton mkoutny gpappalardo hence implementation relation preserved network composi tion restriction network base processes designed divergencefree way however latter standard requirement csp approach recall divergences regarded totally unacceptable example section 3 shown snd ep c twice snd buf hence theorem 2 snd theorem 1 snd 5 verifying implementation relation extraction patterns processes may infinite objects therefore need means represent finite way order allow computer implemen tation deal processes use standard device transition system extraction patterns represented novel notion extraction graph 51 communicating transition systems purposes paper simply assume process given form labelled transition system without worrying representation obtained 7 communicating transition system tuple cts df set states nodes v 0 v initial state c finite disjoint sets channels c represent input output channels cdv set labelled directed arcs called transitions distinguished symbol denoting internal action use following v w denote v w env calling enabled v belongs set v stb stable states w denote v w v v every v v shall assume cts finite ie v finite implementation relation want verify algorithmically expressed denotational semantics csp must know derive information divergences traces failures given cts communicating transition system 7 obtained eg using operational semantics defined csp 18 relating communicating processes 15 tuple following hold df note divergence represented cycle composed labelled transitions reachable initial state proposition 3 let cts communicating transition system 1 pcts csp process 2 provided figure 4 shows graphs four communicating transition systems dicult check base process p cts representation cts later modified applying normalisation procedure detailed 18 result given finite cts denoted cts n deterministic ie v w w together mapping nodes v nodes cts v 0 p 0 respectively initial states cts cts n 52 extraction graphs turn representation extraction patterns extraction graph tuple eg df nonempty finite set channels b channel v set nodes v b b v set labelled arcs v 0 v initial node mapping returning every node v nonempty subsetclosed family 8 proper subsets b v intuitively corresponds ref v indicates traces dom use following notation v w denote v n 8 intended concentrate basic ideas behind verification algorithms simplified several issues practical implementation would need address eg v could represented set maximal elements jburton mkoutny gpappalardo cts snd d1 d1 cts buf d1 d1 r1 r1 e1 r1 fig 4 communicating transition systems representing csp processes used throughout paper initial states white centres v every v v impose following restrictions every node v eg1 w eg2 v w v eg3 r v b satisfying v define extraction pattern extraction graph represents extraction graph set traces df given following way relating communicating processes 17 ut eg2 every u domeg unique v v 0 ut v set extr eg u df point view practical implementation interested extraction graphs finite ie finite number nodes v note finiteness follows b finite eg2 proposition 4 ep eg extraction pattern conversely one easily see every extraction pattern ep extraction graph eg identity extraction pattern corresponding extraction graph eg c mapping c extraction pattern ep twice defined section 32 represented extraction graph eg twice shown figure 5 easy check ep eg twice twice example df belongs domain dom ep twice follows existence path eg twice moreover pr0 r1 dom since v 1 v v1 v3 pr0 r1 v2 psack snak r1 v4 psack snak r0 fig 5 extraction graph eg twice v df representing extraction pattern twice rest paper assume extract one event single event source channels ie every extraction mapping trace domain jburton mkoutny gpappalardo terms extraction graphs means 1 whenever v w assumption introduced simplify presentation could omitted cost slightly complicating losing subsequent results 53 unambiguous ctss implementation processes extraction patterns extraction graphs defined channels base process p channels implementation process q result one eg usually required interpret behaviour implementation process q whole moreover possible cts representing q ambiguous sense explained respect interpretation terms egs let us consider base process buf modelling buer capacity one input channel output channel e defined section 31 modelled communicating transition system cts buf shown figure 4 let us also consider two extraction patterns given extraction 2 first extraction graph df identity extraction graph uninterpreted channel second one sources r target e given figure 6 note unlike previous example input channel buf uninterpreted communication output channel e implemented using simple pingpong communication protocol w0 psack r0 psack r1 w1 w2 pr0 r1 fig 6 extraction graph eg 2 v df would like verify implementation conditions respect ep 1 process q q df q df r whose behaviour described communicating transition system cts shown figure 7a ie although dicult see q ep 1 buf may clear needs done verify using communicating transition systems extraction graphs particular suppose want verify possible attempt would replace arc annotations cts extracted version given corresponding extraction pattern could done actions except sack extract either e0 e1 depending previous actions executed process thus cts ambiguous relating communicating processes 19 representation q wrt extraction graph eg 2 note problem caused wish represent extraction mapping traces traces terms individually labelled arcs node cts needs encode appropriate history reaching initial state case x 3 reached two dierent ways d0 d1 imply dierent interpretation arc x 3 solution propose remove ambiguity suitably modifying cts precisely split node x 3 cts separate two arcs incoming obtaining shown figure 7b unambiguously interpret arc annotations leads graph g shown figure 7c verify holds suces check traces generated g also generated cts buf x3 d1 d1 b d1 d1 c fig 7 disambiguating implementation buer capacity one following algorithm makes construction precise generating equivalent unambiguous cts given cts set extraction graphs algorithm 1 df extraction graphs b mutually disjoint b distinct moreover let communicating transition system algorithm generates communicating transition system cts u two steps jburton mkoutny gpappalardo step 1 first generate labelled directed graph g set nodes node g arcs outgoing q derived outgoing v arc w cts proceed according exactly one following four cases 1 add transition q also set extrq df 2 arc v w eg 1 9 add transition q also set extrq df extrq df 3 c w v nothing 4 w v mark q unfinished node node assumed finished beginning step 2 g obtain communicating transition system cts u channels cts taking q 0 df initial node adding nodes reachable q 0 together interconnecting transitions reachable nodes marked unfinished reject cts u 11 algorithm executed cts representation implementation process q main characteristic definition nodes allows unambiguous interpretation arc labels extraction mappings cf proposition 5 practice one avoid generating whole graph g performing depth first search starting initial node q 0 nodes cts u visited graph g example figure 6 shown figure 8a indicate unfinished nodes restricting relevant subgraph comprising nodes reachable initial one obtain graph shown figure 8b isomorphic cts obtained informally note extrx 3 may state cts u regarded unambiguous proposition 5 let set extraction patterns generated eg q 0 ak q k cts u extr df 9 one eg since b mutually disjoint note extrq well defined single action eg2 2 11 since means traces generated cts u satisfy condition dp cf proof proposition 6 relating communicating processes 21 d1 d1 d1 d1 d1 d1 b d1 d1 fig 8 applying disambiguating algorithm 54 checking implementation conditions section outline check implementation conditions formulated terms denotational semantics csp using communicating transition systems extraction graphs assume following idch ep section 4 communicating transition systems representing p every n eg extraction graph ep eg cts u disambiguated version cts q algorithm 1 initial state q 0 normalised version cts p see section 51 initial state p 0 mapping given 1 first obtain testing dp done generating cts u testing df amounts checking presence loops graph cts u 22 jburton mkoutny gpappalardo proposition 6 q satisfies dp df cts u rejected see step 2 algorithm 1 nodes v w cts u v assume cts u successfully generated contain loops dp df hold q relation sim vcts u vcts n simulation cts u cts n every q p sim extrqa proposition 7 q satisfies simulation cts u cts n note also since cts n deterministic free exists simulation cts u cts n exists smallest one sim min one attempt construct minimal simulation sim min depthfirst traversal product vcts u vcts n starting q 0 arcs given first component nodes representing product construction successful set nodes reachable q 0 gives minimal simulation additionally assume q satisfies te testing next implementation condition ge amounts checking extracted loops graph cts u proposition 8 q satisfy ge nodes v 1 cts u v 1 finally every stable state denote set interpreted channels b proposition 9 q satisfies lc following satisfied every stable state 1 2 q p sim min v 1 n implies p satisfying blockedq idch enq first condition last proposition checked traversing graph cts u second condition checked occasion testing te relating communicating processes 23 6 conclusions work investigated notion system implementation implements another one base specification event interfaces dier issue obvious interest respect system design development interface refinement often major aspect added detail provided implementation compared specification proposed treatment based upon combined use standard csp process model 9 18 describe specifications implementations notion extraction pattern aimed capture semantics interface refinement specification implementation dier implementation relation required hold behaviour specification implementation latter interpreted according extraction patterns describe respective interfaces dier aspects present work significantly extends previous work 11 12 5 class admissible specifications enlarged include nondiverging csp process definition extraction pattern technically improved multiple implementation relation schemes previously proposed unified single one furthermore latter appears appropriate vertical implementation relation csp given realisability theorem 1 collapses standard horizontal implementation 9 words implementation sense work turns implementation standard sense soon intended specification possess interface ie interface refinement actually performed extraction patterns implementation relation identity ones worth noting implementation relation trimmed sense weak strong counterparts 12 fact much immaterial restricted base process class treated prevented straightforward extension approach encompass nondiverging base process manage implementation relation also shown useful verifica tion enjoys kind compositionality specification composed several connected systems may implemented connecting respective implementations theorem 2 means process verification may deal separately individual component processes avoids major cause state explosion problem permits bottomup style reuse verifications carried separately specific components framework hand interfaces implementation specification may dier compositionality together realisability ensures specification actually built plugging implementation suitable environment technical treatment issue provided would essentially adhere lines work 11 jburton mkoutny gpappalardo finally present work build preliminary results 4 based older implementation relations develop ecient algorithms automatically verifying present implementation relation pro cess take advantage compositionality allows us verify component implementation system separately respective specification component avoids point computeraided verification one great sources state explosion problem ie generation state space substantial subset product component state spaces basis mechanical verification render processes extraction patterns graphs communicating transition systems extraction graphs respectively enables us establish graphtheoretic characterization implementation relation directly derive ecient algorithms modular verification conditions dp df te ge lc whose conjunction amounts relation whole future work explore possibilities optimisation well including examples case study evaluate performance verification algorithms practice envisaged application areas range entire field distributed systems particular fruitful results expected realm fault tolerance exploiting experience accrued analysis nmodular redundancy 11 coordinated atomic actions 6 related work compare work presented paper approaches whose goal similar somehow related looking general issue behaviour abstraction approaches eg 2 describe system behaviour sequences state tuples internal component require every possible state sequence correct implementation exist one specification two sequences coincide deleting internal state component similar treatment presented 10 using infinite action sequences ie infinite traces instead state sequences interface specification must subset interface implementation required every trace implementation turned one specification deleting actions specifications interface two approaches comparable ones like eg 14 20 based abstraction hiding contrast notion abstraction essentially based interpretation traces set channels traces another channel abstraction hiding certainly useful unlike notion abstraction interpretation cater interface refinement essential tool system design interface displacement approach proposed 3 interesting similarities work 1 interface transducers play role comparable disturbers extractors 11 2 treatments constrain systems environments mutual refusals essential dierence treatment 3 geared refinement specification compound system whose components interact terface compound implementation whose components interact relating communicating processes 25 dierent typically refined interface refinement validated checking interface change acceptable appropriate sense compound implementation correct respect compound specification notion correct implementation however traditional hor izontal words 17 one compound specification implementation exactly interface dierent interfaces respective components interact hidden essentially interface displacement possible compare processes one side interface addition removal interface transducers serves parameter interface refinement abstraction refinement clearly complementary apt related formal framework work selected however noted many refinementbased approaches action refinement dating back 1 every high level action must refined precise behaviour made low level actions would appear kind refinement mainly suited design wellidentified implementation specification example employed contexts implementor decides replace actions b performed specification sequences 1 2 3 b 1 b 2 b 3 implementation see reason abstraction could used similar way believe also aords distinct benefit allows one stipulate example whenever implementation performs j actions occur construed occurring abstract level clearly suited modelling relative unpredictability faultprone environment important faulttolerant applications like nmodular redundancy eg 11 dicult see similar accomplishments could performed within treatments adhering action refinement approach similar remarks found rensink gorrieris work 17 aims overcoming limitations staying within realm action refinement solution like based upon parametric vertical implementation relation parameter refinement function conversely essentially abstraction mapping maintain approach decisive advantages action refinement based ones flexibility allows multiple implementations given specification dictate strict ordering low level actions implementing high level one simplicity require introduction concurrency model complex standard interleaving ones vertical implementation relation collapses standard horizontal one refinement identity deadlock properties carry abstract concrete level allows compositional verification sense approach endowed decision procedure verification implementation relation 26 jburton mkoutny gpappalardo highlighted merits simply remark also characterize approach present paper lack however least time proof system implementation relation decided nonetheless approach 17 dier greatly technical point view consequence dierent concurrency models em ployed respect noted csp model advantage firmly rooted intuitive notions like traces refusals two appealing consequences abstraction mappings defined natural fashion directly traces refusals ii need change model way purposes hand treatment 17 based upon bisimulation semantics refines actions processes customary action refinement result order regain flexibility tweak horizontal bisimulation quite bit order obtain intended vertical version course preference either approach respect may matter taste crucial issue comparison instead would assess extent approach 17 applicable faulttolerant systems sense highlighted see also 11 fact 17 actions refined deterministic free processes could indicate limitations expected field application finally respect 17 mention fact decision procedure may used restricted cases since verification concrete action explored implementation may necessary guess abstract action refining unless restrictions imposed also interesting compare implications dierences concurrency models underlying work 10 models action based 10 employs infinite traces caters asynchronous com munication contrast csp model finite traces refusals permitting asynchronous well synchronous communication enabling deadlock properties described result artificial constraint placed behaviour implementation system faulty channels need communicate asynchronously faulty modules within faulttolerant implementations need processes restricted class eg io certainly desirable order reflect faithfully unpredictable nature faults impossible model 10 models asynchronous communication hand fair add liveness sense 10 temporal logic cannot expressed finite traces however ability place constraints refusals generally deemed reasonable alternative csp philosophy approach 19 formal analysis faulttolerance quite dierent basically provides criterion whereby system albeit fault prone may abstractly viewed implementation correct specification system contrast 19 system study modelled using csp trace model may embed faultprone components externally observable behaviour must correct without filter abstraction relating communicating processes 27 acknowledgments first author supported epsrc grant would also like thank marta pietkiewiczkoutny comments earlier version paper r towards actionrefinement process algebras existence refinement mappings refining interfaces communicating sys tems verifying implementation relations event interface di implementing communicating processes event interface di compositional development event interface di enhancing tractability relyguarantee specifications development interfering operations algebraic theory processes communicating sequential processes compositional specification verification distributed systems two implementation relations correctness communicated replicated processing behaviour abstraction communicating sequential processes implementation reliable distributed multiprocess systems hierarchical correctness proofs distributed al gorithms towards theory replicated processing communication concurrency vertical implementation theory practice concurrency proving entailment conceptual state specifications dom ep prefixclosure dom ep extr ep monotonic strict extr ep every derivation every every suppose cts u rejected 1 q k stable holds tr communicating sequential processes hierarchical correctness proofs distributed algorithms proving entailment conceptual state specifications algebraic theory processes towards theory replicated processing communication concurrency refining interfaces communicating systems existence refinement mappings compositional specification verification distributed systems towards actionrefinement process algebras behaviour abstraction communicating sequential processes vertical implementation verifying implementation relations tracebased compositional reasoning fault tolerant systems implementing communicating processes event interface difference
complexityrestricted advice functions authors consider uniform subclasses nonuniform complexity classes defined karp lipton lenseign math 28 1982 via notion advice functions subclasses obtained restricting complexity computing correct advice also effect allowing advice functions limited complexity depend input rather inputs length investigated among results using notions described new characterizations npnpcap sparse b np restricted access np oracle c odd levels boolean hierarchy given consequence shown every set nondeterministically truthtable reducible sat sense rich j comput system sci 38 1989 pp 511523 already deterministically truthtable reducible sat furthermore turns np reduction classes bounded versions reducibility coincide odd levels boolean hierarchy b introduction fundamental paper karp lipton 23 introduced notion advice functions investigated nonuniform complexity classes denoted cf c class sets f class advice functions typical class ppoly poly set polynomially length bounded functions interest ppoly stems fact consists exactly languages computed polynomially sizebounded circuits 34 intuitively set cf solved machine type c gets addition input x advice fx f function f depending length x many researchers considered nonuniform classes function class f defined quantitative length restriction poly log see example 3 5 23 36 note f nonrecursive functions f therefore cf contains nonrecursive languages consider uniform language classes obtained imposing complexity bounds advice functions note kamper 22 investigates refinements original cf definition delimiting complexity proof sets ie special abteilung fr theoretische informatik universitt ulm oberer eselsberg dw7900 ulm germany supported part daad acciones integradas 1991 313aieeszk abteilung fr theoretische informatik universitt ulm oberer eselsberg dw7900 ulm germany work done part visiting university rochester supported part dfg postdoctoral stipend th 47211 nsf grant ccr8957604 daad acciones integradas 1991 313aieeszk sets correct advice contrast directly bound complexity computing correct advice concept able show characterizations well finer distinctions several complexity classes example show class np npsparse coincides class npoptpolog n subclass np log correct advice computable optp function 29 ie one interpret equality 11 stating exactly languages np npsparse computed following way input x length n first optpolog n precomputation takes place gets input 1 n logarithmically lengthbounded output precomputation passed along x subsequent np computation decides membership x motivated relativized separation p np baker gill solovay 2 exploiting fact np oracle machine ask superpolynomially many queries book long selman 11 introduced restricted relativizations np bounding number oracle queries various ways subsequently long 32 investigated relationship restricted access nondeterministic machines oracle full access sparse oracle set let np r class languages whose membership np witnessed oracle machine number potential oracle queries asked oracle polynomially bounded definition clear np npsparse contained np np r since also conp contained np np r np npsparse np np r different unless polynomial hierarchy collapses 21 considering proof equality 11 see let optpolog n advice function depend length input input get characterization np np r leads us define class cf defined way cf advice functions depending input thus obtain following characterization np np r characterizations 11 12 give insight difference restricted access np oracles full access sparse np sets seems notion cf appropriate concept studying different kinds truthtable reducibilities let sat k kary characteristic function sat p sat k ffifp class sets ktruthtable reducible np set known classes interleaved levels boolean hierarchy closed complementation classes different unless boolean hierarchy collapses class sets ktruthtable reducible np set evaluator np machine classes turn coincide odd levels boolean hierarchy giving first time charcterization levels boolean hierarchy terms reduction classes furthermore show np2k ktt np np ktt class sets nondeterministically ktruthtable reducible set np sense 35 1 whereas unbounded case sets nondeterministically truthtable reducible sat already deterministically truthtable reducible sat ie np np tt latter result also holds strong nondeterministic truthtable reducibility sn tt introduced long 31 ie show fa j sn satg paper organized follows section 2 introduces notation gives basic definitions section 3 prove mentioned characterizations np npsparse np np r show changing optpolog n larger function class fewoptp containing functions whose membership optp witnessed np transducer generates polynomially many different outputs increase power npoptpolog n npoptpolog n section 4 separate complexity classes relativized world main result separation poptpolog n p npsparseologn section 5 give several characterizations certain levels boolean hierarchy terms various complexity restricted advice function classes 2 preliminaries notation languages considered alphabet 1g string x 2 sigma jxj denotes length assume existence pairing function hdelta deltai sigma theta sigma sigma computable polynomial time inverses also computable polynomial time hdelta deltai extended encode finite sequences strings string hx set jaj denotes cardinality complement sigma gamma denoted n set strings length less equal n languages sparse polynomial p n number words length n pn let sparse class sparse languages set tally subset 1 let tally class tally sets assume reader familiar nondeterministic polynomialtime bounded oracle turing machines complexity classes see 4 36 fp class functions computable deterministic polynomialtime bounded turing transducer np transducer nondeterministic polynomialtime bounded turing machine every branch either accepts writes binary number 1 requiring np generator single valued rich 35 modified nondeterministic truthtable reducibility originally defined ladner lynch selman 30 output tape rejects set outputs generated input x denoted x krentel 29 defines np metric turing machine np transducer accepts every branch np metric turing machine input maximum minimum output generated input x accepting computation class optp 29 optimization functions defined np metric turing machine g class r functions natural numbers called restricting functions define subclass containing optimization functions f 2 optp length fx binary bounded jxj function r denotes class sets whose membership p np witnessed oracle machine making r 2 r rn many queries inputs length n case r singleton set frg simply write optpr respectively throughout paper assume every restricting function r function x 7 rjxj computable polynomial time karp lipton 23 introduced notion advice functions order define nonuniform complexity classes class c sets class f functions sigma sigma let cf class sets set b 2 c function h 2 f x 2 sigma note advice function h depends length x canceling restriction obtain class cf sets set b 2 c function h 2 f x 2 sigma definition cf subset cf class sets c class functions f fulfills condition h 2 f also x 7 h1 jxj special advice function classes considered literature poly exists polynomial p x jhxj pjxjg log ologjxjg 3 np npsparse versus np np r section show np npsparse characterized class npoptpolog n ie class sets accepted np machine advice logarithmically length bounded optp function turns related class np np r see definition coincides npoptpolog n latter two classes show also equal poptpolog n result krentel 29 identical p npologn definition 31 11 oracle turing machine string set oracle queries may ask input x using oracle ie set strings 2 sigma computation input x oracle oracle queried qmx set oracle queries input x using oracle ie asigma qm x set npr class sets l 2 npa whose membership witnessed machine number potential oracle queries polynomially bounded ie exists polynomial p jqmx aj pjxj x first theorem states language l accepted np oracle machine using np oracle way number potential oracle queries polynomially bounded l npoptpolog n ie membership l tested np machine gets along input precomputed value optpolog n function special case sparse containment strengthened npoptpolog n ie inputs length advice function yields result proof census argument similar used hemachandra 18 kadin 21 theorem 32 proof let np machine oracle np let p polynomial bounds running time show let r polynomial jqmx aj rjxj x np machine knowing size set qmx guess set note problem decide given strings x whether qmx np define function set since hx maximum output following algorithm input x guess k rjxj x holds x 2 sigma x 2 l hx hxi 2 b therefore l npoptpolog n ii let sparse r polynomial ja pn j rn n define function set similar argument proof x 2 l hx h1 jxj shows l npoptpolog n combining theorem 32 ii result balcazar schoning 5 follows every conp set nplog correct advice already computed optp function corollary 33 nplog show reverse containments theorem 32 make use following lemma states every optp function h computed deterministic polynomialtime oracle machine asking jhxj many queries np oracle lemma 34 29 optpr fp npr restricting function r corollary 35 proof theorem 32 remains show inclusions right left show let l npoptpolog n via np machine n optimization function h l accepted np machine computes deterministically binary search value h according lemma 34 asking olog n many queries np oracle simulates n without asking oracle queries since qmx polynomially bounded follows l np np r h function depends length argument hx computed binary search using tally np set g proves ii note proof shows every language npoptpolog n thus np np r fact accepted np oracle machine qmx polynomially bounded next lemma show np computation getting along input result hx optp precomputation transformed p computation precomputing one additional bit note bit actually depends x even hx depends length x lemma 36 npoptpr poptpr 1 function r proof let l npoptpr witnessed np set b optpr function define optpr1 function hx0 otherwise holds x hx set oddg p case proved analogously combining corollary 35 lemma 36 obtain characterization class np np r closure complementation note corollary 37 np np corollary 38 np np r closed complementation remark 39 results stated corollary 35 extended classes polynomialtime hierarchy 37 order define restricted relativizations sigmalevels polynomial hierarchy sigma c kr class sets l accepted kalternating polynomialtime turing machine 16 using oracle c jqmx aj polynomially bounded results stated corollary 35 extended opt c class optimization functions computable np transducer using oracle class c since sigma k opt sigma kgamma1 olog n included sharpens recent result 13 sigma sigma k sparse remark 310 advice even depending input provided optpolog n function increase power probabilistic class follows result toda 40 since ppoptpolog n coincides class ppfp npologn see lemma 34 clearly contained pp np r next consider uniform subclasses plog ppoly whereas proof corollary 35 ii also yields inclusion poptpolog n census technique theorem 32 cannot applied obtain reverse containment next theorem proved constructing long enough initial segments sparse np set optp computation underlying technique used mahaney 33 show np npsparse p np theorem 311 p npsparse poptp proof let machine sparse np set let p r polynomials p bounds running time js n j rn since hx maximum output following algorithm input 1 n guess k rpn x computation using oracle input x simulated p machine answering oracle questions according set h1 jxj let fewoptp class functions f 2 optp computed np transducer produces polynomial number different outputs clearly optpolog n fewoptp obviously proper inclusion however shown next theorem classes npoptpolog n npoptpolog n remain unchanged function class optpolog n replaced larger class fewoptp theorem 312 proof let l set npfewoptp via 2 np f 2 fewoptp let np metric machine f ie proof number different outputs polynomially bounded define function set easy see h 2 optpolog n b 2 np x l hx hxi b therefore l npoptpolog latter equality follows corollaries 35 part 37 proof ii analogous replace x 1 jxj technique used previous proof cannot applied show classes poptpolog n pfewoptp equal however proof poptpolog n p npsparseologn using binary search see proof corollary 35 ii refined show following theorem states set pfewoptp decided polynomial time querying sparse np oracle polynomially often theorem 313 pfewoptp p npsparse proof let f fewoptp let np transducer computing f using sparse np set oracle fx computed polynomial time determining first jout 1 n j applying prefix search find optimum value 1 n known relationships language classes considered section summarized diagram figure 31 e e phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi phi r phi phi phi phi phi phi phi phi phi phi phi phi fig 31 inclusion structure considered complexity classes thick lines indicate relativized separations see section 4 4 relativized separations since baker gill solovay 2 separated p np relative oracle relativizations important subject complexity theory section discuss inclusions figure 31 strict least relativized world since nonrecursive sets ppoly nppoly two classes clearly different recursive classes considered whether strict inclusions diagram figure 31 known inclusions however question whether proper linked central open problems complexity theory example result karp lipton sipser see 23 np ppoly implies collapse polynomial hierarchy second level follows ph 6 sigma 2 np contained classes left column figure 31 since holds relativized worlds since exists oracle separating ph sigma 2 24 follows relative oracle inclusions first second column proper similarly using result kadin 21 conp np npsparse implies p npologn since easily seen inclusion conp npoptp implies state following theorem theorem 41 ph 6 p np npoptp 6 poptp furthermore recent result toda 39 ph p pp follows beigel 7 constructed oracle p np separates p npologn p np direct proof see 14 cai et al 15 showed existence oracle relative boolean hierarchy infinite ie fact cai et al construct oracle way k tally test language conp holds every oracle set b 43 28 8 follows l since poptpk contained 2 k th level boolean hierarchy result optimal clearly boolean hierarchy proper complete sets since class poptpolog n complete sets contained bh relativized world boolean hierarchy infinite ie main result section separation classes poptpolog n p npsparseologn fact show fixed polynomial q relativization np contains sparse sets nonuniform class pq defined pfh j jhxj qjxjg theorem 42 every polynomial q exists set proof arbitrary set define sparse set la 2 np follows given n suitable choosen function ln partition 2 ln words length ln qn respect lexicographic ordering ln qn1 interval containing word put word la let w n enumeration sigma n lexicographic order let qn define np set clearly qn words length n ie la sparse construct set stages enumeration polynomialtime bounded turing machines running times stage g stage 1 choose n minimal ns algorithm figure 41 determines words length ln included done diagonalizing machine potential advice input length n let p machine show taking advice qlength bounded function accept la let index 2 potential words advice inputs length n stored advice execution forloop diagonalizes least half possible advice since log2 becomes empty end algorithm construction guarantees every advice jaj qn exists k qn hw ns ns therefore suffices show algorithm always find 2 lns query every execution forloop every advice added set query ie thus lns nsqns contains potential advice diagonalize query query freeze oracle queries construction k 1 qn w ns jaccj jrejj remains empty ie word acc advice w ns ns else put word lns word rej advice w ns ns choose 2 lns fyg fig 41 algorithm used proof theorem 42 ns choice n 0 corollary 43 9a np using kolmogorovargument corollary 43 already shown hema chandra 19 immediate consequence corollary 43 existence oracle separating poptpolog n p npsparseologn corollary 44 5 bounded advice versus boolean hierarchy levels boolean hierarchy build union boolean closure np ie smallest class sets contains np closed union intersection com plementation section give several characterizations odd levels boolean hierarchy first show np machines get advice value kary characteristic function sat k sat sat k evaluated ktuple computed input fp function accept exactly languages 2k 1th level boolean hierarchy true advice consists information many k words produced given input fp function sat cai et al 15 give several characterizations boolean hierarchy take following definition 51 set l kth level npk boolean hierarchy exist sets l np even union k1 npk levels boolean hierarchy denoted bh set denotes characteristic function k kary characteristic function k gives number k words phi k parity number ie phi 2 unbounded version k k clearly every set l 2 npk ktruthtable reducible sat ie l 2 following composition operator ffi takes precedence every set ktruthtable reducible sat npk 28 see also 8 thus since p sat closed complementation classes 51 different unless bh therefore ph 20 collapses interesting note p machine needs know parity number k queries sat order decide set p sat show next theorem first equality 52 also holds nondeterministic counterparts classes furthermore coincide 1th level boolean hierarchy since easily seen np phi sat contained p sat replace p np k 2 second equality 52 unless bh thus ph collapse open question whether also classes np phi sat k ffifp characterize levels boolean hierarchy denote bitwise ordering strings length ie theorem 52 proof let l np2k 1 exist sets l define function let set defined exist f2i j x 2 l 2i g j k holds x 2 l see observe exactly one set f2i j x 2 l 2i g cardinality fx namely g therefore l 2 np sat clear np sat remains show 1 adapt proof technique used buss hay 14 let l np sat exist set 2 np function f 2 fp x 2 l hx sat consider np sets k fx hx ai 2 ag easy see bm bm1 bm furthermore ag latter equality follows fact x 2 bm gamma bm1 one string 2 sigma k containing 1s fulfilling sat namely k fx therefore x 2 l x hemachandra 18 see also buss hay 14 shown classes coincide slight modification proof get following corollary yielding characterization p npologn corollary 53 p sat beigel 8 shows fp theorem 52 following theorem 54 follows equation remains valid p replaced np theorem 54 restates observation 26 sat complete optpk theorem 54 26 corollary 55 np2 ladner lynch selman 30 transformed recursion theoretic truthtable reducibility complexity theory also give definition nondeterministic truthtable reduction following way nondeterministically truthtable reducible b exists np transducer g generator np machine e evaluator every x exists branch gx yielding output accepts known definition equivalent nondeterministic turing reducibility 30 therefore lead new reducibility notion modify definition restricting generator g singlevalued np transducer ie output must every accepting branch let npsv set functions computed singlevalued np transducers 11 reducibility first appeared 11 denoted npunifall explicitely called nondeterministic truthtable reducibility book ko 10 subsequently book tang 12 rich 35 introduced following terminology definition 56 set nondeterministically truthtable reducible b nondeterministically ktruthtable reducible b npsv class c sets let np c class fa j 9b tt bg sets np tt reducible set c let np c ktt bg 11 shown exist recursive sets b np 6 np tt b means np tt properly stronger np question tt properly stronger np tt equivalent p np problem 11 35 however see corollary 58 every set nondeterministically truthtable reducible npcomplete set b also deterministically truthtable reducible b ie np thus surprising result definition 30 nondeterministic truthtable reduction weak definition rich seems strong yield new reduction class fl j l p tt satg satg consequence theorem 57 get characterization odd levels boolean hierarchy terms nondeterministic ktruthtable reducibility notion theorem 57 proof see let f npsv define np set proof ii define np set observe sat fx read b 0 answers parallel queries polynomial bounding running time np transducer computes f corollary 58 ktt k 1 tt remark 59 book tang 12 especially consider olog n bounded version np log ntt nondeterministic truthtable reduction obtained logarithmically bounding number queries produced npsv generator follows appropriately modified versions theorem 57 corollary 53 lemma 36 log log class also considered wagner 42 denoted p np olog n shows coincides class languages fulltruthtable reducible 2 sat consequence follows np log ntt sat full truthtable reducible sat remark 510 book tang 12 generalized nondeterministic truthtable reducibility sigma k truthtable reducibility giving generator evaluator access sigma kgamma1 oracle sigma k truthtable reducible b class c sets let sigma c ktt class fa j 9b 2 bg corollary 58 ii generalizes ie every set sigma k truthtable reducible set sigma k already determini stically truthtable reducible set sigma k 2 set fulltruthtable reducible 28 14 set b function g 2 fp x gx form ha holds x 2 number whose binary representation given b thierauf 38 showed allowing generator nondeterministic truthtable reduction produce polynomially many different outputs ie compute nppv function 11 increase class sets reducible sat theorem 511 38 let l set g nppv transducer e np set l p np tt end section proving also strong nondeterministic truthtable reducibility introduced long 31 applied sat powerful tt like definition ladner lynch selman 30 generator strong nondeterministic truthtable reduction produce exponentially many different outputs evaluator either accept outputs reject definition 512 31 strong nondeterministic truthtable reducible b b np transducer g p machine e x set g x nonempty hy x class sets c denote sn c tt class fa j 9b bg clearly sn tt lies strength p tt np long 31 showed sn properly stronger np constructing two sets b 6 sn np b question whether p tt properly stronger sn tt closely related two major open questions complexity theory 31 theorem 513 sn np tt proof let l sn np tt via generator g evaluator e set 2 np order decide membership given input x suffices find whether output hy gx e accepts hx becomes np problem provided maximum number answers outputs hy gx given along input x precisely define function let b set defined holds x x 2 l hx hxi 2 b ie l npoptpolog note proof theorem 513 remains true evaluator e allowed np machine acknowledgments helpful conversations suggestions work grateful v arvind l hemachandra u schoning also thank two referees valuable suggestions r polynomial terse sets relativizations p nondeterministic witnesses nonuniform advice structural complexity bounded queries sat boolean hierarchy probabilistic polynomial time closed parity reductions sets truthtable reducible sparse sets quantitative relativizations complexity classes characterizing polynomial complexity classes redu cibilities note sparse sets polynomialtime hierarchy truthtable reducibility sat alternation journal association computing machinery computation times np sets different densi ties strong exponential hierarchy collapses personal communication polynomial time hierarchy collapses boolean hierarchy collapses p np sparse turingcomplete sets np turing machines take advice relativized polynomial time hierarchies exactly k levels complexity optimization problems comparison polynomialtime redu cibilities strong nondeterministic polynomialtime reducibilities restricting size oracles compared restricting access oracle sparse complete sets np solution conjecture berman hartmanis simultaneous resource bounds positive relatvizations p polynomial time hierarchy pp hard polynomialtime hierarchy restricted relativizations probabilistic polynomial time restricting access nporacle bounded query computations boolean closure np tr ctr richard chang bounded queries approximations boolean hierarchy information computation v169 n2 p129159 september 15 2001
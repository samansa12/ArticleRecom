software evolution componentware using requirementsassurances contracts practice pure topdown refinementbased development processes sufficient usually iterative incremental approach applied instead existing methodologies however support evolutionary development processes well paper present basic concepts overall methodology based component ware software evolution foundation methodology novel wellfounded model componentbased systems model sufficiently powerful handle fundamental structural behavioral aspects component ware objectorientation based model able provide clear definition software evolution stepduring development evolution step implies changes appropriate set development documents order model track dependencies documents introduce concept requirementsassurances contracts contracts rechecked whenever specification component evolves enabling us determine impacts respective evolution step based proposed approach developers able track manage software evolution process recognize avoid failures due software evolution short example shows usefulness presented concepts introduces practical description technique requirementsassurances contracts b introduction todays software engineering methodologies paper originates research project a1 methods componentbased software engineering chair prof dr manfred broy institut fur informatik technische universitat munchen a1 part bayerischer forschungsverbund softwareengineering forsoft supported siemens ag department zt based topdown development process eg object modeling technique omt 27 objectory process 15 rational unied process rup 14 methodologies share common basic idea system development model system built stepwise rened renement step adds additional properties desired system model last model suciently ne consistent correct representation system consideration may implemented programmers even partly generated surely processes support local iterations instance rup allows iterations analysis design implementation however overall process still based renement steps improve specication model nally end desired system formal approaches like room 3 focus 4 concept renement even strict kinds process models involve severe draw backs initially customer often know relevant requirements cannot state adequately even states inconsistent requirements consequently many delivered systems meet customers ex pectations addition topdown development leads systems brittle respect changing requirements system architecture involved components specically adjusted initial set requirements sharp contrast idea building system truly reusable com ponents process take already existing components account beyond software maintenance lifecycle supported extreme critical instance nowadays maintenance takes 80 percent budget europes companies average 20 percent user requirements obsolete within one year 21 however software evolution basic concept currently well supported opinion partly due lack suitable overall componentware methodology respect software evolution methodology least incorporate following parts 26 common system model provides well dened conceptual framework componentware software evolution required reliable foundation based system model set description techniques componentware needed developers need model document evolution single component whole system development organized according software evolution process includes guidelines usage description techniques well reasonable evolution steps minimize costs software evolution systems based evolutionresistant ar chitectures architectures contain common basic infrastructure components like dcom 2 corba 22 java enterprise beans 16 even important businessoriented standard architectures evolution resistant last former aspects supported tools contribution work seen two different perspectives viewpoint specica tion methods constitutes sophisticated basic system model solid foundation new techniques areas software architectures componentware objectorientation software engineering per spective provides clear understanding software evolution steps evolutionary development process moreover oers new description technique called requirementsassurances contracts contracts rechecked whenever specication component evolves allows us determine impacts respective evolutionary step paper structured follows section 2 provides basic denitions model dynamics componentbased system next section section 3 specify observable behavior entire componentbased system based former denitions section 4 provide composition technique enables us determine behavior system behavior components section 5 complete formal model simple concept types types described development documents section 6 introduces view development documents evolution steps documents section 7 present concept requirementsassurances contracts model explicitly dependencies development documents section 8 provides small example show usefulness proposed concepts case software evolution short conclusion ends paper section elaborates basic concepts notions formal model componentbased systems system model incorporates two levels instancelevel represents individual operational units componentbased system determine overall havior distinguish component interface connection variable instances dene number relations conditions model properties instances typelevel contains normalized abstract description subset common instances similar properties although models componentbased objectoriented systems exist need improve evolutionary approach formal models like instance focus 4 temporal logic 17 strongly connected renement concepts cf section 1 furthermore methods contain well elaborated type concepts sophisticated description techniques needed discuss issues software evolution case evolution types descriptions usually evolved moreover practice formal methods applicable since formal models abstract provide realistic view todays componentbased systems architectural description languages like mils rapide aesop unicon less formal approaches summarized 5 introduce concepts components communication via connec tors consider behaviorrelated aspects component system componentbased system behavior limited communication pairs components also includes changes overall connection structure creation destruction instances even introduction new types runtime context componentware software evolution aspects essential dynamic changes system may happen construction designtime well execution runtime either control system initiated human developers approaches like prepost specications cannot specify mandatory external calls components must make restriction also applies meyers design contract 20 java modeling language jml 18 although especially targeted componentbased development int 7 string int 5 figure 1 component system behavioral aspects reason elaborated novel realistic model claim presented formal model powerful enough handle dicult aspects componentbased systems cf figure 1 dynamically changing structures shared global state last mandatory callbacks thus separate behavior componentbased systems three essential parts structural behavior captures changes system structure including creation deletion instances changes connection well aggregation structure variable valuations represent local global data space system enables us model shared global state component communication describes messagebased asynchronous interaction compo nents thus specify mandatory callbacks without problems following sections rst come de nitions three separate aspects behavior componentbased systems components basic building blocks componentbased system component possesses set local attributes set subcomponents set interfaces interfaces may connected interface via connections runtime basic building blocks created deleted order uniquely address basic elements componentbased system introduce disjoint sets variables id figure 1 shows componentbased system may change structure dynamically basic elements may created deleted alive new interfaces may assigned components assigned interfaces may connected deconnected interfaces connected new subcomponents may aggregated existing parentcomponents parent following denitions cover structural behavior componentbased systems note approach strong enough handle dynamic changing connections structures systems also mobile systems instance covers mobile components migrate one parent component another parent usually state space componentbased system determined current structure also values components attributes cf figure 1 values set possible valuations attributes parameters denoted essence mappings variables attributes parame ters etc values appropriate type valuation variables belong components characterizing state component allocation following denitions cover variable valuations componentbased systems later allow components change values components variables cf section 4 thus model shared global states wellknown objectoriented systems note elaborate underlying type system variables values assume appropriate one given component communication based existing formal system models eg focus 4 sequences messages represent fundamental units communication order model messagebased communication denote set possible messages set arbitrary nite message sequences within time interval components resp interfaces receive message sequences arriving interfaces resp connections send message sequences respective environment given following denition cf figure 1 used messagebased communication asyn chronous like corba oneway calls hence callbacks based asynchronous oneway calls explicitly specied within model one cannot model normal blocking callbacks usual objectoriented programming languages however observation shows callbacks need blocking calls often callbacks used make systems extensible layered system architectures occur calls lower higher layers known upcalls upcalls usually realized asynchronous events cf layers pattern 9 another representative application callbacks asynchronous events observer pattern 11 observer may notied via asynchronous events observed object changed sum believe callbacks supported model powerful enough model real componentbased systems assumption middleware supporting asynchronous message exchange available system snapshot based former denitions able characterize snapshot componentbased system snapshot captures current structure variable val uation actual received messages let snapshot denote type possible system snapshots connected parent allocation valuation evaluation let system denote innite set possible sys tems given snapshot snapshot 2 snapshot system 2 system 1 tuple capture current active sets components interfaces connections 1 remainder paper use shortcut whenever want assign relation x system 2 system component c 2 component say x variables current assignment interfaces components current connection structure interfaces current supersubcomponent relation ship current assignment variables components current values components nally current messages components similar related approaches 4 regard time innite chain time intervals equal length use n abstract time axis denote clar ity furthermore assume time synchronous model resulting simplicity generality means global time scale valid parts modeled system use timed streams ie nite innite sequences elements given main represent histories conceptual entities change time timed stream precisely stream discrete time elements set x element type nnf0g thus timed stream maps time interval element x notation x used denote element valuation x 2 x streams may used model behavior sys tems accordingly snapshot type system snapshot histories simply type behavior relation possible systems connected parent allocation valuation evaluation let snapshot snapshot behavior sys tem given snapshot history snapshot 2 snapshot timed stream tuples capture changing snapshots snapshot obviously couple consistency conditions dened formal behavior specication snapshot instance may require assigned interfaces assigned active component assigned alive furthermore components may connected via interfaces one component parent component parent component connections interfaces component also valid connected assigned parent parent b imagine almost innite set consistency conditions full treatment beyond scope paper resulting formulae rather lengthy deeper discussion issue found 1 previous sections presented observable behavior componentbased system behavior result composition component behaviors show coherence rst provide behavior descriptions single component practice transitionrelations adequate behavior description technique formal model use novel kind transitionrelation contrast predecessor state successor statethe presented transition relation relation certain part systemwide predecessor state certain part wished systemwide successor state let behavior c behavior behavior component component informal meaning tuple behavior c specied part systemwide predecessor state ts given rst snapshot component wants system systemwide successorstate next step given second snapshot consequently need specialized runtime system collects time step components wished successor states composes new welldened successor state whole system main goal runtime system determine system snapshot snapshot t1 snapshot snapshot set behavior relations behavior c components essence provide formulae calculate system behavior initial conguration snapshot 0 behavior relations behavior c external stimulations via messages free inter interfaces connected interfaces thus stimulated environment first calculate transitiontuples active components behavior alive true behavior c calculate transitiontuples active components actual system state let transition set transitiontuples could transition come nal formulae calculation system snapshot snapshot t1 need new operator relations operator takes relation x replaces tuples x tuples rst element tuples equal last able provide complete formulae determine system snapshot snapshot t1 snapshot t1 alive t1 assigned t1 connected t1 parent t1 allocation t1 alive t1 alive assigned t1 assigned connected t1 connected parent t1 parent allocation t1 allocation valuation t1 evaluation t1 evaluation intuitively spoken next system snapshot snapshot t1 tuple element tuple instance alive t1 function determined simply merging former function alive deltafunction 8 transition deltafunction includes wishes transitionrelations basic concepts relations covered previous sections provide mathematical denitions constituents componentbased system runtime however order present adequate model useful practical de velopment introduce concept type connection type variables type type innite set types type models common properties set instance abstract way ty pe assigns instance component inter face connection variables corresponding type let predicate innite set predicates might ever exist predicates boolean expres sions type functions instances type boolean instance component behavior c predicate type c one simplest predicate imagine provides direct mapping typelevel instancelevel predicate true arbitrary transition part component behavior dene functions provide abstract description existing types 3 2 standard notation denotes set mtuples result projection relation r arity r onto components 3 pa denotes powerset set 6 software evolution usually development system various development documents created development documents concrete descriptions contrast abstract descriptions linked types discussed last sections development document separate unit describes certain aspect view system development componentware typically following kinds documents structural documents describe internal structure system component structure component consists subcomponents connections subcomponents supercomponent eg aggregation inheritance uml class diagrams 23 architecture description languages 5 interface documents describe interfaces components currently interface descriptions eg corba idl 24 allow one specify syntax component interfaces enhanced descriptions also capture behavioral aspects use pre postconditions eg eiel 20 java modeling language 18 protocol documents describe interaction set components typical interactions messages exchange call hierarchies dynamic changes connection structure examples protocol descriptions sequence diagrams uml 23 extended event traces 6 interaction interfaces 7 implementation documents describe implementation component program code popular kind descriptions also use automatons like 28 12 kind greybox specications 8 especially componentware implementation component recursively described set structural terface protocol implementation documents development describe systemor exactly types systemby sets docu ments let doc innite set possible doc uments type componentbased system described set development documents semantics given set development documents simply mapping set documents set predicates thus dene semantic function assigns given set documents set properties characterizing system semantic mapping concrete descriptions system doc doc set predicates correct predicates equal predicates abstract description 2 type mally semantic mapping correct following documents sem doc sem doc figure 2 software evolution system development condition holds sem described description already discussed section 1 ability software evolve controlled manner one critical areas software engineering developers need support evolutionary approach based semantic function sem able formulate concept evolution step figure 2 shows three typical evolution steps system development evolution step sense causes changes set development documents within certain time step given functions type evolve call evolution step set documents doc renement condition sem evolve doc abstraction condition sem doc sem evolve doc strict evolution condition sem doc 6 sem evolve doc sem evolve doc sem doc sem evolvedoc total change condition sem doc sem evolve doc holds obviously pay attention strict evolution remaining paper use evolution strict evolution synonymous unless explicitly distinguish various kinds evolution steps detailed discussion dierences evolution renement steps found 26 contracts document changes via evolution step consequences documents rely evolved document clear normally developer causes evolution step check whether documents still correct concrete dependencies documents explicitly formulated developer usually go details concerned documents reason claim evolutionbased methodology must able model track dependencies various development documents reach goal make dependencies development documents explicit cur rently description techniques programming languages dependencies dierent documents modeled extremely rudimentary fashion instance uml 23 designers specify relation uses documents java 10 programmers use import statement specify one document relies another surely sophisticated specication techniques ex ist eg evolving interoperation graphs 25 reuse contracts 29 19 interaction contracts 13 evolving interoperation graphs provide framework change propagation single class changes graphs take account syntactical interface classes static structure class hierarchy system behavioral dependencies reuse contracts address problem changing implementations stable abstract specication evolution con icts scope inheritance dis cussed con icts component collaborations might helpful predict consequences evolving single component eects components entire system clear finally interaction contracts used specify collaborations objects although basic idea interaction contractsto specify behavioral dependencies objectsseems quite good suggestion approach takes neither evolution componentware suciently account interaction contracts strongly couple behavior specication component seen island behavioral dependencies components hence impacts evolutionary step determined contract b contract contract b contract assurances requirements figure 3 requirementsassurances contracts development documents component types avoid drawbacks support evolution based development process best propose decouple component island specication behavioral dependencies specication following two types functions allow us determine behavioral specication single component seen island intuitively function requires 2 requires calculates given set documents doc 2 pdoc set predicates component type ct 2 component type expects environment function assures 2 assures calculates set predicates component type provides environment need specialized description techniques model required assured properties certain component explicitly within development document description techniques must strongly structured least two additional parts capturing set required assured properties cf figure 3 requirements requirements part designer specify properties component needs environment assurances assurances part designer describes properties component assures environment assuming requirements fullled additional aspects specied formally given functions requires assures designer explicitly state behavioral dependencies components specifying component assurances guarantee requirements call explicit formulated dependencies require mentsassurances contracts racontracts figure 3 illustrates usage contracts three development documents include additional requirements white bubble assurances black bubble parts developers explicitly model dependencies components racontracts shown double arrowed lines formally racontract mapping required properties component assured properties components given contract contract 2 contract predicate fulfilled 2 fulfilled holds required properties component assured properties components fulfilled ctrequires ctdescribed ct ctdescribed ctg xdescribed xg case software evolution designer tool recheck whether requirements components rely assurances evolved component still guaranteed formally tool recheck whether predicate fulfilled ctrequires ctevolve described ct still holds instance figure 3 component c changed time designer validate whether contract b still holds exactly check whether requirements component c still satised assurances component advantages racontracts come fully validity adequate description techniques specify requirements assurances components within development documents next section provide small sample including simple description techniques prove usefulness racontracts illustrate practical relevance proposed ra contracts want discuss short example consider windows help screen shown figure 4 contains two components text box list box control element content text box restricts presented help topics list box whenever user changes content text boxsimply adding single characterthe new selection help topics immediately presented list box component helptext component helplist figure 4 short sample windows help screen simple implementation help screen may contain two components helptext helplist collaboration two components usually follows observer pattern 11 case ob servable component helptext changing parts state observing components helplist notied components system often evolve make windows help screen evolution resistant one specify help screen modular fashion thus use two dierent kinds descriptions proposed section 7 descriptions behavior single component seen island start component descriptions behavioral dependencies components start racontract example description technique use keywords written capital letters component island specication consists two parts specication rst part requires part containing interfaces component needs interface required predicates syntax behavior explicitly specied second part assures part capturing interfaces component provides environ ment interface assured predicates syntax behavior explicitly described notation semantic within parts equal one used interaction contracts 13 language supports actions sending message component c denoted c change value v denoted v ordering actions explicitly given operator ifthenelse construct left unspecied operator k language also provides construct ho repetition expression e separated operator variables v satisfy c start textual specication requirements assurances two components helptext helplistthe components island spec ication component helptext requires interface observer methods assures interface textbox locals methods component helptext requires interface supporting method updatevoid note context specication required interface named observer represents neither global name type required interface later explicitly model mapping various required assured interface method names via proposed racontracts additionally component helptext assures interface textbox two methods gettextstring addtexttstringvoid addtextt called method update invoked observers correspondingly component helplist requires interface named observable includes method gettextstring moreover whenever return value gettext changes update method component helplist called via interface listbox basic behavior requirement component helplist needs assured environment component helplist requires interface observable methods invariants assures interface listbox locals methods specify two racontracts one satisfy requirements component helplist requirements component helptext contract contains two sections rst sec tion instantiation declares participants contract initial conguration stance contract helplistcontract two participants hlhelplist hthelptext instantiated initial connection established note variables declared instanciation section global identiers one must able refer current contract well contracts second section predicate mapping maps required interfaces assured interfaces partic ipants additionally contains important part contract proof designer validate correctness contract means proof whether syntax behavior requirementsassurance pair ts together contract helplistcontract includes proof simply starts conjunction assured predicates interface httextbox end required predicates interface hlobservable racontract helplistcontract instantiation helplist mapping required hlobservable assured httextbox racontract helptextcontract instantiation mapping required htobserver assured hllistbox proof omitted windows help screen completely specied implemented usually takes couple months one components appears new improved version example new version component helptext evolved new version assures additional method addcharccharvoid performance reasons method guarantee observers notied method invoked component helptext requires interface observer methods assures interface textbox locals methods assurances part specication component helptext changed therefore designer tool search racontracts helptext used fulll requirements components contracts identied corresponding proofs redone example contract helplistcontract concerned designer recheck whether goal ht reached premises changed obviously goal cannot derived call addcharc changes return value method gett ext result update helplistwhenever text helptext changes update calledare longer satised new component helptext current design system may longer meet expectations quirements designer decide keep former component use realize workaround helplist component however outside scope discussed concepts 9 conclusion future work ability software evolve controlled manner one critical areas software engineer ing therefore overall evolutionbased development methodology componentware needed paper outlined wellfounded common system model componentware copes difcult behavioral aspects objectorientation com ponentware dynamicall changing structures shared global state nally mandatory callbacks model presented includes concepts type abstract well concrete descriptions types system development set descriptions cre ated software evolution means descriptions changed time thus need techniques determine impacts respective evolution steps presented requirementsassurancescontracts developers explicitly model dependencies dierent components whenever component entire system changes contracts show consequences components contracts help developer manage evolution complete system number additional issues remain items future work currently working rst prototype runtime environment presented system model still elaborate underlying type sys tem addionally provide sophisticated graphical description techniques based uml ocl structural documents interface documents protocol documents implementation documents complete development example show description techniques practice description techniques clear semantical mapping system model dened additionally syntax compatible checkers theorem prover model checker could included run correctness proof evolution steps semiautomatically even fullautomatically fi nally develop tool support provide set evolutionresistant architectures based technical componentware infrastructures like corba dcom java enterprise beans acknowledgements grateful klaus bergner manfred broy ingolf kruger jan philipps bernhard rumpe bernhard schatz marc sihling oskar slotosch katharina spies alexander vilbig interesting discussions comments earlier versions paper r formal model componentware design distributed systems introduction focus interaction interfaces towards scienti c foundation methodological usage message sequence charts java nutshell design patterns elements reusable objectoriented soft ware visual formalisms specifying behavioral compositions objectoriented sys tems uni temporal logic actions preliminary design jml behavioral interface speci managing software evolution reuse contracts 500 europa der club der innovatoren clientserver programming java corba modeling software evolution evolving interoperation graphs executive summary software evolution componentware practical approach formale methodik des entwurfs verteilter ob jektorientierter systeme reuse contracts managing evolution reusable assets tr visual formalisms contracts specifying behavioral compositions objectoriented systems objectoriented software engineering objectoriented modeling design realtime objectoriented modeling temporal logic actions design patterns reuse contracts patternoriented software architecture clientserver programming java corba objectoriented software construction 2nd ed unified software development process software change evolution using extended event traces describe communication software architectures interaction interfaces towards scientific foundation methodological usage message sequence charts plea greybox components
primitives authentication process algebras extend pgrcalculus spicalculus two primitives guarantee authentication enable us abstract various implementationsspecifications authentication obtain idealized protocols secure construction main underlying idea originally proposed focardi proc sixth italian conf theoretical computer science november 1998 entity authentication use locations processes order check sending message authentication party originated message message authentication theory local names developed bodei et al theoret comput sci 2532 2001 155 pgrcalculus gives us almost free partner authentication message authentication primitives b introduction authentication one main issues security different purposes depending specific application considered example entity authentication related verification entitys claimed identity 18 message authentication make possible receiver message ascertain origin 30 recent years formalizations different aspects authentication see eg 3 7 13 16 17 22 29 formalizations crucial proofs authentication properties sometimes automatized see eg 12 15 20 21 25 typical approach presented literature following first protocol specified certain formal model earlier version sections 79 appeared 8 work partially supported murst progetto tosca progetto certificazione automatica di programmi mediante interpretazione astratta protocol shown enjoy desired properties regardless operating environment unreliable even harbour hostile intruder use basic calculi modelling concurrent mobile agents give certain kinds semantics offering builtin mechanisms guarantee authentication main contribution paper mechanisms enable us abstract various implementationsspecifications authentication obtain idealized protocols secure construction protocols rather specifications seen reference proving correctness real protocols essence concurrent mobile computation studied pure form using calculus 24 foundational calculus based notion naming systems specified expressions called processes obtained combining via operators parallel composition nondeterministic choice declarations basic actions sending receiving names processes along channels names represent values messages also channels since processes exchange names communica tions interconnection structure network vary dynamically recently abadi gordon 3 defined spicalculus enriching calculus primitives encryption decryption resulting calculus particularly suited security issues among authentication 6 calculus equipped structural operational semantics endows sequential process p whole system local environment ie p local space names local name manager generates fresh name whenever necessary basic ingredient proposal notion relative address process p respect another process q represents path p q abstract view network defined syntax calculus note relative addresses available users calculus used abstract machine calculus defined semantics propose use ideas underlying proposal study authentication calculus spicalculus matter fact kind semantics provides us two builtin authentication primitives key point p use address relative q uniquely reach subterm whole system representing q consequently relative addresses may used authenticate partners communication authenticate origin message sake presentation first introduce primitive partner authentication calculus one message authentication spicalculus easily combine eg introducing first mechanism spicalculus kinds authentication enforced partner authentication variation semantics defined 6 gives us runtime mechanism guarantees principal engage entire run session partners playing roles essentially bind sensitive input output communications relative address ie process p accept communications certain channel say c relative address partner equal apriori fixed address loc order achieve index channels relative addresses obtaining input actions form c loc x output actions form loc 0 hmi sending message semantics check address sender respect receiver indeed loc particular assume p explicitly waiting message process reachable following loc ie p performs input action c loc x possibly hostile process e relative address respect p different loc successfully communicate p c moreover e cannot sniff message sent p output action loc 0 hmi address e relative p different loc 0 located io primitives enable processes control partners example define calculus syntax protocol guarantees partner authentication construction putting parallel following processes loc p represents address p relative q chmi stands sending along c every possible process channel c indexed relative address formally empty one c loc p x input action located loc p input match output chmi executed process reachable q relative address loc p resulting communication effect binding x within residual q yielding q replaces x consider p q also intruder e parallel p j q j e effect guarantee q communication c performed p thus q assured message indeed received p note need c channel private p q although paper focus authentication primitives interesting note located outputs also guarantee form secrecy example consider following protocol p uses located output loc q address q relative p consider p j q j e p also guaranteed communication c performed q ie e cannot intercept thus remain secret channel c needs private p q separately model authentication secrecy public channels mechanism thus concrete use private channel communication every protocol legitimate processes may play different roles sender server receiver etc usually processes recognize roles partners playing seldom know partners relative addresses shall also index channel variable instantiated relative address whenever process p playing instance role sender initiator communicate first time another process role eg server uses channel c semantics rules take care instantiating address p relative communication roughly implements sort anonymous communication note process could also hostile process pretending server however point p keep communicating roles entire session using relative addresses sketched mechanism guarantees principal communicates partners role entire session also circumvent problems arising mixing sessions particular due replay attacks usually protocols use challengeresponse mechanisms based eg nonces typically numbers used whose freshness protects replay attacks framework freshness longer needed distinguish communications one session communications another message authentication semantics 6 extension spicalculus studied section 7 see also 5 directly allow define another authentication mechanism providing us builtin primitive enables receiver message ascertain origin ie process created fact address message relative process p uniquely identifies originator even message maliciously intercepted forwarded indeed guarantee integrity message receiver gets originator made compound message receiver additionally ascertain originators components write primitive authentication message p process 1 intuitively execution process q starts check succeeds happens relative addresses p respect q coincide words q generator note check done interpreter calculus ie semantic rules user communication protocol guarantees message authentication construction easy define using plain handshaking communication calculus spicalculus primitive sketched suppose process p sends message simplicity consider name along public channel c spicalculus syntax following form operator declares fresh name different others whole system put p q also intruder e parallel p j q j e effect guarantee residual q indeed q 0 mx note q guaranteed receive message directly p partner authentication matter fact intruder might well intercepted message originated p forwarded q legal checking originated p see e cannot modify parts without changing relative address relative addresses manipulated semantics also case need c channel private p q solutions assume implementation communication primitives reliable mechanism control manage relative addresses real cases possible eg network management system filters every access user network happens lan virtual private network may case many situations however relative addresses built storing actual address processes selected secure parts message headers cf ipsec 31 yet solutions may help checking correctness different implementations eg based cryptography briefly discussed conclusion contents paper section 2 survey calculus section 3 recall relative addresses section 4 proved version calculus 6 section 5 devoted partner authentication section 6 survey spicalculus section 7 enrich relative address mechanism sections 8 9 message authentication primitive 2 calculus section briefly recall monadic calculus 24 model concurrent communicating processes based notion naming presentation slightly differs usual ones make easier introduce later spicalculus main difference standard presentation relies introduction new syntactic category terms names variables distinguished definition 21 syntax terms denoted denoted built according syntax 1 actually message p see formal development details prefix mp restriction matching replication may either mx input mhni output hereafter trailing 0 omitted often write denote tuples objects instance vector actually feel free consider operate set notations extended componentwise eg n stands n 1 finally means restricted names intuitively 0 represents null process nothing prefix first atomic action process p perform execution process p behaves like p input prefix mx binds name x prefixed process follows name n received along link named free occurrences x prefixed process p substituted output prefix mhni bind name n sent along summation denotes nondeterministic choice process operator j describes parallel composition processes components p 1 jp 2 may act independently also output action p 1 resp p 2 output port may synchronize input action p value sent p 1 replaces relevant occurrences placeholder x p 2 operator acts static declaration ie binder name process p prefixes words unique name p different external names agent mp behaves p except actions ports prohibited however communications along link components within p allowed matching ifthen operator process p activated finally process p behaves infinitely many copies p running parallel write fnm fnp sets names free term process p respectively fvm fvp sets variables free term process p respectively closed term process term process without free variables 21 semantics semantics calculus consider late semantics based reduction relation commitment relation structural congruence rules also needed commitment relation depends abstraction concretion constructs abstraction form xp x binds x p concretion form mhmip term p process names bound p agent b abstraction concretion process f abstraction xp c concretion mhmiq f interactions fc cf mp mx j q congruence structural congruence processes defined standard way except treatment parallel composition assumed neither commutative associative defined least congruence satisfying p q equivalent p q commutative monoid mhmir j q mhmiq following never distinguish congruent terms reduction relation reduction relation least relation closed processes transitive closed contexts satisfies following axioms red repl p p j p red match commitment relation action name representing input coname representing output distinguished silent action note actions record channel input output occurs commitment relation written p p closed process action closed agent defined rules tab 1 3 relative addresses composition recall ideas 6 serve basis authentication mechanisms going introduce consider binary parallel composition main operator calculus neither associative commutative build abstract syntax trees processes binary trees called trees sequential processes follows given process p nodes tree correspond occurrences parallel operator p leaves sequential components p roughly processes whose toplevel operator prefix summation replication tree processes depicted fig 1 comm comm comm sum 1 comm sum 2 comm par 1 comm par 2 comm inter 1 comm inter 2 comm res comm red comm struct table 1 commitment relation figure 1 tree sequential processes p assume left resp right branches tree sequential processes denote left resp right component parallel compositions label arcs tag jj 0 resp jj 1 therefore sequential component process uniquely identified string fjj string corresponds path root toplevel j whole process leaf intuitively address sequential component relative root binary tree consider two different sequential processes say g r tree call path address process g relative process r relative address decomposed two parts according minimal common predecessor p g r tree relative address string written 0 made jj 0 jj 1 represents path p r 2 0 path p g let g r respectively processes p 3 p 1 fig 1 address p 3 relative p 1 jj 0 jj 1 jj 1 jj 1 jj 0 read path upwards p 1 root reverse downwards p 3 speak relative address points back r g relative addresses composed order obtain new relative addresses instance composition relative address jj 1 jj 0 jj fig 1 relative address p 3 wrt relative address jj 0 jj 1 jj 0 p 3 wrt p 2 recall formal definition relative addresses define composition intuition full definitions statements properties 6 definition 31 relative addresses empty string let sum modulo 2 set relative addresses ranged l sometimes omit relative addresses eg write n n relative address l compatible l written l said use relative addresses encode paths pairs nodes binary trees processes like one fig 1 note condition jj 0 0 explicit two components relative address describe two distinct paths going node binary tree also l refer path exchanging source target 2 technical reasons take path p r instead natural path r p address composition partial operation defined relative addresses indeed com posed make sure always case apply fig 2 depicts cases happens definition 32 address composition address composition defined following three exhaustive cases 1 2 3 immediate see neutral element ie l inverse element ie inverse l l 1 associative ie l l g r 1 2 3 figure 2 three possible relative placements three processes g r result composition relative addresses wrt r g wrt represented solid arrows 4 proved semantics relative addresses inductively built deducing transitions proved semantics used 9 section recall 10 proved transition system calculus labels transitions encode portion deduction tree arrows proved transition system labelled action string jj used single subprocess actually performed rules proved commitment tab 2 essentially standard transition system except involving parallel operator rule comm par 1 respectively comm par 2 adds label conclusion tag jj 0 respectively jj 1 register left respectively right component parallel composition moving rules defining congruence reduction relation indeed recover standard semantics calculus need erase occurrence labels transitions note information added labels used inductively build relative addresses indeed tags jj sufficient recover parallel structure process p provide encoding tree processes p instance suppose process p performs transition jj 0 know action performed sequential process form p parallel process q indeed whole system form p jq generally process r performs transition path tree processes permits reach subprocess performs action technically indicate subprocess r p inductively selected following operator comm comm comm sum 1 comm sum 2 comm par 1 comm par 2 comm inter 1 comm inter 2 comm res comm red comm struct table 2 proved commitment relation definition 41 localization operator defined processes induction follows 1 2 mp 3 4 definition helpful end sections 5 8 back fig 1 p 3 communicates p 1 whole process computation step subprocess p 3 performing output sysjj 1 jj 1 jj 0 subprocess p 1 performing input sysjj 0 jj 1 putting together single paths obtain relative address 5 partner authentication introduce first authentication mechanism runtime guarantee principal engage entire run session partners playing roles heavily exploit proved semantics reported previous section essentially bind sensitive input output communications relative addresses precisely channels may relative address index assume form c l semantics ensure p communicates q c l relative address p wrt q indeed l q wrt p l 1 notably even another process r 6 q possesses channel c l r cannot use communicate p consequently hostile process never interfere p q communicate even eavesdrop exchanged messages using located channels processes may control partners often process p willing communicate several processes usually one channels shall also index channel variable instantiated suppose process p playing instance role sender initiator wants communicate process eg server p know relative address say l finally involved channel c first communication p instantiated within p l recall proved operational semantics indeed computes l symmetrically uses channel c different variable uses c 0 sense case anonymous communication note however may well use already located channel c l 0 communication occurs l point p keep communicating roles entire session using known relative addresses thus extend names occur processes indexing location defined either relative address variable instantiated relative address formally definition 51 let 3 countable set address variables let set located channels usually empty location rules defining congruence reduction relation apart obvious substitution located names names rules new commitment relation tab 3 omit symmetric rules communication rules parallel composition proved style comm comm comm sum 1 comm par 1 comm inter l 1 l 0 l comm inter l comm inter 1 comm res comm red comm struct table 3 proved located commitment relation recording component left right process moving arrows annotated also location io action rule location channel involved recorded arrow preserved non communication rules discarded communications location used premises communication rules establish relative addresses one process respect fact first process receiver performs input second process sender performs complementary output action 0 relative address sender respect receiver jj 0 jj 1 0 additional jj 0 jj 1 record two processes left right partners communication three different rules symmetries every communication two processes say p q comment intuitively relate three possible situations p q may comm inter l 1 p wants receive process located l q wants send process located l 0 communication happen relative addresses q wrt p p wrt q path established communication coincide locations compatible ie l side conditions require situation reflects fact p q know possibly previously established connection session partners note l l 0 recover nonlocated communication standard calculus comm inter wants receive process located l q willing send message process sends channel location variable 0 communication successful l coincides path established communication ie l coincides relative address indeed process p wants receive communication 0 suitably bound l 1 relative address p wrt q within q p q know l empty location communication always successful 0 still replaced relative address p wrt q comm inter 1 p q know willing communicate partner exchange relative addresses established deducing premises intuitively p performing initial synchronization two variables replaced relative address q wrt p viceversa l l 0 respectively variables located consequently located channel c l communicated becomes free channel location l lost index c becomes otherwise get c occurring process formally following definition 52 let yp abstraction l iq concretion interaction otherwise occurring q symmetrically cf using definition communication makes easier use channel multiplexing way suppose process p committed communicate channel c l process q also assume sends c l third party r receives c channel c used communications p q case located l well communications r process suitably instantiated rules commitment use particular kind substitution fjljg called selective routed substitution uses particular substitution fjljg called routed applied subprocess located routed substitution takes account parallel structure process updates relative addresses l traversing tree processes instance substitute 0 p 0 jp 1 requires substitute jj 0 component p definition 53 location routed substitution fjljg defined induction follows 1 l otherwise 2 hmip 3 xp 4 5 7 case p definition ie routed substitution may applied p p reduced p jp amounts saying also considering processes inside routed substitutions fully performed consequently target transitions tab 3 may contain expressions form p fjljg order burden heavily notation shall still use p processes abstractions concretions substitutions yet performed use definition implement selective substitution works subprocess whole term reachable selective routed substitution pfjljg defined induction fact channels indexes may also instantiated guarantees two partners establish connection remain stable along whole session indeed let note jj 0 jj 1 address r relative q immediate verifying q accepts inputs c come r course property remains true inputs q along symmetrically process example 55 illustrate partner authentication mechanism simple examples first consider single message exchange alice bob b 0 two location variables message exchange semantic rule comm inter 1 instantiates 0 0 b 0 respectively address relative b ie jj 1 jj 0 b relative ie jj 0 jj 1 respectively intuitively instantiation l represents secure declaration identity process location l cannot manipulated even malicious parties see later located actions also give security guarantees subsequent message exchanges example contd consider following protocol recall simply written shall comment use channel occurs located 0 b 0 bob sends message alice reception note alice requiring second message comes process sent since first message exchange variable instantiated address b 0 relative 0 semantics guarantees authentication second communication respect secure identity declaration alice assured second message sent process received first one order illustrate important point add another process c tries communicate channel process following steps since address c 0 relative 0 jj 0 jj 0 jj 1 6 jj 0 jj 1 either residual 0 receives residual b 0 b 0 c 0 communicate first case second case example channel used two different ways located alice bob alternatively free b 0 c 0 example 59 shall see channel even used multiplexing fashion two pairs processes interleave communications still presenting property engaged process along entire session next example consider situation channel located used output message usage channels also guarantees sort secrecy example 56 seen previous example message mb intercepted c 0 thus violating secrecy consider following protocol bob requiring message mb received user sent first message case bob obtains form secrecy assured mb read process identified 0 ie process sent message indeed new process c read mb address c 00 relative b 00 jj seen locating inputs outputs corresponds guaranteeing authentication secrecy communication respectively summarize two concepts follows message exchange respect address l process obtains partner authentication whenever receives message process reachable l secrecy whenever process reachable l receive message state precisely exploiting def 41 need notion context two holes theorem 57 authentication let proof inspection rules used deduce transition particular consider side conditions rules comm inter l 1 theorem 58 secrecy let proof analogous previous proof next example illustrates locating inputs outputs guarantees permanent hooking two parties allows model multiple sessions quite easily example 59 consider following processes indeed alice bob assured second message also subsequent messages sent received located channels sentreceived user interacted first message exchange hence two users first communication permanently hooked together time third user indeed able take place b communication starts session instead never communicate first message exchange model multiple sessions consider b unbounded number instances alice bob present different fresh message consider two instances sending first messages two instances b ie two parallel sessions note first message exchange partners session permanently hooked second message always sent correct party one initiated session consequence replay messages possible among different sessions also presence malicious party 6 spicalculus syntax section briefly recall often also literally spicalculus 3 monadic version 1 calculus extension calculus introduced description analysis cryptographic protocols first difference calculus spicalculus summation operator also terms structured pairs mn successors terms sucm encryptions last term represents ciphertext obtained encrypting key n using sharedkey cryptosystem des 27 definition 61 terms processes defined according following bnflike grammars names x variables sucm successor shared key encryption prefix mp restriction matching replication let p pair splitting case case case l fx p shared key decryption may either mx mhni 3 process constructs calculus new ones decompose terms process let x p behaves p process case 0 qnx stuck otherwise process case l fx p attempts decrypt l key n l form process behaves p 1 x otherwise stuck structural congruence operational semantics commitment exactly calculus given table 1 new reductions rules instead needed red split let x red zero case 0 red suc case sucm red decrypt case fm n fx 7 names spicalculus handled locally introduce second authentication mechanism need exploit ideas contained 6 relative addresses introduced section 3 used handle names locally sequential processes operational manner space names whole process partitioned local environments associated sequential subprocesses avoid global management names solve two problems names declared locally brandnew local environment furthermore name exported local environments via communications applying reduction rule must guarantee clashes involving names around purely mechanical way 6 sake simplicity instead recalling also mechanism generating fresh names assume name fresh whenever needed shall recall side condition keeping names distinct consider two different sequential processes say g r two syntactically equal names say n suppose g sends n r distinguish two different instances n local environment r name generated g received enriched address g relative r points back r local environment g slightly complex situation arises process receives name sends another process name must arrive new receiver address generator sender relative new receiver consider fig 1 p 1 sends p 2 name generated p 3 rules tab communication use address composition determine address p 3 relative p 2 composing address message recording address p 3 wrt relative address p 1 wrt p 2 carry localized semantics calculus 6 monadic spicalculus first introduce new set localized names names prefixed relative addresses although arbitrary term consider name variable instantiated name useful cases see 3 definition 71 let n set localized names n set standard names operator language concatenation simplicity assume possibly indexed range n 0 n unless necessary syntactically distinguish localized terms terms ie terms prefixed relative addresses like prefixed said recall mechanism 6 generates fresh names whenever needed simply assume fresh however require restricted names always localized ie occur declaration n technically achieved transforming process p n new process obtained replacing subprocess p form nq process nqfjnnjg substitution fjjg def 73 term exported process say p another say q necessary compose relative address prefixing relative address p wrt q composition performed term address composition extends address composition def 32 applied relative address localized term returns updated localized term definition 72 term address composition defined say term exported relative address 0 names n variables natural numbers prefixed relative addresses insensitive address composition explain semantics deals terms first note operator considers compound term whole distribute address composition subterms consider encryption term fmgk atomic entity handled new name local process encrypts say p two localized terms k frozen like encryption time relative addresses changed encrypted message sent net relative addresses cannot updated since fmgk atomic relative address say always point process p made encryption technically k frozen like process containing restrictions names used encryption way decrypting fmgk semantic rules recover correct addresses k simply composing actual address fmgk 0 1 frozen relative addresses k respectively management described used successor pairs first case term frozen sucm terms n frozen mn also routed substitution def 53 extended deal terms processes spicalculus distributes subterm subprocess note term n cannot variable definition 73 spi routed substitution fjnxjg defined induction follows terms 1 rfjnxjg 2 zfjnxjg z x 6 z 3 0fjnxjg 4 sucmfjnxjg 5 processes 1 0fjnxjg 2 rhmip fjnxjg 3 ryp fjnxjg 4 5 7 let 8 case case mfjnxjg case mfjnxjg 9 case l fy p fjnxjg case lfjnxjg fx mfjnxjgs p case lfjnxjg fx mfjnxjgs pfjnxjg otherwise selective routed substitution spicalculus exactly def 54 localized congruence rules structural congruence require changes accommodate localized names 1 2 3 4 note conversion needed binding occurrence name r p 1 replaced different name p 1 properties address composition localized reduction relation add following reduction rules matching replication red split let x red suc case 0 1 sucm red decrypt case 0 1 fy process decomposes term involved subterms updated intuition decryption rule decrypt message fmgn use key exactly frozen key n appear receiver encrypted message k n although starting different sites refer key semantic rules decrypt message update relative address composing 0 1 process p behaves pfj 0 localized commitment relation eventually present tab 4 extended commitments rules localized commitment relation written p p process action performed subprocess agent component labels needed checking side conditions rules communication rules successful complementary actions refer name restriction rule necessary check clashes action restricted name semantic rules update messages relative addresses sender respect receiver indeed congruence rules lift relative addresses restrictions much needed instance applying restricted name r p 1 appears jj 0 r process similarly applying congruence rule term p 0 appears finally also interactions update relative addresses definition 74 let abstraction concretion localized interactions see localized interactions work consider f c restricted names known r p 1 duly updated jj 0 r parallel composition p 0 substitution p 1 message appears p 1 exported term address composition therefore applied relative address jj 1 jj 0 example consider processes fig 1 suppose p 0 willing send n process p 3 message appear jj 0 jj 0 n replace routed substitution variable x p 2 jp 3 jp 4 jj 1 jj 0 jj 0 n note arrive p 3 enriched relative address p 0 wrt p 3 8 message authentication intuitively present authentication primitive akin matching operator address matching passed relative addresses two localized terms n coincide comm comm comm par 1 comm par 2 comm inter 1 comm inter 2 comm res comm red comm struct table 4 localized commitment relation intuition know process packed n say p also say comes indeed authenticating formally extensions due new primitive consist new case processes new reduction rule definition 81 let mn two terms def 61 l l 0 2 loc two relative addresses process define following reduction rule red address match lm note free names prefixed empty relative address hereafter assume initial startup phase processes exchange message fix relative addresses obtained eg preliminary communication partners b restricted shared channel startup phase indeed abstraction preliminary secure exchange secret information eg long term keys necessary every cryptographic protocol see example next session initialization step avoided using partner authentication primitive however sake presentation combine two primitives consider following simple example process b wants authenticate message even presence intruder e protocol p e recall name appears assumption analogously n e show role localized names play guarantee construction b 0 executed message bound x originated ie message received channel c indeed relative address jj 1 jj 0 jj 0 pointing b encodes site hosting thus gives identity process b expecting receive message channel c order analyze behaviour protocol hostile environment consider generic intruder e powerful possible examine following two possible message exchanges first message represents correct exchange message b second one attempt e send different message n b intruder e could actually following form hother bad actionsi names n received b prefixed relative address corresponding respective originators fig 3 shows two message exchanges particular see received b jj 1 jj 0 jj 0 n becomes jj 0 jj 1 n immediate see first case b evolve bfjmxjg figure 3 process b detects message jj 1 jj 0 jj 0 authentic message jj 0 jj 1 n comes intruder e latter stop jj 1 jj 0 jj 0 matches address every attempt intruder introducing new messages c filtered authentication primitive interesting case arises intruder intercepts forwards b show mechanism accepts message authentic particular reconsider previous protocol analyze case different intruder masquerading b written eb intercepts forwards b actually cannot modify would like accept message b even forwarded e matter many times message forwarded address composition maintains integrity identity generator detail eb receives jj 1 jj 1 jj 0 e forwards b message composed address e relative b jj 0 jj 1 yielding jj 0 applying rule 1 def 32 see message received b jj 1 jj 0 jj 0 therefore accepted authentic note also b use jj 1 jj 1 jj 0 component new message 0 receiver r 0 get prefixed relative address say r check 0 packed b 0 hence authenticity 0 even components indeed composition gives address originator ie relative r end section following property c contexts one two holes respectively pfj stands pfj theorem 82 address matching let input c binds variable x matching suppose 1 l proof first communication variable x occurring matching instantiated l input binds x recall def 73 substituting term enriched going tree sequential processes sequence steps leading q 00 change contexts c process p 1 possibly binds variables mxjg reduction matching performed l 00 toplevel c 00 l equal l 9 implementing authentication section show notion message authentication based locations helps studying analysing cryptographic protocols main idea observe specific authentication protocol indeed good implementation authentication primitive ie cryptographic protocol strong detecting names incorrect relative address authentication primitive recall spicalculus compound term encryption considered localized ie relative address say point process p made encryption way decrypting fmgk semantic rules recover correct addresses k simply composing actual address fmgk 0 0 frozen relative addresses k respectively show example correct run wide mouthed frog key exchange protocol consider simplified version analyzed 3 two processes b share keys kas kbs trusted server order establish secure channel b sends fresh key kab encrypted kas server server decrypts key forwards b time encrypted kbs b key kab send message encrypted kab b protocol guarantee b receives message indeed originated protocol composed following three messages message message 3 specification calculus localized names mechanically replaced restricted names localized counterparts ic ab hfmg kab xcase x fyg jj 1 kas c bs hfyg jj 1 kbs xcase x fyg jj 0 jj 1 kbs c ab zcase z frg surprisingly specification style 3 except localized restricted names fig 4 shows localized names handled correct execution protocol p note kas kbs assume different relative address different processes reception message 2 b decrypts received message figure 4 correct execution wide mouthed frog protocol means computing case fyg jj 0 jj 1 kbs c ab z case z frg b reduction rule decrypt applies jj 0 jj 1 variable set jj 0 jj 1 results jj 1 jj 0 kab rule 3 def 32 indeed correct reference key kab generated installed local environment last message b receives succeeds decrypting jj 1 jj 0 kab obtaining jj 1 jj 0 addresses relative b equal indeed authentic characterizes correct execution wellknown attack take place two sessions protocol basically occurs intruder replays messages first session second one follow formalization 3 attack analyzed note single session illustrated problem arises instead even intruder intercepts message sent forwarded b indeed message received right one seen one alter neither relative addresses encrypted message fmgkab show attack immediately detected observer compare localized names eg using authentication primitive sake readability call 0 b 0 two instances b second session 0 trying send message 0 b 0 using session key k 0 message eavesdrops message 2i message 3 eavesdrops message 3i intruder eavesdrops first session replays messages 2 3 second session messages result b 0 receives copy instead one 0 order model two parallel session protocol consider following specification addresses localized names kas kbs suitably updated processes b note generates kab fresh names j originates two different messages say 0 two different keys say kab k 0 ab also modify serve sessions sake simplicity define server able handle two sequential xcase x fyg jj 1 kas c bs hfyg jj 1 kbs c zcase z fwg jj 1 kas c bs hfwg jj 1 kbs specify intruder names c ab c c bs free thus known processes p 0 unlike kas kbs bound observe attack sequence fig 5 particular process b 0 decrypts message message originated 0 indeed address 0 relative b 0 jj 1 jj 1 jj 0 jj 1 attack detected want show protocol done secure construction authentication primitive idea last message accepted originated correct initiator order need least message initiator whose address compared last message protocol trick add startup message securely hooks one initiator one responder sending fresh message restricted channel resulting specification follows modifications bold font restricted names localized sake readability xcase x fyg kas c bs hfyg kbs c zcase z fwgkas c bs hfwgkbs xcase x fyg kbs c ab zcase z frg r p 00 two b 00 processes receive two 00 two different startup messages two different ad dresses thus longer possible intruder carry replay attack fact cheated b 00 able stop delivering message b comparing traces protocol correct construction traces previous one easy see equivalent potential attack thus detected k k fmg k ab ab g ab g figure 5 attack wide mouthed frog protocol jj k stands sequence k tags jj conclusions future work defined two primitives guarantee partner message authentication public channels based semantic feature derived form proved transition systems 9 partner authentication based semantics calculus names channels indexed expected relative addresses communicating parties particular time two processes try communicate common channel relative addresses checked index channel used communication enabled check passed ie relative addresses compatible indexes moreover channel used multiplexing fashion two processes say p q go exchanging messages channel c interleaving activity another pair processes say r using c well never case message p read r comes unless indeed intended behaviour p r p message authentication based semantics spicalculus message localized via relative address l process p packed authentication primitive compares relative address l address l 0 process q relative receiver check succeeds authenticates message l l 0 expressing indeed process q packed two primitives sense orthogonal operate independent features calculi con sidered course one may combine eg carrying spicalculus notion located channel introduced calculus notions authentication guaranteed construction note partner authentication primitive transform public channel private one deed partner authentication clearly separates concepts authentication secrecy importantly two processes communicating public channels hooked impossible third process interfere communication notion message authentication need private channels well message may considered authentic even intercepted eavesdropped ie mechanism guarantee secrecy generated packed claimed entity thus primitive corresponds neither private channel basic calculus cryptographic one spi calculus appear strong message authentication alone guarantee also secrecy idea exploiting locations analysis authentication comes 14 however entities bound physical addresses net approach related abadifournetgonthiers 2 principals explicit fixed names see also joincalculus 19 seal 33 relaxed rigidity fixed mapping sites introducing sort identifiers sites represented relative addresses matter fact actual placement process site recovered composing localized names akin environment function sequential languages allocation tables similar store actually 14 models wider notion authentication plan investigate next discussed paper primitive may implementable directly indeed one lowlevel highly reliable mechanism manage localized names unrealistic many cases possible instance lan virtual private networks step could encrypting relative addresses within header messages style ipsec 31 nevertheless proposal help reasoning authentication security abstract point view indeed main aim approach presently developing ideas briefly describe following first could possible verify correctness cryptographic protocol showing messages implement partner authentication needed example typical challengeresponse technique requires send nonce random challenge expect back encrypted secret shared key challengeresponse proved implement located input actions suitable condi tions proofs implementations satisfy specifications often hard private channels used model authenticated channels indeed private channels often seem far cryptographic implementations proposal help need private channels moreover could verify cryptographybased protocol ensures message authentication checking version containing also primitive original formulation exhibit behaviour check specifications implementations much style congruencebased techniques typical process calculi see eg 3 finally feel confident proposal scales languages concurrent reactive systems like facile 32 pict 28 cml 26 esterel 4 built top core process calculus like one use also operational semantics easily turned proved one successful cases facile 11 esterel 23 show course great deal work still necessary make proposal applicable real cases r secure implementation channel abstractions calculus cryptographic protocols spi calculus synchronous programming language esterel mathematical semantics security issues process calculi names calculus agents handled locally logic authentication authentication via localized names enhanced operational semantics tool describing analysing concurrent systems non interleaving semantics mobile processes causality debugging mobile agents compiler analysing cryptographic protocols using noninterference strand spaces security protocol cor rect using entity locations analysis authentication protocols using non interference analysis security protocols non interference analysis cryptographic proto cols uniform approach definition security properties international organization standardization three systems cryptographic protocol analysis breaking fixing needhamschroeder publickey protocol using fdr hierarchy authentication specification applying techniques asynchronous concurrency synchronous languages calculus mobile processes ii automated analysis cryptographic protocols using mur cml process algebra data encryption standard des pict programming language based picalculus verifying authentication protocols csp applied cryptography rfc 2411 ip security document roadmap facile antigua release programming guide seal framework secure mobile computations tr logic authentication calculus mobile processes cml process algebra reflexive cham joincalculus verifying authentication protocols csp calculus cryptographic protocols noninterleaving semantics mobile processes secrecy typing security protocols applying techniques asynchronous concurrency synchronous languages pict names fo myampersandpgrcalculus agents handled locally compiler analyzing cryptographic protocols using noninterference enhanced operational semantics seal non interference analysis cryptographic protocols breaking fixing needhamschroeder publickey protocol using fdr esterel synchronous programming language mathematical semantics uniform approach definition security properties secure implementation channel abstractions hierarchy authentication specifications authentication via localized names automated analysis cryptographic protocols using murspl phi ctr c bodei p degano r focardi c priami authentication primitives secure protocol specifications future generation computer systems v21 n5 p645653 may 2005 chiara bodei mikael buchholtz pierpaolo degano flemming nielson hanne riis nielson static validation security protocols journal computer security v13 n3 p347390 may 2005
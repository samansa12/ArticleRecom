satbased implication engine efficient atpg equivalence checking optimization netlists paper presents flexible efficient approach evaluating implications well deriving indirect implications logic circuits evaluation derivation implications essential atpg equivalence checking netlist optimization contrary methods approach based graph model circuits clause description called implication graph combines flexibility satbased techniques high efficiency structure based methods proposed algorithms operate implication graph independent chosen logic evaluation implications computation indirect implications performed simple efficient graph algorithms experimental results various applications relying implication demonstrate effectiveness approach b introduction recently substantial progress achieved fields boolean equivalence checking optimization netlists techniques deriving indirect implications originally developed atpg tools play key role development indirect implications successfully applied algorithms optimizing netlists task either set permissible transformations derived 1 2 3 promising transformations applied permissibility later verified atpg tool 4 5 6 furthermore great importance atpgbased approaches boolean equivalence checking combinational sequential circuits 7 8 9 10 11 help identify equivalent internal signals circuits compared late 1980s schulz et al incorporated computation indirect implications atpg tool socrates12 indirect implications indispensable dealing redundant faults help efficiently prune search space branch andbound search order derive indirect implications originally static technique socrates authors refer static learning extended dynamic learning 13 14 recursive learning 7 proposed kunz et al 1992 first complete algorithm determining indirect implications problem finding indirect implications npcomplete small depths recursion feasible recently shown recursive learning adequately modelled andor reasoning graphs 3 another complete method deriving indirect implications based bdds suggested mukherjee et al 15 recently zhao et al presented approach combines iterated static learning recursive learning constrained recursion level one 16 based set algebra similar single pass deductive fault simulation contrary methods work structural description circuit approaches use boolean satisfiability based model satmodel allows elegant problem formulation easily adapted various log ics abstraction however often impedes development efficient algorithms structural information lost larrabee included clause based formulation schulzs algorithm nemesis17 approach improved iterated method tegus 18 transitive closure algorithms suggested chakradhar et al rely relational model binary clauses 19 silva et al proposed another form dynamic learning grasp 20 indirect implications determined conflict analysis backtracking phase satsolver many areas logic synthesis formal verification binary decision diagrams bdd become widely used data structure provide many advantageous properties eg canonicity high flexibility besides exponential memory complexity used atpg equivalence checking optimization large netlists bdds suffer drawback implications cannot derived efficiently data structure given signal assignment decided another signal assignment implied finding possible implications given signal assignment expensive theoretically possible combinations signal pairs checked therefore bddbased approachessuch functional learning 15 restrict search potential learning areas identified non bddbased implication consequently structural hybrid approaches ie bdds combined methods predominant atpg equivalence checking optimization netlists even though approachesmake heavy use implica tions data structures used deriving evaluating implications often suboptimal inflexible propose flexible data structure specifically optimized respect implication paper introduce framework implication based algorithms inherits advantages structural well satbased approaches approach combines flexibility elegance satbased algorithm efficiency structural method working graph model clause system called implication graph memory complexity linear number modules circuit due structural information available graph fundamental problems justification propagation particularly implication carried efficiently graph search indirect implications reduces graph algorithms executed fast easily extended exploit bitparallelism implication graph automatically generated arbitrary logic presented algorithms remain valid independent chosen logic allows rapid prototyping implication based tools new multivalued logics remainder paper organized follows sec 2 show derive implication graph next discuss implications evaluated indirect implications computed sec 3 4 respectively order demonstrate high efficiency approach experimental results various applications using proposed implication engine presented sec 5 sec 6 concludes paper implication graph performing implications one prominent time consuming tasks atpg equivalence checking optimization netlists utmost importance use data structure best suited unlike graphical representations clause systems data structure represents information contained structural netlist clause database implication graphs used nemesis17 tran19 model binary clauses clauses higher order solely included clause database since approach generic nature combinational circuit automatically compiled implication graph rep resentation information logic encoding well truth table descriptions supported module types provided basic steps compilation given fig 1 first supported module types individually compiled encoded table clauses module database circuit implication subgraph logic encoding module optimization implication graph figure 1 deriving implication graph encoded truth tables tables optimized twolevel logic optimizer eg espresso step explained sec 21 next set clauses extracted optimized ta ble shown sec 22 shown sec 23 set clauses transformed implication subgraph stored module database every module circuit appropriate generic subgraph taken module database personalized input output signals given module finally identical nodes merged single node resulting complete implication graph following sections consider 3valued logic l f01xg order present basic ideas approach generation implication graph arbitrary multivalued logic eg 10valued logic l 10 known robust path delay atpg discussed 21 21 encoding signal variable x 2l 3 requires two encoding bits c x c x internal representation complete scheme encoding l 3 shown table 1 order easily detect inconsistencies encoding interpretation x signal x 1 signal x unknown conflict signal x table 1 3valued logic encoding conflicting signal assignments denoted c property expressed following definition definition 1 assignment called nonconflicting iff c x c holds signal variables x based encoding truth tables supported module types converted encoded tables example truth table 2input andgate found table 2 converted encoded table table 2 encoded table truth table b c encoded table c c c b c c optimized table c c c b c c table 2 andgate truth table encoded table optimized table interpreted specifying onset well offset two boolean functions c c c c conflicting assignmentsbelong dontcareset explicitly checked implication engine exploiting dontcares functions c c c c encoded table optimized espresso 22 clause description characteristic function describing andgate respect given encoding easily given conjunctive normal form cnf analyzing individual rows optimized table table 2 every row table corresponds clause contained cnf cnf comprises three clauses c c c c c c c b c c valid value assignments inputs outputs andgate implicitly given nonconflicting satisfying assignments characteristic equation cnf c c 23 building implication graph exploiting following equivalencies clause description eq 1 converted corresponding implication graph xy sufficient provide equivalencies binary ternary clauses clause system higher order decomposed system binary ternary clauses 21 transformed clauses binary ternary clauses subgraphs shown fig 2 used representation clauses graphs contain two types nodes first type rep z x figure 2 implication subgraph binary ternary clause resents encoded signal values second one symbolizes conjunction operation latter type depicted shaded triangle every ternary clause three associated nodes uniquely represent ternary clause implication graph coming back 2input andgate cnfdescription transformed implication graph shown fig 3 every bit encoding signal x represented corresponding node implication graph eg node c c fig 3 gives bit c c signal require nonconflicting assignments literals x replaced c x nodes corresponding nonnegated encoding bits contained fig 3 far implication graph captures logic functionality circuit since structural information indispensable tasks justification propagation provide information within implication graph marking edges three different tags f b edges denote implication input output signal module marked f forward edge relations output input signals tagged b backward edge edges eg input input relations indirect implications given tag tags 2input andgate found fig 3 means tags directed acyclic graph dag extracted implication graph edges forward edges moved obtain dag forms base efficient algorithm backtracing justification simple circuit three different circuit descriptions introduced presented ex 21 please observe clause based approaches work cnf l 2 approach operates cnf variables encoded respect given logic l 3 denoting edges omitted later examples c c c c c c c f f f f figure 3 implication graph 2input andgate 24 advantages using proposed implication graph core data structure cad algorithms many advantages 1 important tasks implication justification carried implication graph manner arbitrary logic peculiarities chosen logic included graph implication derivation indirect implications reduce efficient graph algorithms shown sec 33 44 2 satbased algorithms use static order variable assignments search satisfying assignment 17 19 furthermore algorithms assign values internal signals justification since podem well known assigning values primary input signals helps reduce search space obviously primary inputs special property given instance sat exploited algorithms solving arbitrary sat problems algorithm tegus tries mimic podem ordering clauses special manner 18 approach need techniques structural information provided edge tags 3 algorithms working implication graph easily exploit bitparallelism status every node represented one bit example 64bit machine 64 value assignments processed parallel making bitparallel implication efficient sequential circuits often modelled iterative logic array ila model time domain unfolded multiple copies combinational logic block logic blocks compiled corresponding implication graphs using bitparallel techniques 64bit machine allows keep 64 timeframes without increasing size implication graph 3 perform implications 31 structure based structure based implication special form eventdriven simulation contrary ordinary simulation starts primary inputs implication started arbitrary signal circuit therefore proceed towards primary outputs well primary inputs implications often categorized forward backward implications obviously technique requires many table lookups evaluating module functions becomes particularly costly multivalued log ics eg ones used path delay atpg 32 clause based clause based implication relies boolean constraint propagation bcp bcp corresponds iterative application example 21 circuit descriptions structural clauses implication graph c e f ffl cnf c c e c c c c c c ffl implication graph f f f f f f f f f f f f f c c e c f c c c e c c c c c c c b unit clause rule proposed davis et al 1960 22 bcp unary clauses used simplify clauses simplification possible clause becomes unsatisfied implication started adding unary clause represents initial signal assignment cnf unary clauses computed bcp correspond implications initial assignment force corresponding signals certain logic value time consuming task bcp search clauses simplified unit clause rule search necessary working implication graph since clauses share common variables connected graph 33 implication graph based implication graph based implication simple efficient requires partial traversal implication graph implying signal assignment means first corresponding nodes marked implication graph implication procedure traverses implication graph obeying following rule starting initial set marked nodes successor nodes j marked ffl node j node predecessors marked ffl node j represents encoding bit least one predecessor marked rule applied propagation marks possible nodes marked represent signal values implied initial assignment given conflicting signal assignments easily detected implication since cause nodes c x c x marked let us use circuit ex 21 sake explanation assigning logical value 0 signal e corresponds marking node c e implication graph running implication proce dure following nodes marked c c c f finally obtain implied signal values respect given logic marked nodes decoded according given encoding ie determine deriving indirect implications contrary direct implications detection indirect implications requires special analysis logic function circuit represent information circuit obvious description methods computation indirect implications subject order dependency indirect implications found certain indirect implications already discovered order avoid problem suggested iterate computation 18 41 structure based socrates algorithm 12 first introduce computation indirect implications using following tautologies eq 4 law contraposition may generate candidate indirect implication eq 5 identifies fix value indirect implications primarily computed preprocessing phase idea temporarily set given signal certain logic value possible direct implications signal assignment computed implied signal values checked contrapositive cannot deduced direct implications learning criterion case contrapositive indirect implication indirect implications cannot represented within data structure used describe circuit structural algorithms store external data structure adds additional complexity structure based algorithms 42 clause based clause based computation 17 18 similar structural algorithm sec 41 free literal contained cnf temporarily set 1 bcp used derive possible direct implications ie unary clauses generated unary clauses b checked contrapositive b indirect im plication case corresponding clause b added clause database thereby indirect implications enrich data structure used representing circuit functionality indirect implication added clause database longer require special attention one important advantage clause based algorithms structure based approaches 18 43 andor enumeration different approach known recursive learning taken kunz et al 3 7 indirect implications deduced search 23 possible implications resulting signal assignment search performed recursively injecting reversing signal assignments correspond different possibilities justifying gate followed deriving direct implications signal values common justifications gate yield indirect implications simple structural algorithm executing implications applied let us illustrate principles andor enumeration circuit ex 21 andor tree found fig 4 level 2 level 0 initial assignment f level 1 figure 4 andor enumeration root node andor tree reflects initial assignment andtype 2 example logical 0 assigned signal f signal values implied ornode successor root node justifications 0g order derive indirect implication search implied signal values common justifications implied justifications represented new ornode level 0 andor tree general new ornodes level 0 correspond indirect implications examination gates level 2 become unjustified setting b 0 yield additional indirect implications 44 implication graph based implication graph based method computing indirect implications inherits advantages clause based techniques eliminates costly search process required bcpbased implication moreover approach integrates computation indirect implications based law contraposition andor enumeration framework general andnode marked arc represents signal assignment due justification unjustified gate whereas ornode denotes signal value implied chosen justification justified gates correspond orleaves unjustified gates internal ornodes andor graph 3 441 reconvergence analysis basic idea determining indirect implications search reconvergencies shown fig 5 implication c c b c indirect direct c c x c x c c figure 5 learning contraposition implication graph deduced direct implication c forms indirect impli cation node passed predecessors marked ie forms reconvergent node implication start implication node c b however cannot pass node predecessor c x marked applying law contraposition c c b deduce c c implied c b observation expressed following lemma assignment reconvergent structure c implication graph yields indirect implication c x ffl c x fanout node implication graph ffl node c marked via node predecessors node marked implying along disjoint paths implication graph proof 21 using lemma 1 shown search reconver gencies implication graph detects indirect implications found clause structural based approaches implications found bcp en coded clause description identified search reconvergent structures defined lemma 1 proof 21 explain reconvergence analysis implication graph ex 21 lets assume fanout node c b marked implication procedure sec 33 invoked c c e marked succeeding node c f marked node reached via two disjoint paths graph indicated dashed solid line respectively contrapositive c b forms indirect implication indirect implication included graph form grey edge leading node c f node c b applying graph analysis offers following advantages 1 search reconvergence regions implication graph reduces set candidate signals may yield indirect im plication clause based methods temporarily assign value literals contained cnf 2 reconvergence analysis carried fast adapted version algorithm presented 24 3 method require learning criterion approach 12 442 extended reconvergence analysis contrary reconvergence analysis sec 441 extended reconvergence analysis detects conditional reconvergencies signal nodes corresponds andor search implication graph need following definitions clause c c 1 c 2 c n called unjustified evaluate 1 least one complement c literal c 1 unjustified ternary clauses found implication graph without effort represented nodes exactly one two predecessors marked unspecified literals unjustified let v 1 denote assigned values set nonconflicting assignments called justification clause c value assignments j makec evaluate 1 clause based framework complete set justifications j c unjustified clause c easily given j 1gg approach set j c even simpler ternary clauses unjustified 3 therefore j c always consists exactly two justifications explain two justifications derived implication graph fig 6 given ternary clause c c x c z c x c z c figure unjustified ternary clause c x c c z due assignment c z unjustified due assignment c indicated two nodes exactly one predecessor ternary clause justified setting c z c 1 consider subgraph denoting ternary clause c x c c z straightforward graphical representation following formulae c x c x c c becomes apparent possible justifications j c found consequents implications literal making clause unjustified ie c x antecedent consequents correspond successors two nodes let us explain extended reconvergence analysis corresponds efficient andor search implication graph help fig 7 showing implication graph ex 21 initial assignment c clause c unjustified next possible justifications j determined successors two nodes 1 2 belonging clause c nodes correspond andnodes j 1 j 2 andor tree respec 3 binary clause unjustified according definition 2 reduces unary clause unary clauses represent necessary assignments implied signal values given signal assignment tively distinguish consequences two justifications one assigned different color thus node c marker represented dashed lines fig 7 signals implied c marked green done c using red marker dotted lines fig 7 nodes assigned colors ie nodes markers reconverge implied independent chosen justification nodes therefore elevated previous level andor tree example node c b marked colors derive indirect implication c b analysis unjustified clauses c b c g level 2 andor tree yield additional indirect implications example indicates trace extended reconvergence analysis identical andor tree generated andor enumeration marked nodes converted andnodes marked signal nodes ornodes obviously extended reconvergence analysis capable determining indirect implications given enough colors ie complete efficient procedure implementing extended reconvergence analysis given 21 takes advantage implication graph encoding colors locally nodes using bit slices full machine word thus subtrees andor tree stored parallel different bitlevels additionally bitparallel version implication algorithm introduced sec 33 used algorithm supports depth r levels andor tree 2 r bit architecture decalphastation example maximal depth 6 levels available let us briefly summarize advantages 1 implication graph model allows full word size exploited means bitparallel techniques search indirect implications requires efficient set operations ornode may elevated successor andnodes belonging unjustified clause set operations carried effectively implication graph performing local bitoperations signal nodes separate data structure needed please note advantage efficient set operations remains extend algorithm handle arbitrary depths andor enumeration already done 2 notion unjustified gates necessary 3 7 reduces simple concept unjustified ternary clauses due concept uniformity description andor enumeration easily performed arbitrary logics applying pro cedure already done logic l 10 contrary higher valued logics complicated deal structural approach 7 3 3 detected indirect implications included graph immediately often facilitates computation indirect implications 4 indirect implications easily computed law contraposition requiring high depth andor search approach integrates methods one framework indirect implications identified best suited technique 5 experimental results implication engine presented paper implemented c language library functions applied successfully several cad problems please note c c e c f c c c e c c c c c c c b level 2 level 1 level 0 j initial assignment fc c c c c c c 3 1 j 2 figure 7 extended reconvergence analysis implication graph presented results already published papers dealing application specific issues underlying implication engine discussed included results order show efficiency flexible approach experiments atpg netlist optimization carried decstation3000600 experiments equivalence checking performed decalphastation250 4266 atpg netlist optimization rely earlier version implication engine support techniques sec 442 far advanced techniques used equivalence checking table 3 presents results atpg considering various fault models 25 26 27 due flexibility implication graph nonrobust robust stuckat c5315 342117 6434 81435 52518 5291 12 c7552 277244 14994 86252 57460 7419 52 table 3 result test pattern generation various logics l 3 required different fault models could easily handled table 3 gives number tested faults cpu time required performing atpg nonrobust robust path delay faults well stuckat faults combinational circuits sequential circuits enhanced scan design excellent quality achieved results seen fur circuit gates literals delay time c1908 488 402 933 803 412 339 1364 red 81 32 188 table 4 results delay optimization ther tables 25 26 27 extensive comparison stateoftheart tools made results optimization mapped netlists respect delay provided table 4 basic idea approach applies implication engine verify permissibility circuit transformations described 6 number gates literals circuit delay optimization well required cpu time given results equivalence checking netlists presented table 5 lists total time required equivalence checking ie circuit times level max total indirect implications c432 13 12 1 table 5 results verifying redundancy free circuits atpg plus computation indirect implications time consumed latter columns 2 3 respectively maximal depth andor search necessary successful verification also given column 4 provide early results order show implication engine forms suitable data structure building efficient equivalence checker straightforward approach adopts basic idea wellknown equivalence checker hannibal 28 include advanced heuris tics eg observability implications heuristics candidate se lection nevertheless results shown table 5 comparable ones reported 28 indicates implication engine well suited equivalence checking please note easily incorporated stateoftheart implication based hy brid ie bdds combined implications equivalence checkers approaches benefit 6 conclusion paper proposed efficient implication engine working flexible data structure called implication graph shown indirect implications effectively computed analysis graph experimental results confirm efficiency flexibility approach future preliminary equivalence checker extended deriving observability implications directly implication graph furthermore investigate hybrid technique using bdds implication graph advantageous equivalence checking acknowledgements authors grateful prof kurt j antreich many valuable discussions advice like thank bernhard rohfleisch hannes wittmann using implication engine netlist optimization tool developing path delay atpg tool respectively r multilevel logic optimization implication analysis lot logic optimization testability new transformations using recursive learning andor reasoning graphs determining prime implicants multilevel combinational networks combinational sequential logic optimization redundancy addition removal perturb simplify multilevel boolean network optimizer logic clause analysis delay optimization recursive learning new implication technique efficient solutions cad problems test veri fication optimization advanced verification techniques based learning novel framework logic verification synthesis environment verilat verification using logic augmentation transformations aquila equivalence verifier large sequential circuits socrates highly efficient automatic test pattern generation system improved deterministic test pattern generation applications redundancy identification accelerated dynamic learning test pattern generation combinational circuits functional learning new approach learning digital circuits static logic implication application redundancy identification test pattern generation using boolean satisfiability com binational test generation using satisfiability transitive closure algorithm test generation grasp new search algorithm satisfiability satbased implication engine computing procedure quantification theory method fault simulation based stem regions formal nonheuristic atpg approach bit parallel test pattern generation path delay faults path delay atpg standard scan designs hannibal efficent tool logic verification based recursive learning tr artificial intelligence perturb simplify multilevel logic optimization implication analysis advanced verification techniques based learning logic clause analysis delay optimization path delay atpg standard scan design formal nonheuristic atpg approach verilat graspmyampersandmdasha new search algorithm satisfiability computing procedure quantification theory bit parallel test pattern generation path delay faults static logic implication application redundancy identification ctr joo marquessilva lus guerra e silva solving satisfiability combinational circuits ieee design test v20 n04 p1621 january f lu k iyer g parthasarathy lc wang kt cheng k c chen efficient sequential sat solver improved search strategies proceedings conference design automation test europe p11021107 march 0711 2005 alexander smith andreas veneris anastasios viglas design diagnosis using boolean satisfiability proceedings 2004 conference asia south pacific design automation electronic design solution fair p218223 january 2730 2004 yokohama japan paul tafertshofer andreas ganz sat based atpg using fast justification propagation implication graph proceedings 1999 ieeeacm international conference computeraided design p139146 november 0711 1999 san jose california united states sean safarpour andreas veneris rolf drechsler joanne lee managing dont cares boolean satisfiability proceedings conference design automation test europe p10260 february 1620 2004 ilia polian bernd becker multiple scan chain design twopattern testing journal electronic testing theory applications v19 n1 p3748 february christoph scholl bernd becker checking equivalence partial implementations proceedings 38th conference design automation p238243 june 2001 las vegas nevada united states ilia polian hideo fujiwara functional constraints vs test compression scanbased delay testing proceedings conference design automation test europe proceedings march 0610 2006 munich germany lus guerra e silva l miguel silveira joa marquessilva algorithms solving boolean satisfiability combinational circuits proceedings conference design automation test europe p107es january 1999 munich germany e goldberg prasad r brayton using sat combinational equivalence checking proceedings conference design automation test europe p114121 march 2001 munich germany joo marquessilva thomas glass combinational equivalence checking using satisfiability recursive learning proceedings conference design automation test europe p33es january 1999 munich germany ilia polian hideo fujiwara functional constraints vs test compression scanbased delay testing journal electronic testing theory applications v23 n5 p445455 october 2007 ilia polian alejandro czutro bernd becker evolutionary optimization codebased test compression proceedings conference design automation test europe p11241129 march 0711 2005 joo p marquessilva karem sakallah boolean satisfiability electronic design automation proceedings 37th conference design automation p675680 june 0509 2000 los angeles california united states ilia polian bernd becker scalable delay fault bist use lowcost ate journal electronic testing theory applications v20 n2 p181197 april 2004
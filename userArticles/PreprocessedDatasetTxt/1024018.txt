arithmetic circuits polynomial replacement systems paper addresses problems counting prooftrees introduced venkateswaran tompa counting proofcircuits related seemingly natural question problems lead common generalization straightline programs call polynomial replacement systems prss contribute classification systems investigate complexity diverse problems falling within scope study include example counting proofcircuits evaluating cupcircuits natural numbers number complexity results obtained including proof counting proofcircuits numpcomplete b introduction 11 motivation g3 theta replace adjacent figure gate g 1 input evaluates 9 equivalently treelike boolean circuit obtained circuit drawn 9 proof trees vt89 ie 9 different minimal subcircuits witnessing outputs 1 gates replicated form independent relationship proof tree counting monotone arithmetic circuits used venkateswaran ven92 characterize nondeterministic time classes including p val79 vinay vin91a characterize counting version logcfl sud78 relationship triggered investigation nc 1 caussinus et al cmtv98 ac 0 allender et al aad97 see aml98 let98 all98 recent results motivation study small arithmetic classes recent goal capture small arithmetic classes counting objects proof trees notably paths graphs allender et al aab succeeded identifying appropriate graphs ac 0 early motivation present work desire avoid unwinding circuits trees counting proofs define proof circuit minimal subcircuit witnessing circuit outputs 1 precisely boolean circuit c input x proof circuit edgeinduced connected subcircuit c evaluates 1 x subcircuit must contain output gate c well exactly one cedge gate cedges informatique et recherche operationnelle universite de montreal cp 6128 succ centreville montreal quebec h3c 3j7 canada research performed part leave universitat tubingen supported german dfg canadian nserc quebec fcar mckenzieiroumontrealca theoretische informatik universitat wurzburg exerzierplatz 3 97072 wurzburg germany research supported northern telecom vollmerinformatikuniwuerzburgde z theoretische informatik universitat wurzburg exerzierplatz 3 97072 wurzburg germany research supported dfg grant wa 84712 wagnerinformatikuniwuerzburgde gate reader convince circuit depicted 9 proof trees input x proof circuits input counting classes arise counting proof circuits instead trees question held stock several surprises led us totally unforeseen path first surprise following algorithm 1 replace theta negationfree boolean circuit c 2 view c straightline program prescribing usual way formal polynomial input variables x 3 compute polynomial topdown important proviso step knock nontrivial exponent 1 intermediate sumofmonomials representation get number proof circuits c input x evaluating final polynomial x example circuit depicted 7 proof circuits input x 4 became g 4 middle step 3 ones intuition might simple strategy could massaged arithmetic circuit least sublinear parallel algorithm vsbr83 second surprise counting proof circuits even depth4 semiunbounded circuits pcomplete hence strategy hard parallelize likely genuinely requires exponential time surprise algorithm thus counts proof trees absence idempotent rules counts proof circuits presence moreover whereas arithmetic circuit computing number proof trees circuit readily available producing circuit compute proof circuits seems intractable special idempotent rules would effect multivariate rules nontrivial rules would nonetheless permit expressing counting form arithmetic circuit general framework complexity questions investigated 12 results view results forming three main contributions first contribution define classify polynomial replacement systems prs short prs provide answer framework question prs full generality start polynomial together set replacement rules replacement rule pair polynomials applicable polynomial q q written form appears applying p consists replacing p 1 p 2 see sect 3 formal definitions prs generally defines set polynomials since choice sequencing rules way rules applied may generate different polynomials computational problems interest include computing polynomials poly evaluating polynomials specific points eval testing membership ranges range identify four natural families prs simple rules replace variables deterministic two rules lefthand side acyclic nontrivial infinite sequence rules applicable idempotent rules 2 present general prs obtain canonical forms discuss representation outline broad complexity issues detailed complexity analysis involves simple prs instance exhibit simple deterministic prs range npcomplete prs given part input poly phard corp range npcomplete eval pcomplete second contribution concerns specific case proof trees proof circuits prove boolean circuit c input x corresponds easily computable idempotent simple deterministic acyclic prs property number proof trees resp proof circuits c x maximum resp minimum value eval problem x vice versa see lemma 513 offers one viewpoint reason algorithm subsect 11 counts proof circuits correctly also prove computing minimum eval problem idempotent simple deterministic acyclic prs pcomplete equivalently counting proof circuits pcomplete turing reductions manyone reductions unless pnp provides new characterization p contrasted venkateswarans polydegreepolydepth characterization ven92 retarded polynomials characterization babai fortnow bf91 also prove detecting whether circuit proof trees proof circuits npcomplete third contribution concerns specific case simple acyclic prs prove eval problem prs evaluation problem f thetagcircuits circuits considered previously name hierarchical descriptions wag84 wag86 obtained generalizing trees general circuits f thetagexpressions aka integer expressions whose evaluation problem shown npcomplete 25 years ago stockmeyer meyer sm73 pspaceupper bound given wag84 conclude evaluation simple acyclic prs polynomial space algorithm though result could also obtained directly consider link f thetagcircuits interesting 1 13 paper organization section 2 defines proof trees circuits proves complexity results selfcontained way independent prs formal definition prs well canonical forms found sect 3 section 4 briefly discusses representation polynomials complexity equivalence testing section 5 describes four natural families prs relates straightline programs f thetagcircuits proof trees vs proof circuits problem section 6 investigates complexity theoretic properties simple prs depth counting circuits vs counting trees 21 definition problems circuit c paper mean circuit basis f g usual sense 2n inputs labelled x 1 interesting following clever proof ke yang yan99 evaluating f thetagcircuits pspacehard kes result implies evaluating simple acyclic prs pspacecomplete settling question posed 1999 dimacsdimatia workshop describing present work fix input x c unwind c tree c 0 repeatedly duplicating gates fanout greater 1 define accepting subtree subgraph h c 0 whose gates evaluate 1 additionally fulfills following properties subtree h must contain output gate c every gate v h input wires v must h every gate v h exactly one input wire v must h wires nodes obtained way belong h cx denote number accepting subtrees c define accepting subcircuit subcircuit h c properties ie difference start unwinding c tree given input x let c cx denote number accepting subcircuits c x since accepting subtree subcircuit circuit c form proof c evaluates 1 given input also refer proof trees proof circuits resp consider following problems input circuit c f g input number k unary input circuit c f g input observe unwind circuit tree may exponential blowup size consequence number accepting subtrees may doublyexponential size original circuit possible problem pc values function exponential input length order achieve fair comparison complexity problems therefore count proof trees modulo exponential number 22 initial reductions lemma 21 pt complete fp log proof wellknown connection counting accepting subtrees evaluation circuits vin91b ven92 jia92 pt 2 fp since sufficient evaluate circuit modulo exponential number let f 2 fp x 2 f0 1g let f inputs length jxj computed polynomial size circuit c let output gates c let subcircuits c whose output gates gates say c unambiguous every circuit one accepting subtree may suppose without loss generality c unambiguous lan93 let c trivial circuit 2 accepting subtrees fx equal number accepting subtrees circuit lemma 22 1 following problem npcomplete log given circuit c input x cx 6 c cx 2 following problem pcomplete log given circuit c input x 2 f0 1g proof 1 containment np obtained following algorithm input c guess input x evaluate every gate c check gate g inputs evaluate 1 least 2 different paths g output c simultaneously contained accepting subtree latter problem essentially gap problem since check two paths g cs output gate join gate c gates paths evaluate 1 prove completeness give reduction 3sat given 3cnf formula f construct f g circuit c f structure c f actually formula let c 0 fixed circuit differing numbers accepting subtrees subcircuits circuit cx 6 c cx input x f satisfiable 2 observe algorithm given proof case 1 deterministic input x guessed hence problem examined p completeness also shown along lines time using pcomplete circuit value problem q remark 23 restrict attention circuits depth problem case 2 lemma dspaced witnessed wellknown depthfirst search circuit evaluation algorithm used show 23 counting proofcircuits pcomplete functions f h say f log 1t h functions computable logarithmic space x theorem 24 pc complete p log 1t p proof conjunctive normal form h 3 literals per clause define sah number satisfying assignments variables h known see val79 sa p mcomplete p describe log 1t reduction sa pc conjunctive normal form 3 literals per clause define f gcircuit ch whose inputs set 1 6 levels stratified e edges gates adjacent levels levels follows 1 level 1 consists 1gates v ikl 2 level 2 consists gates v ik incoming edges v ik0 v ik1 3 level 3 consists gates v incoming edges 4 level 4 consists gates w gate w j incoming edges gates v x j appears clause c gate w 0 j incoming edges gates v x j appears clause c construction gate input wires produced replace constant 1gate 5 level 5 consists gates u gate u j incoming edges gates w j consists output gate gate incoming edges gates let 1g define circuit ch 1 subcircuit ch results cutting edge w u j n following facts easy see fact 1 pc fact 2 exactly k clauses h pc fact 3 satisfy h pc fact 4 sah hence sah easily computed pcch 1t pc assume pc complete p p reductions let 2 np function p x 2 fx 0 x assumption manyone reduction g f pc hence x 2 pc latter condition however checked polynomial time since underlying boolean circuit positive number proof circuits evaluates 1 boolean semiring q given proof shows problem pc remains pcomplete even restricted monotone circuits 3 generate polynomials straight line program p variables x set instructions one following variable appears left hand side variables never appear left hand side input variables variable xm output variable given values input variables values variables computed obvious way value computed p value output variable let p p numbertheoretic function computed way p straight line program hence another way looking arithmetic circuit mentioned connection problem counting proof trees evaluation arithmetic circuits see obvious algorithm determine number proof trees circuit consists producing appropriate straight line program evaluating order variables sect 11 sketched related proof circuit counting algorithm next give precise description algorithm given circuit c input gates x inputs noninput gates c topological order e total order gates c consistent partial order given wires hence wire u v 1 transform c straightline program p 2 following manipulate polynomial p variables g 1 initially set p g 3 31 replace variable g p right hand side instruction p whose left hand side g 32 transform p sumofmonomials form 33 reduce powers variables p 1 e replace z 2 z z variable end step p multilinear polynomial 4 substitute values evaluate resulting expression see algorithm correctly counts proof circuits let mc following nondeterministic turing machine input x mc first evaluates gates c input x prunes away zero gate unless output gate g c pruned away mc starts g pruned circuit implements recursive procedure evaluate gate g evaluate triggers consecutive recursive calls one predecessor g gate evaluate triggers single recursive call predecessor g chosen nondeterministically gate predecessor evaluate simply accepts well known mc cx accepting paths see eg cmtv98 mc made c cx accepting paths instead simply making sure whenever evaluate encounters gate g second time g treated constant gate 1 reflect fact choice accepting subcircuit rooted g already made first encounter let c c machine mc modified way algorithm sect 11 formalized precisely computes number accepting paths c c encountering gate g twice means different paths g meet gate recall proof lemma 22 equivalent straightline arithmetic program point view obtaining monomial appears replacing g 2 g thus precisely models counting number accepting paths c c thus number proof circuits c input x summarize algorithm compute proof circuits produces polynomial computing argument number proof trees circuit c input x 1 obtained evaluating straightline program given c whenever possible computation replace power x 2 x particular type polynomial replacement systems define next polynomial replacement systems produce sets polynomials given start polynomial using rules replacing certain polynomials polynomials similar way formal grammars produce sets words start symbol applying production rules paper almost exclusively consider polynomials nonnegative integer coefficients motivated application proof trees proof circuits discussed write denote p polynomial variables z variable vector x always defined consist us say variable x fictive inessential polynomial px pa means x fictive p p written term x appear definition 31 polynomial replacement system short prs defined quadruple set terminal variables set nonterminal variables q polynomial variables x start polynomial r finite set replacement rules e finite set pairs polynomials variables system generate polynomials definition 32 let delta prs let polynomials variables x exist p 3 polynomial p 5 x let reflexive transitive closure exist 0 polynomials q 0 turns form derivations simplified definition 33 let exist p 3 let reflexive transitive closure lemma 34 normal form replacement prs delta polynomials p 1 proof clearly prove p 1 5 polynomial p 1 represent hence defining polynomials moreover consequently prs thus generates set polynomials hence define definition 35 prs fi fi exists p 0 x q set polys polynomials derive several sets natural numbers whose complexities determine upcoming sections definition 36 let delta prs define phi pa phi pa psi observe also allow negative numbers coefficients polynomials prs ranges decidable seen follows robinsonmatiasjevic result see mat93 every recursively enumerable set represented form phi pa 2 n n psi p suitable nary polynomial integer coefficients let p nary polynomial phi pa psi decidable defining prs pa psi besides membership problems polys ranges evals also consider corresponding variable membership problems prs p 2 polys prs 2 ranges psi 4 representations polynomials equivalence test want examine complexity defined sets talk representations polynomials distinguish different kinds representations definition 41 let px polynomial 1 full representation p sumofmonomials form describe p sequence vectors c e consisting nonnegative integers c e given unary vector stands monomial c delta 2 extended full representation ef representation short describe p sequence vectors time c given binary numbers e given unary 3 formula representation p described formula involving variables x precisely set formulas variables x defined inductively following rules formulas b f g formulas 4 straightline program representation slp representation short describe p straightline program input variables x computes p phi representation polynomial one types denote polynomial represented phi p phi easy see definition introduces chain representations increasing succinctness every representation type polynomial equivalent representations types j j computed logarithmic space moreover p full ef formula representation size n degree p bounded n p slp representation size n degree p exponential n idea use slps data structure polynomials introduced promoted erich kaltofen see eg kal88 though succinctness way representing polynomials compared full ef representation called sparse representations considered literature seems nonnegligible one results paper complexity sets defined sect 3 differ go one form representation another central problem upcoming sections complexity problem determine two representations stand polynomial e complexity equivalence problem representations polynomials p phi 1 various types representations similar result give next theorem obtained im83 theorem 42 equivalence problem 1 p full ef representation 2 corp formula slp representation proof make instrumental use following wellknown result sch80 zip79 see also mr95 p 165f proposition 43 schwartzzippel let px polynomial degree field f zero polynomial let f finite set let n chosen independently uniformly random proof theorem 42 two polynomials extended full representation equivalent monomials checked polynomial time given two formulas f 1 f 2 know degree two represented polynomials linear length f 1 f 2 hence proposition 43 suffices evaluate f 1 f 2 random input drawn exponential number possible input vectors actual evaluation formulas p finally given two slps p 1 p 2 compared deal fact degree represented polynomial exponential hence numbers operate double exponential therefore cannot carry necessary arithmetic operations polynomial time instead proceed follows see also mr95 p 169 suppose two numbers different ja gamma bj 2 n different prime divisors let denote number primes smaller equal hence random prime smaller k2 n logk2 n probability j b mod p 2 n thus two numbers different different modulo small primes hence equivalent iff inputs exponential range get inequality iff inputs exponential range get inequivalence modulo small primes since set prime numbers zpp algorithm rp algorithm q different types replacement systems definition polynomial replacement systems presented general introduce number natural restrictions approach similar way different restrictions grammar types introduced eg definition classes chomsky hierarchy later view problems counting proof trees proof circuits two instances problem restricted prs types 51 simple polynomial replacement systems definition 51 prs delta simple contextfree polynomials lefthand sides rules r variables fx g definitions made preceding section general prs carry special cases simple systems however simple prs additionally define particular type replacement application rule z q results replacement occurrences z q latter form denoted j contrast notation derivations defined far definition 52 let delta simple prs exist r let reflexive transitive closure j sets polynomials numbers derived simple systems using new derivation type use names use square brackets instead parentheses definition 53 simple prs fi fi exists p 0 x q case polys define definition 54 let delta simple prs define phi pa pa also define following variable membership problems simple prs p 2 polys simple prs 2 ranges fi fi simple prs p 2 polys 2 n psi clear simple prs polys polys hence also ranges ranges evals evals polydelta polydelta rangedelta rangedelta evaldelta evaldelta 52 simple deterministic acyclic polynomial replacement systems definition 55 prs said deterministic two different rules r lefthand side definition 56 let prs dependency graph g directed graph g consists edges j exists rule p r x essential p 1 x j essential p 2 prs said acyclic dependency graph g acyclic lemma 57 every simple deterministic prs exists simple deterministic acyclic prs 0 system 0 obtained polynomial time proof let delta simple deterministic prs acyclic exist k 1 essential p r set nonterminal variables fictive every polynomial p q polys however deterministic hence replacement would necessarily run along cycle described rules p nonfictive variable fx g every p 0 p non fictive variable fx 1 g thus essential variable p fx 1 repeat cycle removement step long prs still cycles since every step least one nonterminal variable removed get polynomial number steps prs simple deterministic acyclic q also obtain following easy properties lemma 58 1 simple deterministic prs polys set consists one polynomial 2 simple acyclic prs polys polys finite proof simple deterministic without loss generality moreover acyclic rules replace every variable unique polynomial since simple always replace occurrences nonterminal variable sooner later hence result whole derivation process unique acyclic every nonterminal variable replaced constant number steps hence obtain finitely many polynomials q note simple acyclic prs polys polys example take 4xg thus requirement deterministic necessary lemma 581 remainder subsection relate simple deterministic simple acyclic prs different forms circuits operating natural numbers first intuitively clear connection simple deterministic acyclic systems straightline programs made precise following lemma lemma 59 1 simple deterministic acyclic prs polys 6 exists slp p g 2 p slp exists simple deterministic acyclic prs fp p polys 3 transformations simple deterministic acyclic prs corresponding slp viceversa computed logarithmic space proof program p obtained transforming every single replacement rule sequence slp instructions ordering according topological order g statement 2 proved similarly statement 3 obvious q next show acyclic systems strongly related new type arithmetic circuit define circuits immediate generalizations integer expressions introduced stockmeyer meyer sm73 therefore call circuits integer circuits confused ordinary arithmetic circuits referring operations allowed thetacircuits integer circuit n inputs circuit c inner nodes compute one operations theta circuit c specified output gate g computes function first define every gate g 2 c function f g computed g 1 g input gate x f g 2 g gate predecessors g l g r f g l psi function computed theta gate defined analogously 3 g gate predecessors g l g r f g l finally function computed c f gs following relation simple acyclic replacement systems integer circuits obtained easy induction lemma 510 1 every simple acyclic prs delta integer circuit c n inputs f c psi 2 n n 2 every integer circuit c n inputs simple acyclic prs 2 n n 3 transformations simple acyclic prs corresponding integer circuit viceversa computed logarithmic space consider following problems phi c integer circuit n inputs integer circuit n inputs analogous notations used restrict gate types allowed following lemma immediate lemma 510 lemma 511 representations following holds 1 nmember theta j log evaldelta 2 nrange theta j log rangedelta 53 idempotent polynomial replacement systems definition 512 prs psidelta idempotent prs derived case simple deterministic acyclic resp say idem idempotent simple deterministic acyclic resp prs prs delta 2 n n write minevals shorthand min pa psi analogously use maxevals lemma 513 1 every boolean circuit c input x k 2 n exists simple deterministic acyclic polynomial replacement system mineval c cx maxeval 2 every simple deterministic acyclic prs idem exists boolean circuit c mineval 3 transformations idempotent simple deterministic acyclic prs corresponding circuit viceversa computed logarithmic space proof arithmetic circuits straightline programs two different views concept hence go circuit c system vice versa exactly lemma 59 clearly simple deterministic acyclic system computes cx explained discussion beginning sect 3 convert idempotent system idem number proof circuits coincides minimal element eval delta consequence algorithm given beginning sect 3 minimal element obtained derivation polynomial rules applied whenever possible maximal element obtained never pick rule e use rules q 6 complexity results simple replacement systems 61 deterministic systems section consider complexity defined sets simple replacement systems let us start complexity fixed membership problems theorem 61 let simple deterministic 1 polys polys pcomplete representations 2 ranges ranges 2 np fact systems problems ranges ranges npcomplete 3 proof first recall polys polys consist one polynomial p full ef representation p finitely many representations hence complexity polys polys trivial however formula slp representation p may infinitely many representations face following problem given slp p case formulas even easier p fixed say p reduced following holds p instructions form x x j never appears right hand side instructions unless x j output variable additionally x j x instruction p polynomials computed x x k constant zero polynomial otherwise instruction useless e g x hence compute anything new might delete instruction instructions use x k instead x j similarly x j require x x k constant one following holds every polynomial p finitely many representations reduced slps except isomorphic renumbering variables moreover program p transformed reduced form follows inductively determine sets variables compute constant zero constant one polynomial remove instructions compute new polynomial change variables instructions described shows polys polys 2 p hardness follows reduction circuit value problem follows let c boolean circuit let p polynomial gives number proof trees c let evaluate 1 iff c cvp 2 decide range multivariate polynomial nonnegative coefficients clearly np obvious guessing algorithm hardness proof give reduction quadratic diophantine equations problem problem an8 gj79 p 250 follows problem consists triples b c quadratic equation solution positive integers define hx define 4variable polynomial pu v x vy b c 2 n equation solution x pa b x x ff u v x hence see quadratic diophantine equations problem reduces range polynomial qu v x ff 3 observe evaluate fixed polynomial hence result follows since addition multiplication tc 0 q concerning variable membership problems simple deterministic systems obtain theorem 62 simple deterministic prs representations 1 polydelta polydelta corp phard log 2 rangedelta rangedelta npcomplete log 3 evaldelta evaldelta pcomplete log proof containment cases given simple deterministic prs first construct polynomial time slp representation unique polynomial p lemma 57 lemma 58 statement 1 follows equivalence test theorem 42 statement 2 guess suitable input values evaluate p statement 3 evaluate p finished bounds exceeded hardness statement 3 give reduction circuit value problem cvp follows given circuit c input c produce replacement system computes number proof trees c input simple deterministic see sect 3 hardwire input c directly resulting polynomial fictive variables e essentially natural number c accepts iff number greater 0 hence proceeding obtain c 2 cvp iff constant 0 polynomial polys polys statement 2 follows theorem 612 q 62 acyclic systems let us next deal simple acyclic necessarily deterministic systems systems sets polys polys finite lemma 58 hence obtain analogously theorem 61 theorem 63 let simple acyclic 1 polys polys 2 p representations 2 ranges ranges 2 np systems problems ranges ranges npcomplete 3 interesting questions arise examine variable membership problems theorem 64 simple acyclic prs representations 1 polydelta contained nphard log 2 rangedelta evaldelta npcomplete log proof containment proofs similar theorem 62 applying lemma 57 select nondeterministically deterministic prs deleting rules originally given prs claim follows since hardness polydelta proven giving logspace manyone reduction sumofsubset problem sos problem sp13 gj79 p 223 polydelta follows let b f0g define prs phi phi note acyclic simple polys consists polynomials without essential variables c 2 n define p c obtain b since deterministic prs lemma 57 assumed acyclic hardness rangedelta follows theorem 62 next prove hardness evaldelta giving logspace manyone reduction sos problem given b proof polydelta obtain b 2 n n q next turn different variable membership problems simple acyclic systems derivations stockmeyer meyer considered integer expressions terminology integer circuits fanout noninput gates 1 operations allowed proved membership problem case npcomplete easy see result carries case also allow multiplication e problems nmember nmember theta expressions npcomplete corresponding problems circuits considered paper later papers wagner wag84 wag86 name hierarchical descriptions pspace upper bound known since lemma 511 member range problems circuits equivalent evaldelta rangedelta problems simple acyclic prs conclude 2 theorem 65 simple acyclic prs representations 1 polydelta 2 exptime 2 rangedelta evaldelta 2 pspace 63 idempotent systems note also case polys polys finite obtain results analogous theorem 61 theorem 66 let simple deterministic acyclic 1 polys idem 2 meantime learned recent manuscript ke yang circuit problems shown pspacecomplete conclude hardness statement 2 theorem 65 2 ranges idem fact systems problem ranges idem npcomplete 3 evals idem variable membership problems following said theorem 67 idempotent simple deterministic acyclic prs representations proof follows trivial evaluation system q lemma 513 shows importance minimization maximization operations case idempotent systems theorem 68 idempotent simple deterministic acyclic replacement systems representations 1 functions minevaldelta minevaldelta pcomplete log 1t reductions 2 functions maxevaldelta maxevaldelta fpcomplete p proof immediate consequence lemma 21 theorem 24 lemma 513 q completeness note remark 69 simple deterministic simple acyclic prs functions minevaldelta fpcomplete proof simple deterministic 2 n obtain lemma 57 lemma 61 slp representation unique polynomial p polys one compute pa hence minimum maximum element computed theorem 62 showing functions fp hardness follows immediately lemma 21 simple acyclic evaluate according topological order g minimal element obtained every variable x consider rules left handside x whose right hand side minimal hence essentially deal deterministic system upper bound follows case maximization treated similarly hardness follows hardness problem deterministic case q 7 conclusion might interest consider complexity pc circuits restricted depth circuit constructed proof theorem 24 depth 5 simply melting gates levels 3 4 makes depth 4 furthermore easy see depth 1 circuits outputgate problem hard depth circuits outputgate next observe problem easy e fp depth 2 circuits outputgate hence also depth 3 circuits outputgate means complexity pc known case depth 3 circuits outputgate equivalently depth 4 circuits outputgate hard see reduces case 4level stratified circuits level 1 1gates level 2 gates level 3 gates level 4 gate output gate problem turn equivalent following problem given naturals b polynomial fx i1m ki delta x ki 2 f0 1g exploit distributivity reexpress polynomial sum monomials replace every x r new polynomial goal compute measured value e unary n interesting see problem computing permanent formulated similar way substituting replace every x r replace every x r 0 nevertheless clear use idea reduce problem computing permanent problem determine complexity sets ranges ranges fixed cases examined equivalent determining complexity range multivariate polynomial nonnegative integer coefficients always npproblem showed 4variable polynomial degree 6 whose range np complete improved complexity theoretic point view obvious open questions course gap lower upper bound theorems 65 67 closed lot interesting questions prs remain open come back problems posed subsect 11 look multivariate rules also seems worthwhile examine besides idempotent systems prs families related various types arithmetic circuits counting problems boolean circuits acknowledgment grateful sven kosub wurzburg thomas thierauf ulm helpful discussions r making computation count arithmetic circuits nineties arithmetization new method structural complexity theory putation computers intractability modern cryptography probabilistic algorithms deciding equivalence straightline programs questions concerning circuit counting classes lowlevel complexity classes greatest common divisors polynomials given straightline programs unambiguity circuits randomized algorithms fast probabilistic algorithms verification polynomial identities word problems requiring exponential time tape complexity deterministic contextfree languages complexity enumeration reliability problems circuit definitions nondeterministic complexity classes counting auxiliary pushdown automata semiunbounded arithmetic circuits fast parallel computation polynomials using processors new pebble game characterizes parallel complexity classes complexity problems concerning graphs regularities complexity combinatorial problems succinct input repre sentation magic circuit pspacecomplete probabilistic algorithms sparse polynomials tr
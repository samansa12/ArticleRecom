designing masking faulttolerance via nonmasking faulttolerance abstractmasking faulttolerance guarantees programs continually satisfy specification presence faults way contrast nonmasking faulttolerance guarantee merely guarantees faults stop occurring program executions converge states programs continually resatisfy specification present paper component based method design masking faulttolerant programs method components added faultintolerant program stepwise manner first transform faultintolerant program nonmasking faulttolerant one enhance faulttolerance nonmasking masking illustrate method designing programs agreement presence byzantine faults data transfer presence message loss triple modular redundancy presence input corruption mutual exclusion presence process failstops examples also serve demonstrate method accommodates variety faultclasses provides alternative designs programs usually designed extant design methods offers potential improved masking faulttolerant programs b introduction paper present new method design masking faulttolerant systems 14 focus attention masking faulttolerance often desirable ideal property system design masking effects faults ensures system always satisfies problem specification hence users system always observe expected behavior token users system systems design systems becomes simpler motivate design method note designers masking faulttolerant systems often face potentially conflicting constraints maximizing reliability minimizing overhead result designers avoid methods yield complex designs since complexity may result reduced reliability moreover avoid methods yield inefficient implementations since system users generally unwilling pay significant cost price performance sake masking faulttolerance therefore key goal method yield wellstructured hence reliable systems still offering potential efficient implementation goals method include ability deal variety faultclasses ability provide designs albeit alternative ones masking tolerant systems typically designed using classical methods replication exception handling recovery blocks goals mind method based use components add tolerance properties faultintolerant system divides complexity designing faulttolerant system designing relatively simpler components adding components fault intolerant system focusing attention efficient implementation components offers potential efficient implementation resulting system call components added first stage correctors added second stage detectors efficient implementation correctors detectors important noted offering potential efficient masking faulttolerant implementations manage complexity adding components system method proceeds stepwise fashion informally speaking instead adding components ensure problem specification satisfied presence faults method adds components two stages first stage method merely adds components nonmasking faulttolerance nonmasking faulttolerance intuitively mean faults stop occurring system execution eventually reaches good state system continually satisfies problem specification second stage method adds components additionally ensure problem specification violated program reaches good states follows faulttolerance system enhanced nonmasking masking component based design prove correctness resulting composite system need ensure components interfere ie continue accomplish task even executed concurrently components end first stage ensure faultintolerant system correctors added interfere second stage ensure resulting nonmasking faulttolerant system detectors added interfere demonstrate method accommodates variety faultclasses using design programs masking faulttolerant byzantine faults input corruption message loss failstop failures specifically design 1 byzantine agreement program whose processes subject byzantine faults 2 alternatingbit data transfer program whose channel messages may lost 3 triple modular redundancy tmr program whose inputs may corrupted 4 new tokenbased mutual exclusion program whose processes may failstop detectable manner tmr byzantine agreement examples also serve provide alternative designs programs usually associated method replication alternatingbit protocol example serves provide alternative design program usually associated method exception handling rollback recovery mutual exclusion case study serves demonstrate focusing addition efficient components method enables design improved programs proceed follows first section 2 recall formal definition programs faults means programs masking nonmasking faulttolerant section 3 present twostage method design masking faulttolerance next section 4 illustrate method designing standard masking faulttolerant programs byzantine agreement data transfer tmr section 5 present case study design masking faulttolerant tokenbased mutual exclusion finally compare method extant methods designing masking faulttolerant programs make concluding remarks section 6 programs faults masking nonmasking tolerances section recall formal definitions masking nonmasking faulttolerance programs 5 order characterize relationship two tolerance types motivate design method presented section 3 programs program p defined recursively consist possibly empty program q set superposition variables set superposition actions superposition variables p disjoint remaining variables p namely variables q superposition action p one two forms hnamei hguardi gamma hstatementi hnamei haction qi k hstatementi guard boolean expression variables p thus evaluating guard may involve accessing variables q note guard action p particular guard actions second ie k form corresponding action q statement atomic terminating update zero superposition variables p thus superposition actions first form update variables q whereas second may since based action q note since statements p update variables q actions p update variables q actions q thus programs designed superposition variables actions underlying programs 6 superposition actions may access update underlying variables whereas underlying actions may access update superposition variables operationally speaking superposition actions first form execute independently asynchronously actions second form execute parallel synchronously underlying action based upon state state program p defined value variable p chosen predefined domain variable state predicate p boolean expression variables p action p enabled state iff guard true state use term state denote state satisfies state predicate closure action preserves state predicate iff state holds action enabled executing statements action instantaneously parallel yields state holds closed set actions iff action set preserves follows definition closed actions p executing sequence actions p starting state holds yields state holds computation computation p fair maximal sequence steps every step action p enabled current state chosen statements instantaneously executed parallel recall actions second form consist multiple statements composed parallel fairness sequence means action p continuously enabled along states sequence eventually chosen execution maximality sequence means sequence finite guard action p false final state problem specification problem specification p satisfies consists safety specification liveness specification7 safety specification identifies set bad finite computation prefixes appear program computation dually liveness specification identifies set good computation suffixes every computation suffix set assume problem specification suffix closed ie computation satisfies problem specification suffixes remark definition liveness stronger alpern schneiders definition 7 two definitions become identical liveness specification fusion closed ie computations hff x fli hfi x ffii satisfy liveness specification computations hff x ffii hfi x fli also satisfy liveness specification ff fi finite computation prefixes fl ffi computation suffixes x program state invariant invariant p state predicate 6false closed p every computation p starting state satisfies problem specification p informally invariant p includes states reached faultfree executions p note may multiple invariants techniques design invariants articulated dijkstra 8 using notion auxiliary variables gries 9 using heuristics state predicate ballooning shrinking techniques mechanical calculation invariants discussed alpern schneider 10 convergence state predicate q converges r p iff q r closed p starting state q holds every computation p state r holds note convergesto relation transitive lemma 21 q converges r p every computation p starting states r holds satisfies liveness specification every computation p starting states q holds satisfies liveness specification proof consider computation c p starting q state since q converges r p c suffix c 1 starting r state since every computation p starting r state satisfies liveness specification c 1 suffix c 2 identified liveness specification also suffix c follows c also satisfies liveness specification thus every computation p starting q state satisfies liveness specification faults faults program subject systematically represented actions whose execution perturbs program state emphasize representation possible notwithstanding type faults stuckat crash failstop omission timing performance byzantine nature permanent transient intermittent observability detectable repairability correctable cases representation faults introduces auxiliary variables example represent failstop fault state perturbation introduce auxiliary variable action restricted execute true failstop fault represented action changes true false thereby disabling actions detectable manner moreover repair failstopped program represented fault action changes false true initializes state j initialization may retain state process failstopped provided information nonvolatile storage may initialize predetermined value ignore details depend problem hand words failstop repair faults respectively represented following fault actions failstop gamma false repair gamma true f initialize state process g represent byzantine fault state perturbation introduce auxiliary variable b specified actions program restricted execute b false ie program nonbyzantine b true ie program byzantine program allowed execute actions change state arbitrarily thus byzantine fault represented action changes b false true thereby enabling program enter mode executes actions change state arbitrarily words byzantine fault represented following byzantine b gamma b true faultspan faultspan program p faultclass f predicate closed p f informally faultspan includes set states p reaches executed presence actions f note p may multiple faultspans f program p invariant subject faultclass f resulting states p may longer satisfy however states satisfy faultspan p say moreover every state also satisfies faulttolerance masking nonmasking ready give formal definition faulttolerance 5 instantiations definition yield definitions masking nonmasking faulttolerance let p program f set fault actions invariant p say p f tolerant iff exists state predicate p following three conditions hold closure closed p f convergence converges p definition may understood follows state invariant holds executing action p yields state continues hold executing action f may yield state hold nonetheless following three facts true last faultspan holds ii subsequent execution actions p f yields states holds iii actions f stop executing subsequent execution actions p alone eventually yields state holds point program resumes intended execution definition instantiated faultspan identical invariant get p masking f tolerant definition instantiated differs get p nonmasking f faulttolerant rest paper predicate p denotes invariant program p moreover predicate p denotes faultspan predicate program p f tolerant p finally faultclass f clear context omit mentioning f thus masking tolerant abbreviates masking f tolerant 3 method designing masking tolerance definitions previous section observe masking nonmasking faulttolerance related follows theorem 31 program p exists p p p nonmasking f tolerant p every computation p starting state p holds satisfies safety specification p exists p p masking f tolerant p proof let np np state predicates satisfying antecedent every computation p starting state np holds satisfies problem specification starting state np holds satisfies safety specification lemma 21 follows every computation p starting np state satisfies problem specification thus choosing p np satisfies consequent method theorem 31 suggests intolerant program made masking tolerant two stages first stage intolerant program transformed one nonmasking tolerant say invariant np faultspan np second stage tolerance resulting program enhanced nonmasking masking follows nonmasking tolerant program transformed every computation upon starting state np holds addition eventually reaching state np holds also satisfies safety specification problem hand address details stages next stage 1 faultintolerant program say p problem specification satisfied computations p start state invariant holds necessarily start state faultspan holds hence add nonmasking tolerance p program component added p restores faultspan states invariant states call program component added p nonmasking tolerance corrector wellknown examples correctors include reset procedures rollbackrecovery forward recovery error correction codes constraint resatisfaction voters exception handlers alternate procedures recovery blocks design correctors studied extensively literature note correctors designed stepwise hierarchical fashion words large corrector designed parallel andor sequential composition small correctors one simple parallel composition strategy superpose small correctors others example sequential composition strategy due arora gouda varghese 11 order small correctors linear manner generally wellfounded manner corrector interfere recovery task correctors lower chosen ordering detailed discussion corrector compositions refer reader 12 stage 2 nonmasking program say np even though problem specification satisfied computations np converge invariant states safety specification need satisfied computations np start faultspan states therefore second stage restrict actions np safety specification preserved convergence computations np invariant states theorem 31 follows resulting program masking tolerant see restriction actions np sufficient preserving safety convergence recall safety specification essentially rules certain finite prefixes computation np consider prefix computation np ruled safety specification execution action following prefix increases length computation prefix one long elongated prefix one prefixes ruled safety specification safety violated words suffices whenever action executed resulting prefix one ruled safety specification follows exists action np set computation prefixes execution action preserves safety specification assuming existence auxiliary state worst case would record history computation steps action np exists state predicate true exactly states execution action preserves safety call state predicate safe predicate action follows action executed state safe predicate satisfied safety preserved restriction actions np enhance tolerance np masking stated precisely action np restricted execute safe predicate holds moreover action np detection safe predicate may require addition program component np call program component added np detecting safe predicate action holds detector wellknown examples detectors include snapshot procedures acceptance tests error detection codes comparators consistency checkers watchdog programs snooper programs exception conditions analogous compositional design large correctors large detectors designed stepwise hierarchical fashion parallel andor sequential composition small detectors thus sum second stage adds one detector per action np restricts action np execute detector action witnesses safe predicate holds concluding discussion stage make three observations application 1 safe predicate several program actions trivially true 2 safe predicate actions requires simple detector components introduce little history state check safe predicate 3 problem specification fusion closed suffix closed history state required check safe predicate observation 1 follows fact actions masking tolerant programs conceptually characterized either critical noncritical respect safety specification critical actions actions whose execution presence faults violate safety specification hence require nontrivial safe predicates words safe predicate noncritical actions merely true example terminating programs eg feedforward circuits database transactions actions produce output commit result critical reactive programs eg operating systems plant controllers actions control progress maintaining safety critical rich class total programs distributed systems 13 eg distributed consensus infima finding garbage collection global function computation reset routing snapshot termination detection decider actions declare outcome computation critical observation 2 follows fact conventional specification languages typically yield safety specifications tested current state current computation step ie set finite prefixes safety specifications rule deduced last last two states computation prefixes thus safety specifications practice require maintenance unbounded history variables detection safe predicates action observation 3 follows fact problem specification fusion closed suffix closed required history information already exists current state proof observation presented 12 verification obligations addition corrector detector components described may add variables actions intolerant program hence invariant faultspan resulting program may different original program addition corrector detector components thus creates verification obligations designer specifically corrector added intolerant program designer ensure corrector actions intolerant program actions interfere even corrector faultintolerant program execute concurrently accomplish tasks corrector restores intolerant program state problem specification intolerant program resatisfied starting state intolerant program satisfies problem specification similar obligations created detectors added nonmasking program even detectors nonmasking program executed concurrently designer ensure detector components components nonmasking program accomplish respective tasks another set verification obligations due fact corrector detector components subject faults intolerant program subject hence designer obliged show components accomplish task spite faults precisely corrector tolerates faults ensuring fault actions stop executing eventually restores program state desired words corrector nonmasking tolerant faults detector tolerates faults never falsely witnessing detection predicate even presence faults words detector masking tolerant faults expected twostage design method used design masking tolerance detectors original design yield masking tolerant detectors adding detectors components superposition one way simplifying verification obligations add components program superposing program program p designed superposition program q trivially true p interfere q although converse need true ie q may interfere p particular superposition wellsuited addition detector components nonmasking tolerant program np stage 2 since detectors need read update state np reason stated definition programs section 2 terms superposition thus detectors interfere tasks corrector components np superposition used verification converse obligation ie np interfere detectors may handled follows ensure corrector np terminates restores np invariant state long terminated prevents detectors witnessing safe predicate aborting detectors execution corrector guarantees detectors never witness safe predicate incorrectly eventual termination corrector guarantees eventually detectors prevented witnessing safe predicate specifically simplified verification obligations resulting superposition explained theorems 32 33 let program p designed superposition q p q theorem 32 q nonmasking f tolerant q p converges q p theorem 33 q nonmasking f tolerant q converges p p converges p p proof since q nonmasking faulttolerant q converges q q since p designed superposition q follows p q converges p q since convergesto relation transitive p q converges p q follows p q converges p q ie converges p p theorems 32 33 imply p designed superposition nonmasking tolerant program q reason p suffices assume q always satisfies invariant q even presence faults discussion alternative strategies verifying interference freedom refer reader 12 section demonstrate method well suited design classical examples masking tolerance span variety faultclasses specifically examples masking tolerance achieve byzantine agreement presence byzantine failure data transfer presence message loss network channels triple modular redundancy tmr presence input corruption notation convenience presenting designs partition actions program processes 41 example agreement recall byzantine agreement problem unique process general g asserts binary value dg every process j system required eventually finalize decision following two conditions hold 1 g nonbyzantine final decision reached every non byzantine process identical dg 2 even g byzantine final decisions reached nonbyzantine processes identical faults corrupt processes permanently undetectably corrupted processes byzantine well known masking tolerant byzantine agreement possible iff least 3f1 processes f number byzantine processes 14 ease exposition restrict attention case total number processes including g 4 hence f 1 generalization multiple byzantine faults presented elsewhere 15 prescribed method design masking tolerant solution byzantine agreement problem two stages starting intolerant program byzantine agreement first transform program add nonmasking tolerance subsequently enhance tolerance masking intolerant byzantine agreement following simple program suffices agreement tolerance faults process g assumed priori finalized decision dg process j g receives value dg process g finalizes decision value end program maintains two variables process j boolean fj true iff j finalized decision dj whose value denotes decision j program two actions process j first action ib1 copies dg decision variable dj denote j yet copied dg add special value domain dj thus j copies dg dj second action ib2 finalizes decision dj j copied decision truthifying fj formally actions intolerant program ib follows invariant program ib g priori finalized decision moreover process finalizes decision dj different final decision nonbyzantine process identical dg hence invariant program ib ib fault actions faults example make one process byzantine provided process byzantine discussed section 2 faults would represented following fault action j nonmasking tolerant byzantine agreement program ib intolerant g becomes byzantine processes finalized decisions g may keep changing dg arbitrarily hence final decisions reached nonbyzantine processes may differ add nonmasking tolerance ib eventually decisions reached nonbyzantine processes identical since ib eventually reaches state decisions processes differ ie 0 1 follows eventually decisions least two three processes g identical hence processes ensure decision majority resulting program nonmasking tolerant nonmasking tolerant program consists four actions process j first two identical actions ib third action nb3 executed j byzantine action nondeterministically changes dj either 0 1 fj either true false fourth action nb4 changes decision j majority three processes formally actions nonmasking program nb follows gamma dj fj 0j1 truejfalse majdefined dj 6maj gamma dj maj majdefined remark formula operation may read value obtained performing commutative associative operation xj values j case j process satisfy rj special case operation conjunction operation disjunction may read rj true xj may read exists process rj xj true moreover rj true ie xj computed processes omit rj notation generalized 16 invariant faultspan program ib program nb nonbyzantine process finalizes decision dj 6 also g remains nonbyzantine nonbyzantine processes reach decision value process g hence faultspan nb tnb observe g nonbyzantine starting state tnb nonmasking program works correctly also g byzantine nonmasking program works correctly starts state processes correctly finalized decisions hence invariant program nb enhancing tolerance masking program nb yet masking tolerant non byzantine process j may first finalize decision incorrectly later correct decision majority processes hence enhance tolerance nb masking suffices j finalize decision dj majority masking program thus consists four actions process j three actions identical actions nb1nb3 nb4 fourth action mb2 restricted j finalizes decision dj majority formally actions masking program mb follows majdefined dj maj gamma fj true invariant faultspan nonmasking program tnb implied invariant smb masking program also smb j finalizes decision dj majority thus smb theorem 41 byzantine agreement program mb masking faulttolerant invariant smb 42 example 2 data transfer recall data transfer problem infinite input array sender process copied one array item time infinite output array receiver process sender receiver communicate via bidirectional channel hold one message direction time required input array item copied output array exactly order sent moreover eventually number items copied receiver grow unboundedly data transfer subject faults lose channel messages design masking tolerance data transfer two stages resulting program well known alternatingbit protocol intolerant program iteratively simple loop followed sender sends copy one array item receiver r upon receiving item r sends acknowledgment enables next array item sent end program maintains binary variables rs rr rs 1 received acknowledgment last item sent rr 1 r received item yet sent acknowledgment 0 1 items transit r denoted sequence cs 0 1 acknowledgments transit r denoted sequence cr finally index input array corresponding item send next denoted ns index output array corresponding item r last received denoted nr intolerant program contains four actions first two last two r id1 sends item r id2 receives acknowledgment r id3 r receives item id4 r sends acknowledgment formally actions intolerant program id follows c1 ffi c2 denotes concatenation sequences c1 c2 id2 cr 6hi gamma rs cr ns ns remark brevity ignored actual data transfered sender receiver use array index data invariant r receives item ns holds equation continues hold receives acknowledgment receives acknowledgment ns exactly one larger nr equation continues hold r receives next item also cs nonempty cs contains one item hnsi finally state exactly one four actions enabled hence invariant program id id rs fault actions faults example lose either item sent r acknowledgment sent r corresponding fault actions follows cs 6hi gamma cs tailcs cr 6hi gamma cr tailcr nonmasking tolerant program program id intolerant deadlocks fault loses item acknowledgment hence add nonmasking tolerance fault adding action detects item acknowledgment lost recovers id retransmitting item thus nonmasking program consists five actions four actions identical actions program id fifth action retransmits last item sent action executed channels cs cr empty rs rr zero practice action implemented waiting predetermined timeout sender sure either item acknowledgment lost present abstract version action formally actions nonmasking program nd follows gamma cs cs ffi hnsi faultspan invariant item acknowledgment lost program reaches state cs cr empty rs rr equal zero also even presence faults cs nonempty contains exactly item whose index input array hnsi thus faultspan nonmasking program rs invariant invariant id ie enhancing tolerance masking program nd yet masking tolerant since r may receive duplicate items acknowledgment r lost hence enhance tolerance masking need restrict action id3 r copies item output array iff duplicate upon receiving item r checks nr exactly one less index number received item r receive every item exactly thus enhance tolerance masking adding check program nd however check forces size message sent r grow unboundedly however exploit fact nd ns nr differ 1 order simulate check sending single bit item follows process adds one bit bs every item sends bit values added two consecutive items different bit values added item duplicates thus detect message duplicate r maintains bit br denotes sequence number last message received follows item received r duplicate iff br sequence number message masking program consists five actions actions follows gamma rs cs 0 cs ffi hns bsi md2 cr 6hi gamma rs cr ns bs ns gamma cs cs ffi hns bsi gamma headcs 2 6br cs rr tailcs 1 gamma remark observe masking program array index ns nr need sent channel suffices send bits bs br modification resulting program alternating bit protocol invariant state reached presence program fault actions cs nonempty cs exactly one item hns bsi also r receives item nr ns holds equation continues hold receives acknowledgment moreover bs ns mod 2 br nr mod 2 exactly one five actions enabled finally nr ns nr one less ns thus invariant masking program smd rs bsns mod ns theorem 42 alternatingbit program md masking tolerant invariant smd 43 example 3 tmr recall tmr problem three processes share output binary value input inj process j required output set binary value faults corrupt input value one three processes intolerant tmr absence faults suffices set inj process j hence action program ir process j follows denotes output yet set fault actions example faults corrupt input value inj one process represented following fault actions one j k also ranges nonmasking tmr program ir intolerant since may set incorrectly corrupted inj therefore add nonmasking tolerance ir add corrector eventually corrects since one inj corrupted correct output differ one inj hence differs inj two processes corrector resets inj value two thus nonmasking program nr consists two actions process j action nr1 ir1 action nr2 corrector formally two actions follows phi denotes modulo 3 addition gamma inj gamma inj enhancing tolerance masking program nr yet masking tolerant since may set incorrectly corrected therefore enhance tolerance masking restrict action nr1 output always set uncorrupted inj safe predicate restriction action nr1 restricting action nr1 safe predicate yields stronger version action nr2 thus resulting masking tolerant program mr consists one action j gamma inj invariant program mr equal inj j exists another process whose input value inj hence invariant program mr smr theorem 43 triple modular redundancy program mr masking tolerant invariant smr section design new improved masking tolerant solution mutual exclusion problem using twostage method recall mutual exclusion problem multiple processes may access critical sections provided time one process accessing critical section moreover process wait forever access critical section assuming process leaves critical section finite time assume processes unique integer ids instant process either processes execute program actions actions executed process j may involve communication processes connected j via channels channels bidirectional fault failstops one processes ie renders process failstops may occur finite number order time process long set processes remains connected one class solutions mutual exclusions based tokens tokenbased solutions unique token circulated processes process enters critical section necessarily token ensure process waits forever token fair strategy chosen process requests access critical section eventually receives token elegant tokenbased program independently due raymond 17 snepscheut 18 program uses fixed tree circulate token case study organized follows section 51 recall abstract version intolerant mutual exclusion program raymond snepscheut section 52 transform faultintolerant program nonmasking tolerant one adding correctors finally section 53 enhance tolerance masking adding detectors resulting solution compared masking tolerant tokenbased mutual exclusion solutions next section 51 faultintolerant program processes organized tree process j maintains variable pj denote parent j tree variable hj denote holder process j neighbor j direction process token variable requestj denote set requests received neighbors j tree pending j program consists three actions process first making propagating holder process request getting token second transmitting token satisfy pending request neighbor third accessing critical section holding token actions follows j needs request critical section requestj 6 oe gamma gamma hk hj j j requestk gamma access critical section actions maintain holder relation forms directed tree rooted process token holder relation moreover conforms parent tree ie k holder adjacent tree thus invariant faultintolerant program im j p n 52 nonmasking tolerant version presence faults parent tree used im may become partitioned result holder relation may also become inconsistent moreover token circulated im may lost eg process token ie whose holder equals failstops hence add nonmasking tolerance failstops need add corrector restores parent tree holder tree build corrector superposing two correctors nt corrects parent tree nh corrects holder tree particular ensure presence failstops eventually parent tree constructed holder relation identical parent relation hence root process token 521 designing corrector nt parent tree corrector reconstructs parent tree reuse aroras program 19 tree main tenance program allows faults yield program states multiple trees unrooted trees continued execution program ensures convergence fixpoint state exactly one rooted spanning tree deal multiple trees program actions merge trees merge actions use integer variable rootj denoting id process j believes tree root follows process j merges tree neighboring process k rootk rootj upon merging j sets rootj equal rootk pj k also j aligns holder relation along parent relation setting hj k observe merging thus cycles formed root value process remains root value parent merge actions enabled follows rooted processes root value deal unrooted trees program actions inform processes unrooted trees root process actions use variable colj denoting color j follows process detects parent failed color parent red process sets color red leaf process obtains color red separates tree resets color green thus forming tree consisting leaf separates tree aligns holder relation along parent relation setting holder formally actions corrector nt process j follows adjj denotes set neighbors process j gamma colj red gamma pj rootj hj k rootk k fault actions formally failstop action process j follows failstop upj gamma upj false faultspan invariant presence faults actions nt preserve acyclicity graph parent relation well fact root value process root value parent also preserve fact process colored red parent also colored red thus faultspan corrector nt predicate tnt graph parent relation forest faults stop occurring eventually program ensures process colored red children colored red ie processes unrooted tree colored red furthermore program reaches state processes colored green ie process unrooted tree finally graph parent relation forms rooted spanning tree particular root values processes identical remark henceforth brevity use term chj denote children j term j root denote parent j j colj green j term nbrsx denote set processes adjacent processes set processes x including x formally j root j pj j colj green upj 522 designing corrector nh holder tree parent tree reconstructed holder relation may still inconsistent two ways 1 holder j need adjacent j parent tree 2 holder j may adjacent j tree holder relation forms cycle hence corrector nh restores holder relation consists two actions action nh1 corrects holder j 1 holds setting hj pj action nh2 corrects holder j 2 holds parent k j holder j k holder k j j breaks cycle setting hj pj net effect executing actions eventually holder relation identical parent relation hence root process token gamma hj pj gamma hj pj faultspan invariant corrector nh ensures holder j adjacent j parent tree every edge j pj parent tree either hj pj hpj j thus nh corrects program state 523 adding corrector verifying interference freedom described earlier corrector add im built superposing two correctors nt nh nh updates holder relation nt read holder relation therefore nh interfere nt also nt reconstructs tree satisfies snt none actions enabled therefore nt interfere nh im updates variables read nt therefore im interfere nt also nh reconstructs holder relation satisfying predicates snh1 j snh2 j process j snh1 j snh2 j respectively preserved im therefore im interfere nh finally tree holder relation reconstructed nt snh satisfied actions nt nh disabled therefore nt nh interfere im follows corrector consisting nt nh ensures state satisfying nt snh reached even executed concurrently im since nt snh may add corrector im obtain nonmasking tolerant program nm whose actions process j follows faultspan invariant invariant program nm conjunction snt snh thus invariant nm faultspan program nm equal tnt ie theorem 51 mutual exclusion program nm nonmasking faulttolerant snm 53 enhancing tolerance masking actions nm5nm7 nm8 affect safety program execution process executing sets holder thereby generating new token safe predicate hold generation token therefore condition process token towards detection safe predicate exploit fact nm nonmasking tolerant token lost nm eventually converges state graph parent relation rooted tree holder processes parent hence suffices check whether program state perform check let j initiate diffusing computation whenever j executes action nm5nm7 nm8 j completes diffusing computation successfully safely generate token actions nm2 nm3 respectively let process k transmit token process j critical section affect safety program execution involve spurious token generated presence failstops safe predicate hold actions execute would certify token spurious towards detection safe predicate exploit fact failstops detectable faults hence let failstop process force neighboring processes participate diffusing computation recalling new token safely generated diffusing computation completes define safe predicate nm2 k participating diffusing computation action nm3 j participating diffusing computation observe safe predicate detection performed first set actions nm5nm7 nm8 global involves state processes whereas safe predicate detection performed second set actions nm2 nm3 local design separate detector set actions superposition detectors nm yields masking faulttolerant program 531 designing global detector gd discussed global detector gd uses diffusing computation check process token root process initiate diffusing computation upon initiation root propagates diffusing computation children child likewise propagates computation children convenient think propagations propagation wave leaf process receives propagation wave completes responds parent upon receiving responses children parent leaf likewise completes responds parent convenient think completions completion wave completion wave process responds parent result denoting whether subtree rooted process token thus root receives completion wave decide whether process token inspecting result diffusing computation complicated following situations multiple root processes may initiate diffusing computation concurrently processes may failstop diffusing computation progress process may receive token responding parent diffusing computation token deal concurrent initiators let diffusing computation highest id process complete successfully others aborted forcing complete result false specifically process propagating diffusing computation observes another diffusing computation initiated higher id process starts propagating latter aborts former diffusing computation setting result former parent process received former diffusing computation false ensures former parent completes diffusing computation lower id process result false deal failstop process abort diffusing diffusing computations neighboring processes may propagating specifically j waiting reply k complete diffusing computation k failstops j cannot decide descendent k token hence upon detecting failstop k j aborts diffusing computation setting result false finally deal potential race condition diffusing computation misses token token sent process already completed diffusing computation result true ensure even occurs diffusing computation completes initiator result false towards end modify global detector follows process completes diffusing computation result true neighbors propagated diffusing computation variable result maintained false process ever token since last diffusing computation propagated see modification works consider first process say j receives token completed diffusing computation result true let l denote process sent token j follows l least propagated diffusing computation result false moreover since j first process receive token completing diffusing computation result true l complete diffusing computation result false since result l propagated towards initiator diffusing computation completion wave initiator guaranteed complete diffusing computation result false sum diffusing computation deals complications via abort mechanism setting result appropriate processes false fails appropriate diffusing computations initiator diffusing computation completes result false starts yet another diffusing computation towards end diffusing computation provides initiation mechanism lets root process initiate new diffusing computation distinguish different computations initiated process let process maintain sequence number incremented every diffusing computation furthermore process propagates new diffusing computation resets result true provided token discussion process j needs maintain phase phasej sequence number snj result resj phase j either prop comp denotes whether j propagating diffusing computation completed diffusing computation sequence number distinguishes successive diffusing computations initiated root process finally result j denotes whether j completed diffusing computation correctly aborted diffusing computation actions global detector global detector consists four actions viz init prop comp abort init lets process j initiate diffusing computation incrementing sequence number specify statement init conditions j executes init specified later propagate diffusing computation j pj tree snj different snpj holder relation j aligned along parent relation pj propagate phase j propagates diffusing computation sets result true otherwise completes diffusing computation result false comp lets j complete diffusing computation children completed diffusing computation neighbors propagated completed diffusing computation result computed j set true iff result returned children true neighbors j propagated diffusing computation result j true root completes diffusing computation result true safe predicate detected root process proceed safely generate new token consequently change result false abort lets j complete diffusing computation prematurely result false j aborts diffusing computation j also sets result parent false ensure parent j completes diffusing computation result false specify statement conditions j executes abort specified later formally actions detector gd process j follows init j pj j phasej snj prop newseq resj true gamma snj snpj phasej resj prop true else resj false comp j phasej prop gamma resj pj else pj j resj resj false pj 2adjj respj false remark abort action j synchronously updates state parent addition action refined since parent j completes diffusing computation j completes diffusing computation j updates state pj reads state j later fault actions process failstops neighbors abort diffusing computation propagating moreover initiator aborts diffusing computation initiates new one hence fault action denotes statement xl executed processes satisfy rl gamma upj false invariant relegate invariant sgd global detector appendix a1 532 designing local detector ld safe predicate action nm2 k participating diffusing computation comp safe predicate action nm3 j participating diffusing computation phasej comp therefore actions modified follows gamma hk hj j j requestk gamma access critical section 533 adding detectors verifying interference freedom actions nm5nm7 nm8 restricted execute init initiate diffusing computation whose successful completion ie execution comp result true generate new token described actions nm2 nm3 restricted local detectors obtain ld1 ld2 respectively still need verify composition free interference note global detector gd superposition nm hence gd interfere nm ensure nm interfere gd restrict actions nm nm5nm7 nm8 execute abort alert reader note last restriction overkill actions nm need thus restricted leave optimization exercise reader long correctors nm executing gd safely aborted correctors nm terminate gd makes progress hence nm interfere gd also execution gd eventually reaches state phase processes comp thus ld interfere nm since ld detects safe predicate atomically interfered nm gd formally actions resulting masking tolerant program mm follows fault actions fault action identical fault action described section 531 invariant invariant program mm conjunction tnm sgd thus invariant mm theorem 63 mutual exclusion program mm masking tolerant smm remark leader election program easily extracted mutual exclusion case study end drop variables h request program mm thus resulting program consists corrector nt actions mm4gamma6 detector gd actions mm9 mm10 program process leader iff root phase comp program derived adding detector gd nonmasking tolerant program nt detailed design leader election program presented 20 6 discussion concluding remarks paper presented compositional method designing masking faulttolerant programs first corrector composition nonmasking faulttolerant program designed ensure faults stopped occurring program eventually reached state problem specification satisfied detector composition program augmented ensure even presence faults program always satisfied safety specification demonstrated method designing classical examples masking faulttolerant programs notably examples covered variety faultclasses including byzantine faults message faults input faults processor failstops repairs also illustrated generality method terms ability provide alternative designs programs usually associated wellknown design methods masking faulttolerance specifically tmr byzantine examples usually associated method replication generally statemachineapproach designing clientserver programs 21 alternatingbit protocol example usually associated method exception handling rollbackrecovery timeout action md5 exceptionhandler recoveryprocedure found judicious use method offers potential design improved masking tolerant solutions measured terms scope faultclasses masked andor performance resulting programs contrast wellknown design methods method committed overhead replication instead encourages design minimal components achieving required tolerance contrast sometimes ad hoc treatment exceptionhandling recovery procedures focuses attention systematic resolution interference underlying program added tolerance components one example improved masking tolerant solution designed using method tokenbased mutual exclusion program terms performance absence faults program performs exactly faultintolerant version due raymond 17 snepscheut 18 thus incurs extra overhead case way contrast acyclicgraphbased programs dhamdhere kulkarni 22 chang singhal liu 23 incur time overhead providing faulttolerance even absence faults also tree based program agrawal abbadi 24 amount work performed critical section may increase processes fail especially failed processes close tree root program failure process causes overhead convergence phase program converges moreover terms tolerance program tolerant 24 worst case intolerant log n process failstops note passing mutual exclusion program systematically extended tolerate process repairs well channel failures repairs also systematically transformed processes cannot access state neighbors atomically via asynchronous message passing examples improved solutions designed using method interested reader referred designs leader election 20 termination detection 20 distributed reset 25 also note although superposition used detector composition example designs superposition one possible strategies detector composition advantage superposing detectors underlying nonmasking tolerant program immediate guarantee detectors interfere closure convergence properties underlying program one useful extension method would design programs nonmasking tolerant one faultclass masking tolerant another generally possess multiple tolerance properties see 12 25 26 design multitolerant programs motivated insight faultspan program need unique 5 hence multiple faultspans may associated program instance program subject multiple faultclasses follows program nonmasking tolerant one faultclasses masking tolerant another generally find multitolerance several practical applications 12 another useful extension would augment method allow tolerance refinement ie allow refinement tolerant program abstract level concrete level preserving tolerance property tolerance refinement orthogonal tolerance addition considered paper adds desired masking tolerance directly desired fixed level implementation extension could instance refine mutual exclusion program neighboring processes communicate via asynchronous message passing within scope method finally alternative design methods based detector corrector compositions would worth studying alternative stepwise method would first perform detector composition perform corrector composition view designing masking tolerance via failsafe tolerance 12 another alternative stepwise method would compose detectors correctors simultaneously would especially interesting compare methods respect designcomplexity versus performancecomplexity tradeoffs acknowledgments grateful ted herman helpful comments preliminary version paper thank anonymous referees detailed constructive suggestions r compositional framework fault tolerance specification transformation system structure software fault tolerance dependable computing fault tolerance concepts terminology closure convergence foundation faulttolerant comput ing parallel program design foundation defining liveness discipline programming science programming proving boolean combinations deterministic properties constraint satisfaction basis designing nonmasking faulttolerance component based design multitolerance structure distributed algorithms byzantine generals problem compositional design multitolerant repetitive byzantine agree ment predicate calculus program semantics tree based algorithm mutual exclusion fair mutual exclusion graph processes efficient reconfiguration trees case study methodical design nonmask ing faulttolerance designing masking faulttolerance via nonmasking faulttolerance implementing faulttolerant services using state machine approach tutorial token based k resilient mutual exclusion algorithm distributed systems fault tolerant algorithm distributed mutual exclusion efficient faulttolerant solution distributed mutual exclusion multitolerance distributed reset multitolerant barrier synchronization tr ctr anil hanumantharaya purnendu sinha anjali agarwal componentbased design compositional verification faulttolerant multimedia communication protocol realtime imaging v9 n6 p401422 december ted herman superstabilizing mutual exclusion distributed computing v13 n1 p117 january 2000 iling yen farokh b bastani david j taylor design multiinvariant data structures robust shared accesses multiprocessor systems ieee transactions software engineering v27 n3 p193207 march 2001 meng yu peng liu wanyu zang specifying using intrusion masking models process distributed operations journal computer security v13 n4 p623658 july 2005 sushil jajodia paul ammann catherine mccollum surviving information warfare attacks computer v32 n4 p5763 april 1999 felix c grtner fundamentals faulttolerant distributed computing asynchronous environments acm computing surveys csur v31 n1 p126 march 1999
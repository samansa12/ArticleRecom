automated techniques provably safe mobile code present general framework provably safe mobile code relies formal definition safety policy explicit evidence compliance policy attached binary concrete realizations framework proofcarrying code evidence safety formal proof generated certifying compiler typed assembly language evidence safety given via type annotations propagated throughout compilation process typed intermediate languages validity evidence established via small trusted type checker either directly binary indirectly proof representations logical framework b introduction integrating software components form reliable system longstanding fundamental problem computer science problem manifests numerous guises 1 dynamically add services operating system without compromising integrity 2 exploit existing software components building new application 3 support safe exchange programs untrusted environment 4 replace components running system without disrupting operation questions modularity wish treat software components black boxes safely integrated larger system without fear use compromise maliciously otherwise integrity composite system put terms wish ensure behavior system remains predictable even addition new components three main techniques proposed solve problem safe component 1 runtime checking untrusted components monitored execution time ensure interactions components strictly limited typical techniques include isolation separate hardware address spaces software fault isolation 1 methods impose serious performance penalties interest safety moreover often large semantic gap lowlevel properties guaranteed checking eg address space isolation highlevel properties required eg black box abstraction 2 sourcelanguage enforcement components required written designated language known assumed ensure black box abstraction techniques suffer requirement components written designated safe language restriction onerous lack widelyused safe languages one must assume language properly defined also implementation correct practice never case 3 personal authority attempt made enforce safety rather component underwritten person company willing underwrite safety digital signature schemes may used authenticate underwritten code practice entities willing make assurances correctness code missing careful analysis meant safe code exchange rather yet another proposal one might achieve vaguelydefined notion safe integration contention safe component integration fundamentally matter proof integrate component larger system code recipient wishes know component suitably wellbehaved compliant specified safety policy words must apparent component satisfies safety specification governs runtime behavior checking compliance safety specification form program verification seek prove program complies given safety policy viewed matter verification question arises code producer code recipient responsible checking compliance safety policy problem familiar methods impose burden recipient code producer insists recipient employ runtime checks comply producers linguistic restrictions simply trust producer right thing argue exactly wrong way around maximize flexibility wish exploit components many different sources unreasonable expect code recipient willing comply strictures many disparate methods rather argue responsibility code producer demonstrate safety presumably producers interest recipient use code moreover producers responsibility current practices notwith standing underwrite safety product framework shift burden proof recipient producer imposed burden proof producer consumer know required obligations fulfilled one method rely trust producer signs binary affirming safety component suffers obvious weakness recipient must trust producers integrity also must trust tools producer used verify safety component even best intentions unlikely methods foolproof consequently producers likely make warrant consumers likely rely code receive much better method one propose require producer provide formal representation proof code compliant safety policy producer carry proof easily supply proof consumer moreover recipient use tools check validity proof ensure really genuine proof given code complies safety specification importantly much easier check proof find proof therefore code recipient need trust proof checker method effective much simpler tools required find proof first place message paper approach fact made work practice exploring two related techniques implementing approach safe component exchange proofcarrying code typed object code cases mobile code annotated formal warrant safety easily checked code recipient produce warrant exploring construction certifying compilers produce suitablyannotated object code compiler could used code producer generate certified object code two points kept mind reading paper 1 tools techniques logic type theory semantics indispensable 2 methods implemented available today first component system safe mobile code safety infrastruc ture safety infrastructure piece system actually ensures safety mobile code execution forms trusted computing base system meaning consumers mobile code install depend therefore must work properly defect trusted computing base opens possible security hole system fundamental concern design trusted computing base small simple large andor complicated code bases likely contain bugs bugs likely result exploitable security holes us confidence safety infrastructure trusted components must small simple enough likely correct design safety infrastructure consists three parts first one must define safety policy second one specifies acceptable evidence compliance safety policy suppliers mobile code required also supply evidence compliance acceptable form third one must build software capable automatically checking whether purported evidence safety actually valid 21 safety policies first task design safety infrastructure decide properties mobile code must satisfy considered safe paper consider relatively simple safety policy consisting memory safety controlflow safety type safety 1 memory safety property program never dereferences invalid pointer never performs unaligned memory access never reads writes memory locations granted access property ensures integrity data available program also ensures program crash due memory accesses 2 controlflow safety property program never jumps address containing valid code never jumps code granted access property ensures program jump code allowed eg lowlevel system calls also ensures program crash due jumps 3 type safety property every operation program performs performed values appropriate type strictly speaking property subsumes memory controlflow safety since memory accesses jumps program operations also makes additional guarantees example ensures allowable system calls made using appropriate values thereby ruling attacks buffer overruns code system additional guarantees provided type safety often expensive obtain using dynamic means static means discuss paper provide additional cost stronger safety policies also possible including guarantees integrity data stored stack 2 limits resource consumption 34 policies specified allowable traces program operations 5 however policies evidence compliance discuss next section complicated thereby requiring greater expense produce verify evidence possibly reducing confidence systems correctness thus choice safety policy practical system involves important tradeoffs also worth observing stronger policies always better rule many programs example policy rejects programs provides great safety cheap implement entirely useless safety infrastructure therefore important design safety policies allow many programs possible still providing sufficient safety 22 evidence compliance safety policy establishes properties mobile programs must satisfy order permitted execute host however impossible general code consumer determine whether arbitrary program complies policy therefore require suppliers mobile code assist consumer providing evidence code complies safety policy evidence may think certificate safety packaged together mobile program two together referred certified code upon obtaining certified code code consumer automatically verifies validity evidence executing program code second task design safety infrastructure decide form evidence compliance must take decision made light several considerations 1 since evidence safety must transferred network along program code certify wish evidence small possible order minimize communication overhead evidence must checked running program code desire verification evidence fast possible clearly smaller evidence lead faster checking also speed evidence verification careful design form evidence 3 discussed evidence verifier essential part trusted computing base must work properly potential security hole system us confidence verifier works properly must simple means structure evidence checks must also simple thus simplicity desirable aesthetic point view also essential system work 4 finally complete confidence system provides desired safety must prove mathematical rigor programs carrying acceptable evidence safety really comply safety policy proof heart safety guarantees system provides proofs feasible structure evidence must built mathematical foundations light considerations discuss two different forms evidence compliance may take explicit proofs employed proofcarrying code infrastructure 6 type annotations employed typed assembly language infrastructure 72 explicit proofs direct way provide evidence safety provide explicit formal proof program question complies safety policy strategy employed proofcarrying code pcc requires formal language safety proofs expressed language designed according following criteria effective decidability efficiently decidable given object represents valid safety proof compactness proofs small encodings generality representation language permit proofs different safety properties ideally openended new safety policies developed without change trusted computing base simplicity proof representation language simple possi ble since must trust mathematical properties implementation proof checker approach use lf logical framework 8 satisfy requirements logical framework general metalanguage representation logical inferences rules deductions various logics theories specified lf high level abstraction simply stating valid axioms rules inference provides generality since separate theories required reasoning safety properties arithmetic memory update access underlying mechanism checking proofs also simple since based pure dependently typed calculus whose properties deeply investigated 910 proofs logic designed reasoning safety properties represented terms lf checking proof valid reduced checking representation logical framework welltyped carried effectively even large proof objects experiments certifying compilation 11 decision procedures 12 yield proofs whose representation 1 mb yet still checked hand proofs lf compact without additional techniques redundancy elimination following general techniques 13 necula 14 developed optimized representations fragment lf called sufficient use pcc applications experimental results obtained far validated practicality proof compression technique 11 safety policies discussed current research 15 aimed extending improving methods obtain compression without compromising simplicity trusted computing base type annotations second way provide evidence safety using type annotations approach typing discipline imposed mobile programs architects system prove theorem stating program satisfying type discipline necessarily satisfy safety policy well 7 however determining whether program satisfies type discipline involves finding consistent type scheme values program type scheme cannot inferred general therefore approach programs required include enough type annotations type checker reconstruct consistent type scheme type annotations constitute evidence safety provided taken conjunction theorem stating welltyped programs comply safety policy principal advantage type annotation approach explicit proof approach soundness type system established contrast validity explicit proofs establish soundness system proof rules practice proof rules freely customized account safety requirements application main drawback type annotations program violates type sys tems invariants typeable type system therefore cannot accepted safety infrastructure even actually safe explicit proofs invariants built possible work around cases hold idea using types guarantee safety means new many modern highlevel languages eg ml modula3 java rely type system ensure legal programs safe languages even used safety infrastructures example spin operating system 16 required operating system extensions written modula3 thereby ensuring safety drawback using highlevel language ensure safety programs checked safety compilation rather thereby requiring entire compiler included trusted computing base discussed confidence one safety architecture inversely related size trusted computing base typed assembly language tal infrastructure resolves problem employing type safe lowlevel language tal type discipline imposed executable code therefore program code checked safety exact code executed need trust compiler compiler faulty generates unsafe executables executables rejected type checker principal exercise developing type system executable code isolate lowlevel abstractions satisfying two conditions ffl abstractions independently type checkable whatever extent type checking abstractions depends surrounding code data depend types code data additional information reflected types ffl atomic operations abstractions single machine instructions example consider function calls highlevel languages usually provide builtin notion functions functions certainly type checked indepen dently dealt single machine instruction rather function calls processed using separate call return instructions intervening code means atomic return address stored accessible storage modified even disregarded satisfy second condition tals corresponding abstraction code block code blocks invoked using simple jump instruction functions composed code blocks writing code blocks explicit extra input containing return address decomposition corresponds wellknown practice highlevel language programming continuationpassing style 17 first condition satisfied requiring code blocks specify types inputs functions highlevel languages specify types arguments results without specifications would impossible check safety jump without inspecting body jumps target example consider tal code computing factorial code exhibit many complexities tal type system serves give flavor tal programs exhaustive examples appear morrisett et al 72 codefr1intr2fr1intgg mov r31 set accumulator loop jmp loop loop codefr1intr2fr1intgr3intg bz r1done check done branch zero mul r3r3r1 sub r1r11 jmp loop done codefr1intr2fr1intgr3intg mov r1r3 move accumulator result register jmp r2 return caller code type code block written fr1 1 indicating code may called registers fact code block given type fr1int r2fr1intgg indicating fact called must given r1 integer argument r2 code block return address called must given integer return value r1 called fact sets accumulator register type int r3 jumps loop loop computes factorial finished branches done moves accumulator return address register r1 returns caller final return caller extra registers r2 r3 forgotten match precondition r2 mentions r1 alternative typed assembly language one also strike compromise high lowlevel languages exploiting typed intermediate languages safety 18 using typed intermediate languages enlarges trusted computing base since part compiler must trusted loosens second condition type systems executable code provides spectrum possible designs closer intermediate language satisfying second condition lesser amount compiler needs trusted moreover discuss section 3 typed intermediate languages valuable automated certification even end result typed executable 23 automated verification since plays central role provably safe mobile code elaborate mechanisms verifying safety certificates explicit proofs discussed proofcarrying code infrastructure employs lf logical framework terminology logical frameworks judgment object knowledge may evident virtue proof typical safety properties require judgments truth proposition predicate logic equality two integers lf judgment object logic represented type logical framework proof term proof p judgment j representation p type j write representation function adequacy theorem representation function guarantees property inverse whenever term type j proof p j directions critical together mean reduce problem checking validity proof p verifying representation p welltyped pcc checking compliance safety policy reduced type checking representation safety proof logical framework technique allow different safety policies since proofs represented terms lf inference rule represented function proofs premises proof conclusion represent complete logical system need introduce one type constant basic judgment one term constant inference rule collection constant declarations called signature 1 particular safety policy consists verification condition generator extracts proof obligation binary signature lf expresses valid proof principles verification condition means different policies expressed different signatures basic engine verifies evidence lf type checker change different policies however trust correctness lf signature representing policy inconsistent signature example would allow arbitrary code pass safety check type checking lf syntaxdirected therefore practice quite efficient 13 especially avoid checking information statically shown redundant 14 currently touchstone compiler pcc discussed section 31 uses small efficient type checker lf terms written c related projects proofcarrying code 1920 certifying decision procedures 12 use twelf implementation 2123 information logical frameworks see 24 type annotations case safety policy expressed form typing rules checking compliance immediately reduces type checking case carefully design language annotations type checking practical generally complicated safety property annotations required safety property fixed tradeoff space time type annotations easier type checking problem one extreme consists type annotations means type checking undecidable extreme full typing derivation represented example logical framework quite similar proof pcc approach safety policies considered far difficult find appropriate compromises extremes compact permit fast type checking 25 worth noting cases explicit proofs type annotations verification method type checking proofcarrying code always confused digital signature used certify authenticity type checking lf logical framework optimizations eliminate redundant work typed assembly language algorithm type checking varies safety property enforced although basic nature syntaxdirected code traversal remains 3 automated certification certificates safety obtained principle may use means disposal without restriction limitation freedom assured checkability safety certificates always possible determine mechanically whether given certificate underwrites safety given program since code recipient always check validity safety certificate need rely means certificate produced two factors determine hard construct safety certificate program 1 strength assurances wish make program stronger assurances harder obtain certificate 2 complexity programming language lowlevel language harder certify safety programs practical matter easier construct safety certificates likely code certification widely used main technique considered building safety certificates build certifying compiler safe highlevel language ml java typesafe language ada modula certifying compiler generates object code comparable often superior quality ordinary compiler certifying compiler goes beyond conventional compilation methods augmenting object code checkable safety certificate warranting compliance object code safety properties source language way able exploit safety properties semantically welldefined highlevel languages without trust compiler ensure integrity code transit producer consumer key building certifying compiler propagate safety invariants source language intermediate stages compilation final object code means compilation phase responsible preservation invariants input output moreover ensure checkability invariants phase must annotate program enough information code recipient reconstruct proof invariants way code recipient check safety code without rely correctness compiler common case compiler contains errors purported safety certificate may may valid recipient detect mistake since compilation phase construed recipient code produced preceding stage compiler check integrity verifying claimed invariants stage proved invaluable aid compiler writer 1118 31 constructing evidence safety explored two main methods propagating safety invariants compilation 1 translation typed intermediate languages 26 safety invariants captured type system intermediate languages compiler type system designed ensure welltyped expressions safe enough type information attached intermediate forms ensure may mechanically check type correctness typed intermediate forms selfcertifying sense attached type information serves checkable certificate safety 2 compilation proofcarrying code 11 safety invariants directly expressed logical assertions execution behavior conventional intermediate code soundness logic ensures assertions correctly express required safety properties code safety object code checked combination verification condition generation automatic theorem proving equipping theorem prover means generate formal representation proof may generate checkable safety certificates object code two methods mutually exclusive currently exploring integration using dependent types allow assertions blended types single typetheoretic formalism technique robust applied highlevel languages 2728 well lowlevel languages 29 thereby providing ideal basis use certifying compilers 32 typed intermediate languages give sense type information might attached intermediate code give example derived representation lists level source language two methods creating lists 1 nil stands empty list 2 consh constructs nonempty list head h tail values assigned types according following rules 2 1 nil type list 2 h type int type list consht type list variety operations manipulating lists including car cdr operations following types 1 l type list carl type int 2 l type list cdrl type list behavior operations governed following transitions operational semantics language 1 carconsht reduces h 2 cdrconsht reduces one task compiler decide representation lists memory generate code car cdr consistently representation typical somewhat simpleminded approach represent list 1 pointer 2 tagged region memory containing 3 pair consisting head tail list tag field distinguishes empty nonempty lists pointer identifies address node heap representation depicted following compound term ptrtagconspairh interesting individual construct expression may thought primitive typed intermediate language specifically 2 simplicity consider lists integers 1 ptrv type list v type nilvoidconsintlist bracketed expression defines tags nil cons type associated data values none case nil pair case cons 2 tagtv type v type particular tagconspairht type nilvoidconsintlist h type int type list 3 l type l r type r particular intlist h type int type list corresponding representation may generate code say carl behaves follows 1 dereference pointer l value l must pointer type list 2 check tag object heap ensure cons must either cons nil type dereferenced pointer nilvoidconsintlist 3 extract underlying pair project first component must two components type tagged value intlist expressed formally typed intermediate language generated code car operation defined terms primitive operations performing three steps safety code ensured typing rules associated operations type correct program cannot misinterpret data example treating head list floating point number fact integer typedirected compiler 26 one performs transformations typed intermediate languages making use type information guide trans lation ensuring typing preserved transformation stage typedirected compiler compilation phase translates program code also type way translated program translated type far pushed subject ongoing research tilt compiler able propagate type information rtl register transfer language level point type propagation abandoned recent development typed assembly language tal 72 demonstrates feasibility propagating type information x86like assembly code integration tilt tal subject ongoing research propagation type information safety wellbehaved type system one prove soundness theorem relating execution behavior program type one consequence soundness theorem type system impossible welltyped programs incur type errors memory errors control errors welltyped programs safe course every safe program welltyped typing sufficient condition safety necessary one however may readily check type correctness program using lightweight wellunderstood methods technique typedirected compilation demonstrates rich variety programs certified using typed intermediate languages whether demands cannot met using method remains seen 33 logical assertions explicit proofs another approach code certification exploring 3011 use combination logical assertions explicit proofs certifying compiler touchstone works augmenting intermediate code logical assertions tracking types ranges values checking validity assertions twostep process 1 verification condition generation vcgen program symbolically evaluated propagate implications logical assertions instructions program results set logical implications must hold program considered properly annotated 2 theorem proving implications generated vcgen verified using combination automatic theorem proving techniques including constraint satisfaction procedures simplex proof search techniques firstorder logic form trusted computing base must include vcgen procedure theorem provers used check verification conditions addition specification safety policy describes conditions safe execution well pre postconditions procedures supplied host operating system required certified code reduce size trusted computing base may regard combination vcgen theorem proving kind postprocessing phase validity annotated program checked formal representation proof validity verification conditions attached code achieved using certifying theorem provers 1112 seek prove theorems also provide explicit representation proof whenever one found proofs obtained much simpler check find indeed proof checker need integrated trusted computing base theorem provers need trusted protected tampering gain understanding involved consider array subscript operation safe language given array length n integer operation subai checks whether 0 retrieves ith element high level atomic operation compiled intermediate code defined terms primitive operations along following lines 0 return ai1 unsafe access else f signal error note refers length array assume integer array represented pointer sequence words first contains arrays length rest contents annotating code logical assertions obtain following int array 0 return ai1 else f signal error assertion array corresponds invariants mentioned practice much lowerlevel type system employed 11 simple matter check given assertions correct case observe role conditional test enable theorem prover verify index operation ai1 memorysafe stray beyond bounds array many cases runtime test redundant compiler able prove runtime test must come true therefore eliminated example highlevel code simple loop following expect individual bounds checks elided int i0 ilengtha f sum subai call site sub compiler able prove 0 n length propagating code sub find conditional test eliminated compiler prove test must always true leads following code int i0 ia f sum ai1 given annotation perform verification condition generation theorem proving check required precondition unsafe array subscript operation indeed true ensures program safe execute however rather place additional burden programmer instead attach formal representation proof fact assertions int i0 ia f sum ai1 proof term checkable witness validity given assertions checked code recipient practice witness term lf calculus proof checking simply another form type checking see section 23 4 experimental results mentioned earlier implemented several systems test demonstrate ideas certified code typed intermediate languages certifying com pilers certifying theorem provers results experiments systems confirm several important claims general framework safety certification code presented paper 1 approaches certified code pcc tal allow highly optimized code verified safety means compromises need made high performance safety 2 various approaches certifying compilers explored typed intermediate languages logical assertions scaled x vs gnu gcc gnu gcc o4 233 382 351 297 244 262 550 292 317 dec cc o4 292 368 352 279 244 276 688 1152 392 cert comp 264 389 352 386 193 220 400 916 348 blur sharpen qsort simplex kmp unpack bcopy edge gmean100003000050000time ms proof checking ms 77 235 163 1203 96 925 36 147 proving ms 810 2570 1270 12720 1080 19120 250 1430 vc generation ms 63 209 115 739 84 706 35 97 code generation ms 2710 8180 5600 43400 3480 18850 1360 6970 blur sharpen qsort simplex kmp unpack bcopy edge50001500025000 binary size bytes proof 1372 4532 2748 20308 1874 17260 620 2218 code 320 1248 576 3792 496 2528 128 640 blur sharpen qsort simplex kmp unpack bcopy edge fig 1 comparison generated objectcode performance touch stone gcc dec cc optimizing compilers height bars shows speedup object code relative unoptimized code produced gcc languages realistic scale complexity furthermore provide automatic means obtaining code certified hold standard safety properties type safety memory safety control safety 3 need include annotations andor proofs code undue burden furthermore checking certificates performed quickly reliably order support claims give better feel practical details systems present results experiments 41 touchstone certifying compiler touchstone certifying compiler imperative programming language clike syntax although source programs look much like c programs language compiled touchstone made safe strong static type system eliminating pointer arithmetic ensuring variables initialized although language makes restrictions c still rich powerful language sense allowing recursive pro cedures aliased variables switch statements dynamically allocated data structures indeed straightforward translate many practical c source programs language compiled touchstone 31 given source program touchstone generates highly optimized native code target program dec alpha architecture attached proof type memory control safety figure 1 shows results collection benchmark programs compiled touchstone gnu gcc c compiler dec cc c compiler benchmark programs obtained standard unix utility applica xspeedup vs gnu gcc gnu gcc o4 233 382 351 297 244 262 550 292 317 dec cc o4 292 368 352 279 244 276 688 1152 392 cert comp 264 389 352 386 193 220 400 916 348 blur sharpen qsort simplex kmp unpack bcopy edge gmean100003000050000time ms proof checking ms 77 235 163 1203 96 925 36 147 proving ms 810 2570 1270 12720 1080 19120 250 1430 vc generation ms 63 209 115 739 84 706 35 97 code generation ms 2710 8180 5600 43400 3480 18850 1360 6970 blur sharpen qsort simplex kmp unpack bcopy edge50001500025000 binary size bytes proof 1372 4532 2748 20308 1874 17260 620 2218 code 320 1248 576 3792 496 2528 128 640 blur sharpen qsort simplex kmp unpack bcopy edge fig 2 breakdown time required generated proofcarrying code binaries tions xv gzip programs edited completely straightforward way replace uses pointer arithmetic arrayindexing syntax recall clike language compiled touchstone support pointer arithmetic bars figure generated first compiling program gnu gcc compiler optimizations turned touchstone gnu gcc dec cc used compile programs optimizations turned bars figure show relative speed improvements produced optimizing compiler relative unoptimized code figure shows touchstone compiler generates object code comparable speed produced gcc cc compilers fact superior gcc overall result particularly surprising one considers touchstone obligated guarantee array accesses pointer dereferences safe touchstone must sometimes perform arraybounds nullpointer checks whereas gcc cc compilers fact touchstone able optimize away almost arraybounds nullpointer checks generates proofs convince code recipient array pointer accesses still safe figure 2 provide breakdown time required compile benchmark program pcc binary bar figure divided four parts bottommost part shows conventional compile time time required generate dec alpha assembly code plus invariant annotations required underlying pcc system touchstone highly aggressive optimizing compiler bit slower typical compilers however average comparable compiling times dec cc compiler optimizations enabled second part shows time required generate verification conditions finally third fourth parts show times required proof generation proof checking respectively one see little time required verificationcondition generation proof checking important two steps must also performed recipient generated code fact two parts small indication code recipient fact little work early measurements touchstone compiler showed proofs 2 4 times larger code size 31 since time experimental results obtained made considerable progress reducing size proofs without increasing time effort required check reductions lead proof sizes order 10 40 size code addition experimenting new representation refer oracle string representation types programs described reduces proof sizes consistently less 5 code size cost making proof checking 50 slower hope able describe techniques show effects future report 42 cedilla systems special j compiler experimental results shown admittedly less convincing due relatively small size test programs recently however spun commercial enterprise build industrialstrength implementation proofcarrying code system enterprise called cedilla systems incorporated essentially experiment technology transfer sense attempting take ideas results directly laboratory commercial practice cedilla systems shown ideas presented paper scaled fullscale languages shown clearly optimizing nativecode compiler full java programming language called special j 32 successfully compiles 300 realworld java applications including rather large ones suns staroffice application suite hotjava web browser operation special j similar touchstone special j produces optimized target code annotated invariants make possible construct proof safety verificationcondition generator used extract verification condition certifying theorem prover generates proof attached target code see simple example process consider following java program public class bcopy1 f public static void bcopyint src f int int source program compiled special j target program intel x86 architecture shown figure 3 included target program numerous data structures support javas object model runtime system core output however native code bcopy method shown code largely conventional except insertion several invariants marked special ann macro annotations hints compiler help automatic proof generator job generate code constrain object code way however serve important engineering purpose describe ann locals annotation simply says compiled method uses three locals case register allocator need spill space stack locals two formal parameters return address hint useful proving memory safety prover could principle analyze code reverseengineer information much easier compiler communicate already knows since one engineering goals simplify much possible size trusted computing base better compiler generate information leaving checking problem pcc infrastructure ann unreachable annotations come fact safety policy specifies array accesses must always bounds null pointers must never dereferenced java failures result runtime exceptions ann locals bcopy 6arrays6bcopy1aiai globl bcopy 6arrays6bcopy1aiai bcopy 6arrays6bcopy1aiai cmpl 0 4esp srcnull je l6 movl 4esp ebx movl 4ebx ecx testl ecx ecx l0 jg l22 ret l22 xorl edx edx initialize cmpl 0 8esp dstnull je l6 movl 8esp eax movl 4eax esi dstlength l7 ann invann dom loop csubneq eax csubb edx ecx rm mem lf cmpl esi edx idstlength movl 8ebx edx 4 edi srci movl edi 8eax edx incl edx cmpl ecx edx il jl l7 ret ann invann dom loop lf true lf ret l13 call jv throwbadarrayindex ann unreachable nop call jv thrownullpointer ann unreachable nop fig 3 special j output code safety policy example requires proof exceptions never thrown therefore compiler points places must never reached execution proof generator need reverseengineer sourcecode array accesses pointer dereferences ended binary first ann inv annotation far interesting annota tions note special j compiler optimized tight loop ffl required null checks hoisted note null check dst cannot hoisted loop entry loop may never entered hoisted first iteration ffl bounds check src hoisted note hoisting bounds check dst would exotic optimization case dst long enough loop must copy far throw exception proof generator must still prove memory safety must prove inside loop nullpointer dereferences outofbounds memory accesses essentially proof generator needs go reasoning compiler went hoisted checks outside loop therefore help proof generator compiler outputs relevant loop invariants discovered performing codehoisting optimizations case discovered ffl src register ebx null csubneq ebx 0 ffl dst register eax null csubneq eax 0 csub prefix denotes result pentium comparison things loop invariant specify ffl registers modified loop rb ffl memory safety loop invariant rm mem pseudoregister rm denotes computers memory rm mem means unsafe operations performed memory target code generated special j cedilla systems proof generator reads outputs proof code satisfies safety policy first step generate logical predicate called verification condition simply vc whose logical validity implies safety code important vc used producer recipient code recipient guarantee right safety proof provided opposed proof unrelated irrelevant property explained earlier proofs verification conditions expressed language called logical framework lf space prevents us including entire vc bcopy example however following excerpt illustrates main points note x0 dst parameter x1 src parameter x2 pseudoregister representing current state heap x3 variable csubb x3 sel4 x2 add x1 4 csubneq x0 csubneq x1 csubb x3 sel4 x2 add x0 4 saferd4 add x1 add imul x3 safewr4 add x0 add imul x3 add x1 add imul x3 csublt add x3 1 sel4 x2 add x1 4 csubneq x1 csubneq x0 csubb add x3 1 sel4 x2 add x1 4 excerpt vc says given loopinvariant assumptions ffl csubb x3 sel4 x2 add x1 4 ie srci bounds ie dst nonnull ie src nonnull given bounds check emitted dst well additional assumptions outside loop shown snippet proofs required establish safety read src array write dst array furthermore given additional loopentry condition proofs required reestablish loop invariants x0 corresponds eax dst source x1 ebx src source x2 rm memory pseudoregister x3 edx source note srclength sel4 x2 add x1 4 length stored byteoffset 4 array object safety policy hence vc specifies enforces requirements datastructure layout proof generator reads vc outputs proof tiny excerpt proof shown ass10 pf csubb x3 sel4 x2 add x1 4 ass12 pf csubneq x1 0 ass13 pf csubb x3 add x0 4 andi szint below1 ass10 proofs shown concrete syntax lf developed elf system 2221 small snippet proof one see assumptions marked ass identifiers labeled used body proof logical inference rules impi case stands implicationintroduction rule specified declaratively lf language included pcc system part definition safety policy finally binary encoding proof made attached target code proof included data segment standard binary coff format case proof takes 71 total object file note currently use unoptimized binary encoding proof proof tokens 16 bits long huffman encoding produces average token size 35 bits huffmanencoded binary expected 22 size nonhuffmanencoded binary case would make size proof approximately 45 bytes less 2 object file huffman encoding would indeed effective means reducing size proofs found representations oracle strings even better job without incurring cost decompression case current example oracle string representation proof requires less 6 bytes hope report detail representation future report 5 conclusion future work presented general framework safety certification code relies formal definition safety policy explicit evidence compliance attached mobile code evidence may take form formal safety proofs proofcarrying code type annotations typed assembly language cases one establish mathematical rigor certified code tamperproof executed safely without additional runtime checks operating system protection boundaries experience approaches shown overhead acceptable practice time validate certificate space represent using advanced techniques logical frameworks type theory also sketched certificates obtained automatically use certifying compilers theorem provers approach typed intermediate languages propagates safety properties guaranteed highlevel source language throughout compilation process lowlevel code safety remains verifiable layer typechecking certifying compiler touchstone uses logical assertions throughout compilation similar manner except validity logical assertions must assured theorem proving practical class safety policies considered since compiler provide information necessary guarantee proof always found finally certifying theorem prover need part trusted computing base since produces explicit proof terms checked independently implementation logical framework key technology underlying approaches safety type theory used modern programming language design implementation idea type systems guarantee program safety modularity highlevel languages old one see main contribution demonstrating practical working systems touchstone tilt compiler twelf logical framework techniques type theory equally applied intermediate lowlevel languages machine code order support provably safe mobile code certificates generated automatically r efficient softwarebased fault isolation acm symposium principles programming languages type system expressive security policies safe kernel extensions without runtime checking system f typed assembly language framework defining logics equivalence canonical forms lf type theory generating proofs decision procedure empirical study runtime behavior higherorder logic programs efficient representation validation logical proofs algorithms equality unification presence notational definitions definitional interpreters higherorder programming languages semantic model types machine instructions proofcarrying code system description twelf metalogical framework deductive systems elf metalanguage deductive systems logic programming lf logical framework realistic typed assembly language til typedirected optimizing compiler ml eliminating array bound checking dependent types dependent types practical programming dependently typed assembly language design implementation certifying compiler certifying compiler java tr logic programming lf logical framework framework defining logics efficient softwarebased fault isolation extensibility safety performance spin operating system safe kernel extensions without runtime checking proofcarrying code system f typed assembly language eliminating array bound checking dependent types design implementation certifying compiler dependent types practical programming proofcarrying authentication resource bound certification semantic model types machine instructions proofcarrying code type system expressive security policies certifying compiler java algorithms equality unification presence notational definitions stackbased typed assembly language elf system description logical frameworks efficient representation validation proofs definitional interpreters higherorder programming languages dependently typed assembly language compiling proofs higherorder rewriting dependent types lambda calculus ctr andr pang stewart sean seefried manuel chakravarty plugging haskell proceedings 2004 acm sigplan workshop haskell september 2222 2004 snowbird utah usa mike jochen anteneh addis anteneh lori l pollock lisa marvel enabling control adaptive program transformation dynamically evolving mobile software validation acm sigsoft software engineering notes v30 n4 july 2005
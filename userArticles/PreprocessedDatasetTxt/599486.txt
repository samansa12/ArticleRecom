efficient partial order reduction algorithm alternative proviso implementation paper presents partial order reduction algorithm called twophase generates significantly reduced state space large class practical protocols alternative algorithms class reduced statespace generated twophase preserves ctlastx assertions twophase achieves reduction following alternative implementation proviso step particular twophase avoids instack check tools use order realize proviso step paper demonstrate instack check inefficient practice demonstrate much simpler alternative method realizing proviso twophase easily combined onthefly modelchecking algorithm reduce memory requirements simple powerful selective caching scheme also easily added twophasea version twophase using onthefly modelchecking selective caching implemented modelchecker called pv protocol verifier routine use large problems pv accepts proper subset promela never automaton expressing ltlx assertion verified pv helped us complete full statespace search several orders magnitude faster alternative tools available class dozens real protocols pv helped us detect bugs real distributed shared memory cache coherency protocols missed incomplete search using alternate tools b introduction increasing scale software hardware systems corresponding increase number complexity concurrent protocols involved design formal verification concurrent protocols important practical need automatic verification finite state systems based explicit state enumeration methods ces86 z supported part graduate fellowship university utah present address hewlettpackard cupertino systems lab cupertino ca 95014 ratancuphpcom x supported part darpa contract dabt6396c0094 utah verifier nsf grant ccr9800928 c 2000 kluwer academic publishers printed netherlands hol91 dil96 hp96 hol97 shown considerable promise realworld protocol verification problems used success many industrial designs hol97 dpn93 using explicit state enumeration tools protocol modeled set concurrent processes communicating via shared variables andor communication channels hp96 dil96 tool generates state graph represented protocol checks desired temporal properties graph common problem approach state graphs practical protocols quite large size graph often increases exponentially size protocol commonly referred state explosion interleaving model execution used tools one major causes state explosion shown simple example figure 1 figure 1a shows system two processes p1 p2 figure 1b shows state space example property consideration involve least one variables x one two shaded states need generated thus saving one state straightforward extension example n processes would reveal interleaving model execution would generate states partial order reductions attempt bring reductions exploiting fact realistic protocols many transitions commute hence sufficient explore transitions one order preserve truth value temporal property consideration essence every state partial order reduction algorithm selects subset transitions explore whereas normal graph traversal depth first search dfs algorithm would explore transitions partial order reduction algorithms play important role mitigating state explosion often reducing computational memory cost exponential simple system000000000000000000111111111111111111000000000000000000111111111111111111 x0 b state graph figure 1 simple system state graph 2000revtex 21072000 1637 p factor paper presents new partial order reduction algorithm called twophase practical cases outperforms existing implementations partial order reductions algorithm implemented tool called pv protocol verifier finds routine application research partial order reduction algorithm presented pel96a hp94 implemented explicit state enumeration model checker spin 1 hp96 hol97 implicit state exploration tools vis cospan abhq97 klm algorithm presented god95 implemented popackage tool general partial order reduction algorithms must avoid called ignoring problem problem infinitely postponing action resulting incorrect reductionusing measure progress partial order reduction algorithms generally solve problem using provisos whose need first recognized valmari val92 traditional way implementing provisos made clear momentarily ensure subset transitions selected state generate state stack maintained dfs algorithm subset transitions satisfying check cannot found state transitions executed dfs algorithm popackage algorithm also algorithm presented hgp92 requires least one selected transitions generate state stack whereas spin algorithm requires stronger condition selected transition generates state stack stronger proviso hereafter abbreviated proviso sufficient preserve stutter whereas weaker proviso preserves stutter free safety properties hgp92 hp94 pel93 pel96a context verifying reactive systems directory based coherence protocols serverclient protocols observed commonly adopted method implementing provisonamely explicit instack check next statescauses existing partial order reduction algorithms ineffective ng96 example invalidate distributed shared memory protocol described later spin aborts search running memory generating 270000 states limited 64mb memory usage ultimately finishing 961089 states allowed memory popackage also aborts search generating similar number states invalidate many opportunities partial order reductions references spin paper refer versions existed public domain end 1995 first time twophase implemented within pv mid1998 experiments comparing pv spin finished reduce complexity hence protocols complexity ought easy onthefly explicit enumeration tools handle intuition confirmed fact twophase partial order reduction use instack check finishes comfortably protocol within 64m main memory generating 27600 states fact shown section 7 nontrivial examples implementation twophase model checker called pv ng98b outperforms instack checking based algorithms alternate implementation provisos term proviso used refer condition a5 val96 page 222 2 roughly speaking states every action enabled state reduced state space present stubborn set state 0 reduced statespace reachable twophase algorithm implements proviso condition a5 follows encounters new state x expands state using deterministic transitions first phase notions defined shortly resulting state deterministic transitions equivalent singleton ample sets pel96a taken state without effecting truth property verified second phase expanded completely need crossover firstphase second phase detected using different much simpler strategy instack check strategy provides twophase advantages mentioned earlier important consequence strategy twophase naturally supports selective caching conjunction onthefly model checking explicit enumeration search algorithm typically saves list visited states hash table cached since number visited states large would beneficial visited states need stored hash table referred selective caching onthe fly model checking means algorithm finds property true state graph system constructed opposed finding graph completely constructed difficult combine onthefly model checking algorithm partialorder reductions selectivecaching due need share information among three aspects hpy96 shown previous attempts combining instack checking based algorithms onthefly algorithm presented cvwy90 er roneous however thanks fact first phase twophase depend stack state combined easily use colloquial plural form word proviso mean particular implementations instack checks onthefly algorithm presented cvwy90 simple effective selectivecaching strategy discussed sections 6 61 rest paper organized follows section 2 presents related work section 3 presents definitions background section 4 presents basic depthfirst search algorithm instack checking based partial order reduction algorithm section 5 presents twophase algorithm proof correctness section 6 presents onthefly model checking algorithm presented cvwy90 discusses combined twophase section also presents simple effective selective caching strategy shows incorporated twophase section 7 compares performance algorithm pel96a implemented spin twophase implemented pv tool provides qualitative explanation results finally section 8 provides concluding remarks 2 related work lipton lip75 suggested technique avoid exploring entire state graph find concurrent system deadlocks lipton noted execution transitions postponed much possible right movers transitions executed soon possible left movers without affecting deadlocks partial order reductions considered generalization idea verify richer properties deadlocks gw92 gp93 god95 partial order theory based traces preserve safety properties presented work uses slight variation proviso pel96a partial order reduction algorithm based ample sets proviso presented hp94 algorithm similar based algorithm pel96a given algorithm implemented spin algorithm pel96a discussed section 4 algorithms proviso realized using instack check valmari val92 val93 presented technique based stubborn sets construct reduced graph preserve truth value stutter free twophase algorithm conceived end 1995 context verifying real distributed shared memory protocols used avalanche processor ckk96 first proved twophase preserved stutterfree safety properties ng97a later extended proof ltlx ng97b ng98a nal98 pv tool embodying twophase also demonstrated ng98b thanks editorial comments received review paper know condition deterministic discovered us avoid explicit instack check turns exact condition required ctlx stutter free ctl preserving methods gkpp95 val96 pel96b fact realize twophase ends implementing conditions a5 a8 val96 thus twophase preserves ctlx argued section 51 referring existing proofs new insights characterize contributions follows 1 experimental characterization state explosion caused instack method 2 new partial order reduction algorithm called twophase uses alternative proviso implementation instack method thereby considerably mitigating state explosion 3 advantages method realizing proviso terms supporting selective caching onthefly modelchecking 4 extensive list experiments demonstrate superior performance pv modelchecker compared tools class 3 definitions notation process oriented modeling language process maintaining set local variables access assumed value local variables form local state process convenience process assumed contain distinguished local variable called program counter control state concurrent system system consists set processes set global variables pointto point channels finite capacity facilitate communication among processes global state state consists local states processes values global variables contents channels denotes set possible states syntactic state system obtained taking cartesian product range variables local variables global variables program counters channels system range variables local global channels assumed finite hence also finite program counter process associated finite number transitions transition process p readwrite local variables p readwrite global variables send message 2000revtex 21072000 1637 p channel sender andor receive message channel receiver transition may enabled states example receive action channel enabled channel nonempty transition enabled state uniquely defined nondeterminism simulated multiple transitions given program counter 0 used indicate transitions 2 indicate state system ts indicate state results executed p indicate sequential process system pcsp indicate program counter control state p pct indicate program counter transition associated local transition statement said local involve global variable global transition said global involves one global variables two global transitions two different processes may may commute whereas two local transitions two different processes commute control state program counter process said internal transitions associated local transitions unconditionally safe local transition said unconditionally safe states 2 enabled disabled 2 remains enabled disabled 0 transition another process note unconditionally safe transition definition also local transition observation follows executing 0 either order would yield state iet 0 commute property commutativity forms basis partial order reduction theories note channel communication statements unconditionally safe transition process p attempts read channel empty transition disabled however process q writes channel becomes enabled similarly transition process p attempts send message channel channel full disabled process q consumes message channel becomes enabled conditionally safe conditionally safe transition behaves like unconditionally safe transition states characterized safe execution condition pt formally local transition process p said conditionally safe whenever state 2 pt enabled disabled also enabled disabled 0 transition process p words 0 commute states represented pt channel communication primitives conditionally safe receive operation channel c safe execution condition c empty similarly send operation channel c safe execution condition c full safe transition safe state unconditionally safe transition conditionally safe whose safe execution condition true ies 2 pt deterministic process p said deterministic written deterministicp control state p internal transitions p control state safe exactly one transition p enabled independent two transitions 0 said independent iff least one transitions local belong different processes partial order reduction algorithms val92 pel96a hp94 god95 use notion ample set based safe transitions twophase hand uses notion deterministicsingleton ample setsto obtain reductions proof correctness twophase algorithm uses notion independent transitions 31 linear temporal logic b uchii automaton ltlx formulae ltl formulae without next time operator x formally system ltlx lineartime logic without next time operator stutter free ltl defined atomic propositions means boolean connectives 2 always 3 eventually u operators infinite sequence states assign truth value satisfaction relation ff j oe defined follows ff ff ff ff ff ff concurrent system j oe true iff sequence ff generated initial state ff buchii automaton vl90 nondeterministic finite automata acceptance condition specify infinite word word accepted automaton formally buchii automaton tuple set states q 0 initial state sigma input delta q theta sigma theta q f q set final states run word infinite sequence states delta sequence ff accepted iff least one state f appears infinitely often oe model checking problem may viewed automatatheoretic verification problem lm loe lm loe languages accepted lineartime temporal formulae oe respectively automaton buchii automaton oe accepts language loe verification problem lm loe answered constructing state graph synchronous product oe momega oe strongly connected components graph represented satisfies acceptance condition oe oe violated kur94 4 basic dfs instack check based partial order reduction algorithms figure 2 shows basic depth first search dfs algorithm used construct full state graph protocol v f hash table visited used cache states already visited statement 1 shows algorithm expands transitions given state statement shows algorithm constructs state graph system e f partial order reduction based search algorithms attempt replace 1 choosing subset transitions idea two transitions 0 commute state property verified insensitive execution order 0 algorithm explore ts postponing examination 0 ts course care must exercised ensure transition postponed forever commonly referred ignoring problem algorithm pel96a hp94 shown dfs po figure 3 already mentioned algorithm implemented spin algorithm also uses amples select subset transitions expand step amples returns proper subset enabled transitions following conditions must hold set transitions returned commute 2000revtex 21072000 1637 p modelcheck f f foreach enabled endif endforeach figure 2 basic depth first search algorithm transitions b none transitions result state currently explored indicated presence redset variable maintained dfs po intuitive reasoning behind condition b two states 0 reach without condition might delegate expansion transition 0 vice versa hence without condition algorithm may never explore transition condition b sometimes referred reduction proviso simply proviso enforced highlighted line amples transition say postponed must examined successor avoid ignoring problem however ts explored iets 2redset circularity results ts might postponed break circularity amples ensures ts redset section 61 shows later dependency ample redset evaluate set transitions important consequences onthefly model checking algorithms used 41 efficacy partial order reductions partial order reduction algorithm shown figure 3 reduce number states exponential factor hp94 pel96a however many practical protocols reductions effective reason traced implementation proviso using instack checking motivated using system shown figure 4 figure 4a shows system consisting two sequential processes p1 p2 communicate ie total number states system 9 optimal reduced graph system contains 5 states shown figure 4b figure 4c shows state graph generated partial order reduction algorithm figure 3 graph obtained follows initial state s0s0 amples0s0 may return either 2000revtex 21072000 1637 p f record redset partly expanded redset uses redset foreach transition amples completely expanded remove redset redset redsetfsg f process p acceptable true transitions p foreach ift global enabled conditionally safe 62 pt acceptable false endif acceptable least one enabled transition return enabled transitions subset transitions found return enabled transitions figure 3 proviso based partial order reduction algorithm f 5 g without loss generality assume returns resulting states s1s0 s2s0 without loss generality assume algorithm chooses expand s1s0 first transitions f 2 g p 1 f 5 p 2 enabled 2 s1s0 s0s0 dfs pos1s0 called redsetfs0s0g result amples1s0 cannot return f 2 g returns f 5 g executing 5 s1s0 results s1s1 third state figure continuing way graph shown figure 4c obtained note system contains 9 reachable states system thus showing instack checking based partial order reduction algorithm might fail bring appreciable reductions confirmed examples section 7 algorithm may bring much reductions realistic protocols also tt22 tt44 tt66 tt88 system b optimal graph c search order dfspo figure 4 simple example optimal reduced graph reduced graph generated dfs po 5 twophase algorithm previous contrived example shows size reduced graph generated algorithm based instack checking quite high true even realistic reactive systems reactive systems transaction typically involves subset processes example serverclient model computation server client may communicate without interruption servers clients complete transaction transaction completed state system reset initial state partial order reduction algorithm uses instack checking state resetting cannot done initial state stack entire reachability analysis completed since least one process reset algorithm generates unnecessary states thus increasing number states visited already demonstrated figure 4 section 7 demonstrate realistic systems also number extra states generated due proviso high proposed algorithm described figure 5 first phase phase1 twophase executes deterministic processes resulting state second phase enabled transitions examined twophase algorithm often outperforms spin popackage evidenced examples section 7 note phase1 gen f fully expanded used proof f list fsg path fg foreach process p deterministics p let enabled transition p olds path folds sg goto nextproc endif list list next process returnpath f path phase1s phase 2 classic dfs s62v r fe used proof states path foreach enabled transition else states path figure 5 twophase algorithm eral notion coarsening actions example implemented dstep spin coarsening two actions given process combined together form larger atomic operation phase1 actions multiple processes executed 51 correctness twophase algorithm correctness twophase follows previous results particu lar theorem 63 val96 states conditions a5 a8 hold reduced unreduced transition systems branchingbisimilar condition a5 states every action enabled state reduced state space eventually stubborn set state 0 reduced statespace reachable condition easily satisfied twophase states attained end phase1 fully expanded phase2 fe figure 5 twophase records states fully expanded condition a8 states every state reduced state space either stubborn set contains actions internal action stubborn set exactly enabled superdeterministic exact definition superdeterminism context val96 may found reference context superdeterminism defined deterministic page 8 correctness twophase understood also terms proof pel96b proof correctness twophase first principles may found nal98 6 onthefly model checking model checking algorithm said onthefly examines state graph system builds graph find truth value property consideration truth value property evaluated inspecting subgraph algorithm need generate entire graph since state graphs many protocols quite large onthefly model checking algorithm might able find errors protocols otherwise impossible analyze discussed section 31 model checking problem equivalently viewed answering question graph represented momega oe synchronous product model buchii automaton representing oe contain paths satisfying acceptance condition oe algorithms dfs dfs po onthefly model checking algorithms since construct graph e f e r must analyzed later find acceptance condition buchii automaton oe met note e f e r holds information edges traversed part search condition infinite path e e f e r satisfies acceptance condition oe equivalently expressed 2000revtex 21072000 1637 p strongly connected component scc graph satisfies acceptance condition tarjan tar72 presented dfs based onthefly algorithm compute sccs without storing edge information since space premium verification problems store edge information major benefit using algorithm algorithm uses one word overhead per state visited traverses graph twice onthefly model checking algorithm cvwy90 shown figure 6 algorithm used find graph least one infinite path satisfying buchii acceptance condition note whereas tarjans algorithm find strongly connected components satisfy acceptance condition oe algorithm cvwy90 guaranteed find one infinite path satisfying acceptance condition since presence infinite path implies property violated usually sufficient find one infinite path attractiveness algorithm cvwy90 comes fact implemented one bit per state compared one word per state case tarjans algorithm algorithm consists two dfs searches dfs1 dfs2 outer dfs dfs1 similar dfs except instead maintaining e f algorithm calls inner dfs dfs2 accept state fully expanded dfs2 finds accept state reach expanding state state reach self path violating oe found stack needed implement dfs1 dfs2 figure assumes full state graph generated use along partial order reductions statements labeled 1 dfs1s dfs2s appropriately modified use transitions used conjunction dfs po search strategy twophase earlier attempts combining onthefly model checking algorithm dfs po shown incorrect hpy96 reason amples depends redset hence state expanded lines indicated 1 dfs1 dfs2 amples might evaluate different values amples returns different set transitions dfs1 dfs2 even accept state reachable graph constructed dfs1 dfs2 might able prove fact since information redset different dfs1 dfs2 amples may indeed return different transitions leading incorrect implementation hpy96 solves problem using following scheme amples imposes ordering processes system amples cannot choose process say due proviso choose amples equal enabled transitions addition one bit information recorded v1 indicate completely expanded en f outer dfs f foreach enabledtransition accept state call nested dfs 62 v2 seed inner dfs f foreach enabled transition tsseed error elseif dfs2ts figure 6 onthefly model checking algorithm countered part dfs2 bit inspected find amples must return enabled transitions must return subset transitions without requiring proviso strategy reduces opportunities obtaining effective reductions deemed good price pay ability use onthefly model checking algorithm thanks independence phase1 global variables including phase1s called dfs2 resulting state exactly called dfs1 hence onthefly model checking algorithm used easily conjunction twophase section 62 argued combination onthefly model checking algorithm selective caching technique used directly twophase 61 selective caching twophase dfs po used conjunction onthefly model checking algorithm obviate need maintain e r however memory requirements hold v r practical protocols still quite high selective caching refers class techniques instead saving every state visited v r subset states saved natural way incorporate selective caching twophase instead adding states path v r line 1 twophase added guarantees given state always generates subgraph beneath whether expanded part outer dfs inner dfs hence onthefly model checking algorithm still used adding instead list also means memory used list phase1 reused even memory required hold intermediate variable list reduced reason maintaining variable ensure loop terminates still guaranteed instead adding list unconditionally added solds total ordering pv uses bitwise comparison 62 combining onthefly model checking selective caching twophase selective caching technique combined twophase execution goes follows given state first expanded phase1 resulting state added v r fully expanded contains fully expanded states implies state graph starting given state dfs1 dfs2 onthefly algorithm hence onthefly algorithm selective caching used together twophase 7 experimental results already mentioned twophase outperforms algorithm dfs po implemented spin instack checking succeeds often confirmed results table 3 table shows results running dfs po twophase without selective caching enabled various protocols column corresponding dfs po shows number states entered v r time taken seconds spin 4 column column twophase shows number states v r time taken seconds twophase run without selective caching selective column twophase shows 3 examples well pv tool distribution available web url wwwcsutaheduformal verification 4 experiments run versions spin available 199798 number states entered v r list time taken seconds twophase run selective caching verification runs conducted ultrasparc1 512mb dram contrived examples b5 system shown figure 4a processes w5 contrived example show twophase always outperform dfs po system deterministic states hence twophase degenerates full search whereas dfs po find significant reductions sc serverclient protocol protocol consists n servers n clients client chooses server requests service service consists two round trip messages server client local computations dfs po cannot complete graph construction 4 memory limited 64mb memory limit increased 128mb generates 750k states protocols mig inv two cache coherency protocols used implementation distributed shared memory dsm using directory based scheme avalanche multiprocessor ckk96 directory based dsm implementation cache line designated node acts homea node responsible maintaining coherency line node needs access line required permissions contacts home node obtain permissions mig inv two cache lines four processes two processors act home nodes cache lines two processors access cache lines algorithms complete analysis mig within 64mb main memory albeit twophase performing much better inv much involved coherence protocol dfs po requires 128mb memory twophase hand finishes comfortably generating modest 27600 states selective caching 60736 states without selective caching within 64mb main memory protocols spin distribution pftp snoopy protocols provided part spin distribution pftp dfs po generates fewer states twophase without state caching reason little determinism protocol since twophase depends determinism bring reductions generates larger state space however state caching number states hash table goes factor 27 snoopy even though twophase generates fewer states number states generated dfs po twophase without selective caching close obtain meaningful con clusions reason twofold first protocol contains determinism helps twophase however number deadlocks protocol hence proviso invoked many times hence number states generated close table number states visited time taken seconds dfs po algorithm twophase algorithm various protocols protocol dfs po twophase selective mig 11362814 2280526 918517 inv 96108937 6073652 2760030 snoopy 1627944 1430527 861124 upo 49e06210 73354632 17661821 rowo 52e06330 86866544 22263632 memory model verification examples modeled hewlettpackard precision architecture hppa splittransaction coherent bus called runway bcs96 ggh 97 modern symmetric multiprocessor interconnect bus common subset promela supported pv tool spin applied approach verify memory orderings via finitestate reachability analysis described nal98 col92 gmng98 ngmg98 runway bus model method establish given memory ordering write atomicity wa uniprocessor order upo readorder ro read write order rowo involves writing highly nondeterministic test au tomata drive bus verifying execution never causes test automata enter one error states protocols number states saved dfs po approximately 25 times larger number states saved twophase selective caching 8 conclusion presented new partial order reduction algorithm twophase implements proviso without using instack checking correctness twophase shown follow earlier results ctl x preserving partialorder reduction methods also showed algorithm combined onthefly modelchecking algo rithm extensive set experiments demonstrated twophase outperforms algorithms realize proviso using instack checking instack check succeeds often twophase also naturally lends used conjunction simple yet powerful selective caching scheme twophase implemented modelchecker called pv available upon request r automatic verification finitestate concurrent systems using temporal logic specifications acm transactions programming languages systems reasoning parallel architectures memory efficient algorithms verification temporal properties stanford murphi verifier partial order approach branching time logic model checking test modelchecking refining dependencies improves partialorder verification methods using partial orders efficient verification deadlock freedom safety properties coverage preserving reduction strategies reachability analysis design validation computer protocols model checker spin improvement formal ver ification holzmann nested depth first search formal design verification methods shared memory systems partial order reduction without proviso new partial order reduction algorithm concurrent system verification modelchecker verifying ltlx properties partial order reduction algorithm without proviso explicit enumeration modelchecker test modelchecking approach verification formal memory models multiprocessors translation sr promela one combining partial order reductions onthefly model checking partial order reduction linear branching temporal logics process algebras stubborn attack state explosion stubborn set methods process algebras handbook theoretical computer science tr automatic verification finitestate concurrent systems using temporal logic specifications design validation computer protocols reasoning parallel architectures formal specification abstract memory models stubborn attack state explosion computeraided verification coordinating processes model checker spin new partial order reduction algorithm concurrent system verification stubborn set methods process algebras partial order reduction verifying hardware software context using myampersandldquotest modelcheckingmyampersandrdquo verify runwaypa8000 memory model reduction handbook theoretical computer science coverage preserving reduction strategies reachability analysis improvement formal verification formal modeling validation applied commercial coherent bus test modelchecking approach verification formal memory models multiprocessors memory efficient algorithms verification temporal properties one one onthefly verification stubborn sets refining dependencies improves partialorder verification methods extended abstract combining partial order reductions onthefly modelchecking state spin using partial orders efficient verification deadlock freedom safety properties partial order approach branching time logic model checking formal design verification methods shared memory systems ctr madanlal musuvathi shaz qadeer iterative context bounding systematic testing multithreaded programs acm sigplan notices v42 n6 june 2007 twan basten dragan bonaki marc geilen clusterbased partialorder reduction automated software engineering v11 n4 p365402 october 2004
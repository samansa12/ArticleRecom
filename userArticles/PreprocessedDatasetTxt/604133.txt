selective memoization present framework applying memoization selectively framework provides programmer control equality space usage identification precise dependences memoization applied according needs application two key properties framework efficient yields programs whose performance analyzed using standard techniqueswe describe framework context functional language implementation sml library language based modal type system allows programmer express programs reveal true data dependences executed sml implementation cannot support modal type system statically instead employs runtime checks ensure correct usage primitives b describe framework context functional language implementation sml library language based modal type system allows programmer express programs reveal true data dependences executed sml implementation cannot support modal type system stati cally instead employs runtime checks ensure correct usage primitives categories subject descriptors programming languages general f20 analysis algorithms problem complexity general d31 programming languages formal denitions theory d33 programming languages language constructs fea turescontrol structures general terms languages performance algorithms keywords memoization selective programmer controlled performance research supported part nsf grants ccr9706572 ccr0085982 ccr0122581 permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed prot commercial advantage copies bear notice full citation rst page copy otherwise republish post servers redistribute lists requires prior specic permission andor fee popl03 january 1517 2003 new orleans louisiana usa acm 1581136285030001 500 memoization fundamental powerful technique result reuse dates back half century 7 21 22 used extensively many areas dynamic programming 4 9 10 19 incremental computation 11 34 12 36 16 1 37 20 14 2 many others 8 23 17 25 26 20 fact lazy evaluation provides limited form memoization 18 although memoization dramatically improve performance require small changes code language library support memoization gained broad acceptance instead many successful uses memoization rely applicationspecic support code underlying reason one control since memoization performance user must able control performance memoization many subtleties memoiza tion including cost equality checking cache replacement policy memo tables make difference exponential linear running time general widely applicable memoization framework must provide control three areas 1 kind cost equality tests 2 identication precise dependences input output memoized code 3 space management control equality tests critical reusable results identied control identication precise dependences important maximize result reuse able control memo tables individual entries purged critical otherwise user know whether results reused paper propose framework memoization provides control equality identication dependences control space management study framework context small language called mfl provide implementation standard ml language also prove type safety correctness mflie semantics preserved respect nonmemoized version example show analyze performance memoized version quicksort within framework next section describe background related work section 3 introduce framework via examples section 4 formalize mfl language discuss safety cor rectness performance properties section 5 present simple implementation framework standard ml library section 6 discuss framework might extended allow better control space usage discuss relationship work previous work adaptive computation 2 background related work typical memoization scheme maintains memo table mapping argument values previously computed results table consulted function call determine particular argument table call skipped result returned otherwise call performed result added table semantics implementation memo lookup critical performance review key issues implementing memoization efciently equality memoization scheme needs search memo table match current arguments search minimum require test equality typically also require form hashing standard language implementations testing equality structures example require traversing whole structure cost equality test negate advantage memoizing may even change asymptotic behavior function approaches proposed alleviate problem rst based fact memoization equality need exactit return unequal two arguments actually equal implementation could therefore decide skip test equality expensive could use conservative equality test location equality problem approaches whether match found could depend particulars implementation surely evident programmer another approach reducing cost equality tests ensure one copy every value via technique known hash consing 13 5 35 one copy equality implemented comparing locations fact location also used key hash table theory overhead hashconsing constant expected case expecta tion internal randomization hash functions reality however rather different large memory demands hashconsing interaction garbage collection fact several researchers argued hashconsing expensive practical purposes 32 33 6 24 alternative hash con sing pugh proposed lazy structure sharing 32 lazy structure sharing whenever two equal values compared made point copy speed subsequent comparisons pugh points disadvantage approach performance depends order comparisons thus difcult analyze note even hashconsing method remains critical dene equality types including reals functions claiming functions never equivalent exam ple satisfactory result call involving function parameter never reused dependences maximize result reuse result function call must stored respect true dependences issue arises function examines parts approximation parameter enable partial equality checks unexamined parts parameter disregarded increase likelihood result reuse one able match approximation rather parameter exam ple consider code result f depends either xy xz also depends approximation xwhether positiverather exact value thus memo entry 71120 match 41150 since x positive result depends several researchers remarked partial matching important applications 28 27 1 14 abadi lampson levy 1 heydon levin yu 14 suggested program analysis methods tracking dependences purpose although technique likely effective catching potential matches provide programmer controlled mechanism specifying dependences tracked also program analysis technique change asymptotic performance pro gram making difcult asses effects memoization space management another problem memoization space requirement program executes memo tables become large limiting utility memoization alleviate problem memo tables individual entries disposed programmer control application dynamic programming result reuse occurs among recursive calls function thus memo table function disposed whenever ter minates applications result reuse less structured individual memo table entries purged according replacement policy 15 33 problem determine exact replacement policy used analyze performance effects chosen policy one widely used approach replace least recently used entry sophisticated policies also suggested 33 general replacement policy must applicationspecic xed policy programs whose performance made worse choice 33 3 framework selective memoization present overview framework via examples framework extends purely functional language several constructs support selective memoization section use extension mllike language discussion formalize core language study safety soundness performance properties section 4 framework enables programmer determine precisely dependences input result function main idea deem parameters function resources provide primitives explore incrementally value including underlying value resource incremental exploration process reveals dependences parameter function result incremental exploration process guided types value modal type underlying value type bound ordinary unrestricted variable let construct create dependence underlying value result value product type two parts bound two resources using let construct creates dependences value sum type case analyzed using mcase construct branches according outermost form value assigns inner value resource mcase creates dependence outer form value resource key aspect let mcase bind resources rather ordinary variables nonmemoized memoized fun fib nint mfun mfib nint n 2 n n 2 n else yint yint fy return fy else else fz z return fz z figure 1 fibonacci expressing partial dependences exploring input function via let mcase let builds branch recording dependences input result function let adds branch full value mcase adds kind sum let adds nothing con sequently branch contains data dependences lets control dependences mcases return en countered branch recording revealed dependences used key memo table result found memo table stored value returned otherwise body return evaluated memo table updated map branch result type system ensures dependences made explicit precluding use resources within returns body example consider fibonacci function fib memoized counterpart mfib shown figure 1 memoized version mfib exposes underlying value parameter resource performing two recursive calls usual since result depends full value parameter bang type memoized fibonacci function runs linear time opposed exponential time memoized partial dependences input result function captured using incremental exploration technique example consider function f shown figure 1 function checks whether x positive returns fyy fzz thus result function depends approximation x sign either z memoized version mf captures rst checking x positive exposing underlying value z accordingly consequently result depend sign x either z thus mf called parameters 157 rst 253 result found memo second time x positive result depends note mif construct used example special case general mcase construct critical issue efcient memoization implementation memo tables along lookup update operations framework support expected constant time memo table lookup update operations representing memo tables using hashing require underlying type modal type indexable type indexable type associated injective function called index function maps value type unique integer integer called index value uniqueness property indices given type ensures two values equal indices equal framework equality dened nonmemoized type irlintreal list ks case l c w ks ct else let v1v2 v1 else v2 figure 2 memo tables carded completion memoized type irlintreal blist mfun mks cintlirl case unbox l conswvt c w else let v1v2 v1 else v2 end memoized knapsack dis indexable types enables us implement memo tables hash tables keyed branches consisting indices assume primitive type comes index function examples integers identity function chosen index function composite types lists functions must boxed obtain indexable type boxed value type type tbox box created assigned unique locations tag location used unique index boxed value example dene boxed lists follows datatype cons blist box type blist blist box based boxes implement hashconsing form memoiza tion example hashconsing boxed lists implemented follows mfun hcons ha ta return box consht function takes item boxed list returns boxed list formed consing since function memoized ever called two values already hashconsed result returned advantage able de ne hashconsing memoized function applied selectively control space usage memo tables framework gives programmer way dispose memo tables conventional scop ing framework memoized function allocated memo table thus function goes scope memo table garbage collected example many dynamicprogramming algorithms result reuse occurs recursive calls function case programmer scope memoized function inside auxiliary function memo table discarded soon auxiliary function returns example consider standard algorithm knapsack problem ks memoized version mks figure 2 since result sharing mostly occurs among recursive calls mks scoped function calls mks mks returns memo table go scope discarded note technique gives partial control space usage particular give control individual nonmemoized memoized 15 20 fun fil gintbool fun mfil gintbool lint case l case unbox l nil nil nil empty ht consht let let case g h case g h true htt true hconshtt false tt false tt let return case l case unbox l nil nil nil nil consht consht let let qs shqs g mqs shmqs g figure 3 quicksort algorithm memo table entries purged section 6 discuss framework might extended memo table managed according programmer specied caching scheme basic idea require programmer supply caching scheme parameter mfun maintain memo table according chosen caching scheme memoized quicksort sophisticated example consider quicksort figure 3 show implementation quicksort algorithm memoized counterpart algorithm rst divides input two lists containing keys less pivot greater pivot using lter function fil sorts two sublists returns concatenation results memoized lter function mfil uses hashconsing ensure one copy result list memoized quicksort algorithm mqs exposes underlying value parameter otherwise similar qs note mqs build result via hashconsingit output two copies result since example output mqs consumed func tion need even result consumed function one choose use hashconsing operations insertions deletions input list surely change result quicksort memoized quicksort algorithm called similar puts one would expect results would reused indeed show memoized quicksort algorithm computes result expected linear time input obtained previous input inserting new key beginning expectation permutations input list also internal randomization hash functions used implement memo tables analysis assume without loss general ity keys list unique theorem 1 let l list let running memoized quicksort l l0 running time quicksort modied list l0 expected n length l0 3 26 9 figure 4 recursion tree quicksort inputs proof consider recursion tree quicksort input l denoted ql label node pivot corresponding recursive call see figure 4 example consider pivot key p l let lp denote keys precede p l easy see key k subtree rooted p following two properties satised key k0 2 lp 1 k0 p k k0 2 k0 p k k0 keys subtree p less p left subtree greater p right subtree consider recursion tree ql0 pivot ql0 suppose p let k key left subtree p ql since k p two properties k left subtree p ql0 similarly p k right subtree p ql also right subtree p ql0 since ltering preserves respective order keys input list p p input recursive call corresponding left child similarly p input recursive call corresponding right child thus sorting l0 recursive calls nd results memo therefore recursive calls corresponding root children nodes rightmost spine left subtree root children nodes leftmost spine right subtree root may executed two spines shown thick lines figure 4 furthermore results calls adjacent spines found memo consider calls whose results found memo worst case calls along two spines consider sizes inputs nodes spine dene random variables x1 xk xi least number recursive calls nodes performed input size become n less after3 i1 rst becomes 4 n less since k dlog43 ne total expected number operations along spine dlog43 ne 3i1 dlog43 ne 3i1 since probability pivot lies middle half list 12 exi 2 1 dlog43 ne i1ecn 2 ni1 thus bound holds spines therefore number operations due calls whose results found memo since operation including hashconsing takes expected constant time total time calls whose results memo consider calls whose results found memo call spine adjacent thus expected ologn calls since memo table lookup overhead expected constant time total cost ologn conclude quicksort take expected time sorting modied list l0 easy extend theorem show bound holds insertion anywhere list although bound better complete rerun would take onlogn would like achieve ologn section 6 discuss combination memoization adaptivity 2 may used reduce expected cost random insertion ologn section study small functional language called mfl supports selective memoization mfl distinguishes memoized nonmemoized code equipped modality tracking dependences data structures within memoized code modality central approach selective memoization focus attention main result soundness theorem stating memoization affect outcome computation compared standard nonmemoizing semantics also show memoization mechanism mfl causes constant factor slowdown compared standard nonmemoizing semantics 41 abstract abstract syntax mfl given figure 5 metavariables x range countable set variables metavariables b range overf countable set resources distinction made clear metavariable l ranges countable set locations assume variables resources locations mutually disjoint binding scope conventions variables resources would expected syntactic forms usual identify pieces syntax differ choice bound variable resource names term expression resourcefree contains free resources variablefree contains free variables closed term expression resourcefree variablefree otherwise open types mfl include 1 unit int products sums recursive data types ut memoized function types bang types h mfl distinguishes indexable types denoted h accept injective function called index function whose codomain integers underlying type bang type h restricted indexable type int type identity serves index constant function chosen index function nonprimitive types index supplied boxing values types boxed values would allocated ix types types mcase mfun f at1t2 iseend j figure 5 abstract syntax mfl store unique location box would serve index underlying value extension indexable types would dened although supporting boxed types critical practical purposes formalize focus main ideas syntax structured terms expressions terminology pfenning davies 30 roughly speaking terms evaluate independently context ordinary functional program ming whereas expressions evaluated relative memo table thus body memoized function expression whereas function term note however application function term expression corresponds encapsulation memoization function updating memo table benign complete language would include case analysis projection forms among terms sake simplicity include expressions would also include plain function body term note every term trivially expression return expression inclusion 42 static semantics type structure mfl extends framework pfenning davies 30 necessitation modality h used track data dependences selective memoization modality correspond monadic interpretation memoization effects notation pfenning davies though one could imagine adding modality language introductory eliminatory forms necessity standard namely introduction letxhbet ineend elimination modality demands distinguish variables sources variables mfl correspond validity unre stricted context modal logic whereas resources mfl correspond truth restricted context analogy may also made judgmental presentation linear logic 29 31 variables correspond intuitionistic context resources linear context1 1note however impose linearity constraints type system res pairs g fun g funval apply bang inl inr unroll figure 6 typing judgments terms inclusion returnt terms expressions analogue pure modal logic specic interpretation memoization computational effect typing rule returnt requires resourcefree ensure dependence argument memoized function made explicit code computing return value function rst instance resources arise parameters memoized functions resources introduced incremental decomposition using let mcase additional resources track usage asyetunexplored parts data structure ultimately complete value resource may accessed using let construct binds value variable may used without restriction practice means parts argument memoized function whose value function depends given modal type however essential resources modal type computation depend upon every resource modal type static semantics mfl consists set rules deriving typing judgments form gd expressions judgments g variable type assignment nite function assigning types variables resource type assignment nite function assigning types resources rules deriving judgments given figures 6 7 return let case figure 7 typing judgments expressions 43 dynamic semantics dynamic semantics mfl formalizes selective memoization evaluation parameterized store containing memo tables track behavior functions program evaluation function expression causes empty memo table allocated associated function application memoized function affected may affect associated memo table function value become inaccessible also associated memo table hence storage required reclaimed unlike conventional memoization however memo table keyed control ow information rather values arguments memoized functions key supporting selective memoization expression evaluation essentially exploration available resources culminating resourcefree term determines value since exploration datasensitive certain aspects resources may relevant particular outcome example memoized function may take pair integers argument outcome determined independently second component case rst positive recording controlow information evaluation may use provide selective memoization example situation described pairs form map result value irrespective value v conventional memoization memo table would keyed pair result redundant computation performed case function previously called v even though value v irrelevant result framework instead key memo table branch records sufcient control ow information capture general case whenever encounter return statement query memo table current branch determine whether result computed return stored value evaluate return statement associate value branch memo table future use crucial returned term contain resources assured value change across calls function dynamic semantics mfl given set rules deriving judgments form st vs0 terms slbe e vs0 expressions rules deriving judgments given figures 8 9 rules make use branches memo tables stores whose precise denitions follows simple branch list simple events corresponding choice points evaluation expression simple event simple branch eb write bbe stand extension b event e end memo table q nite function mapping simple branches values write qb v b 2 domq stand 7 extension q given binding b write qb mean b 2 domq store nite function mapping locations l memo tables write sl q l 2 doms stand extension 7 given binding l l 2 doms write sl q store maps l q l sl0term evaluation largely standard except evaluation memoizing functions applications arguments evaluation memoizing function term allocates fresh memo ta ble associated functions value expression evaluation initiated application memoizing function argument function value determines memo table used call evaluation body performed relative table initiating null branch expression evaluation performed relative current memo table branch return statement encountered current memo table consulted determine whether branch previously taken stored value turned otherwise argument term evaluated stored current memo table branch value returned let mcase expressions extend current branch reect control ow since let signals dependence complete value value added branch case analysis however merely extends branch indication case taken let construct extend branch additional information gleaned splitting pair 44 soundness mfl prove soundness mfl relative nonmemoizing semantics language straightforward give purely functional semantics pure fragment mfl inductive denition relations v e e v e v pure sense may involve subscripted function values underlying term mfl term obtained erasing location subscripts function values occurring within soundness mfl consists showing evaluation memoization yields outcome evaluation without memoization theorem 2 soundness 0t vs 00 full proof given 3 statement theorem must strengthened considerably account terms expres sions take account nonempty memoization contexts proof proceeds induction evaluation easy show nonmemoizing semantics mfl type safe using completely conventional techniques follows unit number sn ns sn1tn vnsn pair l 2 doms se vs0 funval apply bang st vs0 inject sinlt1t2t inlt1t2 vs0 sinrt1t2t inrt1t2 vs0 unroll figure 8 evaluation terms memoizing semantics also typesafe would closed value type canonical type ever erasure preserves reects canonical forms hence soundness theorem mfl must also type safe 45 performance show memoization slows mfl program constant factor expected respect standard nonmemoizing semantics even results reused result relies representing branch sequence integers using sequence key memo tables implemented hash tables represent branches integer sequences use property mfl underlying type h bang type h indexable ret found s0lbv1a1v2a2e e vs00 let slbleta1a2 bet ineend vs00 case figure 9 evaluation expressions type since value indexable type integer index represent branch dependencies sequence integers corresponding indices leted values zero one inl inr consider nonmemoizing semantics return rule always evaluates body neither looks updates memo tables stores consider mfl program let denote time takes number evaluation steps evaluate program respect nonmemoizing semantics let t0 denote time takes evaluate program respect mem oizing semantics worst case results reused thus difference t0 due memotable lookups updates done memoizing semantics bound time consider memo table lookup update branch b let jbj length branch since branch sequence integers lookup update performed expected ojbj time using nested hash tables represent memo tables note nonmemoizing semantics takes jbj time build branch thus cost lookup update charged evaluations build branch b ie evaluations let mcase furthermore evaluation let mcase charged exactly one return thus conclude expected case 5 implementation describe implementation framework standard ml library aspects mfl language relies syntactic distinction resources variables cannot enforced statically standard ml therefore use separate type resources employ runtime checks detect violations correct usage signature sig expressions type expr val return unit expr resources type res val expose res bangs type bang val bang int bang val letbang bang b expr b expr products type ab prod val pair b ab prod val letx ab prod res b res c expr c expr val split ab prod b c c sums type ab sum val inl ab sum val inr b ab sum val mcase ab sum res c expr b res c expr c expr val choose ab sum c b c c memoized arrow type ab marrow val mfun res b expr ab marrow val mfun rec b marrow res b expr ab marrow val mapply ab marrow b signature type box val init unitunit val box aa box val unbox boxa val getkey boxint figure 10 signatures memo library boxes interface library shown figure 10 provides types expressions resources bangs products sums memoized functions along introduction elimination forms expressions type expr monad return inclusion various forms bind induced elimination forms letbang letx mcase resource type res expose elimination form resources created library thus introduction form resources available user introduction elimination form bang types bang letbang introduction elimination form product types pair letx split respectively letx form bind monad expr split elimination form term context treatment sums similar product types introduction forms inl inr elimination forms mcase choose mcase form bind expr monad choose elimination term context memoized functions introduced mfun mfun rec mfun takes function type res b expr returns memoized function type ab marrow mfun rec similar mfun also takes parameter memoized version note result type contain effect exprwe encapsulate memoization effects benign within function elimination form marrow memoized apply function mapply functor buildmemo structure box box structure struct type list unit type res res expose val val h vbranch susp type val f res x1 res x2 datatype ab sum inl inr b mcase f val case inr v 1g res v lrbranchsusp choose f case inl v f v inr v g v type fun mfun rec val val val case memopadextend mpad branch val vnone v found result similar mfun rec mapply f figure 11 implementation memoization library figure 11 shows implementation library without runtime checks correct usage incorporate runtime checks one needs sophisticated denition resources order detect resource exposed context ie function instance addition interface must updated rst parameter letbang letx mcase occurs suspended form allows us update state consisting certain ags forcing term structure struct type utilities fun ibang fibonacci letbang expose n fn n return fn else mapply f ibangn1 mapply f ibangn2 mapply mfun rec mfib n boxed lists datatype cons blist box type blist blist box hash cons letx expose x fn ht letbang expose h fn h letbang expose fn return fn box consht val hcons mfun hcons knapsack letx expose arg fn cl letbang expose c fn c letbang expose l fn l return fn case unbox l conswvt c w mapply mks pair ibang c bbang else let val ibang c bbang val mapply mks arg1 val ibang cw bbang val mapply mks arg2 v1 v2 v1 else v2 fun mks mapply mfun rec mks x quicksort val val hcons mfun hcons case unbox l consht f h mapply hcons pair ibang h bbang fil f else letbang expose l fn l return fn case unbox l consht let val val val mapply qs bbang val mapply qs bbang gg mfun rec qs figure 12 examples section 3 sml library implementation extends operational semantics mfl language section 43 boxes bang primitive takes value injective function called index function maps value integer called index index value used key memo tables restriction indices unique enables us implement memo tables nested hash tables support update lookup operations expected constant time primitive letbang takes value b bang type body applies body underlying value b extends branch index b function letx takes pair p body binds parts pair two resources applies body resources operational semantics letx extend branch function mcase takes value sum type body branches outer form binds inner value resource applies body resource extends branch 0 1 depending outer form elimination forms sums products term context split choose standard return primitive nalizes branch returns body suspension branch used mfun rec mfun key memo table result found memo table suspension disregarded result reused otherwise suspension forces result stored memo table keyed branch mfun rec primitive takes recursive function f parameter memoizes f associating memo pad subtle issue f must calls memoized version recursively therefore f must take memoized version parameter note also memoized function internally converts parameter resource applying f interface library provides introduction form sources indeed resources created library inside letx mcase mfun rec mfun function expose elimination form resources example one would like apply letbang resource must rst expose source exposes underlying value figure 12 show examples section 3 written sml library note memoized fibonacci function mfib creates memo table every time called mfib nishes table garbage collected applies mks quicksort provide function mqs returns instance memoized quicksort applied instance memo table note also mqs creates local instance hashcons function instance memoized quicksort memo table hashconsing examples use sum types provided library represent boxed lists need general one use provided sum types instead ml counterparts example mcase needed examples figure 12 implemented using following denition boxed lists datatype roll unit boxlist box prod sum type boxlist boxlist box changing code figure 12 work denition boxed lists requires several straightforward modications 6 discussion space cache management framework associates separate memo table memoized function allows programmer control lifespan memo tables conventional scoping somewhat coarse degree control sufcient certain applications dynamic programming ner level control may desirable applications result reuse less regular application benet specifying caching scheme individual memo tables determine size memo table replacement policy discuss framework extended associate cache scheme memo table maintain memo table accordingly caching scheme specied form parameter mfun construct evaluated construct bind caching scheme memo table memo table maintained accordingly changes operational semantics accommodate extension small store map label pair consisting memo table caching scheme handling return changed stores merely expand updated according caching scheme adding new entry following shows updated return rule denotes caching scheme q denotes memo table update function denotes function updates memo table accommodate new entry possibly purging existing entry programmer must ensure caching scheme violate integrity memo table tampering stored values found example specify memo table fibonacci function shown figure 1 contain two entries managed using leastrecentlyused replacement policy sufcient ensure memoized fibonacci runs linear time extension also incorporated type system described section 4 would require associate types memo stores also require develop type system safe update functions enforce caching schemes safe local vs nonlocal dependences dependence tracking mechanism captures local dependences input result function local dependence function f one created inside static scope f nonlocal dependence f created f passes input function g examines fs input indirectly previous work abadi et al 1 heydon et al 14 showed program analysis technique tracking nonlocal dependences propagating dependences function caller however make clear performance implications technique framework extended track nonlocal dependences introducing application form memoized functions expression context extension would example allow dependences nonconstant length chose support nonlocal dependences clear utility exceeds performance effects memoization adaptivity work present paper motivated previous work adaptive computation 2 briey discuss relationship memoization adaptivity combined obtain efcient dynamic incremental algorithms 5 6 adaptive computation maintains dynamic dependence graph representing data control dependences input modied change propagation algorithm updates output dependence graph adaptivity mechanism handles deep 7 changes efciently say change deep affects calls occur leaves call tree computation contrast 8 change shallow affects calls occur roots call tree example consider quicksort algorithm picks rst key input pivot inserting new key end input list deep change change affect last 10 recursive calls lter functions become pivot end sequence recursive calls quicksort contrast inserting new key beginning list shallow change quicksort new key selected pivot immediately rst call quicksort adaptivity mechanism based dynamic dependence graphs handles insertion end input deep change expected ologn 12 time 2 whereas insertion beginning list shallow change cause complete rerun takes onlogn time using memoization however insertion beginning list handled time showed section 3 13 change thought combination shallow deep changes since memoization adaptivity complement handling deep shallow changes would expect combination two techniques would handle general 14 changes efciently example quicksort expect insertion random position list would handled expected time combination two techniques 15 7 conclusion 16 presented framework selective memoization programmer control framework makes explicit performance effects memoization yields programs whose running times analyzed using standard techniques key aspect 17 framework capture control data dependences input result memoized function main contributions paper particular set primitives 18 suggest semantics along proofs sound gave simple implementation framework standard 19 ml language expect framework implemented purelyfunctional language r analysis caching dependencies adaptive functional programming selective memo 23 ization design analysis computer algorithms anatomy lisp dynamic programming tabulation techniques recursive programs acm computing surveys eliminating redundant recursive calls acm transactions programming languages systems algorithms incremental evaluation attribute grammars application syntax directed conference record 8th annual acm symposium pages 105 incremental reduction pages 307 hashing lemmas time complexities applications formula manipulation caching function calls using acm sigplan notices elimination recursive calls using small table randomly selected function values alphonse incremental computation programming lazy memofunctions conference implementation dynamic programming via static static caching incremental computation languages systems formal systems memo functions machine learning automating program speedup deciding cache wizard tilt ef cient techniques automatic memoization applications contextfree parsing generating incremental attribute evaluators using cached functions constructors incremental attribute evalua tion structural cut elimination judgmental reconstruction modal logic natural deduction intuitionistic noncommutative linear logic incremental computation via function caching improved replacement strategy function caching incremental computation via function caching example hierarchical design proof incremental compilation via partial evaluation automating derivation incremental programs tr eliminating redundant recursive calls lazy memofunctions improved replacement strategy function caching incremental computation via function caching specification transformation programs formal approach software development introduction algorithms incremental reduction lambda calculus alphonse analysis caching dependencies automating derivation incremental programs static caching incremental computation caching function calls using precise dependencies tabulation techniques recursive programs example hierarchical design proof adaptive functional programming anatomy lisp incremental evaluation attribute grammars application syntaxdirected editors design analysis computer algorithms dynamic programming via static incrementalization natural deduction intuitionistic noncommunicative linear logic using cached functions constructors incremental attribute evaluation structural cut elimination hashing lemmas time complexities applications formula manipulation dynamic programming ctr kedar swadi walid taha oleg kiselyov emir pasalic monadic approach avoiding code duplication staging memoized functions proceedings 2006 acm sigplan symposium partial evaluation semanticsbased program manipulation january 0910 2006 charleston south carolina haiying xu christopher j f pickett clark verbrugge dynamic purity analysis java programs proceedings 7th acm sigplansigsoft workshop program analysis software tools engineering p7582 june 1314 2007 san diego california usa kevin walsh emin gn sirer staged simulation general technique improving simulation scale performance acm transactions modeling computer simulation tomacs v14 n2 p170195 april 2004 geoffrey washburn stephanie weirich boxes go bananas encoding higherorder abstract syntax parametric polymorphism acm sigplan notices v38 n9 p249262 september darko marinov robert ocallahan object equality profiling acm sigplan notices v38 n11 november neil jones transformation interpreter specialisation science computer programming v52 n13 p307339 august 2004 weingan chin siaucheng khoo neil jones redundant call elimination via tupling fundamenta informaticae v69 n12 p137 january 2006 umut acar guy e blelloch robert harper adaptive functional programming acm transactions programming languages systems toplas v28 n6 p9901034 november 2006 umut acar guy e blelloch matthias blume kanat tangwongsan experimental analysis selfadjusting computation acm sigplan notices v41 n6 june 2006 k v seshu kumar value reuse optimization reuse evaluated math library function calls compiler generated cache acm sigplan notices v38 n8 august
prototyping process monitoring experiment features often basic unit development large software system represent longterm efforts spanning several years inception actual use developing experiment monitor means sampling lengthy processes requires great deal care order minimize casts maximize benefits prototyping often necessary auxiliary step largescale longterm development effort prototyping necessary step development largescale longterm process monitoring experiment therefore prototyped experiment using representative process reconstructed data large rich feature development approach yielded three interesting sets results first reconstructed 30month time diary lead engineer feature composed hardware software data represent daily state lead engineer spent majority time complete cycle development process second found needed modify experimental design initial set states represent data well hoped exemplified fact category large finally data provide evidence waterfall view interactive cyclic view software development conclude prototyping effort necessary part developing installing largescale process monitoring experiment b introduction features often basic unit development large software systems represent longterm efforts spanning several years inception actual use thus monitoring lengthy processes longterm effort well report initial step development experiment monitor processes prototyping experimental design monitor representative process used developing features remainder section 1 provide background information relevant general goals experiment present motivations experiment prototype discuss related work section 2 present experimental design discuss issues instrumenting experiment section 3 describe method prototyping process monitoring experiment evaluate results prototype experiment section 4 discuss results prototype analyses indicate interesting aspects prototype data finally section 5 present conclusions 11 background like costs viewed unit optimization improving software development processes particular processes artifacts evolved time accreted variety inefficiencies optimizing development interval one way exposing many inefficiencies reducing costs general goal organizations maintain increase level quality reducing costs need welldefined repeatable process humphrey89 pp 5 67ff specific goal process monitoring experiment find ways reduce development interval cost accuracy concerns interference fundamental interrelated factors developing experiments monitor process adding features large software system obviously tradeoff cost accuracy obtaining data process typically higher accuracy higher cost obtaining data furthermore higher accuracy likely process obtaining data intrusive turn affect probability successfully completing process measure interference viewed probability inhibiting success background developmental experimental factors note utility modeling development intervals queuing network believe first time queueing models used describe development time interval approach motivates need record server interval person executing process spending time suggest exists strong analogy software designer hardware designer figure 1a sw development queueing network model simple queueing network models example software developers interaction project librarian hardware developer coding module software development accomplishes work manufacturing single job shop works 1 illustrate use queueing network model software development describing arrival new design component coding process initial work software developer example starts developer idle new design component arrives queue figure 1a arc 1 developer immediately starts working new design component figure 1b day 1 2 get marked morning third day discovers need consult hardware interface finds reference notes calls library figure 1a arc 2 finds library closed librarian class leaves message since hardware state information crucial algorithm selection developer decides stop working gets hardware description figure 1b day 3 gets marked waiting library spends rest day answering mail catching reading next morning finds hardware design specification mail efficient librarian answered request left document figure 1a arc 3 using document resolves algorithm choice continues work remainder design figure 1b day 4 late afternoon discovers inconsistency assumption notes hardware document two years old developer decides consult hardware designer figure 1a arc 4 finds longer familiar interface glad help however discovers longer circuit diagrams design document describes must get library figure 1a arc 5 waiting diagrams must find things figure 1b day 5 gets marked waiting hardware expert eventually another day later due interruptions hardware designer resolves problem calls developer late afternoon resolution conflict figure 1a arc 7 works remaining hours continuing implementation figure 1b day 6 note day logged blocked state day finishes work another four days figure 1b days 710 strategy paper assume queueing networks natural fit modeling process 2 sojourn time queueing network development interval would like understand control know queueing theory calculate sojourn time open networks necessary know service distributions branching probabilities 3 queue priority disciplines however many approximation techniques exist information partially known instrumentationcost considerations information captured known inaccurate nozari87 12 motivation two strands discussion interwoven paper process monitoring experiment prototype experiment emphasis paper prototype however use discussion experiment 1 therefore propose using network queueing models investigate software development process 2 believe important topic offer observation fitness modeling technique experiments continue investigate queueing theory framework modeling software development process interval 3 network map figure 1c additional information probable arc given node would taken block hw exp working code block librar reqs figure 1b plot developer activity per day plots show data collected characterize software developer new design component state top plot software developers service time distribution software development task units days bottom plot service time distribution corresponding states context discussion prototype conversely use discussion prototype elicit intriguing observations hope validate subsequent experiments motivation monitoring current processes straightforward want find people actually add features large software system two phrases emphasis last sentence people actually first instance interested people interact tools interact though interested people interact tools people interact paramount importance engineering processes allen77 second instance concerned actually opposed intended thought want understand people progress activities la guindons study software design guindon90 hindered making progress activities features unit development important understand people developing feature interact within single feature development different development groups interact developing several features concurrently particular individual group interactions depend kind size complexity features independent factors purpose experiment provide understanding feature development processes use understanding basis accurate descriptions substantive improvements processes motivation prototyping experimental design also straightforward experiment longterm effort want work many wrinkles possible committing actual experiment situation differs basili weiss basili84 4 following way already costly mechanism place within proposed experimentation mechanism costly otherwise place fact desired result experiment install mechanism approach prototype experiment means case study demonstrate use prototyped experiment tune instrumentation hone experimental purpose actual experiment enables us shortcircuit usual experiment pitfalls increase efficacy experiment 4 basili weiss emphasize validation data collection completely agree position would maintain position valid entire process part study namely coding feel prototyping experiment valuable extension work whatever reason neither methodology instrumentation place hardware designer librarian246software designer figure 1c communication network map plot captures important details different process executors communicate note one develop intuition diagrams relate organizational structure physical location interested reader directed chapter 5 allen77 arc labeling corresponds used figure 1a since discussing part single development frequency information expect gather subsequent experiments analogous need understand interactions among people groups need understand interactions among various aspects experiment general problem experiment large number variables essential ones missing something important experiment example various aspects hardware processes dominate entire process reducing wait time software process intended impact interval kinds factors interaction wish gain preliminary understanding prototype two concerns respect prototyping experiment important first want minimize impact development want minimize cost experiment minimize interference may result experiment maximize accuracy data collected second want illustrate experiment possible results gain early feedback participating experiment also motivate participants showing various kinds anticipated results 13 related work one points discussion 5th international software process workshop need look fields see solved problems modeling processes perry89 note queueing networks extensively used modeling complex manufacturing processes nozari87 virtually work reported various process workshops see potts84 wileden85 dowson86tully88 perry89 katayama90 thomas91 1st international conference software process dowson91 concerned process formalisms analysis support several strands related work consider important reducing task intervals kellners use statemate harel88 provide management perspective modeled processes kellner91 perrys policy productinduced partial ordering process activities perry91 kaiser barghoutis implementation concurrent rulechains automating tool interactions barghouti90 mi scacchis inclusion roles resources basic entities articulator model wi91 common thread discussions providing support monitoring measuring processes several frameworks measurementguided software development tame project basili88 amadeus system selby91 two frameworks latter aimed providing measurement feedback within processcentered environment taylor88 general emphasis automating measurement control evolving products 5 approach assumes know needs measured control process desired level 5 specifically related providing information processes discussions darpa prototech process virtual machine pvm working group pvm912 work however still exploratory stage envisioned resulting framework provide basic facilities monitoring various aspects processes executed within pvm framework precision within desired cost constraints believe reached level maturity measurement control software processes software engineering laboratory basili92 focused experiments various kinds determine effects different languages methods tools software development process knowledge taken approach monitoring processes prototyping experiments work know similar wolf rosenblum wolf93 approach monitor processes situ similar emphases various events intervals differ several important respects experimental approach subject experiments first means capturing process data quite different second process monitoring load build process small one repeated regularly frequently finally monitoring process deals entire system dealing individual feature developments within context entire system 2 experimental design instrumentation first describe design experiment discuss several important aspects instrumentation namely cost precision accuracy finally discuss problems repeatability reproducibility 21 design approach use experiment sample process activities periodic basis use samples build database time spent throughout development various selected features claim advantages approach simplicity low cost process characterized set tasks set states tasks define various activities within process interest sampled experiment states represent either progress within task lack progress task blocked reason participant reminded periodic basis daily usual periodicity remotely log activity previous day tool presents user menu tasks task selected tool presents user menu states task user selects appropriate one intentis sample important aspect task previous day tool automatically provides category tasks states selected tool elicits textual description clarify done person blocked latter facility enables us tune experiment process category becomes large basic mechanisms experiment email system remind users log previous days tasks state progress within task menubased tool activated remote login throughout network development machines capture means reminder prompts previous days work online database accumulate data entered various user may queried time process experimenters experiment range set feature developments chosen balance characteristics respect kind size complexity since order three four different process monitored developments able gather data sufficient representative kinds different software developed project 22 cost precision accuracy experiment incurs minor overhead first already email general logins machines part development environment second sampling tool already exists part change management environment requires minor modifications make applicable approach needed experiment finally training use modified tool small tool known understood selfdocumenting training instead focused clarifying process tasks states consider precision sampling granularity granularity tradeoff cost accuracy hourly data would give us detailed understanding process consider finegrained particularly feature development processes last longer days moreover often data sampled intrusive sampling becomes thus daily sampling rate seems useful initial compromise several problems regard accuracy data gathering first typical problems sampling compared gathering complete data however expect problems lessened large set samples gather second people often multiple tasks concurrently multiple things course workday however ameliorated fact monitor per feature development differentiate effort developer working several features concurrently blocking category assignments differentiate developer things working feature furthermore assume developers really one two things per day per process time overly fragmented 23 repeatability reproducibility ideally developer give response tool identical nearly similar progress lack made believe achieve sufficient level repeatability experiment following reasons first language used categories explanations developers wellunderstood fact designed process engineers also developers second close monitoring interaction training users early stages experiment finally restrict number categories seven plus minus two minimize possible discrimination variance miller56 equally ideally different developers within development provide sample path obviously true stochastic process variances among sample paths queueing network example blocking vary depending whether expert available phone vacation however expected value sense see behavior another factor contributing variance experiment low level maturity processes involved variance comes continuous tinkering process either explicitly management implicitly developers improvise less welldefined understood parts process 3 prototype experiment need three things prototype experiment process development set analyses process selected wellunderstood one standard development process advantages straightforward experimenters understand process well developers unlikely misinterpret experimental results development selected relatively large feature development two reasons first thought would able reconstruct fairly accurate data second felt large complex feature would stress experiment way inherent problems would see analyses selected set basic views data consider blocked working states process first discuss process development analyses prototype next discuss results analyses effect structure experiment finally consider costs prototype experiment 31 prototyped process development analyses initially characterized process terms fifteen tasks eleven states states represent binary choice either making progress waiting within two choices four seven states respectively table 1 lists initial tasks states blank line delineating two sets state choices used log books personal diaries project management notebooks reconstruct set data represent one developers experience selected process benefits obvious data reflects actual experience project primary disadvantage temporal averaging results loss clarity acuity disadvantage reason using reconstruction primary means gaining insight process note reconstruction however provide useful means forming hypotheses relevant processes reconstructed set data decided basic set analyses provide us insight prototyped development process distributions feature development tasks time distribution states time level blocking task breakdown work rework task point plot tasks time point plot states time first two analyses represent results use evaluate prototype remaining analyses represent results use form conjectures eventual results experiment 32 prototype evaluation figure 2 shows percentages time spent task life development weekend data originally included might times people worked weekends case however weekend data contained nothing useful served skew relationships tasks hence figure 2 represents data excluding weekends note unassigned category dominates time spent 6 percentages time spent state life development also shown figure 2 weekend data skewed relationships removed note wait oth state overwhelmingly dominant points weakness characterization process needs corrected initial thought collapse several lightly populated states one encompassing state example fold waiting laboratory hardware software waiting resources fold waiting experts documentation waiting information however discussions development management convinced us categories needed remain distinct since lessening individual effects requires interactions different organizations instead corrected part experimental design dividing states trinary choice rather binary one working making progress blocked waiting make progress several large blocks time wait oth category spent training vacation holidays working assignments thus 6 people specifically unassigned particular feature development make available respond unanticipated requests customers system refined design extending states reduce amount unspecified ways spending time process table 2 illustrates way extended states binary choice trinary one additional states represent third choice working process either working another development attending training going vacation representing lack effort due weekend note wait state intended serve primarily safety net prototype experiment subsequent experiments emphasis primarily progress lack progress 7 state categorizations necessity incomplete since wish keep number within easily managed bound subsequent experimentation may necessitate refinement category process used well understood wellestablished problems deriving appropriate set tasks however processes welldefined aspect may important part prototyping effort 33 cost prototype prototype effort took four personmonths effort approximately 2 weeks spent reconstructing development data remainder time spent analyzing data discussing analyses developers development management reviewing task state structures representative developers consider level effort cost effective experiment involve variety feature developments period several years 4 hypotheses prototyped development process present analyses prototype following caveats first reconstructed development data represents one sample path process one instance process second accuracy data open question retrospective nature information undoubtedly lost lapse time task state categorizations judgments may accurate loss information none less present consistent experience software developers suggestive software development processes general figure 3 shows relationship time spent productively time spent waiting almost every case time spend waiting exceeds productive work also note 60 time spent waiting rather productive may well factors consider seems clear one important way improving process reduce significantly number days blocking states utility conjecture depends degree multiplexing within processes clearly global level blocking consonant local level conjecture hold time spent productively approximately 27 total process time spent working reworking process approximately 13 time spent writing rewriting documentation figure 4 delineates relative amounts time spent making progress one third much time spent reworking process working one half much time spent rewriting documentation spent initially rewriting rework rewriting reduced basic cost evolutionary software development reduced factors contribute rework rewriting eliminated thing note integration figures 2 3 blocking tends prevalent beginning end process figure 5 illustrates blocking relationships various tasks process indicating relative weight task much time spent task well weight blocking factors much time spent waiting middle process low level design test planning coding tend interrupted waiting factors one hand particularly surprising clearly one attack blocking factors requirements high level design high level test phases process since heavily weighted interesting see conjecture represented graph holds wide variety developments figures 6a 6b represent early part development indicate task state respectively day worth noting first part development almost pure waterfall process moving first plan development task requirements certainly interesting fact holds large class processes developments important question source linearization second thing worth noting lengthy blocking times phase process particular note time spent waiting reviews four seven days row surprisingly waiting reviews dominated beginning end process relatively infrequent middle important factor wait oth category dominates even review category 7 also note emphasis progress versus lack progress categorization states possible example one might want probe deeper kinds progress made forms discovery necessary making progress etc figures 7a 7b representing later part process however show completely different overall process various tasks intermixed alternating four five different tasks various blocking factors intermixed well none taking three days order one two days reflects kind process would expect kind guindon shown prevalent work design process guindon90 reiterate caveat data real data reconstructed data one instance process blurring accuracy retrospection feel however intriguing conjectures feature development processes hope validate subsequent experiments 5 conclusion taken simple approach gaining information existing feature development processes sampling daily basis activities performed people executing process disadvantages sampling approach cost effective unintrusive yields fairly accurate precise information process actually performed people involved also provided formal context experiment considering software development example queueing network illustrate appropriateness model provided familiar example part development process given experiment longterm effort existing mechanism place monitoring software processes claim necessary prototype experiment prototype precondition major investment effort part feature development teams resources squandered used carefully reconstructed data provide immediate feedback design instrumentation increase understanding experiment sampled process last least prototype means motivation illustration accomplished company spend money people spend time process monitoring experiments part prototype experiment illustrated interesting ways analyze data refined experimental categories particular process example ignore weekend state refine blocking state conclude prototyping often necessary auxiliary step largescale longterm development effort prototyping necessary step development largescale longterm process monitoring experiment expectations experimentation obtain extremely useful data feature development processes conjectures based reconstructed data validated results significantly conclusive prototyped results experiments range multiple instances monitored processes multiple features carefully mixed size kind complexity acknowledgements thank al barshefsky dave fredericks wen lin unflagging effort coordinating experiment within development process teams todd livesey rich feich support willingness adapt sampling tool muerl smith insight blocking factors relationship organizational politics ward whitt help queueing network model finally careful readings earlier versions paper r managing flow technology modeling concurrency rulebased development environments methodology collecting valid software engineering data tame project towards improvementoriented software environments software engineering laboratory operational software experience factory iteration software process designing design process exploiting opportunistic thoughts statemate working environment development complex reactive systems managing software process support software process software process modeling support management planning control magic number seven plus minus two limits capacity processing information estimating average production intervals using inventory measurements littles law partially observable processes experience software process models policydirected coordination cooperation discussions process virtual machine working group modeling articulation work software engineering processes metricdriven analysis feedback systems enabling empirically guided software development foundations arcadia environment architecture representing enacting software process software process software environments study software process capture analysis tr estimating average production intervals using inventory measurements littles law partially observable processes statemate working environment development complex reactive systems managing software process foundations arcadia environment architecture representing enacting software process software engineering laboratory people organizations process improvement metricdriven analysis feedback systems enabling empirically guided software development experience software process models modeling concurrency rulebased development environments ctr austen rainer empirical investigation software project schedulebehaviour empirical software engineering v5 n1 p7577 march 2000 jonathan e cook lawrence g votta alexander l wolf costeffective analysis inplace software processes ieee transactions software engineering v24 n8 p650663 august 1998 wenqian liu charles l chen vidya lakshminarayanan dewayne e perry design evidence based soft research acm sigsoft software engineering notes v30 n4 july 2005 sanyih hwang wanshiou yang discovery process models instances decision support systems v34 n1 p4157 december 2002 karl reed ernesto damiani gabriele gianini alberto colombo agile management uncertain requirements via generalizations case study proceedings 2004 workshop quantitative techniques software agile process p4045 november 0505 2004 newport beach california cmpan flavio oquendo omega language system online monitoring softwareintensive processes acm sigsoft software engineering notes v25 n4 p6268 july 2000 jonathan e cook alexander l wolf automating process discovery eventdata analysis proceedings 17th international conference software engineering p7382 april 2428 1995 seattle washington united states jonathan e cook alexander l wolf software process validation quantitatively measuring correspondence process model acm transactions software engineering methodology tosem v8 n2 p147176 april 1999 jonathan e cook alexander l wolf discovering models software processes eventbased data acm transactions software engineering methodology tosem v7 n3 p215249 july 1998
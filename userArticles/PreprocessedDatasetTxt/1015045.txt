performance group key agreement protocols group key agreement fundamental building block secure peer group communication systems several group key management techniques proposed last decade assuming existence underlying group communication infrastructure provide reliable ordered message delivery well group membership information despite analysis implementation deployment techniques actual costs associated group key management poorly understood far resulted undesirable tendency one hand adopting suboptimal security reliable group communication hand constructing excessively costly group key management protocolsthis paper presents thorough performance evaluation five notable distributed key management techniques collaborative peer groups integrated reliable group communication system indepth comparison analysis five techniques presented based experimental results obtained actual local widearea networks extensive performance measurement experiments conducted methods offer insights scalability practicality furthermore analysis experimental results highlights several observations obvious theoretical analysis b introduction internet increasingly used support collaborative applications voice video conferencing whiteboards distributed simulations well games replicated servers databases types effective applications need supporting services reliable ordered message delivery well synchronization faulttolerance techniques reliable group communication system provide integrated platform containing services thus greatly simplifying application development process application complexity since communication internet involves traversal insecure networks basic security services data secrecy data integrity entity authentication necessary collaborative applications security services facilitated group members share common secret turn makes group key management fundamental service design challenge secure reliable group communication systems 11 key agreement peer groups several group key management approaches proposed last decade stress distinct multicast key management aims minimize costs key dissemination rekeying large singlesource multicast groups approaches generally fall three categories distributed contributory centralized group key management conceptually simple involves single entity small set generates distributes keys group members claim centralized group key management appropriate peer group communication since central key server must time continuously available present every possible subset group order support continued operation event arbitrary network partitions continuous availability addressed faulttolerance replication techniques unfortunately omnipresence issue impossible solve scalable efficient manner distributed group key management suitable peer group communication especially unreliable networks involves dynamically selecting group member acts key server although ro bust approach notable drawback requires key server maintain longterm pairwise secure channels current group members order distribute group keys consequently time new key server comes play significant costs must incurred set channels contrast contributory group key agreement requires group member contribute equal share common group key computed function members contributions approach avoids problems single points trust failure moreover contributory methods require establishment pairwise secret channels among group members expected cost group key management protocols largely determined two dominating factors communication computation typ ically efficiency one comes expense protocols distribute computation usually require communication rounds messages whereas protocols minimizing communication require computational effort 12 focus recent previous work 1 2 demonstrated provably secure multiround group key agreement protocols integrated reliable group communication system obtain provably faulttolerant group key agreement solutions specifically designed robust contributory key agreement protocol resilient sequence possibly cascaded events prove resulting protocol preserved group communication membership ordering guar antees protocol based group diffiehellman gdh ika3 contributory key agreement 3 generalizes twoparty diffiehellman 4 exchange paper focus performance key agreement protocols identified several notable protocols integrated reliable group communication system spread centralized key distribution ckd centralized key distribution scheme one member group dynamically chosen act key server tree based group diffiehellman tgdh combines tree structure diffiehellman key exchange algorithm achieve computationally efficient protocol gdh str trades less communication increased computation burmesterdesmedt bd dis tributesminimizes computation using mes sages protocols provide security properties similar gdh ika3 main contributions work group key agreement framework supports multiple protocols allows system assign different key agreement protocols different groups detailed comparison conceptual performance five key agreement protocols respect communication computation costs indepth analysis practical results obtained reallife experiments local wide area networks results provide insights protocols scalability practicality rest paper organized follows section overviews related work present secure spread secure group communication system give brief description key agreement protocols supports section 4 next analyze conceptual costs protocols present performance results finally summarize work identify possible directions future work related work section summarize related work two areas group key management reliable group communication 21 group key management indicated focus work performance group key management protocols collaborative peer groups therefore consider distributed key distribution contributory key agreement protocols looking available protocols concerned mostly cost performance types group key management operations occur often might seem first glance typical collaborative group scenario group forms exists time dissolves true would need consider performance initial key agreement leading groups mation moreover performance would great concern since protocol would run infrequently order rekey group ever typical collaborative group formed incrementally population mutate throughout lifetime either members join leave network connectivity changes begin protocol proposed steer et al 5 aimed teleconferencing seen later wellsuited adding new members takes two rounds two modular exponentiations member exclusion rekeying following member leave event however relatively inefficient burmester desmedt 6 proposed efficient protocol takes two rounds three modular exponentiations per member generate group key protocol allows members recompute group key membership change constant cpu cost however requires 2n broadcast messages expensive wide area network tzeng tzeng proposed authenticated key agreement scheme based secure multiparty computation 7 protocol uses two communication rounds round consists n simultaneous broadcast mes sages although cryptographic mechanisms quite elegant main shortcoming lack perfect forward secrecy pfs steiner et al addressed dynamic membership issues 3 group key agreement part developing family group diffie hellman gdh protocols based straightforward extensions twoparty diffiehellman protocol gdh protocols relatively efficient member leave group partition operations merge protocol requires number rounds equal number new merging members followon work kim et al yielded treebased diffiehellman tgdh protocol efficient gdh communication computation 8 contrast contributory group key agreement schemes distributed group key distribution scheme proposed 1 9 10 little done performance analysis peer group key management one exception recent work carman kruus matt 11 compares via simulation different group key agreement protocols ad hoc sensor network setting based power consumption 22 reliable group communication reliable group communication systems lans solid history beginning isis 12 followed recent systems transis 13 horus 14 totem 15 rmp 16 systems explored several different models group communication virtual synchrony 17 extended virtual synchrony 18 recent work area focuses scaling group membership widearea networks 19 20 research securing group communication fairly new implementations group communication systems focus security aside securering 21 project ucsb ho rusensemble work cornell 22 23 24 rampart system att 25 securering system protects lowlevel ring protocol using cryptographic techniques authenticate transmission token data message received ensemble security architecture stateof theart secure reliable group communication addresses problems group keys rekeying also allows applicationdependent trust models optimizes certain aspects group key generation distribution protocols comparison ap proach ensemble uses different group key structure contributory provides different set security guarantees recent research bimodal multicast gossipbased protocols 26 sp inglass system largely focused increasing scalability stability reliable group communication services hostile environments widearea lossy networks providing probabilistic guarantees delivery reliability group membership rampart 25 first system providing atomic reliable services model servers get corrupted system builds group multicast protocols secure group membership protocol antigone umich 27 framework aimed provide mechanisms allow flexible application security policies antigone addresses four policy aspects rekeying policy defines events trigger rekey membership awareness policy determines availability accuracy membership informa tion process failure policy defines type failures supported system available means recovery access control policy spec ifies rights potentially responsibilities group members system implements group rekeying mechanisms two flavors session rekeying group members receive new key session distribution session leader transmits existing session key 3 secure spread framework work presented paper evolved integrating security services spread widearea group communication system specifically multiple agreement protocols integrated resulting secure spread library building blocks implementation uses key agreement primitives provided cliques group key agreement library section overview spread group communication system cliques toolkit secure library 31 spread group communication system spread 28 29 30 group communication system wide local area networks provides reliability ordering messages fifo causal total ordering membership service toolkit supports two different semantics extended virtual synchrony 18 31 view synchrony 32 33 paper implementation use view synchrony semantics spread system consists daemon library linked application architecture many benefits important widearea settings ability pay minimum possible price different causes group membership changes simple join leave process translates single message daemon disconnection connection requires full membership change process daemon memberships correspond model lightweight heavyweight groups 34 spread operates manytomany communication paradigm member group sender receiver designed support small medium groups accommodate large number different collaboration sessions spans internet achieved using unicast messages widearea network routing spread nodes overlay network spread scales well number groups used application without imposing overhead network routers group naming addressing shared resource ip multicast addressing rather large space strings unique collaboration session spread toolkit publicly available wwwspreadorg used several organizations research practical settings toolkit supports crossplatform applications ported several unix platforms well windows java environments 32 cliques library cliques cryptographic toolkit implements number key agreement protocols dynamic peer groups toolkit assumes existence reliable communication platform transports protocol messages provides ordering messages deals group membership management performs computations required achieve shared key group current implementation built atop popular openssl library currently cliques includes five group key agreement protocols gdh ckd tgdh str bd briefly mentioned discussed detail section 4 gdh protocol based group extensions twoparty diffiehellman key exchange 3 provides fully contributory authenticated key agreement gdh fairly computationintensive requiring cryptographic operations upon key change however bandwidthefficient ckd centralized key distribution key server dynamically chosen among group members key server uses pairwise diffiehellman key exchange distribute keys ckd comparable gdh terms computation bandwidth costs tgdh combines binary key tree structure group diffiehellman technique 8 tgdh seems efficient terms computation membership changes require olog n cryptographic operations str 35 form tgdh socalled skinny imbalanced tree based protocol steer et al 5 str efficient protocols terms communication whereas computation costs subtractive group events comparable gdh ckd bd protocol proposed burmesterdesmedt 6 another variation group diffiehellman bd computationefficient requiring constant number exponentiations upon membership group key change however communication costs significant protocols cliques library provide key independence perfect forward secrecy pfs formally key independence means passive adversary knows proper subset group keys cannot discover future previous group key pfs means compromise members longterm key cannot lead compromise shortterm group keys outside intruders passive active considered cliques model entity current group member considered outsider 1 attacks coming inside group considered focus secrecy group keys integrity group membership consequently insider attacks relevant context since malicious insider always reveal group key andor private thus allowing fraudulent membership authentication protocols proven secure respect passive outside eavesdropping attacks 3 8 35 6 active outsider attacks consist injecting deleting delaying modifying protocol messages attacks aim cause denial service address attacks goal impersonating group member prevented use public key signatures since every protocol message signed sender verified ceivers subtle active attacks aim introduce known attacker old key prevented combined use timestamps unique protocol message identifiers sequence numbers identify particular protocol run 33 secure spread library secure spread 36 2 library along reliable ordered message dissemination former future member also outsider according definition membership services spread client library provides security services data confidentiality integrity main added functionality secure spread follows whenever group membership changes secure spread detects initiates execution group key agreement protocol detects termination key agreement protocol notifies application membership change new key addition secure spread encrypts decrypts user data using group key group operational one major consideration designing library modularity flexibility secure spread currently supports five key agreement protocols bd ckd gdh str tgdh described detail low architecture secure spread allows handle different key agreement algorithms different groups client member different groups group key agreement protocol 4 key agreement protocols secure spread section present key agreement protocols currently supported secure spread subject performance evaluation protocols designed accommodate different membership changes join new member leave member network partition network merge due lack space provide description merge partition multiple members leave since join leave seen special cases merge partition respectively 41 gdh protocol cliques gdh ika3 contributory key agreement protocol essentially extension protocol gdh merge assume k members added group size n protocol runs follows generates new exponent n 0 n unicasts message n1 merging member generates exponent n nj computes n nj forwards result nj1 upon receipt accumulated value broadcasts entire group 2 upon receipt broadcast every member sends back nk 3 collecting responses nk generates new exponent n nk produces set broadcasts group step k4 upon receipt broadcast every member computes key n nk figure 1 gdh merge protocol twoparty diffiehellman protocol basic idea shared key never transmitted net work instead list partial keys used individual members compute group secret sent one member group group controller charged task building distributing list controller fixed special security privileges protocol works follows merge event occurs see figure 1 current group controller generates new key token refreshing contribution group key passes token one new members new member receives token adds contribution passes token next new member 2 eventually token reaches last new member new member slated become new group controller broadcasts token group without adding con tribution upon receiving broadcast token group member old new factors contribution unicasts result called factorout token new group controller new group controller collects factorout tokens adds contribution builds list partial keys broadcasts group every member obtain group key factoring contribution members leave group figure 2 group controller times recent remaining group member removes corresponding partial keys list partial keys refreshes partial key list broadcasts list group remaining member compute shared key note current group controller leaves last remaining member becomes group controller group 2 new member list ordering decided underlying group communication system spread case actual order irrelevant gdh protocol gdh leave assume set l members leaving group size n protocol runs follows 1 controller generates new exponent produces set 2 lg broadcasts remaining group step 2 upon receipt every remaining member computes key figure 2 gdh leave protocol 42 ckd protocol ckd protocol simple centralized group key distribution scheme group key contributory always generated one member namely current group controller 3 group controller establishes separate secure channel current group member using authenticated twoparty diffiehellman key exchange key stays unchanged long parties controller member remain group controller always oldest member group whenever group membership changes group controller generates new secret distributes group using longterm pairwise key see figure 3 case merge controller addi tion establishes secure channel new mem ber partition occurs ie multiple members leave controller also discards longterm key shared leaving member special case case group controller leaves group case oldest remaining member becomes new group controller distributing new key new group controller must first estab 3 use term current mean even ckd protocol suite controller fail partitioned thus causing controller role reassigned oldest surviving member protocol ckd assume k members added group size n 1 group controller protocol runs follows selection performed step 2 j 2 1 k nj selects random r nj mod q 3 1 selects random group secret k computes step 4 broadcast message every member compute group key figure 3 ckd merge protocol lish secure channels remaining group members 43 tgdh protocol tgdh adaptation key trees 37 38 context fully distributed contributory group key agreement tgdh computes group key derived contributions group members using binary tree tree organized following manner node hl vi associated key k hlvi corresponding blinded key bk key root node group key shared members key leaf node random session contribution group member leaf node associated group member every member knows keys path leaf node root well blinded keys key tree basic idea every member compute group key blinded keys key tree known group membership event every member unambiguously adds removes nodes related event invalidates keys blinded keys related affected nodes special group member sponsor takes role compute keys blinded keys broadcast key tree 4 group sponsor could compute group key next sponsor comes play eventually sponsor compute group key blinded keys broadcast entire key tree facilitate computation group key members group round 1 request merge groups round 2 update tree 0 get b broadcast figure 4 tgdh merge protocol current members new members new intermediate node sponsor sponsor tree 5 figure 5 tgdh merge operation merge event happens see figure 4 sponsor rightmost member group broadcasts tree information merging subgroup refreshing session random blinded keys upon receiving message members uniquely independently determine merge position 4 keys never broadcasted two trees 5 described keys blinded keys path merge point root node invalidated rightmost member subtree rooted merge point becomes sponsor key update operation sponsor computes keys blinded keys broadcasts tree blinded keys members members complete set blinded allows compute keys path figure 5 shows example merge protocol members 6 7 added group consisting members protocol tgdh partition protocol runs follows round 1 h get b figure 6 tgdh partition protocol sponsor sponsor sponsor sponsor figure 7 tgdh partition operation following partition protocol runs follows see figure 6 first round remaining member updates view tree deleting leaf nodes associated partitioned members cursively respective parent nodes prevent reuse old group key one remaining mem 5 heuristic choose joining node rightmost shallowest node increase height details see 8 bers changes key share end first protocol round shallowest rightmost sponsor changes share sponsor computes keys blinded keys far tree possible broadcasts set new blinded keys upon receiving broadcast member checks whether message contains new blinded key procedure iterates members obtain group key figure 7 shows partition example members 1 4 removed group 44 str protocol str basically extreme version tgdh key tree structure completely imbalanced stretched protocol features described details 35 like tgdh str protocol uses tree structure associates leaves individual random session contributions group members every internal nonleaf node associated secret key public blinded key secret key result diffiehellman key agreement nodes two children group key key associated root node br r br r br r br3 r br 4 r br6k bk 6 6k r brk br 77 r brk bk br 5r k br bk figure 8 str merge operation merge protocol runs two rounds first round two sponsors topmost members right children respective root nodes tree exchange respective key trees containing blinded keys refreshing session random computing keys blinded keys root node highestnumbered member larger tree becomes sponsor second round merge protocol see figure 8 using blinded session random group sponsor computes every key blinded key pair intermediate node root node broadcasts key tree blinded keys blinded session random members members complete set blinded keys allows compute new group key r br r br r br r br r br r br r k br bk figure 9 str partition operation partition sponsor lowestnumbered remaining member deleting leaving nodes see figure 9 sponsor refreshes session ran dom computes keys blinded keys tree terminating root key broadcasts updated tree containing blinded values member compute group key 45 bd protocol unlike protocols discussed thus far burmesterdesmedt bd protocol 6 independent type group membership change sponsors controllers members charged special duties main idea bd distribute computation among members member performs three exponentiations achieved using two communication rounds consisting n broadcasts figure 10 depicts actual protocol protocol bd assume group n mem bers protocol membership changes identical thus separately present join leave scenarios key computed result protocol protocol runs follows step 1 member selects random r mod q computes multicasts message group step 2 member receiving z 1 z i1 computes multicasts group step 3 member j receiving j computes mod p figure 10 bd protocol 5 theoretical evaluation section analyze conceptual costs five protocols presented first evaluate time compute new group key membership change occurs four events lead change membership first two determined actions initiated users new user wants become member group current member leaves group refer events join leave respectively note latter also happen one member gets disconnected simply crashes another category membership change events related connectivity network unreliable network split disjoint components communication possible within component components members one component appears rest members left network fault heals members previously components communicate group perspective appears collection new members added group refer events partition merge respectively conceptual perspective interested two cost aspects cost communication num ber rounds number type messages cost computation number exponentiations signatures verifications although cost communication modern highspeed lan setting appear negligible comparison cost say modular exponentiations discuss nonetheless since becomes meaningful lans protocols trade low computation high communication costs course communication cost important highdelay networks eg wans distributed nature group communication sys tems consider serial cost computation 6 thus stress number cryptographic operations expressed table protocol sum total participants table 1 summarizes communication computation costs five protocols numbers current group members merging members leaving members denoted n p respectively height key tree constructed tgdh protocol denoted h 7 actual cost 6 computation needs processed strictly serial computation processed parallel collapsed accordingly 7 instead fully balancing key tree tgdh uses besteffort tries balance key tree upon additive event height key tree however smaller 2 log n maximum group size n 8 tree better balanced using avl tree management technique described 23 however incur higher communication cost leave communication computation rounds messages unicast multicast exponentiations signatures verifications gdh join leave merge partition tgdh leave partition h 2h 0 2h 3h h h str leave partition merge bd leave merge partition ckd leave merge 3 partition table 1 communication computation costs tgdh protocol depends tree height bal ancedness key tree insertion point joining tree node locations leaving nodes err side safety compute worst case cost tgdh number modular exponentiations str upon leave event determined location deepest leaving node therefore compute average cost ie case nth node left group protocols except tgdh str show exact cost numbers current implementations tgdh str recompute blinded key even though computed already sponsor provides form key confirmation since user receives token another member check whether blinded key computation correct computation ever removed better efficiency consider optimization counting number operation exponentiations bd protocol hidden cost reflected table 1 step 3 see figure 10 bd protocol n 1 modular exponentiations small exponent though single exponentiation takes negligible amount time sum n 1 exponentiations negligible example requires 373 1024bit modular multiplications modular exponentiation implemented square andmultiply algorithm openssl uses montgomery reduction sliding window algorithm implement modular exponentiation faster simple squareandmultiply algorithm however former requires almost time latter small exponent hidden cost difficult compare computational overhead bd protocols join protocols except ckd require two communication rounds ckd uses three rounds new member must first establish secure channel via diffiehellman key exchange current group controller expensive protocol terms communication bd uses n broadcast messages round protocols use constant number messages either two three gdh ckd expensive terms computation requiring linear number exponentiations relative group size tgdh comparatively efficient scaling logarithmically number exponentiations str turn uses constant number modular exponentiations bd requires least modular exponentiations hidden cost leave table 1 shows leave event bd protocol expensive communication point view cost order ckd gdh str tgdh determined strictly computation cost since communication cost one round consisting one mes sage therefore tgdh best handling leave events str gdh ckd scale linearly group size note cost ckd actually higher one listed table 1 case controller leaves group new group controller must establish secure channels group members since bd hidden cost hard compare algorithms merge first look communication cost note gdh scales linearly number members added group communication rounds bd ckd str tgdh efficient using constant number rounds since bd uses n messages round ckd uses sages str tgdh communication efficient handling merge events looking computation costs seems bd lowest cost three exponentiations ever impact number small exponent exponentiations difficult evaluate tgdh scales logarithmically group size efficient str ckd gdh scale linearly group size number new members added group partition table 1 shows gdh str ckd protocols bandwidth efficient one round consisting one message bd less efficient two rounds n messages partition expensive operation tgdh requiring number rounds bounded tree height computationwise difficult compare bd protocols hidden cost step 3 tgdh requires logarithmic number exponentiations gdh str ckd scale linearly group size 6 experimental results section present compare evaluate experimental costs five protocols discussed mentioned earlier four events cause group change join leave partition merge results reflect two common events join leave measure total elapsed time moment group membership event happens moment group key agreement finished application notified group change new key time includes communication computation costs key agreement protocol well cost membership service provide group communication system words represents actual delay experienced application user using secure spread group communication system performs join leave operation group time msec group size members join dh 512 bits bd ckd gdh str tgdh time msec group size members join dh 1024 bits bd ckd gdh str tgdh membership service figure 11 join average time lan50150250350450 time msec group size members leave dh 512 bits bd ckd gdh str tgdh membership service100300500700 time msec group size members leave dh 1024 bits bd ckd gdh str tgdh membership service figure 12 leave average time lan 61 experimental results lan section present compare evaluate performance five protocols discussed local area network setting 611 testbed basic parameters experimental testbed cluster thirteen 666 mhz pentium iii dualprocessor pcs running linux machine runs spread daemon group members uniformly distributed thirteen chines therefore one process running single machine frequent many collaborative applications tests performed testbed show average cost sending delivering one agreed multicast message almost constant ranging anywhere 075 milliseconds 092 milliseconds group size ranging 2 50 members also scenario similar bd round member group sends broadcast message receives n 1 messages rest members n group size average cost 2 milliseconds group 2 members 21 milliseconds group size 50 cost membership service see figures 11 12 negligible respect key agreement overhead varying 2 8 milliseconds group 2 50 members use rsa signatures message origin data authentication although cliques toolkit supports digital signature scheme implemented openssl library rsa signature verification quite inexpensive group key agreement protocols described paper rely heavily source authentication ie protocol messages must verified receivers processes located different cpu platforms verification performed parallel practice however cpu may multiple group processes expensive signature verification eg dsa noticeably degrades performance used 1024bit rsa signatures public exponent 3 reduce verification overhead although quasistandard rsa parameter selection 65 537 1 security risks using 3 public exponent rsa signature scheme 39 2 bd gdh require n simultaneous signature verifications 3 current topol ogy machines multiple group member processes hardware platform rsa sign verify operations take 96 02 milliseconds respectively 8 shortterm group key use 512 1024bit diffiehellman parameter p 160bit q cost single exponentiation 17 53 milliseconds 512 1024bit modulus respectively 612 test scenarios protocol peculiar features took account keeping experiments similar simple possible 8 surprising since openssl uses chinese remainder theorem speed rsa signatures gdh bd oblivious insofar cost position joining leaving member ie leave join operations cost protocols ckd expensive leave event leaving member current group controller take account factoring 1n probability group controller leaving group since theoretical cost leave str average cost tested average case happens member leaving group n2th member located middle str key tree tgdh difficult protocol evaluate cost depends location leave join node tree height balancedness tree truly fair comparison secure spread must first run tgdh long time random sequence joins leaves order generate randomlooking tree experiments join leave must conducted random tree however tests difficult perform mentioned therefore chose simpler experimental setting measuring join leave costs artificially balanced tgdh key tree n members note random tree cost join less expensive since member joined closer root leave expensive still less expensive gdh 8 613 join results figure 11 shows total average time group establish secure membership following join new member graph left 512bit modulus looks overall str outperforms protocols closer inspection reveals bd actually efficient small group sizes less 7 recall bd involves three fullblown exponentiations opposed strs seven however bd str 3 furthermore bd requires log n modular multiplications step 3 compute key see figure 10 finally bd two rounds alltoall broad casts small group size makes factors neg ligible however group size grows bd deteriorates rapidly since modular multiplications rsa signature verifications broadcasts add fact passing group size thirty bd becomes worst performer diffiehellman parameter 512 1024bit modulus gdh worst due sharp increase modular exponentiation another interesting observation bds performance measurements cost roughly doubles group size grows increments 13 recall 13 number machines used experiments bd fully symmetric soon one machine starts running one additional group member process cost bd dou bles moreover noted starting group size 26 performance degrades signifi cantly mentioned machines used dual processors group size 26 assumed one client one processor protocols behavior less obvious since costly tasks performed single member controller sponsor graph right 1024bit modulus show deterioration bd remains best small groups 14 members cost exponentiations rises sharply 512 1024 bits cost rsa signature verifications broadcasts weighs bd 512bit case felt nearly much graphs tgdh str fairly close latter performing slightly better although numbers table 1 show constant cost str measured cost increases slightly 1 cpu may experience increasing number processes number members increases 2 minor overhead factors tree management con ceptually tgdh never outperform str join since latters design includes optimal case ie join root former experimental results however show tgdh sometimes outperform str see small dips tgdh graph around 34 members members fully balanced tgdh tree compute two modular exponentiations last protocol round opposed four str difference ckd gdh comes exponentiation signature verifications extra operations gdh include n verifications one rsa signature one dh modular exponentiation gdh bd n mentioned relatively expensive even 512bit rsa modulus 614 leave results figure 12 shows average time group establish secure membership upon member leave event line conceptual evaluation tgdh outperforms rest requires fewest olog n modular exponentiations sublinear behavior becomes particularly evident past group size 30 note random tree although leave expensive less expensive leave gdh protocol 8 bd worst 512bit leave recall leave join incur cost str ckd gdh exhibit linear increase cost ckd gdh quite close strs linear factor 2n makes slope steeper case 1024bit modulus str expensive protocol since involves costlier 1024 512bit case modular exponentiations tgdh exhibits cost roughly twice 512bit case information communications university korea university california irvine usa john hopkins university usa hardware broadcast milliseconds millisecondsmilliseconds jhu uci icu figure 13 wan testbed remains leader bd however longer worst least small group sizes less 37 performs close better gdh attribute relatively cheap cost rsa signature verifications commensurately small number fullblown 1024bit exponentiations bd 62 experimental results wan extreme case section present preliminary results wan environment highdelays lan experiments focused evaluating total time needed perform join leave operation moment group membership changes due join leave member till moment new key computed delivered members group time includes communication computation costs key agreement protocol well cost membership service group communication system 621 testbed basic parameters figure 13 presents network configuration used experiments wan achieve computation distribution lan experiments used experimental testbed thirteen pcs running linux ten 666 mhz pentium iii dualprocessor pcs one 11 mhz athlon one 930 mhz pentium iii pcs located fol lows first eleven machines johns hopkins university jhu maryland one machine university california irvine uci one information communications university icu korea uniformly distributed group members among thirteen machines one group member process running single machine machine runs spread daemon approximate roundtrip latencies ping times reported ping program jhu uci 70 milliseconds uci icu 300 milliseconds icu jhu 270 milliseconds average delay sending delivering one agreed multicast message depends senders lo cation actual delay milliseconds sender jhu 392 sender uci 328 sender icu 334 group member sends broadcast message waits receive n 1 messages rest group similar bd communication round average cost 1000 milliseconds group size 50 important notice lan setting cost group membership service provided underlying group communication system negligible respect key agreement overhead eg 7 milliseconds vs hundreds milliseconds ever relative cost becomes significantly higher wan setting cost membership service seen figure 14 varies 400 670 milliseconds join operation 250 650 leave operation group 2 50 members lan experiments used rsa 1024 bit public exponent 3 compute message signatures test pcs rsa sign verify operations take 69 179 02 04 milliseconds respectively depending platform shortterm group key use 512bit diffiehellman parameter p 160bit q 9 cost single modular exponentiation 08 17 milliseconds 622 join results figure 14 left presents results average time required establish secure group membership new member joins group graph also separately plots cost insecure group membership service difference total time required protocol insecure group membership service cost represents overhead key agreement communication computation first observation gdh protocol performs significantly worse others main difference gdh protocols comes communication first number rounds greater protocols shown table 1 gdh requires 4 rounds others require 2 rounds second different factor comes round members factor contribution send result group controller see section 41 although theoretically seen one round n unicast messages correctness robustness key agreement protocol messages need agreed order respect messages sent within group raises cost message cost agreed broadcast message lastly members controller sending group controller needs receive process n 1 messages increases cost even conclusion cost factor message round expensive theoretical analysis shows big impact performance protocol behavior less obvious lan setup communica 9 intend include results 1024bit diffiehellman final submission tion cost general much smaller computation overhead rest protocols less range bd becoming expensive group size bigger 30 str tgdh show similar performance interesting notice str tgdh come closer bd per formance also communication aspect protocols stated table 1 sections 44 43 str tgdh 2 rounds first round consists two simultane ous broadcasts implementation broadcasts simultaneous since achieve ordered delivery messages group communication systems use mechanism token passed participants entity token allowed send particular wan setup three main sites jhu uci icu cost passing token inside site significantly smaller cost sites cost str tgdh scenario 2 members sending two broadcasts members need receive close cost bd scenario n members broadcast members need receive n 1 messages deteriorates faster protocols due number broadcast messages though ckd three rounds two involve singlemessage unicasts helps ckd remain competitive respect protocols clearly conclude communication costs number rounds numbers messages sent one round group key agreement scheme affects severely performance wide area net work particularly one highdelays one used experiments one member missed token needs wait token pass whole ring bd scenario token completes cycle matter started everybody succeeds send time msec group size members join dh 512 bits bd ckd gdh str tgdh membership service50015002500 time msec group size members leave dh 512 bits bd ckd gdh str tgdh membership service figure 14 join leave average time wan 623 leave results case leave see figure 14 right bd expensive protocol wan setup due two rounds n broadcasts high computational cost gdh ckd tgdh require single broad cast thus exhibit similar performance results although str also requires one broadcast significantly higher computation cost respect rest observe tgdh exhibits behavior dynamic gdh ckd attribute fact ckd gdh controller bulk computation broadcasts running fixed machine whereas tgdh sponsor also computation broadcasts running 13 testbed machines tested fixed sponsor suspect tgdh gdh ckd would almost identical cost number rounds seems important factor performance protocols investigated extreme wan network 63 discussion following experiments interpretation discussed conclude computation cost important low delay network communication cost important high delay network lan setting tgdh best performing protocol overall however also note small groups greater say dozen members bd slightly better performer another factor bds favor simplicity operations symmetric implemented via protocol data structures manage contrast tgdh involves nontrivial tree management see 8 de tails additional factor skew comparable performance evaluated protocols tgdhwas evaluated wellbalanced tree random unbal anced tree join cost would less expensive since joining node would inserted nearer root node leave cost would expensive less expensive gdh 8 highdelay wan setting tgdh ckd exhibited best performance since tgdh smaller computation overhead expect outperform ckd medium delay wide area network 70 100 milliseconds roundtrip links conclude tgdh best choice key agreement protocol dynamic peer groups local wide area networks 7 conclusions future work presented framework cost evaluation group key agreement protocols realistic network setting focus five notable group key agreement protocols integrated reliable group communication system spread analyzing protocols conceptual costs measured behavior lan wan settings particular presented discussed measurements elapsed time required process two common group membership change events join leave results presented indicate tgdh protocol work best environments items remain future work experimenting protocols mediumdelay eg 70 100 milliseconds roundtrip wide area network interest since communication computation costs expected equalize least theory fi nally also need experiment complex group operations partition merge acknowledgements authors would like thank dang nguyen duc taekyoung kwon providing machines used evaluation tests r secure group communication asynchronous networks failures integration experiments exploring robustness group key agreement key agreement dynamic peer groups new directions cryptography secure audio teleconference sys tem secure efficient conference key distribution system roundefficient conferencekey agreement protocols provable security simple faulttolerant key agreement dynamic collaborative groups optimized group rekey group communication systems disec distributed framework scalable secure manytomany communication constraints approaches distributed sensor network security reliable distributed computing isis toolkit transis communication subsystem high availability ho rus flexible group communication system totem singlering ordering membership protocol high performance totally ordered multicast pro tocol exploiting virtual synchrony distributed systems extended virtual synchrony scalable group membership services novel applications clientserver oriented algorithm virtually synchronous group membership wans securering protocols securing group communication ensemble security using avl trees fault tolerant group key manage ment architecture performance security protocols ensemble group communication system secure agreement protocols reliable atomic group multicast ram part bimodal multicast antigone flexible framework secure group communication spread wide area group communication system low la tency loss tolerant architecture protocol wide area group communication flow control manytomany multicast costbenefit approach replication using group communication partitioned network specifying using partitionable group communication service partitionable virtual synchrony using extended virtual synchrony reliable multicast framework lightweight sessions application level fram ing communicationefficient group key agree ment exploring robustness group key agreement key management multicast issues architec tures key establishment large dynamic groups using oneway function trees twenty years attacks rsa cryptosystem tr exploiting virtual synchrony distributed systems secure audio teleconference system secure agreement protocols totem singlering ordering membership protocol horus specifying using partitionable group communication service reliable multicast framework lightweight sessions application level framing secure group communications using key graphs simple faulttolerant key agreement dynamic collaborative groups key agreement dynamic peer groups method obtaining digital signatures publickey cryptosystems architecture performance security protocols ensemble group communication system provably authenticated group diffiehellman key exchange communicationefficient group key agreement handbook applied cryptography reliable distributed computing isis toolkit roundefficient conference key agreement protocols provable security provably authenticated group diffiehellman key exchange dynamic case high performance totally ordered multicast protocol enhancing survivability security services using redundanc decision diffiehellman problem key establishment large dynamic groups using oneway function trees securering protocols securing group communication clientserver oriented algorithm virtually synchronous group membership wans performance group key agreement protocols exploring robustness group key agreement kronos group key agreement secure group communication using robust contributory key agreement treebased group key agreement highperformance secure group communication ctr xinliang zheng chintser huang manton matthews chinese remainder theorem based group key management proceedings 45th annual southeast regional conference march 2324 2007 winstonsalem north carolina ioannis chatzigiannakis elisavet konstantinou vasiliki liagkou paul spirakis design analysis performance evaluation group key establishment wireless sensor networks electronic notes theoretical computer science entcs v171 n1 p1731 april 2007 shanyu zheng david manz jim alvesfoss communicationcomputation efficient group key algorithm large dynamic groups computer networks international journal computer telecommunications networking v51 n1 p6993 17 january 2007 yair amir cristina nitarotaru jonathan stanton gene tsudik secure spread integrated architecture secure group communication ieee transactions dependable secure computing v2 n3 p248261 july 2005
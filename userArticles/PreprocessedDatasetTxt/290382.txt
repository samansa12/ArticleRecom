mixedmode bist using embedded processors complex systems embedded processors may used run software routines test pattern generation response evaluation system components completely random pattern testable test programs generate deterministic patterns random testing usually random test part program requires long run times whereas part deterministic testing high memory requirementsin paper shown appropriate selection random pattern test method significantly reduce memory requirements deterministic part new highly efficient scheme softwarebased random pattern testing proposed shown extend scheme deterministic test pattern generation entire test scheme may also used implementing scan based bist hardware b introduction integrating complex systems single chips implementing multichip modules mcms become widespread approach variety embedded processors embedded coreware found market allows appropriately split system functionality hardware software modules development however system testing become enormous challenge complexity restricted accessibility hardware components require sophisticated test strategies builtin selftest combined ieee 1149 standards help tackle problem low costs 10 conventional asic testing number powerful bist techniques developed past 1 3 5 example shown combining random efficiently encoded deterministic patterns provide complete fault coverage work supported dfg grant test und synthese schneller eingebetteter systeme wu 24512 keeping costs extra bist hardware storage requirements low 13 14 32 case embedded systems high quality test possible without extra hardware using embedded processor generate tests components usually kind functional testing requires large test programs memory space always available system paper shown small test programs synthesized complete coverage nonredundant stuckat faults combinational parts system obtained costs extra bist hardware conventional systems testing reduced costs hundred bytes system memory store test routines proposed bist approach efficiently exploit designfortestability structures subcomponents shown figure 1 serial bist embedded processor executes program generates test patterns shifts scan regis ters components tested even effi ciently presented approach may used generate test data input registers pipelined combinational subsystems embedded processor scan input scan output scan input scan output test data random deterministic patterns figure 1 serial bist approach structure test program kept sim ple random patterns generated since elementary processor instructions used 12 21 25 28 even linear feedback shift register lfsr emulated efficiently figure 2 shows example modular lfsr corresponding program simplicity ccode shown generate fixed number state transitions void transition int int n unsigned int polynomial unsigned int state transitions modular lfsr degree n int i0 im state n1 state state polynomial else state figure 2 modular lfsr corresponding program generating state transitions usually subcomponents system random pattern testable remaining faults deterministic test patterns applied pur pose compact test sets may generated described 16 18 22 27 reproduced test program hardwarebased deterministic bist scheme emulated test software 13 15 32 kind mixedmode testing may interleave deterministic random testing perform successively case storage requirements deterministic part test program directly related number undetected faults random pattern generation great tradeoff runtime random test memory requirements mixedmode program assume small improvement random test method leads increase fault coverage 992 996 reduces number undetected faults storage requirements factor 12 overall efficiency mixedmode test scheme improved much higher degree modifying random part rather deterministic part paper highly efficient softwarebased random bist scheme presented also used generating deterministic patterns rest paper organized follows next section different random pattern test schemes emulated software evaluated section 3 extension deterministic testing described subsequently section 4 procedure optimizing overall bist scheme presented section 5 describes procedure generating mixedmode test program finally section 6 gives experimental results based intel 80960ca processor example emulated random pattern test test routines exploiting arithmetic functions processor produce patterns properties sufficient testing random pattern testable circuits 12 25 even completely satisfy conditions randomness stated 11 eg however circuits particular circuits considered random pattern resistant arithmetic patterns may perform well linear feedback shift registers lfsrs corresponding primitive feedback polynomials cellular automata generally considered stimuli generators good properties random testing 9 17 20 generated sequences still show linear dependen cies different primitive polynomials perform differently circuit cases linear dependencies may support fault detection circuits perform poorly following fault coverage obtained several lfsrbased pattern generation schemes discussed experimental data 21 feedback polynomial contrast hardwarebased bist softwarebased approach number positions feedback taps lfsr impact costs bist im plementation thus given length achievable fault coverage optimized without cost constraints assuming test per scan scheme shown figure 3 sensitivity fault coverage selected feedback polynomial studied series experiments combinational parts iscas85 iscas89 benchmark circuits 4 6 lfsr feedback scan path cut figure 3 scanbased bist circuit pi f degree lfsr1 lfsr2 lfsr3 lfsr4 lfsr5 lfsr6 average table 1 absolute normalized w r worst lfsr percentage undetected nonredundant faults 10000 patterns fault simulation 10000 random patterns performed circuit using several different feedback polynomials degree typical results shown table 1 first four columns contain circuit name number inputs number nonredundant faults selected degree feedback polynomial 1 remaining columns show characteristics six different lfsrs first entry reports percentage undetected nonredundant faults second entry normalizes number corresponding number worst lfsr worst best performing lfsr printed bold respectively last column gives average lfsrs observed big variance performance different lfsrs degree s641 eg best lfsr reduces number undetected faults 27 faults left undetected worst polynomial 22 multiplepolynomial lfsrs one explanation considerable differences fault coverage observed section 21 given fact linear dependencies scan positions may prevent certain necessary bit combinations scan patterns independent initial state lfsr 2 different lfsrs distribution linear dependencies scan chain different depending structure circuit may different impact fault coverage shown figure 4 impact linear dependencies reduced several polynomials used small example lfsr operate according two dif 1 degrees polynomials selected compatible requirements deterministic test described section 3 ferent primitive feedback polynomials p selected input multiplexer given initial state lfsr produces scan pattern 0 7 depending selected polynomial shown equations hold components st0 st0 0 1 2 3 4 5 6 7 u figure 4 scanbased bist multiplepolynomial lfsr polynomial p 0 linear relation 3 prevents combination 1 1 1 inputs andgate implies polynomial p 0 x never produce test stuckat0 fault node 2 contrast polynomial input positions linearly independent produce possible nonzero bit combinations thus test considered fault similarly stuckat0 fault node 1 cannot tested using polynomial polynomial p 0 x provide test using polynomials certain number patterns increases chance detecting faults multiplepolynomial lfsr implemented efficiently hardware trying share parts feedback several polynomials software emulation also simple since basic procedure simulate lfsr modified slightly control selection feedback polynomials several schemes possible first shown figure 5 assuming n random patterns generated p different polynomials denotes lfsr operation corresponding feedback polynomial p initialize lfsr generate np patterns lfsrp figure 5 successive multiplepolynomial scheme suc polynomials applied successively generate contiguous subsequences np random patterns scheme therefore referred scheme suc one polynomial scheme degenerates conventional single polynomial scheme possibility switch different distributions linear dependencies paid disadvantage patterns may occur repeatedly p times hence overall increase fault coverage cannot expected experiments shown indeed improvement circuits table 2 lists results set circuits studied previous section circuit degree table 2 absolute normalized w r worst best single lfsr percentage undetected nonredundant faults scheme suc 10000 patterns circuit 10000 patterns simulated using p polynomials experiment percentage undetected nonredundant faults reported 1st line well corresponding normalized numbers worst 2nd line best single polynomial 3rd line degree applying successive scheme example circuit c2670 reduces number undetected faults 6958 compared worst single polynomial even important scheme also outperforms best single polynomial number remaining target faults atpg less 75 ie 25 percent faults left best single polynomial additionally covered scheme randomness sequence creased polynomials used successively selected randomly test pattern random selection implemented second lfsr shown figure 6 referred scheme rnd u feedback cut scan chain figure hardware scheme random selection feedback polynomials rnd selection p different feedback polynomials lfsr1 controlled log 2 p bits state register lfsr2 software implementation structure figure 6 two additional registers required storing feedback polynomial state lfsr2 lfsr2 emulated proce dure complete routine generate sequence n random patterns shown figure 7 initialize lfsr1 initialize lfsr2 select p based state lfsr2 generate 1 pattern lfsr1p perform 1 state transition lfsr2 figure 7 software routine random pattern generation scheme figure 6 rnd table 3 shows percentage undetected nonredundant faults corresponding normalized numbers obtained scheme rnd circuit degree table 3 absolute normalized w r worst best single lfsr percentage undetected nonredundant faults scheme rnd 10000 patterns randomly selected polynomials higher chance pattern repetitions randomly switching different distributions linear dependencies may improve quality patterns cir cuits results improvement fault coverage set faults remain deterministic testing reduced 2 3 multiplepolynomial multipleseed another way improving efficiency random test repeatedly storing new seed pattern generation investigated instance 23 technique combined use multiple polynomials shown figure 8 u feedback cut scan chain figure 8 multiplepolynomial multipleseed lfsr scheme rnd log 2 p bits state register lfsr2 used drive selection p different feedback polynomials degree k lfsr1 remaining k bits provide seed lfsr1 sequel scheme referred scheme rnd 2 structure corresponding test program shown figure 9 initialize lfsr2 select seed polynomial p based state lfsr2 initialize lfsr1 generate 1 pattern lfsr1p perform 1 state transition lfsr2 figure 9 test program multiplepolynomial multi pleseed lfsr rnd 2 scheme patterns may occur repeatedly addition advantage randomly changing distribution linear dependencies scheme also able generate zerovector often needed complete fault coverage table 4 gives results percentage undetected nonredundant faults corresponding normalized numbers tables 2 3 circuit degree table 4 absolute normalized w r worst best single lfsr percentage undetected nonredundant faults scheme rnd 2 10000 patterns expected circuits fault coverage increases circuits technique leads significant improvements circuits s8381 s9234 best results obtained compared experiments 3 softwarebased deterministic bist structure multiplepolynomial multipleseed random bist scheme figure 8 similar deterministic bist scheme based reseeding multiple polynomial lfsrs proposed 13 14 see figure 10 u cut scan chain bits id seed figure 10 deterministic bist scheme based multiple polynomial lfsr 14 deterministic pattern encoded polynomial identifier seed respective polynomial test mode pattern reproduced emulating lfsr corresponding polynomial identifier loading seed lfsr performing autonomous transitions lfsr mth transition scan chain contains desired pattern applied cut calculate encoding systems linear equations solved fixed feedback polynomial degree k lfsr produces output sequence i0 satisfying feedback equation k lfsrsequence compatible desired test pattern specified bits holds recursively applying feedback equation provides system linear equations seed variables 0 k1 solution found given polynomial next available polynomial tried 14 shown already 16 polynomials high probability success deterministic pattern specified bits encoded sbit seed hence p different polynomials available polynomial identifier implemented next bit seed next bits deterministic test set number specified bits max require bits storage minimizing st requires minimizing maximum number care bits max number patterns n 15 atpgalgorithm presented generates test patterns number specified bits max mini mized mixedmode bist approach number n patterns highly correlated number faults left undetected random testing 4 synthesizing bist scheme since efficiency mixedmode bist scheme strongly depends number hard faults covered deterministic patterns major concern synthesizing bist scheme optimizing random test experimental data section 2 show significant variances fault efficiency achieved different lfsr schemes exist universal scheme polynomial working circuits sequel procedure presented determining optimized lfsr scheme selection lfsrs guided fault efficiency maximized satisfying requirements efficient encoding deterministic patterns random pattern resistant faults assuming table primitive polynomials available proposed procedure consists 4 steps perform atpg eliminate redundant faults estimate maximum number specified bits max expected test cubes hard faults select polynomials degree max randomly perform fault simulation corresponding shift register sequences rank polynomials according fault coverage achieved select p best polynomials store highest fault coverage corresponding lfsr bestscheme using polynomials simulate schemes suc rnd rnd 2 update bestscheme best solution obtained far number mainly determined limit computing time spent number p also restricted computing time available addition lfsr requires two registers processor pattern generation register file target processor puts limit p table 5 shows results achieved procedure set circuits studied section 2 degrees used section 2 sequences 10000 random patterns applied scheme best uf worst table 5 best schemes relation best worst single polynomial solution second third column show best scheme corresponding number polynomials p column 4 provides fault efficiency fe percentage detected nonredundant faults percentage faults left undetected best scheme reported column uf uf best normalizes solution number obtained best single polynomial uf worst refers worst single polynomial table 5 indicates search appropriate random test scheme reduce number remaining faults significantly procedure needs runs fault simulations may decrease storage amount needed deterministic patterns considerably savings memory mixedmode test program particularly important test program stored rom startup maintenance test generating mixedmode test programs test programs implementing random test schemes reseeding scheme deterministic patterns generated intel 80960ca target processor large register set made compact coding possible since part test program generates deterministic patterns superset instructions required implementing random schemes example complex random scheme shown mixedmode test program figure 11 generates random test patterns multiplepolynomial multiple seed lfsr emulation switches reseeding scheme afterwards program figure 11 requires 27 words memory assumes lfsrs fit registers steps1 equ number steps lfsr1 steps2 equ number steps lfsr2 stepsdet equ number steps deterministic test len1 equ position msb lfsr1 len2 equ position msb lfsr2 testport equ address testport nopolybits equ number bits polynomial choice mask equ define mask start dq startvector define startvector lfsr2 poly dq polynomials define polynomials lfsr1 seeds dq seedvectors define seeds det test seedoffset equ seeds start define offset seed table begin lda testport r10 load address testport lda stepsdet r11 load loopcounter lfsr1 det mode lda steps1 r12 load loop counter lfsr1 lda start r14 load startvector address lfsr1 ld r14 r6 load startvector lfsr2 ld 4r14 r7 load polynomial lfsr2 l0 mov r6 r4 initialize lfsr1 contents lfsr2 mask r4 r15 compute polyid ld 8r14r154 r5 polynomial lfsr1 lda nopolybits r15 load number bits polyid l1 shro nopolybits r4 r4 shift polybits lda steps2 r13 load loop counter lfsr1 l2 st r4 r10 write testpattern testport mov r4 r8 shlo 1 r8 r4 shift left bbc len2 r8 l3 branch msb lfsr2 equal zero xor r4 r5 r4 xor decrement loop counter cmpibne r13 0 l2 branch equal zero mov r6 r8 shlo 1 r8 r6 shift left bbc len1 r8 l4 branch msb lfsr1 equal zero xor r6 r7 r6 xor l4 subi r12 1 r12 decrement loop counter cmpibg r12 r11 l0 branch r12 stepsdet ld seedoffsetr14r124r6 load seed cmpibne r120l0 figure 11 mixedmode bist program always possible random pattern generation encoding deterministic patterns may lead lfsr lengths exceeding bits case program figure 11 modified straightforward way requires memory table 6 gives relation memory requirements lfsr lengths lfsr length memory requirements words table length memory requirements mixedmode test program addition program size memory reserved storing polynomials seeds order decode deterministic patterns experimental results next section show data form far major part memory requirements 6 experimental results described strategy generating mixedmode test programs applied benchmark circuits e circuit 28 runs fault simulation performed determine best random scheme tables 7 8 show results circuit pi degree best scheme p table 7 circuit characteristics best random scheme selected random schemes characteristic data reported table 7 columns 2 3 list number primary inputs pi degree poly nomials best random scheme number polynomials reported subsequent columns table 8 shows detailed results number nonredundant faults circuit given column 2 efficiency random scheme characterized fault efficiency fe percentage undetected nonredundant faults uf normalized numbers uf respect best uf best average uf average single polynomial solution columns 3 6 circuit f fe uf uf best uf average s8381 931 7648 2352 711 6575 table 8 fault efficiency percentage undetected nonredundant faults best random schemes 10000 patterns reduction remaining faults obtained best random test scheme significant instance circuit c7552 known random pattern resis tant single polynomial solution average leads fault efficiency 9579 leaving 421 faults deterministic encoding circuit rnd 2 scheme achieves fault efficiency 9887 113 absolutely 84 faults left corresponds reduction remaining faults 27 circuits s820 s1423 careful selection random scheme even makes deterministic test super fluous finally noted larger cir cuits already small relative reduction means considerable number faults additionally covered random test need considered deterministic test example circuit s38417 reduction 8575 9226 respectively means additional 313 158 respectively faults eliminated random test table 9 shows resulting number test patterns required random pattern resistant faults amount test date storage bits best random scheme compared random test using average single polynomial includes storage needed poly nomials initial lfsr states random test encoded deterministic test set since goal work determine impact random test test data storage standard atpg tool selected perform experiments 24 circuits fault efficiency 100 deterministic test circuit deterministic patterns test data storage bits scheme average polynomial scheme average polynomial s4201 22 34 503 776 s1238 7 21 198 431 s5378 22 31 759 883 table 9 number deterministic patterns storage requirements complete test data bits results show optimized random test fact considerably reduces number deterministic patterns overall test data storage particularly true circuits known random pattern resistant eg circuit c7552 number deterministic patterns reduced 92 51 reduction test data storage 5k circuit s38417 best scheme eliminates 137 deterministic patterns leads reduction test data storage 14k shown table already standard atpg proposed technique requires less test data storage approach based storing compact test set cf 16 18 22 27 circuit deterministic patterns test data storage bits scheme compact test scheme compact test s4201 22 43 503 1505 s5378 22 104 759 22256 table 10 amount test data storage proposed approach storing compact test set expected test data storage presented approach could reduced even atpg tool specially tailored encoding scheme used described 15 7 conclusion scheme generating mixedmode test programs embedded processors presented test program uses new highly efficient random test schemes new softwarebased encoding deterministic patterns shown careful selection primitive polynomials lfsrbased random pattern generation strong impact number undetected faults multiplepolynomial random pattern scheme provides significantly better results many cases quality 0of random scheme main impact overall size mixedmode test program example processor intel 80960ca test programs generated benchmark circuits complete coverage nonredundant faults obtained r test embedding builtin selftest environment exhaustive generation bit patterns applications vlsi selftesting neutral netlist 10 combinational benchmark designs special translator combinational profiles sequential benchmark circuits new pattern biasing technique bist bist hardware generator mixed test scheme multichip module selftest provides means test speed shift register sequences test generation based arithmetic operations generation vector patterns reseeding multiplepolynomial linear feedback shift registers pattern generation deterministic bist scheme compaction test sets based symbolic fault simulation cellular automatabased pseudorandom number generators builtin selftest costeffective generation minimal test sets stuckat faults combinational logic circuits accumulator builtin self test highlevel synthesis rotco reverse order test compaction technique multiple seed linear feedback shift register advanced automatic test generation redundancy identification techniques synthesis mapping logic generating transformed pseudorandom patterns bist minimal test sets combinational circuits circuits pseudoexhaus tive test pattern generation test using unequiprobable random patterns multiple distributions biased random test patterns decompression test data using variablelength seed lfsrs tr ctr sybille hellebrand huaguo liang hansjoachim wunderlich mixed mode bist scheme based reseeding folding counters journal electronic testing theory applications v17 n34 p341349 juneaugust 2001 huaguo liang sybille hellebrand hansjoachim wunderlich twodimensional test data compression scanbased deterministic bist journal electronic testing theory applications v18 n2 p159170 april 2002 rainer dorsch hansjoachim wunderlich reusing scan chains test pattern decompression journal electronic testing theory applications v18 n2 p231240 april 2002 liang huaguo sybille hellebrand hansjoachim wunderlich mixedmode bist scheme based folding compression journal computer science technology v17 n2 p203212 march 2002
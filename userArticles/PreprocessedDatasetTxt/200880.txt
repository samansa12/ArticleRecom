designing programs check work program correctness checker algorithm checking output computation given program instance program run checker certifies whether output program instance correct paper defines concept program checker designs program checkers specific carefully chosen problems class fp functions computable polynomial time problems fp checkers presented paper include sorting matrix rank gcd also applies methods modern cryptography especially idea probabilistic interactive proof design program checkers group theoretic computationstwo structural theorems proven one characterization problems checked theorem establishes equivalence classes problems whenever one problem class checkable problems class checkable b introduction paper introduce concept program checker program checker program p program c instance program p run c run subsequently c either certifies program p correct declares p buggy methods proposed gaining confidence output programs example program verification9 seeks achieve proving program correct program verification suffers problem hard prove programs correct also argued proofs correctness programs improve confidence correctness nature proofs13 recent discussion role verification software development see 3 program testing12 run program test inputs output known see program output matches expected output testing fairly ad hoc technique general methods generating test data theorems proven behavior program passes tests addition work theoretical computer science community concept helping27 35 may regarded deterministic version checking program checking easier verification yields mathematical proofs program behavior unlike testing allows cointossing greatly enhancing power checker comparison model helping ideas paper arise cryptography probabilistic algorithms program testing particularly important work interactive proofs goldwasser micali rackoff19 subsequent related work seen several correctness checkers constructed paper use probabilistic interactive proofs first step design equally important work papers randomized algorithms rabin33 freivalds16 latter remarkably enough includes excellent program checkers integer polynomial matrix multi plication works budd angluin10 weyuker38 relevant seek give program testing rigorous mathematical basis notion program checking used paper first formally defined blum kannan6 paper draws heavily 6 6 concept program checking defined checkers exhibited grouptheoretic problems selected problems p class problems polynomialtime checkers characterized since several papers shed light problem blum luby rubinfeld7 extend notion program checking one step several directions focus large collection numerical problems includes integer multiplication modular multiplication problems show possible detect errors programs also correct errors programs mostly correct also provide efficient tests determining whether program mostly correct process results yield program testers provable performance program passes selftest la 7 instances size n possible prove theorem says high probability p correct instances size n precisely quantified another concept introduced 7 library programs allows checker one problem library call programs problems library long programs library checked means extension allows design efficient simple checkers problems hitherto much complex checkers adleman huang kompella1 provide checkers several numbertheoretic problems including integer greatest common divisor 6 conjectured efficient checker gcd would hard find lipton29 considers programs tested way ensure mostly correct shows one correct errors program transforming given instance several random instances computing answer given instance answers random instances lipton29 building work beaver feigenbaum4 shows polynomials general permanent particular amenable technique rubinfeld34 extends notion checking parallel checking blum et al8 extend programs store retrieve data unreliable memory kannan yao24 considered problem checking cointossing programs produce specified output probability distributions several concepts complexity theory intimately related checking two concepts coherence randomselfreducibility concepts considered extensively literature definitions concepts relation program checking found example 5 14 rest paper organized follows formal description program checking model given section 2 section 3 illustrate concept prototypical example graph isomorphism problem section 4 derive structural theorems allow us derive checkers one problem checkers others section 5 present program checkers grouptheoretic problems section demonstrates close connections design program checkers design interactive proofs section 6 present checkers number common functions computed fp specific problems considered extended gcd sorting matrix rank finally section 7 characterize class problems polynomialtime checkers checkers let denote computational decision search problem x input let x denote output let p deterministic program supposedly halts instances say program p bug instance x p x 6 x define efficient program checker c problem follows c p probabilistic expectedpolytime oracle turing machine satisfies following conditions program supposedly halts instances instance positive integer k socalled security parameter presented unary 1 p bugs ie p instances x probability 2 p 6 probability probability computed sample space finite sequences coin flips c could tossed remarks order running time c includes whatever time takes c submit inputs receive outputs p excludes time takes p computations ii definition p bugs p gives correct output input c p may output correct buggy assumed program p problem halts instances done order help focus problem hand general however programs always halt definition bug must extended cover programming errors slow program cause diverge altogether case definition program checker must also extended require additional condition 3 p x exceeds precomputed bound phix running time value x submitted checker oracle program checker sound warning namely c p remainder paper assumed program p problem halts instances condition 3 everywhere suppressed possible extend notion program checking probabilistic algorithms bpp order simply run program sufficiently often make probability error correct program much smaller 12 k simply treat program though deterministic program check accordingly rest paper consider deterministic programs assurance results checkers deterministic programs extended checkers probabilistic programs approach program correctness question naturally arises one cannot sure program correct one sure checker correct serious problem one solution prove checker correct sometimes easier proving original program correct case extended gcd checker section 6 another possibility try make checker extent independent program checks end make following definition say probabilistic program checker c little oh property respect program p expected running time c little oh running time p shall generally require checker little oh property respect program checks principal reason ensure checker programmed differently program checks instance two programs problem running times definition disallows checker running one check desire checker however definition necessarily constrain us design efficient checkers although running time checker little oh programs running time account time spent calls program checker made one call program running checker would result increase asymptotic running time program general hard achieve significant subclass problems ones considered 7 one design checkers run time worse constant times running time program checked taking account time spent running program checked 3 example graph isomorphism present example good checker checker adaptation goldreich micali interactive proof system graph isomorphism see 18 model 18 relies existence allpowerful prover prover replaced program checked power program turns sufficient simulate prover application checker results practical way check computer programs graph isomorphism graph isomorphism problem lot heuristics work instances appending checker heuristic gives us confidence output possibly unproven heuristic graph isomorphism decision problem defined follows graph isomorphism gi input two graphs g h output yes g isomorphic h otherwise checker c p checks program p input graphs g h begin compute p g h yes use p bugfree search isomorphism g h done standard selfreduction hoffmann22 pages 2427 check whether resulting correspondence isomorphism return buggy yes return correct p g h times toss fair coin generate random permutation g 0 g compute p g g 0 return buggy generate random permutation h 0 h compute enddo return correct end program checker correctly checks computer program whatsoever purported solve graph isomorphism problem even bizarre program designed fool checker caught run input causes output incorrect answer following theorem proves formally theorem 31 p correct program graph isomorphism c p gi always outputs correct p g h incorrect probc p gi outputs correct 1 moreover c p gi runs polynomial time gi runs polynomial time way counting running time checker p bugs g isomorphic h c p constructs isomorphism g h correctly outputs correct p bugs g isomorphic h c p coins discovers outputs correct p g h incorrect two cases 1 p g h yes g isomorphic h c p gi fails construct isomorphism since none exists correctly outputs buggy 2 p g h g isomorphic h way c return correct p g g 0 orh 0 yes whenever coin comes heads comes tails g isomorphic h since g h permuted randomly produce g 0 h 0 g 0 h 0 probability distributions therefore p correctly distinguishes g 0 chance ie 1 2 k possible sequences coin tosses 4 beigels theorem following theorem due richard beigel theorem 41 beigel let two polynomialtime equivalent decision problems polynomial time checker 1 possible construct polynomialtime checker proof simplicity assume initially 1 2 decision problems reducible karp reductions checker c 1 1 program p 2 2 also two way polynomialtime transformations f 12 f 21 going 1 2 2 1 respectively existence f 12 gives us program p 1 1 defined terms f 12 p 2 p 1 x defined p 2 f 12 x way counting running time checker checking program p 2 call p 1 accomplished polynomial time since f 12 polynomialtime function call p 2 counts 1 step check p 2 instance compute p 2 transform instance z 1 using function f 21 use checker c 1 check correctness p 1 z call checker makes p 1 including call instance z transformed polynomial time call p 2 procedure described convinced correctness p 1 z convinces us correctness p 2 p 2 correct p 1 defined terms p 2 thus checker find p 1 correct z convincing us p 2 correct p 2 wrong two cases p 1 correct z discover contradiction immediately p 1 wrong z checker c 1 designed catch precisely situation declare p 1 buggy thereby convinced bugginess p 2 checker 2 described runs polynomial time let n length instance 2 checked running time checker 2 broken following three components ffl running time checker 1 instance whose length polynomial n ffl one application transformation f 21 input length n ffl polynomial number applications transformation f 12 inputs whose lengths polynomial n show theorem holds even problems possibly search problems reductions problems cook reductions case also program p 1 defined terms p 2 proof correctness checker essentially follows along lines proof case karp reductions details check program make polynomially many calls p 2 input transformation f 12 replaced program takes instance 1 polynomial time produces set instances 2 queried also transformation f 21 one particular application beigels theorem graph isomorphism since graph isomorphism known polynomialtime checker problems polynomialtime equivalent graph isomorphism also checkers important note statement beigels theorem requires equivalence 1 2 following example suggests reduction one direction sufficient observe group isomorphism gi reduces extended group isomorphism egi 1 groups given multiplication tables 2 gi differs egi yes answer former explicit isomorphism latter know efficient checker egi gi 41 generalizing beigels theorem let f complexity class let 1 2 problems reducible f suppose checker 1 f conditions give us checker 2 f consider situation f deterministic time complexity class situation similar replace time complexity circuit size circuit depth time complexity classes nc n time complexity function suppose algorithm whose running time bounded fn inputs length n puts problem f call f time complexity function f call complexity class f robust two time complexity functions f g f time complexity functions f words f robust class sum product composition two time complexity functions f time complexity function f examples robust time complexity classes include p log o1 n theorem 42 let f robust time complexity class 1 2 two problems reducible f c 1 checker 1 f checker c 2 2 f proof sketch checker c 2 constructed along lines checker constructed beigels theorem running time analysis note definition robustness precisely one needed guarantee c 2 lies f uses fact algorithm running time fn make fn calls oracle program checked produce outputs transformed instances whose lengths bounded fn input length n thus running time checker 2 bounded sums products compositions running times two reductions checker 1 true even case reductions problems cook reductions corollary 41 1 2 equivalent ncreductions 1 ncchecker 2 proof although nc time complexity class proof follows robustness class nc complexity function nc thought ordered pair functions depthn sizen function class p depthn function log o1 n sums products compositions complexity functions computed componentwise ordered pair representing function since arguments theorem robustness time complexity class holds depth size well robustness classes p log o1 n establishes robustness complexity functions nc turn implies checker 2 nc 42 nccheckers problems p using generalized version beigels theorem prove pcomplete problems checkers nc theorem 43 p complete problems checkers nc proof light generalized version beigels theorem sufficient prove pcomplete problem checker nc pcomplete problems nc reducible particular pcomplete problem provide ncchecker lexicographically first maximal independent set lfmis 11 problem 43 ncchecker lfmis lexicographically first maximal independent set lfmis input graph g vertices numbered 1 n vertex v graph output yes lfmis contains vertex v lfmis present ncchecker informally algorithm pram details pram model see instance 26 step 1 th processor asks whether v lfmis thus processors determine lfmis step 2 step associated vertex group n processors th group processors associated v assume answers obtained step 1 queries correct assumption check see answer query v correct done o1 time since v lfmis iff edge v smaller numbered vertex lfmis thus crcw pram model checker runs o1 time uses 2 proces sors step 2 carefully allows us reduce processor count already mentioned finding nc checker lfmis gives us nccheckers pcomplete problems interesting prove difficult problems p checkers nc although dont know whether decision problems p checkers nc nccheckers pcomplete problems big open question whether npcomplete problems checkers p fact negative evidence question15 5 checkers group theoretic problems many group theoretic problems checkers resembling graph isomorphism subsection 51 shows two fairly general classes examples 52 gives general approach checker construction works particularly well group theoretic problems work group theoretic problems group theory rich source problems checkers elementary properties groups lagranges theorem often exploited design checkers structure groups often implies relationships among correct answers different instances relationships used check consistency programs sometimes consistency checks proven sufficient ensuring correctness program instance checker graph isomorphism described introduction viewed group theoretic checker since problem graph isomorphism polynomialtime equivalent problem determining automorphism group graph31 graph isomorphism essentially check consistency program case program says input graphs g h isomorphic structure problem implies 1 g random permutation g isomorphic 2 g isomorphic h g isomorphic random permutation h 0 h computation used extensively tool group theory fact classification finite simple groups21 motivated aided computer calculations classification shown 26 groups belong infinite family groups 26 groups referred sporadic groups existence sporadic groups confirmed computer construction reasons checking group theoretic problems fruitful endeavour 51 equivalence search canonical element problems problems corresponding checkers described subsection stated terms set elements group g acting b define jg b g let esp g denote equivalence search problem otherwise proposition 51 let esp g equivalence search problem given g suppose exists efficient probabilistic algorithm find random g 2 g according uniform distribution efficient program checker c p problem esp g examples equivalence search problem include graph isomorphism quadratic residuosity generalization discrete log games rubics cube examples arise knot theory block designs codes matrices gf q latin squares 28 page 32 applications burnside polya theorems32 related equivalence search problem equivalence decision problem defined equivalence decision problem edp instance question jg b would nontrivial prove similar proposition edp esp seem reducible edp following argument indicates recall n positive integer z n denotes group positive integers less n relatively prime n group operation multiplication mod n p prime let action g 2 g 2 maps g mod p observe jg b b g mod p g z suppose given oracle factoring find g b g mod p essentially solve discrete log problem cryptographic circles believed solvable polynomial time even given oracle factoring hand edp solvable polynomial time given oracle factoring proof consists showing mod p g orderbjordera x exactly ordera solutions namely finally ordera orderb determined factorization p gamma 1 canonical element problem cep input 2 output c g c unique canonical element equivalence class g 2 g proposition 52 efficient program checker canonical element problem provided probabilistic procedure select random g 2 g efficiently remark cep program fail two canonical elements class define true canonical element class unique element half elements class mapped program 52 group intersection problem use twostep approach designing checker group intersection first design interactive proof system show interactive proof system converted checker babai moran2 independently earlier provided interactive proof system group intersection use checker group intersection beigels trick obtain checkers several problems known polynomially equivalent group intersection first briefly discuss various representations groups computer three common representations used increasing order difficulty manipulation multiplication table representation permutation group representation abstract group representation multiplication table representation explicitly specifies product pair group elements permutation representation group thought acting set group elements permutations group operation composition usually group specified specifying polynomially many size set generating permutations abstract group representation group presented generators related relations specified amongst relations implied specified relations hold generators completely specifies group describe checker group intersection problem following group intersection problem input two permutation groups g h specified generators output generators g h let n size set g h act general specification generating set g n bits done polyn bits hence take input length n probabilistic polynomialtime algorithm known solving group intersection problem surprising since graph isomorphism polynomialtime reducible group intersection following interactive proof protocol works group intersection 521 ip protocol 1 prover sends verifier set permutations supposedly generate 2 verifier checks elements sent prover actually lie g h involves testing membership g h verifier methods 17 consequence verifier convinced elements sent prover either generate proper subgroup 3 verifier sends prover element 2 gh obtains selecting random elements multiplying together 4 prover sends back factorization 0 b 0 0 2 g b 0 2 h 5 verifier checks gamma1 0 element group generated generators prover provided step 1 theorem 51 protocol steps 35 repeated k times allows prover 12 k probability cheating verifier proof denote group generated generators prover sends step 1 clear step 2 g h steps 3 4 aimed giving verifier random element g h following lemma effect lemma 51 notation protocol gamma1 0 random element g h ab 2 g b 2 h x thus two factorizations element recovered computing gamma1 0 x thus x unique factorization along remains proved every pair factorizations correspond element g h suppose two factorizations ab rearranging gamma1 left hand side last equation element g right hand side element h since equal elements must belong g h randomness factorization ab implies randomness element g h obtained procedure since prover know factorization ab used verifier proof lemma 51 essentially completes proof theorem use lagranges theorem note proper subgroup g h random element g h belongs probability half performing k repetitions steps 35 reduces error probability 12 k 522 converting ip protocol checker verifier protocol asks prover factor certain elements gh convert ip protocol checker one must show program group intersection used factor elements gh factorization search problem fsp shown equivalent group intersection problem one could use program group intersection factor fsp following problem factorization search problem input two permutation groups g h permutation output gh 2 g b 2 h ab otherwise associated factorization decision problem fdp known equivalent group pages 236241 following lemma shows equivalence fsp fdp lemma 52 fdp equivalent fsp proof obvious fdp reduces fsp remains shown fsp reduces fdp proof relies notion strong generators introduced 17 assume strong generators g h defined furst hopcroft luks17 assumed without loss generality set generators converted set strong generators polynomial time brief description notion strong generators mg group g mg size permutation domain matrix entries diagonal diagonal position ij entry permutation g fixes pointwise elements moves j case permutation exists ij th entry permutation g convenient customary make diagonal entries identity permutation properties representation given without proof every element g expressed unique way product n row mg using convention string permutations leftmost one acts first rightmost one last consequence previous fact jgj product numbers nonempty entries row mg another consequence random element g obtained multiplying together random elements rows mg also g 1 subgroup g fixes point 1 generated entries rows 2 n mg finally membership g permutation oe tested follows oe moves 1 j look position 1j entry none exists oe g otherwise 1 entry oe 1 fixes point 1 move second row check membership g 1 proceeding thus either find oe g find expression oe product entries mg suppose gh consider h 1 subgroup h consisting permutations fix point 1 since gh ab g b h also b equal product oe n oe th row mh thus permutation oe 1 first row mh aboe 1 gh 1 use oracle fdp find entry first row mh property entry oe 1 consider oe 1 factor gh 1 factorization gh 1 yield factorization gh seen technique applied recursively yields factorization gh completes reduction shows ip protocol described converted checker 6 problems fp section program checkers use oracle determine several times cases instead program checker denoted c p denoted c k latter notation advantage clarifying must tested cases checker nonprobabilistic denoted c instead many problems fp efficient program checkers challenge find follows give fairly complete description program checkers three problems one oldest nontrivial algorithms books sorting one frequently solved problems matrix rank unusual seems require multicall checker twosided error 61 extended gcd problem integer gcd given two integers b find gcd b adleman huang kompella1 recently given probabilistic checker problem extension problem makes easy check idea extending problem without incurring additional running time solve extended problem important one area program checking extended gcd input two integers b output integer integers u v check gcd checker perform 5 arithmetic operations ffl check divides b validity check obvious definition gcd point convinced divisor b ffl check b done three arithmetic operations justify check show two checks convince us gcd refer following standard lemma lemma 61 let b positive integers smallest positive integer expressed integer combination b gcd 62 sorting hardly necessary mention sorting one commonly solved problems computer science large number algorithms available sorting fairly complex program thus necessary check output sorting programs sorting trivially checked comparison tree model model inputs output given ordering input variables permutation oe output x checker sorting confirm output inequalities valid done using fact using linear number operations reasonable model computation general assume outputs point inputs came check sorting merely checking outputs right order ram model computation easy check sorting linear time ram reflect many sorting scenarios define problem sorting provide reasonable model computation sorting input array integers x x representing multiset output array consisting elements x listed nondecreasing order model computation computer fixed number tapes including one contains x another contains x n elements element range 0a random access memory olog nlog words memory words capable holding integer range 0a particular word hold element ffl single precision operations gamma theta take one step denotes integer divide ffl multiprecision operations gamma steps integers words long steps addition machine usual operations shift tape copy word tape ram vice versa takes 1 step model computation described easy check output list order steps need also check multisets done probabilistically steps right method depends relative sizes n n 2 simple bucket sort works need buckets numbers range 0 since log n random access memory space enough buckets thus could run values x put one appropriate bucket could run elements take one appropriate bucket time bucket try take value turns empty checker declares program buggy situation interesting case present following two methods checking multiset equality method 1 method specific important choice hash function first suggested wegman carter39 compute check jy select x 6 probability least 12 sums differ see remove x largest submultiset elements common resulting x still size intersection empty compute two sums equal setting hx 1 1 distinguish x sums different setting hx 1 0 distinguish two either case h probability 12 distinguishing two sets since random function requires enormous number random bits replace random function h suitably chosen hash function choosing easy compute hash function difficult wegmancarter hash function particular requires random access memory hence cannot implemented model computation different hash function work recall select random prime p interval 1 3 delta delta log set indeed primes p x 6 pointed karp rabin25 least half primes interval 1 3deltaa delta log choice interval size arises estimate large get since sum n terms term bounded sum bigger n delta since bound sum a1 interval chosen suitable constant times log a1 thus 25 shows primes randomly chosen interval 1 3 delta delta log hash function probability least 12 catching error method 2 idea first suggested lipton29 recently ravi kannan23 multisets iff g since f g polynomials degree n either n gamma 1 values z probabilistic algorithm decide selecting k values random set 2n possibilities say 12n comparing fz gz k values computations kept reasonable size arithmetic operations modulo randomly chosen small primes computation product fz term bounded absolute value 2n hence product bounded according 25 primes chosen approximately range 1 n loga compare two methods show regardless relative values n one method always run time log n comparison methods 1 2 recall multiset n integers range 0a also recall n 2 bucket sort used check computation since word sizes model olog n 2 primes method 1 fit constant number words number words w required hold prime method 2 omax1 log n log running time method 1 log need perform log multiplications compute constant time operations since prime moduli constant number words long running time method 2 function number words w equal nw 2 since n multiplications performed numbers w words long overriding cost method 2 describe transition one method another decreasing function n use bucket sort n becomes less 2 long n log log n use method 1 running time log instance could use method 1 long n greater log log threshold value n log n log log log log hence log olog n n dips threshold primes method 2 fit log log words method 2 runs time onlog log 2 notice typical case sorting n case method 2 runs linear time thus algebraic finagling mainly prove existence little oh checker relative values n 63 checking matrix rank subsection describe checker matrix rank checker rank mainly theoretical interest satisfies little oh property required however makes 2 calls program checked hence would highly inefficient implement practice blum luby rubinfeld7 subsequently discovered practical checker matrix rank however checker conform original definition checking instead use idea program matrix multiplication checked checking rank one call matrix multiplication program count call one step consider matrices whose entries drawn finite field f let p program takes matrix input outputs integer r supposedly rank describe checker p checker given integer k unary k desired confidence checkers output ie probability checkers wrong o12 k describe checker three parts first part checker produces r x r submatrix supposedly full rank process selfreduction using program obtain intermediate answers part 2 checker checks resulting r x r matrix indeed full rank incidentally proves rank original matrix least r finally also need ensure rank r done part 3 checker 631 selfreduction let n x matrix input p suppose p outputs r let u um columns delete u feed resulting matrix p p says rank endfor number columns remaining 6 r return selfreduction obtained r column vectors supposedly linearly independent r columns nvector selfreduction rows n x r matrix arrive r x r matrix supposedly full rank course want take programs word matrix full rank need check matrix actually full rank thus even program returned wrong answers course selfreduction detect declare program bad done part 2 checker 632 lower bounding rank r x r matrix full rank columns matrix form basis f r case every vector f r unique representation linear combination column vectors matrix part checker exploit uniqueness representation r columns r x r matrix supposedly full rank idea create k linear combinations x r columns matrix suppose example toss fair coin comes heads subtract c 1 v 1 x 1 otherwise choose random 6 c 1 f subtract av 1 x 1 expect x basis x clearly true v form basis suppose v form basis let v j first v nonzero coefficient dependence relation among v v j could coefficient linear combination produce x 1 coefficient v j affected values coefficients v 1 thus program way distinguishing situation subtract c j times v j situation subtract multiple v j thus linear combination x program probability 12 escaping undetected wrong claim independent ideas yield required algorithm described generate k random linear combinations let k random combinations x 1 k j 1 r begin toss fair coin heads else random 6 c j replace v j original matrix ask program rank new matrix heads rank 6 r gamma 1 return program bad tails rank6 r return program bad endfor endfor clear program wrongly claims independent probability 12 k escaping detection 633 upper bounding rank go back original matrix columns um selfreduction left r columns say supposedly linearly independent ndimensional space randomly pick vectors x vectors u basis n dimensional space use programs help deciding set n columns full rank program says redo experiment picking vectors x following lemma lemma 62 r independent probability greater positive constant 1delta4 delta 7 delta n vectors obtained augmenting r random vectors b form basis f n proof worstcase occurs f gf 2 required build random basis scratch case number good choices th vector total 2 n choices works probability th vector independent first gamma 1 yields result lemma clear lemma random trial constant probability succeeding ie producing basis perform experiment ok times program always says set vectors dependent report program buggy know correct overwhelming probability however small chance 12 k program right unlucky enough hit upon basis next need following lemma lemma 63 u dependent u linear combination u dependent u one u dependent u linear combination u dependent u probability half proof first statement lemma obvious second part suppose u rj independent u linear combination x dependent changing coefficient u rj anything else besides one x make new vector independent counting establishes least many independent combinations dependent ones equality occurring case vector space gf2 lemma 63 suffices check k random linear combinationsy u dependent u ensure probability program correct suppose one independent u denote 1 follows let unique expression linear combination u r lemma 64 representation c r probability 1 1of nonzero probability choice random extension basis although program influence distribution random extensions statement lemma still holds vector space generated first vectors basis let w complement v r taking appropriate components vectors w problem restated follows suppose random basis z l w ldimensional space nonzero vector w basis vector coefficient unique representation linear combination basis vectors nonzero probability 1we prove statement fixed vector respect random basis thought equivalent random vector respect random basis let random nonsingular l x l matrix consider 11 correspondence set bases set bases takes basis z l basis az ay image linear transformation nonsingularity 0 random vector w new basis random basis w 11 correspondence given basis random vector w generated randomly picking coefficients basis vectors thus random vector probability coefficient zero 1 result translated back fixed vector result lemmata 63 64 note u dependent high probability one replace one x basis u idea yields following checker repeat k times toss fair coin heads w random linear combination original basis nonzero coefficient x j else w random linear combination original basis without x j nonzero coefficient replace x j w feed resulting matrix p heads rank 6 r reject program tails rank reject program endrepeat endfor endfor clear program wrong original claim u um dependent escape detection probability 12 k thus checker error probability o12 k number places overall probability error bounded sum probabilities therefore o12 k 634 analysis running time expensive operation creation random linear combinations many vectors care taken keep number operations part 1 checker self reduction runs time part 2 generating k linear combinations takes time okn 2 loop repeated onk times run loop takes time thus overall running time part 2 okn 2 part 3 generating random basis takes okn 2 time since might generate kn different vectors finish creating k linear combinations takes okn 2 time bottleneck however loop repeated ok 3 times pass taking 2 time thus overall complexity checker ok 3 n 2 point discussion amount time charged call program analysis made call charged 1 step justified least theoretical sense follows assume model checker query tape write instances program run call program could justifiably charged amount time takes modify query tape order produce new instance previous instance queried possible use suitable data structures implement modifications o1 steps computation 7 checker characterization theorem section characterize set problems checked polynomial time purposes section checker running polynomial time called efficient take definition ip interactive proofsystem definition appearing gold wasser micali rackoff 19 except replace sufficiently large x definition x modification 19 conforms commonly accepted definition ip appears example goldwasser sipser 20 tompa woll 37 functionrestricted ip cofunctionrestricted ip set decision problems interactive proof system yesinstances noinstances satisfying conditions prover honest prover must compute function prover dishonest prover must function set instances fyes nog restriction implies two things 1 verifier may ask questions instances 2 prover prover must answer verifiers questions answer independent provers provers previous history questions answers theorem 71 efficient program checker c exists decision problem lies function restricted ip cofunctionrestricted ip proof theorem immediate definitions efficient program checkers complexity class functionrestricted ip let npsearch denote class problems x x noinstance yes together proof x yesinstance otherwise corollary 71 let np search problem efficient program checker c exists functionrestricted coip main purpose corollary point np 6 cofunctionrestricted ip seems likely efficient program checker c sense npcomplete problems note results lund et al 30 shamir36 give functionrestricted ip proofs npcomplete languages 8 overview conclusions thrust paper show many cases possible check programs output given input thereby giving quantitative mathematical evidence program works correctly input allowing possibility incorrect answer one would computations done hand program designer confronts possibility bug considers answer wrong gives alternative proving program correct may achievable sufficient many situations one way develop theory would require program checker proved correct paper however pure checking meaning proofs correctness whatsoever instead require checker c different program p checks two ways first inputoutput specifications c different p c gets p output responds correct buggy second demand running time checker os running time program checked prevents programmer undercutting approach could otherwise simply running program second time calling check whatever else programmer must think problem 9 acknowledgements grateful ronitt rubinfeld many long conversations marvelous ideas including extension checking ideas parallel computation sandy irani raimund seidel designed interesting checkers various problems computational geometry convex hull wish thank well russell imapagliazzo shafi goldwasser len adleman ideas enthusiastic support r efficient checkers numbertheoretic problems mathematical proofs computer system correctness hiding instances multioracle queries incoherent without hard designing programs check work checking correctness memories correctness problem computer science two notions correctness relation testing taxonomy problems fast parallel algorithms software testing evaluation social processes proofs theorems programs locally random reductions interactive complexity theory fast probabilistic algorithms proofs yield nothing validity languages np zeroknowldege proof systems knowledge complexity interactive proof systems public coins vs private coins interactive proof systems finite simple groups introduction classification personal communication program checkers probability generation efficient randomized pattern matching algorithms parallel algorithms sharedmemory machines helping robust oracle machines computing automorphism groups combinatorial objects new directions testing algebraic methods interactive proof systems note graph isomorphism counting problem combinatorial enumeration groups probabilistic algorithms designing checkers programs run parallel robust algorithms different approach oracles random selfreducibility zero knowledge interactive proofs possession information evaluation programbased software test data adequacy criteria new hash functions use authentication set equality tr taxonomy problems fast parallel algorithms software testing evaluation combinatorial enumeration groups graphs chemical compounds helping robust oracle machines arthurmerlin games randomized proof system hierarchy complexity class evaluation programbased software test data adequacy criteria knowledge complexity interactive proof systems designing programs check work hiding instances multioracle queries selftestingcorrecting applications numerical problems program checkers probability generation parallel algorithms sharedmemory machines proofs yield nothing validity languages np zeroknowledge proof systems checking correctness memories algebraic methods interactive proof systems randomselfreducibility complete sets incoherent without hard efficient checkers numbertheoretic computations social processes proofs theorems programs correctness problem computer science ctr christian collberg stephen g kobourov jessica miller suzanne westbrook agovista tool enhance algorithm design understanding acm sigcse bulletin v34 n3 september 2002 thomas sterling daniel katz larry bergman high performance computing systems autonomous spaceborne missions international journal high performance computing applications v15 n3 p282296 august 2001 edgar f lederer romeo dumitrescu specificationconsistent coordination model computations proceedings 1998 acm symposium applied computing p122129 february 27march 01 1998 atlanta georgia united states christian collberg stephen g kobourov suzanne westbrook algovista algorithmic search tool educational setting acm sigcse bulletin v36 n1 march 2004 dick hamlet continuity software systems acm sigsoft software engineering notes v27 n4 july 2002 ronitt rubinfeld madhu sudan selftesting polynomial functions efficiently rational domains proceedings third annual acmsiam symposium discrete algorithms p2332 september 1992 orlando florida united states dick hamlet dave mason denise woit theory software reliability based components proceedings 23rd international conference software engineering p361370 may 1219 2001 toronto ontario canada zhizhong chen mingyang kao reducing randomness via irrational numbers proceedings twentyninth annual acm symposium theory computing p200209 may 0406 1997 el paso texas united states chen h tse zhiquan zhou semiproving integrated method based global symbolic evaluation metamorphic testing acm sigsoft software engineering notes v27 n4 july 2002 paul ammann dahlard l lukes john c knight applying data redundancy differential equation solvers annals software engineering 4 p6577 1997 arbaugh james r davin david j farber jonathan smith security virtual private intranets computer v31 n9 p4855 september 1998 amit paradkar towards modelbased generation selfpriming selfchecking conformance tests interactive systems proceedings acm symposium applied computing march 0912 2003 melbourne florida chen fc kuo zhi quan zhou effective testing method enduser programmers acm sigsoft software engineering notes v30 n4 july 2005 daniel lewin salil vadhan checking polynomial identities field towards derandomization proceedings thirtieth annual acm symposium theory computing p438447 may 2426 1998 dallas texas united states christian collberg todd proebsting problem identification using program checking discrete applied mathematics v144 n3 p270280 15 december 2004 peifeng hu zhenyu zhang w k chan h tse empirical comparison direct indirect test result checking approaches proceedings 3rd international workshop software quality assurance november 0606 2006 portland oregon w k chan cheng c cheung h tse automatic goaloriented classification failure behaviors testing xmlbased multimedia software applications experimental case study journal systems software v79 n5 p602612 may 2006 borislav nikolik test suite oscillations information processing letters v98 n2 p4755 fast approximate probabilistically checkable proofs information computation v189 n2 p135159 march 15 2004 fast approximate pcps proceedings thirtyfirst annual acm symposium theory computing p4150 may 0104 1999 atlanta georgia united states ronen shaltiel christopher umans lowend uniform hardness vs randomness tradeoffs proceedings thirtyninth annual acm symposium theory computing june 1113 2007 san diego california usa dan gutfreund ronen shaltiel amnon tashma np languages hard worstcase easy find hard instances computational complexity v16 n4 p412441 december 2007 manindra agrawal somenath biswas primality identity testing via chinese remaindering journal acm jacm v50 n4 p429443 july dan gutfreund ronen shaltiel amnon tashma uniform hardness versus randomness tradeoffs arthurmerlin games computational complexity v12 n34 p85130 september 2004 taejoon park kang g shin soft tamperproofing via program integrity verification wireless sensor networks ieee transactions mobile computing v4 n3 p297309 may 2005 rahul santhanam circuit lower bounds merlinarthur classes proceedings thirtyninth annual acm symposium theory computing june 1113 2007 san diego california usa shafi goldwasser dan gutfreund alexander healy tali kaufman guy n rothblum verifying decoding constant depth proceedings thirtyninth annual acm symposium theory computing june 1113 2007 san diego california usa valentine kabanets russell impagliazzo derandomizing polynomial identity tests means proving circuit lower bounds proceedings thirtyfifth annual acm symposium theory computing june 0911 2003 san diego ca usa lori clarke david rosenblum historical perspective runtime assertion checking software development acm sigsoft software engineering notes v31 n3 may 2006 luca trevisan salil vadhan pseudorandomness averagecase complexity via uniform reductions computational complexity v16 n4 p331364 december 2007 christian collberg clark thomborson watermarking tamperproffing obfuscation tools software protection ieee transactions software engineering v28 n8 p735746 august 2002 valentine kabanets russell impagliazzo derandomizing polynomial identity tests means proving circuit lower bounds computational complexity v13 n12 p146 january 2004 marcos kiwi frdric magniez miklos santha exact approximate testingcorrecting algebraic functions survey theoretical aspects computer science advanced lectures springerverlag new york inc new york ny 2002
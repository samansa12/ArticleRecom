integer multiplication overflow detection saturation abstracthighspeed multiplication frequently used generalpurpose applicationspecific computer systems systems often support integer multiplication two nbit integers multiplied produce 2nbit product prevent growth word length processors typically return n least significant bits product flag indicates whether overflow occurred alternatively processors saturate results overflow positive negative representable number paper presents efficient methods performing unsigned twos complement integer multiplication overflow detection saturation methods significantly less area delay conventional methods integer multiplication overflow detection saturation b introduction 11 multiplication multiplication essential arithmetic operation general purpose computers digital signal processors highperformance systems support parallel multiplication hardware various highspeed parallel multipliers proposed realized parallel multiplier designs divided two classes array multipliers tree multipliers array multipliers consist array similar cells generate accumulate partial products 3 tree multipliers generate partial products parallel use tree counters reduce partial products sum carry vectors sum vectors using fast carrypropagate adder several methods developed reducing partial products 1 2 regular structure array multipliers facilitates implementation vlsi technology delay array multipliers however proportional operand length hand tree multipliers offer delay proportional logarithm operand length main drawback tree multipliers irregular interconnection structure makes difficult implement vlsi thus tree multipliers preferred high performance systems array multipliers preferred systems requiring less area new implementations optimizations parallel multipliers still active research areas 5 detail descriptions array tree multipliers given next chapter 12 overflow avoid grow word length instruction set architectures highlevel languages require arithmetic operation return results length input operands result integer arithmetic operation nbit numbers cannot represented n bits overflow occurs needs detected integer multiplication method overflow detection also depends whether operands signed unsigned integers unsigned multiplication overflow occurs result larger largest unsigned nbit number signed integer multiplication overflow also occur result smaller minimum representable nbit number twos complement multiplication also difference fractional integer overflow detection since overflow occurs twos complement fractional numbers gamma1 multiplied gamma1 easy detect overflow multiplying twos complement fractions important design issue computer architecture decide overflow occurs typically overflow results overflow flag set overflow flag used signal arithmetic exception 9 13 saturation general purpose processors overflow handled setting exception flag recent implementations digital signal processing multimedia applications saturate results overflow positive negative representable number 11 12 twos complement integers gamma2 negative numbers 2 positive numbers unsigned integers results large saturate 2 14 thesis overview previous studies focussed overflow detection twos complement addition 13 multioperand addition 14 fractional arithmetic operations 10 generalized signeddigit arithmetic15 thesis presents efficient techniques integer multiplication overflow detection saturation existing computers detect overflow integer multiplication computing 2nbit product testing significant bits see overflow occurred methods proposed thesis calculate n n bits product leads significant reduction area delay chapter 2 presents array multipliers tree multipliers conventional methods overflow detection chapter 3 introduces new methods overflow detection saturation unsigned integer multiplication chapter 4 focuses overflow detection saturation twos complement integer multiplication chapter 5 presents component counts area delay estimates unsigned twos complement parallel multipliers use either conventional proposed methods overflow detection chapter 6 discusses future work gives conclusions chapter 2 previous research 21 unsigned parallel multipliers multiplication two nbit unsigned numbers shown figure 21 multiplication produces 2nbit product n least significant bits used result overflow occurs actual product uses n bits words overflow occurs product greater equal 2 n conventional methods overflow detected 2nbit result pro duced done simply logically oring together n significant bits n2 n1 n2 n1 n2 n2 n1 n2b b 1 n1 n2b b 0 figure 21 multiplication b v one overflow occurs denotes logical although calculating 2n product bits detecting overflow leads unnecessary area delay computers provide integer multiplication overflow detection use approach system requires saturation saturated least significant product bits computed sets product 2 ngamma1 overflow occurs 211 unsigned array multipliers general array multipliers slower tree multipliers spite speed disadvantage however array multipliers often used due regular layout low area simplified design block diagram unsigned 8 8 array multiplier shown figure 22 diagonal figure 22 corresponds column multiplication matrix figure 21 modified half adder mha half adder gate modified full adder mfa full adder gate gates generate partial products full adders half adders add generated partial products sum outputs connected diagonally carry outputs connected vertically last row adders connected left right generates nmost significant product bits critical path multiplier shown dashed lines since almost half latency due bottom row adders row may replaced fast carrypropagate adder although decreases overall delay negative impact designs regularity n n unsigned array multiplier uses n 2 gates n conventional method overflow detection requires n significant product bits calculated product bits ored together produce overflow flag shown figure 22 conventional method saturating multiplication accomplished oring v p 0 p ngamma1 shown figure 23 mha mha mha mha mha mha mha mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa fa c fa c fa c mfaa 7 6 5 4 3 2 1 0 c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c mfa mfa ha c fa c fa c fa c figure 22 unsigned array multiplier conventional overflow detection mha mha mha mha mha mha mha mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa fa c fa mfa fa 7 6 5 4 3 2 1 0 c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c mfa mfa ha c fa c fa c fa c figure 23 unsigned array multiplier conventional saturation 212 unsigned tree multipliers tree multipliers three main parts partial product generation partial product reduction final carrypropagate addition various reduction schemes developed years two wellknown methods multiplier tree designs proposed wallace 2 dadda 1 wallaces strategy combines three rows partial product bits using 3 2 2 2 counters produce two rows daddas strategy leads simpler counter tree requires larger final carrypropagate adder hybrid approaches two methods offers cost speed tradeoffs vlsi implementations reduction schemes differs number placement counters tree size final carry propagate adder tree multipliers presented thesis use daddas method since allows component counts easily determined based n since overflow detection method depend reduction strategy similar savings expected tree multipliers figure 24 shows dot diagram 8 8 unsigned array multiplier dot diagrams often used illustrate reduction strategies tree multipliers 2 technique dot represents partial product bit plain diagonal line represents full adder crossed diagonal line represents half adder two bottom rows dot diagram corresponds sum carry vectors combined using final carrypropagate adder produce product dadda multipliers require n 2 gates n figure 24 dadda reduction scheme cpa number stages based n shown table 21 example 24 24 dadda multiplier requires seven reduction stages worst case delay path equal delay partial product generation plus delay reduction stages plus delay final carrypropagate addition conventional method overflow detected tree n gamma 1 2input gates delay tree gates equivalent dlog 2 ne 2input gates shown figure 25 range n 43 table 21 number stages nbit dadda tree multipliersv101214 pp figure 25 tree 2input gates 22 twos complement multipliers twos complement numbers b product p values gammab overflow occurs multiplication twos complement numbers generates signed partial products shown figure 26 since negative weights subtracted rather added makes design difficult implement requires adder subtracter cells consequently several techniques proposed handle partial products negative positive weight baughwooley algorithm6 variations 7 8 booths algorithm 16 baughwooley algorithm provides method 1 0 0 1 0 n1 x n1 figure 26 twos complement multiplication matrix modifying partial product matrix partial product bits positive weights algorithm modified form often used perform twos complement multiplicationb b 1 n1 1 b n2 n2 n1 n2 bn1a n2 n2 figure 27 modified twos complement multiplication matrix twos complement multiplication often realized using variation baugh wooley algorithm called complemented partial product word correction al gorithm implementation partial product bits containing complemented ones added columns n 2n gamma 1 equivalent taking twos complement two negative terms equation 25 multiplication matrix implementation shown figure 27 221 twos complement array multipliers design array multiplier uses complemented partial product word correction algorithm conventional overflow detection shown figure 28 design shown figure similar unsigned array multiplier design figure 22 gates leftmost column replaced nand gates last row mfas replaced negating modified full adders nmfa specialized half adder sha bottom right corner half adder takes sum carry bits previous row adds 1 cell approximately area delay regular half adder last product bit p 2ngamma1 inverted add one column 2n gamma 1 inverting p 2ngamma1 effect adding one column 2n gamma 1 carry column ignored figure 28 bottom two rows cells consisting n xor gates gates dedicated overflow detection xor gates identify whether differs significant product bits p n outputs xor gates combined determine overflow flag v set logic equation overflow detection flag mha mha mha mha mha mha mfa mfa mfa mfa mfa mfa mha mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa bb 7 6 5 4 3 2 1 0 c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c fa c fa c fa c nmfa nmfa nmfa nmfa nmfa nmfa nmfa fa c fa c fa c figure 28 twos complement array multiplication conventional overflow detection saturating multiplication implemented adding nbit 2to1 multiplexer shown figure 29 twos complement multiplication product flows saturated product determined sign bits b negative overflow occurred product saturates gamma2 hand positive overflow occurred product saturates 2 overflow mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa c mfa c c c c mfa mfa mfa mfa mfa mfa mfa mfa mha mha mha mfa c mha mha mha c andpand 7 6 5 4 3 2 1 0 c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c fa c fa c fa c nmfa nmfa nmfa nmfa nmfa fa c fa c fa c mfa mfa nbit mux xand figure 29 conventional twos complement saturation occurred saturated product n least significant bits saturated product 222 twos complement tree multipliers several techniques available implementing twos complement multiplier trees 4 8 figure 27 shows dot diagram 8 8 twos complement multiplier tree uses complemented partial product algorithm 8 daddas reduction method 1 similar twos complement array multiplier 2n gamma 2 partial product bits inverted ones added columns n 2n gamma 1 although seems heights two columns increased adding ones effect adversely design significant product bit simply inverted sha adds one column n figure 210 dot line indicates complemented partial product bit circled half adder column 8 sha specialized half adder n n twos complement dadda tree multiplier fas 2n gamma 2 bit cpa conventional techniques overflow detection saturation twos complement tree multipliers similar techniques used twos complement array multipliers difference tree multipliers tend use tree gates rather linear array gates computing overflow flag figure 210 twos complement dadda tree multiplier chapter 3 overflow detection saturation unsigned integer multiplication 31 general design approach instead computing 2n bits product methods proposed thesis compute n least significant product bits separate overflow detection logic shown figure 31 carries column n also used overflow detection circuit main idea behind proposed unsigned overflow detection methods overflow occurs partial product bits column n 2n gamma 2 1 overflow detection result operand operand b n n multiplier figure 31 block diagram unsigned multiplication overflow detection carries column n 1 consequently ones detected without adding partial products logic equation unsigned overflow detection expression v overflow flag c th carry column n bit summations corresponds logical ors bit multiplications corresponds logical ands 32 unsigned array multipliers overflow detection saturation figure 32 shows 8 8 multiplication matrix demonstrate partial product bits used detect overflow proposed method partial products used overflow detection b 0 b 0 b 0 b b b b b b b 1357 0 b 1111a b b b b b b b 1357 0 b 2222a b b b b b b b 1357 b b b b ba b 1357 b b b b b b b 1357 b b b b b b b 1357 b b b b b b b 1357 0 b figure 32 8 8 unsigned multiplication matrix using equation 31 common terms logic equation overflow detection used reduce hardware needed detect overflow overflow detection circuit constructed using gates shown figure 33 8 8 unsigned multiplication n n multiplier three gates dashed lines replicated times three gates combined form overflow detection ovd cell overflow detected using following iterative equations temporary bit initial value v temporary overflow bit initial value shown figure 33 ovd cell takes inputs generates outputs ovd cell contains one gate one 2input gate one 3 input form unsigned multiplier proposed overflow detection method cells combined unsigned array multiplier cells used compute p n p 2ngamma1 removed shown figure 34 8 8 unsigned array multiplier b246 aa 7b c c figure 33 proposed overflow detection logic nbit unsigned array multiplier uses proposed method overflow detection requires n 2 fas corresponds n gates conventional method worst case delay path indicated dashed line figure 34 since mfa longer delay ovd cell unsigned multiplier proposed overflow detection logic delay approximately half long unsigned multiplier conventional overflow detection shown figure 33 unsigned saturating multiplication using proposed method performed oring overflow bit n least significant product bits shown figure 35 overflow bit 1 produces product n ones corresponds maximum representable unsigned number otherwise product changed requires n gates worst case delay increases one delay mha mha mha mha mha mha mfa mfa mfa mha mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfao 7v 7 6 5 4 3 2 1 0 c c c c c c c c c c c c c c c c c c c mfa ovd ovd ovd ovd ovd cccc ovd c figure 34 unsigned array multipliers proposed overflow detection logic mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mha mha mha mha mha mha mha 7 6 5 4 3 2 1 0 c c c c c c c c c c c c c c c c c c c mfa ovd ovd ovd ovd ovd cccc ovd c figure 35 unsigned array multipliers proposed saturation logic 33 unsigned tree multipliers overflow detection saturation unsigned tree multipliers technique using array ovd cells linear delay work well since ovd cells would significantly increase multipliers worst case delay path instead n 2 partial product bits generated tree gates used determine partial product bits columns n 2ngamma1 carries column n one method shown 8 8 multiplier figure 36 symbol denotes output 2input gate although method requires hardware overflow detection unsigned array multiplier overflow detection logic logarithmic delay longer contributes significantly critical path n n unsigned array multiplier uses method n 2 n fas since delay gates overflow detection less delay partial product reduction stages worst case delay equal delay partial product generation plus partial product reduction plus n gamma 1bit carrypropagate addition plus one gate delay include final carry saturating multiplication performed method used array multiplier overflow bit ored n least significant bits product figure unsigned tree multiplier proposed overflow detection logic chapter 4 overflow saturation detection twos complement integer multiplication 41 general approach proposed method overflow detection twos complement multiplication detects number consecutive bits equal sign bit essentially method counts number leading zeros operand positive number leading ones operand negative example 11100101 three leading ones 00001001 four leading zeros method works number leading zeros ones indicates magnitude operand operands leading zeros ones smaller magnitudes therefore less likely cause overflow main issue determine many leading zeros leading ones needed guarantee overflow occur overflow occur block diagram shows proposed approach shown figure 41 analysis twos complement multiplication three cases depending operands signs operands positive operands negative one positive negative overflow regions three cases discussed following sections case 1 operands positive let za denote number leading zeros operand zb denote number leading zeros operand b since operands positive nbit integers least one n leading zeros expressed ranges operand operand b terms number leading zeros expressed overflow detection operand operand b multiplier n n figure 41 block diagram proposed method twos complement multiplication overflow detection overflow occurs case 1 overflow occur based 42 range p using 43 overflow guaranteed occur determine number leading zeros b guarantee overflow 44 rewritten taking base 2 logarithm sides gives equivalently thus b together less n leading zeros overflow must occur similarly overflow guaranteed occur determine number leading zeros b guarantee overflow occur equation 48 rewritten since gamma2 ngammaz gamma1 gamma2 ngammaz b gamma1 consequently overflow guaranteed occur taking base 2 logarithm sides gives equivalently using always true since za 1 zb 1 therefore 413 rewritten thus overflow guaranteed occur b together n leading zeros cannot directly determined whether overflow occurred examining number leading zeros rewriting 43 problem however solved analyzing happens za n results obtained far summarized figure 42 overflow overflow undetermined figure 42 overflow regions za determine whether overflow occurs necessary calculate many product bits needed represent result za n using significant product bits sign bits operands overflow flag set n even maximum product equivalently n odd maximum product equivalently thus za always represented n bits overflow determined simply examining sign bit p ngamma1 p otherwise overflow occur 412 case 2 operands negative let denote number leading ones operand b denote number leading zeros operand b since operands negative nbit integers least one n leading ones expressed ranges b terms leading ones expressed gamma2 ngammai gamma1 overflow occurs case 2 overflow occur based 422 range p using 423 overflow guaranteed occur determine number leading ones b guarantee overflow occurs 424 rewritten since values satisfy also satisfy 425 taking base 2 logarithm sides 427 gives thus negative integers overflow occurs operands less leading ones using 423 overflow guaranteed occur taking base 2 logarithm sides equation 429 gives thus overflow guaranteed occur b together leading ones cannot directly determined overflow occurred seen using 423 gives similarly results far shown figure 43 undetermined overflow overflow figure 43 overflow regions even maximum result n odd maximum product represented using n bits except occurs 413 case 3 signs operands differ let denote number leading ones operand zb denote number leading zeros operand b negative operand least one n leading zeros positive operand b least one n leading ones expressed ranges b terms leading ones zeros gamma2 ngammai gamma1 overflow occurs case 3 p gamma2 occur p gamma2 based 436 range p using equation 437 overflow guaranteed occur equivalently zb 439 always true since 2 using 437 overflow guaranteed occur gamma2 equivalently range cannot determined whether overflow occurred since figure 44 shows graphically results obtained far case 3 overflow overflow undetermined figure 44 overflow regions zb even minimum negative number n odd cases product represented using n bits therefore overflow occurs p far proposed method explained mathematically next section implementations overflow logic presented 414 overflow detection logic allow positive negative operands use hardware detecting leading zeros ones sign bits xnored remaining bits takes gates expressed logically logic design detects n gamma 1 fewer leading zeros leading ones includes gates gates used compute ba ngammakgamma2 447 3 preliminary overflow flag generated using xi yi bit products correspond logical ands bit summations correspond logical ors equation implemented using n gamma 2 2input gates gates v 1 one total number leading zeros leading ones less n case overflow guaranteed occur additional logic used detect overflow undetermined regions cases 13 case 1 detected case 2 neither b zero n least significant bits zero case 3 neither b zero detected logic equations 450 454 realized 9 2input gates 4 inverters n gates final overflow flag v generated oring previous flags overflow detection circuit requires 2n gamma gates four inverters overflow detection circuit 8bit twos complement multiplier shown figures 45 46 bb 7 7 7 7 7 7 7 figure 45 logic v 1 8bit multiplication 7y least significant z figure detection logic 8bit twos complement multiplication 415 alternative method alternative method detecting overflow undetermined case instead generating product bits multiplier generate product bits detect undetermined cases checking p n phi p approach shown figure 47 approach works since undetermined cases following situations overflow occurs 2 case 2 overflow occurs one exception generated p 3 case 3 overflow occurs three cases overflow detected 42 twos complement array multipliers overflow detection saturation proposed method overflow detection array multipliers requires half much hardware conventional method 8bit twos complement multiplier n n multiplier operand detection figure 47 block diagram proposed alternative method twos complement multiplication overflow detection proposed method overflow detection shown figure 48 x2a cell contains one 2input xor gate one 2input gate x3a cell contains one 3input xor gate one 2input gate x3na contains two 2input xor gate one 2input nand gate twos complemented array multiplier proposed overflow detection logic 3input xor gates one 2input xor gate four inverters delay multiplier approximately equal delay n gamma plus four 2input gates plus three 3input gates actual delay may differ according various design decisions technology used overflow detection mfa mfa mfa mfa mfa mfa mfa mfa mfa b 7b mfa 7 5 3 1 aa 4 mfaa 7 6 5 4 3 2 mfa mfa mfa mha mha mha mha mha mha c c c c c c c c c c c c c nand figure 48 overflow detection logic 8bit twos complement multiplication twos complement saturating multiplication performed using v flags flags used inputs nbit 2to1 multiplexer shown figure 49 negative overflow occurs result saturated gamma2 positive overflow occurs result saturated 2 adding saturation logic array multiplier overflow detection requires addition inverter nbit 2to1 multiplexor since v already generated overflow detection logic require additional hardware delay increases delay 2to1 multiplexer plus delay inverter overflow detection c c c c c mfa 6 c s7s mfab 432 7 mfa mfa 5 4 2 1 7 6 mfa mfa mfa mfa mfa mfa mfab mfa mfamfa mha mha mha mha mha c c c c c c c c nand mfa nbit mux 6 5 4 3 2 1 07 5 4 2 figure 49 saturating twos complement array multiplication 43 twos complement tree multipliers overflow detection saturation alternative method used tree multipliers method n1 bits product computed v 1 computed approach first method overflow flag generated using logic equation explained section 415 since detection circuit independent multiplication process n1 partial product bits needs generated consequently gates counters generate reduce partial product bits column n multiplication matrix longer needed size carrypropagate adder reduced n bits since least significant product bits used reductions independent strategy used design tree multiplier reduction scheme dadda multiplier uses alternative method shown figure 410 diagonal line x bottom 3 input xor gate diagonal tilda x bottom represents 2input xnor gate xs used denote carry output required worst case delay main constraint custom design alternative design method considered implement overflow detection logic twos complement dadda multiplier proposed overflow detection n gates one nbit cpa worst case delay multiplier also less conventional technique alternative methodthe worst case delay equals delay reduction stages plus delay n adder plus one 2input gate plus one 2input xor gate plus one 2input gate twos complement saturating multiplication logic dadda tree multiplier similar logic array multiplier nbit 2to1 multiplexer inverter added shown figure 49 except partial product bits p ngamma2 connected overflow detection logic control signals v 2to1 multiplexer generated detection logic delay increases delay inverter plus delay 2to1 multiplexer figure 410 dadda dot product scheme proposed overflow detection chapter 5 results 51 area delay estimates theoretical component counts worst case delays given various multipliers tables 51 52 table 53 tables u denotes unsigned signed denote array tree multiplier p c denote proposed conventional table 51 table 52 gives number component size cpa based operand length n table 53 gives number type component worst case delay path proposed methods reduce number gates fas array multipliers reduce number gates fas size cpas tree multipliers proposed methods also reduces delays array tree multiplier since significant product bits longer calculated multiplier number components type inv nand or2 or3 table 51 component counts nbit multipliers overflow detection multiplier number components type xor xnor ha fa cpa table 52 component counts nbit multipliers overflow detection ii multiplier number components worst case delay path type inv or2 xor ha fa cpa table 53 worst case delay nbit multipliers overflow detection table 54 unsigned array multipliers overflow detection possible reduce amount logic required implement detection circuit even proposed method uses straight forward implementation logic equations structures presented previous chapters synthesis tools used optimize design consequently values shown table 51 52 table 53 considered worst case values optimization performed gate level vhdl code various sizes array dadda tree multipliers generated conventional proposed methods overflow detection vhdl code synthesized optimized area using lsi logics 06 micron gate array library leonardo synthesis tool exemplar logic synthesis tool set nominal operating voltage 50 volts temperature 25 ffi c area estimates reported equivalent gates delay estimates reported nanoseconds table 54 gives area delay estimates unsigned array multiplier compared multipliers use conventional overflow detection proposed multipliers 50 53 less area 41 42 less delay table 55 unsigned dadda tree multipliers overflow detection conventional proposed reduction n area delay area delay area delay table signed array multipliers overflow detection gains mainly due reductions area delay fas used generate n significant product bits table 55 gives area delay estimates unsigned dadda tree multipliers compared multipliers use conventional overflow detection method multipliers use proposed method approximately 47 less area 23 28 less delay improvements due reducing number fas reducing size final carrypropagate adder 2n gamma 2 table 56 gives area delay estimates twos complement array multipliers compared multipliers use conventional method multipliers use proposed method require 38 47 less area 41 table 57 signed dadda tree multipliers overflow detection table 57 gives area delay estimates twos complement dadda tree mul tipliers compared multipliers use conventional method multipliers use proposed method 35 44 less area 24 32 less delay chapter 6 conclusions future research 61 conclusions overflow detection saturation methods presented thesis significantly reduce area delay array tree multipliers multiplier sizes examined area reduced 50 unsigned multipliers compared conventional methods proposed methods also change regularity multiplier structure twos complement multipliers proposed methods completely independent multipliers internal structure feature provides designers increased flexibility since add overflow detection logic without effecting original design reduction multiplier hardware also lead reduced power dissipation proposed methods reduce delay array multipliers 40 50 62 future research thesis separately presented overflow detection saturation methods unsigned twos complement parallel multipliers important next step develop single multiplier structure perform unsigned twos complement integer multiplication overflow detection saturation based input control signal another area future research investigate techniques reducing area overflow detection multiplier trees without significantly impacting delay research may able take advantage hybrid structure less delay linear overflow detection structures less area overflow detection trees another research area investigate reductions power dissipation due proposed techniques anticipated significant reduction power dissipation achieved due reduction multiplier hardware methods similar proposed methods also used arithmetic operations needs overflow detection multiplyaccumulate squaring r schemes parellel multipliers suggestion fast multiplier 40 ns 17bit array multiplier parallel reduced area multipliers reduction scheme optimize wallace multiplier twos complement parallel array multiplication algorithm comments twos complement parallel array multiplication algorithm synthesis comparision twos complement parallel multipliers computer architecture quantative approach second edi tion parallel saturating fractional arithmetic units fixedpoint overflow exception detection programmable highperformance iir filter chip overflow indication twos complement arith metic overflow detection multioperand addition zero sign overflow detection schemes generalized signed arithmetic signed binary multiplication technique tr ctr eyas elqawasmeh ahmed dalalah revisiting integer multiplication overflow proceedings 4th wseas international conference software engineering parallel distributed systems p114 february 1315 2005 salzburg austria eyas elqawasmeh ahmed dalalah revisiting integer multiplication overflow proceedings 4th wseas international conference software engineering parallel distributed systems p114 february 1315 2005 salzburg austria
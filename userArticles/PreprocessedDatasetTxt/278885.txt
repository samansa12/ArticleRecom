connectors mobile programs abstractsoftware architecture put forward concept connector express complex relationships system components thus facilitating separation coordination computation separation especially important mobile computing due dynamic nature interactions among participating processes paper present connector patterns inspired mobile unity describe three basic kinds transient interactions action inhibition action synchronization message passing connectors given community unitylike program design language semantics category theory show categorical framework used applying proposed connectors specific components resulting architecture visualized diagram showing components connectors b introduction complexity software systems grows role software architecture increasingly seen unifying infrastructural conceptmodel analyse validate overall system structure various phases software life cycle consequence study software architecture emerged recent years autonomous discipline requires concepts formalisms methods tools 1 2 concept connector put forward express complex relationships system components thus facilitating separation coordination computation especially important mobile computing due transient nature interconnections may exist system components paper propose architectural approach mobility encapsulates dynamic nature interaction welldefined connectors precisely present connector patterns three fundamental kinds transient interaction action inhibition action synchronization message passing pattern parameterized condition expresses transient nature interaction overall architecture obtained applying instantiated connectors mobile system components illustrate proposal components connectors written community 3 4 program design language based unity 5 ip 6 nature connectors proposed paper motivated inspired mobile unity 9 10 extension unity allows transient interactions among programs however approaches somewhat different mobile unity suggests use interaction section define coordination within system components advocate approach based explicitly identified connectors order make architecture system explicit promote interactions firstclass entities like programs moreover base approach modification superposition relation programs mobile unity introduces new special programming constructs leading profound changes unitys syntax computational model however point syntactic semantic modifications like naming program actions locality variables already included community make easier interested readers compare approach mobile unity use example 9 luggage distribution system consists carts moving closed track transporting bags loaders unloaders along track due space limitations omitted many details making example realistic necessary illustrate main ideas paper follow approach proposed 7 give semantics connectors categorical framework approach programs objects category morphisms show programs superposed category theory 8 objects characterized internal structure morphisms ie relationships objects changing definition morphisms obtain different kinds relationships programs without change syntax semantics programming language fact core work presented remainder paper illustration principle changing program morphisms small way actions ramified transient action synchronization becomes possible work partially supported jnict contract praxis xxi 221mat4694 escola project arts contract equitel sa michel wermelinger departamento de informatica universidade nova de lisboa 2825 monte da caparica portugal email mwdifctunlpt jose luiz fiadeiro departamento de informatica faculdade de ciencias universidade de lisboa campo grande 1700 lisboa ii mobile community framework used consists programs morphisms section introduces necessary definitions thorough formal treatment interested reader consult 4 community program basically set named guarded actions action names act rendezvous points program synchronization step one actions whose guards true execute parallel action consists one assignments execute simultaneously attribute used program either externalits value provided environment may change timeor localits value initialized program modified actions attributes typed fixed algebraic data type specification set sort symbolsomega theta sindexed family function symbols phi set firstorder axioms defining properties operations present specification sorts predefined functions used paper community program following structure program p read r init f g ffl v set local attributes ie program variables ffl r set external attributes used program ie readonly attributes instantiated local attributes components environment ffl attribute typed data sort ffl initialisation condition proposition local attributes set action names one associated statement see ffl every action g 2 gamma guard bg proposition attributes stating necessary conditions execute ffl every action g 2 gamma domain dg set local attributes g change ffl every action local attribute 2 dg f g term denoting value assigned time g executed formally signature program defines vocabulary ie attributes action names program signature tuple hv r gammai set local attributes r set external attributes set actions sets v r gamma finite mutually disjoint domain action set v notation program attributes sort attribute denoted domain action g denoted dg inversely 2 v set actions change programs body defines initial values local attributes also actions modify purpose body uses propositions terms built programs attributes predefined function symbols program pair h deltai program signature program body ffl proposition f assigns every every 2 dg term sort assigns every proposition notation dg empty f denoted skip 2 locations important aspect mobility 11 take approach mobile unity represent location distinguished attribute however framework allows us handle locations flexible way distinguish whether program controls motion moved environment declaring location attribute local external respectively formal treatment locations attribute special properties abstract level working however implementation community handle special way change systems location implies change value location attribute viceversa assume therefore special syntactic convention location attributes compiler distinguish attributes following notation proposed mobile unity paper location attributes start give example community program present specification cart like bags unloaders carts unique identifiers represented external integer attributes cart cannot change identity cart transport one bag time source loader destination unloader initially carts destination loader fetch first bag unloader bag must delivered depends bags identifier delivering bag loader empty cart proceeds next loader absence bag denoted identifier zero track divided segments divided ten units location cart therefore given integer carts move two different speeds slow one length unit per time unit fast two length units cart stops reaches destination action performed destination depends whether cart empty full program cart dest int read id nbag int slow 6 dest 1 fast 6 dest 2 load dest nbag k dest destnbag dest unload dest bag dest nextdest turn program morphisms categorical notion expresses relationships certain pairs programs previous definitions community 4 7 morphism two programs p p 0 mapping p attributes actions p 0 stating way p component p 0 therefore called superposition morphism since captures notion superposition 5 p underlying program p 0 transformed one paper keep basic intuition introduce small although fundamental change mobile setting program may synchronize actions different actions different programs different times allow program morphism may associate action g base program p set actions fg superposed program p 0 intuition actions correspond behaviour g synchronizing actions components p 0 action g must preserve basic functionality g adding functionality action synchronized g morphism quite general set fg may empty case action g effectively removed p 0 put words permanently inhibited guard made false due technical reasons mapping actions p sets actions p 0 formalised partial function p 0 p however examples informal discussions use set version action mapping morphisms must preserve types locality domain attributes preserving locality means local attributes mapped local attributes preserving domains means new actions system allowed change local attributes components definition 3 given program signatures consists total function oe ff 0 partial function oe notation following indices ff fl omitted denote preimage oe fl oe also x term proposition oex term resp proposition 0 obtained replacing attribute x notice choice appropriate morphism possible state whether given component given system colocated ie whenever one moves component move independently within system modeled morphism maps location attribute component location attribute system first result signatures morphisms constitute category basically asserts morphisms composed words componentof relation transitive reflexive course proposition 1 program signatures signature morphisms constitute category sig superposition program p 0 base program p captured morphism signatures obeys following conditions ffl initialization condition weakened ffl assignments equivalent ffl guards weakened means validity firstorder sense category signatures extends programs proposition 2 programs superposition morphisms constitute category prog give example program morphism consider need prevent carts colliding intersections achieve goal two steps second presented subsection ivb two carts enter two segments intersect due semantics community allowing one cart move step one carts away intersection first step avoid collisions force cart move slowly words fast action inhibited notice case inhibition depends presence another cart therefore second external location attribute 2 needed cart program thus transformed inhibitedcart given diagram program cart dest int read id nbag int slow 6 dest 1 fast 6 dest 2 load dest bag0 unload dest bag 6 0 program inhibitedcart dest int read id nbag slow 6 dest 1 fast 6 dest 2 load dest bag0 dest bag6 0 inhibition condition distancetocrossing morphism injection 7 fast 7 fast etc next section shows inhibitedcart program obtained composition two components iii architecture configuration system described diagram components channels components programs channels given signatures specify programs interconnected given programs p p 0 signature constructed follows pair attributes actions 2 p shared resp synchronized signature contains one attribute resp action b morphism p maps b morphism p 0 maps b 0 morphisms signatures programs signature seen program f empty body 7 categorical terms operator f functor ie morphism objects different categories simple example consider following diagram connects channel represents attribute sharing generic cart program program initializes integer attribute value 2 program init 2 signature share program cart var init program describes whole system given colimit diagram obtained computing pushouts pairs components common channel program p resulting pushout obtained follows initialization condition conjunction initialization conditions components attributes p union attributes p 1 p 2 renaming shared name attribute p local local least one component example resulting pushout represent cart identifier 2 program cart 2 var bag dest id int read nbag int actions p basically subset pairs actions pairs g 1 g 2 mapped action channel may appear p action p 1 mapped action channelie synchronized action p 2 resp p 1 appears unpaired p synchronizing two actions g 1 g 2 ie joining single one g 1 taking union domains conjunction guards parallel composition assignments actions common attribute resulting assignment f g 1 guard strengthened actions incompatible ie terms denote different values equality false therefore synchronized action never execute expected illustration pushout diagram program cart var bag dest int read id nbag int slow 6 dest 1 fast 6 dest 2 load dest bag0 unload dest bag 6 0 signature i7fast program inhibitor read int skip program inhibitedcart shown previous section actions fast paired together joining guards assignments notice attribute inhibitor program renamed 0 names local next result states every finite diagram colimit proposition 3 category prog finitely cocomplete channels ie signatures allow us express simple static connections programs express complex transient interactions use connectors basic concept software architecture 2 connector consists glue linked one roles channels roles constrain objects connector applied categorical framework connectors therefore architectures built depend categories used represent glues roles channels relationships categories possible use three different categories three parts connector eg 7 proposes roles specifications written temporal logic simplicity assume roles glues members category therefore adopt basic definitions 7 connection tuple hc g r fl aei channel glue role morphisms prog connector finite set connections glue semantics connector given colimit connections diagram definition superposition morphisms object diagram colimit therefore superposition becomes sense symmetric necessary property capture interaction 10 connector applied programs instantiations roles categorical terms must exist morphisms roles programs definition 6 correct instantiation connector fhc g r set morphisms prog resulting system colimit diagram formed morphisms illustration instantiated connector two roles diagram iv interactions interaction two programs involves conditions computations therefore cannot specified signature must use connector programs instances roles interaction glue channel states exactly part program interaction distributed system may consist many components usually classified relatively small set different types since interaction patterns normally depend individual components types necessary define connectors existing component types obtain resulting system connectors instantiated actual components therefore following consider programs correspond component types luggage distribution example three different program types carts loaders unloaders programs individual components differ initialization condition identifier attribute mobile setting one important aspects interactions temporary nature represented conditions interaction takes place proposition true usually proposition based location interacting parties consider three kinds interactions inhibition action may execute 1 synchronization two actions executed simultaneously communication values local attributes one program passed corresponding external attributes program kind interaction develop connector template parameterized interaction conditions means given interacting programs ie roles conditions interact appropriate connector instantiated given set components form overall system possible interactions specified follows ffl inhibition interaction states action g program p executed whenever interaction condition true ffl synchronization interaction states action g program p execute simultaneously action g 0 program true ffl communication interaction states value local attributes message program p written external attributes 0 program p 0 true sets 0 must compatible moreover program must indicate action immediately executed sending resp receiving message definition 7 given set p programs transient interaction either one following ffl transient inhibition hg ffl transient synchronization hg ffl transient communication hg mp bijection ffl proposition attributes p following subsections present connector patterns corresponding interactions glue connector needs include attributes occur interaction condition however make formal definitions easier glue patterns include attributes roles due locality names attributes different roles must put together disjoint union operator written avoid name clashes simplication assume interaction condition uses attributes interacting programs thus roles presented patterns case instantiated connector must roles provide remaining attributes next subsection provides example inhibition inhibition easy elegant express action executed true executed true definition 8 inhibition connector pattern corresponding inhibition interaction hg 1 case interaction program environment program p read r init g bg signature target g program inhibitor init true g skip illustration action inhibition example sections ii iii achieved following connector signature context read int program inhibitcrossing read init true fast skip signature target read int fast fast7fast program cart program cart inhibition condition notice connector two roles one cart whose action temporarily inhibited cart provides context inhibition occur application connector resulting colimit presented next subsection b synchronization synchronizing two actions g g 0 two different components seen merging single action gg 0 system difference static mobile case latter merging done condition true gg 0 executes corresponds simultaneous execution g g 0 therefore g would executed component system fact execute gg 0 means also executing g 0 viceversa sum two actions synchronize either execute simultaneously none executed contrasts approach taken mobile unity allows two kinds synchronization coexecution coselection 10 former corresponds notion exposed latter forces two actions selected simultaneously one inhibited guard false action executes extends basic semantics unity one action selected time since community already allows impose simultaneous selection multiple actions believe intuitive notion synchronization corresponds coexecution handle coselection key represent synchronization two actions subject condition ramify action two one corresponding execution false one true put words action two subactions one normal execution synchronized execution normal subaction execute condition false inhibited true opposite happens synchronization subaction therefore use technique inhibition since two actions synchronized synchronization subaction must shared three instead four subactions facilitate understanding name subaction set names actions part definition 9 synchronization connector pattern corresponding synchronization interaction hg signature c g program synchroniser read init true g skip signature c 0 read program p read r init g bg program p 0 read r 0 init colimit action gg 0 guards assignments g g 0 therefore either bg bg 0 false assignments incompatible gg 0 get executed connector describes called nonexclusive coexecution 10 outside interaction period actions execute normal also possible simulate exclusive coexecution means actions executed synchronously interaction condition true end simply eliminate actions g g 0 inhibition connector shown keeping synchronized action gg 0 continuing example second step avoid collisions crossings force nearest cart move fast whenever distant one moves since latter move slowly nearest cart guaranteed pass crossing first using interaction condition previous section one gets diagram signature c 1 read int fast program synchcrossing read init true fast skip signature c 2 read int slow slow7fslowfastslowg program cart program cart prevent collisions cart 1 cart 2 obtained shown section iii one must consider two symmetrical cases depending cart nearer intersection let us assume cart 1 nearer thus must block fast action cart 2 inhibitor shown previous section synchronize slow action fast action cart 1 using connector diagram cart context inhibitcrossing target cart cart oo synchcrossing c 2 cart following colimit ranges 1 2 abbreviate code duplication program system read nbag dest slow dest dest dest fast 1 slow dest dest dest dest dest destnbag dest dest dest nextdest see synchronization transitive consider following example action g 0 synchronized two actions g g 00 whenever 1 2 true respectively resulting system must provide actions four combinations truth values interaction conditions example 1 2 true actions must occur simultaneously 1 2 false subset actions occur happens indeed pushout two morphisms g basically given pairs fg 1 g 0 morphism oeg g putting words action g ramifies actions g means whenever g would executed subset oeg executes superposed program viceversa execution g implies g executed base program therefore g ramified two distinct ways pushout combination subactions occur whenever g executes pushout morphisms state combinations subaction belongs ssh ssg gggggggggggggggggggg one see combinations 1 2 correct actions executed colimit includes combination actions share name actions g 0 gg 0 left middle pushout synchronized g 0 g 0 g 00 right four possible ways c communication mobile unity communication achieved variable sharing interaction x c engage disengage f x k f states sharing condition c shared initial value variables final value f x f variable operational semantics states whenever program changes x gets value viceversa approach violates locality principle furthermore pointed 10 several restrictions imposed order avoid problems like eg simultaneous assignments different values shared variables also feel communication appropriate concept sharing setting considering namely mobile agents engage transient interactions kind network framework community programs communication seen kind sharing local external attributes keeps locality principle say kind cannot use mechanism static case sharing meant map two different attributes components single one system obtained colimit mobile case local attribute may shared different external attributes different times viceversa apply usual construction attributes would become single one resulting system clearly unintended therefore obtain effect transient sharing using communication perspective precise assume program p wants send message set local attributes p 0 wants receive message must provide external attributes 0 correspond number type program p produces values stores waits message read p 0 since community programs sequential waiting understood restricted sense assume p produce another message previous one read ie messages lost may however executing unrelated actions put another way producing program p expecting acknowledge produce new values attributes purpose assume p action g must executed new message produced similarly program p 0 must informed new message arrived may start processing purpose assume p 0 single action g 0 first action executed upon receipt new message 2 action may simply start using 0 directly may copy local attributes p 0 sum communication established via one single action program 3 action g p waiting read action g 0 p 0 reads ie starts using values 0 expected glue interaction connector transfer values 0 notify programs solution explicitly model message transmission parallel assignment message attributes abbreviate 0 possible local attributes p must external attributes glue external attributes 0 p 0 must local attributes glue assignment done parallel notification p moreover programs may communicate proposition true therefore glue contains action wait 0 synchronized waiting action g p reading action g 0 p 0 executed message transmitted solution another action read glue synchronized g 0 make sure read executed wait use boolean attribute thus 0 inhibited new values transferred 0 like blocking read primitive except 2 always possible write p 0 way 3 similar pointed processes calculus ports distributed systems p 0 may execute actions unrelated 0 since receiver may get messages different senders different times several possible assignments 0 due locality principle assignments attribute must single program therefore message type receiver might get single glue connecting possible senders hand message might sent different receivers therefore several possible assignments 0 associated wait action sender message must single glue connect sender possible recipients sum message type single glue acting like demultiplexer synchronizes sender receiver j interaction condition ij true assumes possible communication patterns known advance communication connector pattern corresponding communication interactions signature sender read wait program communicator read init new j signature receiver j read 0 read j program p read r init program j read 0 init read notice several actions wait ij may occur simultaneously particular receiver j messages sent value distinguish messages sent different senders even content one add local integer attribute glue add assignment action wait ij prevents two different senders sending messages simultaneously luggage delivery example communication takes place cart arrives station ie loader unloader bag exchanged message loaders senders unloaders receivers carts roles bags held station stored attribute type queue integers although locations stations fixed must represented explicitly order represent communication condition namely cart station colocated since connector describe interaction programs stations describe basic computations loaders remove bags queues unloaders put bags queues loader program must separate actions produce message ie computation value bag attribute send message ie bag loaded onto cart c carts connected l loaders connector c identical roles one cart program section l identical roles loader program show roles respective morphisms ithe loader sender jth cart receiver signature sender read load load7fwait i1 wait ic g program load init new j nbag new j true new j false signature receiver read nbag int load load7read j program loader loaded init loaded initlocid newbag q loaded loadedfalse loaded load loaded loadedtrue program cart var dest bag int read id nbag int initlocid slow 6 dest 1 fast 6 dest 2 load dest bag0 bagnbag dest bag60 similarly connector u roles unloaders c roles carts ithe cart sender connected jth unloader receiver follows signature sender read load load7fwait i1 wait iu g program unload read init new j signature receiver j read unload program cart var dest bag int read id nbag int initlocid slow 6 dest 1 fast 6 dest 2 load dest bag0 bagnbag dest bag60 program unloader read unload true program obtained pushout programs init section iii x program corresponding system consisting two carts one loader one unloader obtained computing colimit following diagram shows role instantiation morphisms connectors name glues components synchcrossing slow fast inhibitcrossing fast loader 3 load unload ggo unloader 4 synchcrossing fast slow inhibitcrossing fast notice binary connectors dealing crossings symmetric distinguish cart supposed nearer crossing therefore one must apply connectors twice pair carts v concluding remarks shown fundamental kinds transient interactions inspired mobile unity 9 10 represented using architectural connectors semantics given within categorical framework approach illustrated unitylike program design language 3 4 argued 3 12 general benefits working within categorical framework ffl mechanisms interconnecting components complex systems formalized universal constructs eg colimits ffl extralogical design principles internalized properties universal constructs eg locality names ffl different levels design eg signatures programs related functors work particular synergy software architecture category theory resulted several conceptual practical advantages first systems constructed principled way interaction kind connector template instantiated actual interaction conditions instantiated connectors applied interacting programs thus forming system architecture visualized diagram program corresponding overall system obtained compiling ie computing colimit diagram second separation computation coordination already supported software architecture reinforced two facts one hand glue connector uses signatures interacting programs bodies hand superposition morphisms impose locality principle third capture transient interactions morphism program actions changed syntax semantics language remained two ways dealing architectures mobile components system limited mobility limited number different component types possible interaction patterns foreseen thus static architecture possible interconnections represent system cope systems greater degree mobility one must evolving architectures components connectors added removed unpredictably paper inspired mobile unity follows first approach future work address second approach one ideas wish explore remove interaction condition glues actions instead associate application whole connector diagram system architecture thus becomes dynamic moment including connectors whose conditions true another possibility apply graph rewriting techniques system diagrams third venue change definition morphism represent notion changesto instead componentof words morphism form p p 0 indicates p may become moment ideas capture software architecture evolution categorical setting suitability validity must investigated acknowledgements would like thank antonia lopes many fruitful discussions anonymous referees suggestions improve presentation r special issue software architecture perspectives emerging discipline parallel program designa foundation semantics architectural connectors basic category theory computer scientists mobile unity reasoning specification mobile computing mobile unity language logic concurrent mobile systems towards general location service mobile environments tr ctr michel wermelinger cristvo oliveira community workbench proceedings 24th international conference software engineering may 1925 2002 orlando florida performance evaluation mobilitybased software architectures proceedings 2nd international workshop software performance p4446 september 2000 ottawa ontario canada michel wermelinger antnia lopes jos luiz fiadeiro superposing connectors proceedings 10th international workshop software specification design p87 november 0507 2000 antonio brogi carlos canal ernesto pimentel semantics software adaptation science computer programming v61 n2 p136151 july 2006 antnia lopes jos luiz fiadeiro michel wermelinger architectural primitives distribution mobility proceedings 10th acm sigsoft symposium foundations software engineering november 1822 2002 charleston south carolina usa antnia lopes jos luiz fiadeiro michel wermelinger architectural primitives distribution mobility acm sigsoft software engineering notes v27 n6 november 2002 andrea bracciali antonio brogi carlos canal formal approach component adaptation journal systems software v74 n1 p4554 january 2005 lus filipe andrade jos luiz fiadeiro agility coordination information systems v27 n6 p411424 september 2002 marco antonio barbosa lus soares barbosa orchestrator dynamic interconnection software components electronic notes theoretical computer science entcs 181 p4961 june 2007 michel wermelinger jos luiz fiadeiro graph transformation approach software architecture reconfiguration science computer programming v44 n2 p133155 august 2002 michel wermelinger jos luiz fiadeiro algebraic software architecture reconfiguration acm sigsoft software engineering notes v24 n6 p393409 nov 1999 antnia lopes jos luiz fiadeiro adding mobility software architectures science computer programming v61 n2 p114135 july 2006 dianxiang xu jianwen yin yi deng junhua ding formal architectural model logical agent mobility ieee transactions software engineering v29 n1 p3145 january
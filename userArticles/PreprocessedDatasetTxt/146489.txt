lessons learned suit simple user interface toolkit recent years computer science community realized advantages guis graphical user interfaces highquality guis difficult build support tools uimss ui toolkits interface builders developed although tools powerful typically make two assumptions first programmer familiarity gui model second willing invest several weeks becoming proficient tool tools typically operate specific platforms dos macintosh unixxwindows existing tools beyond reach undergraduate computer science majors professional programmers wish quickly build guis without investing time become specialists gui design class users developed suit simple user iinterface toolkit suit attempt distill fundamental components interface builder gui toolkit explain concepts tool short period time measured college juniors previous gui programming experience use suit productively less three hours suit c subroutine library provides external control uims interactive layout editor set standard widgets sliders buttons check boxes suitbased applications run transparently across macintosh dos unixx platforms suit exported hundreds external sites internet paper describes suits architecture design decisions made development lessons learned extensive observations 120 users b introduction practice experience paper describes experience suit simple user interface toolkit recent years support tools building guis called uimss ui toolkits interface builders gained popularity heavily skewed towards programmers willing invest large amount time mastering tools appropriate many professionals field extended learning curves make prohibitive undergraduate students programmers wish build guis wish invest weeks mastering tool base gui building tools deceptive providing interactive builder provides mousebased interface editing obscure fact programmer familiar callback model guis attempting attach functionality screen components extremely confusing academia exposing students good guibuilding tools speciality item graduate level graphics course mainstream courses undergraduate software engineering projects courses unfortunately courses cannot sacrifice several weeks order teach concepts hidden inside gui model afford luxury allowing students several weeks master complicated gui tools outside academia similar situation exists many professional programmers specialize gui design often need quickly build graphical front ends various application software never take time master complex gui development tools suit simple user interface toolkit attempted distill essential components good gui building tools provided essentials form used programmers come prepared nothing competency c programming language goal provide new capabilities guibuilding realm combine existing techniques clean design learned quickly respect hope suit provide contribution interface builder community pascalwirth programming language community certainly heard many older gui programmers comment current state art gui tools similar programming languages 1960s 1970s motif widget set example exhibits many interference features problems pli suit succeeds providing new silver bullet idea making dozens independent design decisions taken combination produce system easy novice gui programmers learn design methodology relatively straightforward willing rewrite implementation many times perform stringent user testing every phase iterative fashion willing sacrifice well known design principles ease use face evidence user observation performed direct observations one hundred twenty separate users within two year time span suits development end result ten page tutorial requires new users spend 15 3 hours learning use suit time begin using suit programs choice vast improvement four six week learning curve observed students systems like xtk mccormack andrew tool kit palay interviews calder motif widget set suit also provides one hundredsixty page reference manual much also available via online help design approach throughout suits development applied following principles exploit knowledge skills user already make easy things easy hard things possible perform enduser testing early often current ui toolkits uimss tend violate first point forcing users learn new programming language example next interface builder mahoney requires learning objective c interviews requires learning c languages required support model system provides users focused task hand often fail use advanced tools learning threshold languages high design strategy leverage existing skill could assume users would ability program c therefore anything could specified suits interactive tools would done user write c code also acknowledged early new concepts needed users understand inheritance information classbased objectoriented model suit would teach via interactive tools final design goal looked production ten page written tutorial would walk new user system explicitly chose written rather onscreen tutorial format two reasons first limited resource screen realestate putting tutorial paper reduced demand screen space second reason wanted avoid confusion tutorial areas real areas screen using paperbased tutorial could use suit screen layouts without problem argue onscreen tutorials appropriate many applications felt suits target audience paperbased tutorial would superior last design constraint type users targeted testing software working best students even average students interested guis would mistake wanted target users creating guis means end end therefore used captive audience students undergraduate software engineering courses assigned projects required guis would graded overall result effort gui small fraction constantly observing new users able maintain perspective difficulties new users face trying understand suit model sort user testing well understood corporate cultures notably apple computer technique also used great success development trillium blomberg architecture section gives highlevel description suits internal architecture describes suits basic data model begin discussing platform portability cover several popular ui builder models suits definition object suits interactive tool set suit composes links objects together user interface toolkit requires three basic forms support implementation language operating system support graphics package implementation language either c pascal since languages widely known undergraduates although pascal widely used simpler c implementing suit pascal technologically feasible pascal exists three platforms varies widely welsh also standard pascal powerful enough support external control model lacks ability store function addresses variables therefore chose ansic operating system dependency small needed able read write ascii text file standard c io libraries always support graphics needed common lowlevel graphics package supported operations drawline drawfilledcircle platforms surprised find graphics packages implemented three platforms researchers contacted said always ported platforms implementing small compatibility libraries specific graphics commands used applications made porting systems unnecessarily timeconsuming determined would use welldefined common graphics layer beginning project chose use srgp simple raster graphics package distributed addisonwesley publishing company second edition fundamentals interactive computer graphics foley van dam feiner hughes foley90 srgp already implemented macintosh x windows ported turbo c dos top borlands bgi graphics driver dos version srgp distributed textbook figure 1 shows software layering makes suit portable srgp several drawbacks overcome provide wider range functionality layered thin graphic package called gp graphics package top srgp gp allows widget authors avoid screen coordinates providing arbitrary floating point coordinate systems performing standard window viewport mapping addition gp converts mixed sampleevent input model srgp strict event model mouse motion treated discrete event gp also provides color font naming layer color font table values properly set across different platforms gp already providing support fonts augmented drawtext primitive implement small extensible language special characters effects including itext example text btext example text utext example text text example text text example text long suitbased applications restrained choice fonts number colors use applications port across macintosh dos unixxwindows platforms suit simple user interface toolkit srgp simple raster graphics package machine mac toolbox macintosh bgi driver figure 1 layered software portability gp graphics package identical lookandfeel remaining point potential inconsistency number buttons mouse suits interactive tools assume onebutton mouse recommend applications although provide access whatever mouse buttons provided current hardware one feature gp handling colors graphics packages application developed color display ported monochrome display various artifacts appear consider figure 2 red arrow drawn green background systems drawn monochrome display nonwhite colors would map black gps solution define color primitive pair color monochrome appearance purple black suits interactive tools used set objects color set color chips appears color screen toggle button appears monochrome screen different approach portability taken xvt valdes rochkind provides virtual toolkit top native toolkit layer platform advantage xvt approach platform application look feel applications built locally platform two major drawbacks approach first xvt forced provide functions common platforms lowest common denominator solution second user must use different support tools eg layout editors platform suits data model user interface toolkits compiled languages use code dumping model user runs builder application interactively lays screen interface look like exits builder program dumps skeleton program user edits interior callback figure 2 colors monochrome red green routines called user interface actions button press occur motivation code dumping programs vast majority code interact screen widgets ugly mechanically generated drawback dumping code user ever wishes go back change say location color button builder program must able parse back code dumped course requires preventing user editing dumped code although usually done dumping callback skeletons separate files code regarding things like object creation code dumping model also awkward make change interface programmer must fire separate builder application drag button new location dump new code recompile relink rerun application suit uses different model fact fair say suit best understood thought subroutine library provides front end database serpent system uses similar approach bass database maintains information screen objects location color application exits suit writes database permanent storage application next invoked suit queries database see objects go color make interested platform portability would used xresources file permanent storage instead write separate file called foosui application named foo applications programmers create objects making calls void hisuitobject obj printfhello worldn suitcreatebuttonhello hi creates screen button attaches callback function called button pressed first time program runs button screen location appears random location screen application running provide ability interactively lay widgets screen later user moves button suit records location database upon exit database written disk next time program runs suitcreatebutton call create button examine database find screen location stored previous execution thus interfaces modified time program running suit provides collection screen objects object described state contained property list c procedure examines objects state displays screen c procedure handles user input object updates objects state property list containing objects state set name type value triples label text pizza diameter floating point 105 number slicesinteger 6 anchovies boolean false users understand suitbased application collection objects introduce external control explaining suit maintains table onscreen objects database suit maintains suit multiplexes keyboard mouse input based location cursor users quickly understand three different slider objects share code input handling display procedures distinct property lists state table contents table written humanreadable ascii text file executions program users understand suit maintains table objects explain suits interactive tools provided accepting users input commands suit rather particular screen object user input occurs suit queries state control shift keys mouse buttons pressed suit interprets input command move resize screen object updates object table accordingly use keyboard modifiers allows us avoid run versus build mode used interface builders next interface builder avoiding mode switch important new users experienced almost cases users confused giving input suit giving input application combination shift control chosen pragmatic reasons window managers grab combination default two keys users easily locate main loop suitbased application looks like forever wait input event handle suitcommand figure widget call input handler paint objects whove changed suit maintains needs repainted bit next object properties object change suit sets bit bottom loop needs repainted objects repainted bits reset provides two important sources repaint optimization first object would change several times one pass loop painted second avoid repainting altogether repainting object properties changed grasped external control works many users find mildly unsettling become accustomed using flow control programs sequence actions users however find external control nearly difficult first introduction either pointer variables recursion users understand basic mechanism drives suit explain standard set screen objects already implemented stored library motivates question screen objects made invoke application procedures callbacks example slider users understand input handler painting procedure cause slider behave properly sure application routine informed value contained slider changed explain callback function added slider objects property list property exists input handler calls function changing state slider object attachment userlevel callbacks difficult intellectual leap users final comment external control originally implemented suit strictly external control applications main procedure looked something like course one objects usually done button would call exit function terminate program added support internal control applications adding routine would check see mouse keyboard input occurred applications test whatever application wanted extremely important applications especially needed poll realtime devices underscores fact internal versus external control necessarily large difference objects abstract data types many students tend confuse notion objects state mechanisms affect state good success combating treating objects abstract data types multiple mechanisms displaying state example suit supports bounded value object properties minimum value floating point 00 current value floating point 07 maximum value floating point 10 appear following display styles sibert foley86 shown figure 3 command keyboard modifiers cycles various display styles effective establishing difference objects state mechanism displaying altering state many students visceral experience understanding general concept abstract data type user defined property types users may define types use property lists registering subroutines suit initialize copy destroy convert type ascii convert ascii type ascii conversion allows suit write interface file saved executions convert one arbitrary type another going ascii representation users may also register custom widget interactively edits type class mechanism subclassing inheritance complex ideas first show students suit explain suit provides collection screen objects belongs one class inherit portion state class motivating class inheritance mechanisms find figure 3 bounded value display styles scroll bar speedometer vertical thermometer pie slice horizontal thermometer necessary briefly lie students ready appreciate real reasons course based issues modularity abstraction upon weaker undergraduates tenuous grip students understand concrete explanations much better abstract ones understand concept one revisit motivation therefore explain object store values possible property wasteful especially many widgets often value property although storage savings really concern us provide motivation students readily accept program requests value property suit looks first property list containing objects state suit find requested property looks property list stored objects class property found level suit looks global property list property found global property list suit creates using types initialization routine establish default value property editor students best concrete visible items screen objects good explaining objectoriented programming shown early success smalltalk goldberg problem class global property lists longer implicitly visible prototypeinstance architecture myers90 really solve problem prototype objects typically visible onscreen provide direct manipulation schneiderman property editor allows users interactively examine alter state objects suit property editor shown figure 4 always displays object class global property lists allowing user edit state object users alter propertys value clicking property mouse boolean properties toggle clicked properties either bring typein box typespecific dialog box dialog box type font shown figure 5 object currently inheriting value class figure 4 property editor 1 object properties poly activedisplay standard stan filled foregroundcolor green visible yes 3 global properties animated backgroundcolor grey bordercolor grey borderraised yes bordertype motif simple cliptoviewport yes drawborderoninside foregroundcolor black 2 class properties polygon filled yes visible yes trash figure 5 font panel1218new century charter courier helvetica lucida times bold italic quick brown fox jumped user take property value drag class level object level thereby copying property currently specified object level user wishes property default class specification user drags property object level trash deleting object level property way properties manipulated global level exercise suit tutorial asks reader make labels application blue one particular label override default red property sheets date back least xerox star bewley systems use spreadsheet model accessing attributes objects myers91 wilde contribution always expose fixed three levels every invocation produces screen clutter also avoids student learn mechanisms accessing inherited state property editor tremendously successful allows students understand use state inheritance less five minutes believe due combination limiting class hierarchy single level exposing information three levels using direct manipulation systems suns devguide use custom panels widget class rather scrollable list properties suit property editor drawback using custom panel per widget class either requires authors new classes create panels hand requires system provide automatic layout tool arbitrary set properties task beyond current systems power suit user defines new widget class property editor work automatically class linking objects objects default suit provides simple linkage mechanism applicationlevel callbacks registered objects callbacks invoked input handlers screen objects complicated problem provide general linkage mechanism screen components arbitrary user routines next interface builder solves problem allowing user draw connection two screen objects prompting user specify details linkage via sequence dialog boxes suit provides simpler limited form linkage handles large number common cases avoids novices usual confusion whether first object linked second second linked first many linkages onscreen objects merely allow one object control particular aspect property another example polygon drawing program figure 6 slider controls number sides polygon rather attempting link two existing objects suit user would start polygon object invoke property editor user would drag number sides property export icon picture moving van causes suit create new object controls property also side effect locking property shown small lock icon property editor avoids ambiguous situation user modifying polygons number sides property editor exporting fact program shown figure 6 created programming starting blank screen user creates polygon object via menu standard objects exports polygon objects number sides filled properties similar fashion export icon info icon used gain information property users drag property icon get online help describing data type property textual description property used hierarchy interface toolkits novices confuse logical tree subclasses geometric tree visually nests objects avoid problem suit limiting classes one level hiding geometric hierarchy novice users aside motivation providing rich subclasses objects somewhat weak may help implementor toolkit users toolkit want figure application polygon drawing program done know class button derived class label order use properly theory make easier create custom widgets subclassing existing ones discussions motif users revealed find process frustrating helpful although basic suit objects actually hierarchical collections objects provide procedural interactive operations treat objects atomically providing interactive tools allow users move resize multiple objects one time sidestep motivation novices wanting compose basic objects hierarchy users comfortable basic system introduce interactive manipulation hierarchy suit allows users create composite object geometrically contains objects one type composite object bulletin board rearrangement children another stacker vertical horizontal tiling display styles vboxes interviewstex terminology third pull menu hides children pressed screen objects nested within composite object dragging inside object nested composite objects new users often delighted discover place clocks sliders pulldown menus objects inside composite object ambiguity object receive input regular input simple input handler outer object merely passes input appropriate child input directed towards suits interactive tools attempt move object problematic resolved allowing user open composite widget object open suit draws special border around indicate children outer object receive suit commands child moved outside boundaries geometric parent becomes autonomous moving sibling parent geometry tree geometric hierarchy adds semantic complexity several ways first property lookup affected button inside pulldown menu specify color color class buttons geometric parent pulldown menu one correct answer one could implement flag per property object indicating specified look parent class provides possible options cost implementation intellectual complexity instead suit uses simple rule object specify property look first classs property list still find property walk parent chain answer found class property lists ancestors consulted concede arbitrary decision solutions employees suit object represents abstract data type multiple representations called display styles display styles may simple may composed suit objects display style consists objects objects known employees display style figure 7 shows display styles bounded value object speedometer thermometer display styles simple employees scrollbar display style three employees two arrow buttons elevator employees display style appear object display style one cycles bounded value object scrollbar thermometer scrollbars three employees longer needed suit implemented visibility invisible objects suit neither painted sent input one cycles object one display style another employees old display made invisible new display made visible chose change employees visibility rather create destroy necessary employees properties would retained user cycles away display style back terms geometrical composition employees similar children children employees move resize parents may inherit parents properties difference child exists parents display styles employee exists one make distinction clear consider possible implementation object allows user figure 7 employees display styles scroll picture one display style might use scrollbars along axis represent portion picture currently viewed another might use panner object rectangle within another rectangle represent information implementation picture object would child since would necessarily every display style scrollbars would employees first display style panner would employee second practice employees rarely used object suits standard library uses scrollbar mentioned two main reasons first abstraction sufficiently complicated merit breaking several component objects often one good way represent abstraction thus object would one display style object one display style need employees second reason use suit build applications usually particular interface mind therefore design one display style objects one display style makes employees unnecessary last portion architecture supports semantic linking state many systems garnet support constraint model programmer specifies relationship remain true system ensures example programmer make one object stay another screen establishing constraint viewports suits model similar allow programmer register interest object specifying procedure call time property object changes procedure called parameters indicating object question name property changed old new values interest routine set properties object fact suit makes sure buttons size text registers interest button label property button changes suit recomputes new viewport property based size text behavior could implemented specialized constraint language believe simply writing subroutine c straightforward way establish relationship wish maintain string button buttons viewport experience users next two sections important contribution based experiences users changes system motivated two sections delineated whether change programmer interface data model set interactive tools provided interface builder begin lesson learned programmers interface important observation defeated one front general idea callbackbased programming something never able tool teach part process able write fourpage addition read tutorial makes possible students understand external control hindsight surprised external control showstopper college juniors introductory programming courses stress writing programs whose execution paths closely follow order statements read source code callback functions typically covered subroutines take functions parameters fact ansistandard pascal external control even possible function pointers cannot stored variables best undergraduates accustomed encoding state flow program great difficulty adjusting model writing small fragments called order time fact common coping strategy saw single buttons callback procedure encapsulate huge chunk program functionality students also tended towards moded interfaces attempted force user dialog step trying mimic commandline prompt interface within gui custom widget authoring another major observation although creating new widgets relatively painless suit early versions tutorial students found students went great extremes avoid writing custom widgets end result positive whether motivated fear laziness good software engineering principles students reuse existing code wherever possible students write custom widgets saw two major recurring problems first common problem using coordinate systems abstract floating point world coordinate system much easier flexible students expected concrete things almost always easier grasp abstract ones students uniformly expressed desire draw screen pixels however students written several custom widgets usually began appreciate abstract coordinate system second major problem custom widget authors general lack understanding database model input procedures change properties database paint procedures may examine database division caused major problems almost every student attempted paint within input procedure considered mechanically disabling graphics library routines calling users input handler reenabling call painting inside hit procedure would trigger runtime error abandoned probably wouldnt helped student understand wrong students able write programs without creating custom widgets attempted create custom widgets often difficulty based two facts removed section tutorial creating custom widgets students needed create custom widgets eventually provided example program created simple widget students much successful modifying program meet needs working clean slate make easy things easy several places able apply design principle make easy things easy hard things possible first moded interaction techniques dialog boxes grabbed input focus required answer user screen objects would accept input identified commonly requested cases provided simple functions suitinform char message suitaskyesnochar question suitaskokcancelchar question suitaskyesnocancelchar question suitaskchar question char answer1 char answer2 addition provided one generalpurpose moded dialog box passed arbitrary suit object parameter nests okcancel dialog box allows user interact widget user presses either ok cancel button routines seemed meet users needs moded dialog boxes another common case found need users found dynamic interaction techniques rubber banding lines dragging objects around screen provided simple routine xord rectangle current mouse position long button stayed final screen coordinate would functionally returned combined utility function suitobjectatxy made easy users implement simple draganddrop techniques dragging objects trash addition rectangle drag provided text string drag routine general purpose drag routine called application callback time mouse moved time rule thumb anything one sees screen part suit interface stored database restored next time application run instances desirable example applications makes sense scrollable lists return top list retain old location support added calls make particular properties temporary similar fashion entire object could declared temporary meaning none state would saved application invocations name space issues like dynamic systems rapidly developed problem due lack static checking name spaces example property names suit character strings searched run time using string compares since users need declare property using common user error would misspell propertys name thus generating new property default value classic story involved one poor student trying remove border object spent several hours trying figure line code suitsetbooleanmyobject boarder false effect misspelling border property student created new boolean property never examined common problem lispbased systems garnet accidental slot creation problem users often need create new properties kept flexibility avoided misspelling problems suitprovided properties using c preprocessor including lines define hasborder border suith include file suitprovided property name standard set combined decision make string compares suit caseinsensitive effectively solved dynamic name space problems programmer issues certain conditions became necessary prohibit user altering property via property editor example uses tended randomly play various global level properties often causes problems therefore locked properties user could longer change interactive property editor remaining semantic question whether would also prohibit application programmer setting property rejected idea two different lock bits per property specify cases programmer also ability query whether properties locked lock unlock decided make lock prohibit interactive user changing property worked well practice beginning felt important support animation toolkit demonstration programs provide bouncing balls move constant twenty pixels per second regardless speed underlying hardware hardware slow balls appear lower number intermediate positions motion choppier hardware fast motion appear smoother order support needed provide deviceindependent suitgetcurrenttime function added gp since convenient layer also found useful support boolean animated property widgets true suit would automatically call objects paint procedure whether objects properties changed interactive tool observations present variety insights gained watching people use suits interactive tools gathering feedback gathering feedback experts relatively easy encouraged users send electronic mail suit account questions comments mail received able deduce parts suit causing programmers trouble therefore parts needed fixing better documentation gathering feedback novices comparison much harder real way find parts suit hardest novices learn give suit tutorial novices watch work standard observation protocol seat pairs students unix workstations observer suit team sitting behind silently taking notes session pairing students vital part observation two people told work together talk often saying going minds work tutorial forces open dialog one person would entirely internal eavesdropping pair collaborating students learn parts suit tutorial new users find easy parts cause confusion suits design changed innumerable times difficulties saw silent observation sessions keeping observers quiet observations crucial one reason user testing hard observer often influence observed problem quite familiar anyone designs surveys especially true often suit implementors observation maintained strict policy sitting hands observations circumstances observers allowed get chairs help users get bind suit tutorial put required observers deliver standard apology im sorry wrote bad software let help needless say observers remained seated tested suit tutorial often possible many people could often meant living kindness professors department teaching software engineering gave us pool approximately 45 students per semester one class alone classes gave us opportunities test software novices large number people went user testing process video taping never practical alternative real live observation would like note everyone benefits massive user testing experience observers benefit experience learning take notes observant observed benefit kind cultural lesson computer scientists really field test part craft programmers benefit relearning parts software confuse new users user testing electronic mail advanced users yielded great deal practical knowledge summarize three categories suits basic feedback techniques suits different interaction techniques suits methods creating composing widgets feedback techniques xor dangerous useful technique moving graphics interactively found xor nearly portable one might imagine platforms define bit representation black zeros effect xor mode solution always use representation ones color xor black provided native graphics environment platforms color displays xor problem even worse due fact result xor operation illdefined color xoring two colors results third color value depends values loaded color table cannot predicted often found got lucky course anything change color table sometimes suit xors faint blue line onto light grey background take care drawing handles suit uses standard feedback technique drawing handles objects selected purposes direct manipulation operations eg resize convention drew handles small black squares corners edges whatever objects selected users complained sometimes would draw squares parts widgets already black meaning handles essentially invisible black black choosing color clearly solution merely transferred problem someday drawing red red blue blue eventually solved problem outlining black handles 1 pixel wide white border producing handle visible circumstances learned sometimes best answer interface problem isnt engineering graphic design animation draws attention raises expectations use animation suit way drawing users attention particular part screen especially abrupt change interface animation effect saying look changed example user creates new widget interactively suit animates rectangle collapses edges window toward center screen new widget appears much way macintosh animates rectangle new folder opened suits export icon also animates property exported truck drives icon feedback property exported charmed users saw users disappointed icons buttons didnt animate whether whimsical charm moving truck different warrant removal matter debate interaction techniques muscles modes suit unlike interface builders separate run build modes suits interactive tools present program runs blurring difference running building distinguish events meant application meant suit use keyboard modifier shift control keys held mouse clicked send event suit otherwise event passed application unlike moded interface chances confusing run build mode zero user holding shift control keys constant reminder youre talking direct manipulation beats menus design suits property editor originally used cut paste menu driven model dreadful results changing property entailed clicking property accessing menu choose desired operation perform move property level move level delete etc temptation drag property order move copy delete overwhelming menus always seemed put properties arms length user eventually abandoned menus favor direct manipulation style editing direct manipulation users could simply click property produce widget allowed edit propertys value example clicking color property produced selection colors choose clicking font produced listing available faces sizes styles text properties type break click get dialog box press ok accept change model interaction clicking text property wraps type field around currently displayed characters value property clearly irregularity one seen benign exception rule rather strict adherence consistency opted keeping users attention focused string already looking rather producing dialog box part screen moving property class level object level done familiar drag drop action users clearly liked style better old menu move level command users also showed testing trouble understanding dropping property info widget produced dialog box information property dropping trash deleted turns presence trash implied power suit didnt first possess observed users extended drag drop metaphor minds apply whole widgets well properties many tutorial observation trials users dragged widgets trash startled discover nothing happened seems users understood concept regularity always saw property editor place properties dragged place place widgets many people tried delete widgets property trash added feature users happy extending principle also provided help strings widgets dropped info widget dropping widget export button still nothing semantics well defined providing harmless useful level functionality obeyed law least astonishment expense purity model creation composition users liked export user drops property onto property editors export widget suit creates widget corresponding type property color properties produce color chips text properties produce text entry widgets etc widget controls value property exported provides short cut fullblown property editor giving user single widget application interface controls value property ability seen many users way avoiding fair bit uninteresting code applications interactive widget creation demos decoration always impressive demo ability create new buttons sliders fly really useful items act merely decoration labels nicely added items attached functionality must specified suit based c run time binding would much harder lisp based system like garnet suit would need compile link code fly something lisp based system need worry user creates button interactively attach callback function usually attaching callback done creation call button already created present way hand programmer opens c source code file makes function call attaches function pointer button referring button unique string name provided widget created interactively spelling name incorrectly results fatal run time error practical matter suits interactive creation widgets really use widgets functionality labels place mats rectangles exist purely show composition widgets beginning saw need composition widget widget whose purpose contain widgets fit whimsy dubbed new widget type tupperware tupperware seen general purpose container class could used horizontal vertical stacking geometry managers pulldown menus dialog boxes type widget might contain widgets minds distinction different screen objects way displayed subordinates children suit parlance therefore implemented tupperware class display styles bulletin board menu vertical stacker horizontal stacker users saw things differently menu bulletin board dialog box two different things pretending served confuse turned difficulty maintaining code behemoth widget reimplemented several different widgets removed bugs cleared waters considerably users cleanliness model sacrificed learning curve user base conclusions using reduced model subclassing hiding geometric hierarchy providing direct manipulation tools property setting linkage able radically reduce learning time complexity user interface toolkit keeping toolkits implementation lightweight building top easily ported graphics package able implement suit wide variety platforms college juniors familiar external control never seen another ui toolkit able use suit productively roughly two half hours undergraduate software engineering class projects able expand scope significantly using suit students highly motivated able easily produce professional looking interfaces projects best validation tool like suit used external sites must rely printed documentation limited correspondence via electronic mail time writing suit ftpd 100 external internet machines adopted use undergraduate courses number universities professional research laboratories also finding suit attractive often case powerful tool easy novices use often attractive experts well original desire merely produce tool would introduce students relatively difficult concepts specifically external control inheritance presumed spending weeks suit would outgrow move mature complex systems uimx uimx based motif widget set interviews instead observed phenomenon also occurred pascal unless students discovered specific need move advanced platform continued use suit research projects major regret implemented geometrically hierarchical widgets doubled complexity system estimate end value users less five percent paper presented final incarnation suit important remember suits development continuous iterative process dozens versions released tested feedback real students acknowledgments would like thank roderic collins jim defay pramod dwivedi brandon furlich rich gossweiler drew kessler james leatherby chris long william mcclennan kim passarella anne shackelford hansmartin werner nathaniel young contributed suits development would also like users especially anita jones marc brown allowed us use students guinea pigs early versions suit would also like acknowledge help anonymous referees whose comments led substantial improvements paper suit confused suite dewan project purdue similar name getting suit suit provided without charge academic nonprofit organizations readers access internet type finger suituvacscsvirginiaedu directions get run software r serpent user interface environment human factors testing design xeroxs 8010 reflections participatory design lessons trillium experience composing user interfaces interviews guide suite computer graphics applications 63 computer graphics principles practice 2nd edition interface builder objectoriented design nextstep environment overview x toolkit garnet comprehensive support graphical graphical techniques spreadsheet specifying user interfaces andrew toolkitan overview technical overview extensible virtual toolkit step beyond programming languages objectoriented user interface management system user interface management toolkit x virtual toolkit windows mac ambiguities insecurities pascal graphics prototype tool programming language pascal tr objectoriented user interface management system overview x toolkit composing user interfaces interviews computer graphics principles practice 2nd ed garnet spreadsheetbased interactive graphics prototype tool reflections participatory design lessons trillium experience graphical techniques spreadsheet specifying user interfaces human factors testing design xeroxs 8010 myampersandldquostarmyampersandrdquo office workstation ctr matthew conway steve audia tommy burnette dennis cosgrove kevin christiansen alice lessons learned building 3d system novices proceedings sigchi conference human factors computing systems p486493 april 0106 2000 hague netherlands saul greenberg teaching human computer interaction programmers interactions v3 n4 p6276 julyaug 1996 jacob eisenstein jean vanderdonckt angel puerta applying modelbased techniques development uis mobile computers proceedings 6th international conference intelligent user interfaces p6976 january 1417 2001 santa fe new mexico united states sven ubik possibilities using protocol converters nir system construction acm sigcomm computer communication review v27 n2 p3748 apr 1997 caroline appert michel beaudouinlafon smcanvas augmenter la bote outils java swing pour prototyper des techniques dinteraction avances proceedings 18th international conference association francophone dinteraction hommemachine p99106 april 1821 2006 montreal canada brad myers scott e hudson randy pausch past present future user interface software tools acm transactions computerhuman interaction tochi v7 n1 p328 march 2000 brad myers user interface software tools acm transactions computerhuman interaction tochi v2 n1 p64103 march 1995
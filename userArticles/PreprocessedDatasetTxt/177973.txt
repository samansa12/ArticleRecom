reducing indirect function call overhead c programs modern computer architectures increasingly depend mechanisms estimate future control flow decisions increase performance mechanisms speculative execution prefetching becoming standard architectural mechanisms rely control flow prediction prefetch speculatively execute future instructions time computer programmers increasingly turning objectoriented languages increase productivity languages commonly use run time dispatching implement object polymorphism dispatching usually implemented using indirect function call presents challenges existing control flow prediction techniques measured occurrence indirect function calls collection c programs show although important predict branches accurately indirect call prediction also important factor programs grow importance growth objectoriented programming examine improvement offered compiletime optimizations static dynamic prediction techniques demonstrate compilers use existing branch prediction mechanisms improve performance c programs using methods programs examined number instructions mispredicted breaks control doubled existing computers b introduction design computer architectures languages tightly en twined example advent register displacement addressing enabled efficient implementation algol increased use cobol emphasized use bcd arithmetic likewise c paper appeared acm principles practice programming lan guages portland oregon 1994 fortran languages become ubiquitous strongly influenced risc processor design objectoriented programming recently gained popularity illustrated widespread popularity c objectoriented languages exercise different aspects computer architectures support objectoriented programming style paper examine indirect function calls used support object polymorphism influence performance efficient object oriented language modern architectures using deep instruction pipelines speculative execution rely predictable control flow changes indirect function calls cause unpredictable changes program control flow example dec alpha axp 21064 processor one first widelyavailable deeply pipelined superscalar microprocessors stalls 10 instructions processor mispredicts flow control increases mispredicted target instruction cache must fetched systems increasingly rely speculative execution 19 16 importance control flow prediction increase programs conditional branches introduce main uncertainty program flow architectures use variety branch prediction techniques reduce instruction cache misses insure instructions available processor pipeline function calls specify explicit call targets thus function calls trivially predicted control flow prediction important objectoriented programs languages tend use indirect function calls address call target loaded memory fisher et al 12 said indirection function calls unavoidable breaks control compiler hardware tricks could allow instructionlevel parallelism advance past accurately predicting calling address processor reduce instruction stalls prefetch instructions results show accurately predicting behavior indirect function calls largely eliminate controlflow misprediction penalty using statictyped objectoriented languages c figure 1 shows normalized execution time variety c programs measured number instructions executed program collected information concerning conditional branches indirect function calls executed program although measured programs decstation 5000 simulated branch misprediction characteristics deeply pipelined superscalar architecture similar dec alpha axp 21064 program bar indicates number machine cycles spent executing instructions suffering delay imposed mispredicting control flow different assumptions value 1 indicates program spends additional time due delays value 2 indicates program would execute twice slowly leftmost bar indicates delay would incurred every control flow change incorrectly predicted prediction next bar indicates increase execution conditional branches predicted using static profile based prediction next three bars indicate decrease execution time branches indirect function calls correctly predicted using three different techniques described paper programs measured found could improve performance 224 using simple techniques final improvement depends number indirect function calls program libraries used underlying architecture architectures deeper pipelines issue instructions per cycle would evince greater improvement interested reducing cost indirect function calls icalls modern architectures compiler determine unique likely call target indirect function calls converted direct calls unique call targets likewise compilers may choose inline likely unique call targets inlining icalls reduces number function calls exposes opportunities optimizations better register allocation constant folding code scheduling like however type inferencing c programs nphard problem 22 difficult integrate existing compilers becauseaccurate type inference requires information entire type hierarchy information typically available programs linked implying typedetermination algorithms require linktime optimization interested subtle optimizations mod est albeit respectable performance improvement many optimizations code transforms rely modifying existing program executable possibility assisting compiler profilebased optimizations began study asked following questions ffl could predict frequently compilerbased methods could eliminate indirect function calls ffl accurate profilebased prediction dynamic prediction methods accurate ffl use existing branch prediction hardware predict indirect function calls ffl effective combinations prediction techniques type compiler optimizations applied towards indirect function calls order improve performance date experimentation hasdemonstrated although objectoriented libraries support object polymorphism target indirect function calls accurately predicted either prior runs program programs execution furthermore many existing c programs optimized navely linker using information c type system optimization examine involves converting indirect function call calls unique function name direct function call sophisticated compilers linktime code generation significant optimization opportunities exist lastly compiler optimization term icall conversion used increase performance indirect function calls information used simple profilebased binary modification improve execution existing c programs 224 modern architectures measured behavior variety publicly available c programs collecting information instruction counts function calls information also part larger study quantify differences c conventional c programs 7 study show call prediction important many c programs show extent static dynamic compile directed methods reduce indirect function call overhead also demonstrate opportunity profilebased optimization c programs measured theseoptimizations profitably applied existing architectures incur significant controlflow misprediction penalties results present divided two portions first considers applying hardware branch prediction mechanisms existing c programs second considers additional profile based optimizations applied c programs x2 discuss relevant prior work x3 describe experimental methodology used describe programs instrumented measured x4 compare various icall prediction mechanisms studied summarize improve performance existing c programs considerable amount research conducted reducing overhead method calls dynamically typed objectoriented languages many solutions relevant domain apply optimization compiledlanguagesusing icalls c discuss shortly furthermore numerous researchers examined similar issue reducing branch overhead since function calls branches alter control flow considerable overlap work yet substantial differences well one difference conditional branch two possible targets indirect function call large number potential targets measured programs 191 different subroutines called single indirect function call makes branches easier predict dynamic branch prediction mechanisms achieve 95gamma97 prediction accuracy 21 27 29 level accuracy needed superscalar processors issuing several instructions per cycle 28 relevant prior work predicting destination indirect function calls hardware conducted david wall 26 examining limits instruction level parallelism states little work done predicting destinations indirect jumps might pay instructionlevel parallelism simulates static profile based prediction infinite finite dynamic last call prediction finds accurately predict icall destinations however benefit icall prediction minimal examined c fortran programs go beyond research 1 showing icall prediction important programs 2 compiletime optimizations combined static profile based prediction increase programs congress doc idl idraw groff morpher rtsh10normalized number instructions branches branches icalls branches icalls unique branches icalls unique conv figure 1 normalized execution time various c programs including expected instructions stalls due mispredicted control flow computer similar dec alpha axp 21064 performance 3 simple techniques yield accurate icall prediction rates 4 indepth comparisonbetween different static dynamicmechanisms icall prediction 21 compiler optimizations two classes compileroriented optimizations relevant research large body research exists dataflow analysis determine set possible call targets given call site ryder24 presented method computing callgraph set functions may called call site using dataflow equations recent work burke4 hall13 refined technique work characterized programs procedure values may passed function parameters others including hall 13 also examine functional programs cently pande ryder22 shown inferring set call targets call sites languages c type system nphard problem paper seek minimize pipeline stalls using information concerning frequency calling specific call sites unless previous algorithms determine unique call target information needed icall prediction however results study indicates single call targets occur frequently techniques eg ryder 22 may successful prac tice knowledge little work specifying probability specific call targets called using dataflow techniques comparison considerable work adaptive runtime systems reduce cost polymorphism dynamically typed languages recent foremost efforts work self project 8 9 14 customization method dispatches extensive optimization method lookup self dynamiclytyped language providing rich set capabilities present staticallytyped languages c however staticallytyped languages c efficient using constanttime method dispatch mechanism staticallytype objectoriented languages popular less compiler effort needed achieve reasonable performance objectoriented programming style encourages software resources structured software libraries customization optimizations produced considerable performance improvement self implementation many ways extending optimizations explored self project c language however must rely hardware customization eg prediction hardware rather software becausemost c implementations already efficient example indirect function call c takes seven instructions decstation reducing cost greatly improve performance application difficult also feel results research benefit prototyping languages self smalltalk languages optimized modern architectures also secondary effects optimizations certain cases code transformations allow function inlining facilitating optimization self uses inline cacheto speed indirect function calls inline cache records last target address call site method called jump target recovered software cache 14 holzle et al found could improve performance converting inline cache access polymorphic inline cache pic lookup pic encodes datadependent type check stub procedure dynamically modifying program reduces searching appropriate method given data type use similar technique termed ifconversion described later paper convert indirect call type check direct method call trying optimize indirect call site main differences two methods compiling staticlytype object oriented languagec holzle et al compiling dynamicly typed language self use static profiling gather data use instruction cost model decide whether call site could benifit conversion method also benifits indirect jump hardware predicition self system builds pic stub tables runtime adding method types call site stub function indirect jump hardware prediction little benifit self dynamic method lookups implemented indirect jump instructions 22 branch prediction number mechanismsto ameliorate effect uncertain control flow changes including static dynamic branch pre diction branch target buffers delayed branches prefetching targets early branch resolution branch bypassing prepareto branch mechanisms 18 conventional branch prediction studies typically assume two possible branch targets given branch point multitarget branches occur infrequently programs rather present comprehensive overview field focus methods related techniques consider paper architectures employ static prediction hints using either profilederived information information derived compile time analysis information branch direction branch opcode 25 20 2 wall26 found profiledriven static prediction reasonably accurate indirect function calls fisher freudenberger 12 found profilederived static prediction effective conditional branches hypothesize interrun variations occurred prior input cover sufficient execution paths results provide support hypothesis general profile based prediction techniques outperform compiletime prediction techniques techniques use hueristics based branch prediction instruction opcodes architectures use dynamic prediction either using tables explicit branch registers branch target buffer btb 17 23 small cache holding address branch sites address branch targets myriad variations general idea typically cache contains 32 512 entries may 2 4way associative address branch site used tag btb matching data used predict branch designs include decoded instructions well branch target designs eliminate branch target address observing branches go one two ways takennot taken still designs eliminate tag branch site address table designs use branch site address index table prediction bits information actually prediction information another branch however theres least 50 chance prediction information correct improved somewhat 5 common variants tablebased designs 1bit techniques indicate direction recent branch mapping given prediction bit 2bit techniques yield much better performance programs loops 25 17 20 advantage bittable techniques keep track little information per branch site effective practice lastly somecomputersuseexplicit branch target addressregis ters btars specify branch target 11 1 numerous advantages branch instructions compact easily decoded btars applied conditional branches function calls instructions loading branch targets moved loops optimized ways furthermore addresses specified explicit branch target registers provide additional hints instruction caches instructions prefetched decoded early however proposed implementations provide 48 btars1 contents registers probably saved across function calls thus instructions manipulating btars must occur early instruction stream effectively use btars first glance techniques bittable tech niques appear applicable icall prediction indirect function calls jump number call targets later show profilebased icall conversion use mechanisms 3 experimental design comparison used tracebased simulation instrumented number c programs listed table 1 using modified version qpt3 program tracing tool emphasizedprograms using existing c class libraries structured application modular extensible fashion normally associated objectoriented design extensive comparison characteristics c c programs found 7 empirical computer science labourintensive undertaking programs compiled processed decstation 5000s three c compilers gnu g dec c att c v302 required successfullycompile programs much occurred c language standardized collection programs instrumented consumed 1gb disk space despite good performance qpt tracing tool conventional pro grams offers little trace compression programs using indirect calls constructed simulator analyze program traces typically simulator run collect information call branch targets anda second time use prediction information prior run one program groff compared predictions using input differing runs better assess robustness results modified qpt indicate caused basicblock transition direct branch indirect branch fallthrough record whether function call caused direct indirect call programs also able indicate functions methods 1 classified unpredictable breaks control three classes 2brs conditional branch 2brs branch multiple destinations usually arising switch case statements icall indirect function call table 2 lists number occurrences type unpredictable break control different programs show three entries groff use three executions coverage analysis later entries column sites trace lists number branch call sites type encountered program execution example doc actually 2 367 indirect function calls encountered 1 544 calls program ex ecution heading occurrences execution lists number times breaks type appear program execu tion thus 5 310059 indirect function calls traced doc approximately 99 indirect calls c methods except groff 95 methods 4 performance comparison many metrics used compare icall prediction combined icall branch prediction techniques table 3 shows number instructions breaks nibbs without branch icall prediction tracked breaks control flow cause long pipeline delay breaks conditional branches indirect calls returns also cause long pipeline stall returns accurately predicted using return stack 15 track assume unconditional branches procedure calls assigned gotos accurately predicted controltransfer instructions conditional branches icalls also cause instruction misfetch penalty must decoded instruction stream knows instruction type thus instruction fetch unit may incorrectly fetch next instruction rather target destination another paper 6 show misfetch penalties avoided using extra instruction type bits andor simple instruction type prediction table coupled techniques discussed paper considering conditional branches indirect calls would expect parameters table 3 similar c c programs contrary found sample c programs higher number instructions breaks indicating c programs tend either predictable c programs use different linguistic construct conditional logic example consider balancedtree implementation c c c programmer might implement single procedure balance tree passing several flags control actual bal ancing c programmer hand would tend use inheritance object model provide similar functionality thus surprising c programs tend procedure calls fewer conditional operations 7 remaining tables show mean nibb program use harmonic mean nibb summary also use percent breaks predicted bp understand well various techniques predict breaks metric common misprediction rate commonly used compare branch prediction mechanisms however note bp metric could extract information idl compiled dec c name description congress interpreter prologlike language input one examples distributed congress configuration management doc interactive text formatter based interviews 31 library input briefly editing 10 page document groff groff version 17 version ditroff text formatter one input collection manual pages another input 10page paper idl sample backend interface definition language system distributed object management group input sample idl specification fresco graphics library idraw interactive structured graphics editor based interviews 26 library example drawing editing figure morpher structured graphics morphing demonstration based interviews 26 library example morphed running man example distributed program rtsh ray tracing shell interactive ray tracing environment tcltk user interface c graphics library example small ray traced image distributed program table 1 c programs instrumented account density breaks program example may single conditional branch 100000000 instruction program branch may always mispredicted number instructions breaks remains high fore useful look nibb bp comparing prediction techniques across different programs 41 bounds compiletime icall prediction interested determining well interprocedural dataflow analysis could predict indirect method calls 22 compared results profilebased static prediction methods method names c encoded unique type signature linker knew intended type signature call site 2 single function signature function could appropriate call site indirect call could replaced direct call call unique name measureand feel represents lower bound could accomplished dataflow optimization algorithm practice dataflow method accurate symbol table unix system typically includes methods classes never invoked extreme recorded number single target icall sites icall sites record single call target trace compiler directed icall prediction useful single target selected number traces recorded single target measure represents upper bound target prediction could expect dataflowbased prediction algorithms unique name single target values measure number dynamic occurrences general results indicate significant promise static analysis c programs particular effective simple implement feel unique name measure integrated existing compilers linkers currently compilers dont provide information call sites information easy capture 42 static vs dynamic prediction although compiler techniques appear promising found profilebased dynamic prediction techniques clearly better implemented simple majority profilebased technique ran programs recorded likely target call site used predict call targets future runs results shown column labeled static table 4 simple technique accurately predicted surprisingly large number icalls runs used program input generate prediction trace measurements shown determine accurate prediction rates different inputs ran groff two inputs table 5 shows percentage icalls predicted using combinations different input files found small number prediction sets appear sufficient provide accurate predictions cases profilebased methods poor performance experience usually occurs inputs used establish profile used predict branches icalls provide adequate coverage branches indirect function calls problem mentioned others 26 12 studied detail table 4 also shows effectiveness idealized dynamic prediction techniques simulated two infinitely large branch target buffers first btb 1bit simply used previous icall target prediction future icalls much like method caching used self recent method saved second 2bit used 2bit strategy avoids changing prediction information previous prediction incorrect twice row icalls considered unpredicted first encoun tered surprisingly 1bit mechanism worse performance static prediction however require profiling runs improvement shown 2bit technique illustrates 1bit technique changes prediction rapidly example call site calls sequence methods ax bx ax 1bit method would miss three times 2bit method would miss information important designers wideissue processors example recent design proposals consider using 16kb memory btbs another paper show eliminate need sites trace occurences execution program 2brs icalls 2brs 2brs icalls 2brs instructions congress 1817 309 4 18352179 342266 43593 152658312 doc morpher 4050 1200 6 6613548 425072 7807 52131648 table 2 detailed statistics number instructions breaks control program measured metric congress doc groff3 idl idraw morpher rtsh mean 815 755 760 1020 914 740 1420 median 600 600 500 900 500 400 700 stddev 757 599 719 606 1594 876 3094 table 3 number instructions breaks absence control flow prediction program unique names single target static inf 1bit btb inf 2bit btb congress doc 562 767 932 922 965 groff3 66 312 864 790 953 idl 999 999 999 999 idraw 349 835 946 956 980 morpher 703 920 967 966 977 rtsh 29 511 936 960 980 mean 316 663 912 909 963 table 4 percentage indirect function calls predicted using compiletime profilebased dynamic prediction could computed using using using using program groff1 groff2 groff3 combined groff2 825 864 856 864 groff3 796 856 864 863 table 5 percentage icalls predicted groff using static prediction different input files metric congress doc groff idl idraw morpher rtsh break 902 836 842 904 986 1117 912 call 1445 1462 1457 1127 1892 1516 1430 table mean number instructions icall instruction stream hitting break another function call include start procedure break point 2bit 2brs unique name single target static icalls program nibb bp nibb bp nibb bp nibb bp congress 677 880 697 883 709 885 762 893 doc 560 865 952 921 1276 941 1764 957 groff3 740 897 758 900 832 909 1067 929 idl 457 777 457 777 4673 978 4680 978 idraw 710 871 887 897 1360 933 1548 941 morpher 519 858 740 900 851 913 879 916 rtsh 716 802 726 804 950 851 1305 891 table 7 measurements breaks predicted using compiletime static icall prediction 2bit branch prediction resources 6 likely prediction architecture would benefit small 2bit prediction mechanism indirect function calls last prediction mechanism considered branch target address registers btars assumed architectures would implement small number btars would likely saved across procedure calls thus two limits using btars indicate intended branch targets assumed btar could loaded anywhere previous basic block providing lower bound interval btar loaded branch taken likewise assume clever compiler might able load btar immediately following previous procedure call return becausewe assumedbtars saved across function calls table 6 shows two values instructions since beginning basic block instructions since last callreturn general instructions schedule prepare jump information first target instruction needed simple prediction targets indirect function calls ffl dynamic methods using 2bit branch target buffer effective technique considered however style prediction may expensive implement ffl combining simpler branch prediction technique btbs indirect function calls resource demands become realistic ffl static profiledriven prediction wasvery accurate used remainder paper 43 using profiles eliminate indirect function calls prior measurements shown percentage icalls predicted using different techniques comparison table 7 shows percent total breaks predicted using static prediction prior profiles icalls accurately predicts half remaining breaks control doubling number instructions breaks assuming breaks evenly distributed recall figure 1 figure conditional branches indirect function calls predicted using static profilebased technique de scribed second bar program indicates additional delays incurred breaks indirect function calls mispredicted conditional branches third bar eliminates delays statically predicted indirect function calls architectures providing btbs delay would slightly smaller clearly predicting branches foremost priority predicting indirect calls removes substantial number breaks success profilebased static prediction also indicates many methods could successfully compiled inline even without compiletime type analysis convert indirect function call egobject foo conditional procedure call runtime type check typeofobject object afoo else object foo transformation useful three reasons first code transformation performed function call afoo inlined secondly high likelyhood calling afoo code sequence less expensive risc architectures using 45 instructions rather 58 lastly architecture provides branch prediction support prediction indirect function calls transformed code avoid many misprediction penalties existing branch prediction hardware may able improve strictly profilebased prediction accommodate bursts calls secondary call target although inlining functions useful always reduce program execution time 10 however many indirect function calls c tend short programmers likely employ proper data encapsulation techniques believe automatic inlining useful c c architectures converted indirectfunction call efficient high likelyhood calling common function afoo constructed following cost models handling icalls used optimize icalls detail assume cost direct method call c dmc 2 instructions comes extra instruction needed compute object pointer passed call instruction cost indirect method call c imc 7 instructions extra instructions needed compute pointer addresses future branch target cost c shown previous example 3 instructions including indirect load object pointer load constant comparison penalty mispredicting conditional branch indirect function call c miss instruction times assume mispredicted breaks cause 10 cycle pipeline delay get cost indirect method calls prediction since indirect call predicted considered mis predicted comparison static profilebased prediction mechanism discussed previous section cost becomes cpredict p probability accurately predicting call target call site cost converting indirect method call done would however use existing profile information compute q percentage second likely call target selected note q less equal minp1p else would likely target selected interesting note q might high percentage remaining icalls example may next likely branch occurring time means 58 remaining 60 icalls correctly predicted thus cost converting indirect function call construct actually cusegammaif figure 2 shows costs cnopredict horizontal line cpredict lower line boundaries cusegammaif pq best case 00 worst case worst case conversion cusegammaif p hypothetical case many second likely targets q approximately equal zero percent graph best case conversion cusegammaif p q achieved icall site 2 targets canonly happenwhenp 05 whenp 05 best q equal p remaining 1gammap q icall targets cannot predicted reason line graph best case conversion changes slope 05 graph one see always benefit static icall prediction given values c c dmc c miss c imc used depending accurate one predict second likely target q better conversion icall rather predicting likely target graph one see cusegammaif p eventually intersects cpredict p always beneficial conversion architecture provides static prediction architecture assumptions occurs 086 lines cnopredict cusegammaif p worst case also eventually intersect always beneficial conversion architecture provide static prediction architecture assumptions occurs conversion architecture provide static prediction gives user sense benefit static prediction mentioned architecture weve considered similar digital axp 21064 architectures including intel pentium also issue two instructions per clock newly announced architectures ibm riosii issue eight instructions per cycle architectures advantage ifconversion occurs much lower probabilities p general prediction information greatly reduce penalty indirect function calls noticed graph always beneficial predict destination icall accurate profilebased measurements expose optimizations accuracy predicting frequently called function exceeds 8090 table 4 shows occurs many programs measured transformation also provides opportunity inlining body function allowing compiler customize parameters function avoid register spills like rightmost bar program shown figure 1 shows effect applying transformation appropriate based model call site programs comparison second bar right shows benefit using prediction uniquename elimination without using conversion although advantage small similar costbenefit analysis used determine advantage additional function inlining note greater advantage using conversion architecture support static prediction 5 conclusions future work objectoriented programs become common increasing need optimize indirect function calls become even important processor pipeline depths increase superscalar instruction issue speculative execution become common existing branch prediction mechanisms accurately prediction 95gamma97 conditional branches branch prediction successful accurate prediction remaining breaks number cycles percentage icalls site probable target p optimizing icall site static profile static prediction using worst case using best case figure 2 cost instructions additional delay different indirect function call methods controlflow becomes increasingly important processors begin issue instructions concurrently eliminating misprediction penalty indirect function calls c programs remove 10 remaining breaks control c program found static profilebased prediction mechanisms worked well collection existing c programs ex amined saw additional improvements combining compiler optimization techniques unique name elimination conver sion static indirect call prediction information profilebased prediction also useful code transforma tions inlining better register scheduling results show get average 10 improvement number instructions executed program using icall predic tionoptimization techniques recommend compilers highly pipelined speculative execution architectures use profilebased static prediction methods optimize c programs use linktime information remove indirect function calls customize callsites using conversion based profile information furthermore hope architecture benchmarking community expands benchmark suites include modern programming languages c modula3 like languages exercise different architectural features c fortran programs acknowledgements would like thank ben zorn john feehrer reviewers comments paper wed also like thank james larus developing qpt helping us solve various problems encountered applying large programs work funded part nsf grant asc9217394 part continued effort make languages c suitable scientific computing r tera computer system branch prediction free optimally profiling tracing pro grams intervalbased approach exhcaustive incremental interprocedural analysis branch alignment exploiting behavioral differences c c customization optimizing compiler technology self iterative type analysis extended message splitting optimizing dynamicallytyped objectoriented programs subprogram inlin ing study effects program execution time reducing cost branchesby using registers predicting conditional branch directions previous runs program efficient call graph analysis optimizating dynamicallytyped objectorientred languages polymorphic inlines caches branch history table prdiction moving target branches due subroutine returns limits control flow paral lelism branch prediction strategies branch target buffer design reducing branch penalty pipelined pro cessors reducing cost branches improving accuracy dynamic type determination c branch target buffer design optimization constructing call graph program study limits instructionlevel parallelism alternative implementations twolevel adaptive branch predictions comprehensive instruction fetch mechanism processor supporting speculative execu tion comparison dynamic branch predictors use two levels branch history tr reducing cost branches reducing branch penalty pipelined processors customization optimizing compiler technology self dynamicallytyped objectoriented programming language intervalbased approach exhaustive incremental interprocedural dataflow analysis interactive type analysis extended message splitting optimizing dynamicallytyped objectoriented programs limits instructionlevel parallelism branch history table prediction moving target branches due subroutine returns subprogram inlining limits control flow parallelism alternative implementations twolevel adaptive branch prediction optimally profiling tracing programs improving accuracy dynamic branch prediction using branch correlation predicting conditional branch directions previous runs program efficient superscalar performance boosting comprehensive instruction fetch mechanism processor supporting speculative execution efficient call graph analysis branch prediction free comparison dynamic branch predictors use two levels branch history tera computer system branch target buffer design optimization optimizing dynamicallytyped objectoriented languages polymorphic inline caches study branch prediction strategies ctr stevan vlaovic edward davidson gary tyson improving btb performance presence dlls proceedings 33rd annual acmieee international symposium microarchitecture p7786 december 2000 monterey california united states kazuaki ishizaki motohiro kawahito toshiaki yasue hideaki komatsu toshio nakatani study devirtualization techniques java justintime compiler acm sigplan notices v35 n10 p294310 oct 2000 jared stark marius evers yale n patt variable length path branch prediction acm sigplan notices v33 n11 p170179 nov 1998 poyung chang eric hao yale n patt target prediction indirect jumps acm sigarch computer architecture news v25 n2 p274283 may 1997 john kalamatianos david r kaeli predicting indirect branches via data compression proceedings 31st annual acmieee international symposium microarchitecture p272281 november 1998 dallas texas united states david grove jeffrey dean charles garrett craig chambers profileguided receiver class prediction acm sigplan notices v30 n10 p108123 oct 17 1995 hyesoon kim jos joao onur mutlu chang joo lee yale n patt robert cohn vpc prediction reducing cost indirect branches via hardwarebased dynamic devirtualization acm sigarch computer architecture news v35 n2 may 2007 tao li ravi bhargava lizy kurian john adapting branchtarget buffer improve target predictability java code acm transactions architecture code optimization taco v2 n2 p109130 june 2005 karel driesen urs hlzle accurate indirect branch prediction acm sigarch computer architecture news v26 n3 p167178 june 1998 derek rayside kostas kontogiannis syllogistic structure objectoriented programming proceedings 23rd international conference software engineering p113122 may 1219 2001 toronto ontario canada bradley kuhn david w binkley enabling optimization c virtual functions proceedings 1996 acm symposium applied computing p420428 february 1719 1996 philadelphia pennsylvania united states hemant pande barbara g ryder static type determination c proceedings 6th conference usenix sixth c technical conference p55 april 1114 1994 cambridge sara porat bilha mendelson irina shapira sharpening global static analysis cope java proceedings 1998 conference centre advanced studies collaborative research p19 november 30december 03 1998 toronto ontario canada karel driesen urs hlzle direct cost virtual function calls c acm sigplan notices v31 n10 p306323 oct 1996 urs hlzle david ungar optimizing dynamicallydispatched calls runtime type feedback acm sigplan notices v29 n6 p326336 june 1994 b calder grunwald fast accurate instruction fetch branch prediction acm sigarch computer architecture news v22 n2 p211 april 1994 karel driesen urs hlzle minimizing row displacement dispatch tables acm sigplan notices v30 n10 p141155 oct 17 1995 barbara ryder future program analysis acm computing surveys csur v28 n4es dec 1996 amer diwan j eliot b moss kathryn mckinley simple effective analysis staticallytyped objectoriented programs acm sigplan notices v31 n10 p292305 oct 1996 frank tip peter f sweeney class hierarchy specialization acm sigplan notices v32 n10 p271285 oct 1997 kevin skadron pritpal ahuja margaret martonosi douglas w clark improving prediction procedure returns returnaddressstack repair mechanisms proceedings 31st annual acmieee international symposium microarchitecture p259271 november 1998 dallas texas united states david f bacon peter f sweeney fast static analysis c virtual function calls acm sigplan notices v31 n10 p324341 oct 1996 peter f sweeney frank tip extracting librarybased objectoriented applications acm sigsoft software engineering notes v25 n6 p98107 nov 2000 kevin skadron pritpal ahuja margaret martonosi douglas w clark branch prediction instructionwindow size cache size performance tradeoffs simulation techniques ieee transactions computers v48 n11 p12601281 november 1999 mary f fernndez simple effective linktime optimization modula3 programs acm sigplan notices v30 n6 p103115 june 1995 peter f sweeney frank tip study dead data members c applications acm sigplan notices v33 n5 p324332 may 1998 hazelwood david grove adaptive online contextsensitive inlining proceedings international symposium code generation optimization feedbackdirected runtime optimization march 2326 2003 san francisco california loren larsen mary jean harrold slicing objectoriented software proceedings 18th international conference software engineering p495505 march 2529 1996 berlin germany frank tip jens palsberg scalable propagationbased call graph construction algorithms acm sigplan notices v35 n10 p281293 oct 2000 sara porat david bernstein yaroslav fedorov joseph rodrigue eran yahav compiler optimization c virtual function calls proceedings 2nd conference usenix conference objectoriented technologies coots p11 june 1721 1996 toronto ontario canada amer diwan kathryn mckinley j eliot b moss using types analyze optimize objectoriented programs acm transactions programming languages systems toplas v23 n1 p3072 jan 2001 vijay sundaresan laurie hendren chrislain razafimahefa raja vallerai patrick lam etienne gagnon charles godin practical virtual method call resolution java acm sigplan notices v35 n10 p264280 oct 2000 phung hua nguyen jingling xue strength reduction loopinvariant types proceedings 27th australasian conference computer science p213222 january 01 2004 dunedin new zealand frank tip peter f sweeney chris laffra aldo eisma david streeter practical extraction techniques java acm transactions programming languages systems toplas v24 n6 p625666 november 2002 ayal zaks vitaly feldman nava aizikowitz sealed calls java packages acm sigplan notices v35 n10 p8392 oct 2000 olivier zendra dominique colnet suzanne collin efficient dynamic dispatch without virtual function tables smalleiffel compiler acm sigplan notices v32 n10 p125141 oct 1997 jeffrey dean greg defouw david grove vassily litvinov craig chambers vortex optimizing compiler objectoriented languages acm sigplan notices v31 n10 p83100 oct 1996 frank tip jongdeok choi john field g ramalingam slicing class hierarchies c acm sigplan notices v31 n10 p179197 oct 1996 takeshi ogasawara hideaki komatsu toshio nakatani study exception handling dynamic optimization java acm sigplan notices v36 n11 p8395 11012001 peter f sweeney michael burke quantifying evaluating space overhead alternative c memory layouts softwarepractice experience v33 n7 p595636 june takeshi ogasawara hideaki komatsu toshio nakatani edo exceptiondirected optimization java acm transactions programming languages systems toplas v28 n1 p70105 january 2006 peng zhao jos nelson amaral ablego function outlining partial inlining framework research articles softwarepractice experience v37 n5 p465491 april 2007 lorenzo bettini sara capecchi betti venneri double dispatch c softwarepractice experience v36 n6 p581613 may 2006
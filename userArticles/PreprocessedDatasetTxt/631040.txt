new approach version control method controlling versions software hierarchically structured entities presented using variant structure principle particular version entire system formed combining relevant existing versions various components system algebraic version language allows histories numbered series subversions variants joins described shown join operation simply lattice least upper bound together variant structure principle provides systematic framework recombining divergent variants utility approach demonstrated using lemur programming environment modular c programs developed using ways notion versions related possible world semantics intensional logic discussed b introduction software systems undergo constant evolution specifications change improvements made bugs fixed different versions created suit differing needs changes made families systems arise similar yet different handling changes large system nontrivial task different components evolve differently existing version control software configurations systems succeeded solving problems dealing evolution pure version control systems sccs 22 rcs 28 30 using delta techniques save storage space keep track changes made different programmers file space saving techniques also developed 8 16 18 29 software configuration systems make 7 allow automatic reconfiguration system changes made component also detailed analysis changes components reduces much useless compiling 24 31 integrated systems attempt combine ideas among better known system modeller 11 23 tichys work cmu 26 27 gandalf 4 9 17 adele 1 2 5 6 dsee 12 jasmine 15 shape 13 14 odin 3 systems greater lesser degree allow development large projects developed many different programmers use software databases version control files sometimes also modules well allowing restriction certain tasks certain individuals integrate versioning files right operating system despite advances integration hierarchicallystructured entities version control still satisfactory using system rcs sccs file tree revisions trunk considered main version branches correspond variants often number changes made variant changes merged sometimes textually back trunk tree structure show merge took place integrated environments adele used module family variants specification specification variants implementation implementation rcslike structure development implementation cases tree structure used versions yet tree structure appropriate software development constant merging different changes system directed acyclic graph dag would appropriate example suppose program written work standard screen english two people independently modify program first adds graphics interface changes error messages french someone asks version graphics french messages new version inherits two ancestors classes inherit several ancestors objectoriented programming concept variant fully developed parnas 19 described need families software showed variants good idea however concept still formalised discussion variants 32 one could give definition variant 14 read suspect still unsolved problem software engineering produce portable software designs sense predicting planning possibility certain modules system sprout variant branches still fact variants happen perhaps problem variants must planned instead allowed happen furthermore one able refer version complete system language one versions components paper addresses concept variant variants complete system relate versions individual components section 2 presents need versions complete systems informally presents versions components complete systems interact section 3 formally presents algebra versions allows subversions join versions along refinement relation versions version space therefore creates lattice section 4 formally presents relationship versions complete systems components using variant substructure principle section 5 illustrates version language used already existing c programming environment finally section 6 discusses ideas presenting possible extensions well showing could integrated existing configuration management systems global versions main weakness existing tools different versions component local significance might case example third version component also third version component b priori reason expect relationship third versions separate components exception concept variant integrated environments adele variant represents different interface module local significance components implementation interface completely separate thereby creating situation code duplication juggling software configuration lack correspondence versions different components makes difficult automatically build complete system instead users allowed mix match different versions different components arbitrarily tools give users freedom building desired combination also burden responsibility deciding huge number possible combinations yield consistent working instance system approach however version labels necessarily numbers intended global uniform significance thus fast version component meant combined fast version component b programmers expected ensure corresponding versions compatible one advantage approach possible talk versions complete systemformed simplest case uniformly choosing corresponding versions components suppose example created fast version every component say compiler build fast version compiler combining fast versions components course general unrealistic require distinct fast version every component may possible speed compiler altering components components fast versions extend configuration rule follows build fast compiler take fast version component exists otherwise take ordinary vanilla version generalize approach defining partially ordered algebra version labels partial order refinement relation v v w read v refined w v relevant w means informally w result developing version v basic principle configuring version w system use version v particular component component exist relevant version use version v component long component exist version use refinement ordering automate building complete system user specifies version complete system desired variant structure principle defines result combining relevant version component 3 version space section introduce version algebra giving rules practical applications version operators simplest possible algebra would allow one version call version vanilla version written ffl empty string 31 project history simplest versions correspond successive stages development process version 1 version 2 version 3 etc obvious extension allow subsequences 11 12 231 version control system would facilitate maintenance would also aid recovery error physical accidental destruction file logical introduction flawed algorithm furthermore would allow recuperation previously rejected ideas uncommon idea conceived partially thought rejected needed six months later solve kind problem programs sccs rcs designed fact notion numeric string keep track successive stages quite suitable however rcs two different meanings version 1234 actually means subversion 34 version 12 trunk version tree versions 1234 13 therefore incomparable even though would appear figures 13 succeeds 1234 version space numeric versions build one branch subversions must used create forks initial set possible versions described following n nonnegative integer refinement order described earlier indicates one version derived others order written v must wellfounded transitive current set versions use intuitive dictionary order n prefix example 1234 v 13 v 245 numeric versions would used would depend environment used one example would keep complete record changes files could done sixnumber version names corresponding date 19920618111829 another approach would use numbers editing file taking place fewer numbers real versions meaning versions 121 122 123 could correspond successive edits version 12 ultimately yielding version 13 32 differing requirements piece software going used people differing environments likely requirements users differ one important differences would level user interface aspects matter personal taste one prefer use graphics menus one prefer text others necessity syrian would want read write arabic japanese using katakana hiragana kanji canadian would want able choose english french even essential functionality differences user interface would significant differences functionality also appear example lisp systems brobdingnagian 1 everything including kitchen sink included yet typical lisp user need many packages offered rather forced take mini maxi version users able pick choose among packages need particular example autoload features used case systems differences implementation may also arise one ports system one machine another versions machines x may identical differ machine z handle problems need introduce concept subversion called variant many systems problem partially addressed sccs rcs introduction branches unfortunately relying numeric strings identify branches becomes unwieldy choose path naming subversions new space possible versions becomes brobdingnag imaginary country giants jonathan swifts gullivers travels x alphanumeric string example graphicsmouse version user interface would mouse subversion graphics version user interface parentheses inserted reduce ambiguity unlike rcs names variables constants represent anything except refinement relation incomparable need one axiom subversions consider operator ffl identity associative subversions powerful example consider task simultaneously maintaining separate releases common example normal working version current version developed yet difficult handle properly suppose two current releases 234 356 wish make repairs 234 subversion required create version 2341 fix bug version would still considered anterior 356 correspond reality rather would want 234bugfix reader might wonder grammar allowed v v rather v x consider task maria keir working separately subsystems sets versions subversions work merged prevent ambiguity marias versions could preceded maria similarly keir 33 joins versions subversions allow different functionalities uncommon different subver sions compatible example easily imagine wanting japanese lisp system infinite precision arithmetic graphics machine x handle sort thing need able join versions lisp version would japanesegraphicsinfinitex final space versions becomes make order complete add two axioms operator idempotent commutative associative leftdistributes operator defined least upper bound operator induced v relation consider versions v 1 least upper bound v 1 v v 1 holds consider least upper bound variant substructure principle presented x4 calls use relevant components particular configuration built operator defined least upper bound operator term relevant would meaning fact version language allows join independent versions necessarily mean arbitrary join actually makes sense however merge made make sense join perfectly addresses need describe merge note merging text code 10 taking place merging takes place version name configuration manager must ensure components make sense together checking takes place syntactic level version names see x4 34 canonical form equality axioms allow canonical form version expressions fact except commutative associative rules equations simply become rewrite rules joins versions must introduce total order subversions corresponds form dictionary x alphabetically precedes x dictionary order get canonical form joins well examples last first gamma first last assumed rightassociative 4 versions structure referring indiscriminately versions complete systems versions components question arises interact already explained require every component exist every version instead consider absence particular version meaning generic version adequate simplest case meaning vanilla version appropriate means example configure french version use french version component exists otherwise use standard one general however vanilla version always best alternative suppose example need keirapplefast version understood fast version keirs apple version certain component available exactly version would hardly justified assuming vanilla one appropriate keirapple version certainly use failing keir version exists plain one indicated none specific versions available general rule constructing version v system choose version component closely approximates v according ordering versions introduced earlier could call relevant version precisely select appropriate version component c let v set versions c available set relevant versions fv vg relevant version maximum element setif one maximum element error conditionand version v given system generalize principle follows suppose object components version relevant v formed joining versions c 1 c 2 case v version c relevant v furthermore version v constructed principle call variant structure principle describes exactly way subversions system inherit components superversion also accords well motivations given various version forming operators described earlier section example specifies constructing version 32 object take version 282 object exists versions 34 282 279 18 156 ffl specifies building version keirapplefast select keirapple version component exists versions keir keirapple keirfast applefast mariaapple fast ffl finally principle also explains solves problem combining versions example combining marias orange keirs apple versions see x3 desired version system would mariaorangekeirapple according rule component select version relevant mariaorange keir version available version relevant keirapple maria version available thus versions component c available keirpear fredapple keir apple ffl take version keir hand versions available keirapple maria ffl best choice system exist desired version notice possible construct version mariaorangekeirapple even component exists version however also makes sense individual component exist version allows otherwise incompatible projects merged consider example situation described keir maria seen fit alter component c exists keirapple maria versions according principle cannot form mariaorangekeirapple version system appropriate version component question solution keir maria get together produce mutually acceptable compromise version compatible keirapple maria variants system label compromise component mariakeirapple version component done principle says mariaorangekeirapple version whole system compromise version relevant recall version ordering maria keirapple lie mariakeirapple turn lies mariaorangekeirapple 5 lemur test notion versions added sloth existing software engineering environment c programs developed authors resulting evolved program lemur complete presentation sloth well comparison related work see 20 51 sloth sloth set tools designed facilitate reusability c programs system modules devised sophisticated method traditionally used c programs module unix directory two interface files externi externally visible variables definei manifest constants two implementation files vari local variables proci local routines well bodyi containing initialization code import file states modules needed module run correctly sloth three commands vm command used view files mm modify lkm command original sloth builds module uselist file containing list modules depends computing transitive closure import dependencies builds progc file component files compiles resulting progo file linked progo files modules make complete system sloth shown remarkably useful intended goal reusability met popshop several compilers written consists 100 different modules builds 10 different applications reader asked refer 20 details 52 lemur sloth versions lemur evolved form sloth lemur allows user create label different versions individual files make module label element version space described represented simple linear syntax used extension file name example keir needs separate version procedure definition file module would create inside module new file proc keirapplei apple version fast version fast subversion required changes modules procedure definitions would create additional file proc keirapplefasti note new files replace old ones different versions coexist note also every file exists every version example fast subversion keirapple may require changes result files full keirapplefast label lemur basic component files explicit usermaintained versions users directly create separate versions whole modules applications instead lemur uses principle previous section create automatically desired version application suppose example maria would like compile run mariaorange version project call comp invokes lemur configure command comp argument mariaorange parameter v option lemur proceeds much v option absent uses import lists form uselist modules required checks files date recompiling necessary links together executable would normally called comp difference though individual file looks first mariaorange version instead vanilla one link completed executable named comp mariaorange every file needed mariaorange version procedure straight forward said earlier however require every file exist version requested desired version available lemur follows principle x4 selects relevant version available instance means mariaorange version lemur looks maria version even unavailable settles vanilla version file question form inheritance implicit variant structure principle allows source code sharing version subversions lemur also follows principle x4 creating labelling files individual modules suppose mariaorange version requested relevant file fred module must produced lemur automatically using case relevant versions internal fred files required declarations imported modules compilation complete lemur automatically label resulting file fred mariaorangeo one files involved actually full mariaorange label otherwise labels file fred mariao assuming least one maria version involved files involved fact vanilla file produced given vanilla name fredo general labels file least upper bound versions files involved producing resulting label may much generic version requested means file used build versions system inheritance principle therefore allows us share object code version subversions high granularity modules sloth allows one sorts interesting things example one could write test version module interface would allow tester look values inner variables advantage code implementation would change would files even touched import file separate one one version module depend one set modules another version depend another set modules words hierarchical structure shape system change one version another sense lemur actually goes beyond principle previous section assumed structure system invariant however easily reformulate general principle stipulating every structured object explicit subcomponent list one subcomponents allow subcomponent list exist various versions configure object first select relevant version component list assemble relevant versions components appearing list lemur generalizes sloths import lists possible using make rcs versions modules different versions consist completely different modules case different makefiles written version lot information repeated global makefile written ensure right version makefile used create configuration whole process quite complex lemur makefiles need written everything done automatically extension lemur marmoset 21 allows different languages used using simple configuration file much simpler standard makefiles 53 bootstrapping lemur test notion version lemur bootstrapped used lemur create versions original sloth written monolithic manner handle versions rewritten using original version modular form much suitable maintenance extension version basic lemur functionally sloth working used create system allowed files exist multiple versions true lemur true lemur used create subversion lemur allowed lemur use basic versions also subversions ie version xy xz xya subversion subversion lemur created accept numeric versions numeric lemur new subversion created accept join versions join lemur additional variants also created allow different options subsequently joined together 54 implementation lkm builds modules one time starting depend modules makes general version possible module goes complex modules still building general version possible version course depend versions modules depends finally builds general possible version object file situations general version example one could ask xy version one file x version version xy version vm lkm programs error condition hand mm asks user wish create new file version file taken initial copy new version file 6 discussion problem variants software system difficult one claim language proposed paper step right direction difference made version revision variant subsystems level variant evolves point becomes completely different product fine nothing special done course paper way addresses variants versions managed sense controlling access components systems programmers users made ideas paper put question need software databases restrict access certain parts system modified uncontrolled manner language since using lattice describe version space one might ask meet two versions meaning fact ab would version refined b ab example one could conceive common transliteration russian bulgarian example one writes dzhon john result would scheme defined russianbulgarian one asked russian version russianbulgarian file could used russian one current system possible horrendously long version names repeated use might difficult figure happening one solution allow version variables introduce new versions defined terms existing ones example suppose francophone belgian users want french language mouse graphics version infinite precision arithmetic corresponds version algebra expression frenchgraphicsmouseinfinite clear enough rather unwieldy version variables user could introduce definition thereafter request belgian version even use expressions like belgianfast fact effect achieved elegantly allowing inequalities rather equalities example definition given incrementally three inequalities belgian french belgian graphicsmouse belgian infinite sometimes complexity would come many modules named versions within module different case use local version names defined inequalities would allow hiding software developed one key goals modules proposing real version language constants variables different scopes defined using inequalities next step would obviously add types fact surprising since several configuration management systems allow typed version names language component version name example could one lucid lustre related work said introduction approach version control original work directly related however reason ideas developed paper could applied existing systems software configuration systems see sense consider two systems appear flexible enough change easily made odin shape odin 3 system allows one formalize software configuration process object atomic object tool manipulate objects axioms given declaring object one use pre postconditions define actions tools reason versioning cannot added entire system atomic objects could versions rules defining programs would pass versions example mm vm lkm operations could defined odin shape 13 14 system attempts integrate better features adele make dsee attributed file system interface either standard file system database makes access versions transparent user version language disjunctive normal form ors ands version language changed allow variant substructure principle applied shape would generalised significantly speculative remarks close connection notion version discussed logi calphilosophical notion possible world see example 25 possible worlds arise branch logic called intensional logic deals assertions expressions whose meaning varies according implicit context usually context involves space time meaning previous president varies according statement refers eg us france refers 1989 1889 statements eg brothers former employer require extensive information obviously notion possible world literal form raises mindboggling philosophical questions taken formally indicating sort context time place speaker orientation proved extremely useful formalizing hitherto mysterious paradoxical aspects natural language semantics montague pioneer area interpret element version space possible world possible world instance software question instance differ instances possible worlds example world error messages english whereas neighboring world french principle described earlier tells us compound object varies one world next provided know parts vary lemur small way allows us visit one worlds construct instance software without worrying software looks like worlds lemur result intensionalizing one tool namely sloth surely imagine tools even ambitious unix montagunix would specify say command world would like visit say frenchgraphicsmouse world done would give us illusion appropriate instance one exists words examine source would find one copy one copy files test files well files could scattered directory structure could move around course behind scenes montagunix would monitoring activity automatically choosing relevant version every file request versions would hidden us create file would attach appropriate version tag montagunix could give developer illusion private copy project way time sharing gave users impression private computer result sophisticated refinement relation versions however know would implications different users network conflicting software acknowledgements many thanks gordon brown coded lemur quality code exceptional pleased announce lemur available first author r experience database programs protection cooperation software engineering environment odin system object manager extensible software environments representation families software systems configuration manager adele data base programs structuring large versioned software products revision control automatic deletion obsolete information integrating noninterfering versions programs organizing software distributed envi ronment integrated toolset engineering software configurations software system modelling facility efficient applicative data types gandalf project technique stringtostring correction designing software ease extension contraction unix tool managing reusable software com ponents reducing complexity software configuration source code control system controlling large software development distributed en vironment living inconsistency large systems formal philosophy selected papers richard montague software development based module interconnection software development control based system structure description stringtostring correction problem block moves smart recompilation report first international workshop software version configuration control tr rcsmyampersandmdasha system version control smart recompilation odin system object manager extensible software environments editor revision control experience data base programs jasmine software system modelling facility technique stringtostring correction workshop software version configuration control integrated toolset engineering software configurations integrating noninterfering versions programs unix tool managing reusable software components adele configuration manager stringtostring correction problem block moves protection cooperation software engineering environment efficient applicative data types software development control based module interconnection designing software ease extension contraction organizing software distributed environment design implementation evaluation revision control system computeraided software engineering distributed workstation environment representation families software systems software development control based system structure description controlling large software development distributed environment ctr john plaice blanca mancilla collaborative intensional hypertext proceedings fifteenth acm conference hypertext hypermedia august 0913 2004 santa cruz ca usa nikolaos papaspyrou ioannis kassios glu embedded c marriage multidimensional objectoriented programming softwarepractice experience v34 n7 p609630 june 2004
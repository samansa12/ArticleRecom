new approach formal language theory kolmogorov complexity present new approach formal language theory using kolmogorov complexity main results presented alternative pumping lemmas new characterization regular languages new method separate deterministic contextfree languages nondeterministic contextfree languages use new incompressibility arguments illustrated many examples approach also successful high end chomsky hierarchy since one quantify nonrecursiveness terms kolmogorov complexity b introduction feasible reconstruct parts formal language theory using algorithmic information theory kolmogorov complexity provide theorems use kolmogorov complexity concrete powerful tool want preliminary version part work presented 16th international colloquium automata languages programming stresa italy july 1989 supported part national science foundation grant dcr8606366 office naval research grant n0001485k0445 army research office grant daal0386k0171 operating grants ogp0036747 ogp046506 part work performed department computer science york university north york ontario canada address computer science department university waterloo waterloo ontario canada n2l 3g1 email mlimathwaterlooedu z partially supported nserc international scientific exchange award ise0046203 nwo nfi project aladdin contract number nf 62376 address cwi kruislaan 413 1098 sj amsterdam netherlands email paulvcwinl introduce fancy mathematics goal help readers large part formal language theory essential usually easiest sometimes even obvious ways paper important us demonstrate application kolmogorov complexity targeted area restricted trivialities proofs theorems paper may easy however theorems type used tool derived theorems easy apply 11 prelude first application kolmogorov complexity theory computation 19 20 redoing proofs known results shown static descriptional program size complexity single random string used obtain lower bounds dynamic computational running time complexity none inventors kolmogorov complexity originally applications mind recently kolmogorov complexity applied extensively solve classic open problems sometimes two decades standing 16 12 9 10 examples see textbook 13 secret kolmogorov complexitys success dynamic computational lower bound proofs rests simple fact overwhelming majority strings hardly computable regularities call string kolmogorov ran dom incompressible kolmogorov random string cannot effectively compressed incompressibility noneffective property individual string except finitely many proved incompressible recall traditional lower bound proof counting usually involves inputs certain length one shows certain lower bound hold typical input since individual typical input hard sometimes impossible find proof involve inputs understand typical input length constructed via incompressible string however finitely many individual strings effectively proved incompressible wonder old counting arguments involve inputs proof using new incompressibility method one uses individual incompressible string known exist even though cannot constructed one shows assumed lower time bound would hold string could compressed hence would incompressible 12 outline paper incompressibility argument also works formal languages automata theory proper assume basic notions treated textbook like first result powerful alternative pumping lemmas regular languages well known nonregular languages shown nonregular usual uvwpumping lemma plethora pumping lemmas show nonregularity like marked pumping lemma fact seems many example nonregular languages require special purpose pumping lemmas comparatively recently 8 22 4 exhaustive pumping lemmas characterize regular languages obtained pumping lemmas complicated complicated use last reference uses ramsey theory contrast using kolmogorov complexity give new characterization regular languages simply makes intuition finite stateness languages rigorous easy apply characterization works nonregular languages give several examples application quite difficult using pumping lemmas prove certain contextfree language cfl deterministic contextfree dcfl required laborious ad hoc proofs 7 cumbersometostate also difficulttoapply pumping lemmas iteration theorems 5 25 give necessary kolmogorov complexity conditions dcfl easy ap ply test new method several examples cfl gamma dcfl hard handle certain respects kcdcfl lemma may powerful related lemmas theorems mentioned high end chomsky hierarchy present completeness known characterization recursive languages necessary condition recursively enumerable languages let x denote natural number xth binary string sequence 0 representation 3 corresponds natural number 3 binary string 00 way obtain natural bijection nonnegative integers n finite binary strings f0 1g numerically binary string corresponds integer use notation lx denote length number bits binary string x x finite binary string another finite object like finite automaton recursive function natural number use lx denote length standard binary description let hdelta deltai n theta n n standard recursive invertible oneone encoding pairs natural numbers natural numbers idea iterated obtain pairing triples natural numbers natural numbers hx usual definitions kolmogorov complexity 11 20 13 sequel interested shortest effective description finite object x fix thoughts consider problem describing string x 0s 1s let standard enumeration turing machines since computes partial recursive function obtain standard enumeration recursive functions denote oehx yi oex partial recursive function oe strings 0s 1s strings together string p program oe compute x description x useful generalize idea conditional version oep x p program oe compute x given binary string free descriptional complexity c oe x relative oe defined 1 exists universal partial recursive function oe 0 computed universal turing machine u know partial recursive function oe constant c oe strings x oe 0 fix reference universal function oe 0 define conditional kolmogorov complexity x given unconditional kolmogorov complexity x denotes empty string since turing machine copies input output cxjy o1 x since 2 n binary strings length n 2 descriptions follows cx lx binary string x length call strings incompressible random also follows length n binary string binary string x length n cxjy lx considering c integer function using obvious oneone correspondence finite binary words nonnegative integers shown cx 1 x 1 finally cx denotes chx yi example 1 selfdelimiting strings prefix code mapping finite binary code words source words code word proper prefix code word define particular prefix code binary source word define code word x string x 0 called selfdelimiting code x corresponds binary string 10 selfdelimiting code 01011 1 similarly define complexity xth partial recursive function oe conditional yth partial recursive function selfdelimiting code positive integer x requires bits easy verify logarithms base 2 unless otherwise noted convenience simply denote length lx natural number x log x 3 example 2 substrings incompressible strings substring incompressible string also incompressible string specified short description v length cv description lu literal description uw moreover need information tell three items apart information provided prefixing item selfdelimiting description length together takes cv bits hence thus choose x incompressible cx lx obtain shown optimal substring incompressible string length n compressible olog n additional term conforms fact know probability theory every random string length n expected contain run log n consecutive zeros ones substring complexity olog log n 3 3 regular sets finite automata sigma finite nonempty alphabet let q possibly infinite nonempty set states transition function function q extend ffi ffi 0 sigma ffi 0 ffl clearly ffi 0 automaton forgets x sigma drive ffi 0 memory state automaton quintuple everything q 0 q f 2 q distinguished initial state final state respectively call finite automaton fa q finite denote indistinguishability pair histories x 2 sigma x defined strings reflexive sym metric transitive rightinvariant ffi 0 xz q 0 indistinguishability rightinvariant equivalence relation sigma simple matter ascertain formally 2 language accepted automaton set g regular language language accepted finite automaton straightforward exercise verify definitions following fact used later theorem 1 myhill nerode following statements l sigma equivalent l sigma accepted finite automaton ii l union equivalence classes rightinvariant equivalence relation finite index sigma iii x 2 sigma define rightinvariant equivalence x z 2 sigma xz 2 l iff yz 2 l number equivalence classes finite subsequently closure finite automaton languages complement union intersection follow simple construction appropriate ffi functions given ones details found textbook subject like 7 clumsy pumping lemma approach replaced kolmogorov formulation 31 kolmogorov complexity replacement pumping lemma important part formal language theory deriving hierarchy language families main division chomsky hierarchy regular languages contextfree languages contextsensitive languages recursively enumerable languages common way prove certain languages regular using pumping lemmas instance uvwlemma however lemmas quite difficult state cumbersome prove use contrast show replace arguments simple intuitive yet rigorous kolmogorov complexity arguments regular languages coincide languages accepted finite automata invites straightforward application kolmogorov complexity let us give example prove f0 k 1g regular state q particular accepting fa processing 0 k together fa constant description k namely running initialized state q input consisting 1s first time enters accepting state precisely k consecutive 1s size description q bounded constant say c independent k altogether follows choosing k ck log k obtain contradiction large enough k hence since fa fixed finite number states fixed finite number bounds kolmogorov complexity natural number contradiction generalize observation follows definition 3 let sigma finite nonempty alphabet let oe total recursive function oe enumerates possibly proper subset sigma order oe1 call order effective oe enumerator lexicographical order effective order words sigma ordered first according length lexicographically within group length another example oe standard binary representation ith prime effective order f0 1g case oe enumerate sigma let l sigma define l lg regular let oe enumerator sigma exists constant c depending l oe x nth string enumerated complement l x proof let l regular language nth string xy 2 l x described ffl discussion description fa accepts l ffl description oe ffl state fa processing x number n statement complement follows since regular languages closed complementation 2 application kcregularity lemma prove f1 primeg regular consider string p 0 kth prime lexicographical first element l x hence lemma difference two consecutive primes grows unbounded since o1 descriptions length o1 contradiction give examples wellknown textbook hopcroft ullman marked difficult example 3 exercise 31h 7 show ffflgg regular set log lexicographically first word l x contradicting kcregularity lemma 3 example 4 prove jg regular set log lexicographically first word l x cy contradicting kcregularity lemma 3 example 5 exercise 36 7 prove regular set log log n lexicographically first word l x 1 contradicting kcregularity lemma 3 example 6 section 22 exercises 1115 5 prove fp p standard binary representation prime g regular suppose con trary p denotes ith prime 1 consider least binary f0g f1g prime pm exists since interval n n natural numbers contains prime 6 considering pm integer v divided prime less p k pm prime binary length goes infinity k value cv clv also goes infinity k since v lexicographical first suffix integer v 1 uv 2 l kcregularity lemma contradiction 3 32 kolmogorov complexity characterization regular languages pumping lemmas precise enough except difficult construction 4 characterize regular languages kolmogorov complexity easy fact kcregularity lemma direct corollary characterization theorem device show nonregular languages nonregular common pumping lemmas characterization regular sets consequently determines whether given language regular like myhillnerode theorem usual characterizations regular languages seem practically useful show regularity need pumping lemmas stems fact characterizations tend hard use show nonregularity contrast kccharacterization practicable purposes evidenced examples definition 4 let sigma nonempty finite alphabet let ith element sigma lexicographic order 1 l sigma x 2 sigma let characteristic sequence l defined theorem 2 regular kccharacterization let l sigma assume notation following statements equivalent l regular ii constant c l depending l x 2 sigma n c 1n jn c l iii constant c l depending l x 2 sigma n iv constant c l depending l x 2 sigma n proof ii similar proof kcregularity lemma constant c finitely many oneway infinite binary strings n proof claim weaker version theorem 6 2 turns weaker version admits simpler proof make treatment selfcontained present new proof appendix 2 iv claim finitely many distinct associated xs sigma define rightinvariant equivalence relation x x 0 relation induces partition sigma equivalence classes xg since oneone correspondence xs finitely many distinct also finitely many xs implies l regular myhillnerode theorem 2 remark 1 kcregularity lemma may viewed corollary theorem l regular clearly l x regular follows immediately finitely many associated specified c bits c constant depending l enumerator oe say nth string l x specify string corresponding nth 1 using cn bits specify hence loss generality need assume nth string enumerated l x kcregularity lemma string corresponding nth 1 enumeration theorem recursive mapping two remark 2 l nonregular infinitely many x 2 sigma distinct equivalence classes x distinct associated characteristic sequence easy see automaton finite infinite associated equivalence class x 1 difference finite infinite automata precisely expressed fact first case exist priori constant bounds lefthand term show prove positive results kccharacterization theo rem examples negative results given preceding section example 7 prove exists constant c x associated characteristic sequence c 1n jn c therefore l regular kccharacterization theorem example 8 prove number 1s x oddg regular obviously exists constant c x c 1n therefore l regular kccharacterization theorem 3 4 deterministic contextfree languages present kolmogorov complexity based criterion show certain languages dcfl particular used demonstrate existence witness languages difference family contextfree languages cfls deterministic contextfree languages dcfls languages difference difficult identify nondcfl also noncfl cases often use pumping lemma contextfree languages new method compares favorably known related techniques mentioned introduction simpler easier apply apparently powerful works superset examples yet primary goal demonstrate usefulness kolmogorov complexity matter language dcfl iff accepted deterministic pushdown automaton dpda intuitively lemma tries capture following suppose dpda accepts 1g dpda needs first store representation all0 part retrieve check all1 part check seems inevitable discarded relevant information n cannot use information check all2 part complexity all2 part yields contradiction large n definition 5 oneway infinite string recursive total recursive function f recognized deterministic pushdown machine let c constant let recursive sequence sigma described c bits let x 2 sigma cx c let recursive sequence sigma items iii satisfied 1 n given state pushdown store contents processing input description additional description c bits reconstruct n running observing acceptance rejection given state pushdown store contents processing input reconstruct w additional description c bits log log constant c 0 depending l c cw c 0 proof let l accepted input head h r assume n w satisfy conditions statement lemma convenience write input z 2 sigma denote cz pushdown store contents time h r read z moves right adjacent input symbol consider computation input uv time h r reaches end u two cases case 1 constant c 1 infinitely many pairs mn satisfying statement lemma h r continues reaches end v original cu popped except bottom c 1 bits machine decreases pushdown store size lcu size processing v first time occurs let v 0 processed initial segment v v 00 unprocessed suffix state q describe w following items 2 ffl selfdelimiting description including sigma discussion bits ffl selfdelimiting description 1 ffl description cuv 0 q c 1 log jsigmaj o1 bits ffl additional description mentioned item statement lemma selfdelimiting format using 1 bits denote p ffl additional description mentioned item ii statement lemma selfdelimiting format using 1 bits denote r item statement lemma reconstruct v 00 state q pushdown store contents cuv 0 using description p subsequently starting state q pushdown store contents cuv 0 process v 00 end computation obtained state pushdown store contents processing uv according item ii statement lemma together description r reconstruct w since cw length description setting c 0 4c satisfies lemma since need glue different binary items encoding together way effectively separate like hx count cx selfdelimited encoding x x need give selfdelimiting forms one constituent description item case 2 way contradiction assume case 1 hold constant c 1 finitely many pairs mn satisfying conditions lemma cause decrease stack height c 1 processing v part input uv fix constant c 1 set mn satisfy statement lemma long required validate argument choose suffix log log 2 much larger lu much regular mo ments reflection learns always choose u 0 2 large enough exists u 0 starts state accesses top elements stack processing v parts inputs uv u 0 v proof assumption read bottom c 1 symbols cu processing v part input uv argue one choose u 0 top segment cu 0 precisely top segment cu bottom c 1 symbols large enough lu lu 0 see examine initial computation u since deterministic must either cycle sequence pushdown store con tents increase pushdown store repetitions long enough u namely let triple q state q top pushdown store symbol h r ith bit consider triples q steps never go current top pushdown store level reading u popped going v precisely lcu triples input repetitious deterministic triple must start repeat within constant number steps constant interval height pushdown store starts reading ys easy show within repeating interval constant number ys read pushdown store cycle priori bounded set pushdown store contents since would mean constant c 1 processing suffix increase stack height c 1 situation reduces case 1 therefore pushdown store contents grows repetitiously unbound edly since repeating cycle starts pushdown store constant number symbols size constant number ys adjust u 0 starts state reads top segments cu v parts computations uv u 0 v proves claimthe following items form description reconstruct v ffl discussion description o1 bits ffl selfdelimiting description recursive sequence v initial segment 1 ffl selfdelimiting description pair hx yi 1 ffl selfdelimiting description ffl program p reconstruct v given state pushdown store contents processing u item statement lemma therefore selfdelimiting description p takes 1 fflc bits following procedure reconstructs v information using description u 0 construct state q u 0 pushdown store contents processing u 0 claim 2 state q u processing top elements cu cu 0 run input starting state q u 0 stack contents cu 0 assumption popped processed looking consecutive states computation using program p find n according item statement lemma reconstruct v requires definition least cv bits therefore last inequality follows equation 2 contradicts item iii statement lemma large enough 2 items iii kcdcfl lemma considerably weak ened presented version gives essential idea power suffices many examples restricted easier version following corollary 1 let l sigma dcfl let c constant let x fixed finite words sigma let recursive sequence sigma let u suffix prefix let w 2 sigma v described c bits given l u lexicographical ii w described c bits given l uv lexicographical order log log lu constant c 0 depending l c cw c 0 following contextfree languages proved dcfl great effort 7 5 25 new proofs direct intuitive basically v first word l u processing v part input uv must already used information u much information left pushdown store first word w l uv cannot high kolmogorov complexity example 9 exercise 105 7 prove dcfl suppose contrary set item iii lemma since v lexicographically first word l u item lemma satisfied lexicographically first nonempty word l uv set lemma cw n contradicting kcdcfl lemma corollary approximately proof shows contextfree language fxx r contextsensitive language fxx x 2 sigma g deterministic contextfree languages 3 b 7 example 1 25 prove f0 2ng dcfl suppose contrary let log n v lexicographically first word l u lexicographically first nonempty word l uv 1 n set contradicting kcdcfl lemma corollary 3 example 11 example 2 25 prove contains dcfl suppose contrary set even lexicographically first even length word l u cn log n satisfies items iii lemma choosing lexicographically first even length word l uv starting 1 0 satisfies item ii cw omegagamma292 n contradicts kcdcfl lemma corollary 3 example 12 prove kg dcfl suppose contrary let item iii lemma v lexicographically first word l u satisfying item lexicographic first word l uv f1gf2g 12 n1 therefore set contradicting kcdcfl lemma corollary 3 example 13 patternmatching kcdcfl lemma corollary used trickily prove fxyx r z x dcfl suppose contrary let iii lemma since v lexicographically first word l u choice v satisfies item lemma reconstruct v v 0 flipping last bit v 0 1 0 lexicographically first word l uv satisfy item ii since cw omegagamma365 n contradicts kcdcfl lemma corollary 3 5 recursive recursively enumerable yond immediately obvious characterize recursive languages terms kolmogorov complexity l sigma sigma effectively ordered define characteristic sequence terms earlier developed terminology automaton accepting l characteristic sequence associated equivalence class ffl recall definition 5 recursive sequence set recursive iff characteristic sequence recursive sequence follows trivially definitions theorem 3 recursive kc characterization set l 2 sigma recur sive iff exists constant c l depending l n l set fn terms kolmogorov complexity following theorem gives qualitative even quantitative difference recursive languages following theorem due barzdin 1 14 theorem 4 kcre l constant c l depending l n ii exists set l c 1n log n n note l item ii set sigma gamma l possibly non also satisfies item therefore item kolmogorov complexity characterization sets example 14 consider standard enumeration turing machines define ith turing machine started ith program halts language k characteristic sequence clearly set 1 shown example 15 let k previous example define oneway infinite binary sequence h ch 1n log n therefore h characteristic sequence set b b recursive sparsely nonrecursive 3 example 16 probability optimal universal turing machine u halts selfdelimiting binary input p randomly supplied tosses fair coin omegagamma 0 1 let binary representation ofomega 0omega finite nonempty alphabet effective enumeration without repetitions sigma define l sigma v 2 l 1 shown see example 13 finitely many n hence neither l sigma gamma l difficult see l 2 arithmetic hierarchy l recursively enumerable 23 24 3 6 questions future research 1 difficult give direct kcanalogue uvwxy pumping lemma tao jiang pointed us like pumping lemma show primeg cfl clearly hasnt yet captured kolmogorov complexity heart cfl general find cflkccharacterization 2 ambiguous contextfree languages 3 contextsensitive languages deterministic contextsensitive languages appendix proof claim 1 recursive real real number whose binary expansion recursive sense definition 5 following result demonstrated 15 attributed ar meyer constant c finitely many c 1n jn c n moreover recursive real 2 strengthened version c 1n cnc strengthened version c 1n latter version requiring recursive reals completeness sake present new direct proof claim 1 avoiding notion recursive reals recall convention identifying integer x xth binary sequence lexicographical order f0 1g equation 1 proofof c positive constant let cardinality dan dips fixed constant c 0 infinitely many n c 0 upper bound da upper bound cardinality set prefixes length n elements n fix l 2 n choose binary string length 2l choose maximum division holds least similarly division 1 maximality easily proven prove lr l since equations 5 3 follows lm implies ln l consequently prove dovetailing computations reference universal turing machine u programs p lp log c enumerate elements reconstruct mth element say 0 enumeration namely 0 reconstruct n since ly 0 obtain enumerating 0 generated concatenation equation 4 combining equations 7 8 follows log c o1 therefore equation 6 c fixed constant independent n since lr l choose l arbitrarily fixed constant c 0 infinitely many r implies da c 0 hence claim 2 avoided establishing cited references elements defined equation 3 recursive reals resulting proof simpler sufficient purpose since need establish finiteness remark 3 difficult part regular kccharacterization theorem consists proving kcregularity lemma exhaustive ie used prove nonregularity nonregular languages let us look little closely set sequences defined item iii kc characterization theorem set sequences equation 3 superset set characteristic sequences associated l according proof cited references set contains finitely many recursive sequences computable turing machines subset consisting characteristic sequences associated l satisfies much stringent computational requirements since computed using finite automaton recognizing l replace plain kolmogorov complexity statement theorem socalled prefix complexity variant k equivalent set equation 3 contains nonrecursive sequences result rm solovay 21 acknowledgements thank peter van emde boas theo jansen tao jiang reading manuscript commenting anonymous referees extensive comments suggestions improvements john tromp improved proof claim 1 r complexity programs determine whether natural numbers greater n belong recursively enumerable set algorithmic information theory pumping lemmas regular sets introduction formal language theory difference consecutive primes introduction automata theory necessary sufficient pumping lemma regular languages two heads better two tapes three approaches quantitative definition formation tape versus queue stacks lower bounds introduction kolmogorov complexity applications minimalprogram complexity measures variant kolmogorov concept complexity quadratic lower bounds deterministic nondeterministic onetape turing machines kolmogorovs complexity lower bounds information theoretic approach time bounds online computation lecture notes pumping theorem regular languages random sequences algorithmic information theory pumping lemma deterministic contextfree languages tr
solving various weighted matching problems constraints paper studies resolution augmented weighted matching problems within constraint programming cp framework first contribution paper set techniques improves substantially performance branchandbound algorithms based constraint propagation second contribution introduction weighted matching global constraint weightedmatching propagated using specialized incremental algorithms operations research first compare programming techniques use constraint propagation specialized algorithms operations research busaker gowen flow algorithm hungarian method although cp shown competitive specialized polynomial algorithms pure matching problems situation different soon problems modified additional constraints using previously mentioned set techniques simpler branchandbound algorithm based constraint propagation outperform complex specialized algorithm techniques applied success traveling salesman problems 5 seen augmented matching problem also show incremental version hungarian method used propagate weightedmatching constraint extension weighted case work rgin 19 show bring significant improvements timetabling example b introduction constraint logic programming clp generally constraintbased programming cp become interesting approach solving combinatorial optimization problems vh 89 instance problems jobshop scheduling shown efficient traditional approaches based operations research cl 94 delivering flexibility ie easy adapt algorithm slightly customized problem additional constraints goal investigate advantages drawbacks constraint programming compared classical combinatorial optimization maximum weight matching problem bipartite graph see techniques may combined bipartite matching interesting important three reasons first wellunderstood problem many polynomial algorithms ranging simple really elaborate eg gt 89 available therefore performance constraint satisfaction algorithm assessed rigorous gauge second many reallife problems either matching extended matching one additional constraints therefore perfect domain see boundary flexibility efficiency lay moreover many matching problems optimization problems weights may indicated use weighted matching algorithms use generic optimization methods nonweighted techniques third matching often part complex problems efficient propagation matching constraints basic building block modern constraint satisfaction system looking carefully matching algorithms derive ideas use designers constraint solvers paper organized follows section 2 describes naive approach matching improvements implemented easily move complex heuristics cutting rules show used handle larger problems section 3 compares previous results two wellknown algorithms hungarian weighted method busaker gowen flow algorithm show constraint satisfaction approach really compare specialized algorithms problem find optimal matching hand plausible approach finding set good solutions leads section 4 look two extended matching problems first case allow substitution new cost matrix k edges machinetask allocation problem renewal k machines second case study resolution two simultaneous matching problem eg machinetask allocation problem maximize production within bounded energy consumption two variations problem original algorithms adapted compared last apply section 5 various techniques presented paper timetabling problem show use weighted matching global constraint captures hard soft constraints time enabling efficient resolution 2 constraint based programming formally matching problem described follows let gve bipartite graph vertex set v parted two shores edges link v 1 v 2 matching set edges e two adjacent perfect matching matching covering vertices consider case perfect matching corresponds assignment matchings frequently arise production planning assignment jobs machines tasks technicians moreover consider case weighted graph define weight matching sum weights edges purpose find exists perfect matching maximal weight minimal weight weight w ij replaced w ij large constant 21 naive clp natural way see problem constraint program think vertices v 1 variables v 2 values vertex v 1 linked set values v 2 form domain matching corresponds assignment variables different variables always assigned different values problem consists finding assignment maximal weight constraint alldifferent r94 offered builtin clp languages propagation often performed arcconsistency ma77 mm 88 value assigned variable taken domains variables contradiction occurs domain becomes empty system backtracks previous variable assigned tries next possible assignment optimization algorithm classical branch bound scheme variable selected possible values recursively tried solution weight w found constraint weight w added system help pruning subtrees search space using simple upper bounds weight time search two upper approximations maximal matching maintained sum variables best possible assignment variable v define value bestv maximal value weightvx possible values x reciprocally sum values best possible inverted assignment instead computing sums explicitly node search tree maintained incrementally time value x removed domain variablev weightxvbestx bestx recomputed difference old new value subtracted similar updates performed bestv weightxvbestv whenever one bounds becomes strictly smaller goal one predict upcoming solutions smaller weight best one found far branch tree cut propagation algorithm widespread among implementations alldifferent constraint clp system selection node branch usually done firstfail principle one selects variable smallest domain assignments usually tried decreasing order weight drive search towards matchings heavy weights best first principle greedy heuristic shown table 1 naive algorithm solves problems 2x20 nodes within seconds requires unreasonable amounts time larger problems although may case implementations alldifferent constraint taking upper bounds important program considers upper bound 10 times slower 10x10 instances cannot solve 20x20 problems within reasonable times fact gives us hint progress symmetrical view problem bring constraint approach next two sections 22 23 describe improvements made propagation scheme heuristics first fail best first order improve performance 1 experiments reported paper done claire programming language 2 1 programmers using blackbox constraint system access propagation search engine many clp systems changes could encoded within solver allows state problem single command alldifferent changes written expert constraint system programmers using open constraint system access solver propagation engine program little longer user program changes 2 available httpwwwdmiensfrlaburtheclairehtml 22 adding symmetry regret many improvements made algorithm make scale larger problems first idea suggested importance symmetrical upper bounds fully symmetrical description problem model considers vertices v 1 variables vertices v 2 values arbitrary breech symmetry problem although perfectly valid way around add redundant model v 2 seen set variables v 1 set values branching vertices v 1 v 2 implies overhead inverse domain relation must maintained avoids missing evident decisions instance value one domain needs assigned variable hence matching done sides time similar use symmetric redundant models nqueens problem jo 95 would expected since nqueens customized matching problem without weights moreover firstfail heuristic selection vertex branch panacea notion regret gives acute description crucial vertices regret usually defined difference optimal choice second best case v vertex v 1 x value bestvweightvx define regretx difference bestv maximum weightvx values xx focusing regret justified fact problem solutions change constant added edges incident one vertex thus relative values matter opposed absolute ones regret actually change made upper bound best assignment vertex discarded selecting vertex largest regret branching point entropic choice sense try maximize impact decision described cl 94 entropic heuristics powerful tool proofs optimality since limit size tree forcing much propagation happen node avoid real slow algorithm node regret best assignment node memorized updated incrementally another idea would somehow rebreak symmetry time two upper bounds matching available soon one becomes less goal branch cut selecting vertices v 1 large regret decreases conversely cases one bounds clearly better could seem worthwhile encourage dissymmetry choice branching node implemented giving bonus penalty depending situation selection branching vertex proportional vertices v 1 heuristic denoted balance table 1 table illustrates effect techniques randomly generated instances 2 20 2 vertex typically connected 5 8 edges weight random number 1 100 entries table show number backtracks b search process 1kb1000b running times pentium pro 200 finding optimal solution giving proof optimality naive approach arc consistency first fail behaves poorly addition regret symmetry brings gain factor 10 idea balance really pay naive propagation 12 52 kb 500 5 kb 9 kb 198 kb b 800 b 35 kb 800 b 12 95 27 mb basic 900 b 35 kb 900 b 43 kb 25 11 mb table programs 23 finer tuning algorithm one aspects algorithm sharpened propagation addition upper bound evaluation domain reduction due edge selection also domain reduction upper bound matter fact dynamically remove illegal edges edge uv illegal soon bestu weightuv greater available slack goal goal objective weight goal subsequently decreased time admissible solution found call technique dynamic cut report behavior table 2 interest dynamic cut two folds one hand detect failures little earlier rather small benefit hand maintain smaller relevant domains may improve efficiency firstfail principle removing meaningless values produces rapidly domains small cardinals 1 3 firstfail tells us examine want reintroduce firstfail behavior choice heuristic based regret use simple trick used cgl93 select vertex minimize lexicographic pair par fixed parameter effect select vertices largest regret still domains cardinal par select first fail domains smaller par strategy yields improvements small values par 3 search tree described many branches per node actually may waste time wonder edge selected vertex know best one since edges may well look alike numerous search tree constructed differently single alternative node either best edge selected one tree becomes narrower binary maybe deeper practice prevents algorithm wasting time irrelevant choices new branching scheme reported table 2 binary branching tuning done concerns upper bound used cutting branches search tree formula sums best choices estimation best assignment indeed v v 1 favorite choice p vertices v 2 know take account regret atleast p1 cannot matched common favorite vertex therefore possible tighten bound subtracting conservative estimate regrets occur application lookahead principle try forecast evolution bounds vertex v v 1 consider previous set vertices x v 2 bestx set p vertices associate sum regrets highest one call lookv replaced strategy estimates difference simple bound actual choice called lookahead table 2 note estimation corresponds relaxation matching problem could suggest use lagrangean relaxation affecting weights nodes fact lookahead strategy uses similar ideas affecting weights nodes related several others ones preference graph nodes prevent solution relaxed problem matching moreover hungarian method associates weights nodes also seen related lagrangean relaxation basic 12 95 27 mb dynamic cuts 24 kb 15 mb 22 mb new branching 12 95 kb 65 lookahead 45 kb 12 6 table remarks made results first lookahead heuristic works well although benefits obvious numbers backtracks pay size problem large enough hand dynamic cut binary branching schemes produce unstable results difficult measure significant improvement techniques propagation branching bouding heuristics succesfully applied traveling salesman problem tsp represented weighted matching problems trying match node direct successor cycle coupled subtour elimination constraint described cl97 improvements enable constraint programs solve 30city tours instead 15city tours complex techniques also given larger problems 3 traditional algorithmic approaches matchings widely studied operations research community years col 86 ge 94 two methods presented pretend best ones available today made compromise limiting algorithms simple enough understood implemented reasonable amount time proportion implementation times constraintbased programs algorithm busaker gowen described gm 79 vl 90 embeds matching problem flow problem adding source linked vertices v 1 sink linked vertices v 2 case capacities edges set 1 adaptation wellknown fordfulkerson maximum flow algorithm case network weighted edges starts null flow augments saturating along augmenting paths augmenting path found meaning flow maximal polynomial algorithm runs number edges n number nodes however unlike fordfulkerson incremental sense cannot complete partial flow minimal cost maximal flow requires partial flow maximal stream cost hungarian method algorithm class primaldual algorithms often associated problems stated linear programs ps 82 primal program consists finding maximal matching minimal weight dual program consists finding positive weights p u associated vertices u edges uv sum p u maximal algorithm constructs incrementally weights p u starting p u equal 0 constructing graph g p formed edges uv verifying p u algorithm alternatively works dual model updating p u order add new edges graph g p primal model finding augmenting paths g p end matching g p minimal weight maximal matching g polynomial algorithm runs 3 major interest compared flow algorithm incrementality one wants remove edge uv graph recompute optimal solution one sets weight uv large positive constant remove uv g p takes one iteration complete optimal matching 31 comparison clp finding optimal solution pure matching program cp competitive techniques cp solves reasonably well problems 2 40 nodes whereas hungarian method scales problems well 2 100 nodes examples solved 70 80 000 backtracks approximately 200 best constraint programs flow algorithm takes 1 hungarian method takes 03 however one longer considers problem finding one optimal solution optimal solutions rather solutions within given distance optimum clp becomes plausible competitor table 3 reports experiment four programs compared first one straightforward adaptation previous constraint program basic instead stopping first solution explore whole tree second similar branch bound exploration flow algorithm used evaluate optimal matching node instead using upper bound estimate flow algorithm actually triggered one edges current optimal matching removed dynamic graph third program similar different branching scheme edge original optimal solution explore two branches either edge part matching removed dynamic graph fourth program branch bound algorithm similar third one except hungarian method used instead flow algorithm take advantage incrementality hungarian method ability recompute optimal matching single iteration edge discarded node search tree exploration bottleneck amount computation performed node search tree incremental hungarian method best algorithm since explores small search trees explored branches lead admissible solution however constraint algorithm fair competitor performs much less work per node 1 4 sol 2 9 sol 5sol 05 3 sol 1 8 sol 25 sol basic 1249 b b 8000 b 14 kb 11 38 kb 2s 140kb flow algorithm 137 b 9 224 b 2000 b 100 100 b 26 172 b 215 b 48 15kb 200 flow algorithm new branching 57 b 136 b b 34 b b 22 195 b hungarian matching b 58 b b b b b b table finding solutions hence problem finding nearoptimal perfect matchings constraint program behaves better basic operations research program adaptation flow algorithm well smarter program incremental hungarian method big advantage constraint program simplicity indeed much easier implement algorithms naive smart seems therefore good candidate reallife matching problems involving additional constraints thus require exploration space solutions pure problem 4 complex matching section address case two reallife variations matching problem adhoc algorithms could also probably specially designed variations problem however methodological point view decided consider adaptations original solutions could implemented reasonable amount times since constraints programs adapted matter minutes 41 replacing k machines suppose plant manager funds replace k machines among n newer ones want find optimal assignment maximum bringing maximal production tasks machines given newer machines efficient older ones means matching problem extended additional choice k vertices v 1 prefer use different weight matrix say weight instead weight sake comparison implemented three solutions problem one using constraint propagation two solutions basic adaptation flow algorithm smart adaptation hungarian method first one straightforward adaptation constraintbased program basic principle postpone choice k new vertices much possible take account modified upper bound estimate instead taking sum best choices nodes add sum sum k heaviest edges difference graph defined gain production function new old machines ie considering weightuv weightuv weight edge uv like bounds maintained incrementally second program based flow algorithm goes search tree nodes depth correspond choice th machine replace branches explored whenever decision replacement made production function updated ie second weight function used th machine node upper bound computed pruning sum optimal solution matching original graph k decisions made optimal solution matching cardinal ki difference graph third program based hungarian method algorithm goes search tree program looking near optimal solutions cf section 33 node vertex v v 1 selected branch matches one vertices x removing edges vx x x first branch explored corresponds current assignment v solution given hungarian method upper bound sum best possible matching given hungarian method estimate submatching size k difference graph estimate constraint algorithm constraints 266b 01s 433b 01s 735b 01s 19kb 21 26kb 99 44mb 700 flow 5 hungarian matching 20b 22b 31b 30b 30b 34b 40b 71b 107b table replacing k machines figure 4 shows three strategies problems constraintbased approach performs better approach based flow algorithm well algorithm using hungarian method constraint approach much faster smart algorithm n10 little faster n20 somewhat slower n30 much slower n40 anyway upper limit constraintbased approaches pure matching problems main advantage simplicity took simple lines code modify upper bound original constraint algorithm compared algorithms makes constraint approach good solution small midsized problems even values k 10 solution based incremental hungarian method well adapted large problems 42 bimatching second problem addresses case combination two matching problems two distinct weight matrices one problem used satisfiability one optimization tasktomachine assignment amounts maximizing production keeping energy consumption certain level difficulty varies according role played passive matching problem value chosen maximal energy consumption low high energy matching dominating problem marginal hand intermediate values make problem much harder shape solution space equally affected matching problems implies distribution feasible solutions search tree longer concentrated one areas dispersed linear programming perspective bi matching problem made three components matching constraints shared two matching problems energy consumption constraint cost function represent optimization production classical approach situation use lagrangean relaxation push energy constraint cost function implemented several solutions find maximal production matching consumption less given constant first one also straightforward adaptation basic constraint program search guided optimization production consumption constraint used pruning two lower bounds consumption estimated sum edges least consumption vertex set moreover instead considering regret production function consider sum regrets production energy function therefore program obtained simple replication lines original basic program energy substituted production second algorithm branch bound algorithm using twice incremental hungarian method two hungarian matchings constructed one maximal production one minimal consumption branching based hungarian matching maximal solutions matchings used prune branch cut minimal consumption strictly greater e maximal production less best one found far third one fourth based lagrangean relaxation busakers flow algorithm hungarian method general principle method put constraints objective function certain coefficient vary value coefficient 93 assuming relaxed problem ie without constraint pushed cost function simpler solve push energy constraint cost function obtain simple matching problem solve flow algorithm objective function becomes total weight matching following weight function edges weight l u let us call fl value maximum matching weight l construction fl l 0 upper bound original problem since energy consumption smaller e compute value f minimal value fl l varies l 0 f also upper bound found dichotomic search provides us upper bound high quality also varying value l possible lower bound one l yields admissible energy bounds computed node search tree branching made edges matching optimal flow indicated third approach previous section third program straightforward implementation lagrangean relaxation flow algorithm fourth one implementation lagrangean relaxation hungarian method tries incremental possible trying keep part dual solution similar values l inc hung match 24kb 26kb 71 32 kb 140kb 500 900 14kb lagragean relaxation flow algorithm 20b 31b 102b 22b 107b 31b 72 197b 87b lagragean relaxation hung match 14b 51 64b 80b 28b 86b 50 28b 180b 296b constraints basic 1kb 28kb 12 30kb 13 2kb 900kb 43 table bimatching table 5 compares four algorithms two problems cost weight functions randomly generated values ranging 1 100 balance optimization cost feasibility energy cut search tree e small close value minimal energy consumption matching energy responsible pruning program behaves like simple matching one symmetrically e large problem almost unconstrained looks like simple maximal production matching program hardest situation energy cost responsible pruning search tree situation corresponds e 550 e 900 examples lagrangean relaxation pays large problems criterion dominates however seems real life problems criterion often dominates point view constraint approach much efficient constraint program performs better simple algorithm two incremental hungarian matchings also performs better except balanced situation n30 complex lr program fact hungarian method mildly incremental lagrangean relaxation scheme dual solution cannot easily repaired change weight function 5 application previous section shown strenghts constraintpropagation approach compared specialized algorithms shall see techniques combined opposed consider timetabling problem consists filling weekly schedule set lessons duration 1 4 hours lesson given set possible start times set preferred start times schedule made 10 halfdays 4 hours lessons interrupted section illustrates weighted matching techniques applied problem provide significant improvement notice lessons duration 1 problem would indeed matching problem suggests straightforward relaxation consider lessons interruptible second preferences encoded using weights minimum weight matching corresponds assignment using many preferred start times possible rest paper consider lessons l 1 l schedule n time slots length 1 hour 4 lesson given two lists time slots integers 1 n represent respectively set possible preferrred start times goal find start time lesson two lessons overlap ususal disjunctive scheduling constraint pairs lessons either startl startl lesson fits half day within half day says th halfday covering time units 4i1 4i2 4i3 4i4 lessons duration 4 start first unit 4i1 lessons size 3 start units 4i1 4i2 etc number defaults defined number lessons assigned start time outside set preferred times minimal problem dependent range input data problem seen combination satisfiablility problem filling schedule optimization problem assignment problem lessons large enough problem may look like binpacking preference optimization almost irrelevant hand smaller lessons packing much easier optimisation problem dominates similarly difficulty preferences ie tightness preference sets augment importance optimization component problem picked three problems representative different situations problem 1 uses rather short lessons highschool schedule complex preferences optimum 6 defaults problem 2 similar lesson size point view simpler preferences optimum 1 last problem uses larger lessons explore algorithm would react problem satisfiability issue order exploit matching relaxation decompose lesson duration k k units 1 hour total number u units therefore sum durations lessons matching need build associates start time time slot unit unit u associated lesson l time slot give weight edge ui follows cannot happen would imply illegal start time lesson l u happen implies start time outside preferred set happens lesson l starts one preferred time define minweightalldifferentstartu 1 startu u w minimum weight matching graph recall value computed efficiently hungarian matching also maintained incrementally throughout search procedure section 3 described recompute value edges removed graph since lesson l k units straightforward check optimal solution timetabling problem correspond minimum weight matching schedule defaults value matching 1000 u 12 thus search solution less defautlts use redundent constraint solve three problems used branchandbound algorithm minimizes number defaults branching done starting time lesson trying perefered values first lesson branch picked using firstfail heuristics start time decision propagated follows discard values lessons could cause overlap lesson assigned start time units composing lessons set accordingly number default reaches upper bound edges preferred removed use redundent constraint detect becomes impossible place large lessons value duration strictly larger halfday example 3 hours compute set lessons lessonsd duration union possible half days lessons possibled check possibled lessonsd finally check possible432 2 problem 1 24 lessons 39h problem 2 26 lessons 40h problem 3 14 lessons 39h 1 simple propagation 189 kb 1541 286 kb 1040 43 kb 246 2 matching cut 31 kb 177 269 kb 1008 27 kb 160 3 regins filter 31 kb 197 269 kb 1243 27 kb 160 4 weighted matching cut 3511 b 29 234 b 26 17 kb 120 5 global consistency 1206 b shaving 382 b 96 183 b 11 5888 b 314 table applying various weighted matching techniques timetabling problem table 6 gives result obtained following approaches 1 first method performs constraint propagation 2 second method checks underlying matching problems units still feasible ie exists perfect matching 3 third method removes edges belong least one perfect matching using regins algorithm r94 4 fourth method uses new global constraint minweightalldifferent 1 propagated explained earlier using incremental hungarian method 5 fifth method uses lookahead consistency check trying unassigned lesson l discard prefererred respectively nonpreferred edges trying means detect removal values would create contradiction propagation constraints contradiction detected deduce lesson l must start preferred resp nonpreferred time 6 sixth method applies global consistency technique consists trying possible start time removing produce contradiction similar shaving technique used jobshop scheduling cl96 conclusions drawn experiments first global constraint minweightalldifferent brings serious improvement standard propagation local consistency problem 2 number backtracks divided factor 1000 moreover overhead keeping value minimal weight matching date incremental hungarian method reasonable compared cost simple matching propagation bounding defaults indeed addition minweightalldifferent average time per backtrack three instances goes 41 ms 73 ms therefore gain search tree sizes turns real speedup second propagation unweighted matching constraint difference constraint done efficiently filtering algorithm proposed r 94 marginal impact resolution problem compared propagation weighted matching constraint third seems good idea check global consistency performing limited breadthfirst exploration search tree limited depth one seems work better branching decisions based satisfaction lessons method 5 rather actual assignements time slots lessons method 6 due fact complexity method 5 smaller method 6 moreover global consistency techniques work best timetables large blocks lessons duration 3 4 rather problems small lessons matching relaxation accurate 6 conclusion first conclusion might constraint propagation competitive technique pure weighted matching problems specialized algorithms simple enough used appropriately hand constraint propagation plausible approach augmented matching problems depending complexity additional constraints size problem performances obtained easily cp approach range reasonable excellent compared specialized approaches cases good enough best approach incorporate weighted matching techniques constraint based branch bound search first contribution paper set generic techniques improve performance constraintbased branchandbound algorithms problems namely binary branching scheme based regret use implicit symmetry lookahead bounding functions techniques may applied augmented matching problem actually applied success traveling salesman problem cl97 second contribution show indeed weighted matching considered global constraint minweightalldifferent since know propagate efficiently using incremental version hungarian algorithm useful global constraint shown timetabling example constraint solver offers feature able solve problems hard soft constraints time taking advantage weights whereas system relies simple matching implement soft constraints second layer much less efficient way must also notice feature allows us combine best worlds two augmented problems studied part 4 keep simplicity flexibility constraintbased approach ensuring robustness underlying matching algorithm acknowledgments would like thank anonymous referee helpful comments suggestions earlier version paper r deductive objectoriented approach complex scheduling problem improved clp scheduling tasks intervals cumulative scheduling task intervals solving small tsps constraints introduction algorithms matching handbook operations research management science networks faster scaling algorithms network problems concurrence et coopration de modles multiples consistency networks relations running efficiently arc consistency combinatorial optimization filtering algorithm constraints difference csps modern heuristic techniques combinatorial problems constraint satisfaction logic programming graph algorithms tr
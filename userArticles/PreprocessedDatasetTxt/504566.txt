reductions nonclausal theorem proving paper presents tas methodology new framework generating nonclausal automated theorem provers present complete description atp classical propositional logic named tasd ideas make use implicants implicates extended natural manner firstorder logic nonclassical logics method based application number reduction strategies subformulas rewritesystem style order reduce complexity formula much possible branching specifically introduce concept complete reduction extensions pure literal rule ofthe collapsibility theorems strategies allow limit size ofthe search space addition tasd syntactical countermodel construction example power tasd study class formulas linear proofs number branchings either resolution dissolution factoring applied applying method formulas get proofs without branching addition experimental results reported copyright 2001 elsevier science bv b introduction much research automated theorem proving focused developing satisfiability testers sets clauses however experience pointed number disadvantages natural specify realworld problem clause form translation clause form easy handle although number ecient translation methods models usually preserved translation addition clausal methods easy extend nonclassical logics partially standard clause form defined wider setting nonclausal theorem proving research mainly focused either tableaux methods matrixbased methods also ideas based data structure bdds partially supported cicyt project number tic970579c0202 stands transformaciones de arboles sintacticos spanish translation syntactic trees transformations used context recently path dissolution 6 introduced generalisation analytic tableaux allowing tableaux deductions substantially speeded central point eciency satisfiability tester control branching approach focussed previous reduction formula branched much possible actually branching specifically introduce concept complete reduction extensions pure literal rule collapsibility theorems hand another interesting point design atps capability building models provided input formula satisfiable nonclausal algorithm satisfiability testing classical propositional calculus named tasd described input algorithm need conjunctive normal form normal form output either unsatisfiable satisfiable latter case also model formula given determine satisfiability given formula firstly reduce size formula applying satisfiabilitypreserving transformations choose variable branch recursively repeat process generated task feature allows obtain useful information original structure formula make clearer proofs extend method nonclassical logics widely accepted normal form although intention paper introduce required metatheory tasd currently tested obtaining promising results opinion results tests allow consider tas framework reliable approach automated theorem proving tas ideas widely applicable apply dierent types logics flexible provide uniform way prove soundness completeness addition easily adaptable switching dierent logic possible without redesign whole prover fact already extended classical first order logic 4 temporal logic 5 multiplevalued logic 1 2 structure paper follows 1 firstly necessary definitions theorems support reduction strategy introduced section 2 2 later algorithm tasd described section 3 3 finally comparative example included section 4 shows class formulas linear proofs number branchings either resolution dissolution factoring applied 3 7 applying tasd formulas get proofs without branching 11 overview tasd tasd satisfiability tester classical propositional logic therefore used refutational atp method like tableaux methods syntactical model construction reduction strategies main novelty method respect nonclausal atps like methods tasd based disjunctive normal form power based intrinsically parallel design involved transformations also fact transformations applied one guided syntaxdirected criteria described sections 22 24 whose complexity polynomial criteria allow us 1 detect subformulas either valid unsatisfiable equivalent literals 2 detect literals possible obtain equisatisfiable formula appears therefore decrease size problem much possible branching checking criteria give opportunity reduce size problem creating one subproblem addition reductions contribute exponential growth however important feature reductions enable exponential growth rate limited atp tasd sound complete furthermore model building method generates countermodels natural manner 12 preliminary concepts definitions throughout rest paper work classical propositional language connectives standard semantics v denotes set propositional denotes set literals literal opposite literal also use usual notions clause cube implicant implicate negation normal form nnf denotes subformula denotes proper subformula assignment application set propositional variables v 0 1 domain assignment uniquely extended preserving standard semantics whole language formula said satisfiable exists assignment 1 case said model formulas b said equisatisfiable satisfiable b satisfiable formulas b said equivalent denoted b assignment denotes logical consequence finally symbols mean truth falsity transformation formula nnf linear repeated application de morgan rules double negation rule equivalence b ab following consider formulas nnf addition using associative laws consider connectives flexible arity expressions like 1 n 1 n well formed formulas use standard notion tree address node tree address syntactic tree formula mean confusion arises subformula corresponding node address denote address root node similarly say subformula b mean occurrence b b denotes address node corresponding b set literals 1 2 n set literals expression denotes formula obtained substituting every occurrence c formulas b abc denotes result substituting occurrence b c 1 n set literals c formulas expression 1 c 1 n c n denotes formula obtained substituting every occurrence c address c nnf expression ac formula obtained substituting subtree rooted c adding information tree lists sets idea underlying reduction strategy use information given partial assignments extensively used quines method 8 unitary assignments show powerful manner associate nnf two lists 2 literals denoted associated lists two sets denoted c c whose elements obtained associated lists subformulas lists sets key tools method reduce size formula analysed satisfiability 21 lists nutshell respectively lists implicates implicants purpose lists twofold firstly transform formula equivalent smallersized one section 22 secondly means c b sets sections 23 24 get equisatisfiable smallersized one formal definition following 1 given nnf recursively defined follows addition elements 0 list considered conjunctively connected elements 0 list considered disjunctively connected simplifications applied namely 0 0 simplified 1 simplified use lists lexicographic order facilitate presentation examples reader interpret sets intuition behind definition easy explain since 0 intend calculate implicates 0 since union implicates conjunct set implicates conjunction use example 1 2 3 ps st 22 information lists section study information contained lists given formula first theorem states elements 0 implicates elements 1 implicants follows easily structural induction definition b lists theorem 1 let nnf literal 1 0 equivalently 2 1 equivalently immediate corollary previous theorem following result structure lists corollary 1 every nnf one one following possibilities b 0 1 b following corollary states condition 1 lists directly implies satisfiability formula satisfiable 1 assignment model hand following result states conditions lists assuring validity unsatisfiability formula corollary 3 let nnf 1 conjunct 0 clause 1 2 w n disjunct 0 cube 0 proof 1 let using results theorem 1 0 therefore 2 similar previous one definition 2 nnf label means associate node ordered let us name formulas whose lists allow determine either validity unsatisfiability definition 3 nnf said finalizable one following conditions holds 1 2 definition applicable current formula detected unsatisfiable following three definitions referred subformulas current formula detected either valid unsatisfiable equivalent literal 1 conclusive one following conditions holds 1 2 disjunct 0 cube 0 0 conclusive one following conditions holds 1 2 conjunct 0 clause 1 simple literal rs nil nil qst qrs nil figure 1 tree previous results state amount information lists enough detect unsatisfiability results applied given formula resulting one said restricted formal definition following definition 4 let nnf said restricted satisfies following conditions finalizable subtree either 0 conclusive 1 conclusive simple neither leaves 3 previous results state nnf repeatedly applying following sequence steps get restricted formula 1 label 2 substitute subformulas b either b 1 conclusive b 0 conclusive literal b simple 3 simplify logical constants soon introduced using 01laws 4 check unsatisfiability namely chech whether finalizable example 2 given formula linear transformation allows get nnf equivalent negation depicted fig 1 readability reasons leaves labelled figures labelling method finds node 6 rightmost branch ssimple ssimple subtree substituted formula b fig 2 obtained new applications lists get information equivalence formula given following theorem corollary 3 although input formula supposed contain occurrences logical constants introduced reductions see rs nil nil qst r figure 2 tree tb theorem 2 let nnf literal 1 0 2 1 proof 1 let assignment prove theorem 1 item 1 since 0 therefore result obvious second item proved similarly immediate consequence previous theorem following satisfiabilitypreserving result stated used later corollary 4 let nnf 0 equisatisfiable furthermore model extension 1 model following theorem allows substitute whole subformula c literals theorem 2 logical constant theorem 3 let nnf c 1 2 3 0 0 c ac 4 0 1 c ac proof 1 theorem 1 c c let interpretation rest items proved similarly 23 sets previous section information lists used locally information b used reduce node using theorem 1 section purpose defining new structure sets allow globalisation information information b refined information ancestors given restricted nnf define sets c whose elements pairs filtered b list associated subformula b address b section 24 see transform formula equisatisfiable smaller sized one using sets definition sets based filter operator filters information lists according theorems 2 3 specifically literals lists allow substitute subformula either consequence theorem 3 hand theorem applicable still possible delete rest dominated application theorem 2 fact dominated literals deleted framed used extension mixed collapsibility theorem given restricted nnf b filter 0 b 1 literal consequence theorem 3 items 1 3 2 result framing literal consequence theorem 2 items 1 2 resp filter 1 b 1 literal consequence theorem 3 items 2 4 2 result framing literal consequence theorem 2 items 2 1 resp definition 5 let restricted formula b 0 1 set c recursively defined follows literal c c otherwise c subformula b b nil following example present stepbystep calculation c sets example 3 consider formula whose labelled tree appears nil rs r nil ps r nil q q nil qrs tree c literal p nodes 3111 3112 311 framed occurrence 0 literal node 3112 framed occurrence 1 hand c following c qs 22122 qr 221 qrs 222 q 22 pq 2 3 node 211 substituted occurrences q 1 2 q 1 211 node 22121 substituted occurrences p 1 2 finally occurrences framed occurrence p 1 2 occurrences q framed occurrence q 1 2 b sets meaningpreserving results section study information extracted sets stated theorem 4 proof use following facts sets given restricted nnf element c since restricted nnf cannot finalizable c b address leaf since c c literal 0 c list framed literals note literal framed information lists ancestors following theorem states labels labels also allow substituting subformulas either theorem 4 let restricted nnf 1 c 2 c proof 1 suppose c let c subformula address definition c exist formula b c b literal satisfying corollary 1 using 0 c address cannot correspond leaf restricted nnf specifically simple subformulas get 1 note clearly enough prove b bc firstly prove hypotheses 1 b 1 bc b 0 b 0 bc proof induction depth b denoted db db commutativity associativity cannot case would 1 c contradicts fact 1 therefore must consequently bc using 1 1 therefore 1 ii assume result dx us prove db result obvious induction hypothesis 1 b 1 c 1 bc induction hypothesis 1 cases c b 2 similar proof b obtained duality finally prove b bc considering two possibilities 1 0 c 1 b bc theorem 3 bc theorem 1 0 c 0 b bc theorem 3 bc b theorem 1 2 proof similar note theorem introduces meaningpreserving transformation allows substituting subformula constant information given lists substitutes subformulas equivalent either 1 conclusive 0 conclusive however hypotheses theorem need true equivalent either nnf said restricted restricted satisfies following elements c elements c nnf label means label associate root ordered pair c c note given restricted nnf calculating c c unsatisfiability equivalent restricted nnf means substitutions determined theorem 4 01lawsb sets satisfiabilitypreserving results following results allow using information sets substitute nnf equisatisfiable smaller sized occurrences literals occurring complete reduction theorem begin corollary 4 stated terms sets follows theorem 5 complete reduction let nnf c satisfiable satisfiable furthermore model extension 1 model note result allows eliminate occurrences literals appearing named complete reduction usefulness shown examples generalised pure literal rule introduction sets allows generalisation wellknown pure literal rule sets clauses firstly recall standard definition result formula nnf definition 7 let literal occurring nnf literal said pure occur nnf pure literal satisfiable satisfiable furthermore model extension 1 model sets allow generalise definition pure literal consequence get extension lemma definition 8 let nnf literal said pure satisfies following conditions 1 occurs c 2 occurrences c framed next theorem proper extension lemma 1 applied even occur theorem 6 generalised pure literal rule let nnf let pure literal let b formula obtained following substitutions c node substituted ii c node substituted satisfiable b satisfiable furthermore model b extension 1 model proof theorem 2 definition sets c addition b c addition therefore consider formula obtained applying equivalences items b get literal pure application lemma 1 get formula b completes proof rest section introduce necessary definitions extend collapsibility results introduced 9 collapsibility theorems definition 9 let nnf 1 2 literals literals 1 2 01bound following conditions satisfied 1 occurrences 4 either 1 2 c 1 2 2 occurrences either 1 2 c definition sets remark 1 1 2 01bound every leaf literal 1 ancestor maximal sense associated lists satisfy one following conditions ancestor none literals 1 2 1 2 occur lists associated ascendant none literals 1 2 1 2 occur lists associated use following notation proof collapsibility results literals b 0 1 theorem 7 collapsibility let nnf let 1 2 literals 1 2 01bound satisfiable 1 1 satisfiable furthermore model 1 1 extension 1 model proof part immediate part let us suppose satisfiable let satisfying assignment nothing prove let us consider prove also satisfied assignment 1 remark 1 considered formula language following set atoms every leaf either formula literal 1 note 1 1 let assignment obtained changing values follows 4 section say occurrence mean unframed occurrence assignment satisfies 1 coincides rest leaves therefore satisfying assignment 1 result generalisation van gelders collapsibility lemma treats case occurrences 1 bound 1 2 1 2 represented single literal 1 2 see 9 details result drops requirement occurrences defining subset 1 2 children node occurrences defining subset 1 2 children node obviously previous result straightforwardly extended case n literals collapsed one definition 10 let nnf let 1 n literals literals 1 n 01bound following conditions satisfied 1 c occurrences 1 n c 1 n j 2 c occurrences 1 n c 1 n j corollary 5 generalised collapsibility let nnf let 1 n literals 0 1bound satisfiable 1 n1 1 n1 satisfiable furthermore model 1 n1 1 n1 extension j model example 4 van gelders reduction lemmas cannot applied formula example 3 collapsible sense theorem 7 following sets c c qs 22122 qr 221 qrs 222 q 22 pq 2 3 specifically p q 01bound order state generalisation mixed collapsibility need following definition definition 11 let nnf b 0 1 let 1 2 literals literal 1 bbounded 2 following conditions satisfied 1 c occurrences neither framed unframed either 1 1 2 c 1 2 1 2 definition 1 bbound 2 formula every leaf belonging ascendant theorem 8 mixed collapsibility let nnf 1 2 literals 1 1 0bound 2 formula obtained applying following substitutions c substituted 1 1 c substituted 1 1 satisfiable satisfiable addition satisfying assignment extension 1 assignment 2 1 1bound 2 formula obtained applying following substitutions c substituted satisfiable satisfiable addition satisfying assignment extension 1 assignment proof 1 note considered formula language set atoms every leaf either formula literal 1 1 let satisfying assignment 1 theorem 2 every leaf 1 2 0 theorem 2 2 theorem 2 consider assignment obtained changing value obviously monotonicity boolean conjunction disjunction conversely let satisfying assignment let extension theorem 2 every leaf 1 2 0 every leaf 1 2 0 2 proof similar example 5 following formula example 2 formula b figure 2 c c therefore first subtree pruned obtaining tree fig 3 rs nil nil qst r figure 3 tree tc variables r deleted theorem 5 complete reduction rs c storing information able generate model exists input formula addition p 1bounded therefore theorem 8 mixed collapsibility 1 3 substituted information p stored resulting formula q finalizable 1 q specifically satisfiable model deduce input formula example 2 nonvalid negation collecting stored information get following countermodel two possibilities information splitting formula finish section introducing satisfiabilitypreserving result prevents branching suitable hypotheses hold splitting call results consequence following wellknown theorem theorem 9 quine satisfiable ap ap satisfiable model ap extension assignment model similarly model ap extension assignment model satisfiablepreserving reduction applied restricted conjunctive nnf would branch following definition states situation formula branched split restricted nnf said psplittable j p j corollary 6 let restricted psplittable nnf satisfiable v ijp p v ij p p satisfiable furthermore model p extension assignment model similarly model extension assignment model result seen generalisation davisputnam rule following advantages applicable nnf cnf shifted nonclassical logics interactions reduction strategies turn extremely ecient advantage use transformation problem branched split two subproblems occurrences p substituted logical constants describe algorithm prover following steps applied previous examples 3 tasd algorithm section describe algorithm tasd soundness completeness proved flowchart algorithm appears figure 4 keep mind tasd determines unsatisfiability input formula therefore viewed refutational atp data flow algorithm pair b b nnf set expressions literal occurring b elements define partial interpretation input formula used collectinfo necessary interpretation defined follows general due second condition might define one interpretation depending choosing operators involved algorithm described soundness one follows results previous sections initialisation stage nnf users input translated nnf operator nnf specifically b nnf equivalent b reduce finalizable root parallel update spreduce subreduce qbranch unsat model satisfiable restrict restrict figure 4 flowchart tasd algorithm update module dierent stages algorithm transform subtrees input tree trans formation labels ascendant nodes transformed node deleted update processes trees recalculating missing labels giving output either restricted nnf finalizable formula another point view stage updates formula sense prunes subtrees directly deduced equivalent either literal restrict operator input restrict pair b b partially labelled formula possibly logical constants given nnf b restrictb c c restricted formula obtained b indicated definition 4 restrict operator input restrict pair b b restricted formula c restricted formula obtained b indicated definition 6 parallelization input parallel pair b b restricted formula parallel since disjunction satisfiable disjunct satisfiable pair independently passed reduce following module algorithm reduce module input reduce labelled syntactic tree restricted nnf stage decrease possible size b branching using information provided labels labels specifically labels root node allow using spreduce operator substitute b equisatisfiable formula propositional variables eliminated labels proper subtree x allow using subreduce operator substitute subformula x equivalent formula symbols lists occur exactly spreduce operator restricted nnf b said spreducible either completely reducible ie element c pure literals pair 01 bound literals literal bbound literal formulas obtained applying following items 1 c theorem 5 2 pure b c obtained formula applying b substitutions theorem 6 3 01bound c obtained formula applying b substitutions theorem 7 4 bbound c obtained formula applying b substitutions theorem 8 subreduce operator input subreduce restricted spreducible nnf eect described application theorem 2 associativity commutativity formal definition needs extra terminology included definition 13 let spreducible consider w integers denoted j defined associated denotes cardinality finite set said reducible 1 associated let reducible consider defined follows application theorem 2 subreducible subformula b one following conditions holds b reducible literal theorem 2 subreduction preserves meaning therefore c obtained traversing tree depthfirst order find first subtree b indicated 1 apply theorem 2 either 2 substitute b b otherwise interest using subreductions make possible reductions use reductions branching one main novelties method respect others specifically unit clause rule davisputnam procedure special case sp reduction also 9 uses weak version subreductions dominance lemma applies substitutions first level depth subformula split operator input split pair b restricted psplittable nnf neither spreducible subreducible two tasks treated independently update process branching qbranch operator input qbranch pair b b restricted nnf neither sp reducible splittable subreducible nnf two tasks treated independently update process experimental tests show best results obtained choosing p propositional variable occurrences formula analysed information easily obtained sets collecting partial results collectinfo collectinfo operator collects outputs update subproblem generated either parallel split qbranch finishes execution algorithm outputs subproblems collectinfo ends algorithm output unsatisfiable subproblems outputs collectinfo ends algorithm output satisfiable model built subproblems outputs satisfying ends algorithm output satisfiable model built first element 1 31 soundness completeness tasd termination algorithm described obvious applied process reduces size andor number propositional variables formula specifically worst case reduction applied applicable process qbranch decreases one number propositional variables formula prove soundness completeness tasd theorem 10 tasdasatisfiable satisfiable proof suces show processes algorithm preserve satisfiability process nnf clearly preserves meaning translation nnf processes modules update reduce preserve either meaning satisfiability results section 2 finish proof one keep mind subproblem generating processes parallel split qbranch based following fact disjunction satisfiable disjunct satisfiable process collectinfo preserves satisfiability well 32 complete examples example consider formula result updatennfa b pr pq r 1 pq 2 c reduction applied wrt p consequence get updatespreduceb output unsatisfiable therefore valid example 7 consider formula ps nil q nil rs r c c reduction module apply tree b input qbranch apply qbranch wrt variable p obtain subproblem c 1 studied restrict get following tree nil rs r second subproblem c 2 qs nil rs r c c restricts output fed spreduce formula completely reduced qs c therefore applying substitutions q simplifying logical constants get 0 conclusive therefore updatec 2 subproblems generated qbranch output collectinfo produces output unsatisfiable therefore valid example 8 let us study satisfiability formula example 4 nil rs r nil ps q ps nil c sets previous formula following c c application restrict substitutes 211 22121 result equivalent formula b nil rs r r q nil qrs ps nil c c c allows substitute 232 obtaining equivalent formula c nil rs r c c therefore updatea spreduce applied literals p q 01bound substitute occurrences p ie restrictspreducec nil rs r nil rs r c c substituting 311 get rs 1 qrs 2 qs 3 nil rs r nil qrs formula q 1bounded spreduce substitutes branches addresses 2 3 r finalizable 1 nil stage collectinfo ends algorithm output satisfiable model determined interpretation model note defined also model 4 comparative example put method connection existent approaches literature study collection n clausal forms taken 3 also use notation propositional variables consider instance 3 clause contains atoms form p string superscripts clause always form sequence 12 n subscript literal exactly sequence signs preceding literals clause n built n1 added positively negatively easy see n 2 n propositional variables 2 n clauses contains n literals 3 cook reckhow described family n n 1 showed study satisfiability intractable analytic tableaux handled linear time resolution 7 murray rosenthal showed dissolution factoring provides proofs class linear number input clauses n apply tasd test satisfiability n get subreducible instance formula reducet 3 expressed equivalently formula thus restrict reduces previous tree four 0 conclusive subtrees namely conjunctions p 3 simplifying four leaves get therefore using tasd detect unsatisfiability formulas n branching conclusions presented nonclausal satisfiability tester named tasd classical propositional logic main novelty method dierence approaches reductions applied formula dynamically selected applied subformulas like rewrite system following syntaxdirected criteria specifically introduced extensions pure literal rule collapsibility theorems fact increases eciency decreases branching example power tasd studied class formulas linear proofs number branchings either resolution dissolution factoring applied hand applying method formulas get proofs without branching acknowledgments authors would like thank jose meseguer daniele mundici valuable comments earlier drafts work r reductionbased theorem prover 3valued logic reducing signed propositional logics relative e reduction techniques translating clause form using prime implicates implicates reduction techniques temporal logics dissolution making paths vanish relative meris path dissolution method analytic tableaux methods logic satisfiability tester nonclausal propositional calculus tr satisfiability tester nonclausal propositional calculus dissolution relative merits path dissolution method analytic tableaux implicates reduction techniques temporal logics ctr jun wenjiang li da ruan yang xu filterbased resolution principle latticevalued propositional logic lpx information sciences international journal v177 n4 p10461062 february 2007 p cordero g gutirrez j martnez p de guzmn new algebraic tool automatic theorem provers annals mathematics artificial intelligence v42 n4 p369398 december 2004 p cordero g gutirrez j martnez p de guzmn new algebraic tool automatic theorem provers annals mathematics artificial intelligence v42 n4 p369398 december 2004
polynomial formal verification multipliers long ago completely automatical formal verification multipliers feasible even small input word sizes however multiplicative binary moment diagrams astbmd new data structure representing arithmetic functions boolean variables methods proposed verification multipliers input word sizes 256 bits feasible unfortunately experimental data provided verification methods nowin paper give formal proof logic verification astbmds polynomially bounded space time applied class wallacetree like multipliers using knowledge online detection design errors becomes feasible verification run b introduction verifying implementation combinational circuit meets specification important step design process often done applying set testinput patterns circuit patterns simulation performed ensure oneself correct behavior circuit last years new methods proposed formal verification circuits concerning logic function represented circuit eg 1 methods based binary decision diagrams bdds methods fail verify interesting combinational circuits multipliers since bdds multiplication function exponential size 5 recently new type decision diagrams multiplicative binary moment diagram bmd 2 introduced bmds well suited representing linear arithmetic functions boolean domain bmds successfully used verify behavior combinational arithmetic circuits multipliers input word sizes 256 bits 3 motivated results several extensions approach discussed 7 6 verification method 3 based partitioning circuit components easy wordlevel specifications first shown bitlevel implementation component research supported dfg grant mo 64521 117682 module implements correctly wordlevel specification composition wordlevel specifications according interconnection structure whole circuit derived composition algebraic expression bmd generated resulting bmd compared one generated overall circuit specification problem arising methodology need highlevel specifications component modules taking problem account hamaguchi etal proposed another method verifying arithmetic circuits called method verification backward construction 9 method need highlevel information 9 experimental data provided show feasibility method specific multiplier circuits paper give formal proof verification backward construction polynomially bounded respect input word size consider specific multiplier circuit class wallacetree like multipli ers eg 11 10 additionally consider costs intermediate results also costs arise synthesis operation bmds leads possibility interrupt verification process presence design implementation failure furthermore give classes variable orders give classes depthfirst breadthfirst orderings circuit tight bounds reached 2 multiplicative binary moment diagrams section give short introduction represent integervalued functions proposed decision diagram type bmd details found 2 3 bmds motivated necessity represent functions boolean variables nonboolean ranges ie functions f mapping boolean vector onto integer numbers onto rational respectively restrict integer functions class functions booleshannon expansion generalized multiplication addition spectively f x called constant moment f called linear moment f respect variable x gamma denotes integer subtraction equation 1 moment decomposition function f respect variable x bmds rooted directed acyclic graphs nonterminal terminal vertices nonterminal vertex exactly two successors edges pointing successors named low highedge successors named low highsuccessor respectively nonterminal vertices labeled boolean variables terminal vertices successor labeled integer values low high edge nonterminal node points constant linear moment function represented node bmd data structure reduced ordered common way addition ally bmd makes use common factor constant linear moment extracts factor places called edgeweight incoming edge node could lead smaller representations ex ample bmd root vertex v labeled x weight incoming edge v represents function following denote node v labeled variable x simply node x context clear paper consider integer edgeweights integer values terminal vertices since interested integer linear functions make bmd representation canonical restriction edgeweights necessary edgeweights low highedge nonterminal vertex must greatest common divisor 1 additionally weight 0 appears terminal value either outgoing edge node points terminal node weight outgoing edge 1 note reduction terminal node value 0 appear highedge 21 basic operations bmds present detail algorithm basis verification backward construction method backward construction based substituting variables bmd function f bmd another function g according equation 1 substitution based x sketch substitution algorithm seen figure 1 starts bmdf bmdg notation bmd representing function f g respectively additionally variable x substituted handed algorithm top variable bmdf variable substituted algorithm calls recursively low high successor variable x found integer multiplication integer addition performed line 3 note operations exponential worst case behavior 8 following show specific conditions worst case occur key bmd specific structure call sum weighted variables sov bmd unsigned integer encoding example bmd sovstructure outline given figure 2 subst bmdf xbmdg f 1 check terminal cases return figure 1 substitution algorithm figure 2 sovstructure bmd properties exactly one nonterminal node variable highedge nonterminal node labeled weight 1 pointing directly terminal node labeled value corresponding variable properties substitute algorithm simplifies considerably let us assume f bmd sov g bmd sov variable x arbitrary position middle f first phase lines 4 middle f first phase lines 2 4 executed continually x reached line 3 calls multiplication addition multiplication returns result immediately since highf terminal node complexity addition depends bmds f g sovstructure reduces number execution steps since f terminal node variables later paper g bmd known size give detailed analysis returning recursive calls line 4 line 5 recursive calls highf reason line 7 ends immediately bmd e4 line 8 depth 1 reasons maintaining sovstructure long possible reduces number execution steps substitute algorithm since substitution basic operation method verification backward construction overall number execution steps reduces considerably addition sovstructure simplifies analysis complexity method extremely 3 class wallacetree like multipliers let two nbit numbers binary representation n power 2 extend n power 2 set superfluous inputs zero multiplication b equivalent summing n partial products shifted j positions left assume following divide circuit two parts one part calculates partial product bits 1 part adds partial products bits final result using fulladdercells cells arranged eg 3to2 4to2 reduction binary tree linear list influence proof detailed description representatives wallacetree like multipliers please see 10 4 4 complexity backward construction section analyze complexity method verification backward construction introduced 9 subsection 41 explain principles method subsection 42 backward construction bmds adder part circuit analyzed subsection 43 take partial product bits account discuss resulting complexity last subsection put together parts get final overall complexity 41 method backward construction general method verification backward construction works follows first primary output distinct variable assigned next step bmd output word constructed weighting summing bmds variables according given output encoding assume unsigned integer encoding outputs note obtain sovstructure resulting bmd cut placed crossing primary outputs circuit cut moved towards primary inputs output lines gate move onto cut according reverse topological order gates moving cut towards primary inputs cir cuit bmd constructed follows next line circuit crossing cut also output line gate circuit find corresponding variable bmd constructed far substitute variable output function gate delete output line cut add input lines gate cut fi nally cut moved outputs gates computing partial product bits final step substitution corresponding variables obtained bmd partial product bits step obtain bmd representing multiplication b circuit correct mentioned cut moved according reverse topological order gates general exists one order shall see proofs based knowledge specific reverse topological order long substitute variables representing fulladder outputs variables representing initial partial product bits nevertheless give one specific class variable orders statements hold even apply different topological order 42 constructing bmd adder part subsection analyze costs constructing bmd adderpart multiplier first lemma shows substitution sum carryoutput fulladder bmd sov maintains sovstructure means sov invariant substitutions reason analyze substitution costs single fullad der lemma 42 get overall costs theorem 41 theorem 42 lemma 41 let f bmd sov let x denotes set variable f let x two variables representing sum carryoutput fulladder inputs fulladder represented independent order variable sets bmds involved substitution process holds substituting x f bmds functions 1 f 0 sov 2 terminal value highsuccessors nodes high successor node x f proof proof based merely functional argu ment sum carryoutput get following functions gamma2x l xm expressing boolean operations phi integer addition subtraction multiplication ie x phi let variables x bmd f represent sum carryoutput fulladder variables weights w 2w respectively substitution x yields following function f 0 easily verified rest variables f affected since x k x l xm 62 x weighted variables f therefore bmd representing function f 0 must sov independent variable order furthermore three high edges nodes x k x l xm f 0 point terminal node value w completes proof 2 lemma 41 sure sovstructure bmd maintained fulladders basic cells substitute variables corresponding outputs particular fulladder directly one another independent chosen variable order chosen reverse topological order dag representing adder part multiplier additionally point substitution process know exactly size x x figure 3 representation substituting x su x j ca x x figure 4 bmd substitution variable bmd processed next fulladder size increased one proceed calculating costs counting calls substitute algorithm lemma 42 let f bmd sov size defined lemma 41 substituting bounded ojf respect time independent variable order order substitutions proof denote bmds su ca consider first substitution x su substitution process visualized figure 3 note order matter sum carry function totally symmetric therefore nonterminal node labels omitted substitutealgorithm calls recursively reaches node f labeled variable x obviously number recursive substcalls bounded ojf j node labeled x operation f lowx carried bmds low highedge node x point since f sov f highx terminal node call mult ends im mediately since f lowx sov su constant size addition bounded ojf j recursive substcalls constant number mult addcalls sovstructure easily verified get overall bound ojf substitution x su bmd substitution seen figure 4 variable order substitution x j ca analogous arguments hold except fact sovstructure f destroyed su see figure 4 first leads additional recursive substcalls constant su constant depth furthermore get additional calls add mult recursive substcalls nodes labeled variables x k x l xm meet number bounded constant value since su ca constant depth therefore since resulting bmd size jf j according lemma 41 get time bound ojf substitution x su x j ca independent variable order x x n fx g proof first substituting x j ca x su analogous 2 lemma 41 42 leads directly space bound construction bmd adder part theorem 41 constructing bmd adder part multiplication circuit using substitution bounded respect space independent chosen reverse topological order fulladdercells proof bmd f 0 start size follows since one nonterminal node variable representing primary output resulting bmd constructed adderpart size 2 one nonterminal node variable representing initial partial product bit exact size depends chosen realization multiplier lemma 41 42 space bound 2 2 analyzing space requirements substitu tions consider time requirements theorem 42 constructing bmd adderpart using substitution bounded 4 respect time independent chosen reverse topological order fulladdercells proof proof first count number ful ladder elements depending realization exact number elements differs asymptotically cells forming adderpart meaningful multiplier therefore number execution steps upper bound size initial bmd according proof theorem 41 sum figured follows 43 substitution partial products point analyzed complexity method verification backward construction part multiplier circuit adds initial partial product bits obtain result multiplication sequence analyze costs final step substituting partial product bits bmd figure 5 bmd substituting partial product bits figure 6 final bmd multiplication destroy sovstructure bmd starting point bmd constructed outputs gates size since n 2 partial product bits fact holds proof theorem 42 fa denoting number fulladder cells assume following fixed order among aand bword assigned primary inputs circuit fact variable order within b j interest long variables forming one input word variables forming second input word otherwise final bmd may larger 2n 2 define lowpath bmd f path f root leaf consisting lowedges note one path bmd show intermediate bmds structure like figure 5 small box edge denotes multiplicative factor nodes terminal highsuccessor upper diagonal line lowpath marked variable x k assigned fulladder input line lines also output lines gates nodes nonterminal highsuccessor labeled variable also lowpath highsuccessors labeled variable b j located lower diagonal line final bmd structured shown figure 6 theorem 43 let f bmd constructed adder part substitution variables f bmds initial partial product bits delta b j bounded 2 respect space 4 respect time independent variable order f independent chosen reverse topological order gates proof let f 0 denote intermediate bmd generated substitution initial partial product bits node labeled variable x yet substituted must lowpath f 0 consider substitution node x bmd initial partial product bit obviously number recursive calls substitute algorithm figure 1 bounded ojf 0 j last recursive subst calls ie node x following operations carried call mult ends immediately since x terminal highsuccessor sovstructure f beginning substitution process add calls distinguish two different cases 1 nodes substituted initial partial products bits variable since node x one nonterminal node substituted lambdab mda nonterminal nodes size f 0 increases 1 node variable b j shared remains unchanged otherwise variable comes predecessor variable x variable order lambdab mda reaches final position bmd f 0 calls add final substitute call ieline 3 figure 1 number calls obviously bounded ojf 0 j variable comes predecessor variable x variable order reaches final position bmd f 0 calls add resolving previous substitute calls line 8 figure 1 number add calls con stant one easily make sure furthermore one call makenode one call mult previous subst calls lines 6 7 figure 1 2 exists already node variable ie nodes f already substituted initial partial product bits far exists also node b j eg created substitution initial partial product bit l delta b j size f 0 substitution may decreases 1 node b j shared remains unchanged otherwise difference first case additional number n add calls position b j variable order among b 1 worst case occurs b bound total number calls ojf cases 1 2 together give bound total number algorithm calls ojf 0 j substitution node x lambdab mda increase n size starting bmd f first n initial partial product bits substitution process different avariables size f 2 size intermediate bmds substitution bounded proves first part theorem fur thermore since number substitutions bounded size starting bmd f 2 get overall time bound proves second part theorem completed proof 2 44 complexity backward construction theorema 41 42 43 conclude method backward construction applied class wallacetree like multipliers bounded 2 respect space 4 respect time bounds largely depend chosen variable order single substitution steps additionally bounds also depend order substitutions long first substitute fulladdercells afterwards initial partial product bits allow one restriction variable order ing attain totally free substitution ordering across circuit parts means class variable orders substitute initial partial product bit processed fulladder cells nevertheless complexity remains polynomial regard reverse topological order whole multiplier circuit define x b variable order variable order first xvariables second variables third bvariables xvariables denote fulladder outputs bvariables denote variables input words multiplier give following theorem theorem 44 given x b variable order method backward construction applied class wallace tree like multipliers bounded 2 respect space 4 respect time independent reverse topological order circuit proof bmd decomposes two parts upper part consists xvariables sov despite fact last highedge points nonterminal node labeled avariable lower part consists aand bvariables consider two cases 1 substituting su ca first find substituted variable found upper part bmd depending variable ordering within x k add operation substitution continues downward bmd maximally reaches edge pointing 0 respectively ever smallest avariable far recursive calls terminate since x k k theo rema 41 42 applied costs considering size upper part bmd 2 substituting partial product theorem 43 applied one open problem complexity allow initial partial product bits substituted fulladder cells processed different variable order theorem 44 ie xvariables beginning variable order expect complexity remains still polynomial since structure resulting bmd similar one used 5 conclusions future research paper analyzed complexity method verification backward construction applied class wallacetree like multipliers gave formal proof polynomial upper bounds runtime space requirements respect input word sizes method note experimental data given show feasibility method conclusion results prematurely detect design errors watching bmd errors result non correct bmd sizes assume processed gates adderpart circuit processing ith gate bmd size jf actual bmd size error assume considered least initial partial product bits circuit size bmd depends initial partial product bits substituted considering accurate size bound bmd must larger jf 0 j fan smaller 2n time future research directions remove restrictions eg variable order mentioned take look integer dividers could verified backward construction far r hsis bddbased environment formal verification verification arithmetic functions binary moment diagrams verification arithmetic circuits binary moment diagrams easily testable optimaltime vlsi multiplier complexity vlsi implementations graph representations boolean functions application integer multiplication hybrid decision diagrams overcoming limitations mtbdds bmds note complexity binary moment diagram representations efficient construction binary moment diagrams verifying arithmetic cir cuits recursive implementation optimal time vlsi integer multipliers suggestion fast multiplier tr graphbased algorithms boolean function manipulation complexity vlsi implementations graph representations boolean functions application integer multiplication sequential circuit verification using symbolic model checking symbolic boolean manipulation ordered binarydecision diagrams hsis verification arithmetic circuits binary moment diagrams efficient construction binary moment diagrams verifying arithmetic circuits hybrid decision diagrams phdd logic synthesis verification algorithms kbmds verification arithmetic functions binary moment diagrams
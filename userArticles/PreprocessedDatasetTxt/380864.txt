optimal slicing parallel programs optimal program slicing determines statement program pgr whether affects specified set statements given conditionals pgr interpreted nondeterministic choicesonly recently shown reachability program points hence also optimal slicing undecidable multithreaded programs parameterless procedures synchronization 23 sharpen result proving slicing remains undecidable synchronization abandonedalthough reachability becomes polynomial moreover show multithreaded programs without synchronization slicing stays pspacehard procedure calls forbidden becomes nphard loopfree programs since latter two problems solved pspace np respectively even presence synchronization new lower bounds tightfinally show decidability lower bound properties equally apply simple program analysis problems like copy constant propagation true liveness variables contrasted problems strong copy constant propagation ordinary liveness variables polynomial algorithms designed 15 14 24 b introduction static program slicing 27 established program reduction technique applications program standing debugging testing 26 recently also proposed technique ameliorating stateexplosion problem formally verifying software hardware 13 10 4 18 goal program slicing identify remove parts program cannot potentially influence certain values certain program points terest latter called slicing criterion vast amount literature slicing sequential languages see references tips survey 26 crucial idea found many variations perform slicing means backwards reachability analysis graph modeling basic dependences instructions approach pioneered ottenstein ottenstein 21 proposed use structure called pdg program dependence graph apdg captures two kinds dependences data dependences control dependences intuitively statement data dependent another statement updates variable referenced example x e f data dependent appears e path program statement updates control dependence captures guards branching statements loops may determine whether statement executed formal definition found eg 26 first considered static slicing concurrent languages j cheng 3 recent years interest problem increased due proliferation concurrent languages work connection slicing javalike languages 10 28 vhdl 13 4 promela 18 input language spin model checker articles common slicing approached backwards reachability problem extended form pdg called process dependence net 3 multithreaded dependence graph 28 etc structures model dependences besides data control dependences may arise concurrent programs considered kind one dependence interference dependence 17 10 statement interference dependent statement another thread two threads may run parallel variable updated referenced captures situation parallel execution two threads may executed way shared variable overwritten interference dependence may interpreted kind data dependence arising interleaved execution kinds dependences represent data flow induced message passing control flow induced synchronization operations program slicing algorithm must sound must slice away parts program aect given slicing criterion ideally slicer remove much program possible without sacrificing soundness weiser 27 showed already problem determining whether slice statementminimal undecidable 26 p 7 problem undecidable whether condition found program may true false execution path dataflow analysis general suers problem common remedy ignore conditions altogether defining feasible paths words conditional branching interpreted nondeterministic branch ing point view adopted paper call slicer optimal determines statementminimal slice abstraction sequential intraprocedural case ie single proce dures pdgbased slicing ecient optimal optimality also achieved sequential interprocedural case solving contextfree reachability problem system dependency graph sdg program question 11 analysis done polynomial time 26 concurrent languages procedures synchronization primitives even reachability undecidable recent result ramalingam 23 implies also optimal slicing cannot decidable paper consider optimal slicing concurrent languages drop facility synchronization consequence reachability well reverse reachability become decidableeven polynomial 5 6 24 new result optimal slicing remains unde cidable refine new undecidability result proving optimal slicing pspacehard case procedure calls still nphard also loops aban doned latter two lower complexity bounds optimal match corresponding upper bounds conclude ecient slicing algorithms concurrent languages doomed suboptimal unless ppspace results shown weak assumptions concurrent language intuitively exploit weakness interference dependence synchronization properties exploited results point fundamental limitation slicing concurrent languages ramalingams hence applicable much wider range concurrency scenarios finally consider related program analysis problems copy constant propagation true liveness variables exhibit similar undecidability complexity results slicing thereby strengthening recent results 20 certain sense comes surprise slightly simpler analysis questions namely strong copy constant propagation ordinary liveness variables optimally solved polynomial time 15 14 24 2 motivating example turn technical results let us discuss small example illustrates backwards reachability dependence graph give suboptimal results join b join b cfglike representation b data interference dependences figure 1 illustrative example slicing parallel programs consider program fig 1 control flow graphlike representation program shown b data interference de pendences interested slicing wrt variable c write instruction always use write instructions paper mark slicing criterion clearly conve niently purpose write instructions clearly instruction 1 backwards reachable dependency graph execution program realizes dependences path therefore optimal slicer must remove 1 order see consider execution b 0 must executed either c b parallel thread executed c b kills propagation b c b executed c b subsequent statement c 0 kills propagation c b writec undecidability hardness results exploit propagation prohibited way means reinitializations krinke 17 also mentions inter ference dependence transitive gives example however less subtle nature example consider synchronization operations presents optimal algorithm intraprocedural parallel case algorithm worstcase exponential gives hardness proof pspacehardness result explains believe pspacehardnesswhy could find polynomial algorithm 3 parallel programs consider prototypic language shared memory atomic assignments forkjoin parallelism assignments simple form needed x k k either constant variable procedural parallel program comprises finite set proc procedure names containing distinguished name main procedure name p associated statement p corresponding procedure body constructed according following grammar q ranges procmain x given finite set variables use syntax procedure p p end indicate association procedure bodies procedure names note procedures parameters specific nature constants domain interpreted immaterial need 0 two constants representing dierent values whichby abuse notationare denoted 0 1 words need boolean variables atomic statements language assignment statements x e assign current value e variable x donothing statements skip write statements write statements signify slicing criterion statement form q denotes call procedure q operator denotes sequential composition parallel composition operator represents nondeterministic branching loop end stands loop iterates indefinite number times construct chosen accordance common abstraction conditions mentioned introduction apply nondeterministic choice operator also finite sets statements 1 n denotes 1 n ambiguity inherent notation harmless commutative associative idempotent semantically note synchronization operations language synchronization start termination inherent fork joinparallelism also essential results see section 7 parallelism understood interleaving fashion assignments write statements assumed atomic run program maximal sequence atomic statements may executed order execution program program x example three runs x 1 x x x 1 x x x x 1 x denote set runs program runs 4 interprocedural slicing remainder paper adopt following definition optimal slicing problem decision problem instance comprises nondeterministic parallel program slicing criterion c given writeinstructions program statement problem decide whether belongs optimal slice respect c slicing problem parameterized class programs considered theorem 1 parallel interprocedural slicing undecidable wellknown termination problem two counter machines undecidable 19 remainder section reduce problem interprocedural slicing problem thereby proving theorem 1 41 twocounter machines twocounter machine two counter variables c0 c1 incremented decremented tested zero common use combined decrement test instruction order avoid complications decrementing zero counter basic idea reduction represent values counters stack height two threads procedures running parallel incrementing counter represented calling another procedure corresponding thread decrementing returning current procedure test zero using dier ent procedures first stack levels represent possible moves zero nonzero counters respectively simplifies argumentation computation steps involving two counters alternate always enforced adding skipinstructions nothing except transferring control formally use following model twocounter machine comprises finite set control states partitioned two sets q1 qm moves involving counter c0 start p moves involving counter c1 q execution commences distinguished start state wlog p1 also distinguished final state wlog pn execution terminates state except final state pn associated instruction taken following selection c c goto skip q note condition captures moves alternate execution twocounter machine represented transition relation configurations x0 x1 consist current state current values x0 0 x1 0 counters configurations pn called final configurations x0 x1m one following conditions valid x1i thus nonfinal configuration unique successor configuration denote reflexive transitive closure omit subscript clear context execution twocounter machine commences start state counters initialized zero ie configuration p1 0 0 twocounter machine terminates ever reaches final state ie p1 0 0 pn x0 x1 x0 x1 far halting behavior concerned assume without loss generality counters zero upon termination ensured adding two loops final state iteratively procedure loop else procedure loop else goto q l procedure killallp figure 2 definition p0 p 0 decrement counters become zero obviously modification preserves termination behavior twocounter machine note modified machine conditions p1 0 0pn x0 x1 x0 x1 p1 0 0pn 0 0 equivalent assume following loops added given machine 42 constructing program twocounter machine construct parallel program state pk p program uses variable xk state q l q variable l intu itively xk holds value 1 execution program execution corresponds run twocounter machine reaching state pk similarly l main procedure reads follows procedure main procedure init consider slicing respect variable xn writeinstruction slicing criterion construction done initialization x1 1 belongs optimal slice terminates shows theorem 1 goal construction also reformulated follows initialization x1 1 occurrence constant 1 program assignment statement copy values initialize variables 0 terminates xn may hold 1 writestatement 1 initialization variables except x1 0 reflects p1 initial state two counters program uses two procedures p0 p 0 counter c0 procedure loop l else procedure loop else goto p l procedure figure 3 definition q0 q 0 q0 q 0 counter c1 definition found fig 2 3 describe p0 p 0 detail following q0 q 0 completely analogous intuitively p0 p 0 mirror transitions induced counter c0 0 0 respectively hence name procedure nondeterministically guesses next tran sition transition involves two things first state change secondly eect counter value state change pk q l represented copying xk l via auxiliary variable p reinitializing xk zero part killallp eect counter value represented proceed transitions change counter jump back beginning procedure transitions counter value simulated subsequently applies skiptransitions testdecrement transitions zero counter ie testdecrement transitions simulated p0 incrementing transitions call another instance p 0 simulates transitions induced incremented counter return new instance p 0 means counter decremented ie old value therefore jump back beginning procedure return p 0 testdecrement transitions simulated p 0 leave current procedure behavior described structured way means loops sequential nondeterministic composition consistent representation counter value number instances p 0 stack problem achieving 1 procedure may try cheat may execute code representing transition p q j although x hold value 1 decrementing incrementing transition coincidence counter values stack heights may destroyed value 1 may subsequently propagated erroneously cheating may thus invalidate direction problem solved follows ensure appropriate reinitialization variables set 0 procedure tries cheat thus executions cannot contribute propagation value 1 reinitializing set variables safely trivial concurrent environment atomic assignments single variables avail able variable set 0 may well set another value instructions executed instances procedures q0 q 0 running parallel initializing variables assumption moves involving counters alternate comes play due assumption copying assignments q0 q 0 form q x j q q analog auxiliary variable p thus safely assign 0 p0 p 0 target copy instruction q0 q 0 done safely assign 0 q copy instruction q executed parallel thread cannot destroy value 0 contain 0 already safely assign 0 x similar argument explains definition killall p 43 correctness reduction intuition underlying definition direction 1 rather obvious terminates ie transitions leading p1 0 0 pn 0 0 simulate transitions propagating run explaining definition killallp justified direction well formal proof given along lines classic owickigries method proving partial correctness parallel programs 22 8 1 although method usually presented programs without procedures sound also procedural programs ow ickigries method programs annotated assertions represent properties valid execution reaching program point assertion written annotation subject certain rules guarantee soundness method specifically prove writeinstruc tion following assertion valid validity assertion implies direction 1 details proof deferred appendix proof compared undecidability reachability presence synchronization proved ramalingam 23 undecidability ltl modelchecking parallel languages even without synchronization proved bouajjani habermehl 2 proofs employ two sequential threads running parallel ramalingam uses two recursion stacks threads simulate contextfree grammar derivations two words whose equality enforced synchronization facilities programming language bouajjani habermehl use two recursion stacks simulate two counters whose joint operation synchronized ltl formula thus proofs rely kind external synchronization two threads available scenario instead undecidability proof works internal syn chronization provided implicitly killing circulating value 1 soon one thread deviates intended synchronous behavior 5 intraprocedural slicing undecidability result presented means cannot expect program slicer parallel programs optimal therefore must lower expectation dataflow analysis one often investigates also intraprocedural problems viewed problems programs without procedure calls find theorem 2 parallel intraprocedural slicing pspacecomplete forkjoin parallel program without procedures number threads potentially running parallel bounded size program therefore every run program simulated turing machine using polynomial amount space conclude intraprocedural optimal parallel slicing problem pspace remains show pspace also lower bound complexity optimal intraprocedural parallel slicer ie pspacehardness done reduction regular expression intersection problem problem chosen favor better known intersection problem finite automata heading structured programs flow graphs instance regular expression intersection given sequence r1 rn regular expressions finite alphabet problem decide whether nonempty lemma 1 regular expression intersection problem pspacecomplete fact pspacehardness regular expression intersection problem follows reduction acceptance problem linear space bounded turing machines along lines corresponding proof finite automata 16 problem remains pspacecomplete consider expressions without suppose a1 ak given n regular expressions r1 rn reduction construct parallel program starts n1 threads 0 n initialization variables used program procedure main threads refer variables x ia 0 n thread 0 defined follows statement killall0 defined ensures variables except y0 reinitialized 0 irrespective behavior threads shown induced regular expression r given defined induction r follows statement killall reinitializes variables except statement well statements killx j killxy j definition based defined follows obvious thread safely reinitialize variables threads may arbitrarily terleave exploiting copy instructions form j x j1a x ja j j present threads done performing reinitializations order specified 1 two crucial properties exploited first whenever b copying assignments parallel thread variable b reinitialized therefore execution b reinitialization b copies initialization value 0 b cannot destroy initialization sec ondly constant assignments k parallel threads values generated altogether threads constructed way following valid belongs optimal slice 2 following describe intuition underlying construction time prove 2 threads considered form ring processes process processes i1 left neighbor i1 right neighbor thread word lr thread 0 guesses word special form threads ensures propagate initialization value 1 xna 1 agree guessed word interleave corresponding runs disciplined fashion obviously latter possible l word lr1 lrn first letter alphabet run induced w successfully propagates value 1 threads circulate value 1 around ring processes variables x ic letter c w call propagation game following beginning jth round process 0 proposes letter c j copying value 1 variable xnc j1 x0c j left previous round initial ization respectively technical reasons copying done via local variable 2 y0 afterwards processes successively copy value x i1c j 1 following addition subtraction subscripts variables processes understood modulo n1 local strict sense threads use target source copying assignment reinitialize via local variables xnc j copied 0 next round x0c j1 last round j l 0 finally copies value 1 xnc l x0a 1 processes terminate writingby little abuse single run 0 b single run y0 xna killall 0 x 0b y0 summarize discussion saying run 0 n witnesses initialization xna 1 belongs optimal slice implies direction 2 next show construction threads ensures runs follow propagation game cannot propagate value 1 writeinstruction particular propagating run exists implies direction 2 note first runs composed pieces runs 0 pieces form 0a b easily shown induction run deviate propagation game two ways first follow rules terminate middle round run propagate value 1 write instruction killall cm reinitializes x0a 1 secondly run might cease following rules propagation game initial possibly empty part consider first code piece 0a b started negligence propagation game rules hard see first statement code piece respectively sets local variable y0 zero reason propagation game ensures variable x i1a xna holds 0 unless next statement executed according rules propagation game comes 0a b spectively subsequent statement killall killall 0 irrevocably reinitializes variables irrespective behavior threads shown thus run also cannot propagate value 1 writeinstruction owickigries style proof confirms fact contained full paper 6 slicing loopfree programs may lower expectation even ban addition procedures also loops programs expect slice optimally even problem remains intractable unless pnp theorem 3 parallel intraprocedural slicing loopfree programs npcomplete problem np easy see statement optimal slice guess run witnesses statement aect slicing criterion run involve statement program program loopfree hence length consequently time necessary guessing run linear size given program nphardness proved specializing construction section 5 starfree regular expressions intersection problem expressions npcomplete alternative reduction wellknown sat problem given 20 contrast construction current paper reduction relies propagation along copying assignments quasisynchro nization welldirected reinitialization variables however technique seem generalize general intraprocedural interprocedural case 7 extensions 71 beyond forkjoin parallelism weak form synchronization inherent forkjoin parallelism used paper start termination threads synchronized hardness results paper however restricted settings also shown without assuming synchronous start termination therefore also apply languages like java pspacehardness proof section 5 instance modified follows let c two new distinct letters defined initialization final writeinstruction moved thread 0 specifically 0 redefined follows loop course statements killx reinitialize also new variables x ic x id essentially modification amounts requiring propagation game played first round letter cthis ensures quasisynchronous start threadsand final round letter dthis ensures quasisynchronous termination thus belongs optimal slice 0 n similar modifications work reductions section 4 6 72 dataflow analysis problems techniques used obtain similar results also optimal program analysis problems par ticular detection truly life variables copy constants thereby strengthening recent complexity results problems 20 variable x live program point p run p end program x used overwritten referring 9 horwitz et al 12 define variable x truly live program point p run p end program x used truly life context defined truly live context means predicate call library routine expression whose value assigned truly life variable thus true liveness seen refinement ordinary liveness property programs considered paper variable initialized crucial initialization statement truly live program point statement belongs optimal slice therefore lower bounds provided theorem 1 2 3 immediately translate corresponding bounds also truly live variable problem since upper bounds pspace np intraprocedural loopfree intraprocedural programs also easily verified obtain complexity characterizations theorem 2 3 indeed results sharp contrast detection ordinary liveness variable program point shown solvable even polynomial time 15 5 24 constant propagation standard analysis compil ers aims detecting expressions guaranteed evaluate value run program information exploited eg expression simplification branch elimination copy constant detection 7 pp 660 particularly simple variant problem sequential programs problem assignment statements simple forms x c constant assignment x copying assignment c constant x variables considered restriction obeyed programs paper obtain theorem 4 1 interprocedural copy constant detection problem undecidable parallel programs 2 intraprocedural copy constant detection problem pspacecomplete parallel programs 3 intraprocedural copy constant detection problem conpcomplete loopfree parallel programs small modification necessary apply reductions paper copy constant detection parallel programs statement z 0 skip must added writestatement z written variable obviously statement prohibits z copy constant value 1 write statement modification z copy constant write statement necessarily value 0 writestatement cannot output value 1 latter case crucial initialization statement question belong optimal slice proves lower bounds theorem upper bounds easily achieved nondeterministic algorithms guess paths witness nonconstancy theorem 4 essentially states optimal detection copy constants parallel programs intractable result contrasted detection problem strong copy constants strong copy constants dier full copy constants constant assignments taken account analysis particular variable strong copy constant program point p also copy constant detection strong copy constants turns much simpler problem solved polynomial time 14 24 8 conclusion paper studied complexity synchro nizationindependent program slicing related dataflow problems parallel languages means reduction halting problem twocounter machines shown interprocedural problem undecidable consider programs without procedure calls intraproce dural problem slicing problem becomes decidable still intractable specifically shown pspacehard means reduction intersection problem regular expressions finally even restrict attention parallel straightline programs problem remains nphard lower bounds tight matching upper bounds easy establish previous complexity undecidability results dataflow problems concurrent languages 25 23 exploit essential way synchronization primitives considered languages contrast results hold independently synchronization exploit interleaving atomic statements thus applicable much wider class concurrent languages 9 r verification sequential concurrent programs constrained properties slicing concurrent programsa graphtheoretical approach program slicing vhdl automatatheoretic approach interprocedural dataflow analysis crafting compiler program verification invariance approximative semantics respect program transformations interprocedural slicing using dependence graphs demand interprocedural dataflow analysis program slicing vhdl descriptions applications parallel constant propagation lower bounds natural proof systems static slicing threaded programs issues slicing promela applications model checking computation finite infinite machines program dependence graph software development environment axiomatic proof technique parallel programs complexity analyzing synchronization structure concurrent programs survey program slicing techniques program slicing slicing concurrent java programs tr crafting compiler interprocedural slicing using dependence graphs verification sequential concurrent programs 2nd ed static slicing threaded programs efficient algorithms pre post interprocedural parallel flow graphs contextsensitive synchronizationsensitive analysis undecidable program verification constraintbased interprocedural analysis parallel programs complexity copy constant detection parallel programs parallel constant propagation constrained properties semilinear systems petri nets automatatheoretic approach interprocedural dataflow analysis slicing concurrent programs graphtheoretical approach formal study slicing multithreaded programs jvm concurrency primitives invariance approximate semantics respect program transformations program dependence graph software development environment slicing concurrent java programs ctr jens krinke contextsensitive slicing concurrent programs acm sigsoft software engineering notes v28 n5 september markus mllerolm precise interprocedural dependence analysis parallel programs theoretical computer science v311 n13 p325388 23 january 2004 javier esparza grammars processes formal natural computing springerverlag new york inc new york ny 2002 mangala gowri nanda ramesh interprocedural slicing multithreaded programs applications java acm transactions programming languages systems toplas v28 n6 p10881144 november 2006 ingo brckner bjrn metzler heike wehrheim optimizing slicing formal specifications deductive verification nordic journal computing v13 n1 p2245 june 2006 hon f li juergen rilling dhrubajyoti goswami granularitydriven dynamic predicate slicing algorithms message passing systems automated software engineering v11 n1 p6389 january 2004 baowen xu ju qian xiaofang zhang zhongqiang wu lin chen brief survey program slicing acm sigsoft software engineering notes v30 n2 march 2005
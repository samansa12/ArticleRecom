automatically checking implementation formal specification abstractwe propose checking execution abstract data types imperative implementation algebraic specification explicit mapping implementation states abstract values added imperative code form specification allows mechanical checking desirable properties consistency completeness particularly operations added incrementally data type unit testing specification serves test oracle variance computed specified values automatically detected module made part application checking removed may remain place validating implementation specification executed rewriting thought implementation maximum design diversity validation form multiversionprogramming comparison b introduction encapsulated data abstractions also called abstract data types adts promising programminglanguage idea support software engineering adt basis informa tionhiding design philosophy 50 makes software easier analyze understand hope support maintenance reuse several formal specification techniques adts 30 growing number language implementations idea 27 accepted theories adt correctness 20 26 28 adt good setting work unit testing testability 34 however adts promise fundamental problems remain concerning adts specifications implementations paper address problem checking agreement adts formal specification implementation use particular kind equational specification rewrite rules 4 c implementation language 54 latter choice crucial workalmost adt programming language eg ada java would work well use special properties one kind rewrite specification would make difficult substitute different kind specification part show write c classes formal specifications implementation automatically checked specification execution thus specification serves effective oracle application selfchecking adt cannot deviate specified behavior without failure detected specification oracle may inefficient comparison c implementation use may confined prototyping testing phase software development however applications specification implementation may viewed independent versions software continually check since produced human beings subject error utterly different form content suggest minimum chance commonmode failure 43 central idea allows self checking implement part c code mapping concrete implementation states abstract specification objects failure mechanically capture important part design weakness existing adt systems selfchecking adts describe adts check implementations specifications run time give simple illustrative example 21 automatic testing implementation side system available shelf use c language supports adts ada eiffel java smalltalk etc would well make use inheritance part objectoriented language one component scheme thus class implementation whether implementation thought arising intuitive set requirements formal specification second component scheme immaterial description however discuss issue section 52 second component require formal specification axiomatic variety much leeway specification form determines ability mechanically check specification properties like consistency newly added operation plays essential role efficiently checking abstract equality specification serves implementation oracle choose use rewrite system restricted desirable properties confluence termination largely obtained syntactic forms 4 would possible employ general specifications cost using powerful less efficient theorem provers limited goal scheme argues generality loss efficiency made engineering decision use specification fitted role automatic oracle user system must supply one additional component central importance scheme representation mapping 1 concrete data structures c instance vari ables abstractions specification major weakness present adt theory representation mapping nowhere explicit existing theory framed implementation correct exists appropriate representation 22 practice implementor must representation mind way formally record maintain early crucial design decision flaw existing adt design methodologies written axiomatic specification c class explicit representation mapping user may test composite adt using unittest technique example conventional driver code coverage tool could used ensure c code adequately tested according say dataflow criterion 52 tests could generated exercise traces class operations 34 whatever techniques used system serve automatic test oracle existing testing systems lack determines correctness operation invoked according specification alternately user might decide test adt place writing application code using conducting system test perhaps using randomly generated inputs according expected operational profile 47 application program embedded adt test adt cannot fail without detection 22 example small integer set illustrate ideas use class small set integer first used hoare 33 discuss theory data abstraction signature adt shown figure 1 stroustrup 54 signature diagram captures complete syntax adt usage example figure 1 empty takes two arguments elem nat operations types also shown diagram 221 specification semantics adt specified set equations also called axioms expressed names operations example intuitive axioms insertion operation set equations determine combinations operations equivalent along assumption combinations handled equations determine exactly objects name used hoare foundational paper 33 perhaps abstraction mapping common name also better expresses direction set nat elem bool maxsize cardinality member empty insert true false succ figure 1 signature generic bounded adt set expressed ground terms using operations consitute set forms adt common assumption initial one 26 objects cannot proved equal using equations distinct good deal work done algebraic specification see 12 equations viewed rewrite rules proofs equivalences simplified view care must taken rewrite system correct implementation algebraic specification purpose suffices consider groundconvergent ie confluent terminating systems equations rewrite rules first rule applied infinitely often suitable rewrite system obtained equational specification completion 41 although procedure guaranteed terminate alternately form equations suitably restricted 4 approach chosen furthermore implementations sets impose bounds set size values sets elements type intset given stroustrup 54 x532 simple equations describe practical set adts specify type intset understanding code 54 using notation similar several algebraic specifications act one 20 asf 11 larch 29 explain parts needed understand example userdefined sorts specified enumeration constructors arity parameter types followed axioms axiom rewrite rule form l r respectively left right sides rule c optional condition 39a guard application rule symbol right side rule denotes exceptional result semantics formalized within framework order sorted algebras 25 modest purposes denotes computation must aborted following prolog conventions 15 identifier variable begins upper case letter underscore symbol denotes anonymous variable adt intset 54 specified follows intset constructor maxsize element upper bound element set axiom membereinsertfs cardinalityinsertfs maxsizeinsertfs membereinsertfs operations member cardinality maxsize axiomatized shortly rely readers intuition concepts explain axioms style used axioms handles exceptional cases axiom guarded constraint defining exceptional condition thus empty axiom exception occurs parameters inconsistent similarly first axiom insert handles error case attempt made insert element violates upperbound restriction third axiom insert handles attempt insert new element set already maximum size second fourth insert axioms establish normal form nest insertions element order without duplicates last three axioms insert create overlays ie critical pairs overlapping root require conditions overlay axioms mutually exclusive overlays created vacuously joinable consequently 18 system confluent make specifications grow incrementally adopting stepwise specification extension approach 20 increment adds new operations specification new specification complete consistent extension old one adopt two design strategies 4 guarantee completeness consistency follow binary choice strategy generates set complete mutually exclusive arguments operation left side rule define set right sides set conditions associated right sides mutually exclusive recursive reduction strategy uses mechanism similar primitive recursion expressive defining right side rule way ensures termination symbol right side rule stands term obtained left side replacing roughly speaking recursive constructors recursive arguments example axioms cardinality stands cardinalitys promised axioms cardinality maxsize member follows operation cardinalityintset integer axiom operation maxsizeintset integer axiom operation memberintegerintset boolean axiom memberempty false completes example specification intset 222 implementations specification consider three implementations specification referred byhand implementation direct implementation selfchecking implementation byhand implementation c code written programmer provide functionality expressed specification code naturally structured c class operations implemented class member functions byhand implementation intset appears first example stroustrups text 54 x532 direct implementation 30 c code automatically generated specification representing instances abstract data types terms manipulating terms according rewrite rules selfchecking implementation union byhand implementation direct implementation additional c code check mutual agreement describe selfchecking implementation first even though uses direct implementa tion presentation order motivates need direct implementation considerable detail given selfchecking implementation described following section direct implementation provides mechanism c computing normalform terms corresponding sequence specification operations byhand implementation provides similar mechanism computing result using sequence memberfunction calls two computations correspond respectively upper abstract lower concrete mappings diagrams displayed figure 2 abstract world 2 binary relation set membership concrete world member operation transforms values state variables starting lower left diagram passing upper right two possible paths always yields result say diagram commutes concrete implementation commuting diagram definition correct according abstract specification figure 2 suppose boolean result returned member mx x integer value intset value function computed member diagram commutes iff 2 set elem 2 bool state state member figure 2 commuting diagram member operation adt set check byhand result direct result requires code available representation function complete diagram figure 2 selfchecking implementation comprises c code byhand direct implementations plus representation function appropriate calls connecting locus control placed byhand implementation member functions invoked corresponding normalform terms requested direct implementation comparison results however takes place abstract world actually compared normal forms computed selfchecking implementation intset illustrates structure selfchecking class two additional private entities declared first example type absset type mark set direct implementation additional variable abstract contains values sets direct implementation additional function conc2abstr representation mapping takes input parameters instance variables intset returns corresponding absset instance declaration selfchecking intset class class intset absset abstract abstract version class absset concr2abstr representation function line class identical stroustrup p 146ff int cursize maxsize int x public intsetint int n ints 1n code omitted member functions selfchecking implementation differ corresponding ones byhand implementation addition two statements function return 2 precise think state oe mapping instancevariable names values diagram abstract operation f concrete operation f variables state x1 x2 xn diagram commutes iff example selfchecking member function implementing specification operation empty follows intsetintsetint int n ints 1n new intmaxsize additional statements selfchecking abstract value verify check mutual agreement directimplementation function empty called resulta normal form encoded data structures direct implementationsaved added variable abstract code empty appears following section macro verify performs equality test value stored abstract computed conc2abstr also normalform value equality test particularly simple direct implementation equality means identity normal forms verify macro includes error report two values differ code follows define verify cerr formdirect differs byhand line sn last significant piece code selfchecking implementation representation function mapping straightforward starting empty abstract set adding elements concrete version one time calculate corresponding abstract set absset intsetconcr2abstr absset upper bound implemented int return h writing function programmer noticed byhand implementation 54 pays attention upper bound element size maxint must used parameter implications omission discussed 223 direct implementation c direct implementation userdefined sort data structure pointer discriminated union discriminant values tokens whose values stand constructors sort arm union c struct whose components represent arguments constructor associated discriminant dynamic polymorphism would elegant alternative less portable languages example int elem kind generic enum tag empty insert tokens discriminants struct setnode tag constructor discriminant union struct int int associated empty struct elem setnode 1 arm associated insert setnodeint int r setnodeelem e setnode simple macro definitions improve readability define tagofw wt define maxsizeofw w0m define rangeofw w0r define elemofw w1e define setofw w1s declare function signature symbol extern absset emptyint int r extern absset insertelem e absset extern int cardinalityabsset extern int maxsizeabsset extern bool memberelem e absset equalitytest function extern bool equalabsset s1 absset s2 normalform syntactic equality constructors operations implemented functions without side effects execution function implementing constructor dynamically allocates associated union returns pointer function implementing nonconstructor consists nest cases whose labels correspond patterns rewrite rules rule conditions implemented conditional statements since patterns conditions mutually exclusive order execution may affect efficiency result computation completeness patterns implies execution function implementing operation bound find matching rule eventually execute call represents rule right side except case execution call generates finite tree calls whose leaves always calls constructor functions consequently abstract representation sort instance always returned translate condition rule right side means macro exception similar macro assert provided gnu c compiler use project define cerr exception ex form line sn linefile examples direct implementation constructor functions operation function follow absset emptyint int r absset absset insertelem e absset absset h switch case empty new setnodees break case insert int cardinalityabsset switch case empty return 0 case insert memberelemofssetofs return cardinalitysetofs return 223 executing small integer set execution selfchecking implementation intset raises interesting issues byhand implementation 54 although documentation code seems require upper bound value element constraint enforced byhand implementa tion selfchecking implementation detects problem testing issues following warning exception e rangeofs line 41 abssetc message e rangeofs textual code appearing exception macro direct implementation insert comment indicates exception implements violated condition axiom problem undetected test code 54 direct implementation includes operation cardinality corresponding member function byhand implementation 54 naive programmer might add observer function returning value cursize counter elements stored array represents set however selfchecking implementation would report failure cardinality test byhand implementation creates set insert duplicate elements naive programmer missed byhand implementation fact stores duplicates array specification wrote cardinality unexpected behavior would thus catch mistake naive cardinality implementation smallintegerset example illustrates benefits gained formal specification direct implementation specification provides careful check byhand implementation allowing selfchecking test values course requires additional effort write specification argued however without formal specification correct code impossible write seen two examples well understood class textbook example 224 example selfchecking example make clear way explicit representation function allows results computed byhand implementation checked specified direct im plementation consider previously created intset containing elements 1 5 perhaps set created c code intset ex6maxint already checked state defined instance variables including concrete array first two elements 1 5 properly correspond term insert1insert5empty6maxint normal form assigned state representation function suppose element 2 added set perhaps c call exinsert2 figure 3 shows particular case commuting diagram checks computation lower level instance variables comprise concrete state initial value concr2abstr concr2abstr figure 3 commuting diagram inserting 2 ex intset left member function insert byhand implementation transforms variables shown called arguments ex 2 upper level corresponding abstract values transformed rewriting direct implementation explicit representation mapping concr2abstr connects two levels concrete instance variables constructs abstract values comparison shows computation correct occurs abstract value obtained two paths around diagram starting lower left ending upper right course actually compared selfchecking abstract values bit patterns computer state state created compiled c program direct imple mentation however states transparently like structure abstract terms words word algebra obvious properly correspond impossible better mechanical way mechanical comparisons must done computer states true abstractions exist mathematical universe best make states simple faithful mirrors universe 3 proposed automatic testing system example section 22 begins two humancreated objects specification byhand implementation constructed selfchecking implementation adding lines byhand implementation lines call direct implementation specification consider automate construction additional elements selfchecking implementation mechanical creation selfchecking implementation helps justify extra effort needed create independent specifications byhand implementations 31 automating direct implementation direct implementation specification nothing else implementation term rewriting system implementations kind numerous often add extra features rewriting example equational interpreter 49 adds total laziness obj3 27 adds sophisticated module system sbreve 2 adds knuthbendix completion procedure standalone systems contrast direct implementation must appear block c code integrated byhand implementation data representation implementation rewrite rules discussed detail section 222 difficult compile appropriate c code specification using compilercompiler techniques unix system 38 42 envi ronment eg standard ml new jersey 6 7 difficult part compilation semantic processing guarantee specification rewrite rules possess termination confluence properties make direct implementation work wherever possible try convert semantic properties syntax properties statically checked example expressing rewrite rule conditions else form mutual exclusion sufficient make overlays joinable would guaranteed syntax objectoriented reader noticed section 222 uses functionallike style instead objectoriented one initially made abstract object c class changed 1 functional code natural application since abstract objects internal state 2 encapsulation protection offered c class wasted case since directimplementation code created compiler human use hand modularity c used good advantage 32 automating calls direct implementation additional statements must added byhand implementation present difficulties one way write preprocessor c c effects addition using c grammar omits languages detail compiler compiler simply copies code directly one way write preprocessor quickly 9 second idea takes advantage existence parser existing c compiler easy modify code generator insert object code necessary calls 32 ideas converge c compiler preprocessor c say true compiler easiest case preprocessor might written using compiler compiler number technical problems modifying byhand implementation example abstract concrete worlds share builtin types like boolean operations returning types representation function identity thus machinery abstract verify needed inserted calls take simpler form slightly difficult problem arises byhand implementations functional insert usual implementation uses update place 54 abstact operation different arity concrete thus slightly different code required void intsetinsertint code stroustrup section 32 cursize maxsize errortoo many elements int i0 xi1xi int selfchecking added 33 representation function remains representation function maps concrete abstract mains function named concr2abstr section 222 seems way essential parts function automated correspondence concrete abstract objects primary design decision made early byhand implementation designer constrained choice furthermore crucial proper working system propose representation correctly capture link concrete abstract take extreme example programmer codes representation maps inputs sort overloaded constant equality checks verify macro trivially succeed errors caught argued extra programming required code representation function blessing disguise unless programmer detailed accurate idea function impossible write correct functions implement specifications operations better way force understanding insist put code better way protect changes inconsistent representation make use code issues arose example section 223 even answer possibility incorrect representation function trivialize self checking programmers likely err direction misguided elaboration toward trivial simplicity baroque representation less likely conceal faults putting much lead system reporting ersatz failures false success suggested 44 often representation function structurally similar routine prettyprints class value internal representation humanreadable form insight underscores easy code representation function essential capture 34 system overview figure 4 shows selfchecking implementation would result example section 22 direct implementation invoked byhand implementation additional code computes term abstract data structure direct implementation applies representation function concr2abstr map implementation state term compares verify macro selfchecking implementation struct setnode direct implementation class intset f int cursize intsetintsetint byhand implementation selfcheck absset intsetconcr2abstr absset representation function sort intset constructor empty intset specification hand gen auto gen figure 4 construction selfchecking implementation 4 relation previous work previous attempts link formal specification adt implementation taken variety forms proof systems correctness data type representation proved using diagrams presented figure 2 subroutine member tests membership element set program might represent set fixedsize array elements pointer last element hoare 33 shows existence representation mapping r makes diagram commutative proof implementation correctness mapping somewhat retrospective since concrete implementation originates abstract world formalization intuitive concepts executable specifications specification nonprocedural description computation algebraic specification description takes form set equations equations given orientation ie transformed rewrite rules resulting structure called rewrite system 39 allows us compute elementary step computation consists rewriting subterm expression means rule computation sequence elementary steps often two fundamental properties required termination ie computation sequence ends element cannot rewritten 17 confluence ie choice term rewrite expression affect result computation 37 rewrite systems properties model computation underlying programming languages odonnells equational interpreter 49 automatic programming adt specifications viewed veryhighlevel programming language executable nature axiomatic specifications supports view need write implementation specification executed implementation thus questions correctness arise difficulty lies improving efficiency execution antoy et al 3 5 investigate specification translation number different languages volpano 55 proposes compile specification imperative language like c using ideas functional languages like ml able effect compilation although cases efficiency approach would obtained implementation hand testing systems appear three distinct threads attempt use adts tests first proof technique used instrument implementation code runtime assertions check test instances proof assertions could established theorem prover gypsy system 1 uses technique second adt specifications used formalize generation specificationbased tests adt implementation gerhart 24 describes logicprogramming approach generate test points according scheme tester imposes slightly different approach esprit project automatically generates tests based traces operation sequences without direction tester 23 13 14 third daists system 21 attempted check consistency implementation algebraic adt specification executing concrete code corresponding two sides specification axiom comparing results implementationsupplied equality function anna 45 specifications ada intended cut across categories work progressed less far specialized projects cited approach might described terms combination proof testing system contrast executable specification approach consider formal specification independently devised implementation perhaps derived common intuitive description contrast automatic programming approach implementation code guaranteed correct transformational origin indeed implementation may full tricks death formal proof essential practice efficiency view specifications implementation attractive one thing cuts work specification implementation half however drawback merely moves correctness problem level however carefully specification devised may fail capture intuitive ideas problem solution led intuition necessarily exists plane inaccessible formal methods hence may wise duplicate work problem solution different specifications implementations drawing intuitive problem model one may hope model unclear faulty independent attempts capture formally differ precise correctness methods detect difficulty lead correction model unlike use proof systems attempt verify implementation check particular cases return drastic restriction large improvement success rate process lowering skill level needed use testing system using proof techniques whose nearest precursor daists 21 unlike daists however test equality adt values conducted abstract domain hence proof techniques rather concrete domain thus avoid practical theoretical deficiencies could falsify daists success yet pay efficiency penalty use rewriting abstract proofs explicit mapping concrete abstract domain mapping expression part implementation main contribution extra programming required representation function corresponds need daists programmer explicitly code concrete equality function easier natural satisfy system also viewed checking runtime behavior using code assertions unlike ad hoc systems 46 proofbased systems gypsy 1 however assertions written user even conjunction theorem prover rather automatically generated guaranteed detect deviation specifications generate test data judge adequacy test data scheme generate tests 35 36 measure test quality 16 48 used system supplying test oracle facility testing systems presently lack frankl doong 19 describe system uses rewriting obtain one abstract test case another results implementation compared cases sankar 53 uses much powerful rewriting theorem prover attempt prove abstract equality terms implementation generates antoy gannon 4 use rewrite systems similar prove correctness loops subtypes help theorem prover systems less straightforward lack explicit representation function andor specification restrictions needed guarantee rewriting termination compared automatic proof schemes adts automatic programming efficient programs formal specifications goal testing system modest imagine automatically generated perfect set runtime assertions make impossible byhand implementation silently disagree specification attain limited goal ambitious ones present formidable problems worthwhile section try answer question affirmative 51 need test oracles testing literature almost universally assumes test output examined correctness almost universally fails say done furthermore research examples 51 empirical studies 10 alike show common testers failures hands yet ignore thus effective oracle problemthe difficulty mechanically judging programs output meets specificationsis important one assumes extra importance random testing recent work suggests true random testing based valid operational profile essential confidence tests requires vast number test points 31 adequacy criteria widespread use require hundreds points adequate random testing requires millions tests flatly impractical without effective oracle given oracle random testing doubly attractive however theoretically valid able provide true estimate reliability approximates ideal completely automatic test random inputs selected mechanically means mechanically examining outputs test suite run without need human intervention 52 multiversion specificationprogramming specification viewed program high level language yet general algorithm exists compiling language efficient code still place byhand implementa tion view development process directed first comes requirements phase developers communication end users attempt create formal specification captures necessary intuitive problem solution process prototyping aspect see section 53 specification formalism great importance next specification efficiently implemented automatically possible hand otherwise formal methods used show implementation correct practice believe always need byhand implementations general methods proof always need supplemented tests system proposed automate testing process efficiently one argue development proceeds requirements formal specification byhand implementation declarative form specification best rather form specification much closer ultimate imperative implementation language called 56 advantages twofold first procedural specifications easier write second many detailed problems imperativeprogram solution must addressed prototype byhand implementation easier less prone introduce subtle disagreements specification however rather different view specificationimplementation program develop ment view specification implementation imperfect reflections intuitive requirements problem solution view particularly appropriate safetycritical applica tions attempt provide software fault tolerance technique multiversion programming mvp suggested 8 however observed 40 socalled commonmode failures frequent might expectedworking informal specifica tion independent programming teams make mistakes lead coincident wrong results proposed solution design diversity programs differ radically truly independent recent study 43 casts doubt whole idea mvp contrast suggests internal selfchecking valuable particularly checking involves details internal program states system propose fits needs safetycritical applications well ultimate selfchecking code checks applied internal datastructure states explicit representation function maps states direct implementation time direct implementation executed selfchecking implementation viewed twoversion programming package ultimate design diversity declarative nature axiomatic specification direct execution rewriting make commonmode failure conventional byhand implementation unlikely 53 rapid prototyping previous systems implementing specifications directly obj3 27 designed specifications executed prototypes allow potential users interact software complete development effort freezes wrong design direct implementation adds new dimension idea byhand implementation direct one implement specification completely independently software development approach use former production testing latter prototyping two implementations coexist environment final product earlier systems prototypes confined unusual software andor hardware platforms eg obj3 lives inside common lisp prototype production modules interact similar ways rest system external point view difference two versions operation direct implementation sideeffect free byhand implementation efficiency reasons might gap filled trivial interface limited renaming operations rearranging parameters modes function declarations 6 summary future work proposed modest testing system modules using algebraic specification executable rewrite rules programmer must write specification c code implement representation function relating implementation data structures abstract terms three elements selfchecking implementation constructed automatically specification serves test oracle selfchecking implementation viewed vehicle testing special kind twoversion programming system exceptional design diversity pursuing two quite different goals future first investigating expressive languages formal specification component approach byhand implementation languages java simpler c second want use ideas practical set ting learn difficulty writing specifications value test oracle ideal testbed industrial user objectoriented design central group responsible developing highly reliable support software developers use group worthwhile putting extra effort specification return better testing reliability r language specification implementation verifiable programs term rewriting laboratory acunfailing completion using term rewriting systsem verify software lexical analyzer generator standard ml mlyacc version 20 fault tolerance design diversity concepts experiments prototype testing tools comparing effectiveness software testing strategies algebraic specification algebraic system specification development application prolog test sets generation algebraic specifications test data generation using prolog constraints programming prolog formal notion programbased test data adequacy termination rta85 confluence conditional term rewrite systems case studies testing objectoriented programs fundamentals algebraic specification 1 data abstraction implementation theory modules generation test data algebraic specifications test generation method using prolog operational semantics ordersorted algebras initial algebra approach specifi cation introducing obj3 algebraic specification abstract data types larch family specification languages design data type specifications partition testing inspire confidence testing programs aid compiler proof correctness data representations hardware testing software ics module test case generation methodology generation program test data confluent reductions abstract properties applications termrewriting sys tems yacc yet another compiler compiler rewriting systems experimental evaluation assumption independence multiversion programming simple word problems universal algebras use self checks voting software detection empirical study personal communication programming specifications introduction anna software reliability measurement comparison structural testing strategies equational logic programming language criteria used decomposing systems modules automated generation program test data selecting software test data using data flow information software templates operational versus conventional approach software development tr ctr daniel hoffman durga prabhakar paul strooper testing iptables proceedings conference centre advanced studies collaborative research p8091 october 0609 2003 toronto ontario canada dick hamlet random testing proceedings 1st international workshop random testing july 2020 2006 portland maine qing xie atif memon designing comparing automated test oracles guibased software applications acm transactions software engineering methodology tosem v16 n1 p4es february 2007 johannes henkel amer diwan tool writing debugging algebraic specifications proceedings 26th international conference software engineering p449458 may 2328 2004 david owen dejan desovski bojan cukic random testing formal software models induced coverage proceedings 1st international workshop random testing july 2020 2006 portland maine james h andrews susmita haldar yong lei felix chun hang li tool support randomized unit testing proceedings 1st international workshop random testing july 2020 2006 portland maine douglas gregor sibylle schupp stllint lifting static checking languages libraries softwarepractice experience v36 n3 p225254 march 2006
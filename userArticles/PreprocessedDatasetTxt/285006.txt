power finite automata nondeterministic probabilistic states study finite automata nondeterministic random states npfas restrict attention npfas accept languages small probability error run polynomial expected time equivalently study arthurmerlin games arthur limited polynomial time constant spacedwork stockmeyer siam j comput 19 1990 pp 10111023 asked whether npfas accept regular languages known automaton randomness nondeterminism show answer yes case npfas 1way input head also show l nonregular language either l barl accepted npfa 2way input headtoward end define new measure complexity language l called 1tiling complexity n number tiles needed cover 1s characteristic matrix l namely binary matrix row column string length le n entry xy1 string xy l show language constant 1tiling complexity regular result 1way input follows main result regarding general 2way input tape follows contrasting two bounds upper bound polylogn 1tiling complexity every language computed model lower bound stating 1tiling complexity nonregular language complement exceeds function 2omega sqrtlog n infinitely oftenthe last lower bound follows proving characteristic matrix every nonregular language rank n infinitely many n main technical result proof extends techniques frobenius iohvidov developed hankel matrices sitzungsber der knigl preuss akad der wiss 1894 pp 407431 hankel toeplitz matrices forms algebraic theory birkhauser boston 1982 b introduction classical subset construction rabin scott 25 shows finite state automata nondeterministic states nfas accept exactly regular languages results rabin 24 dwork stockmeyer 7 kaneps freivalds 17 show true probabilistic finite state automata run polynomial expected time throughout paper restrict attention automata accept languages error probability constant ffl less 12 however little previous work finite state automata probabilistic nondeterministic states automata equivalent arthurmerlin games babai moran 3 restricted constant space unbounded number rounds communication arthur merlin paper refer npfas computation npfa transition probabilistic state chosen randomly according transition probabilities state whereas nondeterministic state chosen maximize probability accepting state eventually reached let 1npfa 2npfapolytime denote classes languages accepted npfas 1way 2way input head respectively run polynomial expected time dwork stockmeyer 8 asked whether 2npfapolytime exactly set regular languages denote regular paper prove following two results npfas theorem 11 theorem 12 l nonregular either l l 2npfapolytime thus resolve question dwork stockmeyer npfas 1way head case 2way head model reduce question deciding whether 2npfapolytime closed complement theorem 11 also holds even automaton universal well nondeterministic probabilistic states moreover theorem 12 holds even arthurmerlin games use olog log n space proving two results introduce new measure complexity language l called 1tiling complexity tiling complexity arguments used previously prove lower bounds communication complexity see eg yao 29 language l sigma associate infinite binary matrix ml whose rows columns labeled strings sigma entry ml x 1 string xy 2 l 0 otherwise denote ml n finite submatrix ml indexed strings length n 1tiling complexity l matrix ml n minimum size set 1tiles ml n every 1valued entry ml n least one 1tile set 1tile simply submatrix whose rows columns necessarily contiguous entries value 1 section 3 prove following theorems relating language acceptance npfas tiling complexity proofs theorems build previous work dwork stockmeyer 8 rabin 24 theorem 31 language l 1npfa 1tiling complexity l o1 theorem 33 language l 2npfapolytime 1tiling complexity l bounded polynomial log n distinguishes work tiling interested problem tiling matrices ml n distinctive structural properties l unary language ml n matrix entries along diagonal top right bottom left equal matrix known hankel matrix elegant theory properties hankel matrices developed 15 obtain strong bounds rank ml n l unary case l unary language pattern 0s 1s ml n simple unary case although matrix still much structure main technical contribution presented section 4 prove new lower bounds rank ml n l unary proof uses techniques frobenius iohvidov developed hankel matrices theorem 44 l nonregular rank ml n least n 1 infinitely often applying results communication complexity relating rank matrix tiling complexity obtain lower bound 1tiling complexity nonregular languages theorem 45 l nonregular 1tiling complexity either l l exceeds function log n infinitely often however nonregular languages even unary alphabet 1tiling complexity olog n see section 4 thus lower bound 1tiling complexity l l always hold l simpler theorem holds regular languages theorem 41 1tiling complexity l o1 l regular combining theorems 1tiling complexity regular nonregular languages theorems relating 1tiling complexity acceptance npfas two main results theorems 11 12 follow immediate corollaries rest paper organized follows section 2 define model npfa tiling complexity language conclude section discussion related work probabilistic finite automata arthurmerlin games section 3 present theorems 31 33 relate membership language l classes 1npfa 2npfapolytime 1tiling complexity l similar theorem presented class 2npfa underlying automata restricted run polynomial expected time section 4 present bounds tiling complexity regular nonregular languages theorems 11 12 immediate corollaries main results sections 3 4 extensions results alternating automata turing machines small space presented section 5 conclusions open problems discussed section 6 preliminaries first define npfa model section 21 model includes special cases standard models nondeterministic probabilistic finite state automata section 22 define notion tiling complexity language finally section 23 discuss previous work related models 21 computational models language classes twoway nondeterministic probabilistic finite automaton 2npfa consists set states q input alphabet sigma transition function ffi following properties states q partitioned three subsets nondeterministic states n probabilistic random states r halting states h h consists two states accepting state q rejecting state q r distinguished state q 0 called initial state two special symbols 2 sigma used mark left right ends input string respectively transition function ffi form fixed q r set random states oe 2 sigma f6 c g sum ffiq oe q q 0 equals 1 meaning ffi case automaton state q reading symbol oe probability ffiq oe q automaton enters state q 0 moves input head one symbol direction left stationary 0 fixed q n set nondeterministic states oe q 0 meaning ffi case automaton state q reading symbol oe automaton nondeterministically chooses q 0 ffiq oe q enters state q 0 moves input head one symbol direction automaton enters state q resp q r input head moves repeatedly right right endmarker read point automaton halts words q 2 fq q r g ffiq oe q oe given input automaton started initial configuration initial state head left end input automaton halts state q input say accepts input halts state q r say rejects input fix input string strategy strategy w function ffiq oe q oe meaning sw automaton state q 2 n reading w j sw q automaton enters state q 0 moves input head one symbol direction strategy indicates nondeterministic choice made configuration language l sigma accepted bounded error probability constant ffl 12 1 w 2 l exists strategy sw automaton accepts probability 2 2 l every strategy sw automaton accepts probability ffl language acceptance could defined respect general type strategy nondeterministic choice made configuration different times may different known see 4 theorem 26 l accepted npfa respect general definition also accepted respect definition hence results also hold generalized strategies oneway nondeterministic probabilistic finite automaton 1npfa 2npfa never move input head left ffiq oe q also probabilistic finite automaton pfa nondeterministic finite automaton nfa special cases npfa nondeterministic probabilistic states respectively denote 1npfa 2npfa classes languages accepted bounded error probability 1npfas 2npfas respectively inputs w nondeterministic strategies 2npfa halts polynomial expected time say l class 2npfa polytime classes 1pfa 2pfa 2pfapolytime defined similarly pfa replacing npfa finally regular denotes class regular languages model 2npfa equivalent arthurmerlin game arthur 2pfa classes 2npfa 2npfapolytime identical classes am2pfa amptime 2pfa respectively dwork stockmeyer 8 22 tiling complexity language adapt notion tiling complexity function used communication complexity theory obtain new measure complexity language given finite twodimensional matrix tile submatrix entries value tile specified pair r c r nonempty set rows c nonempty set columns entries tile said covered tile tile btile entries submatrix b set btiles btiling every bvalued entry covered least one tile set binary matrix union 0tiling 1tiling called tiling let minimum size tiling let 1 minimum size 1tiling let 0 minimum size 0tiling note definitions permitted tiles type overlap define tiling complexity language associated language l alphabet sigma infinite binary matrix ml rows columns ml indexed say lexicographic order strings sigma entry ml x xy 2 l let l n strings l length n let ml n finite submatrix ml whose rows columns indexed strings length n 1tiling complexity language l defined function 1 similarly 0tiling complexity l tiling complexity l tiling matrix disjoint every entry x covered exactly one tile disjoint tiling complexity matrix minimum size disjoint tiling also disjoint tiling complexity language n tml n tilings often used proving lower bounds communication complexity let f 1g function f represented matrix f whose rows indexed elements x whose columns indexed elements f x let f denote tm f suppose two cooperating parties p 1 p 2 get inputs x 2 x respectively want compute fx exchanging information according protocol precise definitions legal protocols found 13 protocol deterministic worst case number bits need exchanged deterministic communication complexity bounded log protocol nondeterministic lower bound log f 1 finally object nondeterministic protocol verify fx indeed case lower bound number bits exchanged log 1 f 23 related work work npfas builds rich literature probabilistic finite state automata rabin 24 first consider probabilistic automata bounded error probability showed however 2way input head pfas recognize nonregular languages shown freivalds 10 constructed 2pfa language f0 n 1 greenberg weiss 12 showed exponential expected time required 2pfa accepting language dwork stockmeyer 7 independently kaneps freivalds 17 showed fact 2pfa recognizes nonregular language must run exponential expected time follows 2pfapolytime regular roughly rabins proof shows language l accepted 1pfa finitely many equivalence classes two strings x x 0 equivalent xy 2 l myhillnerode theorem 14 states language finite number equivalence classes regular combined rabins result implies decades later idea extended 2pfas strengthened version myhillnerode theorem needed extension given language l say two strings x x 0 pairwise ninequivalent xy 2 l x 0 62 l furthermore nonregularity l size largest set pairwise n inequivalent strings kaneps freivalds 16 showed nl n bn 32c infinitely many n interesting note prove bound kaneps freivalds first showed nl n equals number states minimal deterministic 1way finite automaton accepts words length n l rejects words length n l following karp 19 denote latter measure oe l n karp 19 previously proved oe l n infinitely many n combining fact nl n oe l n equal follows immediately nl n n21 infinitely many n stronger 1 even n kaneps freivalds lower bound also note dwork stockmeyer 7 obtained weaker bound nl n without using oe l n using tools markov chain theory dwork stockmeyer 7 kaneps freivalds 17 showed language accepted 2pfa polynomial expected time language low nonregularity fact nl n bounded polynomial log n combined result kaneps freivalds implies 2pfapolytime regular models computation nondeterministic probabilistic states studied intensively since work papadimitriou 23 games nature babai moran 3 defined arthurmerlin games turing machines nondeterministic probabilistic states accept languages bounded error probability work polynomial time bounded arthurmerlin games laid framework remarkable progress interactive proof systems applications see example 2 references therein space bounded arthurmerlin games first considered condon ladner 6 condon 4 showed amlogspace class languages accepted arthur merlin games logarithmic space equal class p however known whether class amlogspace polytime subclass amlogspace verifier also restricted run polynomial time equal p whether closed complement fortnow lund 9 showed nc contained amlogspacepolytime dwork stockmeyer 8 first consider npfas arthurmerlin games restricted constant space described conditions language classes 2npfa 2npfapolytime statements theorems 32 33 generalize simplify statements theorems proofs build communication complexity theory terms proofs roughly show languages accepted npfas low fooling set complexity measure defined manner similar tiling complexity language based following definition define 1fooling set binary matrix set entries size 1fooling set binary matrix always 1tiling complexity matrix two distinct entries 1fooling set x tile however 1tiling complexity may significantly larger 1fooling set fact random n theta n binary matrix expected size largest 1fooling set olog n whereas expected number tiles needed tile 1entries omegagamma n log n 3 npfas tiling three results presented section classes 1npfa 2npfa 2npfa polytime describe upper bounds tiling complexity languages classes proof 1npfas natural generalization rabins proof two proofs build previous results dwork stockmeyer 8 2npfas 31 1npfa tiling theorem 31 language l 1npfa 1tiling complexity l o1 proof suppose l accepted 1npfa error probability ffl 12 let states cg consider matrix ml 1entry x ml fix nondeterministic strategy causes string xy accepted probability least 1 gamma ffl respect strategy define two vectors dimension c let p xy state probability vector step input head moves right end x ith entry vector probability state moment assuming automaton started left end input 6 cxy initial state let r xy column vector whose ith entry probability accepting string xy assuming automaton state moment head moves right end x probability accepting string xy inner product fflc partition space 0 1 c cells size theta theta delta delta delta theta final entry cross product actually less 1 multiple associate 1entry x cell containing vector p xy say x belongs cell cell c associate rectangle rc defined fxj exists x belongs cg theta fyj exists x x belongs cg minimal submatrix covers entries associated cell c claim rc valid 1tile rc covers 1entries see suppose x belongs c must 1entry otherwise exist x 0 0 x 0 belong c xy cell claim xy accepted probability least 12 strategy namely strategy reading x uses strategy xy 0 reading uses strategy x 0 see note c c c choice hence probability xy accepted strategy described xy accepted probability greater ffl strategy cannot xy 62 l hence x 2 rc xy must l therefore rc 1tile ml every 1entry x associated cell c covered 1tile rc associated c thus every 1entry ml covered rc hence l 1tiled using one tile per cell total d1e 32 2npfa tiling next show l 2 2npfa 1 l n bounded polynomial theorem 32 language l 2npfa 1tiling complexity l bounded polynomial n proof suppose l accepted 2npfa error probability c number states theorem 31 1entry x ml n fix nondeterministic strategy causes accept string xy probability least 1 gamma ffl construct stationary markov chain h xy models computation xy using strategy markov chain states 2c states labeled q l q state l 2 f0 1g states labeled initial accept reject loop state q 0 h xy corresponds state q reading rightmost symbol 6 cx state q 1 h xy corresponds state q reading leftmost symbol state initial corresponds initial configuration states accept reject loop sink states h xy single step markov chain h xy corresponds running input xy using fixed nondeterministic strategy appropriate configuration one steps enters configuration corresponding one chain states q l halts accepting resp rejecting state entering one configurations h xy enters accept resp reject state halt never reads rightmost symbol 6 cx leftmost symbol h xy enters loop state transition probabilities defined accordingly consider transition matrix h xy collect rows corresponding chain states initial q 0 q call submatrix p xy collect rows corresponding chain states q 1 call submatrix r xy transition matrix looks like r xy initial accept reject loop 3 denotes identity matrix size 3 shall engage slight abuse notation using h xy refer transition matrix markov chain note entries p xy depend x nondeterministic strategy used transition probabilities depend assertion appears contradicted fact choice nondeterministic strategy may depend however idea replace 0 maintaining nondeterministic strategy used xy identical p xy transitions involved simulate computation left part input similarly r xy depends strategy x show jxj n p nonzero element p xy second markov chain k6 cx states form q l q state 1 chain state q l l j6 cxj corresponds state q scanning lth symbol 6 cx transition probabilities states obtained transition probabilities obvious way chain states form q cxj 1 sink states k6cx correspond head falling right end 6 cx state q consider transition probability p p xy suppose markov chain h xy p transition probability q 0 q 0 1 p 2 f0 12 1g since h xy makes transition must simulating single computation step suppose p transition probability q 0 q 0 0 p 0 must path nonzero probability k6 cx state q cxj q 0 cxj visits state q 00 cxj since k6 cx cn states path must path length cn 1 since 12 smallest nonzero transition probability follows p 2 gammacngamma1 cases p transition probability initial state similar similarly jyj n r nonzero element r xy r 2 gammacngamma1 next present lemma bounds effect small changes transition probabilities markov chain lemma slight restatement lemma greenberg weiss 12 version due dwork stockmeyer 8 k sink state markov chain r let ak r denote probability r eventually trapped state k started state 1 let fi 1 say two numbers r r 0 ficlose either chains ij1 r ficlose r ij r 0 ficlose pairs lemma 31 let r r 0 two sstate markov chains ficlose let k sink state r r 0 ak r ak r 0 fi 2s close proof lemma based markov chain tree theorem leighton rivest 20 found 8 approach partition 1entries ml n equivalence classes proof theorem 31 time make entries x x equivalent corresponding markov chains h xy h x 0 0 ficlose fi chosen small enough use lemma 31 show xy 0 x 0 accepted high probability combining strategies xy x 0 0 x 1entry jxj n jyj n nonzero p p xy r r xy partitioning coordinate interval subintervals length divide space dcn cells size theta theta delta delta delta partition 1entries ml n equivalence classes making xy x 0 0 equivalent property state transition p p 0 respective transition probabilities either log p log p 0 size subinterval note number equivalence classes dcn claim chosen small enough equivalence classes induce 1tiling ml n size number equivalence classes theorem 31 associate equivalence class c rectangle rc defined fxjthere exists x 2 cg theta fyj exists x x 2 cg claim x rc xy 2 l entries rectangle 1 rectangle forms 1tile let x rc must 0 x 0 x 0 x 0 2 c consider associated markov chains h xy 0 h x 0 particular consider transition submatrices p xy 0 r x 0 first associated particular nondeterministic strategy x namely one assumes input xy 0 tries cause xy 0 accepted high probability second associated particular nondeterministic strategy namely one assumes input x 0 tries cause x 0 accepted high probability two matrices p xy 0 r x 0 taken together correspond hybrid strategy xy reading x use strategy xy 0 reading use strategy x 0 argue hybrid strategy causes xy accepted probability 12 construct hybrid markov chain h xy using p xy 0 r x 0 chain models computation xy using hybrid strategy since 1entries x 0 x 0 equivalence class c follows p p 0 corresponding transition probabilities markov chains h xy 0 h x 0 either therefore h xy 0 h x 0 2 close immediately follows h xy 2 close h xy 0 h x 0 let xy 0 probability accepts input xy 0 strategy xy 0 let xy probability accepts input xy using hybrid strategy xy 0 resp xy exactly probability markov chain eventually trapped accept state started initial state xy 0 2 l implies xy 2 close lemma 31 implies xy xy 0 implies xy since ffl constants since ffl 12 choose constant small xy 12 therefore xy must l since 1entry x equivalence class matrix ml n 1tiled using dcn tiles therefore since c constants independent n shows 1 l n bounded polynomial n 2 33 2npfapolytime tiling show l 2 2npfapolytime 1 l n bounded polylog function theorem 33 language l 2npfapolytime 1tiling complexity l bounded polynomial log n proof suppose l accepted 2npfa error probability ffl 12 expected time tn let c number states 1entry x ml n fix nondeterministic strategy causes accept string xy probability least 1 gamma ffl construct markov chain h xy theorem 32 say probability p small p tn gamma2 otherwise p large note p large transition probability dividing 1 entries ml n equivalence classes make xy x 0 0 equivalent h xy h x 0 0 property state transition p p 0 respective transition probabilities either p p 0 small log p log p 0 size subinterval time number equivalence classes d2 log model computation inputs x 0 xy 0 xy markov chains h x 0 h xy 0 h xy respectively p p 0 corresponding transition probabilities two markov chains either p p 0 2 close p p 0 small let e x 0 event h x 0 started state initial trapped state accept reject transition labeled small probability taken define e xy 0 e xy similarly since halts expected time tn inputs x 0 xy 0 xy probabilities events go 1 n increases therefore changing small probabilities zero significantly change probabilities h x 0 h xy 0 h xy enter accept state provided n sufficiently large formal justification argument found dwork stockmeyer 8 changes argue xy choose xy 12 follows 1 sufficiently large n establishing result 2 4 bounds tiling complexity languages section obtain several bounds tiling complexity regular nonregular languages section 41 prove several elementary results first regular languages constant tiling complexity second 1tiling complexity nonregular languages least log infinitely often also present example unary nonregular language 1tiling complexity olog n section 42 use rank argument show nonregular languages l either l complement high 1tiling complexity infinitely often 41 simple bounds tiling complexity languages following lemma useful proving theorems section proof implicit work melhorn schmidt 21 include completeness lemma 41 binary matrix 1tiled tiles 2 distinct rows proof let binary matrix 1tiled tiles ft row r let g suppose r 1 r 2 rows ir 1 show case rows r 1 r 2 identical see consider column c suppose entry r 1 c value 1 covered tile therefore r 2 2 r j r 2 c covered tile j hence entry r must value 1 since j 1tile hence r 1 c value 1 r 2 c similarly r 2 c value 1 entry r 1 c therefore r 1 r 2 identical rows since 2 possible values ir 2 distinct rows 2 theorem 41 1tiling complexity l o1 l regular proof myhillnerode theorem 14 theorem 36 l regular ml finite number distinct rows suppose l regular fact exists constant k ml k distinct rows consider possibly infinite set r identical rows ml let c b set columns bit b rows r 1 subset specified r c b btile covers bvalued entries rows r follows 1valued entries r covered single tile hence 1tiling ml n size k similarly 0tiling ml n size k suppose l regular since l regular ml infinite number distinct rows follows immediately lemma 41 cannot tiled constant number tiles 2 theorem uses simple fact 1tiling complexity l n language l lower bound number distinct rows ml n fact number distinct rows ml n language l closely related measure previously studied many researchers dwork stockmeyer called measure nonregularity denoted nonregularity l nl n 7 nl n maximum size set ndissimilar strings l two strings w w 0 considered ndissimilar jwj n jw 0 j n exists string v jwvj n easy show number distinct rows ml n nl n nl 2n previously kaneps freivalds 16 showed nl n equal number states minimal 1way deterministic finite state automaton accepts language l 0 l 0 set strings l length n shallit 28 introduced similar measure nondeterministic nonregularity l denoted nnl n minimal number states 1way nondeterministic finite automaton accepts language l 0 l 0 fact hard show see suppose automaton nnl 2n states accepts language construct 1tiling ml n one tile q per state q entry x covered q accepting path xy enters state q head falls rightmost symbol x straightforward verify set tiles defined way indeed valid 1tiling ml n similar argument used schmidt 27 prove lower bounds number states unambiguous nfa next turn simple lower bounds 1tiling complexity nonregular languages theorem 41 clear l nonregular 1 l n unbounded use known lower bound nonregularity nonregular languages prove lower bound n theorem 42 l regular 1 infinitely many n proof kaneps freivalds 16 proved l regular nl n bn32c infinitely many n definition nl n matrix ml n must least nl n distinct rows therefore lemma 41 1 n lemma follows immediatelywe next present example unary nonregular language 1tiling complexity olog n thus lower bound theorem 42 optimal within constant factor theorem 43 let l complement language fa 1tiling complexity ologn proof show 1valued entries ml n covered olog n 1tiles let lg n denote blog 2 binary numbers length lg n number bits numbers right left starting 1 example binary number q lg q maximum index q equal 2 1 next fact follows easily j j maxflg x lg yg roughly construct 1tiling ml n corresponding following nondeterministic communication protocol party p 1 guesses index j sends j x j p 2 also p 1 sends indicating whether j lg x j lg x p 2 checks checks j lg equivalently either case conclude ml n 1 number bits sent 2 describe 1tiling corresponding protocol union two sets tiles first set one tile jb j b lg n second set tiles one tile j0 j dlog ne j 1 see 1s matrix covered one tiles note entry x matrix 1 fact exists index j j maxflg x lg yg either x j covered tile j0 2 nondeterministic communication protocol proof slight variation simple previously known protocol complement set distinctness problem set distinctness problem two parties hold subset must determine whether subsets distinct application problem determine whether subset whose corresponding values x 0 distinct subset whose corresponding values 1 42 lower bounds tiling complexity nonregular languages section prove language l nonregular 1tiling complexity either l l high infinitely often prove first prove lower bounds rank ml l nonregular apply theorems communication complexity relating rank tiling complexity proofs lower bounds rank ml heavily dependent distinctive structural properties ml consider first case l unary language alphabet fag case follows every n ml n auxiliary diagonal diagonal top right bottom left consists equal elements diagonals parallel diagonal example shown figure 1 matrices classically known hankel matrices extensively studied 15 fact direct application known results rank hankel matrices shows l nonregular infinitely often first proved iohvidov see 15 theorem 113 based previous work frobenius 11 ffl 1 2 3 4 5 6 figure 1 hankel matrix ml 6 l nonunary language ml simple diagonal structure hankel matrix nevertheless ml still structural properties able exploit fact term hankel matrix extended classical meaning refer matrices ml nonunary languages see 26 follows generalize results rank classical hankel matrices prove nonregular language l arbitrary alphabet rankml n 421 notation basic facts let l language arbitrary alphabet let consider row indexed string w row corresponds strings prefix w string row ws corresponds strings prefix ws thus entries row ws determined looking entries row w whose columns indexed strings beginning see figure 2 follows consider relationship rows formally let mnm denote set vectors finite rows indexed strings x length n whose columns indexed strings length let mn denote subset vectors mnm indexed strings x length exactly n v 0 row x mnm 0 v row x mnm v 0 called extension v suppose string sigma length possibly empty string ffl define split v subvector formed v selecting exactly columns whose labels prefix also relabel columns split v removing prefix note split ffl v note also sigma unary say foeg split oe v v first column removed let jvj denote dimension number entries vector v sigma binary oe 2 sigma figure 2 matrix m3 palindromeg bold entries row 110 determined bold entries row 11 bold entries row 110 comprise split 0 11 m2 3 generally c also vector v consists first entry indexed empty string ffl plus interleaving entries split oe v oe 2 sigma precisely following fact 41 let generalize definition split function sets vectors v set vectors mnm jsj let split g following fact 42 jsji split follows vectors consider assumed elements vector spaces arbitrary field f eg proofs hold f taken field rationals f references rank span linear independence apply vector spaces f lemma 42 suppose b ff field f suppose 1 k extension mnm 1 b k v 0 extension v length b 0 k suppose also case length split string length consider string j 0 length 1 let j also hypothesis lemma split putting last three equalities together v 0 j let rankmn rank set vectors mnm let spanmn vector space generated vectors mnm next lemma follows immediately definitions lemma 43 v 0 2 spanmn 0 422 lower bound rank mn l nonregular trivial lower bound rank mn given following fact fact 43 l nonregular infinite sequence integers p r satisfying easily shown using myhillnerode theorem clearly sequence exists rank mn n increases unbounded moreover rank mn unbounded number distinct rows mn unbounded myhillnerode theorem states number equivalence classes l equivalently number distinct rows finite l regular follows l nonregular rank mn unbounded conclusion already noted see sections ii3 ii5 book salomaa soittola 26 describes results literature rational power series regular languages lower bound weak follows significantly improve using special structure mn namely show infinite sequence values n rankmn n 1 define first value n sequence length shortest word l clearly case construct remainder sequence show lemma 45 l nonregular value n n rankmn prove lemma 46 proof theorem 44 n rankmn n 1 choose smallest n rankmn fact rankmm 2 begin following useful lemma lemma 44 let n 0 1 suppose mn proof induction result true hypothesis lemma case lemma true follows induction hypothesis v 2 mn must also case v 2 mn remains consider vectors 1 fact 42 vector v form split oe v 0 oe 1 inductive hypothesis fact 42 b vectors split oe mn mn1m gamma i1 hence finally hypothesis lemma spanmn corollary 41 n 0 rankmn1 r proof n p mp submatrix mn 2p result follows trivially otherwise choose n submatrix mn hence lemma 44 rows mp contained spanmn p thus following lemma shows existence n rankmn lemma 45 let l nonregular language n exists n proof let r number strings length n clearly rankmn r since r rows mnm let r fact 43 hence corollary 41 must case rankmn 2p one possible value satisfies lemma 2 remains show n rankmn n 1 smallest number n rankmn1 m1 rankmn m1 rankmm1 m2 clearly true case rankmn 1 2 difficult case exist values help deal case prove following lemma lemma 46 suppose following properties hold 2 smallest number n mn 3 number range vector mn spanmn extension claim split fact 42 b sufficient prove lemma suppose contrary length split basis mnm let fb 0 p g extension basis 1 properties 1 2 lemma v spanmn let applying fact 41 see split want show length split follows lemma 42 contradicting fact v 0 62 spanmn 1 consider vectors split k mn fact 42 b clearly spanmn 1 property 2 lemma vectors spanmn l basis spanmn 1 k l let c 0 k extension mnm clearly set fc 0 l g also linearly independent since rankmn set basis spanmn split also split also since v 2 mn fact 42 b must vectors split v mn hence property 2 lemma lemma 44 vectors spanmn l basis spanmn follows exists unique sequence coefficients l split also combining equation 2 equation 4 see split 1l 2l pl c l thus pk k 2 claim split l 2l l l justify claim initial assumption split thus unique coefficients 0 l split l c 0 c 0 k extension c k unique linear combination c l equal split v follows 0 proves claim combining claim equation 3 yields split desired 2 prove lower bound theorem 44 l nonregular proof base case n shortest word language length n suppose rankmn fixed n let smallest number n rankmn claim rankmm 2 claim clearly true suppose n basis mn k n k 1 extensions vectors b k b k1 let b 0 denote subset b k extensions vectors b kgamma1 construct set linearly independent vectors mm 1 follows k n 1 define linearly independent set c k vectors mm 1 k size least k 1 cm1 desired set let c definition linearly independent set size n initial assumption rankmn n 1 suppose n c k already constructed linearly independent construct c k1 follows k set extensions mm vectors c k add c 0 k c k1 c k1 thus c k1 expanded contain vectors b k1 b 0 iii finally suppose nothing added c k1 step ii rankmn equivalent rankmn thus apply lemma 46 obtain vector v spanmn k add v 0 c k1 claim vectors c k1 linearly independent clearly set c 0 k linearly independent consider vector u 0 added c k1 c 0 k construction u 0 spanb 0 extension vector u mm 1 k claim vector u must linearly dependent set b k true u 0 added step ii since case u mn basis mn k also true case u vector added step iii since lemma 44 hence moreover u expressed unique linear combination vectors c k nonzero coefficients vectors b k u 0 spanc 0 k since extension u would also expressible unique linear combination vectors c 0 k nonzero coefficients vectors b 0 k contradicts fact u 0 62 spanb 0 423 tiling complexity lower bound theorem 45 l nonregular 1tiling complexity either l l leastp log infinitely often proof melhorn schmidt independently orlin showed binary matrix 21 22 result holds field halstenberg reischuk refining proof aho et al showed dlog theorem 44 l nonregular rank mn least n follows infinitely many n log 5 variations model section discuss extensions main results related models first show theorem 11 also holds following alternating probabilistic finite state automaton model model call 2apfa nondeterministic states n partitioned two subsets ne nu existential universal states respectively accordingly fixed input two types strategy defined follows fixed input string existential universal strategy w function ffiq oe q language l sigma accepted bounded error probability constant ffl 12 1 w 2 l exists existential strategy ew automaton accepts probability strategies uw 2 2 l every existential strategy ew automaton accepts probability ffl universal strategy uw complexity classes 1apfa 1apfapolytime defined natural way following conventions npfa model theorem 51 proof theorems 11 31 show l language accepted 1apfa tiling complexity l bounded first extend notation theorem 31 e existential strategy xy u universal strategy xy let p xy e u state probability row vector step input head moves right end x strategies e u let r xy e u column vector whose ith entry probability accepting string xy assuming automaton state moment head moves right end x strategies e u 1entry x ml fix existential strategy e xy causes xy accepted probability least 1 gamma ffl universal strategies partition space 0 1 c cells size theta theta let c nonempty subset cells say entry x ml belongs c xy 2 l c smallest set cells contain vectors p xy strategies u nonempty subset c cells associate rectangle r c defined follows fx j exists x belongs cg theta fy j exists x x belongs cg r c valid 1tile see suppose x 2 r c x belongs c must 1entry otherwise exist x 0 0 x 0 belong c consider strategy e reading x uses strategy e xy 0 reading uses strategy e x 0 claim xy accepted probability least 12 existential strategy e universal strategy u xy probability xy accepted strategies e u belong set cells c cell universal strategy u 0 moreover quantity probability x 0 accepted existential strategy universal strategy hybrid u u 0 also definition e x 0 probability x 0 accepted respect e x 0 universal strategy c choice hence probability xy accepted strategies e u since u arbitrary follows existential strategy e strategies u probability xy accepted strategies e u greater ffl cannot xy 62 l hence x 2 r c xy must l therefore r c 1tile ml proof completed theorem 31 2 way theorem 33 also extended obtain following theorem 52 language l 2apfapolytime 1tiling complexity l bounded 2 polylogn thus example language pal consisting strings f0 1g read forwards backwards class 2apfapolytime see consider submatrix ml n consisting rows columns labeled strings length exactly n matrix contains fooling set size 2 n hence 1tiling ml n requires least 2 n tiles next extend theorem 12 automata olog log n space refer arthurmerlin games since usual notation automata restricted finite number states 7 definition arthurmerlin game similar npfa except machine fixed number readwrite worktapes arthurmerlin game runs within space sn input w jwj n sn tape cells used worktape thus number different configurations arthurmerlin game theorem 53 let arthurmerlin games recognize nonregular language l complement l respectively within space olog log n suppose expected running time bounded tn b 12 log log tn log n b particular tn bounded polynomial n proof proof theorem 12 extended space bounded arthurmerlin games yield following generalization equation 1 let cn upper bound number different configurations inputs length n let sufficiently large n number 1tiles needed cover ml n since uses olog log n space constant c 0 dn log n c sufficiently large n suppose contrary b 12 log log tn log n b sufficiently large n log n hence number tiles needed cover 1valued entries ml n 2 log n argument shows also sufficiently large n number tiles needed cover 1valued entries l n 2 log n hence theorem 45 l must regular contradiction 2 finally consider restriction 2npfa model given polynomial time recognize regular languages restricted 2npfa 2npfa ffl 12 inputs w strategies sw probability automaton accepts either theorem 54 language accepted restricted 2npfa bounded error probability polynomial time regular proof let l accepted 2npfa bounded error probability polynomial expected time let sigma alphabet ffi transition function set states n ae q set nondeterministic states without loss generality let g first define representation strategies strings finite alphabet let sigma loss generality assume sigmasigma string corresponds strategy 6 cw set strings form oe oe alphabet sigma alphabet sigma 0 furthermore corresponds strategy input causes w accepted l 0 accepted 2pfa bounded error probability polynomial time thus l 0 regular 7 moreover note string form l choice 0 l 0 let 0 oneway deterministic finite state automaton l 0 assume without loss generality set states 0 head even position disjoint set states 0 head odd position 0 construct oneway nondeterministic finite state automaton l replacing even position states nondeterministic states hence l regular 2 6 conclusions introduced new measure complexity language namely tiling complexity proved gap tiling complexity regular nonregular languages applied results prove limits power finite state automata probabilistic nondeterministic states intriguing question left open work whether class 2npfapolytime closed complement conclude 2npfapolytime regular recall class 2npfa contain nonregular languages since contains class 2pfa freivalds 10 showed f0 n 1 class however kaneps 18 showed class 2pfa contain nonregular unary language another open question whether class 2npfa contains nonregular unary language also open whether nonregular language 2apfapolytime several interesting open problems one obtain better lower bound tiling complexity nonregular languages given theorem 45 perhaps argument based rank know nonregular language tiling complexity less n infinitely often current gap wide r notions information transfer vlsi circuits proof verification hardness approximation problems computational models games power finite automata nondeterministic probabilistic states probabilistic game automata finite state verifiers power interaction interactive proof systems alternating timespace complexity probabilistic twoway machines lower bound probabilistic algorithms finite state machines different modes communication introduction automata theory hankel toeplitz matrices forms algebraic theory minimal nontrivial space complexity probabilistic oneway turing machines running time recognize nonregular languages 2 way probabilistic automata regularity oneletter languages acceptable 2way finite probabilistic au tomata bounds storage requirements sequential machines turing machines markov chain tree theorem las vegas better determinism vlsi distributed computing contentment graph theory covering graphs cliques games nature probabilistic automata finite automata decision problems succinctness description context free automaticity properties measure descriptional complexity complexity questions related distributed computing lower bounds probabilistic arguments tr ctr lutz schrder paulo mateus universal aspects probabilistic automata mathematical structures computer science v12 n4 p481512 august 2002 bala ravikumar variations twoway probabilistic finite automata models theoretical computer science v376 n12 p127136 may 2007
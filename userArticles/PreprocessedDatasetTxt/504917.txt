prefetching improved bus wrapper performance cores reuse cores reduce design time systemsonachip reuse dependent able easily interface core bus enable interfacing many propose separating cores interface internals using bus wrapper however separation lead performance penalty reading cores internal registers paper introduce prefetching analogous caching technique reduce eliminate performance penalty involving tradeoff power size describe prefetching technique classify different types registers describe initial prefetching architectures heuristics certain classes registers highlight experiments demonstrating performance improvements sizepower tradeoffs introduce technique automatically designing prefetch unit satisfies userimposed registeraccess constraints technique benefits mapping prefetching problem wellknown realtime process scheduling problem extend technique allow userspecified register interdependencies using petri net model resulting even efficient prefetch schedules b overview separating cores interface behavior internal behavior lead performance penalties example consider core architectures shown figures 1a 1b 1c showing core bus wrapper core bus wrapper bw without prefetching core bw prefetching respectively latter two architectures similar proposed vsia bw interfaces system bus whose protocol may arbitrarily complex include variety features like arbitration bw also interfaces core internals core internal bus bus typically extremely simple implementing straightforward data transfer internal bus vsi onchip bus group standardizing without bw read cores internal register onchip bus may take little two cycles shown figure 2a bw read cores internal register may require four cycles two internal module bw acm transactions design automation electronic systems vol 7 1 january 2002 prefetching improved bus wrapper performance 7 fig 3 pvcis location systemonachip two bw bus thus read may require extra cycles compared core whose interface internal behavior combined however core interface behavior separated bus wrapper believed much easier retarget different buses core whose interface behavior integrated internal behavior standardizing interface cores internals bus wrapper retargeting core may become easier 32 pvci deciding single onchip bus standard unlikely vsia developed vci virtual socket interface association 1997b vci proposed standard interface cores internals cores bus wrapper illustrated figure 3 retargeting core using vci involve roughly changes bus wrapper since vci ensures changes limited wrapper internals since bus provider even provide bus wrapper templates bus vci vci far simpler protocol typical bus protocol since pointtopoint transfer protocol contrast bus protocol may involve advanced features arbitration data multiplexing pipelining thus standardizing vci far simpler standardizing bus protocol pvci simplied version vci specically intended periph erals pvci cores would reside lowerspeed peripheral bus shown figure 3 thus would need highspeed features vci eg packet chaining general structure pvci shown figure 4 consists two unidirectional buses one bus leads wrapper internals wrapper sets read line indicate read write sets address lines valid address write also sets wdata lines asserts val line actually initiate read write wrapper must hold lines constant internals assert ack line write means internals captured write data read means internals put read data rdata bus transaction acm transactions design automation electronic systems vol 7 1 january 2002 8 lysecky vahid fig 4 pvcis general structure completed next rising clock edge fast internals module keep ack asserted continuously provide fast transfers similar spirit synchronous wait protocol vahid givargis 1999 33 experiments bus wrappers sought evaluate impact wrapper pvci using simple peripheral bus used bus twophase handshake protocol ensure communication fast possible given peripheral previously demonstrated using wrapper results twocycle overhead per read compared integrated core figure 2a illustrates timing read cycle peripheral bus integrated core peripheral bus master case bridge places address addr strobes rd peripheral responds placing data data strobing rdy early cycle receiving rd strobe thus total read cycle could little two clock cycles figure 2b illustrates read cycle bus core using bus wrapper bus master places address strobes rd wrapper responds translating read request read request internal bus translation involves translating address one appropriate core placing address wrp addr asserting wrp read cores internals respond placing data wrp data asserting wrp rdy wrapper receives data puts peripheral bus strobes rdy write cycle need incur performance overhead wrapper ver sions bus master sets addresses strobes appropriate ready line wrapper respond immediately capturing data strobing ready line like integrated core wrapper proceed write captured data core internals bus master proceeds activities example evaluated simple version digital camera system illustrated figure 5 camera system consists simplied mips mi croprocessor bios memory system bus bridge system bus peripheral bus isa ccd chargecoupled device prefetching improved bus wrapper performance 9 fig 5 digital camera example system preprocessor simple codec compressordecompressor twolevel bus structure accord hierarchical bus concept described virtual socket interface association 1997a camera written registertransfer level synthesizable vhdl synthesizes 100000 cells used synopsys design compiler well synopsys power analysis tools evaluate different design metrics power performance measured processing one frame made changes ccd preprocessor codec cores since represent peripherals peripheral bus cores used heavily processing frame created three versions camera system 1 integrated ccd preprocessor codec cores written interface behavior inlined internal behavior core thus synthesis generates one entity core 2 nonpvci wrapper ccd preprocessor codec cores written interface behavior separated wrapper thus synthesis generates two connected entities core interface two wrapper internal entities consisted single bidirectional bus strobe control line readwrite control line however many address lines necessary distinguish among internal registers 3 pvci wrapper previous version except interface wrapper internal entities pvci nonpvci wrapper version created another purpose well pvci standard developed knowledge version would used experiments thus structure developed simple possible table summarizes size performance power results size reported equivalent nand gates time nanoseconds power milliwatts size overhead using buswrapper nonpvci compared integrated version roughly 1500 gates per core overhead comes extra control acm transactions design automation electronic systems vol 7 1 january 2002 table comparison interface versions using custom bus version ex size wrapper size power total time io time integrated wrapper ccd 1661 34556 811 79055 15520 codec 1674 1904 pvci wrapper ccd 1439 33978 798 79055 15520 codec 1434 1588 registers integrated version cores internals includes control interface peripheral bus wrapper version control replaced control interfacing wrapper size cores internals stays however wrapper must implement control interfacing internals interfacing peripheral bus representing overhead wrapper must also include registers whose contents copied tofrom internals representing additional overhead reason nonpvci wrapper version shows size overhead pvci wrapper version nonpvci version used single bus transfers two core internals whereas pvci species two separate buses resulting less logic wires fifteen hundred gates size overhead seems quite reasonable given continued increase chips gate capacities given peripheral cores typically posses 20000 gates mentor graphics nd system power overhead 1 extra power comes transfer items twice per access write item must transferred rst bus wrapper wrapper internals read item must transferred rst internals wrap per wrapper bus however power consumed memory system bus processor dominate extra power due wrappers smalleven though ccd codec heavily used processing frame table see 100 increase peripheral io access time bus wrappers employed overhead due use wrapper would occurred whether using pvci another wrapper experiments ccd accessed 256 times per image frame codec accessed total 128 times per frame mips processor executed approximately 5000 instructions per frame overall overhead bus wrappers amounts approximately 5 one difference nonpvci pvci interface appear results number wires internal core nonpvci version uses multiplexed bus fewer signals pvci signals shown thus would fewer internal wires noting ccd codec cores relatively small simple interfaces took us 6 designer hours excluding synthesis simulation time retarget design one wrapper another eg convert ccds nonpvci wrapper pvci implementation synthesis time ccd codec approximately 1 hour simulation time capturing acm transactions design automation electronic systems vol 7 1 january 2002 prefetching improved bus wrapper performance 11 one image frame slightly 10 hours power analysis additional 5 hours times obtained synthesizing models gates using synopsys design compiler medium mapping effort using lsi10k library supplied synopsys area delay constraints specied used dual 200mhz ultra sparc ii machine perform synthesis simulation synthesis simulation times relatively integrated bus implementations using bus wrapper note peripheral devices capable dma burst mode io interrupts require time integrate system although use bus wrappers improves usefulness core making easier retarget varying systems reusability comes cost bus wrappers introduce performance power overhead demon strated tightly constrained systems peripheral access time critical overhead often infeasible ideally use bus wrappers could allow quick retargeting core degrading performance next section present technique called prefetching effectively eliminates performance overhead bus wrappers 4 basic prefetching 41 overview focus minimize performance penalty order maximize usefulness core seek manner transparent developers core internal behavior well developers onchip bus continued exponential growth chip capacity seek gain performance making tradeoff increased size since size constraints continue ease however note approach increases switching activity core thus must also evaluate increased power consumption seek minimize increase focus peripheral cores whose registers read microprocessor onchip bus perhaps via bus bridge idea minimize read latency experienced microprocessor basic technique propose called prefetching prefetching technique copying cores internal register data prefetch register cores bw read request bus occurs core immediately output prefetched data without spending extra cycles rst get data cores internal module use terms hit miss manner identical caches hit means desired data prefetch register miss means data must rst fetched prefetch register output onchip bus example figure 2c shows prefetching cores internal register bw register d0 results system read requiring two cycles rather four 42 classication core registers immediately recognized need classify common types registers found peripheral cores since different types would require different prefetching approaches 12 lysecky vahid examining cores primarily inventra library mentor graphics nd focusing bus peripherals serial communication encryption com pressiondecompression dened register classication scheme based four attributes update type access type notication type structure type 1 update type register describes registers contents mod ied possible types include staticupdate register updated system system device devices communicate core onchip bus example static register conguration register system updates register registers content change system updates b volatileupdate register updated source system eg internally core externally cores environment either random xed rate example analogtodigital converter samples external data converts data digital stores result register xed rate c inducedupdate register updated direct result another register within core updated thus associate register inducing register typically induced register one provides status information 2 access type register describes whether system reads andor writes register possible types including readonly access b writeonly access c readwrite access 3 notication type describes system made aware register updated possible types including interrupt notication core generates interrupt register updated b registerbased ag notication core sets ag bit bit may part another register c output ag notication core specic output signal asserted register updated notication system informed updates simply uses recent register data 4 structure type register describes actual storage capability register possible types including singly structured register accessed address internally implemented one register b queuestructured register register accessed address internally implemented block memory common example buffer register uart c blockstructured register block registers accessed consecutive addresses register le memory prefetching improved bus wrapper performance 13 43 commonly occurring register types rst attempt developing prefetching techniques cores focused following three commonly occurring combinations registers cores 1 core1conguration registers many cores congurable settings controlled set conguration registers typical conguration register features static update readwrite access notication singly structured refer example core1 2 core 2task registers many cores carry specic task start completion combination data input register data output register status register indicates completion cores task example codec compressdecompress core typically set registers looked prefetch data output status regis ters data output register following features volatileupdate random rate readonly access registerbased ag notication ag stored status register singly structured status register following features induced update update data output reg ister readonly access notication singly structured although data input register prefetched features volatileupdate random rate writeonly access notication singly structured refer example core2 3 core3inputbuffer registers many cores combination queue data buffer receives data status register indicates number bytes buffer common example core uart features data buffer include volatileupdate random rate readonly access registerbased ag notication stored status register queuestructured status register features include inducedupdate update data register readonly access notication singly structured refer example core3 44 prefetching architectures heuristics 441 architecture order implement prefetching listed combinations registers developed architectures bus wrappers figure 6 illustrates architecture three combinations respectively bw architecture three regions 1 controller controllers main task interface onchip bus thus handles reads writes cores registers write controller writes data core internal bus core internal register read controller outputs appropriate prefetch register data onto bus hit outputting done immediately miss done forcing prefetch unit rst read data core internals 2 prefetch registers registers directly connected onchip bus fast output output bus must pass one registers 14 lysecky vahid bus wrapper architecture timing diagrams core1 b core2 c core3 fig 6 prefetching improved bus wrapper performance 15 3 prefetch unit pfu implements prefetch heuristics responsible reading data core internals prefetch registers goal maximize hits architecture core1 situation shown figure 6a showing one register corresponding prefetch register d0 since updated onchip bus prefetch unit needed instead write d0 whenever write lack pfu exception normal situation figure 6b shows architecture core2 situation data output register status register prefetch registers bw data input register di since never read onchip bus pfu carries prefetch heuristic see next section unless controller asserts writing line case pfu suspends prefetching controller may write di core internal bus figure 6c shows architecture core3 example writeaccess registers hence include bus controller core internal bus 442 heuristics applied following prefetch heuristics within cores bus wrapper upon system write data register simultaneously write data prefetched data register d0 assumes write data register occur prior read register system writes data input register di read cores internal status register prefetched status register s0ifthe status indicates completion read cores internal data output register prefetched dataoutput register do0 repeat process continuously read cores internal status register prefetched status register s0 status indicates buffer longer empty read cores data register prefetched data register d0 waiting system read data continuously read cores internal status register prefetched status register thereby providing current status information data read system depending whether buffer empty either read next data item core repeat process figure 6 shows timing diagrams three cores bw prefetch ing three cores read latency core bw prefetching equal latency core without bw thus eliminating performance penalty note bws architecture heuristic dependent core internals acceptable since core developer builds bw bw controllers bus interface however dependent core internals desired 45 experiments implemented cores representing three earlier common examples order evaluate performance power size tradeoffs achievable acm transactions design automation electronic systems vol 7 1 january 2002 table ii impact prefetching several cores size wo bw gates size wbw wo pf gates size wbw wpf gates26692638617211506performance wo bw ns performance wbw wo pf ns performance wbw wpf ns9835551555454305power wo bw microwatts power wbw wo pf microwatts power wbw wpf microwatts13994805601521energy wo bw nj energy wbw wo pf nj energy wbw wpf nj1376265311655prefetching results summarized table ii three cores written soft cores registertransferlevel behavioral vhdl three cores required 136 220 226 lines vhdl respectively synthesized cores using synopsys design compiler performance average power energy metrics measured using synopsys analysis tools using suite core test vectors core important note cores simple internal behavior used experimentation purposes although examples small pfu unit independent core internals approach applied larger examples well three cores prefetching added bws performance penalty effectively eliminated core2 core3 trivial onetime 30ns 10ns overhead associated initial time required start restart prefetching process particular prefetch heuristics addition bw cores adds size overhead design size constraints continue relax chip capacities continue exponential growth three cores described average increase size core 1352 gates large percentage increase size core1 due fact cores unusually small begin since simple internal behavior 1000 2000 gates typical cores would closer 10000 20000 gates percentage increase caused thousand extra gates would much smaller order prefetching viable solution problem power energy consumption must also acceptable power function amount switching core energy function switching total execution time bws without prefetching caused increase power due additional internal transfers bw increase overall energy consumption due longer execution time three cores compared bws without prefetching bws prefetching may increase decrease power depending prefetch heuristic particular application ex ample core1 core3 increase power due constant activity prefetch unit core2 decrease power due periods time prefetch unit idle however three cores use prefetching bw decreased energy consumption acm transactions design automation electronic systems vol 7 1 january 2002 prefetching improved bus wrapper performance 17 table iii impact prefetching digital camera performance reads cycles wo prefetching cycles w prefetching ccdstatus ccddata codecstatus codecdata25625710241028512514 total 2 cores 772 3088 1544 digital camera peripheral io access digital camera processor execution digital camera 48616 47072 table iv impact prefetching digital camera powerenergy prefetching bw wprefetching power mw 954 981 981 energy j 449 477 462 bw without prefetching reduced execution time addition increase energy consumption relative core without bus wrapper fairly small evaluate usefulness prefetching analyzed digital camera shown figure 5 initially implemented ccd codec cores using bws without prefetching therefore modied use prefetching compared two versions digital camera system table iii provides number cycles reading status data registers two cores capture one picture frame number cycles required cores prefetching half number cycles required without prefetching improvement performance reads ccd codec 50 overall improvement performance digital camera 1500 cycles adding prefetching two cores total 47000 cycles capture picture frame prefetching performance increase digital camera directly related ratio io access processor computation digital camera spends 78 execution time performing computation 12 performing io access prefetching large impact overall performance however increase performance peripheral io access 25 therefore design io intensive one would expect greater percentage performance increase furthermore processor pipelined number cycles required program execution would decrease percentage time required io access would increase thus one would expect greater percentage performance increase prefetching adding prefetching cores would course result even reductions power energy penalties shown table iv see example prefetching able eliminate performance overhead associated keeping interface internals separated core prefetching enables elimination performance penalty fully supporting idea vsi standard internal bus bw core internals also varied tradeoff performance size power ideally future tool would synthesize bw satisfying power performance size constraints given user core 5 realtime prefetching 51 overview one drawbacks prefetching technique described prefetch unit manually designed created desired also investigate automatic solution designing prefetch unit bus wrapper automated approach identical architecture previous bus wrapper prefetching however redene task prefetch unit pfu prefetch unit responsible keeping prefetch registers uptodate possible prefetching cores internal registers internal bus internal bus used write controller ie internal bus idle cycles one register read core internals time assume given list cores readable registers must prefetched also assume bus wrapper accommodate one copy register register list annotated two important readaccess constraints register age constraint constraint represents number cycles old data may read words represents period prefetch register must updated least age constraint 0 means data must recent data turn means data must come directly core hence prefetching allowed since prefetched data necessarily least one cycle old constraint 0 also means accesstime constraint must least four cycles register accesstime constraint constraint represents maximum number cycles read access may take minimum two case register must prefetched accesstime constraint greater 2 denotes additional cycles may tolerated wish design pfu reads core internal registers prefetch registers using schedule satises age accesstime constraints registers note certain registers may prefetched frequently others required satisfy differing register access constraints tradeoff prefetching performance improvement expense size power main goal performance improvement ensure size power grow acceptable amount future work may include optimizing cost function performance size power example figure 7 shows core three registers b c assume registers b independent registers readonly updated randomly core internals assume b register age constraints four six cycles respectively might use naive prefetching heuristic prefetches every idle cycle reading 60 prefetching improved bus wrapper performance 19 fig 7 bus wrapper prefetching table v prefetch scheduling core figure 7 idle cycle schedule 1 schedule 213579 b 40 time leading schedule 1 table v however create efcient schedule shown schedule 2 although schedules meet constraints rst schedule likely consume power naive scheduler also consider effects register writes taken consideration using realtime scheduling techniques investigation heuristics solve prefetching problem noticed problem could mapped widely studied problem realtime process scheduling rich set powerful heuristics analysis techniques already exist describe mapping provide several prefetching heuristics based realtime scheduling heuristics analysis methods 52 mapping realtime scheduling simple denition realtime scheduling problem follows given set n independent periodic processes set processors must acm transactions design automation electronic systems vol 7 1 january 2002 20 lysecky vahid order execution n processes onto processors process period pi deadline di computation time ci period process rate process requests execution deadline length time process must complete execution requests executed finally computation time length time process takes perform computation therefore realtime scheduling task ordering execution n processes among processors ensure process executes every period pi within deadline di process takes ci time complete mapping prefetching problem realtime processscheduling problem follows process register must scheduled prefetching corresponds process must scheduled execution internal bus processor internal bus accommodate one prefetch time likewise processor accommodate one process execution time thus internal bus corresponds processor prefetch process execution prefetch occurs internal bus thus corresponds process execution occurring processor register age constraint process period register age constraint denes period register must prefetched corresponds period process must scheduled register accesstime constraint process deadline accesstime constraint denes amount time read may take relative read request corresponds amount time process must complete execution relative time requested service process computation time prefetch corresponds process execution time prefetch corresponds computation time process paper assume prefetch requires two cycles although heuristics analysis would course apply extended register model allow rather rare situation different registers would require different amounts time read core internals given mapping use several known realtime scheduling analysis techniques solve prefetching problem 53 heuristics 531 cyclic executive approach cyclic executive approach burns wellings 1997 straightforward process scheduling method used xed set periodic processes approach constructs xed repeating schedule called major cycle consists several minor cycles xed duration minor cycle rate process highest priority executed minor cycle therefore equal smallest age registers prefetched approach attractive due simplicity however handle sporadic processes case sporadic writes prefetching improved bus wrapper performance 21 table vi prefetch core descriptions core register max age priority rm pf time response time util util bound process periods registerage constraints must multiple minor cycle time constructing executive may computationally infeasible large number processes registers serve examples describe three cores various requirements table vi contains data pertaining three cores table vi contains information regarding maximum register age constraint max age register access time constraint deadline rate monotonic priority assignment prior ity rm time required prefetch register pf time response time register response time utilization register set util utilization bound register set util bound core1 implements singlechannel dac converter although analog portion converter could modeled vhdl technique converting analog input implemented core single register data readonly updated randomly externally system core2 calculates greatest common divisor gcd three inputs providing checksum information inputs result core contains three registers gcd1 gcd2 cs result gcd calculator valid gcd1 equal gcd2 registers gcd1 gcd2 cs independent readonly registers updated externally system core3 registers stat bias b res stat status register readonly indicates status core ie busy busy registers b readonly registers updated randomly outside system res readonly register containing results computation registers b bias bias writeonly register represents programmable adjustment computation use cyclic executive approach create schedule three cores core1 minor cycle major cycles three core2 minor cycle 10 major cycle 20 finally core3 construct cyclic executive minor cycle major cycle 25 532 rate monotonic priority assignment general scheduling approach used complex examples wherein determine process schedule register prefetch next based priority scheme rate monotonic priority assignment burns wellings 1997 assigns priority register based upon age register smallest age highest priority likewise register largest age lowest priority examples use priority 1 indicate highest priority possible rate monotonic priority assignment known acm transactions design automation electronic systems vol 7 1 january 2002 22 lysecky vahid optimal sense process set scheduled xedpriority assignment scheme set also scheduled rate monotonic assignment scheme refer table vi data pertaining three cores core1 register age constraint register data three cycles given data register present assigned highest prior ity core2s registers gcd1 gcd2 cs age constraints 10 10 respectively therefore corresponding priorities highest lowest gcd1 gcd2 cs however register age constraint gcd1 gcd2 equal priorities core2 could also highest lowest gcd2 gcd1 cs important note priorities registers age constraint assigned arbitrary relative priorities long constraints met core3 age constraints registers stat b res respectively 5 25 25 10 therefore priority registers highest lowest would stat res b 533 utilizationbased schedulability test utilizationbased schedulability test 8 used quickly indicate whether set processes scheduled case whether registers prefetched n registers register set prefetched equation 1 true ci computation time register ai age constraint register n number registers prefetched lefthand side equation represents utilization bound register set n registers righthand side represents current utilization given register set register set passes test registers prefetched schedulability analysis needed however register set fails test schedule register set meets constraints might still exist words utilizationbased schedulability test indicate register set prefetched indicate register set cannot prefetched analyze cores determine whether schedule table vi see core1 core2 pass utilizationbased schedulability test respective utilizations 667 500 corresponding utilization bounds 100 780 indicates create schedule cores need perform analysis however core3 utilization 860 utilization bound four registers 757 therefore failed utilizationbased schedulability test though schedule might still exist 534 responsetime analysis responsetime analysis burns wellings 1997 another method analyzing whether process set case register set scheduled however addition testing schedulability set registers also provides worstcase response time register calculate response register using equation acm transactions design automation electronic systems vol 7 1 january 2002 prefetching improved bus wrapper performance 23 2 ri response time register ci computation time register ii maximum interference register experience time interval c ri interference register amount time process must wait higherpriority processes execute ri ci c ii 2 register set schedulable registers set response time less equal age constraint table vi see registers three cores meet register age constraints therefore possible create prefetching schedule three cores interesting note although utilizationbased schedulability test failed core3 response time analysis indicates registers prefetched refer reader burns wellings 1997 details responsetime analysis writes consider impact writes core registers writes come unknown intervals write ties cores internal bus thus delays prefetches done therefore view register write highpriority sporadic process attribute maximum rate write commands sent core also introduce deadline write deadline write similar accesstime register prefetched deadline indicates write occurs must completed within specied number cycles order analyze register write impact scheduling create dummy register wr register set age wr register period corresponds maximum rate write occur wrs accesstime equal deadline analyze register set determine prefetching schedule exists analysis provide us analysis worst case scenario write occur every period 536 deadline monotonic priority assignment point interested mainly static schedule register set however writes sporadic must provide dynamic mechanism handling thus dynamic scheduling technique used cannot accurately predict writes therefore use advanced priority assignment scheme deadline monotonic priority assignment burns wellings 1997 deadline monotonic priority assignment assigns priority process register based upon deadline accesstime smaller accesstime corresponds higher priority still incorporate rate monotonic priority assignment order assign priorities registers equal accesstimes deadline monotonic priority assignment known optimal sense process set scheduled priority scheme scheduled deadline monotonic priority assignment example order accommodate writes bias register core3 add bias register prefetching algorithm deadline bias register ensure writes always acm transactions design automation electronic systems vol 7 1 january 2002 fig 8 performance ns top size gates middle energy nj bottom highest priority use deadline monotonic priority assignment using priority assignment mechanism priority registers highest lowest would bias stat res b 54 experiments realtime prefetching addition implementing adjust core described implemented two additional examples order evaluate impact perfor mance size energy using realtime prefetching codec core contains three registers din dout stat core behaves like simple compressordecompressor whereby input data modied via arbitrary translation stat register updated reect completion fifo core contains two registers data stat core represents simple fifo data stored data current number items fifo stored stat modeled cores synthesizable registertransfer vhdl models requiring 215 204 253 lines code respectivelynote intentionally describe internal behavior cores rather register accessrelated behavior could see impacts prefetching clearly used synopsys design compiler synthesis well synopsys power analysis tools figure 8 summarizes results three cores core examined three possible bus wrapper congurations bus wrapper bw bus wrapper without prefetching bw bus wrapper realtime prefetching rtpf rst chart figure 8 summarizes performance results using realtime prefetching heuristic see good performance improvement compared bus wrapper without prefetching however fifo acm transactions design automation electronic systems vol 7 1 january 2002 prefetching improved bus wrapper performance 25 see small performance improvement using realtime prefetch ing small improvement due fact data register fifo cannot prefetched using approach prefetch using realtime prefetching would empty fifo lose data fur thermore without prefetching see signicant performance penalty second chart figure 8 summarizes size results expected size cores increased bus wrapper added increased prefetching added bus wrapper average increase size caused adding realtime prefetching bus wrapper 14k gates increase design complexity due need keep track current register ages furthermore size increase relatively small compared typical core size 10k 20k gates third chart figure 8 summarizes energy consumption test vectors three cores overall increase energy consumption bus wrapper added core however addition prefetching bus wrappers always strictly increase decrease energy consumption fact realtime prefetching increased energy consumption codec fifo decreased energy consumption adjust expected compared core without bus wrapper prefetching resulted increase energy consumption 6 updatedependency based prefetching using petri nets 61 overview cases core designer may able provide us information regarding cores internal registers get updatedin particular update dependencies among registers eg register updated externally register b updated one cycle later using information design schedule performs fewer prefetches satisfy given constraints thus yield advantages able handle complex problems using less power 62 general register attributes need method capturing information designer provides regarding register updates section 32 provided taxonomy register attributes used categorize register used extend introducing update dependecies update dependencies provide details register gets updated result updates inducements two kinds update dependencies internal dependencies dependencies registers must accurately described dependencies registers affect operation core time registers updated therefore dependencies extremely important providing accurate model cores behavior 26 lysecky vahid external dependencies updates registers via reads writes ocb also need included model information important reads writes directly update registers trigger updates registers eg write control register codec core trigger event update output data register likewise updates external ports internal core registers must also present model events occur random intervals cannot directly monitored bus wrapper therefore needed provide complete model core needed create model capture information analyzing many possible models describe internal external update depen dencies concluded petri net model would best requirements 63 petri net model construction petri net models places arcs transitions model place represents data storage ie register bus bus wrapper monitor model bus place generate tokens puted outgoing arcs consumed data storage places whenever appropriate transition red transition represents update dependency either bus register two registers transitions may labeled conditions represent requirement data coming transition however many cases register may updated external source ie registers updatetype volatile therefore need mechanism describe updates use transition without incoming arcs without associated condition represent behavior refer transition random transition given random transi tions tokens also generated external sources cannot directly monitored bus wrapper thus model provides complete description cores internal register dependencies without providing details cores internal behavior implemented three core examples analyze update dependency model prefetching technique order demonstrate usefulness model describe one cores implemented refer adjust elaborate example throughout paper adjust contains three registers go md first annotate register general register attributes described earlier go register attributes staticupdate write access notication singly structured md register attributes volatileupdate readwrite access notication singly structured finally register attributes volatile update readonly access notication singly structured next constructed petri net adjust figure 9 shows register update dependency model adjust model see register updated go updated whenever write request go initiated ocb updated randomly external event unknown prefetch unit md updated go equal 1 write request md initiated ocb external acm transactions design automation electronic systems vol 7 1 january 2002 prefetching improved bus wrapper performance 27 fig 9 adjust register dependencies event occurs therefore complete model adjust core used create prefetching algorithm using current model adjust need three prefetch registers bus wrapper namely go0md0 s0go0 would updated whenever write go initiated ocb md need method refreshing prefetch registers keep uptodate possible later discuss heuristics updating registers incoming random transitions however know prefetching md register would required write md made ocb go register equal 1 simple interpretation model reduce power consumed prefetch unit prefetching md needed 64 model renement dependencies renement register update dependency model made eliminate random transitions although model particular core may many random transitions may exist relationships registers random transitions two registers updated external event possible relationship may exist registers example typical codec core would nd data register status register data register updated status register also updated indicate operation completed although registers updated random times know status register indicates comple tion data register updated thus eliminate one random transition replacing random transition transition incoming arc related register assigning appropriate condition transition thus successfully rened model eliminate random transition goal renement eliminate many random transitions possible important note possible eliminate random transitions therefore still need method refreshing contents registers incoming random transitions figure shows rened register update dependency model adjust core new model eliminated one random transition replacing acm transactions design automation electronic systems vol 7 1 january 2002 28 lysecky vahid fig 10 rened adjust register dependencies transition equal 1 hence need modify prefetching algorithm accompany change know need prefetch md equal 1 go equal 1 write md initiated ocb renement simplies prefetching algorithm reduce power consumption 65 prefetch scheduling given update dependency model core need construct schedule prefetch cores registers bus wrappers prefetch registers figure 11 describes update dependency model prefetching heuristic using pseudo code heuristic uses update dependency model conjunction realtime prefetching create schedule prefetching cores registers following description elaborate heuristic order implement prefetching heuristic need two data struc tures rst data structure needed prefetch register heap priority queue used store registers need prefetched second need list update arcs must analyzed register prefetched read write request detected ocb using data structures next describe prefetch unit designed rst step prefetching heuristic add registers incoming random transitions prefetch register heap registers always remain heap need repeatedly prefetched order satisfy register age constraints next prefetch heuristic needs respond read write requests ocb event read request prefetch unit add outgoing arcs list arcs needed analyzed described realtime prefetching work write treated another register special age accesstime constraints ie register age constraint 0 accesstime constraint initially set innity core internal bus may currently use performing prefetch use mechanism eliminate contention described setting accesstime constraint write register 0 ensure write next action performed therefore write request handled rst copying data acm transactions design automation electronic systems vol 7 1 january 2002 prefetching improved bus wrapper performance 29 fig 11 general register model prefetching heuristic used implement pfu corresponding prefetch register setting accesstime constraint 0 adding write register prefetch register heap addition outgoing arcs added list update arcs use realtime prefetching prefetch registers according priorities assigned deadline monotonic priority assignment two registers priority assigned mechanism use priority assigned ratemonotonic priority assignment schedule prefetching according heuristic registers accesstime constraint 0 prefetched rst means write requests describe later registers updated prefetched rst note writes still take highest priority register age constraint 0 write requests registers without incoming random acm transactions design automation electronic systems vol 7 1 january 2002 transitions need prefetched prefetching heuristic next schedule registers incoming random transitions according ratemonotonic priority assignment therefore prefetch register heap sorted rst deadlinemonotonic priority assignment ratemonotonic priority assignment register prefetch made read write request detected ocb need analyze arcs update arc list transition res outgoing arcs transition added list token reaches another place set corresponding registers accesstime 0 add heap thus ensuring register prefetched soon possible order better understand prefetching heuristic look adjust core adjust one random transition connected register noticed design average needed read contents every six cycles therefore set register age constraint six cycles register accesstime constraint two indicating register must prefetched every six cycles md register age accesstime constraints two cycles go however neither age constraint accesstime constraint writeonly register note even though go writeonly register copy must maintained bus wrapper needed order analyze update dependencies prefetching algorithm monitor ocb write go register made data copied go0 write register accesstime set 0 write md register accesstime set also go equal 1 equal 1 set accesstime md 0 finally use scheduling prefetch registers needed perform write operations 66 experiments updatedependency prefetching implemented update dependency prefetching three cores namely adjust codec fifo figure 12 summarizes results three cores four possible bus wrapper congurations core bus wrapper bw bus wrapper without prefetching bw bus wrapper realtime prefetching rtpf bus wrapper update dependency prefetching model udpf rst chart figure 12 summarizes performance results three cores use update dependency prefetching method almost entirely eliminated performance penalty associated bus wrapper still slight overhead caused starting prefetch unit using realtime prefetching heuristic see although performance improvement compared bus wrapper without prefetching perform well update dependency model second chart figure 12 summarizes size results average increase size caused adding update dependency prefetching technique bus wrapper 15k gates comparison realtime prefetching resulted average increase 14k gates interesting note two acm transactions design automation electronic systems vol 7 1 january 2002 prefetching improved bus wrapper performance 31 fig 12 performance ns top size gates middle energy nj bottom approaches although quite different resulted approximately size increase stated earlier using realtime prefetching increase design complexity due need keep track current register ages however using extended approach complexity increases due added logic needed analyze update dependencies third chart figure 12 summarizes energy consumption test vectors however addition prefetching bus wrappers always strictly increase decrease energy consumption fact see adjust fifo decrease energy consumption update dependency prefetching added bus wrapper codec increase hand realtime prefetching increases energy consumption codec fifo decreases energy consumption adjust importantly compare results realtime prefetching update dependency prefetching notice update dependency prefetching results signicantly less energy consumption easily explained fact approach prefetches registers updated whereas realtime prefetching prefetch registers often keep uptodate possible therefore eliminating need prefetch registers within register age constraints reduce energy consumption 7 conclusions keeping cores interface internal behavior separated key cores marketability demonstrated use bus wrappers nonpvci pvci results size power performance overhead thus retargetability advantages standard seem come penalties introduced prefetching technique overcome performance head demonstrated common cases register combinations prefetching eliminates performance degradation expense acceptable increases size power overcoming performance degradation associated bus wrappers prefetching thus improves usefulness cores provided powerful solution problem mapping problem realtime processscheduling domain applying heuristics analysis techniques domain also provided general register update dependency model used construct efcient prefetching schedule conjunction realtime prefetching demonstrated effectiveness solutions several experiments showing good performance improvements acceptable size energy increases furthermore demonstrated using update dependency model able better prefetch registers compared realtime prefetching methodology two approaches thus complementarythe realtime approach used register constraints provided modelbased approach paper used register update information also provided 8 future work although prefetching works well many possibilities improve ments current approach assume registers core prefetched however cores large numbers registers approach feasible thus considering restricting number registers appear bus wrapper creates new cachelike issues mapping replacement coherency issues present current design addition evaluate effects prefetching larger core examples another direction involves developing prefetching heuristics optimize given cost function performance power size r interface cosynthesis techniques embedded systems fast prototyping system design java driven codesign prototyping networked embedded systems new direction computer architecture research description simulation hard waresoftware systems java interface design corebased systems inventra core library computer architecture introduction rapid silicon prototyping hardwaresoftware codesign embedded systemsonachip ics association year1999year international technology roadmap semiconductors case con objectoriented communication library hardwaresoftware codesign experiences system level design consumer ics constructing applicationspecic heterogeneous embedded architectures custom hwsw applications virtual socket interface association virtual socket interface association virtual socket interface association accepted may tr computer architecture quantitative approach realtime systems programming languages interface cosynthesis techniques embedded systems constructing applicationspecific heterogeneous embedded architectures custom hwsw applications interfacebased design case configureandexecute paradigm fast prototyping java driven codesign prototyping networked embedded systems scheduling algorithms multiprogramming hardrealtime environment new direction computer architecture research interface design corebased systems objectoriented communication library hardwaresoftware codesign busbased communication synthesis systemlevel ctr ken batcher robert walker cluster miss prediction instruction caches embedded networking applications proceedings 14th acm great lakes symposium vlsi april 2628 2004 boston usa minas dasygenis erik brockmeyer bart durinck francky catthoor dimitrios soudris antonios thanailakis combined dma applicationspecific prefetching approach tackling memory latency bottleneck ieee transactions large scale integration vlsi systems v14 n3 p279291 march 2006
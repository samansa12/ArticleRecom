contracts higherorder functions assertions play important role construction robust software use programming languages dates back 1970s eiffel objectoriented programming language wholeheartedly adopted assertions developed design contract philosophy indeed entire objectoriented community recognizes value assertionbased contracts methodsin contrast languages higherorder functions support assertionbased contracts predicates functions general undecidable specifying predicates appears meaningless instead functional languages community developed type systems statically approximate interesting predicatesin paper show support higherorder function contracts theoretically wellfounded practically viable manner specifically introduce con typed lambda calculus assertions higherorder functions calculus models assertion monitoring system employ drscheme establish basic properties model type soundness etc illustrate usefulness contract checking examples drschemes code basewe believe development assertion system higherorder functions serves two purposes one hand system strong practical potential existing type systems simply cannot express many assertions programmers would like state hand inspection large base invariants may provide inspiration direction practical future type system research b paper show support higherorder function contracts theoretically wellfounded practically viable man ner specifically introduce lcon typed lambda calculus assertions higherorder functions calculus models assertion monitoring system employ drscheme establish basic properties model type soundness etc illustrate usefulness contract checking examples drschemes code base believe development assertion system higherorder functions serves two purposes one hand system strong practical potential existing type systems simply cannot express many assertions programmers would like state hand inspection large base invariants may provide inspiration direction practical future type system research categories subject descriptors d33 d21 general terms de sign languages reliability keywords contracts higherorder func tions behavioral specifications predicate typing software reliabilitywork partly conducted rice university houston tx address 92002 university chicago 1100 e 58th street chicago il 60637 permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copies bear notice full citation first page copy otherwise republish post servers redistribute lists requires prior specific permission andor fee icfp02 october 46 2002 pittsburgh pennsylvania usa dynamically enforced pre postcondition contracts widely used procedural objectoriented languages 11 14 17 20 21 22 25 31 rosenblum 27 shown example contracts great practical value improving robustness systems procedural languages eiffel 22 even developed entire philosophy system design based contracts design contract although java 12 support contracts one requested extensions1 one exception higherorder languages mostly ignored assertionstyle contracts exception bigloo scheme 28 programmers write firstorder typelike constraints procedures constraints used generate efficient code compiler prove correct turned runtime checks compiler cannot prove correct firstorder procedural contracts simple interpretation consider contract written mllike syntax val rec states argument f must int greater 9 f produces int 0 99 enforce contract contract compiler inserts code check x proper range f called fs result proper range f returns x proper range fs caller blamed contractual violation symmetrically fs result proper range blame falls f world detecting contractual violations assigning blame merely means checking appropriate predicates welldefined points programs evaluation simple mechanism checking contracts generalize languages higherorder functions consider contract val rec contracts domain states g accepts int int functions must apply ints larger 9 turn functions must produce ints 0 99 contracts range obliges g produce ints 0 99httpdeveloperjavasuncomdeveloperbugparadetop25rfeshtml although g may given f whose contract matches gs domain contract g also accept functions stricter contracts val rec gh functions without explicit contracts gl x 50 functions process external data read val rec read read nth entry file gread num functions whose behavior depends context val rec dual purpose l x predicate global state 50 else 5000 long context properly established g applies argument clearly algorithm statically determine whether proc matches contract even possible dynamically check contract g applied even worse enough monitor applications proc occur gs body g may pass proc another function store global variable additionally higherorder functions complicate blame assignment firstorder functions blame assignment directly linked pre postcondition violations precondition violation fault caller postcondition violation fault callee higherorder world however promises obligations tangled complex manner mostly due functionvalued arguments paper present contract system higherorder world key observation contract checker cannot ensure gs argument meets contract g called instead must wait proc applied point ensure procs argument greater 9 similarly proc returns ensure procs result range 0 99 enforcing contracts manner ensures contract violation signaled soon contract checker establish contract indeed violated contract checker provides firstorder value witness contract violation additionally witness enables contract checker properly assign blame contract violation guilty party next section introduces subtleties assigning blame higherorder contract violations series examples scheme 8 16 section 3 presents lcon typed higherorder functional programming language contracts section 4 speci fies meaning lcon section 5 provides implementation section 6 contains type soundness result proves implementation section 5 matches calculus section 7 shows extend calculus function contracts whose range depends input function section 8 discusses interactions contracts tail recursion example contracts begin presentation series scheme examples explain contracts written useful check first examples illustrate syntax basic principles contract checking sections 22 23 discuss problems contract checking higherorder world section 24 explains important contracts firstclass values section 25 demonstrates contracts help callbacks common use higherorder functions stateful world illustrate points section also includes examples drscheme 5 code base 21 contracts first look first example sqrt function number number definecontract sqrt l l following tradition design programs 3 sqrt function proceeded mllike 23 type specification comment like schemes define definecontract expression consists variable expression initial value function case addition second subterm definecontract specifies contract variable contracts either simple predicates function contracts function contracts turn consist pair contracts either predicate another function contract one domain function one range function domain portion sqrts contract requires always receives nonnegative number similarly range portion contract guarantees result nonnegative example also illustrates general contracts check certain aspects functions behavior rather complete semantics function contract position definition arbitrary expression evaluates contract allows us clarify contract sqrt defining biggerthanzero predicate using definition sqrts contract define biggerthanzero l x x 0 number number definecontract sqrt biggerthanzero biggerthanzero l contract sqrt strengthened relating sqrts result argument dependent function contract constructor allows programmer specify range contracts depend value functions argument constructor similar except range position contract simply contract instead function accepts argument original function returns contract module preferences schemecontract provide addpanel opendialog definecontract addpanel l newchild let children send send newchild getparent eq car children newchild l makepanel set makepanels cons makepanel makepanels define makepanels null define opendialog l let instantiate dialog sp instantiate singlepanel parent children map callmakepanel sp makepanels define callmakepanel l sp l makepanel makepanel sp figure 1 contract specified addpanel example dependent contract sqrt number number definecontract sqrt biggerthanzero l x l biggerthanzero res abs x res res l contract addition stating result sqrt positive also guarantees square result within 001 argument 22 enforcement firstorder types key checking higherorder assertion contracts postpone contract enforcement function receives firstorder value argument produces firstorder value result section demonstrates delays necessary discusses ramifications delaying contracts consider toy module module delayed schemecontract provide save use define saved l x 50 definecontract save biggerthanzero biggerthanzero l f set saved f use integer integer define use module preferences scheme provide addpanel opendialog define addpanel l makepanel set makepanels cons makepanel makepanels define makepanels null define opendialog l let instantiate dialog sp instantiate singlepanel parent children map callmakepanel sp makepanels define callmakepanel l sp l makepanel let newchild makepanel sp children send send newchild getparent unless eq car children newchild contracterror makepanel newchild figure 2 contract manually distributed biggerthanzero biggerthanzero l n saved n module 8 9 declaration consists name module language module written provide declaration series definitions module provides save use variable saved holds function map positive numbers positive numbers since exported module contract getter use setter save two visible accessors saved function save stores new function use invokes saved function naturally impossible save detect value saved always applied positive numbers since cannot determine every argument use worse save cannot guarantee time saveds value applied return positive result thus contract checker delays enforcement saves contract saves argument actually applied returns accordingly violations saves contract might detected use called general higherorder contract checker must able track contracts evaluation point contract established call site save discovery contract violation return site use potentially much later eval uation assign blame contract checker must also able report violation discovered contract established toy example clearly contrived underlying phe nomenon however common practical example consider drschemes preferences panel drschemes plugins add additional panels preferences dialog end plugins register callbacks add new panels containing gui controls buttons listboxes popup menus etc preferences dialog bool bool define makec op l x l op x number number bool define c makec define c makec bool define eqc makec eq define equalc makec equal bool define l x figure 3 abstraction predicate contracts every gui control needs two values parent callback invoked control manipulated gui controls need additional controlspecific values label list choices order add new preference panels extensions define function accepts parent panel creates subpanel parent panel fills subpanel controls configure extension returns subpanel functions registered calling addpanel time user opens drschemes preferences dialog drscheme constructs preferences dialog registered functions figure 1 shows definition addpanel contract boxed figure contract requires addpanels arguments functions accept single argument addition contract guarantees result call addpanels argument panel first child parent panel together checks ensure order panels preferences dialog matches order calls addpanel body addpanel saves panel making function list later user opens preferences dialog opendialog function called calls makepanel functions contracts checked dialog singlepanel classes part primitive gui library instantiate creates instances comparison figure 2 contains checking code written higherorder contract checking boxed portion figure excluding inner box contract checking code code enforces contracts comingled code implements preferences dialog comingling two decreases readability contract callmakepanel since client programmers need determine portion code concerns contract checking performs functions work addition author preferences module must find every callsite higherorder function finding sites general impossible practice call sites often collaborators code whose source might available 23 blame contravariance assigning blame contractual violations world firstclass functions complex boundaries cooperating components obscure world firstorder func tions addition invoking components exported functions one component may invoke function passed another component applying firstclass functions corresponds flow values components accordingly blame corresponding contract violation must lie supplier bad value matter bad value passed directly applying exported function applying firstclass function firstorder function contract checking two parties involved contract function caller unlike first order function contract checking general rule applies blame assignment rule based number times base contract appears left arrow higherorder contract base contract appears even number times function responsible establishing contract appears odd number times functions caller responsible evenodd rule captures party supplies values corresponds standard notions covariance even positions contravariance odd positions consider abstract example introduction little detail imagine body g call f 0 definecontract g l f f 0 point g invokes f greaterthannine portion gs contract fails according evenodd rule must gs fault fact g supply bad value g must blamed imagine variation example g applies f 10 instead 0 imagine f returns 10 violation result portion gs arguments contract following evenodd rule fault lies gs caller accordingly contract enforcement mechanism must track even odd positions contract determine guilty party contract violations problem assigning blame naturally appears contracts drschemes implementation example drscheme creates separate thread evaluate users programs typically extensions drscheme need initialize threadspecific hidden state users program run accessors mutators state implicitly accept current thread parameter code initializes state must run users thread2 enable drschemes extensions run code users thread drscheme provides primitive runonuserthread accepts thunk queues thunk run users thread returns contract promises argument thunk ap plied current thread users thread definecontract runonuserthread l thunk contract higherorder function contract one interesting aspect precondition function passed run onuserthread covariant even position function contract according rule blame assignment means runonuserthread responsible establishing contractthis state available users program accessors mutators lexically available users program module preferences schemecontract provide addpanel preferencesaddpanel panel panel void definecontract addpanel l sp let prechildren copyspine send sp getchildren l newchild let postchildren send sp getchildren length postchildren add1 length prechildren andmap eq cdr postchildren prechildren eq car postchildren newchild l makepanel set makepanels cons makepanel makepanels define copyspine l map l x x l figure 4 preferences panel contract protecting panel therefore runonuserthread contractually promises clients function thunks supply applied users thread thunks initialize users threads state 24 firstclass contracts experience drscheme shown certain patterns contracts recur frequently abstract patterns contracts must values passed functions exam ple curried comparision operators common see figure 3 interestingly patterns higherorder function contracts also common example drschemes code manipulates mixins 7 10 values mixins functions accept class returns class derived argument since extensions drscheme supply mixins drscheme important verify mixins result truly derived input since contract common defined drschemes contract library contract define mixincontract res arg contract dependent contract states input function class result subclass input common contracts mixins guarantee base class passed mixin class class implements particular interface support contracts drschemes contract library provides function constructs contract interface class class contract define mixincontractintf l interface l arg l res subclass res arg mixincontractintf function accepts interface argument produces contract similar mixincontract except contract guarantees input function class implements given interface although mixin contract principle checkable type system type system currently implemented ocaml 18 19 26 oml 26 rich enough express mixins typechecking fails interesting use mixins 7 since type system allow subsumption imported classes contract example expressiveness contracts leads opportunity improve existing type systems hopefully example encourage type system designers build richer type systems support practical mixins 25 callbacks stateful contracts callbacks notorious causing problems preserving invari ants szyperski 32 shows callbacks important cause problems short code invokes callback must guarantee certain state modified dynamic extent callback typically invariant maintained examining state callback invoked comparing state callback returns3 consider simple library registering invoking callbacks module callbacks schemecontract provide registercallback invokecallback definecontract registercallback l arg let oldstate save relevant state l compare new state old state l c set callback c define invokecallback l define callback l void function registercallback accepts callback function registers current callback invokecallback function calls callback contract registercallback makes use dependent contract constructor new way contract checker applies dependent contract original functions arguments function applied therefore range portion dependent contract determine key aspects state save closure resulting predicate predicate called result function compare current version state original version state thus ensuring callback wellbehaved technique useful contract drschemes preferences panel whose contract already considered consider revision addpanels contract figure 4 revision morein practice lock variables often used technique presented adapts lockvariable based solution callback problem core syntax n e aop e e rop e ee hde tle mte e e else e true false str e e contracte flatpe prede dome rnge blamee aa ab types list int bool string contract evaluation contexts val rec x e val rec val rec e val rec e e else e dome rnge prede flatpe blamee values figure 5 lcon syntax types evaluation contexts values ensure new child first child addition guarantees original children preferences panel remain panel order thus preventing extension removing preference panels 3 contract calculus although contracts guarantee stronger properties types program execution guarantees hold particular program executions contrast type checkers weaker guarantees hold program executions contracts types play synergistic roles program development maintenance practical programming languages must support spirit calculus contains types contracts show interact figure 5 contains syntax contract calculus program consists series definitions followed single expres sion definition consists variable contract expression expression initializing variable variables bound val rec single program must distinct n1 n1 l xe v ex v fix xe ex fix xe p contains val rec x true e1 else e2 e1 false e1 else e2 e2 true true domv1 v2 v1 figure 6 reduction semantics lcon definitions mutually recursive except contract positions may refer defined variables appear earlier program expressions e include abstractions applications variables fix points numbers numeric primitives lists list primitives expressions booleans strings final expression forms specify contracts contracte e e expressions construct flat function contracts respectively flatp expression returns true argument flat contract false argument function contract pred dom rng expressions select fields contract blame primitive used assign blame definition violates contract aborts program first model omits dependent contracts return later types lcon core ml without polymorphism plus types contract expressions typing rules contracts given figure 7 first typing rule complete programs programs type record types written first types types definitions last type type final expression contracts flat values tagged contract value constructor must predicates operate appropriate type contracts functions consist two contracts one domain contract g g val rec xi string contract g l x list list list list list g list g list g e1 e2 else string figure 7 lcon type rules one range function typing rule defini tions ensures type contract matches type definition rest typing rules standard consider definition sqrt function val rec sqrt contractl xx l n body sqrt function elided contract sqrt must contract type sqrt function type domain range portions contract predicates integers sqrt consumes produces integers4 succinctly predicates contract augment sqrts type indicating domain range must positive figures 5 6 define conventional reduction semantics base language without contracts 4 4 contract monitoring explained earlier contract monitor must perform two tasks first must track higherorder functions discover contract vio lations second must properly assign blame contract viola tions end must track higherorder functions programs evaluation covariant contravariant portions contract monitor contracts add new form expression new values evaluation contexts reduction rules figure 8 contains new expression form representing obligation exx e first superscript contract expression base expression obliged meet last two variables variables enabletechnically sqrt consume produce number since lcon contains integers precise details sqrt unimportant consider restricted form sqrt operates integers contract monitoring system assign blame properly first variable names party responsible values produced expression superscript second variable names party responsible values consumes implementation would add fourth superscript representing source location contract established superscript would carried along evaluation contract violation discovered point would reported part error message model definition treated written different programmer thus definition considered separate entity purpose assigning blame implemen tation finegrained blame instead assigned coarser construct eg modulas modules mls structures functors javas packages drscheme blame modules 9 programmers write obligation expressions instead contracts extracted definitions turned obligations enforce define judgment p ok holds obligation expressions p obligations placed reference val recdefined vari able first part obligation definitions contract ex pression first variable initially name referenced definition second variable initially name defini tion reference occurs main reference occurs last expression function defined accompanying technical report 6 specifies precisely insert obligations expressions introduction obligation expressions induces extension set evaluation contexts shown figure 8 specify value superscript obligation expression determined base value additionally obligation expression induces new type rule type rule guarantees obligation appropriate contract base expression obligation expressions obligation type rule contract obligation evaluation contexts obligation values obligation reductions figure 8 monitoring contracts lcon finally add class labeled values labels function obligations see figure 8 although grammar allows value labeled function contract type soundness theorem coupled type rule obligation expressions guarantees delayed values always functions functions wrapped additional obligations reductions figure 6 superscripted evaluation proceeds like original evaluation except superscript carried instruction result two additional ductions first predicate contract reaches flat value predicate flat value checked predicate holds contract discarded evaluation continues predicate fails execution halts definition named variable positive position superscript blamed final reduction figure 8 key contract checking higherorder functions hoc arrow stands higher order contract application superscripted procedure domain range portion function positions superscript moved argument expression entire application thus obligation maintain contract distributed argument result application obligation moves argument position application value producer value consumer exchange roles values provided function provided argument vice versa accordingly last two superscripts obligation expression must reversed ensures blame properly assigned according evenodd rule example consider definition sqrt single use main expression reduction sequence application sqrt shown left figure 10 brevity references variables defined val rec treated values even though would actually reduce variables current values first reduction example obligations distributed application domain portion superscript contract moved argument procedure range portion moved application second reduction second string string ct l x l p l n flatpct predct x x else errorp else l wrap r figure 9 contract compiler wrapping function last reduction examples flat contracts checked case predicate holds value however predicate failed second reduction step main would blamed since main supplied value sqrt predicate failed second last reduction step sqrt would blamed since sqrt produced result second example recall higherorder program introduction translated calculus val rec val rec bet0 val rec l f f 0 l x 25 definitions gt9 bet0 99 merely helper functions defining contracts need contracts although calculus allow definitions simple extension add contract checker would simply ignore accordingly variable g body main expression reference definition contract thus variable compiled obligation contract obligation gs contract even position contract met g blamed odd position contract met main blamed reduction sequence gt90 0 bet0 99maing bet0 99gmain else first reduction step obligation g distributed gs argument result application additionally variables indicating blame swapped l x 25s obligation second step substitutes l x 25 body g resulting application l x 25 0 third step distributes contract l x 25 0 result application addition variables even odd blame switch positions 0s contract fourth step reduces flat contract 0 test determines contract holds final reduction steps assign blame g supplying 0 argument since promised supply number greater 9 val rec sqrt contractl xx l n body intentionally elided sqrt 4 reductions lon contractl xx 4 contractl xx 0sqrtmain else blamemain else blamesqrt reductions compiled expression wrap contractl xx sqrt sqrt main l wrap contractl xx 0 sqrt wrap contractl xx 0 main sqrt sqrt main next steps show reductions wraps argument reduction wrap clarity sqrt wrap contractl xx 0main sqrt sqrt main sqrt l xx else blamemain sqrt main else blamesqrt figure 10 reducing sqrt lcon wrap example shows higherorder functions firstorder functions treated uniformly calculus higherorder functions merely require distribution reductions firstorder functions fact nested arrow contract expression induces distribution reduction corresponding application simplic ity focus sqrt example remainder paper 5 contract implementation implement lcon must compile away obligation expressions key compilation wrapper function figure 9 wrapper function defined calculus let expression shorthand inline applications lexpressions used clarity accepts contract value test two strings strings correspond variables superscripts write wrap metavariable stand program text figure 9 program variable compiling obligations merely matter replacing obligation expression application wrap first argument contract referenced variable second argument expression obligation final two arguments string versions variables obligation accordingly define compiler c maps programs programs replaces obligation expression corresponding application wrap formal definition given accompanying technical report 6 function wrap defined casewise one case kind contract first case handles flat contracts merely tests value matches contract blames positive position test fails second case wrap deals function con tracts builds wrapper function tests original functions argument result recursive calls wrap textually first recursive call wrap corresponds postcondition check ing applies range portion contract result original application second recursive call wrap corresponds precondition checking applies domain portion contract argument wrapper function call wrap positive negative blame positions reversed befits domain checking function righthand side figure 10 shows compiled version sqrt program reduces begins one call wrap one obligation expression original program first reduction applies wrap since contract case function contract wrap takes second case definition returns l expression next l expression applied 4 point function contract distributed sqrts argument result sqrts application like distribution reduction lcon shown left side figure 10 next reduction step another call wrap argument sqrt contract flat first case definition wrap applies result test test failed else branch would assigned blame main supplying bad value sqrt test passes however expression returns 4 next reduction step ip fh l x p ip fh vv2 v3pn ip fw l xe figure 11 evaluator functions sqrt returns 2 arrive final call wrap contract flat predicate wrap reduces expression time however test failed sqrt would blamed returning bad result final reduction test succeeds result entire program 2 6 correctness definition 61 divergence program p diverges p1 p p1 exists p2 p1 p2 although definition divergence refers use reduction relations following type soundness theorem lcon standard 34 theorem 62 type soundness lcon program p according type judgments figure 7 exactly one following holds x val rec defined variable p hd tl pred dom rng diverges proof combine preservation progress lemmas lcon lemma 63 preservation lcon 0 lemma 64 progress lcon 0 either remainder section formulates proves theorem relates evaluation programs instrumented semantics section 4 contract compiled programs section 5 relate two semantics introduce new semantics show bridges gap new semantics extension semantics given figures 5 6 addition expressions contains obligation expressions flat evaluation contexts reduction figure 8 hoc wrap new values reduction figure 8 reduction dl x ev1 v2pn wrap dl l x e yv1npv2pn free e definition 65 evaluators define fh transitive closure flat hoc define fw transitive flat wrap closure evaluator functions shown figure 11 defined programs p p ok g shorthand notation write program value equal value main expression program vp equal v lemma 66 evaluators partial functions proof inspection evaluation contexts prove unique decomposition program evaluation context instruction unless value follows evaluators partial functions theorem 67 compiler correctness proof combine lemma 68 lemma 69 proof sketch proof straightforward examination evaluation sequences e efw reduction appli flat wrap cation wrap corresponds directly either reduction otherwise evaluators proceed lockstep full proof given accompanying technical report 6 lemma 69 proof sketch proof establishes simulation efh efw simulation preserved reduction step relates values errors full proof given accompanying technical report 6 7 dependent contracts adding dependent contracts calculus straightforward reduction relation dependent function contracts naturally extends reduction relation normal function contracts reduction distributing contracts applications dif ference instead placing range portion contract obligation application range portion functions original argument placed obligation figure 12 dependent contract expressions dependent contract type rule contract dependent contract evaluation contexts dependent contract reductions figure 12 dependent function contracts lcon evaluation contexts given figure 8 dictate obligations superscript reduced value base expression par ticular order evaluation means superscripted application resulting dependent contract reduction figure 12 reduced base expression therefore procedure dependent contract examine state world function proper applied order evaluation critical callback examples section 25 8 tail recursion since contract compiler described section 5 checks post conditions preserve tail recursion 2 30 procedures postconditions typically determining procedure call tail recursive simple syntactic test presence higherorder contracts however understanding exactly calls tailcalls complex task example consider program val rec val l g g 3 f l x x1 body f tail position respect conventional inter preter hence tailcall optimizing compiler optimize call g allocate additional stack space due contract gs result must larger 0 call g cannot optimized according semantics contract checking5 even worse since functions contracts functions without contracts comingle evaluation sometimes call function tailcall times call function call tailcall instance imagine argument f locally defined recursive function recursive calls would tailcalls since would associated toplevel variable thus contract would enforced contracts effective module boundaries serve programmer improving opportunities modular rea soning wellwritten contracts programmer study single module isolation adding functionality fixing defects addition programmer changes contract changed contract immediately indicates source files must changeat minimum compiling tailcall becomes much difficult since experience shown module boundaries typically involved tight loops conjecture losing tail recursion contract checking problem practice particular adding contracts key interfaces drscheme noticeable effect performance removing tailcall optimization entirely however would render drscheme useless presents evidence conjecture tail cursion compiler preserve tail recursion crossmodule procedure call contracts still found problem practice 29 section 341 9 conclusion higherorder typed programming language implementations 1 12 15 19 33 static type discipline prevents certain abuses languages primitive operations example programs might apply nonfunctions add nonnumbers invoke methods nonobjects statically rejected yet languages go runtime systems dynamically prevent additional abuses language primitives example primitive array indexing operation aborts receives bounds index division operation aborts receives zero divi sor together two techniques dramatically improve quality software built languages advent module languages support type abstraction 13 18 24 programmers empowered enforce abstractions type level abstractions expressive power language designer used specifying languages primitives dynamic part invariant en forcement however become secondclass citizen programmer must manually insert dynamic checks blame assigned automatically checks fail even worse discussed section 2 always possible programmer insert checks manually call sites may unavailable modules paper presents first assertionbased contract checker languages higherorder functions contract checker enables programmers refine typespecifications abstractions additional dynamically enforced invariants illustrate complexities higherorder contract checking series examples chosen drschemes codebase examples serve two purposes first illustrate subtleties contract checking languages higherorder functions second demonstrate current static checking techniques expressive enough support contracts underlying drscheme believe experience assertions reveal contracts biggest impact software quality hope information turn helps focus typesystem research practical directions acknowledgments thanks thomas herchenroder michael vanier anonymous icfp reviews comments paper would like send special thanks icfp reviewer 3 whose careful analysis insightful comments paper renewed faith conference reviewing process r att bell labratories proper tail recursion space efficiency design programs revised report syntactic theories sequential control state contracts higherorder 26 functions modular objectoriented programming units mixins plt mzscheme language manual want programmers reduction semantics classes mixins language manual sather 11 javatm language turing programming lan guage manifest types objective caml system programming specifications monographs computer science overview anna specification language ada language definition standard abstract types existential technique software module specification communications acm extension ml principles programming languages practical approach programming ieee transactions software engineering bigloo practical scheme compiler bee integrated development environment scheme programming language debunking mit artificial intelligence laboratory introduction component software ghc team syntactic approach type first appeared technical report tr160 tr abstract types existential type turing programming language eiffel language revised report syntactic theories sequential control state eiffel manifest types modules separate compilation typetheoretic approach higherorder modules sharing syntactic approach type soundness practical approach programming assertions objective ml proper tail recursion space efficiency modular objectoriented programming units mixins revisedsupscrpt5supscrpt report algorithmic language scheme technique software module specification examples programming specifications java language specification definition standard ml composable compilable macros programmers reduction semantics classes mixins drscheme debunking myampersandldquoexpensive procedure callmyampersandrdquo myth procedure call implementations considered harmful lambda ctr frances perry limin jia david walker expressing heapshape contracts linear logic proceedings 5th international conference generative programming component engineering october 2226 2006 portland oregon usa dana n xu extended static checking haskell proceedings 2006 acm sigplan workshop haskell september 1717 2006 portland oregon usa philippe meunier robert bruce findler matthias felleisen modular setbased analysis contracts acm sigplan notices v41 n1 p218231 january 2006 matthias blume david mcallester sound complete model contracts acm sigplan notices v39 n9 september 2004 matthias blume david mcallester sound complete models contracts journal functional programming v16 n45 p375414 july 2006 dale vaillancourt rex page matthias felleisen acl2 drscheme proceedings sixth international workshop acl2 theorem prover applications august 1516 2006 seattle washington tobinhochstadt matthias felleisen interlanguage migration scripts programs companion 21st acm sigplan conference objectoriented programming systems languages applications october 2226 2006 portland oregon usa kathryn e gray robert bruce findler matthew flatt finegrained interoperability mirrors contracts acm sigplan notices v40 n10 october 2005 january 2006 jacob matthews robert bruce findler operational semantics multilanguage programs acm sigplan notices v42 n1 january 2007 nick benton embedded interpreters journal functional programming v15 n4 p503542 july 2005
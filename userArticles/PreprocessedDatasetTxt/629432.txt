unified architecture computation bspline curves surfaces abstractbsplines general nonuniform rational bsplines nurbs particular become indispensable modeling primitives computer graphics geometric modeling applications paper novel highperformance architecture computation uniform nonuniform rational nonrational bspline curves surfaces presented architecture derived sequence steps first systolic architecture computation basis function values basis function evaluation array bfea developed using bfea core architecture computation nurbs curves constructed architecture extended compute nurbs surfaces finally architecture augmented compute surface normals output architecture directly used rendering nurbs surfacethe overall linear structure architecture small io requirements nondependence size problem terms number control points number points curvesurface computed high throughput make architecture highly suitable integration standard graphics pipeline highend workstations results timing analysis indicate potential throughput one triangle normal vectors vertices every two clock cycles b introduction explosive growth computer graphics last two decades greatly facilitated impressive hardware innovations raster graphics became popular due emergence lowcost semiconductor memories frame buffer graphics coprocessors graphics display controllers designed goal offloading graphics computation cpu resulted widespread availability quality graphics cards personal computers geometry engine 3 ushered era highperformance graphics workstations successive generations workstations exploited increasing levels pipelining parallelism graphics pipeline see example reality engine 1 graphics applications however constantly increased requirements continuously beyond reach available hardware capabilities evolution complex graphics abstractions made available main processor starting simple lines current highend systems support antialiased zbuffered gourardshaded 24 bits color per pixel triangles hardware believe next step evolution migration parametric curves surfaces hardware example trend recent microcode implementation nonuniform rational bsplines nurbs graphics workstation 6 paper present unified architecture computation various types bspline curves surfaces believe architecture significant following factors ffl first solution handle types bspline curves surfaces ffl architecture capable high performance one triangle normals vertices every two clock cycles ffl architecture linear structure minimizes number pins required vlsi implementation ffl architecture independent size curvepatch terms number control points well number points curvepatch computed ffl three features make architecture highly suitable integration graphics pipeline highend workstations focusing bsplines rather many parametric curves surfaces described literature since nurbs emerged modeling primitive choice geometric design community nonuniform rational bspline curves surfaces initial graphics exchange specification iges standard since 1983 14 many commercial inhouse modeling applications like geomod proengineer based rational bspline representations popularity rational bsplines due following facts ffl provide one common mathematical form accurate representation standard analytic shapes especially conics well freeform curves surfaces thus unification forms curves surfaces done nurbs ffl offer extra degree freedom form weights apart knot vector control points used designing wide variety shapes ffl projection invariant projection curve achieved projecting control points suitably modifying weights control points introduction rational quadratic representation conics found 15 information nurbs representation circles 2124 hardware implementations bsplines reported literature one early papers direction work tli et al16 architecture generate bezier curves patches proposed de rose 7 et al proposed triangular architecture generate bspline curves using deboorcox algorithm mathias 17 developed similar architecture bezier curves using de casteljau algorithm also developed architectures bspline inversion bspline generation 18 recently megson 19 come design calculate basis functions required generate bsplines also developed composite design calculate bspline patches architectures presented literature following limitations seriously restrict practical implementation ffl size hardware tied size problem number control points solved ffl large number io pins needed architecture proposed paper overcomes limitations addition pointed earlier provides unified highperformance solution computation bspline curves surfaces next section fundamentals bsplines explained properties types bsplines well computation requirements outlined section efficient algorithm compute basis functions hardware implementation presented section 3 using figure 1 bspline curve basis function calculating architecture unified architecture calculate uniformnon uniform rationalnonrational bspline curves surfaces presented section 4 finally architecture presented work compared similar solutions proposed literature shown superior time space efficiency 2 theory bsplines bspline curve defined parameter u following equation curve drawn various values u varying umin umax typically 1 point curve parametric value u denoted p u points denoted p control points points object space using shape bspline curve controlled geometric modeling applications position control points changed achieve required shape curve curve need pass control points though bspline curves always lie within convex hull control points typical bspline curve shown figure 1 basis function blending function denoted n ik u basis functions decide extent particular control point controls curve particular parametric value u parameter k called order one degree curve cubic curve basis function n ik u depends parametric value order curve recursively defined follows figure 2 bspline surface constants called knot values specific instances parametric value u strictly nondecreasing order n knot values put together called knot vector section 21 see knot vector properties basis functions properties basis functions bsplines discussed detail 22 reading bsplines 2420 23 suggested extension bspline curve bspline surface given p u v point surface parametric values u v grid n points denoted p ij basis functions u v directions denoted n ik u n jl v variables k l denote orders surface direction u v respectively bicubic patch shows bicubic bspline patch rational bspline curve normalized result 3d 4d nonrational bspline curve defined 4d control points rational bspline curve defined formula term w denotes weight 3d control point p term w n ik u denotes extent control point p control curve w tends infinity curve pulled towards p w zero control point p influence curve detailed study rational bspline carried first versprille 26 details rational bsplines found 22 24 25 rational bspline surface defined formula term w ij n ik un jl v denotes extent influence control patch grid n points surface every control point associated weight control point 21 basis functions control points section point interesting aspects basis functions control points properties used later paper basis functions dependent knot vector describe knot vector detail let parameter u vary 0 1 let knot vector 00 01 013 03 035 035 035 04 06 07 09 10 let order curve k 4 cubic curve basis function curves knot vector order shown figure 3 shown figure knot values specific instances u varies minimum value maximum value note knot values repeated given example 035 basis function control point p 0 namely n 04 nonzero values u 035 values u basis function remain zero basis function n 14 nonzero values u 1 5 general basis function n ik nonzero values u ik shown particular value u valid range k k basis functions nonzero values 8 valid range u kgamma1 n1 example valid range 03 basis functions nonzero values value u consideration called useful basis functions use concept useful basis functions later section reduce computational complexity bsplines impose various restrictions knot vector restrictions give raise various kinds bsplines knot vector resultant bspline called uniform bspline 8 typical uniform knot vector would 00 01 02 03 delta delta delta 09 10 see differences adjacent knot values equal uniform bspline basis function curves identical figure 4 hence enough calculate basis function curve thus reducing complexity 04 44 74 value figure 3 basis function curves nonuniform knot vector bspline computation large extent taking advantage fact vlsi architecture solve uniform bspline curves proposed 10 unified architecture compute uniform rationalnonrational bspline curvespatches also proposed 11 uniform knot vector first last knot values repeated k times resultant knot vector called open knot vector forces curve start first control point end last control point knot vector conform two conditions called nonuniform knot vector bspline called nonuniform bspline example given beginning section nonuniform knot vector unlike uniform bsplines basis function values bspline nonuniform knot vector computed every value parameter rationalized bspline curves surfaces nonuniform knot vector called nurbs nonuniform rational bspline curves surfaces described knot vectors types bspline curves surfaces proceed analyze properties basis functions clear equations bspline curves surfaces basis function value nonzero corresponding control point controls n 04 n 14 n 24 n 34 n 44 n 54 n 64 figure 4 basis function curves uniform knot vector shape curve k useful basis functions value u discussed earlier k control points contribute computation curve control points called active control points case bspline surface grid k theta l active control points know useful basis functions particular value u compute basis function values compute point curve basis functions corresponding control points need considered hence complexity computation curve dependent k order curve n number control points curve noted approximations used bringing complexity ok instead careful study basis functions led elimination useless computations naive computation scheme problem boils finding useful basis functions given value u use fact knot values strictly nondecreasing order value u thus clearly sandwiched pair consecutive knot values important observation used unfolding recursion basis function computation observation leads conclusion one first order basis function value 1 rest value 0 k useful kth order basis functions n igammak1k n igammak2k delta delta delta n ik using first subscript useful basis functions active control points also found example lies 06 useful basis functions n 44 n 54 n 64 n 74 nonzero value thus active control points p 4 p 5 index incremented current useful basis functions active control points found similarly surface order k l k l useful basis functions particular values u v respectively grid k theta l active control points found using method 3 vlsi architecture basis function generation computation bspline curve surface basis function computation plays important role seen equation 3 basis function computation recursive apparently calls calculation one point curve requires values hence total number calls basis function routine would n 1 using discussion preceding section k useful basis functions number calls reduces two problems using recursive equation 3 computation basis functions first computation k basis functions many lower order functions return zero observation shows computations eliminated second multiple knots denominator equation 3 may become zero certain calls basis function routine n i1 n i11 n i21 n i2 n i12 leading division errors two difficulties overcome using following method 45 computes basis function values including lower order basis functions nonzero value algorithm unfolds recursion identifies directed acyclic graph dag basis functions nonzero values dag sorted topological order would give order computation basis function values eliminates two difficulties discussion previous section know given value u one basis function order one nonzero one find one nondecreasing order figure 5 see nonzero first order basis function k kth order basis functions calculated multiplicative factor along edges given inset whenever two edges meet addition performed get basis function value meeting jm jm jm ut figure 5 basis function computation graph controller figure basis function evaluation array bfea controller node method every computation indispensable denominator become zero follows method used develop new systolic architecture computation basis functions 31 systolic computation basis function figure 6 shows systolic linear array computation basis function controller pumps required input computation basis functions first cell basis function evaluation array bfea design bfea input pattern explained cell bfea computes one level dag shown figure 5 first level one element n i1 u involves computation value always one value pumped controller first cell bfea starting second level one processing element assigned job computing one level dag hence required processing elements 1th cell bfea k basis functions order k output figure 5 method computing basis functions explained previous section clear first cell requires knot pair second cell requires one pair k gamma 1th cell requires apart used preceding cells knot pair last cell receives outputs blending function values hence one dummy pair input make number input output quantities dummy pair follow path knot pairs since linear architecture data required cells downstream passed controller cells upstream thus ith processing cell performs computation steps work communicate knot values cells downstream thus total work cell k k gamma 1th cell output one useful basis function value every clock cycle initial pipeline fill thus whole process computation communication proceeds systolically linear architecture next section elaborates issues involved designing cell basis function evaluation array 32 design cell bfea one cell bfea functional units shown figure 7 present mathematics behind design core components cell one cell bfea say j sequence receiving knot pairs hardware requirements cell greatly reduced identifying symmetry calculation basis functions suitably modifying algorithm done following ways know let us consider computation n ik equation 8 first term rhs equation 8 decomposed follows delay element ut ut figure 7 one processing cell basis function evaluation array 1 seen second term rhs equation 11 second term equation 7 first term equation 11 computed prior n ik thus make use precomputed values get first term equation 8 one mathematical operation instead four similarly first term rhs equation 9 calculated using second term rhs equation 8 subtractor adder subtractor unit figure 7 computes equation 11 equation 8 computed adder 2 communicate ik u calculate require two subtractors ik gamma u sent instead ik sent instead two subtractors reduced one adder separate line required communicate parametric value u avoided data dependency analysis computation basis functions seen cell requires minimum five stages observations faithfully implemented processing cell design rest cell derived directly equation basis function computation input various processing cells different time units shown figure 8 figure shows input various cells calculating k basis function values two different values u row gives data specific point space various time intervals column shows data distribution space specific time instant figure 8 three data inputs cell one three inputs bfea first row input line marked n ij u figure 7 second third row corresponds two inputs marked figure 7 respectively entry second third rows give indices knots example entry second row refers input entry third row refers input u pattern input first cell various time instances shown figure 9 pattern seen figure 8 4 time 1 7 input time 5 11 input j note first order basis function 1 particular clock cycle indices zero times input first cell also includes igammak1 ik used dummy inputs 33 time required basis function generation assume sake simplicity throughout paper functional units take equal amount time namely one time unit cell delay five time units time interval first input knot value generation corresponding basis function value order k first term gives time taken pumping basis function order 1 second term gives delay involved first output time required get k outputs order cell second bfea cell three inputs 10th time step two different parametric values u2 time chart compute two sets fourth order basis u2 j1fourth order basis functions u1fourth order basis functions u2 figure 8 input scheduling various processing cells bfea figure 9 pattern input first cell bfea figure 8 shows input pattern computation two sets basis functions order succession case true computation bspline curves bspline surface calculated orders different directions parametric value u v need different orders output taken two different cells bfea case input timed way ensure data output line bfea corrupted two basis function values seen figure 8 four useful basis functions output u1 time 19 22 immediately followed second set basis functions thus one useful basis function output every clock cycle best achieve linear architecture one output line bfea forms core nurbs architecture optimizations adopted design direct impact design final architecture example computing k nonzero useful basis functions whereas solution proposed megson 19 computes n1 basis functions k n time required generate curvesurface drastically reduced fact apart making architecture independent number control points n also renders time taken compute curvesurface independent n 4 vlsi architecture nurbs curves surfaces describe section bfea effectively deployed compute curves surfaces general form bspline nonuniform rational bspline 41 nurbs curve computation nurbs curve computation given basis function evaluation array controller cell accumulating values knot functions basis points curve tofrom host curve control points figure 10 architecture computation nurbs curve architecture proposed computation shown figure 10 seen previous section bfea gives one useful basis function value every clock cycle initial setup time numerator denominator equation 14 calculated simultaneously multiplying useful basis function values separately summing results independently accumulating cell ac control points p active control points w corresponding weights finally division performed within ac point curve calculated product p w performed beforehand called weighted control point weighted control points w pumped controller ac synchronizing basis functions input calculate next point curve parametric value u incremented input bfea changed appropriately whenever u crosses i1 index incremented new set active weighted control points weights sent ac process continues points curve computed 42 time required calculate nurbs curve seen equation 13 time required calculate basis functions involved ac calculating x coordinate five time units hence time required generate x coordinate first point subsequent clock cycles z coordinates output x coordinate second point curve output k clock cycles x coordinate first point c points calculated curve time x coordinate last point output subsequent clock cycles z coordinates last coordinate also output hence total time required calculate whole curve note equation independent number control points n 43 nurbs surface computation architecture curve computation easily extended compute nurbs surfaces section 3 started argument time taken compute basis function dominant factor computation curve surface compared inner product operation however section see inner product computation speeded cope output rate bfea would also obvious end paper inner product computation cannot speeded arbitrarily thus making attempts improve basis function computation useless equation 6 rewritten follows terms inside parenthesis numerator denominator called virtual control points weights virtual control points respectively equation viewed basis functions pumped vcca k1 pts ctrl basis functions pumped ac p0406control points pumped vcca pac pumped ac vcca virtual control points point surface calculated ac l k control pts 0k 1k 2k 3k 4k 5k 6k 0l 1l 2l 3l 4l 5l 6l 7l figure 11 algorithm surface generation equation nurbs curve virtual control points weights playing role control points weights hence architecture presented initially computes virtual control points weights values used nurbs curve architecture compute nurbs surface architecture calculate nurbs surface shown figure 12 nurbs surface two orders associated k direction u l direction v extending arguments presented section 2 clear given value parameters u v k theta l active control points correspond nonzero basis function values entities involved computation one point surface shown figure 11 grid k theta l active control points loaded columns l values shown vertical rectangular boxes figure 11 partial accumulating cells pacs virtual control point calculating array vcca bfea used compute basis function values parametric values initially kth order useful basis function values direction calculated pumped vcca figure 13 bfea name implies vcca computes virtual control points weights vcca computes virtual control points taking dot product row k active weighted control points shown horizontal dotted boxes figure 11 corresponding basis function values control pts tofrom host values knot functions basis surface virtual control pts calculating array basis function evaluation array controller virtual control accumulating cell points points surfacecurve curve control points figure 12 architecture computation nurbs surface points control virtual controller points control surface ac bfea virtual control points v jl figure 13 virtual control point calculating array virtual control points weights computed problem calculating nurbs surface boils problem computing nurbs curve ac instead getting curve control points controller gets virtual control points vcca control points lth order basis functions directly bfea ac calculates point surface points surface computed column column column points isoparametric curve surface constant value u discrete values v u constant particular column basis functions along u computed stored pacs reused active control point grid found every uv pair weighted control points computed grid sent vcca virtual control point computation lth order basis functions new value v calculated bfea basis functions virtual control points taken ac next point surface generated process continues discrete values v considered isoparametric curve particular value u computed value v reset initial value u incremented new set basis functions u computed stored internal registers pac vcca algorithm continues discrete values u considered note although every point surface requires computation k l basis function values direction u v k basis function values computed every new value u values stored used whole curve drawn particular value u values v 44 time required calculate nurbs patch time required generate nurbs patch calculated respect input bfea basis functions different orders say k l computed one delay fi introduced input bfea ensure output line bfea corrupted two basis function values following table shows values fi delay output experienced various conditions condition delay delay input fi output second set basis functions immediately follows first set synchronization problem ac virtual control points second set basis functions fact basis functions computed earlier inner product computation hence additional delay ff introduced input bfea value ff shown one k l zero otherwise shows performance system depends inner product computation computation basis functions let us assume c u represents number discrete values u c v number discrete values v thus c u isoparametric curves constant u c v points computed curve time required pump input bfea last point surface would isoparametric curve computation requires k inputs kth order basis function generation followed delay ff times l inputs generation basis functions order l first term gives time compute c u curves second term delay introduced computation curves delay introduced c calculation whole surface two terms put together would give total time taken input including last point surface get time input computation last point starts l subtracted quantity time 6 time taken calculate last point given 7l results hence total time required calculate whole surface seen equation independent number control points n 45 computation normals nurbs surface standard graphics pipeline primitives like triangles pumped vertices normal vector required normal vectors used lighting calculations section extends architecture include computation surface normals also thus nurbs surface tessellated triangles actual normal vectors vertices triangle computed using architecture calculate normal nurbs surface point p tangent vector curve respect v point v 0 computed tangent vector curve p u v 0 respect u point u computed cross product two quantities would give normal vector surface point p clearly equation nurbs surface tangent vector calculation would involve computation first derivative basis functions 451 computation basis function derivatives seen equation basis function equation 2 derivative first order basis function zero sum basis function values particular parametric value one sum derivatives zero derivative basis function given new basis function evaluation cell calculates derivatives basis functions also shown figure 14 452 computation tangent vectors derivative point nurbs surface constant u u 0 respect v given jl v jl v ut delay element figure 14 modified bfea cell derivative point constant v v 0 respect u given w ik u x ik u seen x w virtual control points weights respectively quantities computed vcca form equations w u x u w x quantities also computed vcca figure 15 shows modified vcca accommodate computation x u w u contains additional array pacs derivative basis function given input pac arrays given set control points result x w calculated first pac array values x u w u computed second array four values pumped three accumulating cells shown figure 16 accumulating cells similar ac described earlier without functional unit division cells four values values surface control points array array figure 15 modified vcca n jl v n 0 jl v bfea compute quantities required calculate point surface tangent vectors tangent vectors calculated cross product computed complete process output point normal synchronized introducing delays path point calculating point 3d nurbs curve concept normal center ac three used controller send weighted control points performance loss due incorporation normal calculating hardware meager delay introduced path point around ten insignificant whole surface computed thousands clock cycles hence performance practically architecture computation point alone 46 controller controller pumps required data appropriate time various functional units controller divided various functional modules shown figure 17 detailed design various modules controller presented 9 normal surface point calculate calculate calculate ac ac ac jl bfea wn v bfea jl jl jl jl jl xn v u jl jl wn v figure computation surface points normal vectors performance evaluation architecture presented decouples size problem extent possible every computationresult computed bfea indispensable equation 21 clear coefficient c u large making timing dependent c u c v hence proposed architecture performs well number discrete values u less number discrete values v architecture performs better whole curve surface calculated discrete points needed algorithm makes complete use interdependency information sharing consecutive points curvesurface thus architecture outputs one triangle every two clock cycles initial pipeline fill compare performance architecture architecture proposed megson 19 c u c v proportional n time required computation curvesurface increases linearly using architecture proposed ac vcca bfea tofrom host storage interface unit unit control controller unit control ac unit control bfea control unit u figure 17 controller paper computation every point curvesurface dependent n time required megsons architecture increases quadratically seen figure 18 figure 19 analyzing hardware complexity architecture proposed megson requires 5maxk l3maxm n1 inner product cell equivalents 3m1n ffi 2 memory registers surfaces points blending functions degrees k l lj architecture presented paper requires utmost 7maxk l product cell equivalents maxk l theta 5 4maxk l buffer registers 4kl memory registers seen processing element requirements memory requirements much less megsons architecture note hardware requirements specified architecture computation nurbs whereas megsons architecture computation nonrational bsplines number clock cycles number control points architecture megsons architecture figure curve computation comparison number control points number control points number clock cycles megsons architecture architecture figure 19 surface computation comparison 6 summary unified architecture computation bspline curves surfaces presented architecture called unified architecture since compute uniform nonuniform rational nonrational bspline curves surfaces considered computations necessary nurbs description compute nonrational curve control point weights set unity compute uniform curve change necessary since uniform knot vector special case general knot vector unified architecture derived sequence steps first systolic architecture computation basis function values bfea developed using bfea core architecture computation nonuniform rational bspline curves constructed architecture extended compute nurbs surfaces introducing concept virtual control points reducing computation surface computation sequence curves finally architecture augmented compute surface normals output architecture directly used rendering nurbs surface overall linear structure architecture small number data paths required architecture nondependence architecture size problem terms number control points number points curvesurface computed high throughput architecture make highly suitable integration standard graphics pipeline highend workstations results timing analysis indicate potential performance one triangle every two clock cycles normal vectors vertices also shown bfea considerably better earlier solution basis function computation 19 improvements basis function computation immediately warranted since seen section 44 bfea slowed introduction delay output utilized inner product computation units improvement inner product computation part cannot done without compromising linear structure architecture hence improvements require use multiple linear arrays configurations conclude pointing first complete hardware solution computation nurbs curves surfaces r reality engine graphics introduction use splines computer graphics geometry engine practical guide splines package calculating splines system cost effective 3d shaded graphics triangle multiprocessor architecture fast curve surface generation computer graphics principles practice2nd edition special purpose architectures bsplines vlsi architectures computation uniform bspline curves parallel architecture computation uniform rational bspline patches vlsi architecture computation nurbs patches direct manipulation freeform deformations rational quadratic bezier representation conics vlsi systolic architectures computer graphics systolic architectures realistic 3d graphics systolic architecture curve generation systolic algorithms bspline patch generation geometric modeling use infinite control points cagd computer aided geometric design curve surface constructions using rational bsplines applications bspline approximation geometric problems computer aided design rational bsplines curve surface representation geometric modeling using nonuniform rational bsplines mathematical techniques tr
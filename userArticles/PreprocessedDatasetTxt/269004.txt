compositional refinement interactive systems introduce method describe systems components functional specification techniques define notions interface interaction refinement interactive systems components notions refinement allow us change syntactic number channels sorts messages channels semantic interface causality flow messages interaction granularity interactive system component prove notions refinement compositional respect sequential parallel composition system components communication feedback recursive declarations system components according proofs refinements networks accomplished modular way refining compponents generalize notions refinement refining contexts finally full abstraction specifications defined compositionality respect abstraction shown b introduction distributed interactive system consists family interacting components reducing complexity development distributed interactive systems developed number successive development steps step system described detail closer implementation level speak levels abstraction stepwise refinement system development describing behavior system components logical specification techniques simple concept stepwise refinement logical implication system component specification refinement component specification exhibits specified properties possibly fact refinement allows replacement system specifications refined ones exhibiting specific properties sophisticated notions refinement allow refine system component one exhibiting quite different properties original one case however need concept relating behaviors refined system component behaviors original one behaviors refined system component understood represent behaviors original one behavior interactive system components basically given interaction environment therefore refinement system components basically deal refinement interaction notion interaction refinement introduced following concepts refinement software systems investigated since early 1970s one origins refinement concepts data structure refinement treated hoares pioneering paper hoare 72 ideas data structure refinement given explored developed see instance jones 86 broy et al 86 sannella 88 see coenen et al 91 survey also idea refining interacting systems treated numerous papers see instance lamport 83 abadi lamport 90 back 90 typically distributed interactive systems composed number components interact instance exchanging messages updating shared memory forms composition allow compose systems smaller ones basic forms composition systems parallel sequential composition communication feedback recursion set forms composition method specifying system components called compositional sometimes also word modular used specification composed systems derived specifications constituent components call refinement concept compositional refinements composed system obtained giving refinements components traditionally compositional notions specification refinement concurrent systems considered hard obtain instance elegant approach chandy misra 88 compositional respect liveness properties provide compositional notion refinement note makes sense talk compositionality respect set forms composi tion forms composition system components define algebra systems also called process algebra approaches system specifications emphasise forms composition systems instance state machine oriented system specifications systems modelled state transitions particular forms composition system components used consequence compositionality rated less significant approaches favor describing systems using forms composition called algebraic discussion advantages disadvantages algebraic versus nonalgebraic approaches found instance janssen et al 91 finding compositional specification methods compositional interaction refinement concepts considered difficult issue compositional refinement seems especially difficult achieve programming languages tightly coupled parallelism case rendezvous concept like ccs csp tightly coupled parallelism actions directly used synchronization parallel activities therefore granularity actions cannot refined general without changing synchronization structure see instance aceto hennessy 91 vogler 91 presentation compositional notion refinement granularity interaction refined overall objective following sections use functional purely descriptive nonoperational specification techniques behavior distributed systems interacting communication channels represented functions processing streams messages streams messages represent communication histories channels system component specifications predicates characterizing sets stream processing functions system components described way composed decomposed using mentioned forms composition sequential parallel composition well communication feedback forms composition kinds finite data processing nets described allowing addition recursive declarations even infinite data processing nets described following concepts refinement interactive system components defined allow one change number channels component well granularity messages sent particular basic theorems proved show introduced notion refinement compositional basic compositional forms well recursive declara tions accordingly arbitrary net interacting components refinement schematically obtained giving refinements components correctness refinement follows according proved theorems schematically correctness proofs refinements components give examples illustrating compositionality refinement deliberately chosen simple examples keep specifications small concentrate refinement aspects simplicity examples mean much complex examples cannot treated finally generalize notion refinement refining contexts refining contexts allow refinements components refined presentation input history may depend output history allows particular understand unreliable components refinements reliable components long refining context takes care unreliability refining contexts represented predicate transformers special properties give examples refining contexts appendix full abstraction functional specifications considered composing forms treated specification section introduce basic notions functional system models functional system specifications following study system components exchange messages asynchronously via channels stream represents communication history channel stream messages given message set finite infinite sequence messages define briefly repeat basic concepts theory streams shall use later comprehensive explanations found broy 90 ffl x denote result concatenating two streams x assume x ffl hi denote empty stream ffl stream x prefix stream write x v relation v called prefix order formally specified ffl n denote tuples n streams prefix ordering streams well concatenation streams extended tuples streams elementwise application tuple finite streams represents partial communication history tuple channels tuple infinite streams represents total communication history tuple channels behavior deterministic interactive systems n input channels output channels modeled n mary stream processing functions stream processing function determines output history given communication history input channels terms tuples streams example 1 stream processing function let set data elements given let set messages specified symbol signal representing request data elements stream processing function specified function cd describes behavior simple storage cell store exactly one data element initially stored behavior component modeled cd illustrated example input function cd simple example stream processing function every input message triggers exactly one output message end example following use notions domain fixed point theory briefly listed ffl stream processing function called prefix monotonic tuples streams denote function application fx fx avoid brackets ffl ts denote least upper bound set exists ffl set called directed pair elements x exists upper bound x ffl partially ordered set called complete every directed subset least upper bound ffl stream processing function f called prefix continuous f prefix monotonic every directed set set streams well set tuples streams complete every directed set streams exists least upper bound model behavior interactive system components sets continuous therefore definition also monotonic stream processing functions monotonicity models causality input output continuity models fact every behavior systems reaction infinite input predicted components reactions finite prefixes input 1 monotonicity takes care fact interactive system output already produced cannot changed input arrives empty stream seen representing information communication unspecified note example preimposed monotonicity function cd conclude otherwise could construct contradiction specification describes set stream processing functions represent behaviors specified systems set empty specification called inconsistent otherwise called consistent set contains exactly one element specification called determined set one element specification called underdetermined also speak underspecification shall see underdetermined specification may refined determined one underdetermined specification also used describe hardware software units nondeterministic executable system called nondeterministic underdetermined underspecification description behaviors nondeterministic system allows nondeterministic choices carried execution system descriptive modeling interactive systems difference principle underspecification und operational notion nondeter minism particular make difference framework whether nondeterministic choices taken execution starts step step execution set nmary prefix continuous stream processing functions denoted number sorts input channels well output channels specification called components syntactic interface behavior represented set functions fulfill specification called components semantic interface semantic interface includes particular granularity interaction causality input output simplicity consider specific sort information individual channels components following assume set messages however results carry straightforwardly stream processing functions specific sorts attached individual channels exclude specification elaborate liveness properties including fairness note fairness general property fair choices infinite number behaviors figure 1 graphical representation component q specification possibly underdetermined interactive system component n input channels output channels modeled predicate characterizing prefix continuous stream processing functions q called n mary systems specification graphical representation n mary system component q given figure 1 set specifications form denoted example 2 specification component called c storage cell one input channel one output channel specified predicate c component c seen simple store store exactly one data element c specifies functions f functionality let sets specified example 1 c receives data element sends copy output channels receives request represented signal repeats last data output followed signal indicate repeated output signal way used indicating read storage content request signal triggers read operation data element input stream changes content store message triggers write operation initially cell carries arbitrary data element behavior formalized following specification c auxiliary function cd specified example 1 notice data element stored initially specified thus component c underdetermined end example deterministic specification q exactly one function q predicate q fulfilled words often write misuse notation simply q instead q way identify determined specifications behaviors denote identity function assume shall drop index whenever avoided without confusion denote function produces every input empty stream output output channels define similarly write unique function spf words function input channels output channels l n denote logically weakest specification specification fulfilled stream processing functions defined n upsilon denote function produces two copies input 2n upsilon nm denote function permutes input streams shall drop index n well upsilon whenever avoided without confusion composition section introduce basic forms composition namely sequential composition parallel composition feedback compositional forms introduced functions first extended component specifications 31 composition functions given functions write sequential composition functions f g yields function spf n given functions write fkg parallel composition functions f g yields function assume higher priority k given function write f feedback output streams function f input channels yields function spf n fix denotes fixed point operator associating monotonic function f least fixed point fixf thus means respect prefix ordering least solution equation assume higher priority binary operators k graphical representation feedback given figure 2 obtain number useful rules fixed point definition f simple consequence fixed point characterization get unfold rules graphical representation unfold rules feedback given figure 3 f figure 2 graphical representation feedback f f f f f figure 3 graphical representation unfold rules feedback f figure 4 graphical representation semiunfold useful rule feedback semiunfold allows one move components outside inside feedback loop let g 2 spf graphical representation semiunfold given figure 4 reasoning feedback loops fixed points following special case semiunfold often useful rule instance semiunfold correctness rule also seen following argument least fixed point e least fixed point e semiunfold powerful rule reasoning results feedback loops 32 composition specifications want compose specifications components networks forms composition introduced functions extended component specifications straightforward way given component specifications write predicate spec n trivially specifications q 2 spec n following equations given specifications write qkr predicate spec n1n2 m1m2 given specification write predicate spec n feedback underdetermined specifications get following rules 2 determined system specifications q get stronger rules hold underdetermined systems general erroneous assumption rules valid also underdetermined systems source merge anomaly see brock ackermann 81 useful rule feedback fusion allows one move components affected feedback outside inside feedback operator application help basic functions forms composition introduced far represent kinds finite networks systems data flow nets 3 introduced composing forms lead algebra system descriptions 4 refinement representation abstraction section introduce concepts refinement system components respect properties behaviors well respect syntactic interface granularity interaction start defining straightforward notion property refinement system component specifications introduce notion refinement communication histories based notion define concept interaction refinement interactive components notion allows refine component changing number input output channels well granularity exchanged messages 41 property refinement specifications predicates characterizing functions leads simple notion refinement component specifications adding logical properties given specifications e q called property refinement q f 2 spf n e write e e q property refinement q e q properties q may every behavior e q shows also possible behavior q 3 course introduced combinatorial style defining networks always useful practice since combinatorial formulas hard read however prefer throughout report work combinatorial formulas since puts emphasis compositional forms structure composition practical purposesa notation named channels often adequate considered composing forms monotonic refinement relation indicated following theorem theorem 1 compositionality refinement proof straightforward since operators specifications defined pointwise sets functions specified 2 simple example property refinement obtained component c described example 2 page 8 add properties data element initially stored cell property refinement allow one change syntactic interface component however 42 interaction refinement recall section 2 streams model communication histories channels sophisticated development steps component number channels sorts messages channels changed steps represent property refinements therefore introduce general notion refinement able study concepts representation communication histories n channels modeled tuple n streams communication histories channels modeled tuple streams tuples streams seen representations tuples streams introduce mapping ae 2 spf n associates every x representation ae called representation function ae injective called definite representation function note mapping ae injective specification r 2 spec n used specification set representation functions r called representation specification example 3 representation specification specify representation specification r allowing representation streams data elements requests two separate streams one carries requests carries data elements representation functions mappings ae following functionality p used separator signal understood time tick separates messages given streams x let x denote pair streams elementwise concatenation pairs streams words let icks defined set pairs streams ticks equal specify representation specification r explicitly follows note monotonicity specified functions computation representation illustrated following example example demonstrates time ticks used indicate streams aex order requests relatively data messages original stream x end example elements images functions ae rae called representations representation specification representation specification r called definite words r definite different streams x always differently represented obviously r definite representation specification functions ae rae definite definite representation specifications elements x x x 6 x sets representation elements disjoint note representation specification given example definite every injective function thus every definite representation function ae exists function ff 2 spf n function ff inverse ae image ae function ff called abstraction ae notice ff uniquely determined long ae surjective words long elements used representations elements n may several functions ff aff concept abstractions definite representation functions extended definite representation specifications definite representation specification function ff 2 spf n called abstraction function r existence abstractions follows definition definite representation specification definite representation specifications abstraction functions ff uniquely determined image r union images functions ae rae definition 3 abstraction definite representation specification n specification called abstraction r consistent definite representation specifications r abstraction ae contains possible choices representation functions abstraction example 4 abstraction representation specification r described example 3 abstraction functions ff mappings functionality specification reads follows straightforward rewriting proof indeed specification shows considerable amount underspecification since pairs streams f used representations end example parallel sequential composition definite representations leads definite representations theorem 2 let r definite representation specifications assuming second formula definite representation specifications proof sequential parallel composition injective functions leads injective functions 2 trivially obtain abstractions composed representations composing abstractions many applications representation specifications neither required determined even definite indefinite representation specification sets representation elements different elements necessarily disjoint certain representation elements occur several sets representations elements ambiguously stand represent different elements element may represent streams x well x aex aex functions ae ae rae rae indefinite representation specifications represented elements uniquely determined representation elements representation element stands set definite representation specification r set contains exactly one element indefinite representation specification r set may contain one element latter case course abstraction functions ff exist however even certain indefinite representations introduce concept abstraction definition 4 uniform representation specifications consistent specification called uniform representation specification exists specification 2 spec n ae specification called abstraction r formula expresses r leftneutral element every representation function r essentially existence abstraction expresses following property r different elements x x representations possible every representation function maps elements onto equal representations formally stated exist functions e ae ae reae rae e functions ae rae thus elements identified representation functions identification present representation functions amount information forgotten representations representation functions indefinite uniform way definite representations always uniform function injective x x function injective ae defines nontrivial partition domain representation specification uniform functions ae rae define partition uniform representation specification r abstraction product r reflects underspecification choices representations provided r function fl r afl representations definition 5 adequate representation uniform representation specification r abstraction called adequate specification q adequacy means underspecification r introduce underspecification q r already present q note definite representations adequate specifications q definition 6 interaction refinement given representations r 2 spec n specifications b say b q interaction refinement q representation specifications r r r r figure 5 commuting diagram interaction refinement definition indicates replace via interaction refinement system form q r refined system form r b q may think relationship q b q follows specification q specifies component abstract level q 0 gives specification component concrete level instead computing abstract level q translating output via r onto output representation level may translate input r onto input representation level compute b q obtain one famous commuting diagrams shown figure 5 definition 7 adequate interaction refinement interaction refinement q representation specifications r r called adequate specification q r adequate q adequate interaction refinements using uniform representation specifications r abstraction 2 spec since interaction refinement property get adequacy r q shows r b q property refinement q graphical illustration adequate interaction refinement shown figure 6 r figure commuting diagram interaction refinement following table summarizes important definitions introduced far table definitions e property refinement q e r consistent definite abstr r r uniform abstraction rae r r adequate q abs q r q inter refinement b q q r r r b adequate inter refinement r uniform adequate q notion interaction refinement allows one change syntactic semantic interface syntactic interface determined number sorts channels semantic interface determined behavior component represented causality input output granularity interaction example 5 interaction refinement refine component c given example 2 component b c instead one input one output channel two input two output channels refinement b c uses one channels carrying signal read channel one channels carrying data write channel let r given specified examples specify interaction refinement b c c explicitly b c specifies functions functionality specify auxiliary function h specified straightforward proof show assume ae rae h exist f b cf prove induction length stream x exist e ae reae cd specified example 1 aecdx obtain exists 2 icks e e aecdx assume hypothesis holds x exists 2 icks exists 2 icks concludes proof finite streams x continuity h ae proof extended infinite x end example continuing system development adequate interaction refinement component may decide leave r unchanged carry refining b q 5 compositionality interaction refinement large nets interacting components constructed introduced forms composition refining large nets decisive keeping work manageable interaction refinements components lead interaction refinements composed system following prove interaction refinement indeed compositional introduced composing forms sequential parallel composition communication feedback 51 sequential parallel composition systems composed sequential compositions refinements constructed refining components theorem 3 compositionality refinement seq composition assume interaction refinement q representations r igamma1 r interaction refinement q representations r 0 r 2 proof straightforward derivation shows theorem interaction refinement q 1 g interaction refinement q 2 g example 6 compositionality refinement sequential composition let c b c specified example course may compose c well b c sequentially define components cc cc note cc cell repeats last input twice signal straightforward application theorem compositionality refinement cc refinement cc course since r also r cca property refinement cc end example refinement compositional parallel composition theorem 4 compositionality refinement parallel composition assume b interaction refinement q representations r r interaction refinement q 1 kq 2 representations proof straightforward derivation shows theorem r sequential parallel compositiong r interaction refinement sequential parallel compositiong r 1 kr 2 sequential parallel composition compositionality refinement quite straightforward seen simplicity proofs 52 feedback feedback operator refinement immediately compositional obtain general b q interaction refinement q representations r r provided b q interaction refinement q representations rkr r true however r see reason follows feedback loops b q cannot sure representations streams ie streams images functions characterized r occur therefore give slightly complicated scheme refinement feedback theorem 5 compositionality refinement feedback assume b q interaction refinement q representation specifications rkr r r uniform ika r b q interaction refinement q representations r r proof prove r ika r b r ika r b conclude exist functions ae b q ae ff rae b qbq rae aff furthermore q interaction refinement q representations rkr r functions ae rae ae rae q b qq exist functions q e ae qq reae hold furthermore ae given x continuity ae b q ae ff may define ikff ae b qaex tby moreover continuity q may define aeqx ae ty prove e ae computational induction prove induction following proposition aey least elementg e fy 0 least elementg e fy 0 least elementg fdefinition b assume proposition holds obtain fdefinition b finduction hypothesisg e fdefinition e aey furthermore get e fdefinition e finduction hypothesisg fdefinition b i2 g b i2 conclude continuity e ae thus finally qassuming adequate refinement allows us obtain immediately following corollary theorem 6 compositionality adequate refinement feedback assume q adequate interaction refinement q representations rkr r abstraction b q r interaction refinement q representations r r proof let definitions proof previous theorem since interaction refinement assumed adequate exists function e qq carrying proof previous theorem e q instead q ae instead e ae get straightforward computational induction may prove concludes proof 2 assuming r contains identity refinement simplify refinement feedback loops theorem 7 assume b q interaction refinement q representations rkr r abstraction assume furthermore r q interaction refinement q representations r r proof straightforward deduction shows q rnote even refinement r words even r hold refinements r may used simplify refine term r ika r b q fusion rule feedback introduced section 3 obtain may allow refinements b example 7 compositionality refinement feedback let us introduce component f two input channels one output channel specifies functions following functionality f specified follows auxiliary function g specified straightforward proof specification c defined example 1 carry proof induction length input streams x show f fulfills defining equations functions cd definition c example 2 let f function ff g function specified definition f consider two cases definition f exists g defined exists induction length x continuity function g conclude proof refinement b f f according representation specification r example 3 specifies functions functionality reads follows auxiliary function g specified proved straightforward rewrite proof moreover according theorem 5 therefore note refinement definite therefore adequate f therefore may replace ika r b f b component b refined refining r let us therefore look simplification r r since monotonicity ff aff otherwise obtain contradiction since monotonicity first elements ffx coincide x therefore ae rae indicates functions ae ff rae aff valid x therefore cannot simply refine r continue refinement refining p take account properties b f simple rewriting proof shows summarizing refinements obtain concludes example refinement feedback end example recall every finite network represented expression built introduced forms composition theorems show network refined defining representation specifications channels refining components provides modular method refinement networks 6 recursively defined specifications often behavior interactive components specified recursion given function recursive declaration component specification q given declaration based recursive specifications restricted following functions exhibit certain properties 61 semantics recursively defined specifications function monotonic respect implication set specifications called chain 2 functions f 2 spf n function continuous respect implication every chain note set specifications forms complete lattice definition 8 predicate transformer predicate transformer func tion monotonic continuous respect implication refinement note defined netx finite network composed basic component specifications introduced forms composition predicate transformer recursive declaration component specification q given defining equation often called fixed point equation based predicate transformer predicate q called fixed point general function exist several predicates q fixed points fixed point theory partial order domain established every monotonic function least fixed point fixed point associated identifier f recursive declaration form defining semantics programming languages choice ordering determines notion least fixed point take account operational considerations ordering used fixed point construction reflect stepwise approximation result execution specifications operational constraints less significant therefore choose liberal interpretation recursive declarations specifications following define concept upper closure specification upper closure predicate transformer defined following equation notice xi classical closure operator since following characteristic properties predicate q called upward closed xi least elementomega mapped onto specification l fulfilled every function methodological point view sufficient restrict attention specifications upward closed 4 methodological consideration considerable simplification formal interpretation recursive declarations reasons considering upward closed solutions recursive equations predicate transformer called upward closed predicates q recursive declaration 4 taking upper closure specification may change safety properties however safety properties behaviors may changed output independent input empty system behavior produce specific message output channel even increase streams messages input channels output produced channel obviously relevant associate q predicate fulfills following equation predicates q specified according definition associate recursive declaration logically weakest 5 predicate q predicate q denoted fix 62 refinement recursively specified components uniform representation specification r abstraction called adequate predicate transformer predicates x adequacy implies specifications r adequate mapped onto specifications r adequate uniform interaction refinement compositional recursive definitions based predicate transformers refinement adequate definite representations always adequate theorem 8 compositionality refinement recursion let representation specifications r r given r uniform abstraction adequate predicate transformer predicate transformer predicates x b r b 5 true considered weaker false proof without loss generality assume predicate transformers upward closed define prove proposition obtained straightforward induction proof show trivially true since l holds functions induction step reads follows conclude adequacy fdefinition q induction hypothesisg fdefinition q prove induction prove part premises assume induction hypothesis holds trivially therefore premise induction hypothesis fact seen derivation obtain representations r premise always valid following straightforward derivation shows fdefinition lg immediately obtain following theorem corollary useful simplifying refinement recursion theorem 9 given premisses theorem addition r proof theorem proved straightforward deduction even refinement r even r hold refinements r may used simplify term r specification example 8 compositionality refinement recursion course instead giving feedback loop example 7 may also define infinite network recursively 6 obtain straightforward proof along lines proof also straightforward proof show r b f therefore compositionality results r replaced refinement shown end example using recursion may define even infinite nets theorem shows refinement infinite net described recursive equation obtained refinement components net 7 predicate transformers refinements far considered refinement components refining one hand tuples input hand tuples output streams general notion refinement obtained considering predicate transformers refinements definition 9 refining context predicate transformer 6 predicate transformer obtained unfold rule feedback called refining context exists mapping called abstracting context predicates x refining contexts used define quite general notion refinement refinement refining contexts let r refining context abstracting context specification b q called refinement abstracting context specification q note rq refinement specification q abstracting context refining contexts may defined compositional forms introduced previous sections example 9 refining contexts component specifications one input channel two output channels define predicate transformer 1by equation component p specifies functions graphical representation ay given figure 7 let p specified component specification x one input channel one output channel define predicate transformer component q specifies functions ay figure 7 graphical representation ay let q specified stand finite stream length k containing copies message show r define refining context show equivalent showing specifications x equivalent equivalent formula shown proof based specifications p q let stand 2 ky stand function yki 1 functions p q pp qq exists k 2 8i 2 k shown straightforward proof induction obtain furthermore obtain induction length x continuity involved functions proposition proved end example context refinement indeed generalization interaction refinement given two pairs definite representation abstraction specifications r r refining context abstracting context defined since refining contexts lead general notion refinement interaction refinement specifications q b q exist consistent specifications r may exist refining contexts r refining contexts may support usage sophisticated feedback loops refined system refining context way dependency representation input history output history achieved qbhe figure 8 graphical representation masterslave system general form refining context obtained special operator forming networks called masterslave systems notational convenience introduce special notation masterslave systems graphical representation masterslave systems given figure 8 masterslave system denoted qbhe consists two components q h called master kn slave h 2 spec n qbhe 2 spec input slave comes via master output slave goes master masterslave system defined follows readable notation 8x define refining context abstracting context based mas terslave system concept look predicate transformers abstracting context specifications v 2 spec im kn w 2 spec nk mi refining context abstracting context specified follows z figure 9 graphical representation cooperator following requirement fulfilled give analysis requirement based form composition called cooperator cooperator denoted specifications mk cooperator defined follows mm graphical presentation cooperator given figure 9 straightforward rewriting shows cooperator indeed generalization masterslave h 2 spec k particular obtain therefore condition reads follows following theorem gives analysis component w theorem 10 implication implies recall swaps input streams proof definition cooperation may conclude every function every function wi v every f xf exists function e f x e f fx formula true specifications x therefore also definite specifications formula holds functions f addition f obtain constant function f z fx x z equation therefore simplifies prove formula conclude proof contradiction assume exists x x 6 z choose function f fx 6 fz concludes proof theorem 2 concept refining contexts may consider refined system qbw bv bheee refinement refined network continued refining v bhe leaving environment qbw bee remarkable relationship masterslave systems system structures studied relyguarantee specification techniques advocated among others abadi lamport 90 master seen environment slave system indicates masterslave situation models general form composition every net subnet h understood masterslave system qbhe q denotes surrounding net environment h form networks generalized cooperator composing form contrast masterslave systems situation fully symmetric cooperating components q q q seen mutual environments concept cooperation general notion composing form components composing forms considered far special cases cooperation k obtain let net n given set gamma components every partition gamma two disjoint sets components leads partition net two disjoint subnets say q q net equal q number channels n leading q q k denotes number channels leading q q subnets refined independently 8 conclusion notion compositional refinement depends operators composing forms considered composing system compositionality goal per se helpful performing global refinements local refinements refining contexts master slave systems cooperator additional help structuring restructuring system allowing local refinements previous sections demonstrated using functional techniques compositional notion interaction refinement achieved refinement components large net mechanically transformed refinement entire net throughout paper notions refinement treated expressed continuous representation abstraction functions much along lines cip 84 broy et al 86 considered important methodological simplification abstraction representation functions used level specified functions interesting examples refinement however representation functions monotonic see representation functions obtained introduction time broy 90 compositional treatment refinement feedback loops cases remains open problem acknowledgement work carried stay digital equipment corporation systems research center excellent working environment stimulating discussions colleagues src particular jim horning leslie lamport martin abadi gratefully acknowledged thank claus dendorfer leslie lamport cynthia hibbard careful reading version manuscript useful comments appendix full abstraction looking functional specifications one may realize sometimes specify properties one might interested one may observe considered compositional forms basically interested two observations given specification q function f qf input streams x first one straightforward interested output streams addition controlling behavior components especially within feedback loops interested causality given finite prefix e x considered input streams x causality input respect output determines much output monotonicity f prefix guaranteed f technically may represent behavior system component observations system represented pairs chains input corresponding output streams set fx called chain 2 given specification q 2 spec n pair chains called observation q exists function f qf behavior system component specified q represented observations q unfortunately exist functional specifications show set observations nevertheless characterize different sets functions example refer broy 90 fortunately functional specifications mapped easily onto functional specifications set specified functions exactly one characterized set observations reason introduce predicate transformer maps specification abstract counterpart predicate transformer basically constructs given predicate q predicate deltaq fulfilled exactly continuous functions obtained combination graphs functions set functions specified q define definition obtain immediately monotonicity closure property predicate transformer delta theorem 11 closure property predicate transformer delta proof straightforward since qf occurs positively definition deltaq specification q called fully abstract may redefine compositional forms operators deliver always fully abstract specifications results obtained far carry abstract view monotonicity delta fact furthermore given upward closed predicate transformer q least solution deltaq least solution proof straightforward note concept abstraction may obtain cases r hold allows additional simplifications network refinements note full abstraction relative notion determined basic concept observability composing forms presence refinement unclear whether full abstraction defined appropriate however component q used twice network q general determined refinements e q deltaq exist determined refinements b q q therefore using sophisticated forms refinement introduced notion full abstraction might always adequate r adding action refinement finite process algebra composing specifications refinement calculus refinement calculus stepwise refinement distributed systems scenarios model nondeterminate computation algebraic implementations preserve program correctness functional specification time sensitive communicating systems algebraic methods program construc tion project cip parallel program design foundation assertional data reification proofs survey perspective action systems action refinement development parallel systems algebraic approach specifying concurrent program modules proofs correctness data repre sentations systematic program development using vdm survey formal software development methods bisimulation action refinement tr algebraic implementations preserve program correctness systematic software development using vdm parallel program design foundation refinement calculus part sequential nondeterministic programs refinement calculus part ii parallel reactive programs functional specification time sensitive communicating systems logical view composition refinement adding action refinement finite process algebra bisimulation action refinement composing specifications specifying concurrent program modules scenarios ctr bernhard thalheim component development construction database design data knowledge engineering v54 n1 p7795 july 2005 manfred broy objectoriented programming software development critical assessment programming methodology springerverlag new york inc new york ny bernhard thalheim database component ware proceedings fourteenth australasian database conference p1326 february 01 2003 adelaide australia antje dsterhft bernhard thalheim linguistic based search facilities snowflakelike database schemes data knowledge engineering v48 n2 p177198 february 2004 einar broch johnsen christoph lth abstracting refinements transformation nordic journal computing v10 n4 p313336 december manfred broy toward mathematical foundation software engineering methods ieee transactions software engineering v27 n1 p4257 january 2001 rimvydas rukenas rigorous environment development concurrent systems nordic journal computing v11 n2 p165193 summer 2004 marco antonio barbosa refinement calculus software components architectures acm sigsoft software engineering notes v30 n5 september 2005
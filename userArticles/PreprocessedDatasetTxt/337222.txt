lightweight context recovery efficient accurate program analyses compute accurate information efficiently programs use pointer variables program analysis must account fact procedure may access different sets memory locations procedure invoked different callsites paper presents lightweight context recovery technique efficiently determine whether memory location accessed procedure specific callsite paper also presents technique uses information improve precision efficiency program analyses empirical studies show 1 lightweight context recovery quite precise identifying memory locations accessed procedure specific callsite 2 distinguishing memory locations accessed procedure different callsites significantly improve precision efficiency program analyses programs use pointer variables b introduction software development testing maintenance activities important expensive thus researchers investigated ways provide software tools improve eciency thus reduce cost activities many tools require program analyses extract information program exam ple tools debugging program understanding impact analysis use program slicing eg 5 6 15 focus attention parts software influence particular statement support software engineering tools eectively program analysis must suciently ecient tools reasonable response time acceptable throughput program analysis must suciently precise useful information hidden within spurious information 1 int x 2 fint p 3 4 5 f1int q 6 int 7 fz 8 fq 9 10 int 11 main 12 int 13 14 15 f1y 17 printfdw 18 figure 1 example program many program analyses eectively compute program information programs use pointer variables however applying techniques programs use pointer variables several issues must considered first programs use pointer vari ables two dierent names may reference memory location program point example program figure 1 pointer dereference p variable name reference memory location statement 3 phenomenon called aliasing must considered computing safe program formation example without considering eects aliasing program analysis would ignore fact referenced p statement 3 thus conclude incorrectly procedure f modify second programs use pointer variables procedure access dierent memory locations pointer dereferences procedure invoked dierent callsites example f accesses x called statement 8 accesses w x called statement 16 program analysis cannot distinguish memory locations accessed procedure context specific callsite might compute spurious program information callsite example program analysis might report z w modified f f called statement 8 furthermore program analysis propagates spurious program information throughout program unnecessarily inecient many existing techniques eg 2 8 12 14 compute safe program information accounting eects aliasing analysis however techniques eg 8 12 distinguish memory locations accessed procedure context specific callsites techniques use conditional analysis attaches conditions information generated program analysis example p references w statement 3 figure 1 p aliased w entry f thus program analysis reports w modified statement 3 condition determine whether w modified f statement 8 executed program analysis determines whether p aliased w entry f checking alias information statement 8 q aliased w statement 8 p aliased w entry f f invoked statement 8 thus program analysis reports w modified statement 8 executed although technique using conditional analysis distinguish memory locations accessed procedure specific callsites thus avoid computing spurious program information inecient first requires conditional alias information currently provided expensive aliasanalysis algorithms eg 7 second increase cost computing program information example without using conditional analysis complexity computing interprocedural reaching definitions 2 v n size program v number names references memory locations whereas using conditional analysis complexity compute accurate program information without using expensive conditional alias information adding complexity program analysis develop new approach two parts first examining ways memory locations accessed proce dure eciently identifies set memory locations accessed procedure specific callsite second uses set memory locations reduce spurious information propagated procedure callsite callsite procedure eciently identify memory locations accessed procedure specific callsite developed technique lightweight context recovery technique based observation context callsite formal parameter procedure typically points set memory loca tions throughout procedure actual parameter bound formal parameter pointer given memory location accessed exclusively pointer dereferences formal parameter memory location accessed procedure specific callsite memory location accessed callsite pointer dereferences actual parameter bound observation allows technique identify memory locations accessed procedure specific callsite reduce spurious information propagated across procedure boundaries program analyses also developed technique uses information memory locations computed lightweight context covery callsite program information memory location identified accessed called procedure need propagated callsite called procedure called procedure callsite thus technique improve precision eciency program analyses paper presents new first presents lightweight context recovery algorithm section 2 illustrates using interprocedural slicing 15 technique uses information provided lightweight context recovery improve program analyses section 3 main benefit approach ecient use alias information provided ecient alias analysis algorithms liang harrolds 9 andersens 1 lightweight context recovery almost ecient modification side eects analysis using information provided lightweight context recovery program analysis adds little cost program analysis second benefit approach many cases identify large number memory locations whose information need propagated specific callsites thus provide significant improvement precision eciency program analysis third benefit approach orthogonal many techniques improve eciency program analyses thus used techniques improve eciency program analyses paper also presents set empirical studies investigate eectiveness using lightweight context recovery improve eciency precision program analyses section 4 studies show number interesting results many programs studied lightweight context recovery algorithm computes relatively little increase cost significantly smaller number memory locations modified callsite computed traditional modification side eect analysis algorithm several programs using alias information provided liang harrolds algorithm 9 andersens algorithm 1 lightweight context recovery algorithm reports almost modification sideeects callsite landi ryder zhangs algorithm 8 must use conditional alias information using information provided lightweight context recovery reduce sizes slices computed using reusedriven slicing algorithm 5 time required compute slices section first gives definitions presents lightweight context recovery algorithm definitions memory locations program referenced object names object name consists variable possibly empty sequence dereferences field ac cesses object name contains dereferences object name direct object name otherwise object name indirect object name example xf direct object name whereas p indirect object name direct object name obj represents memory location refer lobj say object name n 1 extension object name constructed applying possibly empty sequence dereferences field accesses n 2 case denote n 1 en 2 refer n 2 prefix n 1 empty n 1 proper extension n 2 n 2 proper prefix n 1 n formal parameter actual parameter bound n callsite c define function c e n returns object name ea example suppose r pointer points struct field f e r r e f r rf r proper prefix r r formal parameter function f q actual parameter bound r callsite c f c e f r qf given object name obj statement alias analysis determine set memory locations may aliased obj refer set objs accessed set denote set asetobj example figure 1 asetp landi ryders algorithm 7 used given memory location loc procedure p name set loc p contains object names used reference loc p example name set f figure 1 p memory location loc supports object name obj statement value loc may used resolve dereferences obj ex ample suppose q points r r points x statement r supports q lightweight context recovery identify memory locations accessed procedure p specific callsite lightweight context recovery considers nonlocal memory locations p name set nonlocal memory location loc contains direct object name technique reports loc accessed callsite p name set loc contains single indirect object name technique computes additional information determine whether loc accessed specific callsite p cases eciency technique assumes loc accessed callsite p suppose indirect object name obj object name name set nonlocal memory location loc procedure p loc referenced p must referenced obj none memory locations supporting obj statements p modified p p executed obj references memory location point p case obj extension formal parameter p called callsite c obj must reference memory location one referenced c obj c thus loc referenced p c loc must referenced c obj c program analysis must propagate information loc p c c obj aliased loc c property memory locations gives us opportunity avoid propagating ie filter spurious information information propagated procedure callsite program analyses say loc property p loc eligible filtered callsites p say loc candidate precisely loc candidate p following conditions hold condition 1 locs name set p contains single indirect name obj condition 2 obj proper extension formal parameter p condition 3 memory locations supporting obj statements p modified p example figure 1 name set w f contains p proper extension formal parameter p value p change f thus w candidate f 16 p w need propagate information w f statement 16 however 7 p z need propagate information w f statement 7 lightweight context recovery processes procedures reverse topological bottomup order call graph 1 identify memory locations candidates procedure figure 2 shows algorithm contextrecovery performs processing nonlocal memory location loc referenced procedure contextrecovery computes mark markp loc whose value unmarked u eligible ineligible default markp loc initialized u loc candidate p markp loc case obj object name locs name set contextrecovery stores obj objp loc loc candidate p markp loc objp loc contextrecovery also sets modp loc true loc modified statement p check whether memory locations supporting object name modified p contextrecovery examines way loc accessed p calls update various points eg lines 5 algorithm contextrecoveryp input p program global markp maps memory locations procedure p marks whether memory location modified memory locations object names declare list procedures sorted reverse topological order begin contextrecovery 1 foreach procedure p intraprocedural phase 2 foreach statement p 3 foreach object name obj 4 obj direct 5 updatep lobjf 6 else 7 foreach memory location loc asetobj 8 updatep loctobj 9 endfor 10 endif 11 endfor 12 set modp memory locations modified 13 endfor 14 add p w 15 endfor 16 w interprocedural phase 17 take first procedure p w 18 foreach callsite c r p 19 foreach nonlocal memory loc referenced r 20 markr loc 21 updatep locf 22 elseif locasetac objr loc c 23 ac objr loc indirect 24 updatep loctac objr loc 25 else 26 updatep locf 27 endif 28 endif 29 update modp loc 30 endfor 31 endfor 32 validate object names objp modp 33 markp modp updated add p callers w 34 endwhile contextrecovery procedure updateqlmo input q procedure l memory location boolean object name global markq marks memory locations q array object names begin update 36 markq l objq l 38 extension formal 39 markq l objq l 40 else 41 markq l objq l 42 endif 43 elseif markq 44 oobjq l 45 markq l objq l 47 endif update figure 2 algorithm identifies candidate memory locations compute markp loc objp loc update inputs procedure q memory location l boolean flag object name contextrecovery detects memory location accessed statement p memory location accessed indirect object name algorithm calls update true otherwise memory location accessed indirect object name algorithm calls update f false update sets values markq l objq l according current value markq l f l candidate q condition 1 violated thus markq l updated objq l updated line 36 current value markq l u update checks see whether extension formal parameter q lines 3738 l candidate according information available point computa tion thus markq l updated objq l updated otherwise l candidate condition 2 violated thus markq l updated objq l updated line 41 markq l update checks whether objq l lines 4344 l accessed q one object name violates condition 1 thus l candidate markq l updated objq l updated line 45 cases markq l objq l remain unchanged contextrecovery computes mark obj mod using intraprocedural phase interprocedural phase intraprocedural phase contextrecovery processes object names appearing statement procedure p lines 213 object name obj direct contextrecovery calls updatep lobjf lines 45 obj indirect memory location loc asetobj contextrecovery calls lines 79 memory location l modified contextrecovery also sets modp l true line 12 example contextrecovery processes statement 3 f figure 1 checks p p indirect name asetp thus algorithm calls updatefytp updatefztp updatefwtp contextrecovery also checks x statement 3 x direct name contextrecovery calls updatef xf f processed mark f obj f following values mark f mark f mark f interprocedural phase contextrecovery processes callsite c procedure r procedure p lines 1634 using worklist w nonlocal memory location loc referenced r contextrecovery checks markr loc line 20 markr loc contextrecovery assumes loc accessed r callsite r including c thus contextrecovery calls updatep locf indicate loc accessed r c unknown way line 21 otherwise markr loc contextrecovery checks whether loc aseta c objr loc c line 22 loc loc referenced r c object name c objr loc context recovery calls updatep locta c objr loc c objr loc indirect calls updatep locf c objr loc direct lines 2327 loc loc referenced r c contextrecovery nothing case interprocedural phase memory location loc processed modr loc true modp loc also set true line 29 example contextrecovery processes callsite f statement 8 figure 1 first checks x mark f x thus algorithm calls updatef1xf algorithm checks mark f algorithm checks whether thus algorithm calls updatef1ytq algorithm finally checks z w nothing z w asetq 8 values mark f1 obj f1 change mark f1 mark f1 mark f1 mark f1 statement 8 processed interprocedural phase contextrecovery also validates indirect object names appearing objp make sure memory locations supporting indirect names p modified p line 32 suppose indirect name obj assigned objp loc memory location l supports obj statement p modp l true loc ineligible condition 3 vi olated thus contextrecovery updates markp loc objp loc contextrecovery processes p interprocedural phase modp markp updated algorithm puts p callers w line 33 contextrecovery continues w becomes empty table 1 shows results computed contextrecovery example program figure 1 mark obj mod mark f mark f mark f mark f mark f1 mark f1 markmain markmain table 1 mark obj mod example program given n size program complexity contextrecovery 2 absence recursion 3 presence recursion complexity contextrecovery algorithm computing modification side eects procedures improve slicing section shows information computed using contextrecovery improve interprocedural slicing program analyses computing interprocedural reaching definitions constructing system dependence graphs improved similar way interprocedural slicing program slicing technique identify statements program aect value variable v statement v called slicing criterion 15 program slicing used support tasks debugging regression testing reverse engineering one approach program slicing first computes data control dependences among statements builds systemdependence graph computes slice solving graphreachability problem graph 6 approaches one used reusedriven interprocedural slicing algorithm 5 use precomputed controldependence information compute datadependence information demand using controlflow graphs 2 cfgs procedures use reusedriven slicing algorithm example show program analysis improved using information provided lightweight context recovery reusedriven slicer computes interprocedural slice criterion v invoking partial slicer procedures program reusedriven slicer first invokes partial slicer p procedure contains identify subset statements p procedures called p subset inputs p may aect v refer v partial slicing standard used partial slicer denote v refer subset statements identified partial slicer partial slice respect v also refer subset inputs identified partial slicer relevant inputs respect v p main function program statements procedures call p might also aect slicing criterion v relevant inputs v therefore p processed callsite c calls p reusedriven slicer binds relevant input f back c creates new partial slicing standard c given bound f c reusedriven slicer invokes partial slicer c identify statements p c included slice algorithm continues additional partial slicing standards generated algorithm returns union partial slices computed partial slicer program slice v figure 3 shows call graph program figure 15x 16x f main figure 3 call graph annotated partial slicing standards 3 x solid lines show graph edges dotted lines show relationships among partial slicing standards 1 graph annotated partial slicing standards created reusedriven slicer compute slice 3 x reusedriven slicer first invokes partial slicer f respect 3 x partial slicer computes partial slice 3 relevant input set x f processed reusedriven slicer creates new partial slicing standards 7 x 8 x callsites f f1 partial slicing standard 16 x callsite f main invokes partial slicer standards partial slicer computes relevant input set x 7 x 8 x partial slicer finishes processing 7 x 8 x reusedriven slicer creates partial slicing standard 15 x callsite f1 main invokes partial slicer standard resulting slice 3 x 3 7 8 13 15 16 union partial slices computed processing partial slicer computes partial slice standard v propagating memory locations backward throughout p using p cfg node n cfg p partial slicer computes two sets memory locations n entry n n exit n n computed using n information n n computed union sets n cfg successors partial slicer iteratively computes node fixed point reached formal parameters nonlocal memory locations p entry relevant inputs respect v n callsite partial slicer computes considering n memory locations whose values modified used n memory locations n modified n n statements n control dependent added slice n callsite procedure q partial slicer must process q compute n identify statements q inclusion partial slice figure 4 shows processcall procedure processes callsite c q processcall uses cache store partial slice relevant inputs partial slicing standard created reusedriven slicer memory location u c processcall binds u u line 2 u modified q proce procedure processcallc inout input c call node calls q set c output set c globals caches v pair pslice relinputs previously computed computepslice v begin processcall 1 foreach u 2 3 u modified q pocedures called q 4 5 else 6 cacheqexit u null 7 cacheqexit 8 endif 9 add cacheqexit u pslice slice 11 endif 12 endfor figure 4 procedure processes callsites using caching dures called q processcall simply adds u c lines 34 otherwise processcall creates partial slicing standard qexit u qexit exit q processcall checks cache qexit u line 6 cache contain information qexit u processcall invokes computepslice qexit u stores partial slice relevant inputs returned computepslice cache line 7 processcall merges partial slice program slice line 9 calls backbind show bind relevant inputs back c adds c line 10 c processed statements included slice c statements c control dependent added slice example compute slice 17 w slicer first propagates w statement 17 16 statement 16 callsite slicer propagates w f creates new partial slicing standard 4 w slicer invokes partial slicer 4 w computes partial slice 3 relevant inputs xyzwp slicer binds x z w p back statement 16 puts xyz w in16 slicer keeps processing adds statements 3 6 7 17 slice interprocedural slicing using information provided lightweight context recovery precision eciency reusedriven slicer improved identify set memory locations modified procedure specific callsite slicer propagates memory location callsite called procedure first checks whether memory location modified procedure callsite memory location cannot modified procedure callsite reusedriven slicer propagate memory location called procedure similarly precision eciency reusedriven slicer improved identify set memory loca procedure processcallc inout input c call node calls q set c output set c globals caches v pair pslice relinputs previously computed computepslice v begin processcall 1 foreach u 2 u modified q c 3 4 else 5 7 cacheqexit 8 endif 9 add cacheqexit u pslice slice 11 endif 12 endfor function backbindev ars c p input ev ars memory locations reaching entry p c call node calls p output memory locations callsite begin backbind 13 foreach memory location l ev ars 14 l formal parameter 15 add memory locations bound l c calleev ars 16 elseif l referenced p c old 16 else 17 add l calleev ars 18 enif 19 endfor 20 return calleev ars backbind figure 5 processcall modified backbind tions referenced procedure specific callsite slicer propagates called procedure callsite memory locations referenced callsite improvements reduce spurious information propagated across procedure boundaries thus improve precision efficiency reusedriven slicer example consider actions reusedriven slicer 17 w figure 1 two improvements described made improved slicer first propagates w statement 17 statement 16 modifies w invoked statement 16 improved slicer propagates w statement 16 f creates partial slicing standard 4 w improved slicer invokes partial slicer 4 w adds statement 3 partial slice identifies x z w p relevant inputs improved slicer checks statement 16 finds x w referenced f invoked statement 16 thus adds x w in16 improved slicer propagates x w 15 f1 modifies neither x w invoked statement 15 improved slicer propagates x w directly in15 without propagating f1 improved slicer continues adds statements 3 12 13 16 17 slice example shows using specific callsite information help reusedriven slicer compute precise slices modify processcall figure 4 use set memory locations modified procedure specific callsite reduce spurious information propagated callsite called procedure figure 5 shows modified processcall lines 25 replace lines 25 original version u c new processcall first checks whether u modified q c line 2 u modified q c new processcall adds u c line 3 u modified q c new processcall binds u u q creates partial slicing standard qexit u continues computation usual way lines 510 u modified q c implies u modified q new processcall need check u also modify backbind use set memory locations referenced procedure specific callsite reduce spurious information propagated procedure callsites figure 5 shows modified backbind line 16 changed backbind checks memory location l input ev ars line 13 l formal parameter backbind adds memory locations bound l c calleev ars lines 1415 otherwise new backbind checks whether l referenced p invoked c line 16 backbind puts l calleev ars line 17 finally backbind returns calleev ars line 20 use markp objp modp computed contextrecovery determine memory locations modified p callsite c 3 nonlocal memory location loc p modp loc true markp loc loc may modified p callsite p including c modp loc true markp loc loc loc modified p c otherwise loc modified p c example according result table 1 mark f thus f modifies f invoked statement 8 figure contains however f modify f invoked statement 16 aseta ie asetw 16 contain use similar approach determine memory locations referenced p p invoked c memory location loc markp loc loc referenced p c markp loc objp loc obj loc aseta c obj c loc referenced p c otherwise loc referenced p c 3 also use conditional alias information determine memory locations may modified p c however approach might expensive large programs performed several studies evaluate eective ness using lightweight context recovery improve precision eciency program analyses implemented contextrecovery reusedriven slicing algorithm uses information provided contextrecovery using prolangs analysis framework paf 3 studies compared results computed alias information provided liang harrolds algorithm lh 9 andersens algorithm 1 4 gathered data studies sun ultra30 workstation 640mb physical memory 1gb virtual memory 5 left side table 2 gives information subject programs cfg lh program nodes loc ci cr ci cr loader 819 1132 007 011 008 011 dixie 1357 2100 012 019 011 017 learn 1596 1600 011 02 011 017 assembler 1993 2510 026 035 023 034 smail simulator 2992 3558 047 059 049 057 arc 3955 7325 038 077 038 068 space 5601 11474 148 162 186 191 larn 11796 9966 218 285 211 284 espresso 15351 12864 734 881 862 1525 moria 20316 25002 2929 3898 2249 2479 twmc 22167 23922 298 469 353 796 table 2 information subject programs left time seconds contextinsensitive modification side effect analysis ci contextrecovery cr right goal study 1 evaluate eciency algorithm cr compared time required run cr program time required compute modification sideeects procedures program contextinsensitive algorithm ci make comparison 1 time computing modification sideeects relatively small compared time required many program analyses 2 algorithm used instead ci compute precise modification sideeects required many program analyses right side table 2 shows results computed using alias information provided lh algorithm algorithm table see subjects studied cr almost ecient ci suggests time added algorithm might negligible many program analyses goal study 2 evaluate precision algorithm identifying memory locations modified procedure specific callsite mod 4 see 9 detailed comparison two algorithms 5 simulate eects library functions using new stubs greater details data reported studies subject programs dier reported previous work figure average sizes mod callsite callsite compared size mod callsite computed traditional contextinsensitive modification sideeect analysis algorithm cimod al gorithm algorithm reduction size mod callsite indicates eectiveness technique filtering spurious information call site also compared results computed algorithm results computed landi ryder zhangs modification side eect analysis algorithm lrz algorithm 8 uses conditional analy sis results computed lrz algorithm viewed lower bound algorithm used implementations cimod algorithm algorithm used implementation lrz algorithm provided paf figure 6 shows results study graph total length bar indicated either lh represents average size mod callsite computed cimod algorithm using alias information provided algorithm lh al gorithm bar length slanted segment represents average size mod callsite computed algorithm using alias information provided corresponding alias analysis algorithm ex ample using alias information provided algorithm cimod algorithm reports callsite modifies 29 memory locations space using alias information however algorithm reports callsite modifies 42 memory locations graph shows subject programs stud ied algorithm computes significantly precise mod callsite cimod algorithm thus expect using information provided algorithm significantly reduce spurious information propagated across procedure boundaries figure 6 also shows average size mod callsite computed lrz algorithm 6 graph length bar indicated lrz represents average size mod callsite computed lrz algorithm example lrz algorithm reports callsite space modify 5 memory locations note algorithm uses alias information computed landi ryders algorithm 7 treats structure way fields cases algorithm reports larger mod callsite algorithm space graph shows several programs studied size mod callsite computed algorithm close computed lrz algorithm result suggests algorithm quite precise identifying memory locations may modified procedure specific callsite graph also shows precision mod callsite computed algorithm varies dierent programs suggests eective ness improving program analyses using information provided algorithm might depend program written study 3 goal study 3 evaluate eectiveness using information provided lightweight context recovery improving precision eciency reusedriven slicing algorithm compared size slice time compute slice without using information provided lightweight context recovery table 3 shows results left side table 3 shows average size slice computed using information provided lightweight context recovery average size slice computed without using information table also shows ratio percentage table see programs using information provided lightweight context recovery significantly improve precision computing interprocedural slices however programs see significant improvement one explanation may programs precision interprocedural slicing sensitive precision identifying memory locations modified referenced statement result consistent results reported references 9 14 show precision interprocedural slicing sensitive precision alias information right side table 3 shows average time compute slice using information provided 6 data programs unavailable landi ryders algorithm 7 fails terminate within 10 hours time limit set computing alias information programs average size time seconds name alias ss tt load lh 187 241 779 23 64 350 er 187 241 779 23 64 352 dixie lh 629 648 970 100 230 436 609 648 940 53 123 429 learn lh 499 501 996 162 297 546 479 501 956 109 212 515 791 806 981 83 97 857 assem lh 744 751 991 152 938 162 smail lh 1066 1087 981 158 545 290 1032 1090 947 129 390 330 546 698 783 103 395 262 simu lh 1174 1178 997 111 185 598 later 1174 1178 997 108 187 580 arc lh 788 804 981 94 129 725 771 803 961 76 92 822 space lh 2028 2161 939 318 577 55 2019 2161 934 312 574 54 larn lh 4590 4612 995 642 977 657 4576 4603 994 619 798 775 average size time hours name alias ss tt espre lh 5704 5705 100 12 47 254 sso 5704 5705 100 69 73 937 moria lh 7820 28 100 7822 71 100 twmc lh 4331 4331 100 19 22 837 4327 4327 100 17 20 841 data collected slices program data collected one slice table 3 average size slice left average time compute slice right lightweight context recovery average time compute slice without using information provided lightweight context recovery time measured include time required building cfg alias analysis computing modification sideeect context recovery table also shows ratio table see using information provided lightweight context recovery significantly reduce time required compute interprocedural slices suggests technique might eec tively improve eciency many program analyses flowinsensitive alias analysis algorithms ex tended using similar technique reference 4 compute polyvariant alias information identifies dierent alias relations procedure dierent callsites using polyvariant alias information program analysis identify memory locations accessed procedure specific callsite thus computes accurate program informa tion however computing polyvariant alias information may require procedure analyzed multiple times specific calling context requirement may make alias analysis inecient observing memory locations pointed pointers procedure program information procedure developed technique 10 partitions memory locations equivalence classes memory locations equivalence class share program information procedure therefore procedure analyzed information representative equivalence class computed information reused memory locations equivalence class experiments 10 11 show technique eec tively improve performance program analyses technique presented paper improves performance program analyses another dimension thus used together equivalence analysis improve eciency program analyses horwitz reps binkley 6 present technique uses sets variables may modified may referenced procedure avoid including unnecessary callsites slice technique needed systemdependencegraph based slicer compute slices precise computed interprocedural slicers eg 5 technique diers technique uses sets memory locations may accessed procedure specific callsite filter spurious program infor mation thus technique improve precision performance many program analyses horwitz reps binkleys technique cannot apply many techniques improve performance program analyses eg 13 lightweight contextrecovery technique used many approaches improve performance dataflow analyses 6 conclusion future work presented lightweight context recovery algorithm illustrated technique uses information provided lightweight context recovery improve precision eciency program anal yses also conducted several empirical studies results studies suggest many cases using lightweight context recovery eectively improve precision eciency program analyses future work first repeat studies paper larger programs validate conclusions second perform studies evaluate eectiveness combining lightweight context recovery equivalence analysis improve e ciency computing interprocedural slices third apply technique program analyses evaluate eectiveness program analyses fi nally perform studies compare technique conditional analysis acknowledgments work supported nsf grants ccr 9696157 ccr9707792 ohio state university r program analysis specialization c programming language programming languages research group call graph construction objectoriented languages interprocedural slicing using dependence graphs safe approximate algorithm interprocedural pointer aliasing interprocedural modification side e equivalence analysis general technique improve e interprocedural defuse associations c programs program slicing tr interprocedural slicing using dependence graphs safe approximate algorithm interprocedural aliasing interprocedural modification side effect analysis pointer aliasing call graph construction objectoriented languages effective wholeprogram analysis presence pointers reusedriven interprocedural slicing equivalence analysis efficient pointsto analysis wholeprogram analysis dataflow analysis program fragments interprocedural defuse associations c systems single level pointers effects presision pointer analysis reusedriven interprocedural slicing presence pointers recursions ctr donglin liang maikel pennings mary jean harrold evaluating impact contextsensitivity andersens algorithm java programs acm sigsoft software engineering notes v31 n1 january 2006 anatoliy doroshenko ruslan shevchenko rewriting framework rulebased programming dynamic applications fundamenta informaticae v72 n13 p95108 january 2006 markus mock darren c atkinson craig chambers susan j eggers improving program slicing dynamic pointsto data proceedings 10th acm sigsoft symposium foundations software engineering november 1822 2002 charleston south carolina usa markus mock darren c atkinson craig chambers susan j eggers improving program slicing dynamic pointsto data acm sigsoft software engineering notes v27 n6 november 2002 markus mock darren c atkinson craig chambers susan j eggers program slicing dynamic pointsto sets ieee transactions software engineering v31 n8 p657678 august 2005 michael hind pointer analysis havent solved problem yet proceedings 2001 acm sigplansigsoft workshop program analysis software tools engineering p5461 june 2001 snowbird utah united states baowen xu ju qian xiaofang zhang zhongqiang wu lin chen brief survey program slicing acm sigsoft software engineering notes v30 n2 march 2005
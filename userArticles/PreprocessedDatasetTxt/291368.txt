theoretical analysis communicationinduced checkpointing protocols rollbackdependency trackability abstractrollbackdependency trackability rdt property states rollback dependencies local checkpoints online trackable using transitive dependency vector paper address three fundamental issues design communicationinduced checkpointing protocols ensure rdt first prove following intuition commonly assumed literature fact false protocol forces checkpoint stronger condition must take many forced checkpoints protocol based weaker condition result implies common approach sharpening checkpointinducing condition piggybacking control information message may always yield efficient protocol next prove optimal online rdt protocol takes fewer forced checkpoints rdt protocol possible communication patterns finally since comparing checkpointinducing conditions sufficient comparing protocol performance present formal techniques comparing performance several existing rdt protocols b introduction distributed computation consists finite set processes connected communication network communicate synchronize exchanging messages network local checkpoint snapshot local state process saved nonvolatile storage survive process failures reloaded volatile memory case failure reduce amount lost work process record local state say process takes local checkpoint distributed computation thus associated checkpoint communication pattern defined set messages local checkpoints global checkpoint 1 set local checkpoints one process global checkpoint consistent message sent checkpoint received another checkpoint 2 computation consistent global checkpoints important work one interested designing implementing systems ensure dependability applications run many protocols proposed select local checkpoints order form consistent global checkpoints see survey 3 remark local checkpoints taken independently risk consistent global checkpoint ever formed wellknown unbounded domino effect occur rollbackrecovery 4 avoid domino effect kind coordination determination local checkpoints required 2 5 coordination achieved price synchronization means additional control messages another approach namely communicationinduced checkpointing 6 achieves coordination piggybacking control information application messages case processes select local checkpoints independently called basic checkpoints protocol requires take additional local checkpoints called forced checkpoints order ensure progression consistent recovery line forced checkpoints taken according certain condition tested time message received basis control information piggybacked messages generally fact two local checkpoints causally related necessary sufficient condition belong consistent global checkpoint 7 hidden dependencies make impossible belong consistent global checkpoint dependencies characterized fact cannot tracked transitive dependency vectors solve problem wang defined rollbackdependency trackability rdt property 8 checkpoint communication pattern satisfies property dependencies local checkpoints online trackable ie trackable simple use transitive dependency vector rdt two noteworthy properties 1 ensures set local checkpoints pairwise causally related extended form consistent global checkpoint 2 enjoys efficient calculations minimum maximum consistent global checkpoints contain given set local checkpoints consequence rdt property applications large family dependability problems software error recovery 9 deadlock recovery 10 mobile computing 11 distributed debugging 12 etc moreover combined appropriate message logging protocol 13 rdt allows solve dependability problems posed nondeterministic computations computations piecewise deterministic 8 since rdt property wide range applications many problems becomes important pragmatic issue design efficient communicationinduced checkpointing protocols satisfying rdt property number forced checkpoints size piggybacked control information dominant factors price paid hence main question context design efficient rdt protocol less number forced checkpoints smaller size piggybacked control information common intuition literature 8 14 protocol forces checkpoint weaker condition must force least many checkpoints protocol stronger condition necessarily true note stronger condition subset weaker condition actually tradeoff number forced checkpoints size piggybacked control information 15 paper give theoretical analysis problems first counterexamples previous two statements enumerated demonstrate optimal online protocol terms number forced checkpoints since common intuition proved invalid interesting techniques comparing useful protocols also proposed techniques used compare many existing rdt protocols literature remark results theoretical point view also practical one considering task designing efficient protocols rdt property paper structured five main sections section 2 defines computational model introduces definitions elements rollbackdependency trackability theory section 3 discuss impossibility problems several techniques comparing useful protocols addressed next section section 5 depicts hierarchy graph comparing family rdt protocols marshal discussions context finally conclude paper section 6 2 preliminaries 21 checkpoint communication patterns distributed computation consists finite set p n processes fp communicate synchronize exchanging messages assume ordered pair processes connected asynchronous reliable directed logical channel whose transmission delays unpredictable finite process runs processor processors share common memory bound relative speeds fail according failstop model process execute internal send receive statements internal statement involve communication p executes statement sendm puts message channel p p j p executes statement receivem blocked least one message directed p arrived message withdrawn one input channels received p executions internal send receive statements modeled internal sending receiving events processes distributed computation sequential words process p produces sequence events sequence finite infinite events produced distributed computation modeled partially ordered set wellknown defined follows 16 definition 1 relation hb set events satisfies following three condition 1 b events process comes b hb b 2 event sendm b event receivem hb b 3 hb hb distributed computation associated checkpoint communication pat tern composed distributed computation h set local checkpoints k1 k2 figure 1 checkpoint communication pattern ccpat defined h figure 1 shows example checkpoint communication pattern ccpat c ix represents xth checkpoint process sequence events occurring p c called checkpoint interval denoted ix called process id x index checkpoint checkpoint interval assume process p starts execution initial checkpoint c i0 22 rollbackdependency trackability first briefly introduce concepts zpath 7 causal doubling zpath 15 concept rollbackdependency trackability 8 details subjects please consult papers previously cited definition 2 zpath sequence messages best knowledge notion introduced first time netzer xu 7 name zigzag path zpath say zpath ix jy example pattern ccpat depicted figure 1 paths zpath k2 i2 however path zpath rest paper use following notation zpath first last message denoted first last let two zpaths whose concatenation also zpath concatenation represented delta introduce notion causal zpath zpath causal receiving event message except last one precedes sending event next message sequence zpath noncausal causal zpath one message trivially causal simplicity casual zpath also called causal path definition 3 zpath ix jy causally doubled exists causal path ix 0 jy 0 x x 0 0 previous definition every causal path obviously causally doubled example zpath pattern ccpat figure 1 noncausal causally doubled causal path following concept rollbackdependency trackability introduced wang 8 defined differently equivalently 15 definition 4 checkpoint communication pattern ccpat satisfies rdt property noncausal zpaths causally doubled ccpat words checkpoint communication pattern satisfies property sense dependencies local checkpoints need online trackable since dependencies passed along causal paths 23 pcmpaths given checkpoint communication pattern ccpat necessary check every noncausal zpath causally doubled ensure ccpat satisfies rdt property namely consider certain embedded subsets noncausal zpaths 15 important subset pcmpaths introduced definition 5 causal path ix jy prime every causal path ix 0 jy 0 x x 0 0 satisfies receivelast hb receivelast intuitively prime path ix jy first one including existence interval ix ie new dependency p j current state transitively depends causal past p j current state pcmpath delta zpath concatenation causal path single message prime sendm hb receivelast pattern ccpat shown figure 1 path 5 prime 3 prime path pcmpath following theorem direct consequence 15 theorem 1 checkpoint communication pattern ccpat satisfies rdt property pcmpaths causally doubled ccpat idea behind theorem according definitions rdt since dependencies local checkpoints must online trackable new dependency passed along zpath end due new dependencies included prime causal paths firstly pcmpaths causally doubled necessary sufficient ensure rdt property note exploit following transitive dependency tracking mechanism proposed literature 11 17 18 detect existence prime path system processes process p maintains sizen transitive dependency vector tdv represent current interval index equivalently checkpoint index next checkpoint p record highest index intervals process p j current state transitively depends tdv piggybacked application messages sent upon receipt messages processes decide evaluating vector prime path encountered 8 according theorem 1 order ensure rdt property pcmpath causally doubled needs broken forced checkpoint pcmpath delta whose breakpoint ix receipt last process p distinguish delta causally doubled information carried message pcmpath causally doubled also visibly doubled defined follows 15 order broken definition visibly doubled causally doubled causal path 0 receive 0 last hb sendlast figure 2 shows example visibility doubling intuitively causal doubling pcm path visible process receipt message last path 0 causally doubles belongs causal past last note definition causally doubled pcmpath necessarily visibly doubled noncausally doubled one must nonvisibly doubled based foregoing discussion theorem 1 deduce characterization rdt respect protocols based entirecausal history 15 corollary 1 checkpoint communication pattern produced protocol based entirecausal history satisfies rdt property pcmpaths visibly doubled last figure 2 visibility doubling pcmpath interval ix another interval ix 0 process p call pcmpath pcmcycle x pcmcycle causally doubled called nondoubled pcmcycle 15 example path figure 1 pcmcycle nondoubled remainder paper sake clarity refer pcmpath process another different one pcmpath contrary pcmpath process one pcmcycle pcmpaths pcmcycles called pcmconditions 3 impossibility problems section discuss impossibility problems first disprove truthfulness following common intuition literature 8 14 protocol forces checkpoint weaker condition must force least many checkpoints protocol stronger condition words even though conditions involved two different protocols inclusive subordinative relationship may impossible compare two protocols terms number forced checkpoints motive problem since forced checkpoint change given checkpoint communication pattern consequently affect later condition testings soon two protocols differ decision force checkpoint two resulting checkpoint communication patterns possibly strongly diverge future thus perhaps impossible compare two protocols also overthrow concept tradeoff number forced checkpoints size piggybacked control information rdt protocols last subsection given proof demonstrate another impossibility problem optimal online protocol ensures rdt property scenario quite common area online algorithms due knowledge future information 31 common intuitions necessarily true two counterexamples enumerated specious statements mentioned previ ously results show fact definitely needs formal proof comparison two different protocols therefore propose techniques comparing useful protocols next section counterexample 1 cpn protocol breaks pcmpaths every pcmcycle sendfirst cpm protocol breaks pcmpaths every cmcycle delta cmcondition concatenation causal path necessarily prime single message sendm hb receivem hb sendfirst easily verified cpn cpm break noncausally doubled pcmpaths nondoubled pcmcycles hence two protocols rdt protocols theorem 1 need piggyback tdv application messages note apply consequence 15 evaluate size piggybacked control information paper please refer paper details obviously cpm forces checkpoint weaker condition cpns result shown figure 3 cpn must take two forced checkpoints diamond box make considered checkpoint communication pattern satisfy rdt property however cpm needs one forced checkpoint make pattern ensure rdt depicted figure 3 b counterexample shows cpm forces fewer checkpoints cpn given checkpoint communication pattern thus disproves common intuition besides overthrowing common intuition following counterexample also demonstrates necessarily tradeoff number forced checkpoints size piggybacked control information counterexample 2 let nononvisiblydoubledpcm nnvdpcm protocol breaks nonvisibly doubled pcmpaths nondoubled pcmcycles pcmpath protocol breaks pcmpath nondoubled pcmcycles similarly since protocols break nonvisibly doubled pcmpaths nondoubled pcmcycles initial checkpoint forced checkpoint basic checkpoint figure 3 scenario counterexample 1 cpn b cpm according corollary 1 also rdt protocols moreover since nnvdpcm decide whether pcmpath visibly doubled needs piggybacked control information nopcmpaths nnvdpcm takes one forced checkpoint see figure 4 nopcmpath see figure 4 b hence counterexample also shows protocol piggybacking less control information nopcmpath outperforms one piggybacking control information nnvdpcm checkpoint communication patterns terms number forced checkpoints idea behind counterexamples forced checkpoint taken protocol based stronger condition make cmpath rightmost part considered checkpoint communication pattern become noncausally doubled pcmpath thus another checkpoint necessary forced break pcmpath however forced checkpoint taken protocol weaker condition give rise scenario initial checkpoint forced checkpoint basic checkpoint figure 4 scenario counterexample 2 nnvdpcm b nopcmpath 32 optimal online protocol take two categories online protocols consideration problem two categories online protocols based entire causal history transitive dependency tracking ie piggybacking tdv message control information respec tively shown optimal protocol following descriptions given checkpoint communication pattern counterexample 1 redrawn figure 5 denoted ccpat directly following lemma since pcmcycle nondoubled lemma 1 process p 3 needs force least one checkpoint point b make ccpat satisfy rdt entirecausal tdv online rdt protocols lemma 2 forced checkpoint taken point c b process p 3 process p 2 must take another forced checkpoint satisfy rdt entirecausal tdv online rdt protocols ccpat c ccpat initial checkpoint 4 c b figure 5 checkpoint communication patterns ccpat ccpat c forced checkpoint taken point c b process p 3 zpath becomes noncausally doubled pcmpath since 3 turns prime hence p 2 force another checkpoint break pcmpath satisfy rdt entirecausal tdv online rdt protocols scenario shown figure 3 qed consider following theorem theorem 2 optimal online protocol based entire causal history terms number forced checkpoint protocol optimal given checkpoint communication pat tern protocol less number forced checkpoints see checkpoint communication pattern ccpat depicted figure 5 since protocol cpm counterexample needs one forced checkpoint make ccpat satisfy rdt protocols force checkpoint point c b lemma 2 protocols must force two checkpoints protocols take one checkpoint point c cannot optimal optimal protocol must take exactly one forced checkpoint point c according lemma 1 however online protocol cannot optimal force one checkpoint cut pattern ccpat c shown left region dotted line figure 5 due causality ccpat position protocol cpn counterexample 1 takes zero forced checkpoint ccpat c therefore optimal online protocol based entire causal history terms number forced checkpoints qed mentioned earlier counterexample 1 protocols cpm cpn piggyback transitive dependency vector hence corollary similar proof previous theorem corollary 2 optimal online protocol based transitive dependency tracking tdv terms number forced checkpoints 4 techniques comparison 41 fdas vs protocols wang proposed fixeddependecyaftersend fdas checkpointing protocol 8 breaks pcmconditions subsection two assertions fdas outperforms protocols force checkpoint weaker conditions fdass protocols force checkpoint stronger conditions better fdas terms number forced checkpoints demonstrated first prove former assertion true let c f denotes condition fdas based ie breaking pcm conditions cpw denotes protocol takes forced checkpoint weaker condition fdass based condition denoted cw obviously c f subset cw represent relation c f cw let ccpat f ccpat w represent checkpoint communication patterns produced protocols fdas cpw respectively since adding forced checkpoints cannot make pcpath ie prime causal path original checkpoint communication pattern become nonpc path directly following lemma lemma 3 pcpath original checkpoint communication pattern still pcpath checkpoint communication pattern produced protocol define extra pcpath nonpc path originally becoming pcpath due forced checkpoint taken protocol following two lemmas lemma 4 extra pcpath ccpat f also extra pcpath ccpat w proof assume exists extra pcpath ccpat f extra pcpath ccpat w extra pcpath produced forced checkpoint taken thus exists pcpath condition 1 sendfirst ccpat f fdas forced process take checkpoint break c f condition formed 1 checkpoint made become extra pcpath say produced 1 obviously 1 causal past similarly 1 pcpath either originally pcpath figure observation process lemma 4 extra pcpath produced another pcpath 2 causal past 1 thus also causal past repeatedly foregoing observation since messages causal past finite eventually obtain original pcpath n previous progress shown figure 6 lemma 3 n also pcpath ccpat w hence cpw must force process take checkpoint necessarily checkpoint one ccpat f receive n last nearest previous messagesending event avoid n form c f condition cpw also needs break since c f cw forced checkpoint makes ngamma1 ccpat w become extra pcpath since ccpat f also extra pcpath messagesending event receive n last nearest previous messagesending event namely cannot exist causal path prevents ngamma1 becoming prime reason ngamma2 also becomes pcpath ccpat w finally also becomes extra pcpath ccpat w leads contradiction qed lemma 5 fdas never force two consecutive checkpoints two consecutive condition c w pcpath pcpath figure 7 scenario lemma 5 checkpoints forced cpw proof prove lemma showing cpw must force least one checkpoint two consecutive forced checkpoints taken fdas see scenario shown figure 7 two consecutive checkpoints forced fdas exist two continuous conditions pcpath latter c f condition ccpat f lemma 3 lemma 4 also pcpath ccpat w therefore cpw force one checkpoint pcpath nearest previous messagesending event prevent c f condition formed shown hollow diamond figure 7 checkpoint obviously two consecutive checkpoints forced fdas qed consequence derive following monotonicity property theorem 3 cpw takes nth forced checkpoint later fdas n proof induction given checkpoint communication pattern exactly cpw fdas forced checkpoint taken clear cpw must force first checkpoint later fdas reason c f cw suppose cpw takes kth checkpoint later fdas according lemma 5 cpw take 1th checkpoint later fdas qed let f ckptcp denotes number forced checkpoints taken protocol cp applying previous theorem obvious f ckptcpw f ckptfdas russells algorithm 19 protocol presented 20 named noreceive aftersend nras fixeddependencyinterval fdi wang 8 respec tively rdt protocols definitions nras breaks cmpaths fdi forces checkpoint whenever pcpath encountered hence belong family cpw theorem 3 know fdas better two protocols terms number forced checkpoints begin demonstrate latter assertion aforementioned beginning valid also let cps denote protocol takes forced checkpoint stronger condition fdass condition based c obviously c c f let ccpat represent checkpoint communication pattern produced protocol cps similarly consider following lemma lemma extra pcpath ccpat also extra pcpath ccpat f proof assume exists extra pcpath ccpat extra pcpath ccpat f since cps also breaks certain pcmconditions observation lemma 4 obtain original pcpath n causes become extra pcpath lemma 3 n also pcpath ccpat f hence fdas must force process take checkpoint necessarily checkpoint one ccpat receive n last nearest previous messagesending event avoid n form c f condition fdas needs break forced checkpoint makes ngamma1 ccpat f become extra pcpath since ngamma1 ccpat also extra pcpath messagesending event receive n last nearest previous messagesending event reason ngamma2 also becomes pcpath ccpat f finally also becomes extra pcpath ccpat f leads contradiction qed similar description lemma 5 following lemma proved lemma 7 cps never force two consecutive checkpoints two consecutive checkpoints forced fdas therefore obtain corollary straightforward way corollary 3 fdas takes nth checkpoint later cps n assertion f ckptfdas f ckptcps holds rdt protocol bhmr proposed 14 breaks nonvisibly doubled pcmpaths pcmcycles including nondoubled pcmcycles thus belongs family cps side effect foregoing corollary give formal proof showing bhmr outperforms fdas terms number forced checkpoints instead simulation results 42 nopcmcycle vs fdas another interesting result technique comparing nopcmcycle fdas applying corollary 3 protocol nopcmcycle breaks nonvisibly doubled pcm paths pcmcycles outperforms fdas based condition stronger fdass however find nopcmcycle actually equivalent protocol fdas shown following theorem theorem 4 pcmcycles nonvisibly doubled pcmpaths broken checkpoint communication pattern visibly doubled pcmpath also broken proof visibly doubled pcmpath delta shown figure 8 since must exist prime path visibly doubles delta without loss generality 1 assumed prime figure 8 know 1 causal past last show case analysis delta broken 1 delta last prime pcmcycle 1 delta last delta broken thus pcmpath b 1 delta last prime exists causal path 0 1 process p necessarily receive 1 last otherwise turn nonprime shown figure 8 without lost generality assume 0 1 nearest causal path p 1 first pcmcondition pcmcondition broken theorem assumption forced checkpoint make 1 delta last become prime since first causal path p receive 1 last consequently broken pcmpath 1 first visibly doubled pcmpath shown figure 8 b clearly 2 causal past 1 last thus causal past 1 also causal past last repeatedly applying foregoing observation since messages causal past last finite eventually obtain pcmcondition n delta 0 n first either nonvisibly doubled pcmpath pcmcycle therefore need broken forced checkpoint make become prime pcmpath broken reason ngamma2 delta 0 ngamma2 first also broken finally pcmpath delta also broken qed according previous theorem protocol nopcmcycle fact breaks pcmconditions equivalent fdas result shows first last b figure 8 scenario theorem 4 reduce redundant size piggybacked control information adopting fdas instead nopcmcycle nopcmcycle needs extra information distinguish visibly doubled pcmpath 43 pcm vs pescm 15 baldoni et al proposed constrained characterization rdt property pescm designing protocols pescmcondition composed pcmcondition delta elementary simple besides prime interest subsection lies fact existence pcmcondition implies existence pescm condition position consequently becomes unnecessary take stronger condition piggybacked control information consideration protocols first introduce definitions terms elementary simple 15 definition 7 zpath elementary traversal sequence p sequence processes traversed repetition definition 8 causal path simple two events receivem sendm i1 occur interval 8i 1 namely elementary zpath traverses process simple causal path include local checkpoints instance checkpoint communication pattern shown figure 1 path neither elementary simple traverses process p j twice local checkpoint c k1 included path elementary simple definition 7 every causal path contains elementary causal path elementary causal path contained prime causal path starting interval ending point thus also prime pecmcondition defined pcm condition property elementary addition prime directly following theorem corollary theorem 5 existence pcmcondition implies existence pecmcondition position corollary 4 existence nondoubled pcmcondition implies existence nondoubled pecmcondition position next begin demonstrate lemma lemma 8 pecpath prime elementary causal path contains pescpath prime elementary simple causal path proof note nonsimple causal path written component simple prove lemma showing last simple path contained pecpath prime course elementary depicted figure 9 pecpath l prime exists prime path point x 0 point 0 point 0 precedes point since 1 causal path receivelast hb turns nonprime leads contradiction qed according theorem 5 corollary 4 previous lemma easily verified following theorem corollary true theorem 6 existence pcmcondition implies existence pescmcondition position corollary 5 existence nondoubled pcmcondition implies existence nondoubled pescmcondition position idea underlying previous results protocol nopescm breaks pescmconditions protocol nononvisiblydoubledpescm breaks nonvisibly doubled pescmpaths nondoubled pescmcycles presented 15 exactly fdas nnvdpcm respectively however piggybacked control information sake necessity distinguish simple paths intuitively break nondoubled pcmconditions order satisfy rdt theorem 1 figure 9 pecpath achieve goal breaking nondoubled pescmconditions scenario necessarily pescmcondition pcmcondition breaking former eliminate latter reason previous results hold 5 family rdt protocols figure depicts hierarchy graph comparing family communicationinduced checkpointing protocols satisfying rdt property plain arrow protocol cp1 another protocol cp2 indicates f ckptcp1 f ckptcp2 dotted arrow indicates piggybacked control information cp1 less cp2 line two arrows means equivalent line mark x means incomparable protocol cbr checkpointbefoereceive 8 bottom figure 10 checkpoint placed every messagereceiving event easily verified fdi nras force fewer number checkpoints cbr figure 10 marshals discussions previous sections note family includes many existing rdt protocols literature therefore result helpful wide range practical applications nopcmpath nopcmcircle fdas nras fdi cbr figure 10 comparing family rdt protocols 6 conclusions paper provided theoretical analysis rdt protocols context impossibility problems addressed first shown common intuitions literature convincing definitely needs formal proof demonstrate one protocol better another one rigorous demonstrations usually found necessarily worthy adopt protocols based stronger conditions piggybacked control information also proved optimal online protocol ensures rdt property scenario quite common area online algorithms due knowledge future information moreover techniques comparing useful protocols proposed showed techniques exploited compare many existing protocols literature hence results provide guidelines designing evaluating efficient communicationinduced checkpointing rdt protocols acknowledgements authors wish express sincere thanks jeanmichel helary irisa michel raynal irisa whose comments helped improve presentation paper would like also thank jeff westbrook valuable discussions online algorithms tsai kuos work supported national science council taiwan roc grant nsc 872213e259007 r consistent global checkpoints based direct dependency tracking distributed snapshots determining global states distributed systems survey rollbackrecovery protocols messagepassing systems system structure software faulttolerant checkpointing rollbackrecovery distributed systems experimental evaluation multiprocessor cachebased error recovery necessary sufficient conditions consistent global snapshots consistent global checkpoints contain given set local check points maximum minimum consistent global checkpoints applications guaranteed deadlock recovery deadlock resolution rollback propagation checkpointing distributed applications mobile computers causal distributed breakpoints piecewise determinism almost true communicationinduced checkpointing protocol ensures rollbackdependency trackability rollbackdependency trackability optimal characterization protocol time clocks ordering events distributed system efficient distributed recovery using message logging optimistic recovery distributed systems state restoration systems communicating processes optimal checkpointing local recording dominofree rollback recovery tr ctr roberto baldoni jeanmichel hlary michel raynal rollbackdependency trackability visible characterizations proceedings eighteenth annual acm symposium principles distributed computing p3342 may 0406 1999 atlanta georgia united states jichiang tsai properties rdt communicationinduced checkpointing protocols ieee transactions parallel distributed systems v14 n8 p755764 august b gupta z liu z liang designing direct dependency based fast recovery algorithms distributed systems acm sigops operating systems review v38 n1 p5873 january 2004 b gupta k banerjee rollforward recovery scheme solving problem coasting forward distributed systems acm sigops operating systems review v35 n3 p5566 july 1 2001 manivannan mukesh singhal quasisynchronous checkpointing models characterization classification ieee transactions parallel distributed systems v10 n7 p703713 july 1999 jm hlary mostefaoui r h b netzer raynal communicationbased prevention useless checkpoints distributed computations distributed computing v13 n1 p2943 january 2000 junlin lin margaret h dunham lowcost checkpointing technique distributed databases distributed parallel databases v10 n3 p241268 december 2001
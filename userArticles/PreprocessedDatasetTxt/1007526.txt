test input generation java pathfinder show model checking symbolic execution used generate test inputs achieve structural coverage code manipulates complex data structures focus obtaining branchcoverage unit testing core methods redblack tree implementation java treemap library using java pathfinder model checker three different test generation techniques introduced compared namely straight model checking code model checking used blackbox fashion generate inputs fixed size lastly model checking used whitebox test input generation main contribution work show efficient whitebox test input generation done code manipulating complex data taking account complex method preconditions b evaluate approaches generating tests redblack tree 16 implementation java treemap li brary contributions work powerful exible test input generation framework unit testing framework uses ecient approach symbolic execution code manipulating complex data structures takes account preconditions stop analysis infeasible paths soon possible framework used uniformly whitebox blackbox testing show framework used generating tests code manipulating complex data structures specically redblack trees illustrate exibility model checking tool test input creation comparing straight model checking code test blackbox approach whitebox approach 2 background describe java pathfinder jpf model checker 43 extended symbolic execution ca x x pc true x x pc xy x x pc xy x xy pc xyint x 1if 2 3 4 5 x x xy x pc xy x x pc xy x x x x figure 1 code swaps two integers corresponding execution tree transitions labelled program control points pability show section 4 use extension jpf whitebox blackbox test input generation 21 java pathfinder jpf explicitstate model checker java programs built top custommade java virtual machine jvm jpf handle language features java also treats nondeterministic choice expressed annotations program analyzed annotations added programs method calls special class verify following methods verify class used paper randombool returns boolean value nondeterministically randomn returns values 0 n nondeterministically ignoreifcond forces model checker backtrack cond evaluates true jpf previously used nd errors number complex systems including realtime operating system deos honeywell 39 prototype mars rover developed nasa ames called k9 11 recently also used means generating input plans current k9 rover takes input 5 plans generated blackbox fashion similar technique described section 42 22 symbolic execution java pathfinder section give background symbolic execution present symbolic execution framework used reasoning java programs 221 background symbolic execution main idea behind symbolic execution 31 use values instead actual data input values represent values program variables symbolic ex pressions result outputs computed program expressed function symbolic inputs state symbolically executed program includes symbolic values program variables path condition pc program counter path condition quantier symbolic inputs accumulates constraints inputs must satisfy order execution follow particular associated path program counter denes next statement executed symbolic execution tree characterizes execution paths followed symbolic execution program nodes represent program states arcs represent transitions states consider code fragment figure 1 swaps values integer variables x x greater figure also shows corresponding symbolic execution tree initially pc true x symbolic values x respectively branch point pc updated assumptions inputs order choose alternative paths example execution rst statement else alternatives statement possible pc updated accordingly path condition becomes false ie set inputs satisfy means symbolic state reachable symbolic execution continue path example statement 6 unreachable 222 generalized symbolic execution 30 describe algorithm generalizing traditional symbolic execution support advanced constructs modern programming languages java c algorithm handles dynamically allocated structures primitive data concurrency since extended work 30 adding support symbolic execution arrays algorithm starts execution method inputs uninitialized elds uses lazy initialization assign values elds ie initializes elds rst accessed methods symbolic execution allows symbolic execution methods without requiring priori bound number input objects execution accesses uninitialized reference eld algorithm nondeterministically initializes eld null reference new object uninitialized elds reference object created prior eld initialization systematically treats aliasing execution accesses uninitialized primitive string eld algorithm rst initializes eld new symbolic value appropriate type execution proceeds branching condition primitive elds eval uated algorithm nondeterministically adds condition negation corresponding path condition checks path conditions satisability using decision procedure path condition becomes infeasible current execution terminates ie algorithm back tracks 223 framework symbolic execution framework built top jpf model checker enable jpf perform symbolic execution lazy initialization original program instrumented source source translation adds nondeterminism support manipulating formulas represent path conditions1 1the interested reader referred 30 detailed description code instrumentation class node int elem node next precondition acyclic void foo 1 elem telem 2 figure 2 simple example illustrate generalized execution model checker checks instrumented program using usual state space exploration techniques essentially model checker explores symbolic execution tree program state includes heap conguration path condition primitive elds thread scheduling whenever path condition updated checked satisability using appropriate decision procedure omega library 40 linear integer constraints path condition unsatisable model checker backtracks framework used test input generation nding counterexamples safety properties test input generation model checker generates paths witnesses testing criterion encoded set properties every reported path model checker also reports input heap conguration encoding constraints reference elds path condition primitive input elds thread scheduling used reproduce error note performing forward symbolic execution programs loops explore innite execution trees systematic state space exploration framework uses depth rst search iterative deepening breadth rst search although concentrate paper analysis sequential code worth mentioning symbolic execution framework handles concurrency uses model checker systematically analyze thread inter leavings using model checker search engine framework allows us also exploit builtin capabilities model checker backtracking dierent search capabilities eg heuristic search techniques combat stateexplosion eg partial order symmetry reductions also note although consider branch coverage metric testing framework handle testing criteria encoded properties model checker check eg dataow based coverage 224 illustration illustrate generalized symbolic execution simple example see figure 2 class node implements singlylinked lists elds elem next represent respectively nodes integer value reference next node figure 3 gives part corresponding code instrumented symbolic execution concrete types replaced symbolic types library classes pro vide concrete operations method calls implement equivalent operations symbolic types class expression supports manipulation symbolic integers class node expression elem node next boolean nextisinitialized false boolean elemisinitialized false static vector static vaddnull node newnode int return nodevelementati return n node getnext ifnextisinitialized verifyignoreifpreconditioneg acyclic return next void foo 1 ifgetelemgttgetelem 2 setnexttgetnext figure 3 instrumented code input structure next next pc true1 next next pc e0e1 pce0e1 next next next next next next next next next next next figure 4 symbolic execution tree excerpts field reads updates replaced get set methods get methods implement lazy initialization eld original class declaration boolean elds ie next initialized elem initialized added elds set true get set methods vector v stores input objects created result lazy initialization helper method new node called get node uses elements vector v systematically initialize input reference elds according dierent aliasing possibilities figure 4 illustrates paths generated symbolic execution code method foo given input structure node execution tree denotes symbolic state branching tree corresponds nondeterministic choice introduced build path condition handle aliasing edges labelled numbers refer program statements without numbers lazy initialization steps value elem eld indicates eld initialized cloud indicates next eld initialized null nodes represented structures represent constraints reference elds eg input structure figure 4 represents cyclic acyclic lists least two nodes points second node explain later section 43 method preconditions used lazy initialization input structure violates precondition model checker backtracks ie call method verifyignoreif figure 3 example consider precondition input list acyclic algorithm explore transitions marked x figure 4 3 case study redblack trees used input generation techniques testing variety programs including methods classes javautil package programs manipulate complex data structures particular illustrate techniques java implementation redblack trees given javautiltreemap standard java libraries version 13 redblack trees 16 binary search trees one extra bit information per node color either red black restricting way nodes colored path root leaf redblack trees ensure tree balanced ie guarantee basic dynamic set operations redblack tree take olog n time worst case binary search tree redblack tree 1 every node either red black 2 root black 3 node red children black 4 every simple path root node descendant leaf contains number black nodes four redblack properties expressible java use four properties together basic properties binary search trees dene repok method ie java predicate checks representation invariant class invariant corresponding data structure case repok checks input redblack tree figure 5 gives part javautiltreemap declaration figure 6 gives fragment code repok representing third redblack tree property red nodes black children generation redblack trees particularly interesting framework due complex structure ie primitive elds back pointers etc next section present dierent techniques used generate test inputs implementation redblack trees javautiltreemap illustrate test input generation several helper methods put remove methods class javautiltreemap responsible adding deleting node corresponding public class treemap entry root static final boolean static final boolean static class entry implements mapentry object object value entry left entry right entry parent boolean precondition repokroot public object removeobject key public object addobject key figure 5 declaration javautiltreemap boolean repokentry e redhasonlyblackchildren worklistisempty entry currententryworklistremovefirst entry cl currentleft entry cr currentright ifcurrentcolor red ifcl null clcolor red return false ifcr null crcolor red cl null cr null return true figure given key tree note deletion complex operation among standard operations redblack trees involves rotations together auxiliary methods addition together deletion javautiltreemap 300 lines java code implicit precondition put remove methods requires input satisfy class invariant ie repok input must redblack tree 4 test input generation section illustrate three applications model checking test input generation software manipulating complex data structure focus implementation put remove methods redblack trees java treemap library testing criterion use source code level branchcoverage since want compare blackbox whitebox approaches test input gen eration mentioned section 223 framework also handle kinds testing criteria aim generate set nonisomorphic tests meets desired coverage criteria isomorphism among tests dened isomorphism among graphs heap java program viewed edgelabeled node identities permutable primitive values 10 note java semantics allow object allocation dictate exact object identities implies initializing test input concrete representation level setting eld values abstract level using sequence method invocations say regression testing generate identical structures generates isomorphic structures first show model checker used testing executing sequences method calls data structures interface secondly show use execution framework build nonisomorphic input trees given small size used blackbox testing method done symbolically executing java code methods precondition case code repok lastly show framework used whitebox test input generation conservative preconditions used lazy initialization stop analysis infeasible paths also show input constraints computed symbolic execution solved provide inputs actual testing 41 model checking testing model checking clear distinction system analyzed environment system ie inputs system takes whenever environment underapproximated less behaviors considered present actual environment model checking model checking becomes form testing note often case model checking software since environment usually large considering connection one therefore use model checker generate inputs analyze code inputs illustrate idea show one test java treemap library analyzing sequences put remove calls set maximally n elements using jpf model checker figure 7 note example interested coverage code rather correctness hence use model checkers default properties uncaught exceptions important oracle general approach allows general oracles including method postconditions expressed java predicates 42 input generation blackbox testing framework used automatically generate java data structures description method precon public static int public static treemap new treemap public static integer elems static elems new integern int new public static void mainstring args true else figure 7 model checking testing ditions note sequential code generalized symbolic execution explores paths nonisomorphic puts therefore generate nonisomorphic input structures satisfy precondition applying generalized symbolic execution code precondition input structure use otheshelf constraint solvers solving constraints path condition thus obtaining test input test inputs used blackbox testing method test drawback approach relationship inputs code coverage hand one would interested covering input specication rather code test blackbox method achieves full coverage input structures given bound order test put remove methods automatically generated nonisomorphic input trees given small size java description methods precondition ie structural invariant thus eliminating need construct inputs using sequence method calls framework symbolically executes repok generates input structures whenever repok returns true put limit number generated objects whenever size vector stores objects created lazy initialization see section 2 reaches limit model checker backtracks result input structures satisfying repok size specied limit created approach contrasted brute force ap proach one rst generate possible trees given size according class denition would apply repok select valid redblack trees approach scales better since generate trees demand lazy initialization backtrack soon redblack tree property violated thus pruning large portions search space important note actual structure repok crucial eciency method repok would rst evaluate tree end determine whether tree valid approach would equivalent generating trees pruning 43 input generation whitebox testing symbolic execution framework used input generation white box testing generate inputs meet given testing criterion framework used symbolically execute method test model check properties encode testing criterion counterexamples properties represent paths satisfy criterion every path framework also reports input structure path condition primitive input values together dene set constraints inputs satisfy order execute path2 particular characteristic framework uses method preconditions two phases input generation eliminate infeasible structures conservative precondition deal partially initialized structures used lazy initialization see section 431 counterexample found structural constraint path used input concrete precondition one used section 42 solve constraints valid inputs see section 431 conservative preconditions use preconditions initializing elds see figure 3 particular eld initialized value violates precondition notice evaluate precondition structure still may uninitialized elds therefore require precondition conservative ie return false initialized elds structure violate constraint precondition consider analysis remove method redblack tree implementations method precondition class invariant redblack tree data structure ie repok java predicate conservative version precondition used lazy initialization illustrated figure 8 boolean ags left initialized right initialized added code instrumentation keep track uninitialized input elds see section 224 code conservative repok identical repok exception constraints encoded repok evaluated initialized elds example assume three input trees illustrated figure 9 created analysis remove method lazy initialization step round lled nodes represent entries colored black empty nodes represent entries colored red null nodes represented cloud denotes uninitialized eld intuitively representing set nodes since lazily initialized dierent nodes simplicity presentation omit represent key value elds figure 9 also shows results evaluating conservative repok tree structures rst tree violates repok matter concrete value cloud since red nodes cannot red children case model checker backtrack consider structure second tree concrete structure satises repok third tree represents concrete trees may may satisfy repok conservative repok returns true rather dont know analysis continues note lazy initialization input elds framework related materialization summary nodes shape analysis 33 conservative preconditions formulated context abstract interpre tation would like explore connections 2our framework also reports thread scheduling informa tion case multithreaded code boolean conservativerepokentry e redhasonlyblackchildren worklistisempty entry currententryworklistremovefirst entry cl currentleft entry cr currentright currentcolor red currentleftisinitialized cl null clcolor red return false currentrightisinitialized cr null crcolor red return false currentleftisinitialized cl null currentrightisinitialized cr null return true figure 8 predicate conservative repok false true true dont know figure 9 evaluation conservative repok 3 structures 432 handling destructive updates lazy initialization algorithm builds input structures needed basis rst accessed symbolic execution code analysis performs destructive updates structure inputs lost create test inputs therefore need reconstruct input structures example consider structures leaves symbolic execution tree depicted figure 4 result destructive update structures longer contain information input structure link rst two nodes order recover original input structures keep mappings objects uninitialized elds objects solution satisfies repok solution symbolic input structure constraint 4 violated satisfying conservativerepok figure 10 concretization symbolic structures created elds initialized mappings used reconstruct input structures note whenever precondition needs evaluated lazy initialization rst reconstruct input structures evaluate precondition reconstructed input structures 433 solving constraints result symbolically executing particular program path heap structure encodes constraints reference elds path condition encodes constraints primitive data constraints dene inputs allow execution path order obtain actual test inputs solve constraints ie build actual java data structures used testing framework solve constraints separately structures primitive data rst convert symbolic structures concrete structures uninitialized elds also satisfy methods precondition method pre conditions amounts simply setting uninitialized elds null otherwise symbolic input structure satises conservative precondition used input code concrete precondition symbolically executed obtain concrete structure way similar test input generation method described section 42 constraints path condition solved using otheshelf constraint solver note concretizations symbolic structure satises conservative precondition valid solutions example given figure 10 5 experiments mentioned measured branchcoverage methods treemap class simplicity consider 3 helper methods deleteentry del fixafterdeletetion xd fixafterinsertion xi optimal3 branchcoverage achieved methods 86 19 22 deleteentry 100 20 20 fixafterdeletion 88 14 16 fixafterinsertion note 100 statement coverage obtained 3 methods uncovered branches missing else branches option always taken 3the rest branches shown infeasible resources coverage n time mem states del xd xi 28 3 24 23 730 68 5 75 6 memory table 1 model checking testing results obtained using jpf model checker version 311 22 ghz dual processor pentium 1 gb memory running windows 2000 java 142 51 model checking testing results table 1 show coverage achieved three methods model checking code figure 7 dierent values n number entries added treemap coverage numbers gathered using jpfs facility calculate branchcoverage bytecode level execution simple transformation done obtain branchcoverage source code level note technique also used branchcoverage calculations rest section table also contains time taken seconds memory consumed mb number states generated model checking results indicate approach scale well size 4 results give appearance actually good fast low memory reasonable coverage exponential explosion becomes apparent size 5 size 6 cannot handled entirety fixafterdeletion 100 branchcoverage achieved fixafterdeletion called deleteentry hence surprising large jump coverage size 3 4 advantage model checking approach obtains good path behavioral coverage small input domains well systems testing fundamentally hard concurrent systems domain considered namely sequential programs manipulating complex data technique testing could appropriate rst pass nding errors obtain good structural coverage one needs sophisticated approach 52 blackbox table 2 shows results blackbox structural coverage xed size n input trees generated symbolic execution repok method using jpf input trees possible node deletions one new insertion executed tests code coverage measured also report total number trees created structs specic size n parenthesis number trees size n given well many structures considered candidates lazy initialization code within repok since memory consumption minimal less 10mb cases shown report time taken generate trees time running tests negligible note since structures generated given size results include smaller structures well statistics coverage structs candidates time tests del xd xi table 2 blackbox structural tests statistics coverage time mem tests del xd xi table 3 whitebox tests 1 minute trees required achieve optimal coverage code generated size 5 note trees size n created analyzing sequences put remove operations section 51 subset trees size n allowed repok believe due class invariant repok permissive property maintained sequences putremove op erations indeed say performance concerns methods may maintain properties stronger stated class invariant thereby disallowing certain structures otherwise valid generated executions method sequences 53 whitebox results whitebox analysis methods treemap obtain set test inputs achieve optimal branchcoverage three methods given table 3 report time taken seconds memory usage mb number tests run number tests generated removing duplicates parenthesis coverage obtained although mention input trees considering test input consists input tree well node putremove note dont parameterize results size trees table 2 since goal cover branches achieved dierent size trees however limit size trees looking size 5 smaller expected coverage obtained optimal many duplicates amongst input trees generated cover 53 branches code 11 unique input trees required 11 trees made trees size 1 2 3 4 two trees size 5 8 possible trees 54 discussion lazy initialization repok use blackbox test input generation compared approach taken korat 10 korat generates inputs constraints given java predicates uses backtracking also monitors executions repok fully initialized inputs within priori given input size example used number candidate structures two techniques consider similar however one also introduces integer values structures approach considers lot fewer structures since uses symbolic execution together integer constraint solving whereas korat enumerate integer elds fact whitebox approach 11 test inputs required versus 84 obtain optimal coverage blackbox approach illustrates power using goaldirected whitebox approach blind blackbox approach test input generation obtaining high coverage believe complicated structural invariants dierence test input size black white box approach would even pronounced drawback current approach cannot determine whether code unreachable code contains cycles case redblack tree examples considered considering techniques automatic invariant generation 38 use shapepredicates abstraction address problem inherent drawback symbolic execution strength decision procedures used check infeasible path conditions currently deal linear integer constraints hope add powerful decision procedures near future note experimented dierent approaches representing data structures eg could completely symbolic represented partially initialized java structures context work presented used latter approach facilitates evaluation preconditions written java predicates 6 related work 61 specicationbased testing idea using constraints represent inputs dates back least three decades 14 29 31 41 idea implemented various tools including effigy 31 tegtgen 32 inka 24 prior work solve constraints primitive data integers booleans solve constraints complex structures requires dierent constraint solving techniques recent frameworks notably testera 35 korat 1034 support nonisomorphic generation complex structures redblack trees testera generates inputs constraints given alloy rstorder declarative language based relations testera uses otheshelf sat solvers solve constraints already discussed korat section 54 korat algorithm recently included asml test generator 20 enable generation structures testera korat focus solving structural constraints directly solve constraints primitive data instead systematically try primitive values within given bounds may ecient testera korat used blackbox testing whitebox setting early paper goodenough gerhart 23 emphasizes importance specicationbased testing various projects automate test case generation specications z specications 18 uml statecharts 37 adl specications 12 asml specications 25 specications typically involve structurally complex inputs address objectoriented programs doong frankl 19 use algebraic specications generate tests including oracles object oriented programs astoot tool generates sequences interface events checks whether resulting objects observationally equivalent specied algebraic specication although interested generating tests covering input structures blackbox code white box using algebraic specication create additional tests check functional requirements code straightforward extension gargantini heitmeyer 21 use model checker generate tests violate known properties specication given scr notation ammann black 3 4 combine model checking mutation analysis generate test cases specication rayadurgam et al use structural coverage based approach generate test cases specications given rsmle using model checker 26 lee et al 28 dene framework using temporal logic specify dataow test coverage 62 static analysis threevaluedlogic analyzer tvla 3342 rst static analysis system verify preservation list structure programs perform list reversals via destructive updates input list tvla used analyze small programs manipulate doubly linked lists circular lists well sorting programs recently tvla system extended also deal preconditions shapegraphs 44 pointer assertion logic engine pale 36 verify large class data structures represented spanning tree back bone possibly additional pointers data structures include doubly linked lists trees parent pointers threaded trees static analysis program properties promising approach ensuring program correctness long run current static analysis techniques verify limited program properties example none techniques verify correctness implementations balanced trees redblack trees testing hand general verify decidable program property realistically large implementations bounded inputs 63 software model checking lot recent interest applying model checking software 781517222743 work focused checking event sequences specied temporal logic api usage rules form nite state machines approaches oer strong guarantees program successfully checked inputexecution would lead error however typically consider linked data structures considered reduce state space explored check data structures work shows enable otheshelf model checker check properties complex structures taking account complex preconditions algorithms implemented straightforward fashion enable model checkers support dynamic structures check structural properties recently two popular software model checkers blast slam based predicate abstraction used whitebox test input generation 2 6 cases goal generate tests cover specic predicate combination predicates techniques focus generating complex test inputs class invariant redblack trees would also like handle complex preconditions thank reviewers detailed comments allowed us greatly improve paper 7 conclusion 8 main contribution work show com plex preconditions used allow ecient symbolic execution code manipulating complex data generate test inputs obtaining high code coverage particular illustrated use conservative precondition evaluates structures ie structures fully initialized eliminate structures cannot lead valid concrete inputs achieve stated coverage conservative precondition seen abstract version concrete precondition since disallow 3 valid structures might accept structures instantiated concrete structures fail concrete precondition although created conservative precondition hand would like investigate 4 generate directly concrete precondition using techniques abstract interpretation experiments precondition class invariant approach handle precondition expressed java predicate 5 also showed two approaches using model checking symbolic execution testing firstly traditional approach model checking perspec tive one simply applies model checking system test approach obtain high levels behavioral coverage small congurations data 6 structures secondly showed symbolically executing code precondition one eciently obtain tests suitable blackbox testing second ap 7 proach shows exibility lazy initialization approach symbolic execution resembles algorithm employed korat tool 10 highly successful generating test inputs 8 believe exible approach testing complex software important end think techniques covered seen continuum following fashion code analyzed doesnt full specication one use blackbox approach considers structure inputs generate tests 10 note structure inputs must known case given java predicate specication exist example algebraic specication used 19 specication centered approach test input genera tion used augment note requires specication given notation acceptable model checker java case point blackbox approach exhausted one needs consider code whitebox generate additional tests although considered simple coverage criteria drive symbolic execution based test input generation one specify criteria expressed prop erties model checker example predicate coverage 26 lastly testing sucient cases example testing concurrent program notoriously incomplete powerful technique program model checking used 13 acknowledgments 14 would like thank darko marinov insightful discussions sharing us java implementation r economic impacts inadequate infrastructure software testing specicationbased coverage metric evaluate test sets using model checking generate tests specications experiments test case generation runtime analysis automatically validating temporal safety properties interfaces slam project debugging system software via static analysis software testing techniques korat automated testing based java predicates international symposium software testing analysis issta experimental evaluation verication validation tools martian rover software structural specicationbased testing automated support experimental evaluation model checking system generate test data symbolically execute programs introduction algorithms automating formal specication based using model model checking programming languages using verisoft toward theory test data selection temporal logic based theory test coverage generation approach program testing generalized symbolic execution model checking testing symbolic execution program testing automated test data generation programs procedures tvla system implementing static analyses testing using solver imperative constraints testera novel framework automated testing java programs pointer assertion logic engine generating tests uml specications verication java programs using symbolic execution invariant generation verication time partitioning deos scheduler kernel omega test fast practical integer programming algorithm dependence analysis automated generation program test data solving shapeanalysis problems languages destructive updating model checking programs symbolically computing mostprecise abstract operations shape analysis tr introduction algorithms astoot approach testing objectoriented programs model checking programming languages using verisoft solving shapeanalysis problems languages destructive updating automatic test data generation using constraint solving techniques deadlock detection tool concurrent java programs using model checking generate tests requirements specifications structural specificationbased testing model checking bandera verification time partitioning deos scheduler kernel approach program testing symbolic execution program testing pointer assertion logic engine automatically validating temporal safety properties interfaces sscplamscp project software testing techniques generating finite state machines abstract state machines korat model checking programs specificationbased coverage metric evaluate test sets temporal logic based theory test coverage generation automating formal specificationbased testing tvla toward theory test data selection using model checking generate tests specifications testera generating tests counterexamples ctr willem visser corina psreanu radek pelnek test input generation redblack trees using abstraction proceedings 20th ieeeacm international conference automated software engineering november 0711 2005 long beach ca usa automated test generation engineering applications proceedings 20th ieeeacm international conference automated software engineering november 0711 2005 long beach ca usa nikolai tillmann wolfram schulte parameterized unit tests unit meister acm sigsoft software engineering notes v30 n5 september 2005 colin blundell dimitra giannakopoulou corina psreanu assumeguarantee testing acm sigsoft software engineering notes v31 n2 march 2006 patrice godefroid compositional dynamic test generation acm sigplan notices v42 n1 january 2007 petri ihantola creating visualizing test data programming exercises informatics education v6 n1 p81102 january 2007 carlos pacheco shuvendu k lahiri michael ernst thomas ball feedbackdirected random test generation proceedings 29th international conference software engineering p7584 may 2026 2007 koushik sen darko marinov gul agha cute concolic unit testing engine c acm sigsoft software engineering notes v30 n5 september 2005 rupak majumdar koushik sen hybrid concolic testing proceedings 29th international conference software engineering p416426 may 2026 2007 nikolai tillmann wolfram schulte parameterized unit tests acm sigsoft software engineering notes v30 n5 september 2005 michael emmi rupak majumdar koushik sen dynamic test input generation database applications proceedings 2007 international symposium software testing analysis july 0912 2007 london united kingdom willem visser corina psreanu radek pelnek test input generation java containers using state matching proceedings 2006 international symposium software testing analysis july 1720 2006 portland maine usa tao xie jianjun zhao framework tool supports generating test inputs aspectj programs proceedings 5th international conference aspectoriented software development march 2024 2006 bonn germany sarfraz khurshid yuk lai suen generalizing symbolic execution library classes acm sigsoft software engineering notes v31 n1 january 2006 james h andrews susmita haldar yong lei felix chun hang li tool support randomized unit testing proceedings 1st international workshop random testing july 2020 2006 portland maine marat boshernitsan roongko doong alberto savoia daikon agitator lessons challenges building commercial tool developer testing proceedings 2006 international symposium software testing analysis july 1720 2006 portland maine usa arindam chakrabarti patrice godefroid software partitioning effective automated unit testing proceedings 6th acm ieee international conference embedded software october 2225 2006 seoul korea patrice godefroid nils klarlund koushik sen dart directed automated random testing acm sigplan notices v40 n6 june 2005 marcelo damorim steven lauterburg darko marinov delta execution efficient statespace exploration objectoriented programs proceedings 2007 international symposium software testing analysis july 0912 2007 london united kingdom aysu betin tevfik bultan mikael lindvall benjamin lux stefan topp eliminating synchronization faults air traffic control software via design verification concurrency controllers automated software engineering v14 n2 p129178 june 2007 paul darga chandrasekhar boyapati efficient software model checking data structure properties acm sigplan notices v41 n10 october 2006 marc fisher ii gregg rothermel darren brown mingming cao curtis cook margaret burnett integrating automated test generation wysiwyt spreadsheet testing methodology acm transactions software engineering methodology tosem v15 n2 p150194 april 2006
parallel algorithm reconstruct bounding surfaces 3d images growing size 3d digital images causes sequential algorithms less less usable whole images parallelization algorithm often required developed algorithm named sewing faces synthesizes geometrical topological information bounding surface 6connected3d objects call combined information skin paper present parallelization sewing faces based splitting 3d images several subblocks subblocks processed gluing step consists merging subskins get final skin moreover propose finegrain approach subblock processed several parallel processors b introduction past decade 3d digitalization techniques magnetic resonance imaging extensively developed opened new research topics 3d digital image processing primary importance many application domains medical imaging classical notions 2d image processing extended 3d pixels voxels 4 connectivity 6connectivity etc 2d algorithms adapted 3d problems 4 2 process amount data increased order magnitude n 2 pixels 2d image n 3 voxels 3d image n size image edges consequence time complexity 3d algorithms also increased order magnitude order still get efficient algorithms terms running time deal growing size images algorithms parallelized among many problems 3d image processing focus paper problem reconstruction bounding surfaces 6connected objects 3d digital images 3d digital image characterized 3d integer matrix called block integer iv block defines value associated volume element voxel v image image describes set objects organs medical images contour object composed voxels belong object least one adjacent voxels background set voxels compute bounding surface object set closed surfaces enclosing object developed 6 sequential algorithm bounding surfaces reconstruction objective paper present parallel version algorithm parallelization based decomposition 3d block subblocks subblock fragment bounding surface computed fragments determined final step consists merging together order retrieve complete bounding surface paper organized follows section 2 recalls principles bounding surfaces reconstruction section 3 presents basic notions 3d digital images section 4 briefly recalls sequential algorithm bounding surfaces reconstruction section 5 discusses subblocks decomposition sections 6 7 respectively present coarsegrain finegrain parallelizations algorithm section 8 briefly show transform reconstructed surface 2d mesh finally section 9 presents experimental results compares approach related works notions introduced paper illustrated figures since always easy visualize 3d presented using 2d analogy surface reconstruction closed surfaces bound object determined two different ways ffl using method approximation surface reconstructed interpolating discretized data marching cubes 5 developed lorensen cline method builds triangulation surface various extensions method proposed either defining heuristic solve ambiguous cases 9 reducing number generated triangles faster reconstructions developed based parallelized versions algorithm 7 others use octree abstract data type 3 reduces number scanned voxels ffl using exact method surface composed faces shared voxel object voxel background method proposed artzy et al 1 efficiency various reconstruction algorithms strongly related type scan used determine surface hence surface reconstruction realized either complete search among voxels block contour following voxels object contour scanned contour following approach yields efficient algorithms whose time complexity proportional number voxels contour instead number voxels whole block marching cubes algorithm based wholeblock scanning method proposed 1 relies contour following determination bounding surface object useful visualize object also manipulate using techniques distortion surface transformation surface surface mesh derefinement surface merging adjacent coplanar faces reversible polyhedrization discretized volumes former case surface needs defined geometrical information ie list triangles case approximation methods list faces case exact method latter case however surface must defined geometrical information also topological information ie information stating faces connected together note course possible recover topological information geometrical one face one scan faces defining surface order find adjacent faces ie ones share one edge surface contains n faces topological reconstruction 2 avoid quadratic operation topological information must collected together geometrical information figure 1 block algorithm developed 6 reconstructs bounding surface 6connected object 3d digital image called sewing faces characteristics following ffl exact method extracts faces belonging voxel object voxel background ffl based contour following time complexity therefore proportional number voxels contour ffl synthesizes geometrical topological information case reconstructed surface named skin topological information synthesized using sews stating two adjacent faces bounding surface connected together ffl time space complexity linear according number faces skin proved 6 3 notions 3d digital images 3d block see figure 1 seen stack adjacent voxel slices pushed together according one three axes x z voxel made six faces whose types numbered shown figure 2 twelve edges face opposite face voxel instance face type 2 opposite face type 5 cf figure 2 following call face face type two faces share one edge adjacent two voxels share one face 6adjacent share one edge 18adjacent see figure 3 following call object block set 6connected voxels two voxels set exists path x 6adjacent 6connected block b contains one object say b made several 6connected components call set objects composed object denote theta theta voxels object theta background boolean function defined block b denoted theta b v states whether voxel v belongs object theta several ways define function theta b v depending z z figure 2 type voxel faces b face shared u v edge shared u v figure 3 u v 6adjacent b u v 18adjacent type digitalized data block already thresholded may define theta b userdefined block segmented may use function theta b true contrary want define object complement background may define theta b sophisticated definitions possible object contains n holes bounding surface made 1 n borders connected together border closed surface made adjacent faces sewed together figure 4 illustrates notion 1hole object using 2d analogy since objects 6connected sets voxels exist three different types sews two adjacent faces border three types relations presented rosenfeld 8 named 1sew 2sew 3sew see figure 5 depend adjacency relation voxels supporting two faces figure 4 2d object one hole two borders 3sew 2sew 1sew figure 5 three types sews 6connected object n holes border upsilon pair ffl f set faces separate 6connected component background closed ffl r sewing relation set 4tuples f expressing faces f 1 f 2 sewed together common edge e using sew type 3 using definition notions skin introduced follows definition 3 skin object characterized n holes union borders denoted j skin composed object union skins denoted theta theta since skin composed object union borders also defined pair f r introduced definition 2 4 sewing faces algorithm skin reconstruction border upsilon reconstructed starting point sewing faces pair v v voxel object contour face v belonging border upsilon pair called startingvoxel either given user determined dichotomous search algorithm depends type 3d image principles sequential version sewing faces following starting voxel algorithm first computes faces belong bounding surface detects among adjacent voxels either 6 18adjacent ones belong contour voxels determines faces also included bounding surface realizes sews adjacent faces skin process iterated adjacent voxels also belong contour stepbystep bounding surface reconstructed based contour following algorithm uses hash table memorize faces already added skin stack store voxels examined uses two main functions getf aces v reat seq v described rely notion neighbor voxel according given face defined type cf figure 2 definition 4 let v voxel whose face type shared voxel u voxel u called neighbor v face denoted nv function getf aces v determines faces v belonging skin face runs follows 1 add 1 face type v f 2 add f four faces type j v adjacent face type nv 2 theta nv b ie neighbor v face j object 3 one face added border steps 1 2 add f face type k v opposite nv 2 theta nv b add r 1sews e added f steps 1 2 3a c push v stack voxels treated hence voxel v entirely treated step particular 2sews ans 3sews adjacent voxels detected yet add hash table faces v added skin function reat seq v determines 6adjacent 18adjacent voxels v one faces belong skin sews faces v share one edge ie realizes 2 3gammasews data structure used reat seq v array indicates face type reference f corresponding face voxel v face already added skin corresponding entry empty face f face already added skin reat seq v defined follows operation add add face twice f ie checks whether given face already belongs f actually adds belong f one adjacent faces v call j belong border face k opposite adjacent j also belongs border neighbor v face k object reat seq v get hash table edge e v shared two faces faces v w object theta b case face j voxel u belongs skin else w object theta b case opposite face face voxel w belongs skin endif endfor using two functions sequential version sewing faces denoted sf seq defined starting voxel v getf aces v empty stack reat seq top stack 5 subblocks decomposition let us suppose blocks deal contain one byte long integers memory size required blocks size 128 3 512 3 1024 3 respectively 2mb 128mb 1gb allow computer run sewing faces largesize data whole block must decomposed subblocks algorithm must processed subblocks size subblocks depends available amount memory general case voxel intensity g bytes long c bytes memory space available subblock storage hold subblocks size l l l l gc 13 using parallel machine decomposition subblocks also useful since bounding surfaces reconstruction algorithm may run simultaneously different subblocks assigned different processors architecture 51 subblocking splitting block subblocks subblocking operation subblock six faces face voxel slice fully defined coordinates origin block size according axes x z subblock block gluing faces gfgf gf gf gf gf gf gf gf gfgfgfgfgfgfgf figure gluing faces forbidden faces subblock subblock sewing faces builds subskin subskins must finally merged get whole skin order able glue subskins together overlap two adjacent subblocks must twoslices wide two subblocks whose origins block b bx 1 whose sizes b 1 z exist two axes ff fi 2 x z bff third axis fl said adjacent subblock two particular types faces emphasized gluing faces forbidden faces illustrated figure 6 using 2d analogy correspond overlap subblocks therefore defined inside whole block faces definition 6 let b subblock f b one faces f b included face block b face f b called forbidden face slice adjacent forbidden face called gluing face execution sewing faces subblock b reconstructs subskin associated b subskin similar skin except border subblock b sews missing missing sews connect face voxel lying one gluing faces face voxel belonging subblock adjacent b notice since sews type 1 involve one voxel always detected even gluing face missing sews therefore type 2 3 must detected memorized treated final gluing phase complete neighboring gluing faces voxels must examined explains presence forbidden faces adjacent gluing faces since voxels forbidden faces treated subblock b forbidden face must shared adjacent subblock considered gluing face adjacency relations subblocks guarantee gluing process subskins possible characterized follows gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf mbsizey bsizey n gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf gf figure 7 valid subblocking definition 7 set fb subblocks belong forbidden face b ffl 8v adjacent valid subblocking respect object notice valid set subblocks need cover whole block part image contains background voxels unnecessary process figure 7 shows valid sub blocking using 2d analogy general case easy automatically split block valid subblocking whose subblocks separately processed 52 gluing phase subskins different subblocks reconstructed must merged together get final skin process requires realization missing sews call whole process merging sewing gluing phase subblock b subskin characterized pair set faces belonging subskin b r b corresponding set fully realized sews subskin computation missing sews called halfsews memorized defined follows definition 8 halfsew quintuple e f coord ffl e edge sewed ffl type sew realize ffl f face set f sharing edge e ffl coord coordinates voxel v owns f ffl type unknown face share edge e face f subblock information memorized using either hash table list ordered according field coord gluing process realized two steps first one consists merging together different sets f b computed subblocks second step concerns set rb defining sews faces fb step realized building fullsews pairs halfsews describing two parts sew definition 9 fullsew composed two halfsews characterized define coordinates two adjacent voxels involved sew end gluing process skin describes geometry topology borders pointed starting voxels given beginning 53 fragmentation objects following problem occurs decomposing block subblocks 6connected object contained block fragmented different subblocks given subblock fragment object may 6connected problem carefully taken account skin reconstruction incorrect figure 8 illustrates situation using 2d analogy initial block splitted two subblocks overlap two slices gluing forbidden faces 6connected object distributed two subblocks way subblock 2 two nonconnected fragments object therefore algorithm subblock 2 runs one starting voxel one two fragments reconstructed since realistic expect user give many starting voxels fragments objects different subblocks problem must automatically solved method realized gluing faces voxel contour lies gluing face adjacent voxels belonging forbidden face may also belong contour therefore considered new starting voxels adjacent subblock figure 8 let two voxels drawn starting voxel starting voxel new starting voxel figure 8 fragmentation 6gammaconnected object non 6gammaconnected fragments dark grey starting voxels subblock processing subblock 1 detects subskin reconstructing gets subblock 2 new starting voxel drawn black pushed subblock 1 stack subblock 2 part skin lost also send subblock 2 starting voxel voxel mentioned figure subblock 2 discard voxel since already treated constructing small fragment top figure 8 starting voxel vice versa subblock 2 send two new starting voxels subblock 1 also discarded subblock 1 since already treated mecanism guarantees whole skin finally reconstructed consequence one startingvoxel v described section 4 per subblock required beginning algorithm 6 coarsegrain parallelization coarsegrain parallelization sewing faces based notions subblocking gluing phase idea decompose 3d block data subblocks defined section 5 subskins subblock computed simultaneously different processors subskins determined final gluing phase realized computation subskin similar sequential version except voxels gluing faces may induce missing sews voxel following steps must realized 1 store corresponding halfsew defined definition 8 order later compute fullsew 2 determine voxel v 0 forbidden face treated realize sew 3 determine subblock b j owns v 0 slice forbidden stack voxels subblock b j new starting voxel allows solve fragmentation problem introduced section 53 four points realized function halfsews notice order realize point 3 subblock know origin size subblocks point 4 realized either message passing mecanism distributed memory processor using shared memory share memory machine parallel version algorithm denoted sf par obtained changing function reat seq v reat par v follows reat par v get hash table edge e v shared two faces faces v e defines missing sew halfsews else w object theta b case face j voxel u belongs skin else w object theta b case opposite face face voxel w belongs skin endif endif endfor subblocks terminated execution subskin characterized gluing process begin explained section 52 half sews associated subblock memorized ordered lists gluing phase consists therefore scanning lists order complete sews due ordering lists according coordinates supporting voxels process linear relatively length lists number voxels treated subblock obviously depends objects considered also subblocking subblocking may datadriven whole image scanned order detect objects splitting block method used 7 achieve loadbalancing marching cubes parallelization whole block scanning terribly costeffective compared contour following used sewing faces get good time performance moreover believe good load balancing strongly related domain application given type images instance brain images obtained magnetic resonance imaging techniques images treated rather similar relatively question loadbalancing therefore think using sewing faces given field preliminary study must conducted set standard images order detect appropriate subblock decomposition result effficent loadbalancing decomposition may example split block either cubic subblocks slices 7 finegrain parallelization finegrain parallelization sewing faces consists allowing several processors deal subblock obviously input data data structures must shared processors running sewing faces subblock consequence main difficulty parallelization prevent data corruption let us see detail corruption problems may arise possible datacorruption readonly ffl hash table array faces new written hash table previous version old currently stored hash table contains values stored new two arrays must merged moreover 1sews faces faces new v faces old new v j faces old faces new v j old new v faces old must added r merging step access hash table array faces v processors must forbidden using semaphorelike method ffl stack voxels possible datacorruption since voxels pushed poped common stack depending stack implementation semaphorelike operations may used guarantee correctness stack information set f faces simply implemented using array new skin face f detected one getf aces execution next available face number f must read incremented using indivisible instruction semaphorelike operation ffl set r sews data curruption possible r writeonly file ffl set halfsews implemented writeonly disk file therefore data corruption possible moreover gluing process easily deal duplicated halfsews omitting case arise finegrain parallelization sewing faces solves load balancing problem general case processors executing algorithm subblock share one stack voxels one hash table etc result finish execution time stack voxels empty finegrain approach used alone without coarsegrain parallelization loadbalancing always optimal finegrain parallelization may combined coarsegrain decomposition using cluster sharememory processors different subblocks assigned different machines cluster share memory machine different processors may compute subskin associated one subblock shared stack voxels embedding far realized topological operations adding faces set f adding sews set r without considering real coordinates vertices therefore extracted surface topological surface order visualize must transformed geometrical surface ie 2d mesh process called embedding face embedded 3d space becomes facet convert faces facets starting point required real table 1 execution time related sequential version sf size 3d block number faces time 260 316656 60 300 421968 80 coordinates four vertices given face f border type face f sews types easy deduce face arises four faces sewed f compute coordinates four faces adjacent f thus obtain real coordinates faces fb get facets three dimensions basic parallelepiped representing one voxel integer values embedding skin require computation real values embedding process f number faces skin 9 results already proved 6 sequential version sewing faces linear time space according number faces skin linearity still achieved coarsegrain finegrain approach tables 1 2 3 focus execution time coarsegrain version versus sequential version input data consist digital balls growing size 230 3 300 3 image contains one object whose skin made one border starting voxels automatically detected dichotomous algorithm subblockings obtained splitting block 8 subblocks b i07 identical sizes tests summarized tables 1 2 3 realized intel pentium 133 mhz computer running linux indicated times user system times table results obtained sequential version sewing faces number faces elapsed time seconds indicated indicated times include block loading research starting voxel skin building table 2 shows elapsed time coarsegrain version sewing faces elementary subblock measured time includes subblock loading research starting voxel subskin building halfsews detection third column indicates elapsed time related gluing process finally last column shows theoretical time obtained multiprocessor architecture subblocks processed altogether time obtained adding gluing time elementary subblock time table 3 points time saved coarsegrain approach shows percentage last column indicates speedup factor due coarsegrain approach underlines fact using 8 processors get speedup factor 5 let us study influence subblocking parallel computation time efficiency obviously depends number structure subblocks number table 2 execution time related coarsegrain parallel version sf par size 3d block time compute subblock time gluing phase total time 300 11 05 16 table 3 speedup obtained coarsegrain parallelization size 3d block time saved speedup 260 8000 50 300 8000 50 subblocks large gluing phase become timeconsuming due increasing number missing sews problem studied synthetic block size 225 theta 300 theta 225 representing bar size 210 theta 300 theta 210 block decomposed vertical subblocks equal width order analyze influence number subblocks efficiency parallel version sewing faces executed abovementioned block increasing number subblocks experiment realized sgi r4400 figure 9 shows experimental results indicates computation time decreases number subblocks reach 12 subblocks 12 subblocks computation time remains almost may take advantage lack penality terms computation time increasing number subblocks execute sewing faces 12 subblocks case memory limitation experiment also conducted brain images cf figure 11 using cubic subblocks equal size previous results confirmed certain number subblocks 27 case indicated figure 10 computation time decrease anymore due increasing number missing sews glue figure 12 shows result decomposition two subblocks conclusions proposed paper parallel version reconstruction surface algorithm goal increase time performances also deal large 3d images time subblocks figure 9 parallel time computation bar currently available practical fields medical imaging parallelization based subblock decomposition order compute skin using contour following approach twoslices wide overlapping adjacent subblocks required moreover subblocks must communicate neighbors guarantee computation whole skin initial choice data structures used sequential version sewing faces one stack voxels one hash table voxel faces allows easily fully parallelize using coarsegrain andor finegrain approach moreover notions border composed object subblock overlapping cause parallel version sewing faces flexible notice moreover subblock based algorithm may also useful mono processor machine deal blocks data large fit memory experimental results shown efficiency parallel version algorithm synthetic balls data brain images r octrees faster isosurface generation digital topology marching cubes sewing faces wu digital surfaces allen van gelder jane wilhelms topological considerations isosurface generation tr
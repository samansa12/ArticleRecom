elusive atomic register present construction singlewriter multiplereader atomic register singlewriter singlereader atomic registers complexity construction asymptotically optimal om2 shared singlewriter singlereader safe bits required construct singlewriter mreader nbit atomic register b introduction currently accepted theory concurrent computing deeply rooted concept atomic registers atomic register data object read written one processes according following assumption several read write operations register enabled simultaneously different processes operations executed sequence one concurrently assumption strongly suggests wellknown interleaving semantics concurrent computations validity assumption thus cornerstone justifying present theory concurrent computing one way check validity assumption show atomic register constructed using set realistic registers read written concurrently different processes construction process reads writes constructed atomic register invoking program within program registers realistic kind read written different programs invoked different processes concurrently required however net effect resembles serial invocation programs restricted waitfree ie synchronization primitives p v await unbounded busywait loops allowed restriction guarantees process reads writes constructed atomic register finite amount time regardless activities processes also means read write process immune failure processes also access register waitfreedom restriction distinguishes problem constructing atomic register classic readerswriters problem 6 peterson 16 first suggest problem constructing atomic registers safe registers safe register data object read written concurrently different processes read operation overlaps write operation may return value value domain register read operation overlap operation obtains recently written value leap safe registers atomic registers quite large fortunately divided number smaller steps figure 1 depicts two chains register constructions lead singlewriter singlereader singlebit safe registers kwriter mreader n bit atomic registers notation kmn denotes register written k processes read processes store n bit value step figure labeled reference papers given construction presented henceforth concern singlewriter atomic registers problem constructing multiplereader atomic register singlereader atomic registers mentioned open problem lamport 12 vitanyi awerbuch 23 first solution problem presented us 2 tworeader construction given generalized construct mreader register gamma 1reader registers solution though easy explain understand uses exponential number single safe atomic atomic atomic kmn atomic 12 20 2 4 7 10 13 15 19 3 13 17 18 23 2 4 7 10 13 15 19 16 21 figure 1 two chains register constructions reader atomic registers subsequently several solutions polynomial complexity presented 4 10 13 15 including one given us 19 latter construction generalization tworeader construction paper present construction multiplereader atomic register based upon solution 19 presentation construction differs 19 two respects first solution presented optimal complexity whereas one given 19 actually optimal solution attained combining solution 19 constructions lamport 12 peterson 16 see 19 details second correctness proof presented paper rigorous formal hope easier understand proof presented 19 rest paper organized follows section 2 formally define problem constructing mreader atomic register singlereader atomic registers section 3 present construction informal description construction presented section 4 formal correctness proof presented section 5 proof makes use several lemmas stated proved appendix concluding remarks appear section 6 register construction register constructions defined number different ways choice definitions based simplicity convenience order avoid confusion henceforth capitalize terms read write apply constructed register leave uncapitalized apply variables used construction 2 view writer reader construction program invoked process order write read value register program writer one input parameter indicating value written similarly program reader one output parameter indicating value read example see constructions depicted figures 2 3 variable construction singlereader singlewriter atomic register restriction arises since aim construct multiplereader register singlereader registers also require variables bounded size simple solution variables unbounded 23 mentioned introduction program construction waitfree ie synchronization primitives busywait loops allowed formal definition waitfreedom refer 1 next define several concepts needed state correctness condition multiplereader construction definitions apply given construction state assignment values variables construction note programs program counter considered variable construction one state designated initial state 2 event execution statement program 2 u two states construction state u result executing statement state e event corresponding statement execution say e enabled state write e u history construction sequence 0 initial state 2 precedes another event f history iff e occurs f historydefinition set events history corresponding complete program execution called operation operation p precedes another operation q history iff event p precedes events q 2 observe precedes relation irreflexive total order events irreflexive partial order operations proof correctness construction sufficient consider histories initial write operation precedes operations incomplete program executions ie operations deal histories note assuming initial write operation value read read operation matched written write operation equivalent defining initial state equal results initial write operation note also history incomplete operations extended one complete operations possible since programs required wait free dealing complete operations value read written constructed register operation welldefined notation denote ith operation writer denotes initial write 2 following lamport 12 define correctness condition construction follows let h history construction h said atomic iff exists function oe maps every read operation h natural number w write operation h following three conditions hold ffl integrity read operation r h value read r value written w oer ffl proximity read operation r h r precede write operation write operation w oer1 precede r ffl precedence two read operations r h r precedes oer oesdefinition register construction correct iff histories atomic 2 3 multireader construction proposed construction depicted figure 2 consists writer program program reader 1 shared variable construction singlereader kind interface writer reader consists variable wri written writer read reader variable rw written reader read writer interface across readers consists set variables rri j j variable rri j written reader read reader j 1 explanation field names appearing type definitions follows alt bit alternates value operation writer done bit distinguishes two values written write operation variables wri new current value constructed register valtype type constructed register old previous value constructed register 1 possible eliminate variables rri construction however including variables simplifies proof correctness rrtype range 1 initialization new valtype initialization begin 0 old new alt new val alt 1 k 1 read qk rw k od 2 k 1 seqk qk phi 1 od 3 k 1 write wrk old new seq1m alt false od 4 k 1 write wrk old new seq1m alt true od returns valtype var define lag initialization begin 0 read x wri 1 write rw xseqi 2 k 1 read vk rrk od 3 read wri 4 f lag 5 k write rri k f lag yseqi yalt od lag returnynew else returnyold fi figure 2 multiplereader construction f lag bit indicates whether read operation returned old new value seq modulo3 integer sequence number phi denotes modulo3 addition variables local program declared either var block variable declared block assumed retain value across invocations corresponding program variable declared var block assumed retain value across invocations initialization assertions follow variable declarations serve define appropriate initial values variables construction state satisfying assertions suitable initial state however recall assumption initial write operation precedes read operations programs construction use special syntax order distinguish reads writes shared variables reads writes local variables program reads given shared variable z executing statement form read u z u local variable type z program writes shared variable z executing statement form write z u variable z consists fields u mtuple ith component u local variable whose value stored ith field z use similar names sometimes identical components u fields z correspondence obvious sequence numbers shared writer readers form basis construction included every value written writer set sequence numbers one per reader write operation writer reads variable rw k obtain recent sequence number reader k new sequence number reader k obtained incrementing read rw k using modulo 3 addition writer writes readers two passes first pass writer writes readers order 1 second pass order reversed done bit distinguishes two passes value writer writes reader includes previous current value constructed register aforementioned set sequence numbers alt done bits reader reads two values writer x reads sequence number obtained first read written back writer value read reader k k values read writer readers used compute f lag bit indicates whether old new value returned note f lag assigned value based upon expressions expressions introduced shorthand defined define section returning value reader writes value reader k k value includes reader f lag bit also sequence number reader alt bit writer obtained reader second read wri calculate space complexity construction determining number shared singlewriter singlereader safe bits required size shared variable construction follows consists 2m consists 2 bits consists 4 bits using construction 22 singlewriter singlereader bbit atomic register constructed using shared singlewriter singlereader safe bits construction yields space complexity 6m 2 6mn 26m 19m 12 well known lower bound space problem construction asymptotically optimal given correctness proof section 5 construction establishes following theorem theorem possible construct singlewriter mreader n bit atomic register using shared singlewriter singlereader safe bits 2 4 informal explanation section explain intuition behind algorithm discussing proof obligations established next section appendix however introduce notation useful ensuing discussion operation program p label statement p loop denotes event corresponding execution statement operation p otherwise loop denotes event corresponding iteration loop loop counter equals j 2 example write operation w construction figure 2 w 1i denotes event w reads rw w 4i denotes event w writes wri second time next define three types control predicates 11 operation program p history let event p p true state history iff event true state iff state occurs event true state iff state occurs event n label loop program p use p n shorthand 8i p ni use p n shorthand 8i p ni use p n shorthand 9i p ni observe loop p implies p particular p strengthens p also requiring p enabled hand loop possible p p assertion holds event loop first enabled following assertions consequence preceding definition let p given definition ffl p examples control predicates observe write operation w construction figure ffl w 1i denotes w read sequence number reader ffl w 4 denotes w begun second pass writes ffl w 4i denotes w completed write reader second pass ffl w 4 denotes w completed second pass writes let b two state assertions assertion unless b holds iff every pair consecutive states history ab holds first state ab holds second state 2 notion unless borrowed unity logic chandy misra 5 informally unless b means becomes true remains true unless b becomes true particular falsified event b either true state prior occurrence event true state following occurrence event requirement b eventually becomes true however case remains true forever operation z local variable p pz denotes final value variable z assigned operation p 2 ready explain intuitive idea algorithm let us examine write operation w writer assume w changes value register old new possible identify two points b within execution w reader returns new reader returns old b let us call interval b uncertainty interval w establishing correctness construction main difficulty ensuring precedence condition definition atomic history given section 2 violated uncertainty interval write operation w amounts proving newthenold conflicts arise interval avoiding newthen old conflicts difficult fact singlereader registers used construction result limitation w must inform readers new value written one time thus uncertainty interval w exist certain points readers informed w value new currently written difficulty encountered construction multiplereader atomic register singlereader ones solution uncertainty interval begins writer writes wr1 second pass ends writer writes wrm second pass words uncertainty interval exists predicate w 4 w 4 true solution therefore guarantee following three properties reads beginning interval return new value reads end interval return old value reads interval result newthenold conflicts state properties precisely define predicate cue relates values written particular write operation existing value variable rri j informally predicate cuew j thought cue reader reader j reader returned new value w predicate defined follows cuew lag rri according reader program values read wrj reader j written write operation w value read rri j satisfies predicate reader j find predicate p true subsequently return value new returning discussion uncertainty interval property a0 ensure cuew j false beginning interval words control predicate w 1i added conjunct ensure value wseqi used definition cuew j available reader prove property lemma 4 appendix based lemma readers return new value beginning uncertainty interval property a0 holds consider operation r reader assume values read wri r written w r begins uncertainty interval w r find p 0 true consequently r return value new thus readers return old value end interval hence property a1 holds finally ensure property a2 holds ie newthenold conflicts avoided within uncertainty interval consider successive read operations reader reader j two cases consider either j j former case difficult operation reader returns value new uncertainty interval w upon completing establishes cuew j show predicate remain stable uncertainty interval reader j also return value new newthenold conflicts arise stability cuew j captured following property w 4 cuew proved lemma 5 appendix latter case interesting direct communication reader reader j j order avoid newthenold conflicts case rely upon either writer completing writes reader j reader k j setting cuew k j true words show w 4 cuew l let us examine assertion detail states uncertainty interval w reader cued reader l hence returns new value smaller j reader write values either w written final values reader j case reader j return new value reader j turn cued reader k case stability cuew k j reader j return new value property proved lemma 9 appendix completes last remaining obligation a2 proof newthenold conflicts occur formal proof next section mirrors intuitive explanation presented 5 proof correctness prove construction correct defining function oe given history showing defined oe meets three conditions integrity proximity precedence defined section 2 following notational conventions definitions used proof notation order avoid using many parentheses define binding order symbols use following list symbols grouped binding power groups ordered highest binding power lowest gamma phi 6 oe let e f two events history e oe f j e precedes f e event corresponding execution statement read z operation p z local variable shared variable value p reads written operation q say operation q determines pz 2 let r two operations reader reader j respectively ry determined write operation sy determined write operation precedes proof fdefinition determinesg precedes sg determines sy definition determinesg ftransitivity oeg operations occur sequentially historyg ng let r read operation suppose write operation ry oer defined follows lag otherwiseobserve oer nonnegative see recall initial write operation assumption precedes read operations thus ry determined w 0 rydone holds implies rf lag holds hence proof integrity let r read operation suppose write operation determines ry lag true definition oe r returns value rynew ie value written w lag false definition oe r returns value ryold ie value written w proof proximity let r operation reader suppose write operation ry precede precede r thus proximity satisfied case since r precede w clearly r 1 next show precede r definition implies rf lag false hence rp 0 also false definition p 0 implies rydone false rxseqi 6 ryseqi rydone false 3i thus either case precede r 2 proof precedence proof precedence quite complicated consists somewhat lengthy case analysis relegated appendix make use lemmas 6 10 11 proved three lemmas based lemmas 4 5 9 discussed informal description previous section let r operation reader operation reader j r precedes proof obligation show oer oes assume write operations determine ry sy respectively observe following ng fby definition oe ffrom observation proved earlier r precedes fby definition oe appendixg fby definition oe fby definition oe fby definition oe oes ng fby definition oe f lag flemmas 6 11 appendixg true 6 discussion shown singlewriter mreader n bit atomic register constructed waitfree manner using singlewriter singlereader atomic registers construction requires om 2 mn shared singlewriter singlereader safe bits asymptotically optimal definition atomicity equivalent given misra 14 axioms atomicity essence require read write operations shrunk point shrinking operations possible iff function oe meets three conditions definition exists recently herlihy wing 8 extended idea atomicity arbitrary abstract data types defining concept linearizability though akin serializability usual correctness criterion concurrent execution transactions subtle differences two concepts one important distinction linearizability local correctness condition whereas serializability refer reader 8 details order prove correctness multiplereader atomic register construction function oe meets three conditions integrity proximity precedence defined every possible history leads long somewhat tedious proofs mainly proof must take account possible ways reads writes overlap keep resulting case analysis proof minimum chose function oe simple depends boolean variable f lag proof appears formidable spite simplification formal reasoning leave doubt validity proof however given length proof seems reasonable inquire whether exist approaches constructing mreader register facilitate simpler correctness arguments briefly describe approach next main idea behind approach develop construction mreader 2 register collection gamma 1reader registers mreader register implemented singlereader registers recursively applying construction first replace gamma 1reader registers gamma 2reader ones replace registers gamma 3reader ones simple implementation mreader register gamma1reader registers depicted figure 3 construction writer reader 1 denoted w r respectively remaining readers denoted 1 sm readers execute program called construction uses two singlereader shared variables wr rw two shared variables ws rs variables name indicates programs read write respectively example ws written writer w read readers 1 sm gamma1 observe readers shared variables fact crucial exploited recursive applications construction local variables used construction similar used construction figure 2 primary advantage recursive construction proof correctness simplified assuming two readers namely r specifically ignore possible interleavings may arise among readers 1 sm gamma1 considering proofs integrity proximity precedence follows quite easily proofs integrity proximity conditions relate individual read operation operations writer proof precedence note precedence condition restricts values returned read operations strict precedence relationship one another readers 1 sm gamma1 initialization lag program new valtype begin old new alt new val alt read q rw program r returns valtype program returns valtype var begin begin read x wr read x ws read wr read ws f lag lag returnxnew returnynew else returnyold figure 3 recursive construction execute identical programs write shared variables precedence relationships interest following read operation r precedes read operation read operation r precedes another read operation r read operation j precedes read operation r read operation j precedes read operation k cases precisely arise special case 2 thus proof correctness mreader register reduces much simpler task proving correctness tworeader construction consisting readers r formal proof correctness construction figure 3 appears 2 construction first presented remainder section informally describe construction works two readers comparing general construction given earlier figure 2 general construction considered assume variables removed see footnote beginning section 3 hence reader program loop index statement 2 1 loop index statement 5 1 begin comparison considering variant tworeader version general construction figure 2 variant shown figure 4 variant statements combined larger atomic statements denote enclosing within angle brackets h note also renamed programs variables coincide names given figure 3 also moved assignment seq1 occurs immediately read rw changes original construction clearly affect constructions correctness thus original construction correct construction shown figure 4 also correct consider code w figure 4 fifth atomic statement w always assigns value true wrdone hence done field wr removed without affecting constructions correctness change w fifth atomic statement replaced single write wr next consider reader first atomic statement assigns values local variables x thus reader ss calculation f lag depends p 0 p 1 defined figure 2 tautology removed change seq2 fields construction serve useful purpose hence removed finally condition reader ss computation f lag also tautology instead removing choose replace another tautology changes clearly affect constructions correctness yield code given figure 4 b figure shown reader r code changed note construction figure 4 b statement reads writes multiple shared variables first statement reader statements eliminated turns slight changes code reader r first statement reader broken three separate statements required program begin old new alt new val alt read q1 rw hread q2 sw hwrite wr old new seq1 seq2 alt false program r returns valtype program returns valtype begin begin read x wr hread x ws read wr read v rs f lag p0 read ws lag p0 p1 f lag returnynew f lag returnynew else returnyold fi else returnyold fi program returns valtype begin begin read q1 rw read v rs lag ydone lag lag returnynew else returnyold fi b figure 4 two intermediate constructions changes reader r follows reader r computes f lag f lag f lag ydone assigns f lag xseq1 xalt rs rather f lag yseq1 yalt reader r always returns xnew last change turns writer longer needs write old value reader r resulting construction given figure 3 completes comparison two constructions although construction figure 3 simpler correctness proof figure 2 simplicity comes price particular shown 2 construction multiplereader register requires number bits exponential number readers acknowledgements would like thank ted herman ut distributed systems discussion group comments paper would also like thank nancy lynch anonymous referees helpful comments appendix remainder correctness proof prove lemmas used proof given section 5 outlined informal discussion algorithm section 4 lemmas 4 5 9 relate uncertainty interval write operation values variables rri j used communication readers lemmas 1 2 3 state elementary results used proving subsequent lemmas lemmas 7 8 used prove results used proof lemma 9 lemmas 6 10 11 consider values returned two successive read operations used proof precedence presented section 5 words concerning structure proofs order juncture proofs reasoning based upon sequences states events words assume total order reads writes internal variables construction wherever possible proofs simplified introduction invariants establishing invariants usually proceed case analysis order events may affect one another example consider write operation w read operation r reader operation w reads sequence number reader operation r writes sequence number writer possible case analysis whether ws read sequence number occurs rs write sequence number whole proofs difficult due numerous interleavings events may potentially occur rather lengthy following definitions used proofs first repeated section 4 let w write operation let 1 cuew lag rri consider history 0 say state prior event e i1 state following e similarly e event prior state i1 e i1 event following state i1 2 lemma 1 let r operation reader rp k holds k let w write operation determines ry holds state prior event r 2k proof program writer 3 therefore transitivity w 1i oe r 3 implies wqi determined either r predecessor r show r determine wqi rp k holds w determines ry therefore transitivity r determines wqi w assigns seqi qi phi 1 implies contrary 1 therefore r determine wqi thus conclude wqi determined predecessor r ie w 1i oe r 1 second part proof assume k 6 0 let state prior event 2k rp k true k 0 following assertion holds state rrk lag rrk k 0 definition p k w determines ry implies walt thus transitivity following assertion holds state rrk lag rrk therefore definition cue cuew k holds state 2 following lemma relates sequence numbers read two consecutive operations reader states values differ one intuition follows order reader sequence number incremented 1 must first written reader rw read writer incremented writer written wri finally read reader two reads wri two consecutive read operations complete sequence events happen lemma 2 let r consecutive operations reader proof prove lemma first showing following assertion invariant prove b invariant consider assertions b0 b4 defined show b0 invariant assertions refer local variables qi seqi writer xseqi reader see b0 invariant observe following ffl b0 initially true statement possibly falsify read writer rw executing statement b0 true establishes b1 ffl statement possibly falsify b1 assignment seqi writer executing statement b1 true establishes b2 ffl statement possibly falsify b2 first write writer wri executing statement b2 true establishes b3 ffl statement possibly falsify b3 read reader wri executing statement b3 true establishes b4 ffl statement possibly falsify b4 write reader rw executing statement b4 true establishes b0 thus conclude b0 delta delta delta b4 invariant also implies b invariant since use invariant b show lemma holds proof obligation follows let denote state prior event r consecutive value rw state equals rxseqi value wriseqi state equals sxseqi since b invariant either state case 1 state case following lemma relates value written rri j operation r reader values written overlapping succeeding write operation w proof lemma makes use lemma 2 lemma 3 let r operation reader let w write operation state w 1i holds value appearing rri j j state written r cuew j false proof let state w 1i holds j indices j assume value appearing rri j state written r proof obligation show cuew j false first show rxseqi 6 wseqi let e event prior state w 1i holds w therefore wqi determined either r successor r former case rxseqi w assigns seqi qi phi 1 implies wseqi 6 rxseqi latter r writes value appearing rri j state state following event e r consecutive operations reader hence lemma 2 wqi equals rxseqi rxseqi phi 1 therefore wseqi equals rxseqi phi 1 rxseqi phi 2 phi modulo3 addition implies wseqi 6 rxseqi thus cases wseqi 6 rxseqi r writes value appearing rri j state holds state consider two values ryseqi wseqi equal wseqi 6 rxseqi rxseqi 6 ryseqi consequently rf lag false therefore 2 rri jf lag false hence cuew j false hand ryseqi 6 wseqi 2 rri jseq 6 wseqi therefore false 2 following lemma ensures new value returned write operation uncertainty interval states reader cue reader j return new value unless writer begun second pass writes readers proof makes use lemmas 1 3 lemma 4 let w write operation j proof prove lemma induction assume result indices less prove consider state interval w 1i w 4 holds need show cuew j false interval j consider state interval question assume cuew j false states interval occur note could first state interval show cuew j also false j rri jf lag false cuew j clearly false remainder proof assume rri jf lag true since rri jf lag false initially exists operation r reader writes value appearing rri j consider events false required remainder proof assume w 1i oe r 1 let e event prior state program reader r writes value appearing rri j state r 5j e w 4 holds e oe therefore ry determined w write operation immediately preceding w latter case ryalt 6 walt therefore cuew j false remainder proof consider case ry determined w therefore rydone false hence definition p 0 rp 0 false show l false well r writes value appearing rri j implies rri jf lag false hence cuew false consider l range program writer w assumption w 1i oe r 1 program reader 3 thus 3 consider state prior event r 2l precedence assertion w 1l w 4 holds state l cuew l false state follows assumption cuew j false j states occur interval w 1i w 4 holds false state induction hypothesis thus either case cuew l false state since w determines ry contrapositive lemma 1 rp l false establishes remaining proof obligation 2 following lemma asserts stability cuew uncertainty interval states cuew true interval remains true interval ends proof makes use lemma 3 lemma 5 let w write operation let j w 4 cuew proof stated safety property preserved trivially event writer readers different reader show also preserved event reader let operation reader consider event 5j event may falsify predicate cuew state prior event let u state following event assume w 4 cuew holds proof obligation show cuew j holds u w 4 holds u trivially program reader following assertion holds u thus prove cuew j holds u suffices prove following lag cuew j false initially rri jf lag initially false value appearing rri j state written operation r reader immediately precedes consider events w 1i r 1 contrapositive lemma 3 w 1i holds w 1i oe r 1 assumption w 4 holds therefore show w determines ry program reader since r precedes w 4 holds ie state prior 5j r 5j oe therefore ry determined either w write operation immediately preceding w latter case ryalt 6 walt therefore rri jalt 6 walt consequently false contrary assumption therefore w determines ry program writer therefore applying 6 therefore w determines sx sy latter implies walt meets two three proof obligations 5 left proof obligation sf lag holds proved next cuew holds r writes value appearing rri j state rf lag holds since w determines ry implies cuew holds state following event r 5i consequently since r consecutive operations reader also holds state prior event 2i definition cue implies following assertion holds state lag rri program reader rri also holds state therefore lag w determines sx sy shown earlier consequence 7 therefore using 8 definition p sp true consequently sf lag holds final proof obligation 2 following lemma considers case operation reader precedes operation reader j j lemma formalizes following property variables reads determined write operation implying assigns variable uncertainty interval write operation first read returns new value second read also returns new value lemma based lemmas 1 4 5 turn used proof precedence lemma r operation reader operation reader j precedes assume ry sy determined write operation proof assume write operation w determines ry sy rp k holds k proof obligation show sp l holds l j first establish w determines sx sy j program reader therefore w determines sy 9 w determines sx sy consider events first dispose former case showing sp 0 true w determines sx sy sydone true therefore definition p 0 sp 0 true remainder proof assume 9 assumption rp k holds k thus lemma 1 program reader 3 therefore 10 next show cuew true state prior event 2i let state following event r 5j rp k holds rf lag true therefore following assertion holds state lag rri w determines ry walt thus following assertion holds state lag rri hence cuew true state thus contrapositive lemma 4 w 1i w 4 holds state program reader r precedes r 5j oe thus 11 therefore w 1i holds state consequently w 4 holds ie w 4 w 4 holds precedence assertion w 4 hold thus w 4 holds ie w 31 oe r 5j therefore observe w 4 holds states r 5j 3 thus lemma 5 holds states interval particular holds state prior program reader j rri holds state prior event implies following assertion holds lag account 10 fact sx sy determined walt therefore lag hence definition p sp true proof obligation 2 writer writes higher numbered readers first lemma needed ensures newthenold conflicts arise history operation higher numbered reader followed operation lower numbered one required property given later lemma 9 lemmas 7 8 given next take care subcases arising proof lemma 9 lemma 7 states reader cued reader j new value uncertainty interval write operation w either account reading final value writer ie w 4i holds account cued turn reader ie holds proof lemma makes use lemmas 1 3 4 5 lemma 7 let w write operation j w 4 cuew proof consider reader state interval w 4 holds need show property holds states interval consider state interval question assume property 12 holds states interval occur note could first state interval show property also holds state assume cuew 4i holds state j proof obligation show cuew k holds state k since rri jf lag false initial state cuew j initially false therefore assume value appearing rri j state written operation r reader consider events w 1i r 1 contrapositive lemma 3 w 1i holds w 1i oe r 1 assumption w 4 holds therefore program reader r writes value appearing rri j state r 5j e e event prior state w 4i holds e oe w 4i therefore therefore ry determined either w immediate predecessor w immediate predecessor w determine ry account true state w determines ry cuew holds state rri jf lag also holds hence r writes value appearing rri j rf lag holds program reader implies rp k true k k show k 0 observe assertion 13 implies r 3 oe e oe w 4i thus w determines ry rydone false implies rp 0 false thus k 0 k 1i program reader 5j thus 13 let u denote state prior event r 2k rp k holds k 0 lemma 1 cuew k holds state u thus contrapositive lemma 4 w 1k w 4 holds u assertion 14 w 1k holds u consequently w 4 holds u ie w 4 w 4 holds u 14 w 4 hold u thus w 4 holds u implies w 31 oe r 2k thus assertion 14 observe w 4 holds states r 2k w 4i since cuew k holds state u lemma 5 cuew k holds states interval particular holds state state following event e establishes proof obligation k case holds state u 15 u lies within interval w 4 holds u occurs consequently assumption property 12 holds states prior interval w 4i holds state u holds state u k however 15 w 4i hold state u therefore cuew k holds state u k consequently applying lemma 5 previous paragraph cuew k also holds state desired 2 according next lemma reader cued reader j uncertainty interval write operation w also cued readers indices j proof follows essentially fact reader writes readers order increasing indices lemma makes use lemmas 3 4 5 turn used proof lemma 9 lemma 8 let w write operation j w 4 cuew proof assume w 4 cuew holds state let k j show cuew holds state rri jf lag false initial state cuew j initially false therefore assume value appearing rri j state written operation r reader let u state following event r 5k since cuew holds since r writes identical values rri j rri k cuew holds u consider events w 1i r 1 contrapositive lemma 3 w 1i holds w 1i oe r 1 assumption w 4 holds therefore program reader r writes value appearing rri j state r 5j e e denotes event prior state since w 4 holds e oe w 4m therefore since w 1i cuew holds state u lemma 4 w 4 holds u words w 4 w 4 holds u 16 w 4 hold state u thus w 4 holds u consequently lemma 5 cuew holds states interval r 5k w 4m particular state establishes proof obligation 2 lemma 9 relates value rrl rrk j states reader l cued reader uncertainty interval write operation w readers indices lower either informed new value writer ie w 4j holds turn cued reader ie holds proof lemma makes use lemmas 7 8 lemma 9 let w write operation l w 4 cuew l proof assume w 4 cuew l holds state brevity let p j shorthand show w 4j p j holds state proof induction inductive step given following assertion shown later holds state w 4 cuew given assumption w 4 cuew l holds inductive step implies one disjuncts consequent holds second disjunct holds inductive step applied time using w 4 cuew l 1 antecedent number readers finite reader indices l appearing second disjunct consequent smaller indices l inductive step applied way finite number times thus finite number applications eventually obtain consequent first disjunct holds since assertions p j accumulated second disjunct application inductive step implies following assertion holds induction terminates 4j assert following state combining ranges two universal quantifications get state implies holds state required proof obligation proof inductive step follows state predicates refer state w 4 cuew l w 4l assumption w 4g w 4l w 4l fdefinition p jg w 4l assumption w 4 cuew l ig w 4l w 4l fdefinition p jg w 4l w 4l fpredicate calculus l ig w 4l fdefinition p 1 g w 4l assumption w 4g w 4l following lemma considers two successive read operations r r though precedes reads recent write operation order writer writes readers situation arise index r greater lemma ensures r computes f lag false computes f lag true lemma based lemmas 1 4 turn used proof precedence lemma 10 let r operation reader operation reader j precedes assume ry sy determined write operations lag false sf lag true program reader w determines sy w precedes w therefore hence rydone false sydone true thus definition p 0 rp 0 false sp 0 true sp 0 true program reader j sf lag true meets half proof obligation remainder proof show rp k false k range implies remaining proof obligation namely rf lag false consider two events 1 former case contrapositive lemma 1 rp k false k desired assume remainder proof k program reader 3 thus using 17 note w 0 1k w 0 4 holds state prior r 2k hence lemma 4 holds state therefore contrapositive lemma 1 rp k false required proof obligation 2 final lemma proof construction considers case operation reader precedes operation reader j j lemma counterpart lemma 6 considers case j lemma based lemmas 1 4 5 9 turn used proof precedence lemma 11 let r operation reader operation reader j precedes assume ry sy determined write operation proof assume write operation w determines ry sy rp k holds k proof obligation show sp l l j consider two events first dispose former case r precedes program reader therefore thus since w determines sy sydone true therefore definition p 0 sp 0 true establishes proof obligation remainder proof assume r 3 ry determined implies rydone false definition p 0 implies rp 0 false 1 program reader therefore let denote state prior event r 2k show w 4 holds rp k true k 0 lemma 1 cuew k holds state hence contrapositive lemma 4 w 1k w 4 holds thus previous precedence assertion following therefore w 1k holds state consequently w 4 holds ie w 4 w 4 holds precedence assertion w 4 hold thus w 4 holds since w 4 cuew k holds state j lemma 9 w 4j holds cuew j holds j former case r precedes implies repeating reasoning following 18 implies sp 0 holds required remainder proof assume cuew j holds since w 4 holds state 2k program reader therefore consider two events first dispose former case r precedes r hence 19 sydone true moreover since therefore definition p 0 sp 0 true establishes proof obligation remainder proof assume 3 r precedes r 3 oe 3 thus 19 following assertion holds therefore assertion 20 w 4 holds states interval r 2k 3 recall cuew j holds state ie state prior event r 2k therefore lemma 5 cuew holds states interval particular holds state following event 2m program reader j rrm state therefore lag w determines sy sy syalt therefore lag consequently definition pm sp true proof obligation 2 r virtue patience concurrent programming without waiting elusive atomic register constructing twowriter atomic registers constructing multireader atomic values nonatomic values parallel program design foundation concurrent control readers writers counterexamples one writer multireader atomic variable construction burns peterson linearizability correctness condition concurrent objects atomic multireader register hoare logic parts ii construct waitfree variables axioms memory access asynchronous hardware systems protocol waitfree concurrent reading writing concurrent reading writing ii multiwriter case correctness atomic multiwriter registers elusive atomic register revisited construct atomic variable converting lamports regular registers atomic registers concurrent reading writing revisited atomic shared register access asynchronous hardware tr axioms memory access asynchronous hardware systems elusive atomic register revisited constructing multireader atomic values nonatomic values protocol waitfree atomic multireader shared variables converting lamports regular register atomic register constructing twowriter atomic registers parallel program design foundation linearizability correctness condition concurrent objects concurrent reading writing concurrent control myampersandldquoreadersmyampersandrdquo myampersandldquowritersmyampersandrdquo atomic multireader register construct atomic variable extended abstract share concurrent asynchronous waitfree varaibles preliminary version virtue patience concurrent programming without waiting elusive atomic register ctr haldar k vidyasankar constructing 1writer multireader multivalued atomic variables regular variables journal acm jacm v42 n1 p186203 jan 1995 cynthia dwork orli waarts simple efficient bounded concurrent timestamping traceable use abstraction journal acm jacm v46 n5 p633666 sept 1999 alessandro panconesi marina papatriantafilou philippas tsigas paul vitnyi randomized naming using waitfree shared variables distributed computing v11 n3 p113124 august 1998 james h anderson yongjik kim nonatomic mutual exclusion local spinning proceedings twentyfirst annual symposium principles distributed computing july 2124 2002 monterey california rida bazzi gil neiger gary l peterson use registers achieving waitfree consensus distributed computing v10 n3 p117127 april 1997 ming li john tromp paul b vitnyi share concurrent waitfree variables journal acm jacm v43 n4 p723746 july 1996 paul c attie e allen emerson synthesis concurrent programs atomic readwrite model computation acm transactions programming languages systems toplas v23 n2 p187242 march 2001 john tromp paul vitnyi randomized twoprocess waitfree testandset distributed computing v15 n3 p127135 july 2002 yehuda afek david greenberg michael merritt gadi taubenfeld computing faulty shared objects journal acm jacm v42 n6 p12311274 nov 1995 james h anderson lamport mutual exclusion 27 years planting seeds proceedings twentieth annual acm symposium principles distributed computing p312 august 2001 newport rhode island united states
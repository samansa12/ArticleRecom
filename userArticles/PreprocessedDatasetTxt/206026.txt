optimal file sharing distributed networks following file distribution problem considered given network processors represented undirected graph gve file size k arbitrary file w k bits distributed among nodes g end node assigned memory device accessing memory adjacent nodes node reconstruct contents w objective minimize total size memory network paper presents file distribution scheme realizes objective k gg log deltag deltag stands maximum degree g range k total memory size required suggested scheme approaches integer programming lower bound size scheme also constructive sense given g k memory size node g well mapping file w node memory devices computed time complexity polynomial k v furthermore node reconstruct contents file w ok2 bit operations finally shown requirement k much larger log deltag necessary order total memory size close integer programming lower bound b introduction consider following file distribution problem network processors represented undirected graph g arbitrary file w prescribed size k measured say bits distributed among nodes g assign memory devices nodes g accessing memory adjacent nodes node reconstruct contents w given g k objective find static memory allocation nodes g independent w minimize total size memory network although restrict file distribution reconstruction algorithms particular form aim simple efficient ones problem file allocation network ie storing file network every processor easy access file considered many variants see 4 survey specific version reconstruction adjacent nodes received attention form file segmentation task partition file node u network union file segments stored nodes adjacent u complete file 4813 shall see allowing general reconstruction procedures simply taking union file segments adjacent nodes result considerable savings total amount memory required letting delta g denote maximum degree node g memory requirement best segmentation scheme times larger optimal requirement general scheme bound tight start deriving linear integer programming lower bounds total size memory required network g file size k present simple scheme attains bounds sufficiently large values k scheme however file size k must cases much larger delta g log delta g order approach abovementioned lower bounds regard great disadvantage two reasons scheme may turn efficient large files even requires addressing large units stored data time node accesses file thus devote considerable attention problem finding scheme close linear integer programming bounds file size small possible main result critical file size linear integer programming bounds approached order log present file distribution scheme network g file size k total memory size within multiplicative factor g k linear programming bound g stands term approaches zero k log delta g increases hand present infinite sequence networkfilesize pairs k l log delta g l yet file distribution scheme applied pair g l k l requires memory size 1 larger integer linear lower bound lim inf l1 ffig l k l 4 proves file size order log delta g indeed critical point rest paper organized follows section 2 provide necessary background definitions section 3 describe linear integer programming lower bounds prove linear programming lower bound approached large file sizes k section 4 prove main result namely present file distribution scheme approaches linear programming bound ratio k log delta g increases finally section 5 exhibit fact file size log delta g critical point exist infinite families networks linear integer programming lower bounds cannot attained background definitions throughout paper assume underlying network presented undirected graph e set nodes set edges eg g parallel edges ii node contains self loop stands fact node access memory undirected graph satisfying conditions ii referred network graph two nodes u v network graph e adjacent edge g connecting u v adjacency matrix network graph e jv j theta jv j adjacent note definition network graph every node u 2 v adjacent thus every gammau set nodes adjacent u g degree u denoted deltau delta jgammauj maximum degree g denoted delta g two real vectors said satisfy relation z scalar product delta z vectors defined usual real vector called nonnegative 0 0 denotes allzero vector norm nonnegative vector mean l 1 norm kyk delta denotes allone vector given network graph e positive integer k file distribution protocol g intuitively procedure allocating memory devices nodes g map arbitrary file w size k memory devices node u reconstruct w reading memory contents nodes adjacent u precisely let f 2 e network graph let k positive integer real vector agz u uth entry 1 agz entry equal v2gammau z v file distribution protocol g k list consisting ffl memory allocation nonnegative integer vector entry x u denotes size memory bits assigned node u encoding mappings 2 every mappings define coding rule file w size k memory devices nodes contents memory node u given e u w ffl decoding reconstruction mappings 2 every memory allocation encoding mappings decoding mappings satisfy requiremen u 1 defined order set nodes v order entries vectors z fixed arbitrarily applies rows columns adjacency matrix ag subvectors z v v2gammau equation 1 guarantees node u able reconstruct value contents file w size k memory contents e v w nodes v adjacent u memory size file distribution protocol g defined norm kxk denoted jj memory size file distribution protocol total number bits assigned nodes minimum memory size file distribution protocol g k denoted mg k example 1 file segmentation method mentioned section 1 described file distribution protocol g associated encoding mappings 2 form k node u 2 v able reconstruct original file w mappings e v v 2 gammau must every entry w w appears least one e v w implies set nodes w mapped encoding mappings must dominating set g node u 2 g adjacent node hand given dominating set g construct file segmentation protocol g memory size k delta jsj k delta jv j case corresponds simply replicating original file w node g ffl file distribution scheme function g g maps every network graph g positive integer k file distribution protocol g file distribution scheme g constructive complexity computing memory allocation x polynomial k jv j b every w 2 f k 2 complexity computing encoded values e u w u2v polynomial memory size kxk c every 2 complexity reconstructing c polynomial original file size k computational complexity problem mean running time turing machine solves problem remark 1 definition memory size file distribution protocols chose count amount memory required node u store run routines implement decoding mappings u delta reasoning neglecting auxiliary memory practice number files say size k distributed network file distribution protocol implemented independently file using program working space handle files end might better think k size smallest information unit eg word record addressed access file complexity point view would prefer k small possible motivation paper summarized finding constructive file distribution scheme g g maintains ratio memorysize filesize virtually equal lim l1 mg relatively small file sizes k ffl remark 2 one might think weaker definition constructiveness allowing nonpolynomial precomputation x item possibly data structures depend g k w eg calculating suitable representations e u u schemes may justified assumption precomputation steps done given network graph g file size k hand items b c constructiveness definition involve complexity frequent occasions file encoded even reconstructed paper however aim finding file distribution schemes constructive way defined ie strong sense satisfying three requirements ac ffl end section introducing terms used describing mappings e u u proposed file distribution schemes let phi finite alphabet q elements n k code c phi nonempty subset phi n size k parameter n called length c members c referred codewords minimum distance n k code c phi minimum integer two distinct codewords c differ least coordinates let c n k code phi let subset hni delta ng say c separable respect every two distinct codewords c differ least one coordinate indexed next lemma follows directly definition minimum distance lemma 1 minimum distance n k code c phi minimum integer c separable respect every set hni size n gamma 1 let q power prime n k code c field linear subspace phi n case dimension c generator matrix b linear n q k code c phi k theta n matrix b phi whose rows span codewords c k theta n matrix b generator matrix set hni denote b k theta jsj matrix consisting columns b indexed following lemma easily verified lemma 2 let c n q k linear code field phi let b generator matrix c let subset hni c separable respect b rank k 3 lower bounds statement main result section first derive lower bounds mg k ie memory size file distribution protocol g k state main result theorem 2 establishes existence constructive file distribution scheme g attains lower bounds whenever k ae log delta g proof theorem 2 somewhat long deferred section 4 instead present section simple file distribution scheme attains lower bounds k log delta g 31 lower bounds u2v memory allocation file distribution protocol g k assigning x u bits node u 2 v node must see least k memory bits adjacent nodes else 1 would hold therefore every u 2 v must vector notation let jg denote minimum value attained following integer programming problem jg ipg ranging integer also let ae g denote minimum value attained following rational linear programming problem ranging rational z 2 next theorem follows previous definitions example 1 fact jg 1 size smallest dominating set g theorem 1 every network graph g positive integer k call jg k integer programming bound whereas ae g delta k referred linear programming bound 1 problem deciding whether network graph g dominating set size wellknown npcomplete 6 next corollary immediately follows corollary 1 given instance network graph g positive integers k problem deciding whether exists file distribution protocol g memory size ie whether mg note know whether decision problem corollary 1 np therefore whether npcomplete since unclear verify 1 polynomialtime even encoding decoding mappings computable polynomialtime remark 3 result lovasz 11 states jg 1 ae g log 2 delta g hand one construct infinite family network graphs fg l g l ones presented section 5 jg l see also 7 terms file segmentation schemes example 1 means always exists file distribution protocol g based segmentation whose memory size k delta jg 1 within multiplicative factor log 2 delta g linear programming bound ae g delta k yet hand families network graphs multiplicative gap definitive constant 4 even k tends infinity ffl 32 statement main result corollary 1 suggests unlikely exists efficient algorithm generating file distribution scheme g mg k directs objective finding constructive file distribution scheme g g k jg kj ae g delta k close 1 values k small possible specifically prove following theorem theorem 2 exists constructive file distribution scheme g jg kj log log maximum righthand side 3 determined according whether k smaller larger log delta g also theorem 1 ratios jg kj mg k mg kjg k jg kae g delta section 4 prove theorem 2 presenting algorithm generating constructive file distribution scheme g g satisfies 3 particular computational complexity encoding mappings resulting scheme item b constructiveness requirements ok delta jg kj whereas applying decoding mapping node item operations returning discussion remark 1 complexity mappings suggests file size k small possible still greater log delta g means files distributed network segmented records size k delta log delta g large constant record encoded decoded independently information retrieved file reading whole records size delta log delta g bits requiring oa 2 log 2 delta g bit operations whereby ratio memory size required network file size k 1 times ratio k 1 file distribution algorithm divided two major steps step 1 finding memory allocation finding approximate solution integer programming problem resulting memory size jg satisfy 3 step 2 constructing set k theta x u matrices b u matrices define encoding mappings choice matrices b u turn k theta agx u matrix b v v2gammau rank k thus yielding decoding mappings satisfy 1 33 file distribution scheme large files section present fairly simple constructive file distribution scheme g g jg kj note proves theorem 2 whenever k log delta g given network graph e positive integer k first compute memory allocation optimal solution linear programming problem lpg 2 vector z found time complexity polynomial jv j eg using karmarkars algorithm 9 set h delta l delta dkhe define integer vector u clearly furthermore since agz 1 also agy ie agy l delta 1 memory allocation g k defined x delta easy verify kxkae g delta turn defining encoding decoding mappings step 2 end first assign delta g delta l colors nodes g node u assigned set c u u colors words multicolor nodes g way node sees least l colors adjacent nodes coloring obtained following greedy manner start c u every call node u saturated l hence beginning nodes unsaturated whereas end become saturated scan node u 2 v visited node u redefine set c u u distinct colors contained sets c v already assigned nodes v 2 gammau 0 unsaturated nodes u verify procedure yields indeed allsaturated network first show step enough colors assign current node let oeu denote number unsaturated nodes u redefined recalling l every v 2 v easy verify number disqualified colors c u oeu leaves least u qualified colors assign node u claim node becomes saturated point node u remained unsaturated along sets c v v 2 gammau disjoint case would contradicting fact u unsaturated deltal distinct elements phi delta corresponding color j note jphij given file w k bits group entries w htuples form coefficients polynomial wt degree phi compute values w store node u values w requiring memory allocation x u access images w j wt evaluated l distinct elements node interpolate polynomial wt hence reconstruct file w encoding procedure described also terms linear codes refer end section 2 characterization turn useful sections 4 5 let b rs l theta delta g l matrix defined b rs l every node u 2 v let c u set colors assigned u let b u regarding c u subset f1 consists columns b rs indexed c u mappings defined e matrix b rs known generator matrix chs 1011 note since every l columns b rs linearly independent every l theta agy u matrix b v v2gammau rank l allowing node u reconstruct w wb v v2gammau remark reedsolomon codes extensively applied reconstruction problems networks shamirs secret sharing 18 see also 1014 file distribution scheme described section satisfactory file size case ratio g kae g delta might bounded away 1 rectified next construction presented section 4 4 proof main result section present file distribution scheme attains memory size stated theorem 2 section 41 present randomized algorithm finding memory allocation scaling perturbing solution linear programming problem lpg defined 2 found memory allocation x describe section 42 second randomized algorithm obtaining encoding decoding mappings algorithms derandomized section 43 obtain deterministic procedure computing file distribution scheme claimed theorem 2 section 44 present alternative proof theorem using lovasz local lemma section 45 consider variant cost measure used rest paper instead looking near optimal solution respect total memory requirement system consider approximating best solution maximum amount memory required node close minimum feasible done using techniques section 5 41 step 1 solving memory allocation goal section prove following hereafter e stands base natural logarithms theorem 3 given network graph g integer let z z u u2v nonnegative real vector satisfying agz 1 nonnegative integer vector x satisfying log e delta g log e delta g absolute constant c fact provide also efficient algorithm compute nonnegative integer vector guaranteed theorem vector x serve memory allocation computed file distribution protocol instance g k need take slightly larger k order construct encoding decoding mappings section 42 theorem 3 proved via randomized rounding argument see 1517 first solve corresponding linear programming problem lpg 2 say karmarkars algorithm 9 use rational solution define probability measure integer vectors candidates x show probability space contains integer vector x satisfies conditions theorem 3 furthermore vector found polynomialtime randomized algorithm note interested weaker result log jv j replaces log delta g theorem 2 theorem 3 slight modification raghavans lattice approximation method applied 15 however prove theorem 3 need socalled local technique one possibility use method alteration see 19 random integer vector selected probability space perturbed coordinates satisfy conditions theorem another option use lovasz local lemma methods used prove theorem 3 made constructive deterministic method alteration applying method conditional probabilities see spencer 19 p 31 raghavan 15 local lemma using becks method 2 show method alteration present second existence proof using local lemma section 44 given nonnegative real vector real number 0 define vectors u note 0 p u2v random vector independent random variables u f0 1g let u2v random vector defined fix real vector unit hypercube 0 1 jv j delta z 1 since expectation vector e equal p particular z rational vector satisfying agz 1 showing existence instance x serve desired memory allocation x makes use following two propositions proofs propositions given appendix similar statements found also 15 throughout section lffi jg stands max log e fi proposition 1 given nonnegative real vector z integer let defined 57 let real vector 0 1 jv j delta z 1 let positive integer exists constant c 1 every fi 1 proposition 2 given nonnegative real vector z integer let defined 57 let real vector 0 1 jv j exists constant c 2 every fi 1 joo consider following algorithm computing nonnegative integer vector x instance g algorithm 1 1 set g mg 2 solve linear programming problem lpg defined 2 z 3 generate instance random vector 57 4 integer vector x u theorem 3 consequence following lemma lemma 3 vector kxk obtained algorithm 1 satisfies inequality 4 probability proof call node v deficient agx generated vector x first note x u either x u x u fact deficient nodes v agx v delta agz v proposition 1 every node v 2 v node v deficient hence node u x node v deficient therefore expected number nodes u x 1 jv j probability least 1 2 jv j nodes u observing agz thus obtain probability 1 recalling e apply proposition 2 hence 8 9 10 conclude probability 1 integer vector x satisfies last inequality implies log e fi g lemma follows substituting log e fi g log e fi g g 12 note log log compare righthand side 3 vector x computed serve slight modification memory allocation g k section 43 shall apply method conditional probabilities make algorithm 1 deterministic 42 step 2 defining encoding mappings found memory allocation x provide randomized algorithm constructing encoding decoding mappings construction makes use following lemma lemma 4 12 p 444 let denote random matrix uniformly distributed matrices f 2 given instance g k let u2v nonnegative integer vector obtained algorithm 1 following algorithm computes node u matrix b u used encoding mappings algorithm 2 1 u 2 v assign random matrix q u uniformly distributed k theta x u matrices f 2 2 define encoding matrix b u k rank u k stands k theta k identity matrix note b u k theta x u binary matrix x x vector serve final memory allocation g k show later section excess k xk kxk small enough let equation hold also respect memory allocation x establish memory size claimed theorem 2 associated encoding mappings given e overall process encoding w e requires ok delta k xk multiplications additions f 2 recalling definitions section 2 note node u k theta k xk matrix separable respect set gammau rank b k therefore node u knowing values able reconstruct file w end node u process k fixed coordinates wb gammau namely k coordinates correspond k linearly independent columns let set coordinates indexed set u assuming hard wired connection node u k entries wb gammau indexed u decoding process u sums multiplying vector wb tu 2 f k 2 inverse b tu hence mappings u given u decoding process node thus requires ok 2 multiplications additions f 2 note cases set b u 14 identity matrix decoding process trivial since whole file written node u turn estimating memory size x first note every node u matrix u uniformly distributed k theta agx u matrices f 2 recalling construction agx rank u g hence expected number nodes 15 jv j therefore probability least 1 2 jv j g nodes u whose memory allocation x u increased x g total memorysize increase 15 bounded g kzk hence 13 k xk g kzk log log log delta g recall construction section 33 covers theorem 2 larger values k section 43 apply method conditional probabilities see 19 p 31 15 order make computation matrices b u deterministic remark 4 worthwhile comparing file distribution scheme described sections 41 42 scheme section 33 modified employ algorithm 1 g dkhe ke solve memory allocation verified resulting file distribution scheme slightly worse one obtained every term log delta g 3 changed logdelta g delta particular method critical file size log 2 delta g ffl 43 deterministic algorithm show make algorithms 1 2 deterministic using method conditional probabilities spencer 19 p 31 raghavan 15 adapted conditional expectation values idea method conditional probabilities search probability space defined random choices iteration probability space bisected setting one random variables throughout search estimate probability success conditional choices fixed far value next random variable chosen one maximizes estimator function derandomizing algorithms 1 2 employ estimator expected value size allocation every step conditional expectation possibilities value next random variable computed setting smaller thus increasing probability success chosen unlike raghavan 15 employ pessimistic estimator rather conditional expectation estimator fairly easy compute start derandomizing computation initial memory allocation x let vectors computed course algorithm 1 recall every u 2 v entry x u random variable given x node u deficient refer e expectation estimator x comparing last inequality 12 would suffice found memory allocation whose size e note computed efficiently calculating expressions subsets w gammau consisting first nodes gammau computation carried efficiently dynamic programming first entry define conditional expectation estimators indeed e furthermore two conditional expectation estimators e convex combination therefore one must bounded e set entry 1 bit b smallest note like e conditional expectation estimators efficiently computed determined first entry reiterate process second involving conditional expectation estimators continuing way subsequent entries end nondecreasing sequence conditional expectation estimators thus determining whole vector therefore vectors x x latter memory size turn making computation encoding mappings deterministic recall algorithm 2 first assigns random k theta x u matrix q u node u may regard assignment kxkstep procedure nth step random column f k 2 added node v less x v alreadyassigned columns denote q un partial matrix node u 2 v nth step assignment random matrices q u nodes network thus described random process fu n g kxk u2v random column configuration denoting contents node adding nth column network graph shall use notation u 0 initial column configuration columns assigned yet node let u denote random matrix q v v2gammau algorithm 2 let r number nodes u rank u k recall algorithm 2 based inequality er delta allowed us give probabilistic estimate 2er jv j number nodes u required replacing q u k instead compute sequence column configurations u kxk particular ie number nodes u b u set k 14 guaranteed less order attain inequality chain 16 proceed follows let u 0 empty column configuration assume induction column configuration u ngamma1 determined n 1 let v node assigned less x v columns u ngamma1 determine column added v obtain u n done manner similar process described derandomizing algorithm 1 set first entry b 1 added column 0 assume entries random bits compute expected value e 0 r conditioned u repeat process b 1 set 1 resulting conditional expected value e 1 r since two conditional expected values e 0 e 1 average er j u must average first entry b 1 column added v set bit b e b smallest process iterated second bit b 2 column added v resulting two conditional expected values smaller determines b 2 continuing way obtain sequence conditional expected values r er j u thus determining entire column added v note indeed accordance 16 remains show compute conditional expected values r used determine column configurations u n easy verify event er rank u hence computation conditional expected values r boils following problem let denote k theta random matrix f 2 whose first l columns well first entries l 1st column preset rest entries independent random bits probability 1of zero probability rank k let h denote k theta l matrix consisting first l preset columns random matrix denote matrix consisting first l columns w matrix consisting last columns also let random variable ae denote rank clearly ae may take two values namely rank h rank h 1 show indeed without loss generality assume first r rows linearly independent assume entries w chosen randomly row row selected first r rows w thus obtain first r rows turn linearly independent next select r 1st row w clearly 2 choices row one row result r 1st row spanned first r rows hence given first r rows w set probability first rows linearly independent conditioning upon linear independence first r select r 2nd row w case two choices row yield r2nd row spanned first r 1 rows hence probability first r 2 rows linearly independent given linear independence first r general assuming linear independence first r 2 choices r 1st row w yield row belonging linear span first r conditional probability first r rows linearly independent thus equation 18 obtained reiterating process rows w complete computation probability rank k need calculate probability ae denote first rows h r denote first preset entries l 1st column show first perform elementary operations columns h first r columns h linearly independent whereas remaining l gamma r columns h zero ii first r columns h linearly independent whereas remaining l gamma r columns h zero c linear span columns h 1 otherwise 2 rgammar ways select last entries l 1st column column spanned columns h choice corresponds one linear combination last r gamma r nonzero columns h therefore conditioning upon rank h probability rank equations 18 19 applied u compute righthand side 17 stands event columns u n set u ngamma1 bits currentlyadded nth column set b 1 44 proof using lovasz local lemma section present alternative proof existence memory allocation x satisfying 3 k theta x u binary matrices b u encoding mappings e techniques used turn useful section refvariations end make use following lemma lemma 5 lovasz local lemma 519 let 1 events arbitrary probability space suppose event mutually independent set ffi events j prob fa applications lemma well use sequel stand bad events hence probability bad event p bad events nottoodependent one another sense stated lemma strictly positive probability none bad events occur however probability might exponentially small recently beck 2 proposed constructive technique used applications lemma finding element shall mainly concentrating existence proof construction follow technique similar one 2 start using local lemma present alternative proof theorem 3 given network graph integer construct directed graph satisfies following four properties edge whenever u adjacent v g ii parallel edges h iii node h indegree delta iv node h outdegree bounded lemma 6 directed graph h satisfying iiv always exists proof complete graph ie adjacency matrix ah allone matrix otherwise construct h g follows make every self loop g directed edge h change edges g two antiparallel edges h finally adjoin extra edges parallel existing ones indegree g node h realize last step scan nodes h add incoming edges nodes whose indegree less delta g one node time let u node let gammau set nodes h outgoing edges terminate u show least one nodes gammau outdegree less 2delta g thus allowing us adjoin new incoming edge u node proof continues inductively since indegree node h stage delta g total number edges outgoing nodes gammau bounded 1 hand gammau contains least nodes hence exists least one node gammau whose outdegree number turn less proof theorem 3 using local lemma let z solution linear programming problem lpg 2 property z satisfies inequality ah z 1 redefine fi g g accordingly mc 1 delta lffi g mg let x obtained 57 proposition 1 property ii proposition 2 node u 2 v every define event u u 20 21 follows prob fa u g every node u h denote gamma u set terminal nodes edges outgoing u h every node u event u mutually independent events v gamma u gamma hence properties iii iv u depends h g events v therefore lemma 5 exists nonnegative integer vector x satisfying agx show kxk satisfies inequality log e fi g 24 fact node h indegree delta h ahx u log e cauchyschwarz inequality ah z u therefore log e inequality 25 obtained bounding jv j delta h kzk finally theorem 3 consequence 23 25 turn defining encoding decoding mappings given instance g k end shall make use following lemma lemma 7 let 1 subsets hni delta ng size subset intersects ffi subsets let q power prime let k nonnegative integer satisfying exists n q k linear code separable respect proof construct inductively l theta n matrices b l 1 l k generating linear code separable respect every b l rank l start allone 1 theta n matrix b 1 induction step assume matrix b lgamma1 property already constructed l k append lth row b lgamma1 given matrix b lgamma1 row vector phi n good respect appended b lgamma1 yields matrix b l b l rank l otherwise row vector bad respect row span b consists q vectors phi js means probability randomly selected row bad respect q gammajs similarly probability randomly selected row bad respect j q gammajs jgammajs j j2lgamma1 therefore events row vector bad respect row vector bad respect j independent thus lemma 5 guaranteed row vector phi n good respect every vector appended b lgamma1 obtain generator matrix b l b l rank l let x integer vector guaranteed theorem 3 partition set hkxki jv j disjoint subsets q u jq js furthermore u intersects exists linear separable respect u k theta x u matrix consisting columns b indexed q u use define encoding decoding mappings section 42 45 variations memory cost measure techniques used section 44 adapted obtain file distribution schemes g g close optimal respect variants memory cost measure instance consider problem every instance g k looking file distribution protocol g whose memory allocation x satisfies following two criterions largest component x max x smallest possible ii among file distribution protocols satisfy take one whose memory size kxk smallest variant original problem might suit cases say node network graph opposed network manager needs pay memory since respective decision problem npcomplete need look approximations optimal solution given network graph e integer k proceed follows let delta min min u2v deltau clear dkdelta min e lower bound largest component x set consider following linear program ae ranging rational u2v next set fi mg let obtained 57 redefine events u 22 u 20 21 prob fa u following along lines section 44 lovasz local lemma guarantees file distribution protocol memory allocation x whose maximal component x max size kxk satisfy log log ae gff delta k log log x max kxk approach optimal values k becomes larger log delta g 5 integer programming bound tight section 4 presented algorithm finding constructive file distribution scheme g ratio memory size jg kj ae g delta k approaches 1 ratio k log delta g tends infinity section present family network graphs l1 file size log delta g l indeed critical point exists sequence file sizes k l log 2 delta g l ratios mg l k l jg l k l therefore bounded away 1 integers l l define network graphs g let um set elements say consist subsets um size l set v draw edge two nodes following cases u v um ie um clique ii u 2 um v 2 w ml loops first verify ae g ml nonnegative real vector satisfying ag ml loss generality assume z otherwise remove quantity z v node v add value z u node u 2 gammav gamma fvg um change results new nonnegative vector z norm z satisfies ag ml z 1 rename nodes um node l z ag ml z therefore z u z l 1l every node u l um hence ae g l z z l setting z 1l u 2 um obtain equality ae g every positive integer r similar analysis similar setcovering problem appears also 7 forthcoming discussion concentrating two types network graphs g ml namely case ae g l l case ae h proof next proposition makes use following known lemma lemma 8 spherepacking hamming bound 12 ch 1 let phi alphabet q elements exists n k code minimum distance 2t proposition 3 fixed positive integer r lim ae g l proof set positive integer r let x memory allocation file distribution protocol g l memory size assume x nodes u renamed letting h delta inequality follows p l turn implies inequalities x l1 x l r file w denote encoded memory contents e u1 determined file distribution protocol regard set cw l alphabet q delta elements code c must separable respect subset hl 2i size l else would nodes w 2ll could reconstruct file w hence lemma 1 minimum distance c least 3 readily implies lemma 8 inequality substituting noting 2 l log log hence fixed r sufficiently large l must 1 combining lower bound h 28 yields inequality lim 27 concludes proof corollary 2 k l lim ae g l delta k l corollary 2 exhibits fact file size log delta g l critical point following strong sense k l 2l log 2 delta g l size memory allocation g l k l must bounded away ae g l l gap jg l k l ae g l l rather gap mg l k l jg l k l point counterpart proposition 3 also lim proof based following result lemma 9 gilbertvarshamov bound 3 pp 321322 let phi alphabet q elements let n k positive integers satisfying exists n k code minimum distance phi values satisfy equality therefore lemma 1 lemma 9 exists 2l 2 rl code c f h 2 separable respect subset h2li size l assign coordinates f h c nodes u 2 u 2l g l map files w 2 f rl distinct codewords c protocol allows every node g l reconstruct file w requiring total memory size 2r compared jg l r delta remark 5 readily verified jg ml every l k particular jg l hence file distribution protocol based segmentation least 1 times larger linear programming bound ae g l delta k even k tends infinity see example 1 remark 3ffl file sizes k smaller log delta g one find examples ratio mg jg k even larger stated proposition 3 demonstrate network graphs h l g 2 l l next proposition making use following lemma lemma 10 plotkin bound 3 p 315 let c n k code minimum distance alphabet q elements thenq proposition 4 l k stands lim l1 f l kg l uniformly k particular l ratio mh l kjh l approximately l turn least log 2 delta h l proof distinguish three ranges k stated proposition case 1 l 27 jh l l fact also mh l l construct reedsolomon code c rs gf 2 r separable respect subset h2 l size l 12 chs 1011 compare section 33 assign coordinates gf 2 r c rs nodes u 2 u 2 l h l map files w distinct codewords c rs separability c rs every node h l readily reconstruct file w case 2 strictly positive integer r l let x memory allocation file distribution protocol h l memory size assume x l nodes u 2 l renamed x 1 x 2 x 2 l x l compare 28 bound h regard set n 2 k code alphabet q delta separable respect subset hni size l minimum distance must lemma 1 least turn implies lemma 10 inequality2 h combining last inequality 29 yields l o1 stands expression independent k tends zero l goes infinity recalling jh l r bounds 31 32 definitive multiplying factor 1 gamma o1 upper bound mh l l obtained assigning coordinates reedsolomon code gf 2 l nodes u 2 u 2 l h l code separable respect subset h2 l size r therefore respect subset size l case 3 k l let n h defined case 2 noting 29 30 still apply l 2 ie le l combining last inequality 29 yields turning jh l k k l jh l remark 5 fact equality easy verify integer vector defined satisfies inequality ah l 1 hence 33 obtain bounds 33 34 definitive simply replicate file w node u 2 u 2 l h l requiring memory size k delta 2 l acknowledgment thank noga alon cynthia dwork many helpful discussions anonymous referee useful comments suggestion consider variations memory cost measure appendix proofs propositions 1 2 make use following lemma lemma 11 let u real vectors 0 1 jv j let u u2v vector independent random variables f0 1g prob fy every e gammaffi b every proof lemma 11 proved 15 16 part b lemma appears 15 sake completeness include proof part real random variable z constants fl 0 b e flbgammaz inequality known chernoff bound letting every fl 0 e gammafl auyu e gammafl auyu substituting exp fgammap u u 2 0 1 2 0 1 therefore e gammaffi part obtained substituting proof proposition 1 let r denote difference note delta z 1 implies delta p delta p delta delta z implies also let random variable 7 readily proves proposition r hence assume 0 r apply lemma 11a 36 e gammaffi oe therefore prob suffices require oe case 1 r 2oe easy verify log e 1 2 hence inequality 37 implied r oe log e fi turn satisfied r 6 oe log e fi recalling inequality 37 thus implied case 2 r 2oe range oe delta log e oe oe hence inequality 37 satisfied r log e fi existence constant c 1 implied 38 39 setting c proof proposition 2 let random variable 7 let r positive proposition holds trivially since case prob 1 therefore assume apply lemma 11b therefore prob suffices require case 1 ra noting 1 inequality 40 satisfied whenever e delta p implied r case 2 ra delta noting 7 1t gamma1 log e 1t monotonously increasing ii 5 3 log e2 ie inequality 40 satisfied existence constant c 2 c implied 41 42 r parallel algorithmic version local lemma algorithmic approach lovasz local lemma algebraic coding theory comparative models file assignment problem computers intractability guide theory npcompleteness fractional solution set covering problem file distribution problem processor networks new polynomialtime algorithm linear programming secret sharing systems ratio optimal integral fractional covers theory errorcorrecting codes optimal allocation resources distributed information networks efficient dispersal information security probabilistic construction deterministic algorithms approximating packing integer programs lecture notes randomized algorithms technique provably good algorithms algorithmic proofs share secret ten lectures probabilistic method tr ctr anxiao andrew jiang jehoshua bruck network file storage graceful performance degradation acm transactions storage tos v1 n2 p171189 may 2005 stavros g kolliopoulos neal e young approximation algorithms coveringpacking integer programs journal computer system sciences v71 n4 p495505 november 2005 aravind srinivasan chungpiaw teo constantfactor approximation algorithm packet routing balancing local vs global criteria proceedings twentyninth annual acm symposium theory computing p636643 may 0406 1997 el paso texas united states
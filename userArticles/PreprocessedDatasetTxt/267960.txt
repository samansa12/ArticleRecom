approach exploring code improving transformations although code transformations routinely applied improve performance programs scalar parallel machines properties codeimproving transformations well understood article present framework enables exploration analytically experimentally properties codeimproving transformations major component framework specification language gospel expressing conditions needed safely apply transformation actions required change code implement transformation framework includes technique facilitates analytical investigation codeimproving transformations using gospel specifications also contains tool genesis automatically produces transformer implements transformations specified gospel demonstrate usefulness framework exploring enabling disabling properties transformations first present analytical results enabling disabling properties set code transformations including traditional parallelizing transformations describe experimental results showing types transformations enabling disabling interactions actually found set programs b introduction although code improving transformations applied compilers many years properties transformations well understood widely recognized place program code transformation applied order applying code transformations selection particular code transformation apply impact quality code produced although concentrated research efforts devoted development particular code improving transformations properties transformations adequately identified studied due part informal methods used describe code improving transformations lack common formal language notation difficult identify properties code transformations compare transformations determine transformations interact one another identifying various properties code improving transformations interactions costs expected benefits application frequencies informed decisions made transformation apply apply order apply order application important quality code transformations interact one another creating destroying potential code improving transformations work partially supported nsf grant ccr9407061 slippery rock university ccr 9109089 university pittsburgh dr whitfields address department computer science slippery rock university slippery rock pa 16057 example quality code produced would negatively affected potential applying beneficial transformation destroyed application less beneficial transformation certain types transformations may beneficial one architecture another benefits transformation also dependent type scheduler dynamic static used 15 one approach taken determine appropriate transformations order application set programs implement code transformer program optimizer includes number code improving transformations apply transformations programs evaluate performance transformed code however actually implementing code transforming tool time consuming process especially detection complex conditions global control data dependency information required also ad hoc manner code transformers usually developed addition transformations even deletion transformations may necessitate substantial effort change transformer another approach modify existing optimizer however optimizing compilers often quite large eg suif 12 300000 lines c code gnu c compiler 8 200000 lines code complex making difficult use experiments take account various factors influencing performance transformed code paper present framework exploring properties code improving transformations major component framework code transformation specification language gospel framework includes technique utilizes specifications analytically investigate properties transformations gospel also used design genesis tool automatically produces code transformer program specifications enabling experimentation specification transformation consists expressing conditions program code must exist transformation safely applied actions needed actually implement transformation program code specification uses variant first order logic includes expression code patterns global data control dependencies required applying transformation actions expressed using primitive operations modify code code improving transformations expressed gospel require fixpoint computation class includes many traditional parallelizing code improving transformations demonstrate framework used study phase ordering problem transformations exploring enabling disabling properties transformations using gospel first show enabling disabling properties established analytically also demonstrate use genesis properties studied experimentally using genesis code transformers automatically produced set transformations specified gospel executed transform test suite programs present results experiments explored kinds transformations found test suite types numbers transformation interactions found number benefits accrue framework guidelines suggesting application order set code improving transformations derived analytical experimental exploration interactions also new transformation specified gospel relationship transformations analytically experimentally investigated specifications transformer generated genesis using sample source programs user experimentally investigate transformations system consideration decision transformations include particular architecture order transformations applied easily explored new transformations particularly tailored architecture specified used generate transformer effectiveness transformations experimentally determined using architecture transformations effective removed consideration new transformation added simply changing specifications rerunning genesis producing program transformer implements new transformation transformations safely combined could also investigated analytically need combine explored experimentally another use gospel genesis teaching tool students write specifications existing transformations transformations modify tune transformations implementations transformations generated genesis enabling experimentation transformations prior research reported tools assist implementation code improving transformations including analysis needed research performed automatic code generation useful development peephole transformers 4679 works transformations considered localized require global data flow information number tools designed generate analyses sharlit 13 pag 1 use latticebased specifications generate global dataflow analyses spare another tool facilitates development program analysis algorithms 14 tool supports high level specification language analysis algorithms expressed denotational nature specifications enables automatic implementation well verification algorithms software architecture useful rapid prototyping data flow analyzers also recently presented 5 approaches developed integrate analysis code transformations approach technique combine specific transformations creating transformation template fully describes combined operations developed part framework iterationreordering loop transformations 11 new transformations may added framework specifying new rules work applied iterationreordering execution order loop interactions perfect tight loop nest provide technique specify characterize transformations general next section paper discusses framework developed specify transformations section 3 presents details gospel language section 4 shows gospel used analytical investigation enabling disabling conditions transformations automatic generation transformers section 5 demonstrates utility specification technique using genesis presents experimental results conclusions presented section 6 2 overview transformation framework code improving transformation framework shown figure 1 three components gospel code transformation specification language analytical technique uses gospel specifications facilitate formal proofs transformation properties genesis tool uses gospel specifications produce program implements application transformations three components used explore transformations properties paper use framework explore disabling enabling properties gospel specification consists preconditions needed program code order transformation applicable code modifications implement transformation part precondition specification textual code pattern needed transformation example includes existence statement assigns variable constant existence nested loop thus code patterns operate program objects loops statements expressions operators operands order determine whether safe apply transformation certain data control dependencies may also needed program objects also used express dependence relationships describing transformations gospel uses dependencies expressed terms flow anti output control dependencies 21 dependencies quantified combined using logical operators produce complex data control conditions flow dependence j dependence statement defines variable statement j uses definition antidependence j exists statement uses variable defined statement j output dependence dependence statement defines writes variable later defined written j control dependence exists control statement statements j control concept data direction vectors forward backward loopcarried dependencies array elements also needed transformations parallelization 10 element data dependence vector consists either forward backward equivalent direction represented respectively directions combined meaning direction number elements direction vector corresponds loop nesting level statements involved dependence cases code improving transformations traditionally expressed using global data flow information information either expressed combination data control dependencies 21 introduced gospel relationship needs computed checked underlying assumption gospel algorithm needed compute data flow data dependency information available thus gospel uses basic control data dependency information possibility extensions types data flow information noted twenty transformations studied research data flow information expressed terms combinations data control dependencies 16 17 sample transformation specifications given appendix b gospel also includes specification code modifications needed implement transformation although code improving transformations produce complex code modifications code changes expressed gospel primitive operations applied combinations specify complex actions operations applied code objects statements expressions operands operations using primitive operations express code modifications provides flexibility specify wide range code modifications easily another component framework analytical technique useful proving properties transformations technique uses specification gospel provide clear concise description transformation useful analysis show component used establishing enabling disabling properties set transformations last component framework genesis tool generates program implements transformations gospel specification transformations thus generated program contains code check conditions needed safe application transformation satisfied also contains code perform code modifications expressed gospel specification program transformed input program generated genesis output produced program transformed specified transformations runtime interface provided either permits user select type place application transformation automatically finds applicable transformations points demonstrate utility genesis determining kinds frequencies transformations occurring number programs types frequencies enabling disabling interactions figure 1 presents code improving framework uses framework three components framework shown box applications framework shown ovals solid lines connect framework applications described paper solid line connects framework interaction prover used establish enabling disabling properties transformations another solid line framework experimental studies enabling disabling properties dotted line connecting framework combining transformations represents potential use framework yet fully explored code improving transformation framework uses figure 1 components utilization transformation framework 3 description gospel language gospel declarative specification language capable specifying class transformations performed without using fixpoint computation specified twenty transformations using gospel including specifications invariant code motion loop fusion induction variable elimination constant propagation copy propagation loop unrolling transformations require fixpoint computation partial dead code elimination partial redundancy elimination cannot specified likewise although gospel used specify type constant propagation folding cannot used example specify constant propagation transformations requiring fixed point computation however studies shown code seldom contains types optimizations needing iteration 3 bnf grammar section gospel appears appendix grammar used construct wellformed specifications also used implementation genesis transformer paper assume general form statements program transformed three address code extended include loop headers array references however gospel genesis adapted handle representations including source level representation assume basic three address code statement form three address code retains loop headers array references source program enables user specify loop level transformations array transformations template specification transformation consists name used identify particular code improving transformation followed three major specification sections identified keywords declaration precondition action precondition section decomposed two sections codepattern depend overall design gospel specification follows combining genesis proof technique enabling disabling interaction properties experimental study enabling disabling transformations gospel declaration precondition codepattern depend action declaration section used declare variables whose values code objects interest eg loop statement code objects attributes appropriate head loop position operand precondition section contains description code pattern data control dependence conditions action section consists combinations primitive operations perform transformation figure presents gospel specification constant propagation ctp transformation see section 32 details specification uses three variables j l whose values statements codepattern section specifies code pattern consisting statement defines constant type opr 2 const value statement exists depend section j used determine statement uses constant pos attribute records operand position first second third flow dependence j second statement l ensures definitions constant assignment might reach j pos attribute records position flow dependence j l j l specification indicates two statements statement operand j pos operand l pos specification ensures dependence position recorded j involve variables dependence found 1 declaration precondition codepattern find constant definition depend use definitions j pos flowdep j l pos flowdep l operand pos operand l pos action change use constant modify operand j pos opr 2 figure 2 gospel specification constant propagation j found meets requirements l found meet specified requirements operation expressed action section performed action modify use j constant found second operand next consider specification parallelizing transformation loop circulation crc found figure 3 defines two statements three tightly perfect nested loops loops without statements occurring headers codepattern section specifies occurrence tightly nested loops l 1 l 2 l 3 data dependence conditions depend section first ensure loops tightly nested specifying flow dependences loop headers next depend section expresses pairs statements loop flow dependence direction vector statements found heads ends loops interchanged specified action section next section provides details gospel language 31 gospel types operations variables whose values code elements defined declaration section declaration idlist variables declared one following types statement loop nested loops tight loops adjacent loops thus objects types value pointer statement loop nested loop tight loop adjacent loop respectively types predefined attributes denoting relevant properties next nxt previous prev usual numeric constants integer real available gospel specifications besides constants two classifications predefined constants also available operand types opcode values constants declaration precondition codepattern find tightly nested loops l 1 depend ensure perfect nesting flowdep action interchange loops move figure 3 gospel specification loop circulation reflect constant values code elements specified gospel examples constants include const constant operand var variable operand typical mathematical opcodes well branches labels appear specification code gospel extended include op codes variable types changing grammar tools genesis uses grammar variable type statement value statements program possesses attributes indicating first second third operand opr 1 opr 2 opr 3 respectively operation opcode additionally pos attribute exists maintain operand position dependence required depend section aloop typed variable points header loop attributes body identifies statements loop head defines lcv loop control variable init initial value final last value loop control variable end loop also attribute thus typical loop structure attributes head lhead defines linit lfinal llcv loopbody lbody endofloop lend nested loops tight loops adjacent loops composite objects whose components type loop nested loops defined two loops second named loop appears lexically within first named loop tight loops restrict nested loops ensuring statements loop headers adjacent loops nested loops without statements end one loop header next loop idlist keyword declaration either simple list eg statement loop identifiers list pairs eg identifiers pair nested adjacent tight loops example tight loopone looptwo defines loop structure consisting two tightly nested loops 32 gospel precondition section order specify code improving transformation conditions safely applied pattern code data control dependence conditions needed must expressed two components constitute precondition section specification keyword precondition followed keywords codepattern identifies code pattern specifications depend identifies dependence specification code pattern specification code pattern section specifies format statements loops involved transformation code pattern specification consists quantifier followed elements needed required format elements quantifier elementlist formatof elements quantifier operators one following meanings returns set elements requested types successful match returns set one element requested type match successful returns null set requested match successful example quantifier element list j returns pointer statement j second part code pattern specification formatofelements describes format elements required statement element type formatofelements restricts statements operands operator similarly loop element type formatofelements restricts loop attributes thus constants required operands loops required start iteration 1 requirement specified formatofelements example code pattern specification specifies final iteration count greater initial value loop loopfinal loopinit 0 expressions constructed formatofelements using operators usual meaning also restrictions placed either type operand ie const var position pos opcode seen codepattern section figure 2 depend specification second component precondition section depend section specifies required data control dependencies transformation dependence specification consists expressions quantified return boolean truth value set elements meet conditions pos attribute used operand position dependence also returned general form dependence specification quantifier element setsofelements dependenceconditions setsofelements component permits specifying set membership elements memelement specifies element member defined set set described using predefined sets name specific set expression involving set operations set functions union intersection dependenceconditions clause describes data control dependencies code elements takes form typeofdependence stmtid stmtid direction version gospel dependence type either flow dependent flowdep anti dependent antidep output dependent outdep control dependent ctrldep direction description direction vector element vector consists either forward backward equivalent direction represented respectively also used allows direction direction vectors needed specify loopcarried dependencies array elements parallelizing transformations direction vector may omitted loopcarried dependencies relevant example following specification one element named element loop 1 j element loop 2 either flow dependence anti dependence j 33 gospel action section decompose code modification effects applying transformations sequence five primitive operations semantics indicated table 1 operations overloaded apply different types code elements five primitive operations parameters semantics table 1 action operations example move operation moves loop1 header loop2 header moveloop1head loop2head example modify action modifies end loop2 jump header loop2 modifyloop2end address loop2head primitive operations combined fully describe actions transformation may necessary repeat actions statements found precondition section hence list actions may preceded forall expression describing elements actions applied flow control specification implicit exception forall construct available action section words action keyword acts guard permit entrance section unless conditions met 4 applications gospel specification gospel specifications useful number ways section demonstrate utilization specifications explore phase ordering problem transformations operation parameter semantics move object afterobject move object place following afterobject add objdesc objname afterobj add objname objdesc place afterobj delete object delete object copy obj afterobj newname copy obj newname place afterobj modify object objectdescription modify object objectdesc analytically establishing enabling disabling properties section 42 show gospel used produce automatic transformer generator genesis used explore properties transformations experimentally 41 technique analyze specifications gospel specifications analyzed determine properties transformations particular use analysis technique establishing enabling disabling properties transformations enabling disabling conditions interactions transformations create conditions destroy conditions applying transformations determined knowing interactions occur among transformations useful determining apply transformations example strategy might apply transformation destroy conditions applying another transformation order exploit potential second transformation especially second transformation considered beneficial 411 enabling disabling conditions enabling interactions occur two transformations application one transformation creates conditions application another transformation previously could applied disabling interactions occur one transformation invalidates conditions exist applying another transformation words transformation enables transformation b denoted b performed b applicable performed b applied bs precondition true similarly transformation disables transformation b denoted b preconditions transformation b true applied bs precondition becomes false properties involved phase ordering problem transformations determining interactions among transformations conditions enabling disabling transformation must established enabling disabling conditions found analyzing precondition specifications transformations condition codepattern depend section transformation least one enablingdisabling condition produced example code pattern includes statement statementopcode assign enabling condition creation statement opcode assign disabling conditions deletion statement modification statements opcode enabling disabling conditions six transformations derived specifications see appendix b gospel specifications given table 2 412 interactions among transformations using gospel specifications prove nonexistence interactions also use specifications developing examples demonstrate existence interactions transformation enabling conditions disabling conditions dead code elimination dce 1 create used 2 nonexistence l l delete l path deleted 1 destroy used 2 existence l l introduce l uses value computed constant propagation ctp 1 create 2 insert j 3 nonexistence l l modify l l destroy l j introduce definition b delete l c path deleted 1 destroy 2 nonexistence j 3 existence l l modify l l create l j definition deleted b introduce l l c path l j created constant folding cfo 1create form const opcode const 1 remove modify loop unrolling 1 create loop l 1 destroy loop l loop fusion 1 existence 2 adjacent loops add loop 2 two loops identical head ers modify header 3 nonexistence n backward dependence forward remove n add definition n delete path n 4 non existence remove remove add def destroying depend delete path j 1existence 2 nonadjacent loops add loop 2two loops identical headers modify header 3the existence n backward dependence forward insert n delete definition n create path n 4 existence delete def dependence holds create path j loop interchanging 1 existence 2 nested loops add loop 2 nonexistence n dependence remove n add definition n delete path n 3 loop headers invariant modify header 1nonexistence 2 nested loops remove loop 2 existence n dependence insert n remove def n create path n 3loop headers vary respect modify header denotes condition possible correct specifications ie maintains semantic equivalence table 2 enabling disabling conditions example interaction given figure 4 loop fusion fus enables loop interchange inx two inner loops j fused one larger loop interchanged sometimes interaction two transformations complex transformation enable disable transformation invariant code motion icm loop interchange inx two transformations shown figure 5 icm enables inx also disable inx figure 5 example icm enabling inx given figure 5 b example icm disabling inx shown ease proving noninteraction use formal notation gospel specifications directly derived specification language using mathematical symbols place language related words comparison two styles exemplified language figure 4 loop fusion enables loop interchanging figure 5 enabling disabling transformations icm enables inx b icm disables inx following claim proof illustrate technique prove nonexistence enabling disabling interactions transformations claim loop interchange inx cannot disable application constant propagation ctp proof utilizes disabling conditions ctp given previously table 2 disable constant propagation proof assume inx ctp inx disable ctp inx ctp must applicable inx applied inx applicable must two tightly nested loops l 1 l 2 loop limits invariant data dependence direction vector ctp applicable must exist defines constant j uses constant value l l since ctp applicable inx must alter state code disable ctp three disabling conditions ctp given table 2 produce following cases case 1 destroy defines constant inx delete statements move header l 2 defines variable loop header defines loop control variable loop control variable variable defined ctp applicable define constant value inx destroy statement defining constant case 2 nonexistence j removal dependence inx delete statements move header l 2 however moving header outside loop would destroy relationship since headers must invariant relative order inx applicable inx destroy j case 3 creation l l inx create modify statement three ways inx create condition could delete definition legal action transformation could introduce l inx create statements move header l could header l defines constant creates path l reaches j j could header definition l would reached j prior inx since headers must invariant inx create l thus show inx ctp loop interchange applied destroy opportunities constant propagation exploring examples interactions developing proofs noninteraction derived hand interaction table displays potential occurrence interactions table 3 displays interactions eight transformations dead code elimination dce constant propagationctp copy propagation cpp constant folding cfo invariant code motion icm loop unrolling lur loop fusion fus loop interchange inx entry table consists two elements separated slash first element indicates enabling relationship transformation labeling row transformation labeling column second element disabling relationship indicates interaction occur whereas e indicates enabling disabling interaction occurs respectively example first row indicates dce enables dce disables ctp notice high degree potential interactions among triples fus inx lur ctp cfo lur 413 impact interactions transformation ordering disabling enabling relationships transformations used transformations applied automatically transformations applied interactively transformations applied automatically case optimizing compilers interactions used order application apply many transformations possible applying transformations interactive mode knowledge interaction help user determine transformation apply first using interaction properties two rules used particular ordering goal applying many transformations possible 1 transformation enable transformation b order b ab 2 transformation disable transformation b order b b rules cannot produce definite ordering conflicts arise 1 b b 2 b b 3 b b ctp ed e e e e e lur e e e e e ed ed fus ed ed table 3 theoretical enabling disabling interactions cases precise orderings cannot determined properties however shown next section experimentation performed using genesis determine value applying one transformation transformation example using orderings consider scenario transformer designer decides lur extremely beneficial transformation target architecture transformer designer could benefit two pieces information 1 transformations enable lur 2 transformations disable lur seen table 3 ctp cfo lur enable lur interactions indicate ctp cfo applied prior lur architecture additionally one could infer table since ctp enables cfo cfo enables ctp two transformations applied repeatedly lur course may factors consider applying loop unrolling paper focus one namely transformation interactions factors may include impact unrolled loop cache factors important application transformations factors could embedded genesis experiments eg adding measures cache performance table 3 also displays interactions disable lur fus transformation disables lur decision must made importance applying fus target architecture lur important either fus applied end transformation process information interactions could also used development transformation guidance system informs user transformation potential disabling another transformation also informs user transformation potential enabling another transformation interactions among transformations also used determine pairwise orderings transformations instance table 3 indicates applying cpp ctp cpp applied first information gleaned table 42 genesis automatic transformer generator tool another use framework construction transformer tool automatically produces transformation code specified transformations genesis tool analyzes gospel specification generates code perform appropriate pattern matching check required data dependences call necessary primitive routines apply specified transformation 19 figure 6 presents pictorial description design genesis value genesis greatly reduces programmers burden automatically generating code rather programmer implement optimizer hand figure 6 code transformer developed generator constructor generator produces code specified transformations utilizing predefined routines transformer library including routines compute data control dependencies constructor packages code produced generator library routines adds interface prompts interaction user generator section genesis analyzes gospel specifications using lex yacc producing data structures code three major sections gospel specification generator first establishes data structures code elements specifications code generated find elements required format three address code code verify required data dependences next generated finally code generated action statements genesis system 6500 lines c code include code compute data dependencies high level representation algorithm used genesis given figure 7 generated code relies set predefined routines found transformer library routines transformation independent represent routines typically needed perform transformations library contains pattern matching routines data dependence computation algorithms data dependence verification procedures code manipulation routines pattern matching routines search loops statements possible pattern found generated code called verify items operands opcodes initial final values loop control variables possible application point found intermediate code data dependences must verified data dependence verification may include check nonexistence particular data dependence search dependences search one dependence within generator constructor gospel specifications transformations library routines transformed applying user options transformer code transforming system code perform figure 6 overview genesis loop set generated code may simply ensure dependence exist may complex integration tests loops example statements dependent need examined code generated collect statements required direction vectors associated dependence specification matched direction vectors dependences exist source program dependences verified action executed routines consisting actions specified action section specification generated appropriate code elements constructor compiles routines transformer library generated code produce transformer set transformations specified constructor also generates interface execute various transformations interface transformer reads source code generates intermediate code computes data dependences interface also queries user interactive options interactive capability permits user execute genesis iterate transformation list readgospel specification transformation analyze gospel specifications using lex yacc gen code setup data structures gen code search patterns gencodedependverifydatadependences gen code verify data dependences gen code perform primitive actions end create interface template constructoptimizergeneratedcode libraryroutines readsourcecode convert source intermediate representation userinteractiondesired selecttransformations selectapplicationpoints computedatadependences performoptimization usersdirection endwhile figure 7 genesis algorithm number transformations order user may elect perform transformation one application point possibly overriding dependence constraints possible points program 421 prototype implementation order test viability robustness approach implemented prototype genesis produced number transformers ease experimentation prototype produces transformer every transformation specified transformation specified generator produces four procedures tailored transformation setuptrans matchtrans pretrans acttrans procedures correspond declaration codepattern depend action sections specifications implementation transformer consists driver calls routines generated specifically transformation code driver given figure 8 format driver transformer generated driver calls procedures generated call interface specific transformation setuptrans matchtrans pretrans acttrans call interface turn calls generated procedures implement transformation generated transformation specific code ctp given figure 9 setuptrans procedure consists single call setupctp driver requires successful pattern match matchctp prectp order continue thus matchtrans pretrans call interface procedures return boolean value done false matchsuccess match match code patterns matchsuccess presuccess precondition verify dependences presuccess perform actions optimization done true end figure 8 driver algorithm generated setup procedure consists code initializes data structures element specified using precondition section type table data structure typetable contains identifying information statement loop variable specified declaration section typetable holds identifier string creates entry quantifier may used identifier precond section maintains type identifier eg statement loop adjacent loop nested loop type statement entry initialized type corresponding identifier looptyped variable specified additional flags nested adjacent loops set type table entry entries filled information relevant element found transformations performed statement declaration section call typetableinsert generated identifier type identifier placed setup procedure execution ctp shown figure 9 type table entry initialized type statement identifier transformer executes procedure setupctp setupctp procedure terminates driver indirectly initiates exhaustive search statement recorded type table calling matchctp source programs statement match transformer driver restarts search new statement match procedure generated statements codepattern section gospel specification quantified statement codepattern section call settableinsert made identifier type identifier quantifier settableinsert searches requested type initializes settable data structure appropriate attributes type eg statement opcode operands set next restrictions codepattern section directly translated conditions statements determine requested restrictions met current quantifier loop generated check objects found settable ctp example figure 9 code generated searches assignment statement constant right hand side next routine pre procedure generated statements depend section quantified statement call settableinsert generated however pattern matching performed runtime ctp example prectp procedure inserts element settable structure dependence condition statement j inserted settable dependence library routine called find first statement flow dependent statement found condition fails l also inserted settable dependence routine called l l flow dependent j examined determine operand l causing dependence variable involved dependence j l found condition fails next assignment statement generated assign hits field settable data structure result requested dependence membership procedure call example setting hits field result flowdependence call hits field contain either 1 quantifier many quantifier statement numbers flow dependent required direction vector next statements directly generated relational conditions exist specification last procedure called action procedure action procedure generated statements action section gospel specification individual action call primitive transformation made required parameters eg modify requires object modified new value gospel forall construct used loop type table insertstatement si set type table statement table insertstatement si classify set statements set table siopcodekind assgn return failure j opcode assgn fail set table sioperandakind const match successful prectp table insertstatement sj classify j set statements table insertstatement sl classify l set statements table find assign flow dep j ifset table sihits null flow dep j exist try return failure table foreachsettableslhits quadnumbers involved dependencies modify one j operands ifsioprcsjorpa modify sjopra sioprc else endif figure 9 generated code ctp return failure generated calls primitive transformations placed within loop example figure simply modifies operand collected j modification occurs either first second modify statement depending operand carries dependence thus first call modify considers operand j replacement second call considers operand b replacement effectively implementing pattern matching needed determining operand position dependence procedure actctp called driver matchctp prectp terminated successfully implementation details reader referred another paper 5 experimentation using prototype implementation genesis performed experiments demonstrate genesis used explore properties transformations including 1 frequency applying transformations 2 interactions occur among transformations using genesis transformers produced ten twenty transformations specified lur fus experimentation performed using programs found hompack test suite numerical analysis test suite 2 short description gospel specifications transformations given appendix b hompack consists fortran programs solve nonlinear equations homotopy method numerical analysis test suite included programs fast fourier transform programs solve nonlinear equations using newtons method total ten programs used experimentation benchmark programs coded fortran language accepted front end ranged size 110 900 lines intermediate code statements programs numerical nature mixture loop structures including nested adjacent single loops traditional optimizations parallelizing transformations could applied programs interested interaction types transformations longer programs would likely show opportunities transformations thus opportunities interactions order verify genesis capability find application points four transformations specified gospel run hompack test suite number application points transformations recorded compared number application points found tiny 20 comparison revealed genesis found number applications points tiny found furthermore seven optimizations specified gospel optimizers generated genesis generated optimizers compared handcoded optimizer verify genesis ability find application points optimizers generated genesis found application points optimizations test programs ctp frequently applicable transformation often enabled application points icm found noted intermediate code include address calculations array accesses may introduce opportunities icm ctp also found create opportunities apply number transformations expected total 97 application points ctp 13 enabled dce 5 enabled cfo 41 enabled lur assuming constant bounds needed unroll loop cpp occurred two programs create opportunities transformation results shown table 4 entry indicates interaction theoretically possible number gives number interactions occurred example entry inxfus indicates 5 enabling interactions found 4 disabling interactions found 13 application points investigate ordering transformations considered transformations fus inx lur showed section 4 theoretically enable disable one another one program fus inx lur applicable heavily interacted one another creating destroying opportunities transformations example applying fus disabled inx applying lur disabled fus different orderings produced different transformed programs transformations also interacted three transformations applied applying fus inx one instance fus program destroyed opportunity apply inx however lur applied fus inx inx disabled thus users aware applying transformation point program may prevent another transformation applicable complicate process determining beneficial ordering different parts program responded differently orderings one segment program inx disabled fus another segment inx enabled fus thus right order application context application point needed using theoretical results interactions formal specifications transformations guide user may need multiple passes discover series transformations would fruitful given system framework could also used explore value combining transformations freq dce ctp cpp cfo icm lur fus inx lur fus 11 5 0 1 10 06 table 4 enabling disabling interactions blocking transformation combines strip mining interchange 11 performed preliminary experiment applied various orders loop interchange inx loop unrolling lur loop fusion fus experiments lur followed inx produced opportunities transformations orders thus performing experimentation examine happens series transformations applied might beneficial combine certain transformations apply pair example would consider combining lur inx 6 concluding remarks code improving transformation framework presented paper permits uniform specification code improving transformations specifications developed used analysis automatically generate transformer analysis transformations enables examination properties transformations interact determine transformation creates destroys conditions another transformation relationships offer one approach determining order apply transformations maximize effects implementation gospel specifications permits automatic generation transformer automated method enables user experimentally investigate properties rapidly creating prototypes transformers test feasibility particular machine genesis also permits user specify new transformations quickly implement future work research includes examining possibility automatically proving interactions expanding specifications detailed level transformation interaction proving tool would enable user determine properties transformations also design transformation guidance system prototype examined feasibility type system would aide user applying transformations interactively providing interaction information gospel specifications also explored determine easily combined create useful transformations acknowledgment especially grateful toplas associate editor jack davidson insightful criticisms advice earlier drafts paper also thank anonymous referees helpful comments suggestions resulted improved presentation paper appendix precondition grammar gospel prototype preconlist preconlist quantifier codelist memlist conditionlist preconlist e quantifier codelist stmtid stmtidlist memlist memlist memlist memlist memlist mem mem nomem conditionlist conditionlist conditionlist conditionlist conditionlist conditionlist type stmtid stmtid dirvect type flowdep outdep antidep ctrldep dirvect dir dirlist e gospel specification transformations bumping bmp modify loop iterations bumping index preset amount eg 2 declaration precondition codepattern l depend flowdep llcv action add sprev 2 sopr 1 sopr 1 modify linitial evallinitial 2 modify lfinal evallfinal 2 constant folding cfo replace mathematical expressions involving constants equivalent value declaration precondition codepattern find constant expression const const opcode assign checks action fold constants expression modify modify opcode assign copy propagation cpp replace copy variable original declaration precondition codepattern find copy statement depend uses defs along path action propagate delete copy modify operand j pos opr 2 delete loop circulation crcinterchange perfectly nested loops two declaration precondition codepattern find tightly nested loops l 1 depend ensure perfect nesting flowdep action interchange loops move move common subexpression elimination cse replace duplicate expressions calculations perfomed declaration precondition codepattern find binary operation n depend find common subexpression action add modify n assign n opr 1 temp modify dead code elimination dce remove statements define values variables used declaration precondition codepattern find statement assigning variable value expression depend statement may used action delete dead code delete loop fusion combine loops headers declaration precondition codepattern find adjacent loops equivalent heads l 1 depend dependence backward direction first def reaching prior loops action fuse loops modify modify delete l 1 end delete l 2 head invariant code motion icm remove statements within loops values computed change declaration precondition codepattern loop l depend statement without dependence within loop k mem k l mem l action move statement within header move k lstartprev loop unrolling lur duplicate body loop declaration precondition codepattern loop iterated least const type l 1 final const checks action unroll one iteration update original loops initial modify modify l 1 initial evall 1 initial 1 delete l 2 end delete l 2 headlabel parallelization par modify loop type parallelization declaration precondition codepattern depend action modify l 1 opcode par mining smi modify loop utilize vector architecture declaration precondition codepattern l lfinal linitial sz depend action copy lhead lheadprev l 2 head modify l 2 lcv tempt modify l 2 step sz modify l 1 initial modify copy lend lend l 2 end loop unswitching uns modify loop contains contains loop declaration precondition codepattern l depend find else k mem k l ctrldeps k action copy lhead k l 2 head copy lend lendprevprev l 2 end modify l 2 end addressl 2 head move lhead move lend k prev r generation efficient interprocedural analyzers pag faires numerical analysis global code motion global value numbering automatic generation peephole transfor mations flexible architecture building data flow analyzers automatic generation fast optimizing code generators automatic generation machine specific code transformer gnu c compiler manual v peep architectural description driven peephole transformer advanced compiler transformations supercom puters general framework iterationreordering loop transformations stanford suif compiler group sharlit tool building transformers spare development environment program analysis algorithms techniques integrating parallelizing transformations compiler based scheduling methods approach ordering optimizing transforma tions investigation properties code transformations design implementation genesis automatic generation global optimizers tiny loop restructuring research tool high performance compilers parallel computing tr advanced compiler optimizations supercomputers automatic generation fast optimizing code generators approach ordering optimizing transformations automatic generation global optimizers sharlitmyampersandmdasha tool building optimizers general framework iterationreordering loop transformations techniques integrating parallelizing transformations compilerbased scheduling methods design implementation genesis global code motionglobal value numbering flexible architecture building data flow analyzers peep automatic generation peephole optimizations automatic generation machine specific code optimizers generation efficient interprocedural analyzers pag ctr prasad kulkarni david b whalley gary tyson jack w davidson search nearoptimal optimization phase orderings acm sigplan notices v41 n7 july 2006 spyridon triantafyllis manish vachharajani neil vachharajani david august compiler optimizationspace exploration proceedings international symposium code generation optimization feedbackdirected runtime optimization march 2326 2003 san francisco california prasad kulkarni david b whalley gary tyson jack w davidson exhaustive optimization phase order space exploration proceedings international symposium code generation optimization p306318 march 2629 2006 prasad kulkarni david b whalley gary tyson evaluating heuristic optimization phase order search algorithms proceedings international symposium code generation optimization p157169 march 1114 2007 mathieu verbaere arnaud payement oege de moor scripting refactorings jungl companion 21st acm sigplan conference objectoriented programming systems languages applications october 2226 2006 portland oregon usa haneda p w knijnenburg h g wijshoff generating new general compiler optimization settings proceedings 19th annual international conference supercomputing june 2022 2005 cambridge massachusetts haneda p w knijnenburg h g wijshoff optimizing general purpose compiler optimization proceedings 2nd conference computing frontiers may 0406 2005 ischia italy prasad kulkarni stephen hines jason hiser david whalley jack davidson douglas jones fast searches effective optimization phase sequences acm sigplan notices v39 n6 may 2004 stephen hines prasad kulkarni david whalley jack davidson using deoptimization reoptimize code proceedings 5th acm international conference embedded software september 1822 2005 jersey city nj usa min zhao bruce childers mary lou soffa predicting impact optimizations embedded systems acm sigplan notices v38 n7 july prasad kulkarni wankang zhao hwashin moon kyunghwan cho david whalley jack davidson mark bailey yunheung paek kyle gallivan finding effective optimization phase sequences acm sigplan notices v38 n7 july keith cooper alexander grosul timothy j harvey steve reeves devika subramanian linda torczon todd waterman exploring structure space compilation sequences using randomized search algorithms journal supercomputing v36 n2 p135151 may 2006 prasad kulkarni stephen r hines david b whalley jason hiser jack w davidson douglas l jones fast efficient searches effective optimizationphase sequences acm transactions architecture code optimization taco v2 n2 p165198 june 2005 decidability phase ordering problem optimizing compilation proceedings 3rd conference computing frontiers may 0305 2006 ischia italy keith cooper alexander grosul timothy j harvey steven reeves devika subramanian linda torczon todd waterman acme adaptive compilation made efficient acm sigplan notices v40 n7 july 2005 prasad kulkarni wankang zhao stephen hines david whalley xin yuan robert van engelen kyle gallivan jason hiser jack davidson baosheng cai mark bailey hwashin moon kyunghwan cho yunheung paek vista vpo interactive system tuning applications acm transactions embedded computing systems tecs v5 n4 p819863 november 2006 mike jochen anteneh addis anteneh lori l pollock lisa marvel enabling control adaptive program transformation dynamically evolving mobile software validation acm sigsoft software engineering notes v30 n4 july 2005 stephen drape oege de moor ganesh sittampalam transforming net intermediate language using path logic programming proceedings 4th acm sigplan international conference principles practice declarative programming p133144 october 0608 2002 pittsburgh pa usa l almagor keith cooper alexander grosul timothy j harvey steven w reeves devika subramanian linda torczon todd waterman finding effective compilation sequences acm sigplan notices v39 n7 july 2004 sorin lerner david grove craig chambers composing dataflow analyses transformations acm sigplan notices v37 n1 p270282 jan 2002 min zhao bruce r childers mary lou soffa modelbased framework approach profitdriven optimization proceedings international symposium code generation optimization p317327 march 2023 2005 sorin lerner todd millstein erika rice craig chambers automated soundness proofs dataflow analyses transformations via local rules acm sigplan notices v40 n1 p364377 january 2005 min zhao bruce r childers mary lou soffa approach toward profitdriven optimization acm transactions architecture code optimization taco v3 n3 p231262 september 2006 ganesh sittampalam oege de moor ken friis larsen incremental execution transformation specifications acm sigplan notices v39 n1 p2638 january 2004 mathieu verbaere ran ettinger oege de moor jungl scripting language refactoring proceeding 28th international conference software engineering may 2028 2006 shanghai china david lacey neil jones eric van wyk carl christian frederiksen compiler optimization correctness temporal logic higherorder symbolic computation v17 n3 p173206 september 2004 oege de moor david lacey eric van wyk universal regular path queries higherorder symbolic computation v16 n12 p1535 marchjune
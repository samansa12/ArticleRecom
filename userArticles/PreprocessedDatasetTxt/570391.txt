answer set programming plan generation idea answer set programming represent given computational problem logic program whose answer sets correspond solutions use answer set solver smodels dlv find answer set program applications method planning related line research frame problem started invention formal nonmonotonic reasoning 1980 b introduction kautz selman 19 proposed approach problem plan generation reducing problem nding satisfying interpretation set propositional formulas method known satisability planning used several planners 1 paper discuss related idea due subrahmanian zaniolo 36 reducing planning problem problem nding answer set stable model logic program advantage answer set programming approach planning representation properties actions easier logic programs used instead axiomatizations classical logic view nonmonotonic character negation failure two best known answer set solvers systems computing answer sets available today smodels 2 dlv 3 results computational experiments use smodels planning reported 4 30 latest system kind created inventors satisability planninghttpwwwtcshutfisoftwaresmodels httpwwwdbaituwienacatprojdlv paper based earlier reports 22 23 applications answer set programming planning discussed perspective research frame problem nonmonotonic reasoning done ai since 1980 specically relate line work started invention default logic 33the nonmonotonic formalism turned particularly closely related logic programming 2 26 10 publication yale shooting scenario 14 widely believed solution frame problem outlined 33 inadequate several alternatives proposed 18 20 34 15 21 29 8 turned however approach 33 completely satisfactory rest default theory set correctly 37 fact general discussed section 52 see descriptions actions style 33 37 used basis planning using answer set solvers next section review concept answer set dened 9 10 25 relation default logic describe computational possibilities answer set solvers section answer set programming method 27 30 applying graphtheoretic search problem section 4 section 5 turn use answer set solvers plan generation section 6 describes relation work research actions planning answer sets 21 logic programs begin set propositional symbols called atoms literal expression form atom call classical negation distinguish symbol used negation failure rule element expression form l l l literal rule ordered pair head body 1 head body nite sets rule elements rule 1 constraint disjunctive cardinality head greater 1 write 1 2 drop 2 body rule empty program set rules denitions dier traditional description syntax logic programs several ways first rules propositional atoms assumed formed predicate symbols constants variables input le given answer set solver usually contain schematic rules variables schematic rule treated abbreviation set rules obtained grounding result grounding propositional object like set clauses would given input satisability solver hand ways 2 general rules found traditional logic programs l may contain classical negation symbol traditional logic programs use one kind negationnegation failure head 2 may contain several rule elements traditionally head rule single atom negation failure symbol allowed occur head rule body traditional logic programming see later additional expressivity given syntactic features indeed useful 22 denition answer set notion answer set dened rst programs contain negation failure l k every rule 2 program let program let x consistent set literals say x closed every rule 1 head x body x say x answer set x minimal among sets closed relative set inclusion instance program two answer sets add constraint 3 get program whose answer set rst sets 4 hand add rule 3 get program whose answer set fp q rg extend denition answer set programs negation failure take arbitrary program let x consistent set literals reduct x relative x set rules rules 2 x contains literals l contain lm1 thus x program without negation failure say x answer set x answer set x consider instance program q q r r let x fp rg reduct 5 relative set consists two rules since x answer set reduct answer set 5 easy check program 5 answer sets example illustrates original motivation denition answer setproviding declarative semantics negation failure implemented existing prolog systems given program 5 prolog system respond yes query query p r say query belongs answer set 5 sense role answer sets similar role concept completion 3 provides alternative explanation behavior prolog p r entailed programs completion 23 comparison default logic let program head every rule single literal transform propositional default theory sense 33 turning rule 6 default simple correspondence answer sets extensions default theory dt x answer set deductive closure x consistent extension dt conversely every consistent extension dt deductive closure answer set instance default theory corresponding program 5 r extension default theory deductive closure programs answer set fp rg correspondence rule without negation failure represented default without justications say inference rule facta rule empty bodycorresponds default neither prerequisites justications axiom normal counterpart rule q p q 8 logic programs dened general defaults rules may several elements head elements may include negation failure hand defaults general may contain arbitrary propositional formulas literals conjunctions literals connection interesting note one technical issues related yale shooting controversy whether eects actions described axioms loaded inference rules loaded according 37 formulation 10 better choice language logic programs 10 would written aliveresultshoot loaded formula 9 hand correspond rule sense logic programming paradoxically limitations language logic programs play positive role case eliminating bad representational choices available properties actions described default logic 24 generating eliminating answer sets perspective answer set programming two kinds rules play special role generate multiple answer sets used eliminate answer sets program one way write program many answer sets use disjunctive rules several atoms program consists n rules form 2 n answer sets instance program 4 answer sets observed 5 rule 11 equivalently replaced program two nondisjunctive rules notation default logic rules written alternatively program many answer sets formed using rules form l 12 l literal rule two answer sets flg program consists n rules form 12 2 n answer setsall subsets set literals occurring rules instance answer sets program q q 13 4 subsets fp qg rules used eliminate undesirable answer sets constraintsrules empty head saw section 22 appending constraint q program 3 eliminates one two answer sets 4 eect adding constraint program always mono tonic collection answer sets extended program part collection answer sets original program precisely say set x literals violates constraint program obtained program adding constraint 14 set x literals answer set 0 x answer x violate constraint 14 instance second answer sets 4 program 3 violates constraint q rst doesnt accordingly adding constraint 3 eliminates second programs answer sets see rules kindsthose generate answer sets eliminate themcan work together consider following translation propositional theories logic programs let set clauses let program consisting rules 11 atoms occurring constraints l clauses l 1 l n l denote literal complementary l answer sets 11 correspondence truth assignments satisfying every truth assignment represented set literals assigns value true 3 answer set solvers system dlv computes answer sets nite programs without negation failure heads rules l k every rule 2 program instance given input le r p return answer sets program 3 given input le p q q r r return answer set program 5 system smodels requires additionally input program contain disjunctive rules limitation mitigated two circumstances first input language smodels allows us express exclusive disjunctive rule disjunctive rule accompanied constraints combination represented second smodels allows us represent important disjunctive combination 12 head rule enclosing l braces f l g list rules form conveniently represented smodels input le one line instance rules 13 written simply pq dlv smodels allow user specify large programs compact fashion using rules schematic variables abbrevia tions systems employ sophisticated grounding algorithms work fast simplify program process grounding joinedxy edgexy joinedxy edgeyx inx iny xy joinedxy vertexx vertexy hide show inx figure 1 search large clique 4 answer set programming idea answer set programming represent given computational problem program whose answer sets correspond solutions use answer set solver nd solution example show method used nd large clique subset v vertices given graph every two vertices v joined edge cardinality v less given constant j figure 1 shows smodels input le used nd large clique determine exist le supposed accompanied le describes graph species value j one shown figure 2 possible values variables x figure 1 restricted domain predicates vertex edge case graph described figure 2 predicate vertex holds numerals const j3 vertex05 edge01 edge12 edge20 edge34 edge45 edge53 edge40 edge25 figure 2 test clique program predicate edge holds 8 pairs vertices accordingly expression beginning figure 1 set atoms inx x vertexx meaning in0 in1 in2 in3 in4 in5 last expression understood abbreviation set rules form 12 discussed section 3 answer sets set rules arbitrary sets formed 6 atoms symbol j beginning rule restricts answer sets whose cardinality least j instance cardinality construct available smodels 31 allows user bound number atoms certain form included answer set lower bound placed left expression braces example upper bound would placed right main parts program figure 1 two labeled generate test former denes large collection answer setspotential solutions latter consists constraints weed answer sets correspond solutions discussed potential solution subset vertices whose cardinality least j constraints eliminate subsets cliques similar use generating eliminating rules section 24 part labeled define contains denition auxiliary predicate joined part labeled display tells smodels elements answer set included output instructs system hide literals encode clique case problem shown figure 2 part answer set displayed smodels discussion example terms generating set potential solutions testing elements illustrates declarative meaning program understood description actually happening operation answer set solver system smodels process program shown producing answer sets generate part checking whether satisfy constraints test part reasonable satisability solver search model given set clauses generating possible truth assignments checking whether clauses satised search procedures employed systems smodels dlv use sophisticated search strategies somewhat similar used ecient satisability solvers answer set programming found applications several practically important computational problems 30 35 16 one problems planning 5 planning 51 example code figures 35 allows us use smodels solve planning problems blocks world imagine blocks moved robot several grippers blocks moved simultaneously however robot unable move block onto block moved time usual blocks world planning assume block moved blocks top three domain predicates example time block location location block table constant lasttime upper bound lengths plans considered nd shortest plan one use minimize feature smodels discussed paper generate section denes potential solution arbitrary set move actions executed prior lasttime every number actions executed time exceed number grippers rules labeled define describe sequence states corresponding execution given potential plan sequence states represented complete set literals define rules figure 5 specify positive literals describing initial positions blocks rst two define rules figure 3 specify positive literals describing po time0lasttime locationb blockb locationtable timet tlasttime effect moving block blockb locationl timet tlasttime onblt onblt1 locationl blockb timet tlasttime uniqueness location blockb locationl locationl1 timet figure 3 planning blocks world part 1 two blocks cannot top block blockb timet block cant moved unless clear blockb blockb1 locationl timet tlasttime block cant moved onto block moved also blockb blockb1 locationl timet tlasttime hide show moveblt figure 4 planning blocks world part 2 const grippers2 const lasttime3 block16 initial state goal on120 on2table0 on340 on4table0 on560 on6table0 on32lasttime on21lasttime on1tablelasttime on65lasttime on54lasttime on4tablelasttime figure 5 test planning program sitions blocks time t1 terms positions time uniqueness location rule species negative literals included answer set terms positive literals answer set note second define rule figure 3 smodels representation normal default consistent assume time t1 block b location time indeed location see section 23 default interesting compare solution frame problem proposed reiter 1980 33 section 114 take relation r tuple arguments x b l expression turn dierence defaults 15 16 rst describes change terms passage time becomes 1 latter terms state transitions becomes fb l consider three constraints labeled test figure 4 role rst constraint prohibit indirectly actions would create physically impossible congurations blocks moving two blocks onto block b two constraints express robots limitations mentioned beginning section adding constraints program eliminates answer sets corresponding sequences actions executable given initial state extend program adding test section figure 5 eliminate addition sequences actions lead goal state answer sets program 11 correspondence solutions given planning problem display section instructs smodels hide literals except begin move part answer set displayed smodels list actions included plan stable model move3table0 move1table0 move541 true duration 0340 52 discussion description blocks world domain figures 3 4 sophisticated several ways shooting example 14 seemed dicult formalize 1987 first version blocks world includes concurrent execution actions second eects moving block described indirectly shooting domain eects actions specied explicitly told action load aects uent loaded action shoot aects uent alive description blocks world given dierent block 1 located top block 2 moved onto table action aects two uents on1 table becomes true on1 2 becomes false rst two eects described explicitly rst define rule figure 3 description second eect indirect uniqueness location rule allows us conclude block 2 top block 1 anymore fact block 2 table ramication problemthe problem describing indirect eects actionsis addressed classical action representation formalisms strips 7 adl 32 finally executability actions described example indirectly well discussed impossibility moving two blocks b 1 b 2 onto block b implicit description blocks world executing action would created conguration blocks prohibited one constraints figure 4 strips adl executability action described explicitly listing actions preconditions usual description blocks world asserts instance moving one block top another executable target location clear description applicable however several blocks moved simultaneously initial state shown figure 5 block 1 moved onto block 4 block 3 moved time fortunately answer set approach describing actions adopted specifying action preconditions explicitly unnecessary usefulness indirect descriptions action domains applications ai demonstrated recent report 38 modelling reaction control system rcs space shuttle system consists several fuel tanks oxidizer tanks helium tanks maneuvering jets pipes valves components behavior rcs aected ipping one switches according 38 action one direct eect trivial changing position switch causes switch new position also postulate asserting valve functional stuck closed switch controlling open closed position valve open closed two facts together tell us certain conditions ipping switch indirectly aects corresponding valve furthermore helium talk correct pressure open path propulsion tank paths leak propulsion tank correct pressure also using postulate conclude certain conditions ipping switch aects pressure propulsion tank multilevel approach describing eects actions leads wellstructured easy understand formal description operation rcs answer set programming approach handles multileveled descriptions quite easily 6 relation action languages satisability planning recent work representing properties actions formulated terms highlevel action languages 12 11 c 13 descriptions actions languages concise logic programming representations example counterparts rst two define rules figure 3 language c moveb l causes onb l inertial onb l design language c based system causal logic proposed 28 large class action descriptions c equivalent translation logic programming notation dened 24 possibility translation illustrates expressive power action representation method used paper noted introduction answer set programming approach planning related satisability planning fact formal connection two methods program without classical negation positiveorderconsistent tight answer sets characterized collection propositional formulas 6the formulas obtained applying completion process 3 program translations language c described 24 happen produce tight programs describing planning problem program like translating program propositional logic nally invoking satisability solver nd plan form satisability planning viewed also answer set programming without answer set solvers 1 essentially planning performed causal calculator 4 7 conclusion answer set programming solutions combinatorial search problem represented answer sets plan generation domains involve actions indirect eects promising application area programming method systems smodels dlv allow us solve nontrivial planning problems even absence domainspecic control information larger problems however information becomes necessity possibility encoding domainspecic control knowledge used answer set solver crucial progress area possibility using control knowledge propositional solvers crucial progress satisability planning 17 topic future work acknowledgements useful comments preliminary versions paper provided maurice bruynooghe marc denecker esra erdem selim erdogan paolo ferraris michael gelfond joohyung lee nicola leone victor marek norman mccain ilkka niemela aarati parmar teodor przymusinski miros law truszczynski hudson turner work partially supported national science foundation grant iis9732744 r fages theorem answer set programming minimalism subsumes default negation failure encoding planning problems nonmonotonic logic programs transformations logic programs related causality planning strips new approach application theorem proving problem solving autoepistemic logic formalization commonsense reasoning stable model semantics logic programming logic programs classical negation representing action change logic programs action languages action language based causal explanation preliminary report nonmonotonic logic temporal projection simple causal minimizations temporal persistence projection using logic programs stable model semantics solve deadlock reachability problems 1safe petri nets control knowledge planning bene logic persistence planning satis pointwise circumscription preliminary report formal theories action preliminary report action languages answer set planning representing transition systems logic programs answer sets general nonmonotonic reasoning preliminary report victor marek miros law truszczy victor marek miros law truszczy causal theories action change anomalous extension problem default reasoning ilkka niemel ilkka niemel adl exploring middle ground strips situation calculus logic default reasoning chronological ignorance time timo soininen ilkka niemel relating stable models ai planning domains representing actions logic programs default theories situation calculus approach application action theory space shuttle tr nonmonotonic logic temporal projection anomalous extension problem default reasoning autoepistemic logic formalization commonsense reasoning preliminary report logic programs classical negation adl planning satisfiability action language based causal explanation control knowledge planning answer set planning extending implementing stable model semantics logic programs stable model semantics constraint programming paradigm developing declarative rule language applications product configuration application action theory space shuttle representing transition systems logic programs transformations logic programs related causality planning using logic programs stable model semantics solve deadlock reachability problems 1safe petri nets encoding planning problems nonmonotonic logic programs ctr esra erdem vladimir lifschitz tight logic programs theory practice logic programming v3 n4 p499518 july de vos vermeir extending answer sets logic programming agents annals mathematics artificial intelligence v42 n13 p103139 september 2004 enrico giunchiglia joohyung lee vladimir lifschitz norman mccain hudson turner nonmonotonic causal theories artificial intelligence v153 n12 p49104 march 2004 josefina sierrasantibez heuristic planning declarative approach based strategies action selection artificial intelligence v153 n12 p307337 march 2004 chiaki sakama induction answer sets nonmonotonic logic programs acm transactions computational logic tocl v6 n2 p203231 april 2005 ernest davis leora morgenstern introduction progress formal commonsense reasoning artificial intelligence v153 n12 p112 march 2004 thomas eiter axel polleres towards automated integration guess check programs answer set programming metainterpreter applications theory practice logic programming v6 n12 p2360 january 2006 davy van nieuwenborgh dirk vermeir preferred answer sets ordered logic programs theory practice logic programming v6 n12 p107167 january 2006 tran cao son chitta baral nam tran sheila mcilraith domaindependent knowledge answer set planning acm transactions computational logic tocl v7 n4 p613657 october 2006 pascal hitzler matthias wendt uniform approach logic programming semantics theory practice logic programming v5 n12 p93121 january 2005 marcello balduccini enrico pontelli omar elkhatib hung le issues parallel execution nonmonotonic reasoning systems parallel computing v31 n6 p608647 june 2005 chiaki sakama katsumi inoue abductive framework computing knowledge base updates theory practice logic programming v3 n6 p671715 november nicola leone gerald pfeifer wolfgang faber thomas eiter georg gottlob simona perri francesco scarcello dlv system knowledge representation reasoning acm transactions computational logic tocl v7 n3 p499562 july 2006 logic programming knowledge representationthe aprolog perspective artificial intelligence v138 n12 p338 june 2002
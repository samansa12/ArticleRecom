parallel algorithms adaptive mesh refinement computational methods based use adaptively constructed nonuniform meshes reduce amount computation storage necessary perform many scientific calculations adaptive construction nonuniform meshes important part methods paper present parallel algorithm adaptive mesh refinement suitable implementation distributedmemory parallel computers experimental results obtained intel presented demonstrate scientific computations involving finite element method algorithm exhibits scalable performance small run time comparison aspects scientific computations examined also shown algorithm fast expected running time parallel random access machine pram computation model b introduction adaptive mesh refinement techniques shown successful reducing computational storage requirements solving many partial differential equations 10 rather use uniform mesh grid points evenly spaced domain adaptive mesh refinement techniques place grid points areas local error solution large mesh adaptively refined andor unrefined computation according local error estimates domain technique much efficient use uniform meshes solution changing much rapidly areas others adaptive construction nonuniform meshes crucial part adaptive mesh solution methods examined many researchers example 3 10 11 12 13 14 15 16 18 typically one begins initial mesh conforming particular geometry mesh selectively refined based local error estimates construct mesh satisfies certain error tolerance research focused meshes composed simplicial ele ments line segments one dimension triangles two dimensions tetrahedra three dimensions paper focuses primarily twodimensional simplicial meshes however algorithms analyses presented applicable dimensions nonsimplicial meshes paper present new parallel algorithm adaptive construction nonuniform meshes algorithm well suited implementation mediumgrained distributedmemory parallel computers intel delta algorithm based simplicial bisection algorithm given rivara 15 algorithm scalable expected run time slowly growing function triangles mesh work supported part office scientific computing us department energy contract w31109eng38 address first author computer science department university tennessee knoxville tn 37996 address second author mathematics computer science division argonne national laboratory 9700 south cass avenue argonne il 60439 demonstrate performance algorithm present experimental results obtained intel delta results demonstrate practical scientific calculations algorithm exhibits scalable performance run time much smaller computations necessary entire solution method paper organized follows x2 review methods adaptive mesh refinement x3 present algorithm analyze expected run time pram computation model mediumgrained distributedmemory version algorithm detailed x4 discuss experimental results intel x5 finally x6 summarize research discuss possible future work 2 adaptive refinement methods finite element method proven extremely effective computation approximate solutions partial differential equations pdes focus adaptive local refinement strategies generating finite element meshes approach obtain much accurate solutions problems uniform mesh number elements computation approximate solution pde consists three main tasks 1 construction finite element mesh 2 assembly sparse linear system 3 solution linear system although explicitly discussing last two tasks must kept mind particular method local error estimation requires approximate solution given element mesh parallel implementation must remember essential adaptive mesh algorithm integrated parallel algorithms matrix assembly solution resulting linear system addition adaptive strategy assignment partitioning elements vertices processors must updated modification mesh ensure continued efficient execution matrix assembly linear system solution solve pde k estimate error triangle maximum error triangle larger given tolerance based error estimates determine set triangles k refine divide triangles k triangles necessary form k1 solve pde k1 estimate error triangle endwhile fig 1 framework adaptive solution pdes consider general adaptive mesh algorithm 10 shown figure 1 begin assuming initial element mesh given triangulation consistent geometry problem domain attention focused step algorithm current mesh k adaptively refined step denoted figure 1 suppose arbitrary subset triangles k k marked refine ment developed implemented parallel algorithms constructing new mesh k1 satisfies required changes mesh keep presentation clear brief assume set k contains triangles marked refinement unrefinement however software able unrefine triangles previously refined refinement mesh must maintain several important properties given finite element approximations used first require mesh k conforming compatible intersection two triangles k single vertex line segment connecting two vertices empty set side triangle called nonconforming 0 vertices two endpoints triangle called compatible none sides 1 nonconforming examples conforming nonconforming meshes given figure 2 mesh conforming one basic type finite element necessary otherwise several special element types required andor complicated matrix assembly note however use triangles restrict one linear finite elements one use higherorder basis functions triangulation fig 2 left conforming mesh right nonconforming mesh second requirement mesh k graded smooth adjacent triangles differ dramatically area nonsmooth mesh could result finite element approximation far continuous solution final requirement angles mesh bounded away 0 latter condition necessary discretization error finite element approximation shown grow maximum angle approaches 1 would like avoid small angles condition number matrices arising mesh elements shown grow 1 min smallest angle mesh 4 21 related work number mesh refinement algorithms shown maintain mesh properties given section briefly review three widely used refinement methods begin note two methods used subdivide triangle bisection regular refinement bisection vertex triangle connected midpoint opposite side triangle figure 3 forming two triangles equal area regular refinement midpoints sides triangle connected figure 3 form four similar triangles fig 3 left triangle divided bisection right triangle divided using regular refinement regular refinement algorithm bank sherman weiser 3 used successfully software package pltmg 2 triangles divided using regular refinement temporary bisections selected triangles make mesh conforming bisected triangles merged mesh refined merging bisected triangles level method guarantees triangle k1 either similar triangle 0 bisection triangle similar triangle 0 clearly angles k1 bounded away 0 mesh refinement algorithm 56 rivara 15 uses bisections triangles across largest edge dividing largest angle selective divisions across smaller edges approach shown yield triangulations k whose smallest angle bounded worst onehalf smallest angle 0 17 detailed discussion algorithm given following subsection newestnode algorithm sewell also based bisection without restriction bisecting longest edge 10 algorithm triangle always bisected using newest node propagation inherent bisection regular refinement algorithms avoided refining triangles pairs however pair restriction possible triangle may never able refined experiments run mitchell 10 difficulty arise mitchell compared three methods series numerical experiments found difficult choose consistently superior algorithm 10 addition found three methods superior using uniform refinement except smooth problems given similar performance three methods choose discuss bisection algorithm detail paper three reasons 1 simpler implementation standpoint regular refinement algorithm 2 manifests propagation inherent bisection regular refinement algorithms therefore demonstrates ability algorithm handle propagations 3 potential unrefinable nodes newestnode algorithm note ever algorithms applicable three algorithms addition simple modification parallel implementation required implement newestnode algorithm note williams 19 developed voxel database approach parallel mesh refinement problem approach present following section differs approach explicit parallel runtime bounds addition designed approach yield data structures suitable assembly sparse linear systems arise meshes well solution sparse linear systems sophisticated iterative direct sparse factorization methods denotes triangles yet refinedg children refined trianglesg bisect triangle q across longest edge bisect triangle r across nonconforming edge incompatible triangles embedded placed r i1 incompatible triangles placed q endwhile fig 4 bisection algorithm 22 bisection algorithm figure 4 present bisection algo rithm algorithm slightly altered ease presentation algorithm 56 presented rivara 15 however modified algorithm yields final mesh original algorithm presented rivara fig 5 process bisection algorithm shown left right initial mesh shaded triangles refined subsequently shaded triangles refined compatible illustrate bisection algorithm give example propagation figure 5 note refinement could propagate unmarked triangles adjacent marked triangles finishing rivara however shown loop terminate finite number iterations denote number iterations l p general l p depends characteristics mesh refined rivara also shown triangle k embeds 1 2 3 4 triangles resulting compatible mesh k1 show possible 2 3 4 resulting triangles figure 6 formalize following useful result 15 theorem 21 execution bisection algorithm side triangle may divided fig 6 possible divisions single triangle bisection algorithm proof vertices may created triangle member q bisects longest edgeand vertex already exist location triangle q children excluded qm steps thus may create vertices therefore triangle containing edge e creates vertex e step vertices created triangle children given creation vertex triangle b adjacent sharing e would create another vertex e member q addition children b cannot create vertices thus one vertex may inserted edge refinement 2 3 parallel adaptive refinement section present parallel algorithm adaptive refinement correctly implements bisection method illustrate key aspect algorithm synchronization necessary correct parallel execution bisection algorithm finally give analysis algorithm pram computation model first need following definitions let ng set vertices mesh mg set polygons assume final mesh consists triangles ie conforming mesh however intermediate meshes nonconforming hence allow nonconforming elements definition let e graph associated mesh edges g let dual graph associated mesh g refinement algorithm formulated within context dual graph begin pram analysis assume given time many processors triangles triangle assigned processor p analysis follows specific pram computational variant make difference one may assume crew pram model used synchronization must managed execution algorithm maintain correct neighbor information graph g dual graph modified thus processor p must keep track current neighbors note correct neighbor information g constructed straightforward way illustrate synchronization required correct execution parallel algorithm note two ways neighbor information corrupted u fig 7 left two processors creating vertex location right possible corruption neighbor information first two different processors must create vertices location bisecting triangles two vertices created location postprocessing step must included merge vertices eliminate need postprocessing proper synchronization figure 7 see example two processors p 1 p 2 creating two vertices location second must ensure outdated neighbor information propagated exam ple figure see triangle u 1 may believe triangle w neighbor rather triangle w 1 triangles u w refined simultaneously key observation synchronization problems avoided triangles independent set refined simultaneously independent set subset triangles two triangles adjacent triangles refined neighboring triangles notified another independent set chosen refinement based correctly updated neighbor information following subsection consider two possible approaches computing independent sets parallel 31 two methods computing independent sets parallel purpose running time analysis refinement algorithm review two approaches computing independent sets approaches require graph bounded degreewhich true problem consider first approach uses assignment random numbers vertices graph obtain sequence independent sets slowly growing function size graph second approach compute graph coloring use coloring generate independent sets advantage coloring approach guarantee number colors thus number independent sets independent size graph bounded degree graph however computation coloring requires use first random number approach therefore coloring useful used enough times justify initial expense first consider use independent random numbers generate independent sets suppose wish compute sequence independent sets set triangles 0 subset corresponding subgraph 0 triangle 0 assign distinct independent random number aet choose independent set 0 according following rule 2 neighbors b either b aet aet b update set triangles consideration deleting independent free generate next independent set sequence using rule process continues 0 empty set expected number independent sets given following lemma lemma 31 let 0 bounded degree undirected graph n vertices suppose vertex 0 assigned unique independent random number aet consider sequence independent sets generated rule expected number independent sets bounded eolog nlog log n proof bound consequence corollary 35 7 2 consider second approach obtaining sequence independent sets first note valid coloring graph used generate required independent sets recall function oe scoloring oet thus sequence independent sets generated scoloring assigning triangles color one sets efficiently compute coloring use parallel greedy heuristic presented 7 outline heuristic presented figure 8 independent sets required heuristic generated using random number method described greedy step heuristic color assignment smallest consistent color smallest color assigned neighbor 0 choose independent set 0 color parallel choosing smallest consistent color oet 2 fig 8 outline parallel greedy coloring heuristic advantage using coloring generate independent sets bounded degree graph maximum number colors independent size graph include wellknown result following lemma lemma 32 consider bounded degree graph maximum degree delta parallel greedy coloring heuristic computes scoloring proof every vertex colored greedy heuristic assigning smallest consistent color since worst every neighbor different color maximum color assigned required degree plus one thus maximum color assigned greedy heuristic vertex delta sum available two methods generating sequence independent sets required parallel refinement algorithm following pram running time analysis turns best running time bound obtained maintaining coloring dual graph comprising triangles fined however practice overhead associated maintaining coloring advantageous hence first approach used practical algorithm presented x4 32 pram adaptive refinement algorithm figure 9 present pram algorithm avoids synchronization problems discussed simultaneously refining triangles independent sets note independent sets used refinement also used update coloring update required dual graph modified bisection triangle remainder section show algorithm avoids two possible synchronization problems fast run time based local error estimates set triangles q 0 marked refinement triangle j q 0 assigned random number aet j subgraph dq 0 colored parallel greedy coloring heuristic finner loopg choose independent set q simultaneously bisect triangles embedded across longest edge simultaneously bisect triangles embedded r across nonconforming edge new triangle j assigned smallest consistent new processor processor owning bisected triangle updates information processors owning adjacent triangles endwhile incompatible triangles embedded incompatible triangles endwhile fig 9 parallel algorithm refinement assume initial dual graph bounded degree fact triangulation surface primary interest assume triangle edge shared two triangles initial triangulation case maximum degree initial conforming mesh three fact bounded degree useful following runtime proof also useful practice design data structures software simplified maximum number neighbors graph bounded small constant show degree intermediate nonconforming dual graph bounded twice initial maximum degree lemma 33 dual graph bounded degree times execution algorithm fact degree vertex never exceeds six result maximum number colors required times execution algorithm color seven less proof theorem 21 triangle edge divided therefore triangle double number neighbors lemma 32 maximum degree dual six seven colors required execution refinement algorithm 2 degree dual graph remains bounded note work assigned processor one pass inner loop algorithm done constant time pram computational model show two possible corruption problems discussed cannot occur lemma 34 neighbor information dual graph correctly updated execution refinement algorithm proof proof induction assume initial neighbor information correct neighbor information correct following step refined step properties independent set none neighbors refined triangles 1 2 resulting bisection correct information neighbors former neighbors therefore notified refinement given correct information new neighbors thus following step refinement algorithm modified neighborhood information correct 2 vertices created position execution refinement algorithm proof proof induction assume vertices unique initially following step 1 vertex created position step two different processors one two situations must occur 1 two processors must simultaneously refine edge 2 processor must refine previously refined edge notified vertex created edge first condition prevented definition independent setno adjacent triangles refined simultaneously second condition prevented correct notification neighbor information ensured lemma 34 2 finally give bound expected running time refinement algorithm theorem 36 recall l p number loop iterations serial bisection algorithm figure 4 algorithm given figure 9 terminates finite number steps expected run time pram computational model eo logjq 0 j log logjq 0 j proof first consider expected running time compute initial coloring dq 0 lemma 31 time eo logjq 0 j log logjq 0 j next consider running time inner loop refinement algorithm step define graph set triangles refined step set f subset edges b f b 2 lemma 33 know always bounded degree graph also lemma 33 number colors required thus number independent sets bounded constant hence work assigned processor inner loop bisection triangle updating coloring neighbor notification takes time bounded constant independent mesh size finally must show takes l p iterations outer loop form conforming mesh clearly every triangle becomes incompatible step refined step sequential algorithm figure 4 thus number iterations outer loop algorithm identical l p hence total expected running time entire algorithm bounded log logjq 0 j close section several notes running time analysis first since typically context initial mesh refined obtained previous level refinement initial coloring step would required instead coloring mesh could maintained levels refinement using information pram running time algorithm would ol p fig 10 left shaded triangle marked refinement right resulting conforming mesh refinement note refinement propagated every triangle mesh one finally close analysis comments l p length propagation point easy construct worst case example j example figure 10 give example generalized illustrate worst case behavior however another way looking example assume particular mesh generated previous refinements starting single triangle case average length propagation l p levels refinement actually constant furthermore note experimental results presented x5 average number independent sets required obtain conforming mesh appears bounded small constant independent size mesh thus believe possible worst case behavior l p ominous problem appears could practical implementation 4 distributedmemory implementation use practical parallel computer must modify pram algorithm analyzed preceding section rather assigning single triangle vertex processor assign set vertices triangles processor vertices v partitioned disjoint subsets owns subset v j choose partition vertices rather triangles found makes finite element evaluation mesh refinement sparse matrix assembly solution necessary straightforward efficient based partitioning v determine partitioning disjoint subsets processor j owns subset j practice one assume least one vertex triangle j set v j communication purposes processor j stores set triangles set triangles adjacent triangle j dual graph set triangles containing vertex v j addition processor j stores set vertices set vertices contained triangles given sets processor j information necessary evaluate finite elements vertices v j assemble complete rows andor columns sparse matrix associated vertex v j perform parallel refinement algorithm yet specified triangles j illustrate sets processor j figure 11 figure partitioned vertices geometric cuts represented orthogonal dashed lines vertices interior four dashed lines assigned processor jthe set v j shown filled vertices set set unfilled filled vertices j set shaded triangles set unshaded shaded triangles fig 11 illustration sets maintained processor j set vertices assigned processor j v j shown set filled vertices set shaded triangles set j union set shaded unshaded triangles union set filled unfilled vertices figure 12 present practical version pram algorithm given figure 9 algorithm ensures vertices created location sets j processor j correct note modified algorithm triangle vertex created processor j processor j owner inner outer loops pram algorithm combined single loop greater efficiency separate loops allowed clearer presentation runtime bounds necessary section based local error estimates initial set triangles q marked refinement triangle 2 q assigned random number aet q r 6 choose independent set triangles q r processor j bisects triangles j embedded q across longest edge processor j bisects triangles j embedded r across nonconforming edge new triangle b new random number aet b chosen new triangle b created processor j added j new vertex v k created processor j added v j triangle 2 j notification bisection sent processor l adj processor receives notification updates sets incompatible triangles embedded w incompatible triangles r endwhile fig 12 practical parallel algorithm refinement algorithm independent sets chosen according slightly different rule rule used pram algorithm triangle j neighbors b one following hold c aet aet b modification allows two triangles processor refined step computation independent sets requires communication processor necessary information computation communication random numbers necessary seed given pseudorandom number generator used determine aet based solely thus communication necessary algorithm notification bisections global reduction required determine whether efficiency notification messages packed processor receives one message another processor time loop modified algorithm figure 12 uses essentially synchronization scheme presented x3 collisions avoided neighbors separate processors simultaneously bisected thus following theorem theorem 41 changes made processors trianglesvertices sets v j processor j received sets kept updated throughout algorithm figure 12 proof sets j v j updated correctly processor j bisect triangles set create new vertices set changes triangles vertices attributable changes triangles vertices directly communicated algorithm remaining portion attributable v j accounted bisected another processor notification bisection sent received finally show vertex neighbor information correct note neighbor information correct subgraph induced neighbor information contained subgraph g induced must also correct 5 experimental results section computational results presented demonstrate parallel refinement algorithm scalable execution time negligible compared computations required solve pde parallel refinement algorithm implemented subroutine library called application program chameleon 5 used achieve portability across several architectures including intel delta focus section note addition refinement algorithm subroutine library also includes similarly constructed parallel unrefinement algorithm unrefinement algorithm necessary many applications including one used performance similar refinement algorithm results included well results presented parallel refinement algorithm two different twodimensional pdes poissons equation equations linear elasticity problems solved two different geometries 51 test problems first set test problems models poissons equa tion square domain linear finite element approximation used function fx gaussian charge distribution centered point x domain mesh selectively refined according energy norm 10 estimate local error triangle less specified tolerance point x moved several times new solutionmesh found old solutionmesh movement requires significant mesh refinement around new charge position definement around old position remainder mesh remains relatively constant parallel conjugate gradient method preconditioned incomplete factorization used solve sparse linear systems arise 6 second problem considered linear elasticity equations plane stress problem given without inclusion load xy xy u v x displacements respectively equations solved rectangular region central hole one side region constrained zero displacement constant traction applied opposite side linear finite elements used approximate equations mesh selectively refined according energy norm local error estimate triangle less specified tolerance linear systems solved using code used poisson problem problem set initial coarse mesh approximately 200 nodes except running 128 256 nodes cases initial coarse meshes approximately 2 4 times larger respectively problems carefully choosing maximum tolerance local error estimator one determine maximum number vertices solution meshes following two problem sets constructed final solution mesh successive problem roughly twice many verticestriangles previous problem information two problem sequences given tables 1 2 table sequence test problems based poisson problem maximum number maximum number ratio area vertices triangles largest triangle name adaptive mesh adaptive mesh smallest triangle poisson1 2673 5268 256 poisson2 5176 10260 512 poisson3 10238 20330 512 poisson4 20296 40412 1024 poisson6 80116 159872 2048 poisson7 159758 318948 2048 sequence test problems based linear elasticity equations plane stress problem maximum number maximum number ratio area vertices triangles largest triangle name adaptive mesh adaptive mesh smallest triangle tables 3 4 give number refinement steps required problem solution process refinement step consists finding approximate solution pde current mesh k solving sparse linear system arising finite element model computing estimates local error triangle refining k according estimates obtain conforming mesh k1 one observes unexpectedly takes mesh refinement steps construct larger meshes addition number iterations loop algorithm figure 12 given number iterations least l p perhaps slowly growing function mesh size use random number rule generate independent sets one notes number loop iterations needed slowly growing function number processors problem size result indicates one general achieve scalable performance may expected theorem 36 poisson problem set charge location moved twice movement meant two solution steps mesh refined around charge also unrefined around old charge position however still refinement operationssteps unrefinement operations unrefinement necessary elastic problem set load function unchanged good partitioning vertices problems necessary new algorithm perform efficiently many good partitioning methods available geometric partitioning algorithm 8 chosen work figure 13 shows average number partitions adjacent given partition information gives sense number processors processor shares triangles must therefore exchange information figure 14 shows percentage total triangle edges endpoints two different processors data gives sense number triangles number refinement steps loop iterations sequence poisson test problems number number average number name processors refinement steps loop iterations poisson5 poisson6 poisson8 128 24 246 table number refinement steps loop iterations sequence linear elasticity test problem number number average number name processors refinement steps loop iterations processor must coordinated another processor note values initially rise rapidly one would expect approximately processors use larger numbers processors values increase slowly 52 experiments experiments run 256 nodes intel delta parallel computer meshconnected 16 theta 32 array intel i860 microprocessors 1 experiments reported times given seconds operations rates indicate number bisections vertex deletions note vertex deletions correspond unrefinement constitute small percentage total per second 1 note constraints amount time available us delta 512processor case run believe however results convincingly demonstrate effectiveness parallel refinement algorithm poisson number neighbors6number processors fig 13 average number partitions partition adjacent final mesh poisson 100 2003number processors percentage crossedges fig 14 percentage crossedges final mesh demonstrate scalability new algorithm implementation designed problems test set nearly equal numbers vertices final mesh assigned processors fact seen tables 1 2 show many processors problem run size final meshes test problems refined localized regions mesh therefore processors refinement work others load imbalance reflected tables 5 6 give average number operations per processor per step average maximum number operations single processor per step average number operations falls number processors increases decrease results refinement steps taken achieve number vertices per processor final mesh average maximum number operations increases mesh size increases refinement concentrated size area limited number processors working recall entire mesh repartitioned refinement step thus concentration new elements continuously redistributed processors fewer elements however even given handicaps results demonstrate algorithm performs quite well figure 15 shows average number refinement operations per second per processor function number processors number refinement operations poisson problem sequence average number average number operations per maximum number name processors processor operations per processor poisson5 poisson6 poisson8 128 111 573 poisson 100 200 number processors300700 number triangles per second fig 15 average number triangles refined per processor per second refinement occurring uniformly processors one could expect rate nearly constant however test problems practical problems case figure 16 shows interesting rate maximum number refinement operations per second individual processor one would expect rate remain constant nearly algorithm perfectly scalable poisson problem set one sees little degradation maximum refinement rate one might expect degradation resulting increasing number neighbors processor must exchange information number processors increases however possion problem set increase number neighbors offset rapidly increasing maximum number operations per processor given table 5 elastic problem set one observes expected degradation maximum number operations per processor increasing moderately prior reaching processors maximum rate refinement rapidly changing number refinement operations linear elasticity problem sequence average number average number operations per maximum number name processors processor operations per processor poisson 100 200 number processors300700 number triangles per second fig 16 maximum number triangles refined per second individual processor increasing communication requirements number processor neighbors percentage crossedges increases reaching 16 processors number processor neighbors percentage crossedges stabilizes one sees approximately 20 degradation rate refinement 16 256 processors results given figure 17 demonstrate reasonably complex set problems time solve linear systems dominates time refine mesh number processors fact total refinement time always less 4 percent total execution time note linear system solved level refinement example total execution time shown 128 processors figure 17 includes assembly solution 13 sparse linear systems time represented white region bar graph composed almost entirely sum times required repartitioning mesh level refinement partitioning time includes time number processors time sec execution total matrix solution time refinement time partitioning etc fig 17 comparison refinement times times required aspects problem solution linear elasticity problem sequence move vertices triangles data associated processors note implementation partitioning heuristic preliminary believe times significantly reduced examine total running time detail consider one problem elastic9 run 256 processors figures show time required solve linear system number nonzeros assemblied matrix function refinement level initially matrix size doubling every level refinement since triangles bisected refinement step however last several refinement levels small areas mesh refined result interpolated solution previous mesh excellent initial guess solution refined mesh small number conjugate gradient iterations required obtain solution satisfies specified tolerance relative residual problem elastic9 run 256 processors show figure 19 time required refine mesh function refinement level figure show number vertices added mesh level refinement note refinement time continues increase number vertices reaches maximum effect explained noting areas computational domain refinement occurring become confined fewer processors mesh refined recall figure 16 maximum rate refinement processor constant thus refinement occurring smaller number processors average rate refinement worse higher levels refinement behavior explains linear system solution time solution time matrix millions refinement level fig 18 time required solve linear systems number nonzeros assembled linear system level refinement problem elastic9 run 256 processors intel vertices addedsec total thousands created vertices refinement refinement level fig 19 refinement times number vertices added level refinement problem elastic9 run 256 processors intel decrease average rate refinement function number processors shown figure 15 6 concluding remarks described parallel algorithm adaptive refinement meshes algorithm shown run provably fast time pram model computation addition described efficient method implementation algorithm practical distributedmemory parallel computer gave results two problems demonstrate scalable nature algorithm results given paper twodimensional triangular mesh use independent sets parallel synchronization however generalizes threedimensional case well refinement algorithms next logical step work develop theoretical results threedimensional tetrahedralizations well practical parallel implementation three dimensions addition note use higherorder basis functions straightforward methodology fact include functionality current parallel implementation 9 r pltmg software package solving elliptic partial differential equa tions refinement algorithms data structures regular local mesh refinement condition finite element matrices generated nonuniform meshes users manual chameleon parallel programming tools comparison adaptive refinement techniques elliptic problems algorithm adaptive refinement triangular element meshes data structure adaptive finite element mesh refinements algorithms refining triangular grids suitable adaptive multigrid techniques lower bound angles triangles constructed bisecting longest side finite element program automatic usercontrolled mesh grading dynamic solutionadaptive unstructured parallel solver tr ctr j p surez p abad plaza padrn computational aspects refinement 3d complex meshes proceedings international conference computational methods sciences engineering p615618 september 1216 2003 kastoria greece jorn behrens adaptive atmospheric modeling scientific computing best computing science engineering v7 n4 p7683 july 2005 miguel padrn jos p surez ngel plaza adaptive techniques unstructured nested meshes applied numerical mathematics v51 n4 p565579 december 2004
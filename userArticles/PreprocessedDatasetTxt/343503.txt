interval routing schemes allow broadcasting linear messagecomplexity extended abstract purpose compact routing provide labeling nodes network way encode routing tables routing performed efficiently eg shortest paths keeping memoryspace required store routing tables small possible paper answer longstanding conjecture showing compact routing also help perform distributed computations particular show network supporting shortest path interval routing scheme allows broadcast messagecomplexity n number nodes network consequence prove messages suffice solve leaderelection graph labeled shortest path interval routing scheme improving therefore om previous known bound b introduction paper addresses problem originally formulated peleg informally summarized follows networks supporting shortest path compact routing schemes present specic ability term distributed com putation eg broadcasting leaderelection etc pa part work done third author visiting computer science department university parissud lri supported australianfrench arccnrs cooperation 99n920523 laboratoire de recherche en informatique bat 490 univ parissud 91405 orsay cedex france additional support cnrs httpwwwlrifrpierre z laboratoire bordelais de recherche en informatique univ bordeaux 33405 talence cedex france additional support aquitaine region project 98024002 httpdeptinfolabriubordeauxfrgavoille x department computing division ics macquarie univ sydney nsw 2109 australia httpwwwcompmqeduaubmans per answers armative showing nnode networks supporting interval routing schemes 26 27 irs allow broadcasting messagecomplexity formally network e paper network always mean connected undirected graph without loop multiple edge supports irs nodes network labeled 1 way following satised given node x 2 v degree set intervals one edge ed incident x 1 v n implies shortest path x passing edge e irs shortest path routing table property set destinationaddresses using given link consecutive set integers irs famous technique purpose compact routing since network maximum degree supporting irs routing table size log n bits compared n log bits routing table returning every destination output port corresponding destination irs refer 6 10 17 19 21 22 16 recent survey compact routing general refer 12 13 14 18 20 hand broadcasting information dissemination problem consists arbitrary node network send message nodes messagecomplexity broadcasting lies n since one hand reception message every node source requires least messages hand broadcasting always performed ooding network upon reception message every node forwards message incident edges apart one received message better upper lower bounds derived function knowledge nodes network eg see 1 2 4 maximal size messageheaders eg see 24 following knowledge every node label irs intervals attached incident edges irs size messageheader transmitted broadcasting protocol dlog 2 ne bits relationship irs broadcasting previously investigated instances van leeuwen tan 27 proved minimum spanning tree construction therefore broadcasting related distributed problems leaderelection solved exchanging messages ring labeled irs omn messages arbitrary graphs labeled irs recall leader election without network knowledge requires n log n messages ring mn log n messages arbitrary graph 15 generally question much labeling help solution distributed problems studied 8 9 framework sense direction shown 5 messagecomplexity broadcast problem n 1 restricted class networks supporting allshortestpath irs irs shortest paths represented additional restrictions intervals strictness linearity finally de la torre narayanan peleg 3 showed result holds irs networks satisfying socalled ssrtree prop erty informally property states node x set paths induced irs originated x ending nodes tree paper improve results showing network supporting standard shortest path irs supports broadcast protocol messagecomplexity n result many consequences problems leaderelection distributed spanning tree instance korach et al 23 shown leaderelection problem solved using bnnlog bn messagecomplexity broadcasting nnode networks therefore nnode networks supporting shortest path irs allow leaderelection problem solved log n messagecomplexity instead omn log n arbitrary networks fact prove messages suce solve leaderelection graphs labeled shortest path irs see 11 proof improving therefore omn previous bound van leeuwen tan 27 paper organized according several hypotheses irs hypotheses relaxed going paper indeed distinguish two types intervals interval b said linear whereas interval b b refers set bg said cyclic class networks supporting linear irs lirs short intervals irs lin ear strictly included class networks supporting irs possibly includes cyclic intervals also distinguish case v every node x case x appears interval one incident edges least one node x former case irs said strict hence get four types interval routing schemes irs lirs strict irs strict lirs following section presents preliminary sults section 3 dedicated networks supporting strict lirs sections 4 5 successively relax strictness requirement linearity requirement order present main result given theorem 1 2 preliminary results section present distributed broadcast protocol network supporting irs protocol simple though ecient since messagecomplexity shown called updown protocol second part section presents tools analysis protocol 21 updown broadcast protocol let source broadcast identied label irs source initiates broadcast sending two copies message one destinated node 1 destinated node 1 latter copy called copy whereas former called copy obviously source sends one copy two copies message circulating network let us concentrate copy destinated 1 message eventually reach shortest path set irs may possibly cross intermediate nodes nodes forward message destination stored message header without taking care content node receives message reads content modies header replacing node labeled 2 generally node labeled receives message destinated x reads content modies header replacing x x forwards toward node labeled x 1 node labeled n receives message reads content removes network strategy applied copy replacing x reaches node labeled 1 reads content removes network every given time copy message destinated one specic node called target node dierent target receives message take opportunity read content forwards message target along shortest path set irs leads target clearly messagecomplexity updown protocol equal denotes distance node labeled x node labeled g unfortunately knowledge authors good bounds networks supporting irs let us point known 5 networks supporting allshortestpath strict lirs networks strict lirs encodes shortest paths class networks supporting allshortestpath strict lirs restricted see 16 see weaker results proved single shortest path lirs irs assume source labeled 1 let sequence nodes visited message source w1 labeled 1 nal destination w labeled n node may appear several times w however node x appear target node thus possible occurrences node x correspond steps protocol x traversed message destinated target node 6 x let us complement sequence w two virtual nodes two nodes target nodes precisely w maximal sequence consecutive target nodes sequence non target nodes last node x rst node x i1 particular nodes called intermediate nodes notation every throughout paper always make use following last node x last node z rst node 22 intermediate nodes sequences next lemmas give properties satised intermediate nodes properties shown helpful compute messagecomplexity updown protocol lemma 1 let g network supporting strict lirs x 1 shortest path node labeled x node labeled x node labeled x 1 strict lirs u1 u2 vk 1 x 1 proof let interval edge x denition path unique shortest u u i1 hand denition path lirs strict therefore since intervals linear similarly one show lemma 1 states strict lirs networks target node x received message resp protocol node label smaller resp greater equal x visited anymore corollary 1 network supporting strict lirs ig next lemma analyzes relationship consecutive sequences intermediate nodes aim answer following given intermediate node w 2 w nd another intermediate node w j 2 w j whose label smaller label w lemma 1 answers question w last node intermediate sequence yr set nodes v node u 2 v denote du distance u says w last node sequence yr 1 ie dw r kr ie jyr j jxr j kr 1th node yr smaller w words w 1 look w j r kr complex depends mainly relative lengths ys xs r lemma 2 let g network supporting strict lirs let u node g let r assume exists r ks every intermediate node w proof first note implies note also implies ks 2 let us show induction every note let i1 interval edge xr 1 let interval edge every 1 xr 1 2 lemma 1 also u1 u u r thus since u 2 get u 2 every therefore shortest path xr u goes consequence r assume du r 1 let us show du i1 1 reasons case get shortest path last node x i1 x i1 u goes nodes i1 get thus du i1 1 proof equation 2 consequence equation 2 ks let i1 interval edge xs v1 xs interval edge v thus du xs 1 contradiction thus u v 1 therefore u v lemma 1 completes proof lemma 2 know enough start analysis updown protocol 3 strict linear interval routing schemes section show messagecomplexity updown protocol 3n network order n supporting strict lirs 31 partition sequencedecomposition algorith assume rst source node 1 make use sequence w displayed equation 1 since total number target nodes n n therefore aim rest proof bound total number intermediate nodes purpose partition intermediate nodes w three types pairwise disjoint subsequences result partition called sequencedecomposition precisely sequencedecomposition composed active path deadend paths jumped paths active path built starting walk w0 w1 along construction sequencedecomposition parts active path become deadend paths end decomposition two extremities active path w0 w1 total number nodes kept active path also end construction sum lengths deadend paths sum lengths jumped paths bounded therefore total number intermediate nodes jw careful analysis constants actually show jw j 3n sequencedecomposition performed visiting intermediate nodes sequence w w0 w1 constructing way active path one may jump intermediate nodes length jump bounded number jumped targets result jump jumped path one may also backtrack along active path bounded number nodes result backtrack deadend path decomposition requires two parameters mark direction role mark keep mind progression along sequence w general mark indicates current position precisely index current set mark important parameter backtracks backtrack occurs mark set remember current maximum position ever reached direction indicates whether backtrack recently occurred case initially active path reduced w0 neither deadend path jumped path mark set 0 direction set 1 construction sequencedecomposition precisely described algorithm 1 explanations several steps construction given case 1 construction currently visiting yr last node sequence intermediate nodes reached active path updated adding forthcoming nodes current sequence informally lemma 1 size active path increase much since labels nodes strictly decreasing order case 2 happens particular last node current sequence yr reached denition motivated lemma 2 exist construction stops exist make jump sequence w explained thereafter note like lemma 2 case 211 simply jump next intermediate node w whose label smaller label current node case 212 seen extremal case algorithm 1 one step construction sequence decomposition strict lirs current active path r p 2 yr let case 1 1 active path updated neither new deadend path jumped path mark direction modied case 2 smallest index exist active path updated new deadend path intermediate nodes last node ym w 1 form new jumped path construction stops exists let ks assume two cases considered case 21 two cases may occur case 211 intermediate node w pick rst node w type active path updated intermediate nodes last node ym w form jumped path assume w 2 mark set case 212 every intermediate node w active path updated p0 intermediate nodes last node ym v forms jumped path mark set cases new deadend path direction set 1 case 22 direction set 1 let 0 1g largest index p forms deadend path assume 1 intermediate nodes 1 jumped path mark updated 1 case 211 know lemma 2 jumping v ne since label node smaller label current node p mark updated contain index sequence intermediate nodes reached jump case 22 particular case backtrack occurs backtrack motivated fact one cannot nd intermediate node label smaller label p informally backtrack along active path reach node p 0 0 lemma 2 applied note 0 well dened since ng lemma 3 construction sequencedecomposition given algorithm 1 produces set paths every intermediate node appears exactly proof based following claim claim 1 proof claim initially holds assume claim holds step consider several cases algorithm 1 case 1 p t1 still ym still 1 case 21 direction set 1 denition setting mark cases 211 212 case 22 sets 1 claim holds step proof lemma follows proof every step let us dene resulting mark last node ym otherwise claim every step intermediate nodes appears exactly sequencedecomposition claim initially holds assume holds step case 1 claim 1 q active path upgraded adding next node sequence thus claim holds step case 21 set p t1 2 ym thus q every intermediate node last node ym q put jumped path claim holds step case 22 part active path becomes deadend path setting intermediate nodes yet assigned type paths intermediate nodes put jumped path thus every intermediate node q q put jumped path therefore step intermediate nodes q appears exactly sequencedecomposition complete proof lemma noticing every step either active path increased part active path put deadend path setting mark intermediatenode put deadend path jumped path considered anymore steps therefore construction sequence decomposition algorithm 1 ends nite number steps 32 messagecomplexity updown pro tocol sequencedecomposition algorithm let us compute messagecomplexity updown protocol lemma 4 number intermediate nodes active path n excluding w0 w1 pre cisely labels nodes active path including w0 w1 form decreasing sequence n proof prove lemma let us go several cases step decomposition let p last node current active path case 1 lemma 1 insures p t1 p case 2 exist next node active path smaller every nodes current active path remaining proof assume exist since case 22 add new node active path focus case 21 case 211 new node added active path denition smaller p case 212 v p application lemma 2 completes proof lemma lemma 5 number nodes deadend paths n proof deadend path composed sequence nodes formerly active path backtrack occurred every backtrack driven set target nodes similarly let lemma 4 number nodes deadend path corresponding active path traversed reverse direction produced sequence nodes increasing labels updated 1 backtrack thus considered anymore counting number nodes deadend paths x may considered another deadend path since 0 equal however k last nodes x involved consequence total number nodes deadend paths bounded 2 assume two jumps j 0 j successively occurred x j 0 occurred later backtrack led back x j occurred let 2 respective extremities j 0 j assume setting mark distance j proof denition setting backtracking j 0 hand arguments equation 2 dy 0 generally dy completes proof claim lemma 6 number nodes jumped paths n proof deadend paths jumped paths characterized disjoint sets target nodes form let us rst consider jumped paths created application case 21 algorithm 1 assume jump j occurred x 2 yr 2 r number nodes jumped path assume thus number nodes corresponding jumped path 1 j case number nodes jumped path setting corresponds another jump j 0 occurred x say x respectively value mark distance j 0 occurred claim 2 hand size jump 0 yields number node two jumps 0 1 repeat 0 considered jumps successively occurred x yields total number nodes set jumped paths occurring node x contains extremity last jump occurred x analysis jumped paths created case 22 proceeding jump occurred p 0 last node 1 recall p 0 conclude proof noticing due setting mark two jumps occur set target nodes therefore total number nodes combining lemmas 4 5 6 lemma 3 allows conclude total number intermediate nodes 3n actually improve upper bound 2n let x extremity active path cannot dened nodes active path belong application lemma 4 application lemma total number nodes active path j since sets used bound total number deadend paths conclude sum number nodes active path plus number nodes deadend paths n precede total number nodes sequencedecomposition therefore total number intermediate nodes 2n therefore total number nodes sequence w 3n hence messagecomplexity updown protocol 3n source node node labeled 1 let 1 label source lemma 1 message complexity copy going upward 3n whereas messagecomplexity copy going downward 3 summarize get property 1 messagecomplexity updown broadcast protocol 3n network order n supporting strict lirs note k2n 2 complete bipartite graph one partition size 2 another partition size n 2 supports strict lirs updown protocol uses messages 4 linearintervalroutingschemes next lemma variant lemma 1 adapted non strict lirs networks lemma 7 let g network supporting lirs let 1 shortest path node labeled x node labeled x1 resp node labeled x 1 lirs every k 1 every proof let interval edge 1 denition x1 2 u otherwise would exist shorter path x x generally 1 every j 1 therefore since intervals linear u every 1 result v obtained similar way corollary 2 network supporting lirs ig dierence lemma 1 lemma 7 motivates following adaptation lemma 2 lirs networks non necessarily strict lemma 8 let g network supporting lirs let u node g let r assume assume exists r r1 every 0 r 0 let 2s r let assume u x every every intermediate node proof note rst implies ks 1 implies 2 proceed way similar proof lemma 2 show every r shortest path zr u set irs goes nodes yr thus r 1 therefore equation 3 holds assume equation 3 holds let us show holds 1 shortest path z i1 u set irs goes nodes i1 thus hence dy equation 3 holds consequence equation 3 ks thus node v1g v u indeed otherwise path set irs zs u would go thus would shortest path let smallest index v u 1 v2 u lemma 7 result holds order analyze updown protocol networks supporting lirs partition sequence w slightly different manner previous section formal decomposition given algorithm 2 decomposition lirs actually looks similar decomposition strict lirs fourth type path introduced auxiliary path path motivated fact active path include one node every two according lemma 7 every node two nodes active path dropped auxiliary path let us mention dierences appearing every step sequence decomposition case 1 roughly case 1 algorithm 1 decomposition uses current intermediate sequence construct active path modication one node every two dropped auxiliary path one may stop u r 1 u r therefore case 2 considers also case true implies u r put auxiliary path case 2 also diers case 2 algorithm 1 denition new settings adapted statement lemma 8 otherwise general structure decomposition lirs algorithm 1 show following results firstly labels nodes active path form non increasing sequence number times p thus number intermediate nodes active path n result rened showing number nodes deadend paths active path direct consequence number nodes auxiliary path n since number nodes auxiliary path exceed number nodes active path deadend path contribution jumped paths bit larger since number nodes jumped paths n therefore lemma 9 number intermediate nodes active path n excluding w0 w1 precisely labels nodes active path form non increasing sequence number times p proof lemma 7 case 1 insures p case 2 exist p assume exists setting active path case 22 case 211 jump occurs denition case 212 jump occurs p t1 p lemma 8 number jumps lemma 10 number nodes deadend paths active path n proof similar arguments proof lemma 5 using notation number nodes deadend path corresponding sets plus number jumps occurring portion p 0 w yields total number nodes deadend paths observed strict lirs case x 2 last node active path dierent w1 total number nodes active path number jumps nal active path sets used enumerate nodes deadend paths total number jumps cannot exceed therefore total number nodes active path deadend paths n lemma 11 number nodes auxiliary path n proof direct consequence lemma 10 since number nodes auxiliary path exceed number nodes active path deadend path indeed one node dropped auxiliary path every node entering active path nodes formerly active path become member deadend path lemma 12 number nodes jumped paths n proof let us rst consider jump created application case 21 let j jump corresponding sets assume j occurred x 2 yr jump nodes therefore case number jumped intermediate nodes setting corresponds another jump j 0 occurred x say x value mark value distance respectively jump occurred setting backtracking j 0 therefore dx 0 arguments proof claim 2 size jump j 0 thus size two jumps one apply 0 arguments get number nodes set jumped paths occurring node x 2 yr 1 contains extremity last jump occurred x analysis jumped paths created case 22 proceeding jump occurred p 0 last node 1 recall p 0 worst case reached every jump single whose cost term nodes 1 total number nodes therefore get property 2 messagecomplexity updown broadcast protocol 9n network order n supporting lirs 5 interval routing schemes opposed linear irs labels nodes irs play role therefore slightly modify updown protocol adapt irs networks source labeled 1 n one copy message going upward n n 1 nally 1 1 rather two copies one going downward 1 going upward n protocol denoted up1up far up1up protocol concerned one assume wlg source labeled 1 order analyze up1up protocol make use sequence w dened equation 1 every ng 7 ng 1 using techniques lemmas 1 7 reader check lemma 13 let g network supporting irs let 1 shortest path node labeled x node labeled node labeled x 1 irs irs strict n otherwise every k 1 every using techniques lemmas 2 8 reader also check lemma 14 let g network supporting irs let u node g let r assume irs strict assume exists r 1 every 0 r 0 let ks let every x 2 x lx u lx x every every intermediate node w otherwise assume exists r every every intermediate node w minflxs v1 lxs v2g lxs u therefore sequencedecomposition algorithm 1 adaptation lirs networks described section 4 applied introducing relabeling lx every time comparison performed two labels resulting algorithms given algorithms 3 4 previous lemmas section show major dierence sequencedecomposition lirs networks sequencedecomposition irs net works fact up1up protocol irs strict irs networks satisfy properties updown protocol lirs strict lirs networks respectively key proof following result lemma 15 assume lx p i1 lxr p sequencedecomposition strict irs networks lx p i1 lxr p maximum number equality sequence decomposition irs networks proof according statement lemma considering case 21 sequence decomposition hence precisely possible setting mark several backtracks ending us rst consider strict irs decomposition us assume lxr since lemma 13 1 get p equal target node contradiction hypothesis case 21 therefore lxr arguments allow show lx p i1 lxr p sequencedecomposition irs networks therefore fi denotes index active path p0 resulting sequencedecomposition strict irs networks satises pair j 1 j irs networks might equalities sequence consequence theorem 1 messagecomplexity up1up broadcast protocol respectively 3n network order n supporting strict irs 9n network order n supporting irs consequence networks supporting shortest path interval routing scheme allows broadcasting messagecomplexity corollary 3 network supporting strict irs average distance two nodes labeled two consecutive integers 3o1n network supporting irs average distance two nodes labeled two consecutive integers 9 o1n 6 r optimal broadcast partial knowledge tradeo impact knowledge broadcasting time radio networks broadcast linear messages irs representing shortest paths complexity interval routing random graphs sense direction de impact sense direction message complexity sense direction distributed computing interval routing schemes interval routing schemes allow broadcasting linear messagecomplexity searching among intervals compact routing tables designing networks compact routing tables distributed algorithm minimal spanning tree survey interval routing compact routing tables graphs bounded genus compactness interval routing lower bounds compact routing multilabel linear interval routing schemes modular technique design ecient distributed leader nding algorithms tradeo space eciency routing tables labelling implicit routing networks interval routing tr interval routing tradeoff space efficiency routing tables tradeoff space efficiency routing tables modular technique design efficient distributed leader finding algorithms tradeoff information communication broadcast protocols memory requirement routing distributed networks impact sense direction message complexity worst case bounds shortest path interval routing optimal broadcast partial knowledge compactness interval routing survey interval routing distributed algorithm minimumweight spanning trees complexity interval routing random graphs sense direction distributed computing compact routing tables graphs bounded genus lower bounds compact routing extended abstract multilabel linear interval routing schemes extended abstract impact knowledge broadcasting time radio networks searching among intervals compact routing tables ctr cyril gavoille routing distributed networks overview open problems acm sigact news v32 n1 march 2001
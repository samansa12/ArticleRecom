making views selfmaintainable data warehousing data warehouse stores materialized views data one sources order provide fast access integrated data regardless availability data sources warehouse views need maintained response changes base data sources except simple views maintaining warehouse view requires access data available view hence maintain view one either query data sources store auxiliary data warehouse show using key referential integrity constraints often maintain selectprojectjoin view without going data sources replicating base relations entirety warehouse derive set auxiliary views together selfmaintainablethey maintained without going data sources replicating base data addition technique applied simplify traditional materialized view maintenance exploiting key referential integrity constraints b introduction problem materialized view maintenance received increasing attention recently 6 7 11 particularly due application data warehousing 3 14 view derived relation defined terms base relations view said materialized stored database rather computed base relations response queries materialized view maintenance problem problem keeping contents stored view consistent contents base relations base relations modified data warehouses store materialized views order provide fast access information integrated several distributed data sources 3 data sources may heterogeneous andor remote warehouse consequently problem maintaining materialized view data warehouse differs traditional view maintenance problem view base data stored database particular changes reported one data work supported rome laboratories air force contract f3060294c023 equipment grants digital ibm corporations source may necessary access base data data sources order maintain view 9 view involving join maintaining view base relations change may require accessing base data even incremental view maintenance techniques used 5 8 example view r 1 insertion relation r reported usually necessary query order discover tuples join insertion r warehousing scenario accessing base data means either querying data sources replicating base relations warehouse problems associated querying data sources sources may periodically unavailable may expensive timeconsuming query inconsistencies result warehouse unless care taken avoid use special maintenance algorithms 14 problems associated replicating base relations warehouse additional storage maintenance costs incurred paper show many views including views joins key referential integrity constraints present necessary replicate base relations entirety warehouse order maintain view give algorithm determining extra information called auxiliary views stored warehouse order maintain selectprojectjoin view without accessing base data sources algorithm takes key referential integrity constraints ac count often available practice reduce sizes auxiliary views view together set auxiliary views maintained warehouse without accessing base data say views selfmaintainable maintaining materialized views way especially important data martsminiature data warehouses contain subset data relevant particular domain analysis geographic region data collected centralized data warehouse becomes increasingly important distribute data localized data marts order reduce query bottlenecks central warehouse many data marts exist cost replicating entire base relations changes data mart becomes especially prohibitive 11 motivating example start example showing amount extra information needed maintain view significantly reduced replicating base relations entirety present results without explanation obtained revisit example throughout paper consider database sales data chain department stores database following relations storestore id city state manager salesale id store id day month lineline id sale id item id sales price itemitem id item name category supplier name first underlined attribute relation key relation store relation contains location manager store sale relation one record sale transaction store date sale sale may involve several items one per line sales receipt stored line relation one tuple every item sold transaction item relation contains information item stocked assume following referential integrity constraints hold 1 salestore id storestore id 2 linesale id salesale id 3 lineitem id itemitem id referential integrity constraint sb ra implies every tuple 2 must tuple r 2 r suppose manager responsible toy sales state california interested maintaining view years sales toy items sold california 1996 along sales price month sale made name manager store sale made include item id sale id line id select storemanager salesale id salemonth itemitem id itemitem name lineline id linesales price store sale line item storestore linesale id lineitem question addressed paper given view one auxiliary views materialized warehouse view auxiliary views together selfmaintainable figure shows sql expressions set three auxiliary views sufficient maintain view cal toy sales insertions deletions base relations self maintainable paper give algorithm deriving auxiliary views general case along incremental maintenance expressions maintaining original view auxiliary views materializing auxiliary views figure 1 repre store select store id manager store select sale id store id month store id select store id aux store item select item id item name item figure 1 auxiliary views maintaining cal toy sales view sents significant savings materializing base relations entirety illustrated table 1 suppose four base relations contain number tuples listed first column table 1 assuming selectivity storestateca 02 selectivity saleyear1996 25 selectivity itemcategorytoy 05 distributions uniform number tuples passing local selection conditions selection conditions involving attributes single relation given second column table 1 related proposal hull zhou 10 achieves selfmaintainability base relation insertions pushing projections local selection conditions base relations storing warehouse tuples attributes base relations pass selections projec tions thus approach would require number tuples appearing second column table 1 stored warehouse handle insertions improve upon approach 10 also taking key referential integrity constraints ac count example dont need materialize tuples line key referential integrity constraints guarantee existing tuples line cannot join insertions rela tions likewise exclude tuples sale join existing tuples store whose state california guaranteed existing tuples sale never join insertions store using approach dramatically reduce number tuples auxiliary views pushing selections number tuples required approach handle base relation insertions example appears third column table 1 tuples tuples passing tuples auxiliary base relation base relation local selection conditions views figure 1 store sale 80000000 20000000 400000 line 800000000 800000000 0 item 1000 50 50 total 880003000 820000090 400090 table 1 number tuples base relations auxiliary views similarly use key constraints handle deletions base relations without base relations available determine effects deletions sale line item without referencing base relations cal toy sales includes relations simply join deleted tuples cal toy sales appropriate key even though view include key store store joined sale key sale effect deletions store determined joining deleted tuples sale joining result cal toy sales key sale consider updates updates treated deletions followed insertions common view maintenance properties key referential integrity constraints use reduce size auxiliary views would longer guaranteed hold thus updates treated separately approach note data warehousing environments common certain base relations updated eg relations sale line may append even base relations updateable may attributes updated eg dont expect update state store updates base relations example cannot change values attributes involved selection conditions view auxiliary views figure sufficient even attributes appearing view may updated hand updates sale may change year example additional auxiliary view line line id sale id item id sales price line item id select item id aux item would need materialized would 40000000 tuples would need store purchases items whose category toy case year corresponding sales record changed later 1996 updates may change category item toy would need keep line relation order maintain view practice found attributes appearing selection conditions views tend attributes updated example illustrated formalized later updates occur much less auxiliary information required selfmaintenance thus exploiting knowledge permitted updates important feature approach 12 selfmaintenance self maintenance formally defined follows consider view v defined set base relations r changes ffi r made relations r response view v needs maintained want compute ffi v changes v using little extra information possible ffi v computed using materialized view v set changes ffi r view v alone selfmaintainable view v selfmaintainable interested finding set auxiliary views defined relations v set views fv ga selfmaintainable note set base relations r forms one set auxiliary views however want find economical auxiliary views much smaller base relations notion minimal set auxiliary views sufficient maintain view v formalized section 3 general problem make set vn views selfmaintainable ie find auxiliary views av selfmaintainable simply applying algorithm view v since opportunities share information across original auxiliary views recognized final set av may minimal intend investigate sets views future work 13 paper outline paper proceeds follows section 2 presents notation terminology assumptions section 3 presents algorithm choosing set auxiliary views materialize sufficient maintaining view selfmaintainable section 4 shows view maintained using auxiliary views section 5 explains set auxiliary views selfmaintainable related work appears section 6 preliminaries consider selectprojectjoin spj views views consisting single projection followed single selection followed single crossproduct set base relations usual combination selections projections joins represented form assume base relations view might contain duplicates due projection view paper assume singleattribute conjunctions selection conditions disjunctions simplicity results carry multiattribute keys selection conditions disjunctions section 3 impose certain additional restrictions view explain restrictions lifted full version paper 12 say selection conditions involving attributes single relation local conditions otherwise join conditions say attributes appearing final projection preserved view order keep materialized view date changes base relations must propagated view view maintenance expression calculates effects view certain type change sertions deletions updates base relation use differential algorithm given 5 derive view maintenance expressions example view maintenance expression calculating effect insertions r 4r represents tuples insert v result 4r since data warehousing environments updates certain base relations may occur may change values certain attributes define base relation r one three types updates depending updateable attributes used view definition ffl updates r may change values attributes involved selection conditions local join view say r exposed updates ffl otherwise updates r change values attributes involved selection conditions may change values preserved attributes attributes included final projection say r protected updates ffl otherwise updates r change values attributes involved selection conditions values preserved attributes say r ignorable updates ignorable updates cannot affect view need propagated consider exposed protected updates exposed updates could cause new tuples inserted view tuples deleted view propagate deletions tuples old values followed insertions tuples new values example given view value ra tuple r changed 9 10 new tuples could inserted v result protected updates change attribute values existing tuples view cannot result tuples inserted deleted view therefore propagate protected updates separately alternate treatment updates considered section 412 addition usual select project join symbols use represent semijoin represent union bag semantics gamma delta represent minus bag semantics assume project bag semantics notation 1x represents equijoin attribute x 1 keyr represents equijoin key attribute r assuming attribute joined relations insertions relation r represented 4r deletions represented 5r protected updates represented r tuples r two attributes corresponding attributes r one containing value update another containing value update use old project old attribute values new project new attribute values 3 algorithm determining auxiliary views present algorithm algorithm 31 given view definition v derives set auxiliary views view v views taken together selfmaintainable ie maintained upon changes base relations without requiring access data auxiliary view expression form auxiliary view selection projection relation r followed zero semijoins auxiliary views seen number tuples ar never larger number tuples r illustrated section 11 may much smaller auxiliary views form easily expressed sql maintained efficiently shown 12 intuitively first part auxiliary view ex pression oer results pushing projections local selection conditions onto r tuples r pass local selection conditions cannot possibly contribute tuples view hence needed view maintenance therefore need stored ar warehouse semijoins second part auxiliary view expression reduce number tuples ar restricting contain tuples joinable certain auxiliary views addition show cases need ar eliminated altogether first need present definitions used algorithm given view v let join graph gv view directed graph hr ei r set relations referenced v form vertices graph directed edge contains join condition r key r j edge annotated ri referential integrity constraint r b r j assume graph forest set trees vertex one edge leading cycles assumption still allows us handle broad class views occur practice example views involving chain joins sequence relations r join conditions foreign key r key r n star joins one relation r 1 usually large joined set relations usually small join conditions foreign keys r 1 keys addition assume selfjoins explain assumptions removed 12 following definition used determine set relations upon relation r dependsthat set relations r j 1 foreign key r joined key r j 2 referential integrity constraint r r j 3 r j protected updates ri r j exposed updates g determines set auxiliary views r semijoined definition auxiliary view ar r given reason semijoins follows let r j member g due referential integrity constraint r r j fact join r r j key r j tuple 2 r must join one one tuple pass local selection conditions r j cannot contribute tuples view updates r j protected definition depr never contribute tuples view necessary include ar warehouse sufficient store tuples r pass local selection conditions r join tuple r j passes local selection conditions r j ie semijoin condition join condition r r j view r semijoined ar j rather oer j definition ar follows similar argument applied inductively following definition used determine set relations upon relation r transitively depends r transitive closure depr r used help determine whether necessary store ar warehouse order maintain view whether ar eliminated altogether intuitively dep r includes relations referenced view v except r ar needed propagating insertions base relation onto v reason key referential integrity constraints guarantee new insertions base relations join new insertions r existing tuples r behavior explained section 4 line ri ri ri store item figure 2 join graph gcal toy sales following definition used determine set relations relation r needs join key one joining relations preserved view joins must keys foreign keys relation exists needr includes relations view oe key r preserved key r preserved v r j otherwise note restrict graph forest one r j er j r used help determine whether necessary store auxiliary views particular auxiliary view ar j necessary r j appears need set r intuitively key r preserved view v deletions protected updates r propagated v joining directly v key r otherwise key r preserved v r joined another relation r j key r v preserves key r j deletions protected updates r propagated onto v joining first r j joining result v case r j need set r hence ar j necessary generally key r present v r joins r j key r auxiliary views r j relations needr necessary propagating deletions protected updates r finally none conditions hold auxiliary views relations referenced r necessary illustrate definitions consider cal toy sales view section 11 figure 2 shows graph gcal toy sales need functions base relations given table 2 assume base relation protected updates algorithm 31 appears figure 3 explain algorithm works running cal toy sales example auxiliary views generated algorithm exactly given figure 1 section 11 shown relational algebra form table 3 algorithm 31 input view v output set auxiliary view definitions method let r set relations referenced v construct graph gv every relation r construct r every relation r r r r ar needed else p set attributes r preserved v appear join conditions key r strictest set local selection conditions possible r c l join condition r key r k l figure 3 algorithm derive auxiliary views table 2 dep need functions base relation relation r referenced view v algorithm checks whether dep r includes every relation referenced v r relation r j referenced v necessary store part r order maintain v relation line example auxiliary view relation needed otherwise two steps taken reduce amount data stored auxiliary view ar r first possible push r local selection conditions explicit inferred view store id manager oe stateca store oe year1996 sale store id store table 3 auxiliary views maintaining cal toy sales view tuples dont pass selection conditions dont need stored also possible project away attributes r except involved join conditions preserved v key r second depr g empty possible reduce tuples stored ar tuples r join tuples auxiliary views ark r k depr g auxiliary view sale example steps applied sale restricted semijoin store include tuples join tuples passing local selection conditions store auxiliary views store item examples selection projection applied although view definitions small running time crucial observe running time algorithm 31 polynomial number lations therefore clearly acceptable state theorem correctness minimality auxiliary views derived algorithm 31 theorem 31 let v view treestructured join graph set auxiliary views produced algorithm 31 unique minimal set views added v fv ga self maintainable 2 proof theorem 31 given 12 minimal mean auxiliary view removed possible add additional selection condition semijoin reduce number tuples auxiliary view still fv ga selfmaintainable show section 4 v maintained using explain section 5 maintain without referencing base relations 31 effect exposed updates recall far example considered protected updates suppose sale exposed updates ie updates could change values year sale id store id note definition dep include relation exposed updates thus dep function line include sale get case auxiliary view line would created line item id item selection projection applied line line local selections line view attributes line either preserved view appear join conditions section 41 explains exposed updates different effect set auxiliary views needed protected updates 4 maintaining view using auxiliary views recall view maintenance expression calculates effects view certain type change insertions deletions updates base relation view maintenance expressions usually written terms changes base relations 5 2 section show set auxiliary views chosen algorithm 31 sufficient maintain view showing transform view maintenance expressions written terms changes base relations equivalent view maintenance expressions written terms changes view auxiliary views give view maintenance expressions type change insertions deletions updates sepa rately addition type change apply changes base relation separately propagating changes base relation onto view updating base relation reason give maintenance expressions form rather maintenance expressions propagating several types changes maintenance expressions form easier understand sufficient purpose showing possible maintain view using auxiliary views generated algorithm 31 view maintenance expressions insertions handled section 41 deletions handled section 42 protected updates handled section 43 since exposed updates handled deletions followed insertions treated within sections 41 42 41 insertions section show effect view insertions base relations calculated using auxiliary views chosen algorithm 31 view maintenance expression calculating effects spj view v insertions base relation r obtained substituting 4r insertions r base relation r relational algebra expression v example view maintenance expressions calculating effects cal toy sales view sec tion 11 insertions store sale line item appear table 4 store idmanager oe stateca 4st store id sale idstore idmonth oe year1996 sa 1 item id item iditem name oe categorytoy store idmanager oe stateca st store id sale idstore idmonth oe year1996 4sa 1 item id item iditem name oe categorytoy store idmanager oe stateca st store id sale idstore idmonth oe year1996 sa 1 item id item iditem name oe categorytoy store idmanager oe stateca st store id sale idstore idmonth oe year1996 sa 1 item id item iditem name oe categorytoy 4i table 4 maintenance expressions insertions words explanation table order ffl convenience table hereafter abbreviate store sale line item st sa l respectively ffl abbreviate view cal toy sales v ffl applied general rule pushing selections projections maintenance expressions ffl use notation 4vr represent insertions view v due insertions base relation r example 4v st represents insertions v due insertions st ffl maintenance expressions table 4 calculates effect view v insertions one base relations show section 413 even insertions multiple base relations propagated auxiliary views generated algorithm 31 still sufficient expressions table 4 would appear beyond pushing selections projections nothing done reduce base relation data required evaluating maintenance expressions referential integrity constraints indeed case however referential integrity constraints allow certain maintenance expressions eliminated requiring less base relation data auxiliary views maintenance expressions eliminated due following property corresponding rule property 41 insertion property foreign keys referential integrity constraint r j b r r j b foreign key key r r exposed updates general conditions hold following true property 41 holds referential integrity constraint requires tuple r j join existing tuple r joins key r cannot join tuples 4r join 4r r j must empty rule 41 insertion rule foreign keys let gv join graph view v maintenance expression calculating effect view v insertions base relation r guaranteed empty thus eliminated relation r j r rule 41 used eliminate maintenance expression calculates effect view v insertions base relation r another relation r j v r join graph v rule holds definition dep r depr view equates foreign key r j key r referential integrity constraint foreign key r j key r r protected updates effect exposed updates discussed section 412 since maintenance expression calculates effect insertions r includes join 4r r j must empty property 41 therefore eliminated joins referential integrity constraints keys foreign keys common practice conditions rule 41 often met able eliminate certain maintenance expressions calculating effect view v insertions base relations significantly reduce cost maintaining v although view maintenance expressions main theme paper nevertheless important standalone result 411 rewriting maintenance expressions use auxiliary relations eliminating certain maintenance expressions using rule 41 allows us use auxiliary views instead base relations propagating insertions applying rule 41 remaining maintenance expressions rewritten using auxiliary views generated algorithm 31 replacing oer subexpression corresponding auxiliary view ar r example assuming base relations protected updates maintenance expressions 4v st 4v sa 4v table 4 eliminated rule 41 due referential constraints salestore id storestore id linesale id salesale id lineitem id itemitem id respectively 4vl expression calculating effect insertions l guaranteed empty maintenance expression 4vl rewritten using auxiliary views follows recall auxiliary views shown table 3 notice base relation l never referenced maintenance expression auxiliary view l needed addition sa joined st maintenance expression acceptable store tuples sa join existing tuples sttuples sa dont join existing tuples st wont contribute result proof auxiliary views sufficient general evaluate reduced maintenance expressions insertions appears 12 412 effect exposed updates suppose view contains join condition r j key r referential integrity constraint r j b r r exposed rather protected updates depr thus contain r recall exposed updates change values attributes involved selection conditions local join handle exposed updates deletions tuples old attribute values followed insertions tuples new attribute values since exposed updates may result deletions insertions view thus r exposed updates may include tuples representing new values exposed updates tuples join existing tuples r j without violating referential integrity key constraints property 41 hold rule 41 cannot used eliminate maintenance expression propagating insertions r example suppose updates may occur year attribute sa auxiliary view l would created shown section 31 cannot semijoin l sa auxiliary view l new values updated tuples sa could join existing tuples l old values updated tuples didnt pass local selection conditions sa hence werent sa suppose year sale tuple changed 1995 1996 although old value doesnt pass selection criteria year1996 therefore wouldnt appear sa new value would since could join existing tuples l cannot restrict al include tuples join existing tuples sa paper assume known advance whether relation view v exposed protected updates relation exposed updates may need store information auxiliary views order maintain v relation protected updates example create auxiliary view l sa exposed updates auxiliary view l wasnt needed sa protected updates alternate way consider updates doesnt require advance knowledge protected versus exposed assume every base relation protected updates propagating updates updates base relation divided two classes updates modify attributes involved selection conditions first class updates propagated protected updates using expressions section 43 assuming second class updates relatively small updates second class could propagated issuing queries back data sources 413 propagating insertions multiple relations maintenance expressions form used table 4 propagate onto view insertions one base relation time propagate insertions multiple base relations using formulas table 4 4vr calculated assume insertions base relations r j j already applied base relations 5 8 maintenance expressions given propagating changes base relations consider one relation time case maintenance expressions easier explain amount data needed auxiliary views whether insertions deletions updates propagated one relation time see 12 42 deletions section show effect view deletions base relations calculated using auxiliary views view maintenance expression calculating effects spj view v deletions base relation r obtained similarly expression calculating effects insertions substitute 5r deletions r base relation r relational algebra expression v exam ple view maintenance expressions calculating effects cal toy sales view deletions store sale line item appear respectively 5v st 5v sa 5vl 5v table 5 use notation 5vr represent deletions view v due deletions base relation r often simplify maintenance expressions deletions use contents view keys store idmanager oe stateca 5st store id sale idstore idmonth oe year1996 sa 1 item id item iditem name oe categorytoy store idmanager oe stateca st store id sale idstore idmonth oe year1996 5sa 1 item id item iditem name oe categorytoy store idmanager oe stateca st store id sale idstore idmonth oe year1996 sa 1 item id item iditem name oe categorytoy store idmanager oe stateca st store id sale idstore idmonth oe year1996 sa 1 item id item iditem name oe categorytoy 5i table 5 maintenance expressions deletions preserved view using following properties rule deletions presence keys property 42 deletion property keys given view key relation r preserved v following equivalence holds consider join graph gv view v property 42 says v preserves key relation calculate effect v deletions r joining v 5r key r property holds tuple v value key r tuple 5r must derived conversely tuples v derived tuple 5r must value key r therefore set tuples v join key r exactly set tuples v deleted deleted r similar property holds key r preserved v equated selection condition v attribute c preserved v case effect deletions r obtained joining v 5r using join condition property 42 used 4 determine view selfmaintainable respect deletions base relation extend result property 43 property 43 deletion property key joins given view satisfying following conditions 1 v contains join conditions r 2 attribute key r ij 0 j k 3 r ik preserved v following equivalence holds even without referential let gv join graph view v property 43 generalizes property 42 say v preserves key relation r ik r joins r ik along keys needr include base relations v calculate effect v deletions r joining 5r sequence relations r ik joining r ik property holds tuples v value key r ik tuple r ik must derived explained property 42 furthermore since joins r ik r along keys tuple r ik join one tuple 0 r means tuples v derived tuple r ik must also derived tuple 0 r conversely tuple v derived 0 r must value key r ik tuple r ik 0 joins therefore set tuples v join key r ik tuple r ik joins along keys tuple 0 r exactly set tuples v deleted 0 deleted r similar property also holds key r ik preserved v equated selection condition v attribute c preserved v case effect deletions r obtained joining v r ik using join condition rule 42 deletion rule let v view tree structured join graph gv let maintenance expression calculating effect view v deletions base relation r may simplified according property 43 reference v unless includes base relations v except r fi rule 42 used simplify maintenance expressions deletions use contents view fewer base relations allows us rewrite maintenance expressions deletions use auxiliary views instead base relations 421 rewriting maintenance expressions use auxiliary relations simplifying maintenance expressions according rule 42 simplified expressions rewritten use auxiliary views generated algorithm 31 replacing oer subexpression simplified maintenance expression corresponding auxiliary view ar r maintenance expressions table 5 simplified using rule 42 follows proof auxiliary views sufficient general evaluate simplified maintenance expressions deletions appears 12 43 protected updates section show effect view protected updates base relations calculated using auxiliary views recall exposed updates treated separately deletions followed insertions give two maintenance expressions calculating effect view v protected updates base relation r one returning tuples delete view denoted 5 vr another returning tuples insert view denoted 4 vr practice pairs maintenance expressions usually combined single sql update statement view maintenance expression calculating tuples delete spj view v due protected updates base relation r obtained substituting old r old attribute values updated tuples r base relation r relational algebra expression v recall r old new defined section 2 view maintenance expression calculating tuples insert obtained similarly substituting new r new attribute values updated tuples r base relation r relational algebra expression v example view maintenance expressions calculating tuples delete cal toy sales view due protected updates base relations given table 6 expressions calculating tuples insert view cal toy sales shown obtained substituting new old expressions table 6 note table 6 expressions similar deletion expressions table 5 simplify maintenance expressions protected updates similarly way simplify maintenance expressions deletions using contents view keys preserved view give following properties rule updates presence preserved keys following let p r old store idmanager oe stateca st store id sale idstore idmonth oe year1996 sa 1 item id item iditem name oe categorytoy store idmanager oe stateca st store id old sale idstore idmonth oe year1996 sa 1 item id item iditem name oe categorytoy store idmanager oe stateca st store id sale idstore idmonth oe year1996 sa line idsale iditem idsales price l 1 item id item iditem name oe categorytoy store idmanager oe stateca st store id sale idstore idmonth oe year1996 sa item iditem name oe categorytoy table maintenance expressions removing old updates use old new project old new attribute values respectively preserved attributes r regular attribute values preserved attributes relations v use 1oldkeyr denote joining attribute key value update held property 44 protected update property keys given view key relation r preserved v following equivalences hold new property 45 protected update property key joins given view satisfying following conditions 1 view v contains join conditions r r ik b 2 attribute key r ij 0 j k 3 r ik preserved v following equivalences hold even without referential 1 old oer 1oer 1 new oer 1oer new properties 44 45 similar corresponding properties deletions attributes r involved selection conditions guaranteed updated matter whether test old new value selection conditions property 44 used 4 determine view selfmaintainable base relation updates consider join graph gv view v property 45 generalizes property 44 property 45 says v preserves key relation r ik joins r ik along keys needr include base relations v calculate effect v protected updates r joining r sequence relations r ik joining r ik v deletions similar property also holds key r ik preserved v equated selection condition v attribute c preserved v case effect updates r obtained joining v r ik using join condition rule 43 protected update rule let v view tree structured join graph gv let maintenance expressions calculating effect view v protected updates base relation r simplified according property 45 reference v includes base relations similar rule deletions rule 43 used simplify maintenance expressions 5 vr 4 vr use contents view fewer base relations maintenance expressions rewritten terms auxiliary views 431 rewriting maintenance expressions use auxiliary relations simplifying maintenance expressions according rule 43 simplified expressions rewritten use auxiliary views generated algorithm 31 replacing oer subexpression maintenance expression corresponding auxiliary view ar r rewriting similar rewriting insertions deletions example proof auxiliary views sufficient general evaluate maintenance expressions given 12 5 maintaining auxiliary views due space constraints give intuitive argument based upon join graphs set auxiliary views selfmaintainable details maintaining auxiliary views efficiently proof set auxiliary views selfmaintainable appear full version paper 12 recall auxiliary views derived algorithm 31 form c equijoins foreign key r corresponding relation r joins along foreign key referential integrity constraints semijoin could replaced join thus auxiliary view spj view join graph constructed discussed section 3 note join graph auxiliary view subgraph graph original view join auxiliary view also join original view thus information needed maintain original view also sufficient maintain auxiliary views 6 related work problem view selfmaintainability considered initially 1 4 modification type insertions deletions updates identify spj views maintained using view modification 1 states necessary sufficient conditions view definition view selfmaintainable updates specified using particular sql modification statement eg delete tuples ra 3 4 uses information key attributes determine selfmaintainability view respect modifications certain type paper consider problem making view selfmaintainable materializing set auxiliary views original view auxiliary views taken together selfmaintainable although set base relations view defined forms one set auxiliary views approach derive auxiliary views much smaller storing base relations en tirety identifying set small auxiliary views make another view selfmaintainable important problem data warehousing base relations may readily available 10 views made selfmaintainable pushing selections projections base relations storing results warehouse thus using terminology consider auxiliary views based select project operators improve upon approach considering auxiliary views based select project semijoin operators along using knowledge key referential constraints shown section 11 approach significantly reduce sizes auxiliary views show 12 auxiliary views form algorithm produces selfmaintained efficiently 13 inclusion dependencies similar referential integrity constraints used determine possible answer view joining several lations query subset relations eg given v view joining r relations r hand use similar referential integrity constraints simplify view maintenance expressions r updating derived relations detecting irrelevant autonomously computable updates algorithms deferred view maintenance ieee data engineering bulletin data integration using selfmaintainable views incremental maintenance views duplicates maintenance materialized views problems materialized views maintaining views incrementally stanford data warehousing project framework supporting data integration using materialized virtual approaches rejuvenation materialized views gmap versatile tool physical data independence view maintenance warehousing envi ronment tr ctr lyman pamela drew wei jin vish jumani david van rossum issues developing large data warehouses proceedings 24rd international conference large data bases p633636 august 2427 1998 mala rajamani karen c davis partitioned auxiliary views selfmaintainable data warehouse proceedings 1st acm international workshop data warehousing olap p6671 november 0207 1998 washington dc united states wensyan li daniel c zilio vishal batra calisto zuzarte inderpal narang load balancing data placement multitiered database systems data knowledge engineering v62 n3 p523546 september 2007 samtani v kumar mohania self maintenance multiple views data warehousing proceedings eighth international conference information knowledge management p292299 november 0206 1999 kansas city missouri united states kenneth salem kevin beyer bruce lindsay roberta cochrane roll join asynchronous incremental view maintenance acm sigmod record v29 n2 p129140 june 2000 hoshi mistry prasan roy sudarshan krithi ramamritham materialized view selection maintenance using multiquery optimization acm sigmod record v30 n2 p307318 june 2001 goretti k chan qing li ling feng design selection materialized views data warehousing environment case study proceedings 2nd acm international workshop data warehousing olap p4247 november 0206 1999 kansas city missouri united states jens lechtenbrger hua shu gottfried vossen aggregate queries conditional tables journal intelligent information systems v19 n3 p343362 november 2002 toby bloom data warehousing data cleaning loading handbook data mining knowledge discovery oxford university press inc new york ny 2002 avigdor gal obsolescent materialized views query processing enterprise information systems proceedings eighth international conference information knowledge management p367374 november 0206 1999 kansas city missouri united states agrawal el abbadi singh yurek efficient view maintenance data warehouses acm sigmod record v26 n2 p417427 june 1997 nam huyn multipleview selfmaintenance data warehousing environments proceedings 23rd international conference large data bases p2635 august 2529 1997 wang maria orlowska weifa liang efficient refreshment materialized views multiple sources proceedings eighth international conference information knowledge management p375382 november 0206 1999 kansas city missouri united states stphane lopes jeanmarc petit farouk toumani discovering interesting inclusion dependencies application logical database tuning information systems v27 n1 p119 march 2002 themistoklis palpanas richard sidle roberta cochrane hamid pirahesh incremental maintenance nondistributive aggregate functions proceedings 28th international conference large data bases p802813 august 2023 2002 hong kong china hector garciamolina wilburt labio jun yang expiring data warehouse proceedings 24rd international conference large data bases p500511 august 2427 1998 h engstr chakravarthy b lings maintenance policy selection heterogeneous data warehouse environments heuristicsbased approach proceedings 6th acm international workshop data warehousing olap november 0707 2003 new orleans louisiana usa jens lechtenbrger gottfried vossen computation relational view complements acm transactions database systems tods v28 n2 p175208 june laks v lakshmanan jian pei yan zhao qctrees efficient summary structure semantic olap proceedings acm sigmod international conference management data june 0912 2003 san diego california dimitri theodoratos timos k sellis data warehouse configuration proceedings 23rd international conference large data bases p126135 august 2529 1997 hongsong li houkuan huang youfang lin dsd maintain data cubes efficiently fundamenta informaticae v59 n23 p173190 february 2004 hongsong li houkuan huang youfang lin dsd maintain data cubes efficiently fundamenta informaticae v59 n23 p173190 april 2004 xin zhang lingli ding elke rundensteiner parallel multisource view maintenance vldb journal international journal large data bases v13 n1 p2248 january 2004 dimitri theodoratos timos sellis incremental design data warehouse journal intelligent information systems v15 n1 p727 julyaug 2000 yingwei cui jennifer widom janet l wiener tracing lineage view data warehousing environment acm transactions database systems tods v25 n2 p179227 june 2000 inderpal singh mumick dallan quass barinderpal singh mumick maintenance data cubes summary tables warehouse acm sigmod record v26 n2 p100111 june 1997 songting chen bin liu elke rundensteiner multiversionbased view maintenance distributed data sources acm transactions database systems tods v29 n4 p675709 december 2004 arvind arasu brian babcock shivnath babu jon mcalister jennifer widom characterizing memory requirements queries continuous data streams proceedings twentyfirst acm sigmodsigactsigart symposium principles database systems june 0305 2002 madison wisconsin amit manjhi anastassia ailamaki bruce maggs todd c mowry christopher olston anthony tomasic simultaneous scalability security dataintensive web applications proceedings 2006 acm sigmod international conference management data june 2729 2006 chicago il usa dimitri theodoratos mokrane bouzeghoub general framework view selection problem data warehouse design evolution proceedings 3rd acm international workshop data warehousing olap p18 november 0611 2000 mclean virginia united states laurent j lechtenbrger n spyratos g vossen monotonic complements independent data warehouses vldb journal international journal large data bases v10 n4 p295315 december 2001 bin rui wang ying chen ana lelescu james rhodes biwtl business information warehouse toolkit language warehousing simplification automation proceedings 2007 acm sigmod international conference management data june 1114 2007 beijing china nick bassiliades ioannis vlahavas ahmed k elmagarmid elias n houstis interbasekb integrating knowledge base system multidatabase system data warehousing ieee transactions knowledge data engineering v15 n5 p11881205 september himanshu gupta inderpal singh mumick incremental maintenance aggregate outerjoin expressions information systems v31 n6 p435464 september 2006 yannis kotidis aggregate view management data warehouses handbook massive data sets kluwer academic publishers norwell 2002 shivnath babu jennifer widom continuous queries data streams acm sigmod record v30 n3 september 2001 b davidson j crabtree b p brunk j schug v tannen g c overton c j stoeckert jr k2kleisli gus experiments integrated access genomic data sources ibm systems journal v40 n2 p512531 february 2001 ladjel bellatreche kamalakar karlapalem mukesh mohania issues design data warehousing systems data warehousing web engineering irm press hershey pa 2002 stefano rizzi alberto abell jens lechtenbrger juan trujillo research data warehouse modeling design dead alive proceedings 9th acm international workshop data warehousing olap november 1010 2006 arlington virginia usa brian babcock shivnath babu mayur datar rajeev motwani jennifer widom models issues data stream systems proceedings twentyfirst acm sigmodsigactsigart symposium principles database systems june 0305 2002 madison wisconsin zhiyuan chen chen li jian pei yufei tao haixun wang wei wang jiong yang jun yang donghui zhang recent progress selected topics database research report nine young chinese researchers working united states journal computer science technology v18 n5 p538552 september
lodsprite technique accelerated terrain rendering present new rendering technique termed lodsprite rendering uses combination levelofdetail lod representation scene together reusing image sprites previously rendered images primary application accelerating terrain rendering lodsprite technique renders initial frame using highresolution model scene geometry renders subsequent frames much lowerresolution model scene geometry texturemaps polygon image sprite initial highresolution frame renders subsequent frames technique measures error associated divergence view position position initial frame rendered error exceeds userdefined threshold technique rerenders scene highresolution model efficiently implemented lodsprite technique texturemapping graphics hardware although date applied lodsprite terrain rendering could easily extended applications feel lodsprite holds particular promise realtime rendering systems b introduction scene geometry becomes complex millions poly gons even advanced rendering hardware cannot provide interactive rates current satellite imaging technology provides terrain datasets well beyond level complexity presents two problems realtime systems 1 provided frame rate may insufficient 2 system latency may high much realtime computer graphics dedicated finding ways trade image quality frame rate andor system latency many recent efforts fall two general categories levelofdetail lod techniques model objects scene different levels detail select particular lod object based various considerations rendering cost perceptual contribution final image imagebased modeling rendering ibmr techniques model objects scene image sprites sprites require 2d transformations rendering operations dependingon object result substantial time savings however 2d transformations eventually result distortions require underlying objects rerendered full 3d geometry ibmr techniques typically organize 1 department computer science state university new york stony brook stony brook ny 117944400 usa email virtual reality laboratory naval research laboratory code 5580 swanacmorg ekuohomemailcom culling object quality lod renderer ibmr renderer output image output image figure 1 traditional hybrid lod ibmr techniques render object either sprite certain level detail culling object quality output image lod ibmr renderer figure 2 lodsprite technique renders object sprite geometric object certain level detail scene separate nonoccluding layers layer consists object small group related objects render layer separately alphachannel composite hybrid techniques use multiple lods ibmr methods 16 27 22 general pipeline techniques shown figure 1 3d object first subjected culling operation depending upon usersupplied quality parameters system either renders object particular lod reuses cached sprite object paper presents lodsprite rendering technique shown figure 2 technique similar previous hybrid techniques utilizes view frustum culling usersupplied quality metric objects also modeled lod models sprites however lodsprite technique differs 2d sprite coupled lod representation renderer utilizes lod sprite inputs create output im age lodsprite technique first renders frame highresolution 3d scene geometry caches frame image sprite renders subsequent frames texturemapping cached image sprite onto lowerresolution representation scene geometry continues image quality metric requires rendering scenefrom highresolution geometry developed lodsprite technique part rendering engine realtime threedimensional battlefield visualization system 9 application terrain database consumes vast majority rendering resources therefore paper focus terrain rendering however lodsprite generalpurpose rendering technique could certainly applied many different types scene geometry primary advantage lodsprite previous techniques sprite transformed 2d transformation within context underlying 3d structure even composed polygons much larger transformation occur image distortions require rerendering sprite full 3d scene geometry thus lodsprite technique reuse image sprites larger number frames previous techniques addition sprite preserves object details lower lod model used image quality properties allow interactive frame rates larger scene databases next section paper places lodsprite context previous work section 3 describes lodsprite technique section 4 presents results implementation lodsprite previous work closely related lodsprite classified imagebased modeling rendering techniques levelofdetail techniques first revisit classify previous ibmr techniques also considering lod techniques focus hybrid techniques 21 imagebased modeling rendering previous work imagebasedmodeling rendering falls primarily three categories 1 scene modeled 2d image sprites 3d geometry used many previous techniques model 3d scene registering number static images 2 18 19 26 techniques particularly wellsuited applications photographs easy take modeling scene would difficult outdoor settings example novel views scene created 2d transforming interpolating images 3 18 adding depth 17 even layered depth 23 sprites realistic navigation includes limited parallax possible another category samples full plenoptic function resulting 3d 4d even 5d image sprites 13 10 allow unrestricted navigation class techniques however techniques lack full 3d structure scene restrict navigation least degree 2 scene modeled using either 3d geometry 2d image sprites another set previous techniques model object either 3d geometry 2d image sprite based object contribution final image viewing direction 5 16 20 21 22 27 lodsprite technique differs techniques integrates 3d geometry 2d image sprites model render objects 3 scene modeled using combination 3d geometry 2d image sprites group techniques add simple 3d geometry single 2d image 6 7 12 24 guides subsequent image warping debevec et al 7 construct 3d model reference images sillion et al 24 darsa et al 6 use textured depth mesh constructed simplified depth information general using depth mesh projective texture mapping gives better image quality using depth image warping 17 mesh stretches cover regions pixel information available thus holes appear main advantage adding 3d scene geometry image allows warping approximate parallax therefore increases range novel views possible image distortion becomes severe lodsprite closely related techniques cohen et al 4 soucy et al 25 create texture map 3d object represented high geometric resolution subsequently represent object much lower geometric reso lution apply previously created texture map geometry however lodsprite technique generates texture maps image sprites images rendered runtime techniques generate texture map object 22 levelofdetail large body previous work levelofdetail lod techniques reviewed general lodsprite technique requires geometric objects represented various levels detail require particular lod representation technique although specific implementation lod sprite need access underlying lod data structures paper cover create lod representations terrain exist numerous multiresolution representations height fields lindstrom et al 14 hoppe 11 represent recent viewdependent terrain lod methods luebke erikson 15 also adapted terrain datasets paper adopt technique lindstrom et al 14 algorithm organizes terrain mesh hierarchical quadtree structure decide quadrant level use algorithm computes screen space error vertex compares predefined error threshold error measures pixel difference fullresolution lowerresolution representations quadrant 23 accelerated virtual environment navigation stated many lod ibmr techniques applied problem accelerating virtual environment naviga tion lodsprite closely related techniques maciel shirley 16 shade et al 22 schaufler stuerzlinger 21 aliaga 1 papers present similar hybrid lodibmr techniques create hierarchy image sprites based space partition scene geometry subsequent frames node techniques either texture map node sprite onto polygon rerender nodes 3d geometry error metric threshold reused image sprite means entire subtree 3d geometry need ren dered yields substantial speedup navigating large virtual environments main limitation techniques creating balanced space partition quick operation must updated objects move also avoid gaps neighboring partitions either maintain fairly large amount overlap partitions 22 morph geometries guarantee smooth transition geometry sprite 1 operations add storage computational complexity lodsprite differs techniques interpolate image sprite single 2d polygon lodsprite interpolates image sprite coarse representation 3d scene geometry 31 algorithm general idea lodsprite technique cache rendered view highresolution representation dataset refer image sprite frame sprite created keyframe lodsprite renders subsequent frames referred novel views lower resolution applies sprite texture map lodsprite measures error caused divergence viewpoint keyframe novel view rendered error exceeds threshold lodsprite renders new keyframe pseudocode lodsprite algorithm given figure 3 lines 1 5 generate sprite image highresolution scene geometry necessary whenever viewer jumps new viewpoint position line 1 lodsprite generates new render sprite image highresolution scene geometry viewpoint vp 2 novel viewpoint vp 4 error threshold 5 render sprite image highresolution scene geometry viewpoint vp set lowresolution scene geometry polygons 7 poly 8 wasvisible poly sprite 9 render poly map sprite else render poly map original texture map figure 3 pseudocode lodsprite algorithm line 5 line 2 algorithm processes novel viewpoint lines 3 4 measure error associated far current viewpoint diverges viewpoint time sprite rendered procedure errormetric described section 32 line 6 algorithm prepares render frame current viewpoint gathering set polygons lowresolution version scene geometry line 7 considers polygon line 8 determines lowresolution poly gon whether polygon visible sprite image taken routine wasvisible described section 33 determines whether polygon texture mapped sprite texture line original texture map line 11 sprite data structure holds sprite texture map viewing parameters lodsprite uses map polygons sprite texture line 9 creating new sprite lines 1 5 requires copying frame buffer texture memory efficiently implemented opengl glcopytexim age2d function texture mapping keyframe could achieved using projective texture mapping light placed keyframe camera position projects sprite image onto scene geometry however implementation lodsprite use projective texture map ping current opengl implementation test polygon visibility occluded polygons keyframe mapped wrong textures become visible therefore implementation detects polygon visibility line 8 applies different texture map dependingon polygons visibility lines 9 11 32 lodsprite decides render new keyframe based error metric similar described shade et al 22 figure 4 gives technique drawn 2d clarity consider rendering fullresolution dataset viewpoint position v1 case line segments ac cb rendered 3d polygons view ray passing vertex c intersects edge ab point c 0 rendering fullresolution dataset image v1 stored texture map consider rendering scene novel viewpoint v2 using lowresolution representation dataset case line segment ab rendered texture mapped sprite rendered v1 note projects vertex c position c 0 ab v1 projection makes visible differ ence however v2 vertex c 0 shifted angle true location c angle converted pixel distance image plane view v2 measure error rendering point c view v2 fi view angle single pixel eg fieldofview screen resolution ffl userspecified error threshold long equation 1 true render using sprite recent keyframe eg line 5 figure 3 skipped equation 1 becomes false necessary render fullresolution dataset eg line 5 figure 3 executed figure 4 calculating error metric theoretically evaluate equation 1 points highresolution dataset eachnovel view clearly impracti cal instead implementation calculates central vertex lowresolution quadtree quadrant resolution quadrant determined number levels traverse quadtree created lod algorithm 14 calculate central vertex averaging four corner vertices quadrant calculate know point c 0 calculate interesting vector v1c plane spanned estimated central vertex two original vertices quad rant know c 0 calculate dot product vectors v2c 0 v2c next calculate average sum squares error evaluated quadrants compare fi delta n number lowresolution quadrants test fails line 5 figure 3 executed 33 visibility changes viewpoint changes polygons originally occluded culled view frustum may become visible figure 5 illustrates problem let two objects represent mountains light shaded region back mountain indicates occluded polygons keyframe heavy shaded regions mountains show polygons culled view frustum regions become visible novel view sprite texture map solution map texture map use generate keyframe classify visibility polygon single pass vertices lowresolution geometry loop part process generating new keyframe novel views visibility polygon sprite already flagged visibility keyframe viewport novel frame viewport figure 5 originally occluded view frustum culled objects may become visible flag controls texture map used polygon thus line 8 figure 3 fast table lookup opengl determines visibility polygon novel viewpoint using hardware zbuffer implementation terrain represented triangle mesh determine visibility lowresolution triangle using keyframe viewing parameters keyframe z buffer visibility determination triangle binary means consider partially occluded triangle fully occluded attempt subdivide partially occluded tri angles achieving would require clipping triangle visible invisible subtriangles 8 would expensive would also generate many small triangles accurately detect visibility scanconvert whole triangle detect visibility every pixel obviously expensive instead perform detection three triangle vertices three vertices visible flag triangle visible course fails triangles unoccluded vertices nevertheless partially occluded eg part edge interior could occluded triangle erroneously flagged visible however terrain datasets rarely occurs since projections background triangles tend much smaller foreground triangles use zbuffer determine visibility vertex calculate keyframe store zbuffer viewing matrix vertex calculate x screen coordinate zdepth value keyframe viewing matrix compare depth value z value location x zbuffer tells us whether vertex occluded keyframe raises several implementation issues first vertex usually projected onto integer grid point zbuffer using zbuffer value closest grid position always give correct visibility z value could represent neighboring triangle interpolating neighboring z values also inappropriate could represent disconnected ob jects second issue lod mesh static compare lowresolution geometry zbuffer rendered highresolution geometry although solve either problems obtained good results practice using following equation determine visibility z vertex calculated z value vertex z buffer zbuffer value closet grid point ffl specified thickness visible surface equation 3 true flag vertex visible 34 implementation notes enhance rendering time tried optimize implementation graphics hardware frame need two texture maps original texture map current keyframe map visible polygons much costly load appropriate map texture memory perpolygon basis instead load maps texture memory scale calculated texture coordinates polygon accesses correct map addition use triangle strips rendering primitive drawback primitive apply one texture map whole strip strips contain visible invisible triangles use original texture map results shown figures 6 7 input 512 theta 512 height field 512 theta 512 texture map figures 6ae compare lodsprite technique standard lod technique 14 figure 6a shows terrain dataset rendered lowresolution lod decomposition containing 1503 triangles figure 6b shows terrain rendered highresolution decomposition 387973 triangles figures use texture map comparing 6a 6b see expected many surface features smoothed figure 6c shows view rendered lodsprite technique using 1503 triangles figure 6a texture mapped figure 6b unlike figure 6a surface features quite well preserved yet figures 6a 6c take amount time 10 milliseconds render figures 6d 6e give difference images figure 6d gives absolute value difference high low resolution images figure 6e high lodsprite images figures 6d e clearly show imagequality advantage lodsprite tech nique notice however bright band along silhouette horizon well edge dataset lower lefthand corner images appear lod decomposition 14 sensitive edge dataset silhouette edges figure 7ae show similar results rendered viewpoint mountains looking onto plain beyond figure note close mountains appear similar low resolution high resolution b lodsprite technique c mountains close even high resolution polygons large lod decomposition keeps polygons full resolution difference images figures 7d e also demonstrate comments regarding silhouette edge given also apply figure although case entire silhouette edge also edge data figures 914 give algorithms timing behavior camera path shown figure 8 camera starts away terrain zooms flies plain mountain range onto plain beyond path visits interesting topological features dataset animation contains 600 frames figures except figure 12 frame count varied frame rendered resolution 512 theta 512 sgi onyx 2 6 195mhz mips processors infinite reality graphics rendered animation three different runs 1 using highresolution lod decomposition 2 using lowresolution lod decomposition 3 using lodsprite technique lodsprite technique used settings highresolution run keyframes settings lowresolution run frames figure 9 shows number triangles changes frame rendered lowresolution lodsprite runs identical triangle counts except keyframes high figure 8 camera path figures 914 resolution run requires 2 orders magnitude triangles semilog plot shows triangle counts similar variation animation progresses figure shows lodsprite error section 32 changes frame rendered error always starts zero novel views interpolated keyframe error increases error exceeds 10 pixels calculate another keyframe highresolution scene geometry drops error zero figure 11 shows amount time required render frame highresolution time runs along top graph average 526 milliseconds per frame lowresolution time runs along bottom average 22 milliseconds per frame rendering time lodsprite frames follows lowresolution times except new keyframe rendered animation system generated 16 keyframes average time 680 milliseconds per keyframe great majority lodsprite frames shown near bottom graph took average 36 milliseconds render overall average lodsprite 53 milliseconds per frame figure 12 shows fraction total number rendered frames keyframes plotted total number frames rendered path shown figure 8 expected frames rendered fixed path distance moved frame decreases coherence successive frames figure shows system takes advantage increasing coherence rendering smaller fraction keyframes figure also illustrates useful property lodsprite technique realtime systems frame update rate increases lodsprite technique becomes even efficient terms reusing keyframes figure also shows fraction total number rendered frames keyframes time plots fraction error threshold pixels expected larger error threshold means fewer keyframes need rendered however shape curve indicates decreasing performance benefit error threshold exceeds 10 pixel given dataset path representative types maneuvers user expected make type analysis help determine best error threshold versus performance tradeoff lodsprite technique results substantial speedup rendering fullresolution dataset rendering 600 frames fullresolution dataset along path figure 8 takes 316 seconds rendering 600 frames lodsprite technique using error threshold 10 pixel takes frame number triangles highresolution lodsprite figure 9 number triangles function frame number semilog plot 600 frames path figure 8 frame number0206114 figure 10 error pixels function frame number lodsprite run 600 frames path figure 8 99 figure 14 shows speedup varies function error threshold 5 conclusions future work paper described lodsprite rendering technique application technique accelerating terrain rendering technique combination two rich directions accelerated rendering virtual environments multiple levelofdetail lod techniques imagebasedmodeling rendering ibmr tech niques generalpurpose rendering technique could accelerate rendering application could built upon lod decomposition technique improves image quality lod techniques preserving surface complexity improves efficiency ibmr techniques increasing range novel views possible lodsprite technique particularly wellsuited realtime system architectures decompose frame number10030050070090011001300rendering time msec highresolution lowresolution lodsprite figure 11 rendering time milliseconds function frame number 600 frames path figure 8 total number frames001003005007fraction keyframes figure 12 fraction keyframes function total number frames rendered path figure 8 scene coherent layers primary applied thrust work augment rendering engine realtime threedimensional battlefield visualization system 9 system operates realtime important item future work address variable latency caused rendering keyframes one optimization use dualthread implementation one thread renders keyframe another renders lodsprite frame another optimization render keyframe advance predicting viewpoint next time render keyframe predict extrapolating past several viewpoint loca tions thus begin rendering new keyframe immediately previous keyframe rendered system makes bad prediction perhaps user makes sudden highspeed neuver two solutions possible 1 could use previous keyframe sprite additional frames lodsprite render ing penalty succeedingframes errors beyond normal threshold 2 predicted viewpoint closer current viewpoint current viewpoint previous keyframe use predicted viewpoint keyframe threshold pixels005015025 fraction keyframes figure 13 fraction keyframes function error threshold 600 frames path figure 8 threshold pixels481216 figure 14 speedup function error threshold 600 frames path figure 8 stead also considering implementing cache keyframes would accelerate common virtual environment navigation behavior moving back forth within particular viewing region issues include many previous keyframes cache choosing cache replacement policy continuous lod algorithm 14 implementation wellsuited application realtime terrain rendering ever lowresolution mesh generated technique preserve silhouette edges demonstrated figures 6 7 forces us use original texture map along silhouette another problem many continuouslod techniques includ ing 14 artifact caused sudden resolution changes results continuous popping effect realtime flythroughs solution artifact geomorphing geometry slowly changed several frames address issues currently integrating lod technique luebke erikson 15 preserves silhouette edges provides nice framework evaluating geomorphing techniques finally important limiting factor performance lodsprite technique well imagebased modeling rendering techniques eg 22 opengl requires texture maps dimensions powers 2 thus many texels texture maps actually unused lodsprite technique could efficiently implemented graphics hardware impose constraint acknowledgments acknowledge valuable contributions bala krishna nakshatrala bug fixes various improvements code regenerating animations help preparing graphs work supported office naval research grants n000149710402 n0001499wr20011 national science foundation grant mip9527694 acknowledge larry rosenblum advice direction project r visualization complex models using dynamic texturebased simplification quicktime vr imagebased approach virtual environment navigation view interpolation image synthesis navigating static environments using imagespace simplification morphing modeling rendering architecture photographs hybrid geometry imagebased approach efficient viewdependent imagebased rendering projective texture mapping lumigraph smooth viewdependent levelofdetail control application terrain rendering tour picture using spidery mesh interface make animation single image light field rendering realtime continuous level detail rendering height fields visual navigation large environments using textured clusters plenoptic modeling imagebased rendering system priority rendering virtual reality address recalculation pipeline three dimensional image cache virtual reality layered depth images efficient impostor manipulation realtime visualization urban scenery texturemapping approach compression colored 3d triangulations video mosaics virtual environments commodity realtime 3d graphics pc tr view interpolation image synthesis priority rendering virtual reality address recalculation pipeline visual navigation large environments using textured clusters quicktime vr plenoptic modeling modeling rendering architecture photographs light field rendering lumigraph hierarchical image caching accelerated walkthroughs complex environments realtime continuous level detail rendering height fields talisman visualization complex models using dynamic texturebased simplification postrendering 3d warping navigating static environments using imagespace simplification morphing viewdependent simplification arbitrary polygonal environments tour picture appearanceperserving simplification multiplecenterofprojection images layered depth images smooth viewdependent levelofdetail control application terrain rendering battlefield visualization responsive workbench realtime photorealistic visual flythrough ctr yadong wu yushu liu shouyi zhan xiaochun gao efficient viewdependent rendering terrains description graphics interface 2001 p217222 june 0709 2001 ottawa ontario canada huamin qu ming wan jiafa qin arie kaufman image based rendering stable frame rates proceedings conference visualization 00 p251258 october 2000 salt lake city utah united states alexandre passos richard simpson developing 3d animated applications prototypes classroom journal computing sciences colleges v17 n5 p132139 april 2002 jrgen dllner konstantin baumman klaus hinrichs texturing techniques terrain visualization proceedings conference visualization 00 p227234 october 2000 salt lake city utah united states multilayered image cache scientific visualization proceedings ieee symposium parallel largedata visualization graphics p9 october 2021 trker yilmaz uur gdkbay varol akman modeling visualization complex geometric environments geometric modeling techniques applications systems tools kluwer academic publishers norwell 2004
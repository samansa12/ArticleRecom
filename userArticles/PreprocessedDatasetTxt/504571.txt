typed context calculus paper develops typed calculus contexts ie lambda terms holes addition ordinary lambda terms calculus contains labeled holes hole abstraction context application manipulating firstclass contexts primary operation contexts holefilling captures free variables operation conflicts substitution lambda calculus straightforward mixture two results inconsistent system solve problem defining type system precisely specifies variablecapturing nature contexts keeps track bound variable renaming mechanisms enable us define reduction system properly integratesbrgreduction holefilling resulting calculus churchrosser type system subject reduction property believe context calculus serve basis developing programming language advanced features call manipulation open terms copyright 2001 elsevier science bv b introduction context lambda calculus term hole operation contexts hole context term purpose 1 authors version article appear theoretical computer science current aliation department information science university tokyo bunkyoku tokyo 1130033 japan 3 atsushi ohoris work partly supported japanese ministry education grantinaid scientic research priority area 275 advanced databases parallel distributed processing research consortium japan preprint submitted elsevier preprint 23 january 2001 explanation section write c context containing hole indicated write cm term obtained c lling hole example c xy 3 cxz xxzy 3 seen simple example feature distinguishes operation substitution lambda calculus captures free variables example x x z becomes bound lled context one motivation behind using contexts theory lambda calculus study properties open terms since behavior open term depends bindings free variables order analyze behavior essential consider possible contexts open term occurs study program analyses based contexts observational equivalence 1311 yields important results analysis programming languages usages context metalevel notion applicability programming languages largely limited metalevel manipulation programs believe programming language extended rstclass contexts extended language provide various advanced features call manipulation open terms let us brie mention programming environment conventional programming environments programs must rst compiled object modules must linked together form executable program moreover executable program must closed term programming environment extended ability link various software components dynamically exibility signicantly increase since mechanism contexts advocating oers way performing linking runtime would provide basis developing environment theoretically sound way distributed programming distributed programming one often wants send piece code remote site execute witnessed recently emerging internet programming languages java 4 feature greatly enhance expressive power distributed programming one naive approach send program pack necessary resources closure send entire closure remote site obvious drawback approach ineciency since cases communicating sites share common resources standard runtime libraries better approach would send open term make necessary binding remote site typed calculus rstclass contexts would provide clean type safe mechanism manipulating open terms firstclass modules program using module naturally regarded open term containing free variables whose values supplied module one way modeling module exporting set functions f identiers f would therefore regarding context captures variables f bind f respectively using opening module corresponds lling hole context variables approach provide new foundation exible module systems conventional languages modules modula2 18 standard ml 12 rigid separation type system modules terms allowable operations modules rather limited signicant potential advantage modulesascontexts approach modules freely combined constructions available language ie modules treated rstclass citizens needless say actual module system must account various features type abstraction type sharing separate compilation simple view alone immediately provide proper basis module systems nonetheless believe properly rened various mechanisms module systems studied literature approach open new possibility exible module systems indeed recent work wells vestergaad 17 shows connection module language context calculus general motivation study develop programming language rstclass contexts represent features clean way despite potentially promising features contexts language rstclass contexts well investigated lee friedman 10 proposed calculus contexts lambda terms two disjoint classes objects contexts regarded source code lambda terms compiled code separation done assuming two disjoint variable name spaces one lambda terms one contexts consequence system reduction llreduction two disjoint relations without nontrivial interaction dami 2 also announced system dynamic binding similar lee friedman approaches would useful representing source code data structure allow contexts language treated rstclass values inside language kahrs 9 developed combinatory term rewriting system compatible contexts however contexts holelling represented terms within system terms talcott 16 developed algebraic system manipulating binding structures system includes suitable mechanisms manipulating contexts particular contains holes holelling commutes substitution however metalevel system issue representing contexts associated holelling operation inside reduction system lambda calculus addressed one features contexts bind variables holes sense contexts closely related environments abadi et al 1 developed calculus explicit substitutions motivation similar spirit internalizes metalevel mechanism lambda calculus however address problem rstclass treatment substitu tions revising present article authors noticed sato et al 14 recently developed environment calculus environments rstclass values obtaining con uent calculus also address problem variable binding presence rstclass environments solution problem similarity although general mechanisms needed calculus rstclass contexts shall comment detail describe approach next section goal paper establish type theoretical basis programming language rstclass contexts developing typed context calculus lambda terms simply special case contexts particular contexts lambda terms belong syntactic category sharing set variables substitution holelling dened syntactic objects property essential achieving various features explained observed literature 910 however reduction llreduction contexts mix well naive integration yields inconsistent system development meaningful calculus containing reduction llreduction acting set terms constitutes nontrivial technical challenge main technical contribution establish calculus possible prove calculus churchrosser type system subject reduction property obtain con uent calculus overcome various delicate problems dealing variables introduce several new mechanisms lambda calculus giving technical development next section explain problems outline solution 2 problem solution hard extend syntax untyped lambda calculus constructors contexts conventional study holes contexts name less however since goal develop calculus rstclass contexts able consider context containing contexts requires us generalize contexts contain multiple dierent holes one lled holelling operation one way dene uniform syntax contexts introduce labeled holes 9 use upper case letters labeled holes incorporate operations contexts terms lambda calculus introduce hole abstraction xm abstracts hole x term creates term acts context whose hole x introduce context application denotes operation abstracted hole 1 term 2 example context c x represented term context application term denotes term obtained lling hole context x call subterm form xm contracts term obtained 1 lling xhole 1 2 dierent meta notation cx application term constructor allows us exploit features rstclass contexts combining lambda abstraction lambda application example write term like contracted term goal paper develop type system reduction system lambda calculus extended three term constructors ie labeled holes hole abstraction context application crucial step development proper mechanism integrating variablecapturing hole lling captureavoiding substitution lambda calculus see problem consider term use dierent type faces x x x distinguish dierent occurrences variable x pay attention term two redexes one llredex intention inner x captured x lled hole x outer x free following reduction sequence produces intended result however reducing redexes llredex result dierent term reduce inner redex llredex binding inner x lost yielding x reduce outer redex llredex outer x unintentionally captured depending order llredex redex avoid inconsistencies redene scope lambda binding ect behavior terms form xm 1 2 suppose x 1 whose scope contains x since 2 lled x scope x also extends 2 property implies following two requirements first redex containing hole x cannot contracted secondly substituting term containing x free variable 2 x 1 corresponding variables 1 2 need renamed avoid unwanted capture example contract inner redex holelling contract outer redex hole lling rename x x substitution situation becomes subtle consider term like w zwx since w variable simple inspection term wxz longer tells variables xz regarded bound however variablecapture still occur hole abstraction substituted w strategy solve problem dene type system tells exactly variables considered bound introduce rened notion equivalence reconciles holelling substitution tell variables considered bound type hole abstracted term xm context type form 1 type abstracted hole 2 type term produced lling hole context term describes set variables captured lled hole x call variables interface variables example would typed fx intg int int however simply list set actual bound variables surrounding x xm interface variables type cannot rename bound variables since substitution dened renaming bound variables causes problem extending substitution hole abstracted terms example cannot rename bound variable x term xxx noted usual bound variable convention solve problem lambda calculus simply assume bound variables dierent free variables redex possible freely rename bound variables well known theory lambda calculus condition preserved substitution even start term satisfying bound variable condition anomalous terms like may appear reduction avoid problem separate actual bound variables xm corresponding interface variables rene holelling operation also performs variable renaming manipulation binding structures talcott 16 developed technique pair hole substitution use approach annotate hole x variable renamer renames interface variables corresponding bound variables write x hole x annotated context represented typed term x interface variable renamed lled x separation bound variable renamed without changing type term allows us achieve proper integration holelling substitution terms form xm semantics holelling preserved applying renamer faxg term lled x example following reduction example yet another delicate problem arises consider interaction substitution term form mn construct may bind variables n order determine bound variables need annotate construct set variables n bound forming term since set must correspond set interface variables context term naive attempt would annotate constructor mn set subterm example term might represented term xax faxg z noted earlier variable x must treated bound variable implies combining substitution variable needs renamed unfortunately impossible terms form w fxg cannot rename corresponding interface variables hole abstracted term substituted later w need separate set interface variables type hole abstracted term set variables captured lled hole context achieve annotate constructor context application renamer write n renamer renames variables n bound holelling corresponding interface variables hole abstracted term eect obtained composing renamer hole bound variables n independent corresponding interface variables perform bound variable renaming example correctly represented following term b term b bound variables renamed without changing typing term semantics holelling preserved applying composition faxg fxbg fabg renamers faxg fxbg term lled x following example reduction involving renamer applications b 3 another slightly general alternative n make renamer term constructor n introduce new type constructor n g constructor believe also possible system however shall take approach since elimination operation would modied version holelling therefore additional exibility essential achieving goal rstclass treatment contexts based strategies outlined worked denition type system calculus reduction system proved type system subject reduction property reduction system churchrosser work sato et al 14 typetheoretical approach similar taken order identify set free bound variables however system fully address problem mixing construct substitution calculus contains term constructor e 1 intuitive meaning evaluate e 2 bindings provided environment e 1 however reduction nested application construction restricted variables act general terms restricted treatment subtle problem equivalence explained arise system careful reader may noticed aspects contexts already represented lambda calculus one predetermine exact order variables exported context imported term lled context one represent hole abstractions context applications simply functionals seen following encoding scheme holelling form represented lambda term form however encoding eliminates ability bind variables names therefore signicantly reduces benets rstclass contexts advocated introduction rest paper organized follows section 3 dene context calculus section 4 denes reduction system proves subject reduction property churchrosser property calculus section 5 concludes paper discussion investigations appendix contains proofs lemmas 3 calculus use following notation functions domain codomain function f written domf codf respectively sometimes regard function set pairs write empty function let f g functions write f g f g provided domf domg omit g explicitly represented set writing ff g f g restriction function f domain written f j set types ranged calculus given syntax b ranges given set base types ranges variable type assignments function nite set variables types let x range countably innite set variables let x range countably innite set labeled holes let range variable renamers function nite set variables variables denoted fy 1 x g let renamer avoid unnecessary complication assume fy ng fx n renamer changes name domain renamer fresh name identity renamer extended set variables letting follows identify renamer extension however maintain domain dom renamer always means domain original nite function composition 1 2 two variable renamers 1 2 function set unchecked terms ranged calculus given syntax term xm binds hole x denitions bound holes free holes given similarly usual denition bound variables free variables ordinary lambda calculus write fhm set fig 1 sets free bound variables free holes since x binder holes create subtle problems explained variables calculus therefore safely assume renaming bound holes congruence ordinary lambda calculus follows regard terms equivalence classes induced bound holes renaming set free variables denoted fv bound variables denoted bv given figure 1 denitions correctly model eect context application terms form 1 2 binds variables dom 2 addition sets free bound variables need distinguish three classes variables let term containing hole x variables cod call free variable candidates behave similarly free variables abstracted variables set dom call interface variable candidates source interface variables see last one consider term contains 1 2 variables cod call exported variables used match variables exported context 1 bound variables 2 formal denitions set fv cm free variable candidates set iv cm interface variables candidates given figure 2 denition set ev exported variables given figure 3 fig 2 sets free variable candidates interface variable candidates fig 3 set exported variables dene set pfv potentially free variables position dene type system calculus since term may contain free holes well free variables type depends types variables also types free holes hole type determined triple consisting type term lled type assignment describing set interface variables types variable renamer used keep track correspondence bound variables interface variables describes set abstracted variables describes set free variable candidates abstracted triple obtained abstracting x whose denition given operation extended type assignments follows hole type assignment ranged nite function assigns hole triple describing type hole call variables dom interface variables write clos hole type assignment domg write hole type assignment g type system calculus dened proof system derive typing form indicates term type variable type assignment hole type assignment set typing rules given figure 4 explanations order rule hole since x surrounded moment associated type assignment hole type assignment empty set variable candidates x specied abstracted rule abs rule abs lambda abstracting x discharges x type hypothesis term also extends set interface variables hole corresponding x 0 later eect represented operation closfx g extends appearing rule forming term 1 fx 0x 1 x 0 xng 2 x 2 becomes bound set interface variables hole 2 extended property modeled discharging x typing judgment 2 abstracting 2 rule similar one closure ie term associated explicit substitution calculus 1 figure 5 shows example typing derivation abs app dom fx 0 fig 4 type system fig 5 example typing derivation calculus free hole occurs linearly welltyped term multiple occurrences hole allowed could dierent interface variables would considerably complicate conceptual understanding contexts well type system linearity condition ensured rule hole condition implied notation 1 2 rules app property rule adding redundant hypothesis following lemma easily shown induction typing derivations dom moreover free hole appears exactly following standard properties also hold type system easily shown induction typing derivations lemma lemma lemma 7 x fx 0 yng occurs fz ng fx 0 fy 0 fy 0 0 obtained substituting x fx 0 yng wng 4 reduction system dene reduction relation need dene substitution holelling operations ordinary lambda calculus substitution dened modulo congruence allows us simply assume unwanted variable capture happen calculus since yet obtained congruence need rst dene substitution operation syntactic terms equivalence class write fm 0 xgm term obtained substituting 0 free occurrence x following lemma shows substitution preserves typing strong variable hygiene conditions lemma proof deferred appendix standard denition sub stitution following composition lemma explained earlier holelling involves application variable renamer associated hole term lled dene holelling extend variable renamer function terms follows following renaming lemma whose proof deferred appendix holelling dened combination variable renamer substitution write 0 x term obtained syntactically substituting term 0 x variable renamer associated x denition obtained simply extending following clauses according structure denition property typing easily seen following lemma shows holelling preserves typing lemma proof deferred appendix following composition lemma holelling iv cx denotes domain variable renamer shoulder hole x lemma 12 proof dom 1 pfv mndom 2 mthe notion congruence calculus dened congruence relation set well typed terms generated following two axioms yng fy 1 x 62 bv following lemma shows renaming preserves typing proved induction derivation using lemma 10 congruence allows us rename bound variables whenever necessary follows assume following variable convention calculus bound variables distinct set bound variables intersection set interface variable candidates set potentially set exported variables variable convention reduction axioms calculus given follows axiom restriction fhm 2 needed ensure linearly restriction fhm 1 needed maintain binding generated x holes 1 since calculus contexts represented terms free holes hole abstracted terms restrict rstclass treatment contexts onestep reduction relation n dened set well typed terms well typed 0 obtained applying one two reduction axioms subterm write exive transitive closure reduction following desired results theorem 14 subject reduction app fig 6 denition parallel reduction proof direct consequence lemmas 78 11 13 2 theorem 15 con uence well typed term 3 1 proof using technique parallel reduction due tait martinlof parallel reduction relation calculus written given figure 6 denition easily seen transitive closure parallel reduction coincides reduction relation calculus prove theorem therefore sucient prove diamond property show follow takahashi 15 prove following stronger property lemma 16 well typed term exists term lemma denotes term obtained parallel reducing possible redexes whose denition given figure 7 proof lemma 16 induction derivation using following lemmas 1 lambda abstraction 1 hole abstraction fig 7 denition lemma terms mm 0 fx proof proceed induction derivation 0 show cases betred andlred case betred induction hypothesis therefore rulebetred 1 rest case lemma 9 case lred induction hypothesis therefore rulelred assume x 62 dom hygiene condition lemma proof proceed induction derivation 0 show crucial case lred case lred induction hypothesis 2 x rule lred since fx x 0 gbv therefore fx 0 xgm 0 terms mm 0 n proof proceed induction derivation 0 show cases hole lred repeated application lemma 18 case lred 6 x suppose induction hypothesis 1 therefore rulelred rest subcase 0 induction hypothesis therefore rulelred therefore lemma 12 completes proof theorem 15 conclusions developed typed calculus contexts calculus contexts lambda terms share set variables freely mixed far typecheck allows us treat contexts truly rstclass values however straightforward mixture reduction llreduction results inconsistent system solved problem developing type system precisely species variablecapturing nature contexts resulting typed calculus enjoys subject reduction property churchrosser property believe typed context calculus presented serve type theoretical basis developing programming language advanced features manipulation open terms number interesting topics merit investigation brie discuss integration explicit substitution calculus contraction restricted redexes contain free holes restrict rstclass treatment contexts removing restriction make reduction system slightly general noted earlier one reason restriction contract redex containing free hole binding hole lost one way solving problem would integrate calculus calculus abadi et al 1 generalize variable renamers explicit substitutions dowek et al 3 considered calculus containing holes grafting roughly corresponds holelling developed technique mingle captureavoiding substitution grafting encoding calculus explicit substitution using de bruijn notation although calculus contain term constructor context application therefore technique directly applicable calculus believe possible extend technique calculus translating machinery developed calculus de bruijn notation however translation would signicantly decrease exibility access exported variables names also noted notion de bruijn indexes presupposes equivalence terms therefore dening context calculus using de bruijn notation requires mechanisms something similar obtaining equivalence developed paper programming languages contexts motivation provide basis developing programming language feature rstclass contexts context calculus worked article guarantees typed language rstclass contexts order develop actual programming language however need develop realistic evaluation strategy calculus preliminary investigation shows usual callbyvalue evaluation strategy using closures extended calculus challenging topic develop polymorphic type system type inference algorithm calculus enable us develop mlstyle programming language feature contexts advocated one crucial issue exible treatment context types current denition constructor fx1x 0x nx 0 n g annotated variable renamer reduces exibility calculus better approach would rene type system 0 context type used whenever context type one authors recently developed mlstyle language rst class contexts 5 mlstyle polymorphic type system callbyvalue operational semantics type inference algorithm given relationship formulaastype notion intuitively clear context represented term calculus constructive meaning important question characterize intuition formally sense curryhoward isomorphism 7 would lead us new form proof normalization process corresponding llreduction since context calculus church rosser possible develop proof system conservative conventional intuitionistic logic supports proof normalization process corresponding llreduction authors recently noticed intriguing similarity proof system typings context calculus joshi kulicks partial proof manipulation system 8 used represent linguistic information another relevant system herbelins lambda calculus isomorphic variant sequent calculus proofs certain sequents interpreted applicative contexts 6 results suggest interesting connections context calculus proof systems acknowledgements authors thank pierrelouis curien laurent dami yasuhiko minamide didier remy masahiko sato anonymous referees careful reading draft paper numerous useful comments second author also thanks shinnder lee dan friedman insightful discussions contexts r explicit substitutions lambdacalculus dynamic binding feel java lambdacalculus structure isomorphic sequent calculus structure formulaeastypes notion construction partial proof trees building blocks categorized grammars context rewriting enriching lambda calculus contexts towards theory incremental program construction fully abstract models typed lcf considered programming language explicit environments parallel reductions theory binding structures applications rewriting con uent equational reasoning linking firstclass primitive modules programming modula2 tr programming modula2 3rd corrected ed theory binding structures applications rewriting parallel reductions myampersandlgrcalculus enriching lambda calculus contexts lambdacalculus dynamic binding definition standard ml feel java explicit environments firstclass contexts ml lambdacalculus structure isomorphic gentzenstyle sequent calculus structure context rewriting higherorder unification via explicit substitutions ctr brigitte pientka functional programming higherorder abstract syntax explicit substitutions electronic notes theoretical computer science entcs v174 n7 p4160 june 2007 roger keays andry rakotonirainy contextoriented programming proceedings 3rd acm international workshop data engineering wireless mobile access september 1919 2003 san diego ca usa yosihiro yuse atsushi igarashi modal type system multilevel generating extensions persistent code proceedings 8th acm sigplan symposium principles practice declarative programming july 1012 2006 venice italy christian urban andrew pitts murdoch j gabbay nominal unification theoretical computer science v323 n13 p473497 14 september 2004 murdoch j gabbay new calculus contexts proceedings 7th acm sigplan international conference principles practice declarative programming p94105 july 1113 2005 lisbon portugal makoto hamana term rewriting variable binding initial algebra approach proceedings 5th acm sigplan international conference principles practice declaritive programming p148159 august 2729 2003 uppsala sweden steven e ganz amr sabry walid taha macros multistage computations typesafe generative binding macros macroml acm sigplan notices v36 n10 october 2001 gavin bierman michael hicks peter sewell gareth stoyle keith wansbrough dynamic rebinding marshalling update destructtime acm sigplan notices v38 n9 p99110 september makoto hamana initial algebra approach term rewriting systems variable binders higherorder symbolic computation v19 n23 p231262 september 2006
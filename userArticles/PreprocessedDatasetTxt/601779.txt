fixedparameter complexity semantics logic programs decision problem called parameterized input pair strings one strings referred parameter following problem example parameterized decision problem k serving parameter given propositional logic program p nonnegative integer k decide whether p stable model size k parameterized problems npcomplete often become solvable polynomial time parameter fixed problem decide whether program p stable model size k k fixed part input solved time omnk size p n number atoms p thus problem class p however algorithms running time given polynomial order k satisfactory even relatively small values kthe key question whether significantly better algorithms degree polynomial dependent exist tackle use framework fixedparameter complexity establish fixedparameter complexity several parameterized decision problems involving models supported models stable models logic programs also establish fixedparameter complexity variants problems resulting restricting attention definite horn programs purely negative programs problems considered paper high fixedparameter complexity thus unlikely fixing bounds models supported models stable models lead fast algorithms decide existence models b introduction paper study complexity parameterized decision problems concerning models supported models stable models logic programs investigations use framework fixedparameter complexity introduced downey fellows df97 framework previously used study problem existence stable models logic programs tru01 present work extends results obtained first addition class finite propositional logic programs consider two important subclasses class horn programs class purely negative programs second addition stable models logic programs also study supported models arbitrary models decision problem parameterized inputs pairs items second item pair referred parameter problems decide given logic program p integer k whether p model supported model stable model respectively k atoms examples parameterized decision problems problems npcomplete however fixing k k longer regarded part input makes problems simpler become solvable polynomial time following straightforward algorithm works every subset atp cardinality k check whether leave faculty mathematics information science warsaw university technology second author partially supported nsf grants cda9502645 iri 9619233 eps9874764 model supported model stable model respectively p check implemented run linear time size program since sets tested overall running time algorithm omn k size input program p n number atoms p problem algorithms running times given omn k practical even quite small values k question arises whether better algorithms found instance algorithms whose runningtime estimate would given polynomial order depend k algorithms existed could practical wide range values k could find applications computing stable models logic programs question subject work also consider similar questions concerning related problems deciding existence models supported models stable models cardinality exactly k least k refer problems smallbound problems since k fixed regarded small addition study problems existence models supported models stable models cardinality jatp j gamma k exactly jatp least jatp j gamma k refer problems largebound problems since jatp j gamma k fixed k informally thought large address questions using framework fixedparameter complexity df97 results negative provide strong evidence many parameterized problems considered paper algorithms whose running time could estimated polynomial order independent k formally parameterized decision problem set l sigma theta sigma sigma fixed alphabet selecting concrete value ff 2 sigma parameter parameterized decision problem l gives rise associated fixedparameter problem lg parameterized problem l sigma theta sigma fixedparameter tractable exist constant integer function f algorithm determines whether x 2 l time fjyjjxj jzj stands length string z 2 sigma denote class fixedparameter tractable problems fpt clearly parameterized problem l fpt associated fixedparameter problems l solvable polynomial time algorithm whose exponent depend value parameter parameterized problems fixedparameter tractable called fixedparameter intractable study compare complexity parameterized problems downey fellows proposed following notion fixedparameter reducibility simply reducibility definition 1 parameterized problem l reduced parameterized problem l 0 exist constant p integer function q algorithm 1 assigns instance x l instance 2 runs time oqjyjjxj p 3 x 0 depends upon x 0 depends upon 4 x 2 l use notion reducibility throughout paper two parameterized problems l 1 l 2 l 1 reduced l 2 conversely say l 1 l 2 fixedparameter equivalent simply equivalent downey fellows df97 defined hierarchy complexity classes called w hierarchy classes wt described terms problems complete problem complete complexity class e 2 e every problem class reduced let us call boolean formula normalized conjunctionofdisjunctionsofconjunctions literals number conjunctionsof disjunctionsof expressions definition example 2normalized formulas conjunctions disjunctions literals thus class 2normalized formulas precisely class cnf formulas define weighted tnormalized satisfiability problem given tnormalized formula phi nonnegative integer k decide whether model phi exactly k atoms alternatively decide whether satisfying valuation phi assigns logical value true exactly k atoms downey fellows show every 2 problem wst complete class wt also show restricted version problem ws2 given 2normalized formula phi clause consisting two literals integer k decide whether model phi exactly k atoms complete class w1 strong evidence suggesting implications 1 proper thus proving parameterized problem complete class wt 1 strong indication problem fixedparameter tractable stated earlier paper study complexity parameterized problems related logic programming problems ask whether input program p model supported model stable model satisfying cardinality constraints involving another input parameter integer k categorized two general families smallbound problems large bound problems formal definitions given c denotes class logic programs represents class models interest delta stands one three arithmetic relations given logic program p class c integer k decide whether p model class jm j delta k given logic program p class c integer k decide whether p model class jatp j gamma paper consider three classes programs class horn programs h class purely negative programs n class programs also consider three classes models class models class supported models sp class stable models st thus example problem sp n asks whether purely negative logic program p supported model k atoms jm j k problem st 0 asks whether logic program p syntactic restrictions stable model k atoms false jatp similarly problem 0 h asks whether horn program p model least k atoms false jatp three examples given general problems delta c 0 c input instance consists logic program p class c integer k regard problems parameterized k fixing k k longer part input element problem description leads fixedparameter versions problems denote delta c paper three problems delta c 0 c establish fixedparameter complexities results summarized tables 1 3 table 1 complexities problems c 0 c table 1 list complexities problems bound problems type ask existence models program p contain least k atoms largebound problems group concerned existence models contain jatp j gamma k atoms number false atoms models least k point view fixed parameter complexity problems interesting several remain npcomplete even k fixed words fixing k simplify enough make tractable reason entries table 1 listing complexity npcomplete denoted npc table refer fixedparameter versions c problems c c problem 0 npcomplete every fixed k 1 fixedparameter problems table 1 marked npcomplete npcomplete every value k 0 hand many problems c 0 c easy fixedparameter tractable strong sense solved polynomial time even without fixing k indicated marking corresponding entries table class p rather fpt one exception problem 0 n w1complete smallbound problems cases viewed problems deciding existence small models models containing exactly k k atoms fixedparameter complexities problems summarized table 2 w2 table 2 complexities problem computing small models smallbound problems cases problems involving class purely negative programs class programs w2complete strong indication fixedparameter intractable problems form h fixedparameter tractable fact solvable polynomial time even without fixing parameter k indicate marking corresponding entries p similarly problem st h deciding whether horn logic program p stable model size exactly k p however perhaps somewhat surprisingly remaining two problems involving horn logic programs harder proved problem h w1complete problem sp h w1hard thus likely fixedparameter tractable also showed problem sp h class w2 exact fixedparameter complexity sp h remains unresolved largebound problems cases viewed problems deciding existence large models models small number false atoms equal k less equal k fixedparameter complexities problems summarized table 3 table 3 complexities problems computing large models largebound problems cases problems specified concerning existence models p similarly problems specified involving horn programs solvable polynomial time lastly problem st 0 h well problems p even without fixing k eliminating input problems group higher complexity likelihood fixedparameter intractable one problems 0 w1complete remaining problems w2complete surprisingly problems even harder three problems concerning supported models w3complete two problems involving stable models st 0 could prove w3hard two problems succeed establishing upper bound fixedparameter complexities study fixedparameter tractability problems occurring area nonmonotonic reasoning relatively new research topic two papers aware tru01 gss99 first two papers provided direct motivation work discussed earlier second one authors focused parameters describing structural properties programs showed choices parameters decision problems nonmonotonic reasoning become fixedparameter tractable results concerning computing stable supported models logic programs mostly negative parameterizing basic decision problems constraining size models interest lead cases fixedparameter tractability however several interesting aspects work first identified problems w3complete w3hard relatively problems classes known df97 second context polynomial hierarchy distinction problem existence models specified sizes clausal propositional theories similar problems concerning models supported models stable models logic programs problems npcomplete however look complexity problems detailed way perspective fixedparameter complexity equivalence lost problems w3hard problems concerning existence models 2normalized formulas w2complete easier third results show context fixedparameter tractability several problems involving models supported models hard even class horn programs finally work leaves three problems unresolved obtained bounds problems succeed establishing precise fixedparameter complexities rest paper organized follows next section review relevant concepts logic programming present several useful fixedparameter complexity results problems existence models propositional theories certain special types last section give proofs complexity results preliminaries paper consider propositional case logic program clause rule expression r form propositional atoms call atom p head r denote hr call set atoms fq body r denote br distinguish positive body r symbols negative body r fs symbols logic program collection clauses logic program p atp denote set atoms appear p every clause logic program p empty negative body call p horn program every clause p empty positive body call p purely negative program clause r given 2 propositional interpretation implication given logic program p propositional interpretation p mean propositional formula say set atoms model clause 2 propositional model clause prr usual atoms interpreted true atoms interpreted false set atoms atp model program p model formula prp emphasize requirement paper given program p interested truth values atoms actually occur p well known every horn program p least model respect set inclusion denote model lmp let p logic program following cla78 every atom p 2 atp define propositional formula compp fs atom p 2 atp rules p head get empty disjunction definition compp interpret contradiction define program completion cla78 p propositional theory set atoms atp supported model p model completion p easy see p appear head rule p p false every supported model p also easy see supported model program p model p converse true general given logic program p set atoms define reduct p respect p symbols logic program obtained p 1 removing p clause r call clauses blocked 2 removing negated atoms bodies rules remain rules blocked reduct p horn program thus least model say stable model p notion reduct stable model introduced gl88 known every stable model program p supported model p converse hold general however program p purely negative stable supported models p coincide fag94 arguments use fixedparameter complexity results problems decide existence models prescribed sizes propositional formulas special classes describe problems introduce additional terminology first given propositional theory phi atphi denote set atoms occurring phi case logic programming consider models propositional theory phi sets atoms subsets atphi next define following classes formulas tn class tnormalized formulas simply cnf formulas class 2normalized formulas whose every clause disjunction three literals clearly 2n 3 subclass class 2n tnm class monotone tnormalized formulas tnormalized formulas occurrences negation operator tna class antimonotone tnormalized formulas tnormalized formulas every atom directly preceded negation operator finally extend notation delta c 0 delta c case c stands class propositional formulas terminology 0 3nm denotes problem decide whether monotone 3normalized formula phi model exactly k atoms false similarly tn simply another notation problem wst discussed following theorem establishes several complexity results use later paper theorem 1 problems 2n 2nm w2complete ii problems 2n 3 2na w1complete iii problem 0 3n w 3complete proof statements ii proved df97 prove statement iii use fact problem 3n w 3complete df97 reduce 3n 0 3n conversely let us consider 3normalized literals observe phi model cardinality k related formula obtained phi replacing every negative literal x new atom x every positive literal x negated atom x model cardinality least jat construction defines reduction 3n 0 3n easy see reduction satisfies requirements definition fixedparameter reducibility reduction 0 3n 3n constructed similar way since problem 3n w3complete problem 0 3n 2 proof part iii theorem 1 observed reduction described satisfies requirements specified definition 1 fixed parameter reducibility throughout paper prove complexity results constructing reductions one problem another cases verify condition 4 definition usually nontrivial part proof checking remaining conditions hold straightforward leave details 3 proofs section present typical proofs fixedparameter complexity results problems involving existence models supported models stable models logic programs goal introduce key proof techniques used proving results discussed introduction theorem 2 problems 0 w2complete proof problems clearly w2 models logic program p models corresponding 2normalized formula prp since h complete proof enough show problem 0 h w2hard end reduce problem 2nm 0 h let phi monotone 2normalized formula let k 0 let fx set atoms phi define horn program p phi corresponding phi follows choose atom occurring phi include p phi rules form x next clause phi include p phi rule show phi model size k p phi model size let model phi size k define set 0 us consider clause r c 2 p phi form given since satisfies c model r c since clauses x hence 0 model p phi conversely let 0 model p phi size exactly n gamma k 2 0 consequently obtain clauses phi indeed let us assume clause c atom c atoms c 0 contradiction assertion follows theorem 1 2 theorem 3 problem h w1complete proof first prove hardness part end reduce problem 2na problem h let phi antimonotone 2normalized formula let k nonnegative integer let different atoms occurring phi clause phi define logic program rule r c define p phi let us assume model size k program p phi consequently contradiction thus contain atoms since satisfies rules r c since consists atoms phi model phi indeed body rule r c must false consequently clause c must true similarly one show model phi model p phi thus w1hardness follows theorem 1 prove problem h class w1 reduce problem 2n 3 end every horn program p describe 2normalized formula phi p clause consisting three literals p model size k phi p model k moreover show phi p constructed time bounded polynomial size p degree depending k first let us observe without loss generality may restrict attention horn programs whose rules contain multiple occurrences atom body occurrences eliminated time linear size program next let us note restriction horn program p model size k program p 0 obtained p removing clauses bodies consisting k atoms model size k program p 0 constructed time linear size p k thus describe construction formula phi p horn programs p body every rule consists k atoms let p program define every set b 2 b introduce new variable ub every atom x p introduce 2 k new atoms xi define several families formulas first every x 2 atp set b 2 b x 2 b define next set b 2 b x 2 b define finally rule r p introduce formula define phi p conjunction formulas precisely 2normalized representations given parentheses formula u clearly phi p formula class 2n 3 since body rule p k elements set b jp j2 k elements size k jp j denotes cardinality p number rules p thus phi p constructed time bounded polynomial size p whose degree depend k let us consider model p jm k define set 0 satisfies formulas dx x 2 atp addition formula u also satisfied 0 let us consider formula ebx us assume x ub n fxg true 0 moreover since ub n follows b consequently ub 2 0 thus 0 satisfies eformulas phi p next let us consider formula f b x us assume 0 satisfies ub follows b consequently x 2 lastly let us look formula gr r 2 p let us assume since r horn clause since model p follows hr 2 consequently hr 2 0 thus 0 model gr proved 0 model phi p moreover easy see jm conversely let us assume 0 model phi p jm 0 k set first show model p let us consider arbitrary clause r 2 p say h b atoms let us assume fb need show h 2 br set fb subsets belong b thus phi p contains formulas formulas satisfied 0 also u 2 phi p consequently u satisfied 0 well since atoms b also satisfied 0 since 0 formula belongs phi p thus satisfied 0 follows thus model r consequently program p complete proof show jm model contains atoms xi 1 assume jm j k let us consider atom ub b 2 b ub 2 0 every x 2 b phi p contains rule f b x set 0 model f b x thus x 2 0 since x 2 atp x 2 follows b easy see number atoms form ub true 0 smaller 2 k thus jm contradiction consequently jm follows problem h reduced problem 2n 3 thus theorem 1 problem h class w1 completes argument 2 theorem 4 problem sp w 2 proof show reduction sp 2n w 2 theorem 1 let p logic program atoms x identify supported models p models completion compp completion form compp literals constructed linear time size program p use compp define formula phi p atoms phi p x ui j formula phi p conjunction formulas written formulas given parentheses precise clearly phi p 2normalized formula show compp model size k equivalently p supported model size phi p model size 2k model compp model vm ij model every formula phi denote one j arbitrary one claim model phi p clearly g true 0 every satisfied 0 since one j ui j 2 0 follows every definition j ui 0 model vm ij satisfied 0 finally formulas clearly true 0 thus 0 model phi p size 2k conversely let 0 model phi p jm us assume contains exactly atoms ui j clauses h ensure 0 contains one atom ui j therefore set 0 fui j form fup ps since conjunction g g 0 equivalent x follows exactly atoms x belong 0 thus jm easy see 0 form fx prove every true 0 end let us assume x true 0 k since formula true 0 formula 0 thus formula true 0 since every 1 n formula j true 0 follows formulas phi true 0 since atoms 0 appear atoms x model compp thus problem sp reduced problem 2n completes proof 2 problem sp also established hardness result proved w2hard omit proof due space restrictions thus found exact location problem whierarchy problem st 0 consider succeeded establishing lower bound complexity proved w3hard succeed obtaining nontrivial upper estimate complexity theorem 5 problem st 0 proof reduce problem 0 3n problem st 0 let 3normalized formula xi j literals let v2k1 new atoms occurring phi atom x 2 atphi introduce new atoms xs let p phi logic program following rules ae clearly jatp phi show phi model cardinality least n gamma k p phi stable model cardinality least jatp phi model phi x atoms atphi necessarily distinct claim stable model p phi let us notice rule ax blocked 0 hence program p 0 phi consists rules rules heads ui let us suppose every rule p phi head ui contains either negated atom x 2 nonnegated atom every either xi j thus model formula consequently model phi contradiction hence every rule head ui containing neither negated atom x 2 nonnegated atom x 62 rules also contribute reduct p 0 phi atoms xs facts p 0 phi thus belong lmp 0 conversely xs 2 lmp 0 moreover evident rules bx x 2 lmp 0 x 6 hence observations previous paragraph ui 2 phi finally vq 2 lmp 0 rules dq belong reduct p 0 phi hence stable model p phi cardinality least nk conversely let 0 stable model p phi size least jatp phi j gamma 2k atoms vq must members 0 conse quently hence rule p phi x 0 thus 0 model formula therefore model phi routine task check rules ax imply stable models p phi form necessarily distinct hence jm reduced problem 0 3n problem st 0 thus assertion follows theorem 1 2 r negation failure parameterized complexity consistency clarks completion existence stable models stable semantics logic programs fixed parameter complexity ai nonmonotonic reasoning computing large small stable models tr foundations logic programming logic programming autoepistemic logic contributions theory logic programming fixedparameter complexity ai nonmonotonic reasoning ctr zbigniew lonc mirosaw truszczyski computing stable models worstcase performance estimates theory practice logic programming v4 n2 p193231 january 2004
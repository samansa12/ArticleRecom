file system continuous media continuous media file system cmfs supports realtime storage retrieval continuous media data digital audio video disk cmfs clients read write files sessions guaranteed minimum data rate multiple sessions perhaps different rates nonrealtime access proceed concurrently cmfs addresses several interrelated design issues realtime semantics fo sessions disk layout acceptance test new sessions disk scheduling policy use simulation compare different design choices b introduction current disk drives raw data rates 5 10 million bits per second mbps rates suffice many forms digital audio motion video continuous media cm data audio data rates 8 kbps 14 mbps compressed video ranges one several mbps however disk accessed via generalpurpose file system data rates seen clients generally lower may vary unpredictably developed continuous media file system cmfs whose clients read write files sessions guaranteed minimum data rate multiple sessions perhaps different data rates coexist cmfs handle nonrealtime traffic concurrently realtime sessions authors addresses dp anderson 1891 east francisco blvd san rafael ca 94901 osawa mo business development division storage systems group sony corporation 2255 okata atsugi kanagawa 243 japan r govindan cs division eecs department uc berkeley berkeley ca 94720 work performed university california berkeley supported nsf infrastructure grant cda 8722788 nsf pyi grant ccr8657529 california micro program sun microsystems provide data rate guarantees cmfs addresses following interrelated issues realtime semantics cmfs client interface described section 2 flexible welldefined realtime semantics disk layout section 4 gives cmfs assumptions disk layout acceptance test section 5 describes cmfs determines new session accommodated alternative policies ordering disk read write operations discussed sections 6 7 several broad classes cm data servers envisioned workstation file systems handle voice mail messages well data networkaccessible archives data resources lectures hypermedia documents etc research education advent bisdn networks commercial information services offering movies news music hundreds thousands concurrent clients highlevel issues security naming indexing file structuring differ among classes deal issues however common need store retrieve data streams predictable realtime performance thus concepts techniques cmfs apply class cmfs meant serve part distributed system handles integrated audio video endtoend performance guarantees cannot course achieved disk scheduling alone cmfs conforms metascheduling model 2 provides mechanism making guarantees role cmfs larger context discussed section 3 2 client interface cmfs clients access realtime files sessions session fifo buffer data transfer client cmfs concreteness assume cmfs part os ker nel client kernel process fifos circular buffers physical memory alternatives discussed section 31 21 semantics sessions flow data session necessarily smooth periodic instead session semantics defined terms logical clock runs fixed rate fifo stopping catches clients position cmfs promises stay ahead logical clock given positive amount cushion semantics allow cmfs handle variablerate files nonuniform access simple way cmfs guided client behavior need know data timestamps file internals session created using int direction read write fileid name int offset fifo buffer time cushion int rate direction read requestsession requests session given file read sequentially starting given offset henceforth assumed zero session cannot accepted error code returned otherwise session established id returned startclock starts sessions logical clock client remove cushion amount data calling appropriate value cushion depends clients maximum delay handling data see section 32 client notified via rpc exception end file reached cmfs provides seek operation flushes data currently fifo repositions read write point describe semantics read sessions formally use following notation see figure 1a r rate argument requestsession cushion argument requestsession start time startclock called index next byte put fifo cmfs time index next byte removed fifo client time value logical clock time size fifo buffer bytes logical clock c zero increases rate r whenever following read session axioms must hold start 1 2 client cmfs read b write session offset file zero stop clock read session offset file cmfs client read zero stop clock figure 1 semantics read write sessions described terms put pointer logical clock c shaded rectangles represent data fifo conditions say cmfs overflow fifo cmfs allows client read ahead logical clock bytes client read beyond write point cmfs therefore provides guaranteed minimum data rate long client keeps reading upper bound actual data rate client cmfs principle work arbitrarily far ahead logical clock write session client transfers data fifo buffer cmfs moves data buffer disk describe semantics write sessions using notation case p index next byte inserted fifo client g index next byte removed cmfs logical clock c increases rate r whenever following write session axioms must hold start see figure conditions say client overflow fifo cmfs removes data fifo fast enough client always write ahead logical clock least cmfs read beyond write point 22 file creation nonrealtime access cmfs supports realtime nonrealtime files realtime file created using createrealtimefile boolean expandable int size int maxrate expandable indicates whether file dynamically expanded size gives fixed size maxrate maximum data rate bytes per second file read written cmfs rejects creation request lacks disk space maxrate high nonrealtime operations may performed either type file cmfs provides two nonrealtime service classes interactive background interactive access optimized fast response background high throughput performance guarantees nonrealtime operations 23 symmetry reading writing describing session acceptance scheduling algorithms redundancy treating read write sessions separately avoided observing following symmetry reading writing suppose write session w fixed parameters start b r timevarying parameters consider imaginary read session r start b r parameters see figure 2 disk block written cmfs w advances p w thus corresponds disk block read cmfs r file byte offset cmfs read client write write session client read cmfs write equivalent read session figure 2 interchanging emptyfull readwrite write session transformed read session b equivalent respect scheduling claim 1 suppose w write session r defined c r start r satisfies read session axioms eqs 1 2 w satisfies write session axioms eqs 4 5 6 proof g substituted definition c w result defines c r thus logical clock advances r exactly advances w rate equivalence read write axioms follows substituting eqs 7 8 eqs 1 2 point view scheduling cmfs reading writing essentially equivalent main difference initial condition empty buffer write session corresponds full buffer read session describing cmfss algorithms scheduling session acceptance refer read sessions 24 using cmfs interface idealized client might read 1 byte fifo every 1r seconds beginning moment session acceptance general however uniformity neither necessary desirable example 1 data may grouped large chunks example video frames needed single moment 2 data may longterm rate variation perhaps variablerate compression clients may delay initial io synchronize multiple sessions clients may pause resume io sessions 5 clients may work ahead filling intermediate buffers improve overall performance cmfs interface accommodates requirements show start defining notion temporal data variable bounded rate file f parameters r e th byte f timestamp j see figure 3 words amount data time interval length digital video file example r maximum longterm data rate e maximum number bytes per frame timestamps may explicit embedded data implicit suppose client reads boundedrate file f say file read real time starting 0 buffer size n 1 byte read ie removed fifo 2 time n bytes intuitively means client reads file fast enough get data time slow enough n bytes additional buffer space needed cmfs interface allows client read boundedrate file real time using limited buffer space 2 suppose client creates session reading boundedrate file f parameters r e session begins time 0 possible client read f real time starting e r buffer size e proof given appendix implicit flow control provided cmfs interface accomplish goals well client pause session simply stopping removal data fifo logical clock stop soon thereafter data rate bufferrequirement guarantees remain valid client resumes reading pauseresume equivalent shifting timestamps remaining data byte offset data timestamp 30kb 50kb 333 666 1333 figure 3 boundedrate file contains timestamped data example represents file framessecond video data varying number bytes per frame frame shown vertical bar file parameters r e number bytes timestamps interval length cannot exceed tr suppose client plays several files transmitted via network connections different cmfs servers synchrony single workstation io server workstation handles synchronization begins output sufficient data received connection done example acme server 3 cmfs handles case client intervention logical clocks pause initial synchronization period resume thereafter client hardware fast enough read arbitrarily far ahead logical clock workahead data buffered distributed applications buffers may spread across many nodes protecting playback glitches allowing improved system response transient workload 3 system integration issues 31 implementation alternatives implementation cmfs runs userlevel process unix accesses scsi disk via unix raw disk interface communicates clients via tcp connections architectures however possible see figure 4 example cmfs could implemented either kernel user level client control interface could provided either system calls local clients remote procedure call client data interface mechanism data removed read sessions fifo take several forms general approach data sent flowcontrolled network connection established part requestsession call data removed fifo whenever protocol allows client userlevel process machine cmfs fifo could sharedmemory buffer memorymapped stream 6 finally data consumed io device machine cmfs fifo might reside kernel memory accessed directly io device interrupt handler alternatives different performance implications example kernellevel implementation might lower cpu scheduling overhead work could done interrupt level improved control physical memory however issues addressed cmfs disk scheduling buffer allocation etc apply regardless alternative chosen 32 endtoend scheduling typical applications cm data handled many shared hardware resources disk cpu network bus memory etc provide applications deterministic endtoend perfor mance must integrate scheduling resources cmfs designed serve part metascheduling scheme cmresource model 2 scheme resource reserved sessions fixed workload delay bounds parameterization workload delay lets resources work ahead realtime streams response quickly nonrealtime workload cmfs sessions cushion parameter allows adjacent resource typically cpu looser delay bounds example suppose client runs host cmfs figure 4c cpu processing data sending next resource say net work client determines upper bound cpu time per unit data requires reserves session cpu resource session delay bound say easy show following 3 suppose situation client successfully creates cmfs session cushion starts session processed amount data say time 0 thereafter processes data without voluntarily pausing times 0 client processed least rt bytes data r session data rate control data system calls client c io device audiovideo fifo cmfs fifo client cmfs client fifo client cmfs rpc data fifo cmfs system calls calls system kernel user figure 4 cmfs prototype userlevel process communicates clients network connections alternatively could implemented os kernel client data access system calls b memorymapped streams c device interrupts note would hold cushion less cpu delay bound would possible logical clock stop claim 3 generalized boundedrate files provides useful version claim 2 makes unrealistic assumption client cpu processing instantaneous scheduled precise instants 4 disk layout assumptions assume cmfs uses singlespindle disk drive disk operations done sequentially disk read written blocks fixed size multiple hardware sector size cmfs reservation scheduling algorithms mandate particular disk lay instead assume layout allows following bounding functions u f v f obtained 1 given file f u f n upper bound time read n logically contiguous blocks f including seek rotation time independent position disk head starting block number read upper bound time needed read n blocks file f starting block bounds need tight slackness bounds may however cause sessions rejected unnecessarily functions u v take account sector interleaving interrupthandling latency cpu time used cmfs features track buffering disk con troller bad sectors detected disk initialized 41 examples disk layouts cmfs prototype uses contiguous allocation file begins point within cylinder filling remainder cylinder zero adjacent cylinders part final cylinder number sectors per block fixed parameter ignoring cpu overhead factors bounds functions layout easy derive assume l seekmin l seekmax bounds 1track seek time worstcase seek time respectively l block time read one block l rotation rotation time n number blocks per cylinder assume controller trackbuffering reads track local buffer immediately seeking hence entire track read rotational latency negligible regardless order sectors read possible bounds functions rotation l rotation k number cylinders storing n blocks f starting offset j number blocks f first last cylinders account cpu overhead would necessary leave gap blocks perhaps interleaving modify u v accordingly contiguous layout policy feasible readonly file systems disk space abun dant flexibility variant 42bsd unix file system layout 8 could used realtime file might consist clusters n contiguous blocks every sequence k clusters constrained single cylinder group n k perfile parameters related maxrate parameter file bounds functions u v computed n k size cylinder group disk parameters overhead reading writing allocation map index blocks allocation compaction strategies would pose complex set issues discuss 5 acceptance test cmfs accept new session data rate requirements together existing sessions guaranteed sufficient condition existence static schedule cyclically reads fixed numbers blocks session satisfying rate requirements session worstcase assumptions enough buffer space available section give algorithm deciding whether schedule exists algorithm constructs shortest schedule minimal static schedule also plays important role dynamic scheduling see section 6 51 properties static schedules suppose sessions 1 n read files f 1 f n rates r 1 r n operation set f assigns positive integer cmfs performs operation set seeking next block file f reading blocks file every session order operations specified section 4 upper bounds elapsed time operation f whole respectively data read f sustains session period r block size bytes denote period f f period data read f sustains sessions data read f lasts longer worstcase time takes perform f call workaheadaugmenting set holds l f f equivalently amount data read session operation set f fits corresponding fifo say f feasible holds size fifo buffer used cushion parameter section 21 inequality reflects worst case fractional block already buffered client used none cushion operation sequence f pair p f p permutation 1 n f operation set cmfs performs operation sequence operations f order pn f called workaheadaugmenting f workaheadaugmenting likewise f feasible f feasible duration data buffered session beyond clients cushion given r parameters call workahead denote w say starves w becomes negative file system state w time vector w 1 w n let f operation sequence suppose enough data buffered f performed immediately session starves operation completed say state safe relative f holds j recall l j worstcase time needed j operation following two claims show cmfs accept set session feasible workaheadaugmenting sequence order p important simplicity assume identity permutation 4 f workaheadaugmenting feasible system state safe relative f proof let w state buffers full j r r w safe relative f final three steps use eqs 13 12 11 5 suppose feasible workaheadaugmenting operation sequence f assume time 0 state w safe relative f cmfs satisfy read session axioms eqs 1 2 0 proof prove defining disk scheduling policy called static policy satisfies axioms policy follows repeatedly apply schedule given f following exception point starting block read immediately skip next session since reading block could cause buffer overflow clear policy preserves eq 1 consider particular session k one cycle f starting time 5 let denote time k operation ends eq 2 holds 0 since c advances r bytessecond operation k either reads full amount truncated either case since f workaheadaugmenting let e denote time cycle ends combining eq 14 eq 15 clock rate bound r see w k remains positive therefore starvation occurs cycle eq 16 state w end cycle remains safe relative f hence static scheduling policy maintains read session axioms sessions 52 minimal feasible shows cmfs satisfy data rates set sessions feasible describe algorithm compute minimal feasible f feasible l f least clearly minimal feasible exists feasible exists suppose sessions 1 n given let duration one block data set numbers form kd k 0 0 operation figure 5 diagram proof claim 5 showing workahead w k session k one cycle static scheduling policy start cycle k enough workahead last time operation finished amount data read suffices least l f exceeds length e cycle therefore w k always positive ie k never starves see figure 6 let denote interval 1 let f denote operation set note f 1 differs f addition 1 block sessions whose data periods divide hence sequence f easy compute note also operation set f l f l f proof sequence f f must read least blocks session 7 feasible f f f feasible proof f must read least many blocks session f therefore since f feasible f 8 following algorithm computes minimal minimal operation set f 0 2 f infeasible ie allocation b n buffer space client fifos feasible minimal feasible go 2 proof suppose algorithm stops step 3 returning j let f minimal let f possible j since f feasible claim workaheadaugmenting algorithm would terminated iteration also 0 figure block data session duration depends data rate set multiples periods defines set intervals within interval unique minimallength operation set f enumerating f find minimal feasible possible j since l f l f contradicting minimality l f therefore claim 6 must l f minimal finally suppose algorithm terminates step 2 suppose feasible exists f j arguments j f reads least many blocks session f buffer allocation feasible f feasible f contradiction 53 buffer space allotment suppose fixed amount b buffer space available cmfs client fifos space divided among various clients cmfs performs best sessions work ahead time see section 7 words buffer space allocated session beyond needed clients cushion roughly proportional data rate r cmfs therefore uses following policy let r session j allocated bytes allocation rounded needed multiple memoryallocation block size 6 disk scheduling policy completion disk block io cmfs decides disk block read write next issues appropriate command seek read write disk device driver algorithm decision constitutes disk scheduling policy policy must prevent starvation current sessions must delay return requestsession call newly accepted session safe also handle nonrealtime workload efficiently policies realtime cpu scheduling earliestdeadlinefirst 7 immediately relevant seeks section describe several possible disk scheduling policies policies defined terms slack time define 61 slack time particular time enough data buffered sessions cmfs free non realtime operations workahead realtime sessions amount slack time denoted h computed follows suppose minimal f takes worstcase time permutation 1 n let f operation sequence p f f performed immediately workahead session j fall called slack time session j cmfs safely defer starting f period min 9 let p ordering sessions increasing value workahead w among permutations p p gives maximal value h proof consider permutation p w increasing particular suppose denote slack times two sessions reverse order two sessions p new slack times e c c e see figure 7 slack times sessions remain unchanged hence minimum slack times decreased reversing order therefore consider increasingworkahead ordering p sessions let f denote p denote corresponding slack times particular moment important note h 0 imply starvation occurred occur h based pessimistic assumption interfile seek needed prior every operation example h 0 multiblock file operation cmfs compelled finish current operation starting new would incur interfile seek 62 realtime scheduling policies describe several possible disk scheduling policies policies avoid starva tion relative performance discussed section 7 1 staticminimal policy special case static policy described section 5 simply repeats minimal 2 greedy policy longest possible read session iteration computes slack time h finds session smallest workahead reads blocks period h words devotes entire slack time reading ahead 3 cyclical plan policy differs greedy tries distribute current slack time among sessions way maximizes future slack time augments minimal f h seconds additional reads reads done session immediately read f policy distributes workahead identifying bottleneck session h smallest schedules extra block updating h h repeated h exhausted resulting time figure 7 slack time maximized ordering sessions increasing workahead suppose sequence two sessions j order bold lines represent worka heads w slack times b c shown denotes maximum time needed operations preceding time bound operation session reversing order two sessions slack times e simple algebra shows c global slack time minimum session slack times result follows schedule determines number blocks read leastworkahead session read completes procedure repeated greedy cyclical plan policies leastworkahead session serviced immediately therefore value h used policies computed minimum slack times sessions except leastworkahead session yielding aggressive versions policy policies skip next session buffer size limit reached point buffers full operation done client subsequently removes sufficient data fifo policy restarted greedy staticminimal low cpu overhead prototype 15 mips workstation three sessions use 200 microseconds per scheduling decision cyclical plan builds schedule one block time uses cpu time proportional buffer space transition sessions limits utility 63 nonrealtime operations nonrealtime operation n worstcase latency l safely started l h ever policy servicing nonrealtime operations whenever safe may tend low forces scheduler short realtime operations close minimal causing system run inefficiently may preferable nonrealtime operations h exceeds nonzero threshold avoid seek overhead rapidly alternating realtime nonrealtime operations cmfs uses following slack time hysteresis policy nonrealtime workload interactive operation started whenever h h 2 initially interactive operations started h h 1 however h falls h 1 interactive operations started h exceeds h 2 similarly background operations done within hysteresis interval h operation started interactive operation eligible start section 7 examine effects hysteresis hysteresis parameters system performance 64 session startup newlyaccepted session said start requestsession call returns must occur system state safe respect new special mechanism needed handling startup phase suppose sessions 1 n currently active session n 1 accepted yet started let f n f n 1 denote feasible wass sets 1 n 1 n 1 respec tively n 1 started follows cmfs adjusts fifo buffer sizes according procedure described section 53 shrink buffer discarding data end fifo needed must later reread data disk scheduler goes startup mode policies changed follows 1 nonrealtime operations queued later execution 2 scheduling purposes slack time h computed relative f n however cyclical plan policy allocation slack time workahead done relative f n 1 using session ordering new session appears first however io n 1 done phase 3 system state safe respect f n 1 read f n 1 n 1 blocks n 1 started read completed system state safe n 1 sessions call n 1 allowed return f n 1 becomes systems system leaves startup mode step 3 omitted write sessions equivalent read session starts full buffer section 23 7 performance section study effects disk scheduling policies hardware parameters cmfs performance study uses simulation chose use real io version cmfs scheduling vagaries unix poor performance scsi disk io restriction available disk wrote cmfs prototype disk io operations optionally simulated rather performed simulator keeps track disk head radial rotational position models latencies realistically actions eg cpu execution modeled instantane ous unless otherwise stated simulations use cyclical plan policy assume disk 118 mbps transfer rate 39 ms worst case seek time block size 512 bytes 71 number concurrent sessions figure 8 shows maximum number concurrent sessions accepted cmfs function total buffer space shown two different session data rates 64 kbps 14 mbps graph curves given three different disk types 39 ms maximum seek time 118 mbps transfer rate cdc wren v 35 ms maximum seek time 86 mbps transfer rate cdc wren iii 180 ms maximum seek time 52 mbps transfer rate sony 525 optical disk disk transfer rate imposes upper bound number concurrent sessions accepted unbounded buffer space needed limit approached reach 90 limit wren v disk requires 4 mb 14 mbps sessions 85 mb 64 kbps ses sions efficiency depends length operations minimal 64 kbps sessions require proportionally longer therefore buffer space number accepted sessions fixed disk higher seek time needs longer minimal therefore buffer space 72 performance disk scheduling policies since nonrealtime operations done enough slack time important criterion disk scheduling policies quickly increase slack time study simulated cmfs three concurrent 14 mbps sessions nonrealtime traffic 8 mb system buffer size results figure see cyclical plan performs slightly better greedy slack low greedy quickly catches staticminimal cannot long operations performs much worse higher slack levels appropriate hysteresis values cmfs maintains moderate slack levels steadystate operation thus dynamic policies preferable 73 response time interactive traffic study effect realtime traffic interactive traffic simulated fixed number sessions together interactive requests read randomly positioned blocks disk interactive request arrival poisson mean arrival rate l define response time interactive request time arrival start disk operation delay operation including seek included effect hysteresis parameters noticeable heavy load otherwise slack remains high hysteresis exercised figure 10 plots mean interactive response time 52 mbps 180 ms 86 mbps 35 ms ms 52 mbps 180 ms 86 mbps 35 ms ms number sessions8464 kbps number sessions15050 100b 10kb 1mb 100mb 10gb 10kb 1mb 100mb buffer space buffer space 14 mbps figure 8 number sessions accepted cmfs depends available buffer space disk transfer rate imposes upper limit number sessions reach 90 limit 118 mbps disk requires 4 mb buffer space 14 mbps sessions 85 mb 64 kbps sessions figure 9 disk scheduling policies build slack different rates aggressive cyclical plan solid line aggressive greedy dotted staticminimal dashed policies shown nonaggressive versions shown performed slightly worse h 2 different values h 1 heavy load observe fixed h 1 increasing h 2 interactive response time drops steeply rises gra dually h 1 nearly equals h 2 interactive response poor system switches rapidly realtime nonrealtime operations causing high seek head h 2 increases oscillation becomes less frequent response improves since interactive requests queued slack builds h 1 h 2 response degrades h 2 increased past certain point h 1 response best h 2 h 1 05 seconds h 1 small eg 01 sec figure 10 slack builds slowly h 1 h 2 response poor similar effect observed h 2 exceeds 095hmax h max denotes upper bound h imposed buffer space since difficult fill buffers simultaneously 5000300010002509interactive response time milliseconds upper hysteresis limit seconds lower lower lower lower figure 10 effect hysteresis limits h 1 h 2 mean response time non realtime requests interactive class experiment conducted 2 mb total buffer h max 34 seconds 20 interactive arrivals per second three 14 mbps sessions based observations reasonable rule thumb values h figure plots mean interactive response time function arrival rate different values system buffer size interactive arrival rate low system slack stays near h ure 12 interactive requests serviced without waiting realtime traffic higher arrival rates figure 11 5 per second 500 kb case 10 per second 1 mb interactive response degrades slack sometimes reaches lower hysteresis limit h 1 interactive requests blocked slack reaches h 2 74 throughput background traffic estimate effect realtime traffic background traffic throughput simulated three 14 mbps sessions single background task sequentially reads long contiguouslyallocated file define background throughput fraction fraction residual disk bandwidth ie disk bandwidth taken realtime sessions used background task reasons discussed section 73 low h b 1 small close h max h small case since throughput rather response time goal penalty h large found maximized plots hysteresis limits buffer space analytical approximation mean response time mean arrival rate per second figure 11 mean interactive response time function arrival rate different values total buffer space experiment four concurrent 14 mbps sessions hysteresis limits 004 008 035 065 used 500 kb 1 mb cases respectively infinite buffer curve obtained analytically modeling file system mg1 queue time seconds302010002515520 arrivalssecond arrivalssecond slack time seconds figure 12 variation slack time h presence interactive nonrealtime traffic three 14 mbps sessions start time zero system 2mb buffer space h max 34 seconds hysteresis limits h 20 interactive arrival rate low per second case h stays near h max high arrival rates 20 per second h oscillates hysteresis limits fraction background throughput095085075 100kb 1mb 10mb 100mb total buffer space figure 13 background throughput function total buffer space realtime workload three 14 mbps sessions buffer space increases h longer periods background io hence less seek overhead 75 session startup time write sessions usually started immediately see section 23 study startup time read sessions ran simulation requests six sessions arrive time zero figure 14 shows start times sessions difference successive start times increase workaheads existing sessions increased accommodate new minimal becomes longer sessions added startup times order one second similar startup time consumer vcr however large applications require instantaneous response interactive musical performance using sounds stored disk problem solved storing initial segment sound file memory 8 related work structural issues multimedia files sharing parallel composition annotations etc addressed xerox etherphone system 14 sun multimedia file system 13 northwestern network sound system 12 projects concentrate performance scheduling issues systems cannot make performance guarantees projects addressed performance without hard guarantees abbott gives qualitative discussion disk scheduling playback multiple audio tracks 1 compares balanced policy readahead divided among sessions shortestseekfirst pol icy analysis however provide acceptance test performance guarantees park english 9 describe system supporting single channel audio playback non realtime traffic may concurrently access disk causing available disk bandwidth change 075225session number start time figure 14 six 14 mpbs session requests arrive simultaneously time zero actual start times staggered shown alternative disk bandwidth reservation audio channel propose changing data rate channel dynamically accommodate nonrealtime workload high data rate chosen workahead stream fixed threshold strategy guarantee minimum data rate yu et al 15 discuss layout interleaved data streams different data rates compact disk guaranteedperformance playback assumptions single session fixed rates small buffers nonrealtime traffic restrictive gemmell christodoulakis 5 describe file system supporting multiple audio channel playback concurrent nonrealtime traffic like cmfs work provides basis hard performance guarantees however differs cmfs several respects channels must constant data rate must start time scheduling policy static system repeatedly applies single feasible audio channels reserves time operation sequence service nonrealtime traffic nonrealtime traffic static policy may perform worse cmfs 1 cmfs interrupt allowing nonrealtime traffic start immediately 2 cmfs use accumulated system slack handle long bursts nonrealtime traffic rangan vin 11 describe system combines disk input displaydevice output multiple data streams give expressions admission control assumption streams equal data rates disk scheduling policy similar staticminimum 9 conclusion continuous media file system cmfs provides guaranteedperformance read sessions several sessions coexist nonrealtime workload single disk central ideas cmfs include following semantics cmfs session interface supports range client requirements including variablerate data starting stopping synchronization multiple streams client workahead semantics defined rigorously section 21 include provides flexibility client cpu scheduling layout cmfs requires bounds functions u v obtained section 4 mandate particular disk layout session acceptance decide session request accepted cmfs checks feasible section 52 exists disk scheduling found dynamic policies greedy cyclical plan performed better staticminimal policy concurrent nonrealtime access cmfs handles nonrealtime well realtime file access disk space dynamically used either purpose cmfs uses slack time hysteresis policy scheduling nonrealtime access appropriate parameters policy allows long nonrealtime operations complete without interruption 91 refinements future work following observations suggest possible improvements cmfs first session graph workahead w function time roughly sawtooth function consider two sessions 1 2 opposite phases scheduling cycle generally less maxw share buffer space possibly improving nonrealtime performance increasing number sessions accepted second scheduling policy could take disk head position account various ways example could yield session ordering efficient smallestworkaheadfirst section 61 similarly use policy scan 4 ordering nonrealtime operations could improve performance although presented cmfs algorithms context singlespindle disk drive equally applicable disk array files striped across multiple disks 10 clientlevel session could composed sessions multiple disks disk reserved scheduled described could used provide sessions data rates higher underlying disk drives could improve loadbalancing availability even sessions data rates lower individual disks acknowledgements discussions vassilios polimenis george homsy mark moran contributed cmfs design r efficient editing digital sound disk metascheduling distributed continuous media continuous media io server synchronization mechanism effects scheduling file memory operations principles delaysensitive multimedia data storage retrieval scheduling ipc mechanisms continuous media scheduling algorithms multiprogramming hard realtime environment fast file system unix variable rate strategy retrieving audio data secondary storage case redundant arrays inexpensive disks raid designing file systems digital audio video network sound system unix multimedia file system managing stored voice etherphone system efficient placement audio data optical disks realtime applications tr fast file system unix managing stored voice etherphone system case redundant arrays inexpensive disks raid efficient placement audio data optical disks realtime applications scheduling ipc mechanisms continuous media designing file systems digital video audio continuous media io server synchronization mechanism variable rate strategy retrieving audio data secondary storage principles delaysensitive multimedia data storage retrieval scheduling algorithms multiprogramming hardrealtime environment metascheduling distributed continuous media ctr james gemmell harrick vin dilip kandlur p venkat rangan lawrence rowe multimedia storage servers tutorial computer v28 n5 p4049 may 1995 tat seng chua cheng hian goh beng chin ooi kianlee tan replication strategy reducing wait time videoondemand systems multimedia tools applications v15 n1 p3958 september 2001 simon shim taisheng chang david h c du jenwei hsieh yuewei wang performance scalable multimedia server sharedstorage clusters multimedia tools applications v18 n1 p3154 september 2002 ravi jain john werth j c browne introduction special issue inputoutput parallel computer systems acm sigarch computer architecture news v21 n5 p56 dec 1993 raymond ng jinhai yang maximizing buffer disk utilizations news ondemand proceedings 20th international conference large data bases p451462 september 1215 1994 jenwen ding yuehmin huang resourcebased striping efficient striping strategy video servers using heterogeneous disksubsystems multimedia tools applications v19 n1 p2919 january stephen childs filing system interfaces support distributed multimedia applications proceedings 8th acm sigops european workshop support composing distributed applications p162169 september 1998 sintra portugal yuehmin huang jenwen ding shiaoli tsao constant time permutation efficient block allocation strategy variablebitrate continuous media data vldb journal international journal large data bases v8 n1 p4454 april 1999 raymond ng paul shum optimal clip ordering multiclip queries vldb journal international journal large data bases v7 n4 p239252 december 1998 hiroshi tezuka tatsuo nakajima simple continuous media storage server realtime mach proceedings annual technical conference usenix 1996 annual technical conference p88 january 2226 1996 san diego ca dwight makaroff gerald neufeld norman hutchinson evaluation vbr disk admission algorithms continuous media file servers proceedings fifth acm international conference multimedia p143154 november 0913 1997 seattle washington united states silvano maffeis design implementation configurable mixedmedia file system acm sigops operating systems review v28 n4 p410 oct 1994 huang hungming ho pinned demand paging based access frequency video files video servers journal systems software v78 n3 p223233 december 2005 philip kwok chung tse clement h c leung improving multimedia systems performance using constantdensity recording disks multimedia systems v8 n1 p4756 jan 2000 divyesh jadav alok choudhary p bruce berra evaluation design tradeoffs highperformance mediaondemand server multimedia systems v5 n1 p5368 jan 1997 prashant j shenoy harrick vin efficient support interactive operations multiresolution video servers multimedia systems v7 n3 p241253 may 1999 babak hamidzadeh tsunping j prioritized admission strategies improve userperceived performance interactive vod servers multimedia tools applications v13 n1 p534 january 2001 jonathan chienliang liu david h c du simon shim jenwei hsieh mengjou lin design evaluation generic software architecture ondemand video servers ieee transactions knowledge data engineering v11 n3 p406424 may 1999 rajesh krishnan dinesh venkatesh thomas c little failure overload tolerance mechanism continuous media servers proceedings fifth acm international conference multimedia p131142 november 0913 1997 seattle washington united states ramzi r yehia imad mahgoub storage system multimedia classification extensions distributed parallel databases v7 n4 p429442 oct 1999 tsunping j babak hamidzadeh dynamic realtime scheduling strategies interactive continuous media servers multimedia systems v7 n2 p91106 march 1999 ketil lund vera goebel adaptive disk scheduling multimedia dbms proceedings eleventh acm international conference multimedia november 0208 2003 berkeley ca usa kyungoh lee heon yeom effective admission control mechanism variablebitrate video streams multimedia systems v7 n4 p305311 july 1999 prashant j shenoy harrick vin efficient support scan operations video servers proceedings third acm international conference multimedia p131140 november 0509 1995 san francisco california united states divyesh jadav alok n choudhary p bruce berra techniques increasing stream capacity highperformance multimedia server ieee transactions knowledge data engineering v11 n2 p284302 march 1999 wonjun lee difu su duminda wijesekera jaideep srivastava deepak kenchammanahosekote mark foresti experimental evaluation pfs continuous media file system proceedings sixth international conference information knowledge management p246253 november 1014 1997 las vegas nevada united states h vin p goyal goyal statistical admission control algorithm multimedia servers proceedings second acm international conference multimedia p3340 october 1520 1994 san francisco california united states jayanata k deysircar james salehi james f kurose towsley providing vcr capabilities largescale video servers proceedings second acm international conference multimedia p2532 october 1520 1994 san francisco california united states asit dan dinkar sitaram online video placement policy based bandwidth space ratio bsr acm sigmod record v24 n2 p376385 may 1995 michael vernick chitra venkatramani tzicker chiueh adventures building stony brook video server proceedings fourth acm international conference multimedia p287295 november 1822 1996 boston massachusetts united states prashant shenoy harrick vin cello disk scheduling framework next generation operating systems realtime systems v22 n12 p948 janmarch 2002 prashant j shenoy harrick vin cello disk scheduling framework next generation operating systems acm sigmetrics performance evaluation review v26 n1 p4455 june 1998 banu zden rajeev rastogi avi silberschatz multimedia support databases proceedings sixteenth acm sigactsigmodsigart symposium principles database systems p111 may 1115 1997 tucson arizona united states weifeng shi shahram ghandeharizadeh trading memory disk bandwidth videoondemand servers proceedings 1998 acm symposium applied computing p505512 february 27march 01 1998 atlanta georgia united states hui guo guobin shen zhiguang wang shipeng li optimized streaming media proxy applications journal network computer applications v30 n1 p265281 january 2007 chenghan tsai edward th chu taiyi huang wrrscan ratebased realtime diskscheduling algorithm proceedings 4th acm international conference embedded software september 2729 2004 pisa italy rodney van meter minxi gao latency management storage systems proceedings 4th conference symposium operating system design implementation p88 october 2225 2000 san diego california l n reddy jim wyllie k b r wijayaratne disk scheduling multimedia io system acm transactions multimedia computing communications applications tomccap v1 n1 p3759 february 2005 deepak r kenchammanahosekote jaideep srivastava io scheduling digital continuous media multimedia systems v5 n4 p213237 july 1997 hsungpin chang rayi chang weikuan shih rueichuan chang gsr global seekoptimizing realtime diskscheduling algorithm journal systems software v80 n2 p198215 february 2007 w g aref kamel ghandeharizadeh disk scheduling video editing systems ieee transactions knowledge data engineering v13 n6 p933950 november 2001 craig freedman david j dewitt spiffi scalable videoondemand system acm sigmod record v24 n2 p352363 may 1995 fabio panzieri marco roccetti synchronization support groupmembership services reliable distributed multimedia applications multimedia systems v5 n1 p122 jan 1997 scheduling data layout policies nearline multimedia storage architecture multimedia systems v5 n5 p310323 sept 1997 dominic mazzoni roger b dannenberg fast data structure diskbased audio editing computer music journal v26 n2 p6276 july 2002 wonjun lee jaideep srivastava bikash sabata qosaware admission control dynamic resource provisioning framework ubiquitous multimedia computing environments journal supercomputing v32 n1 p2550 april 2005 nevzat hurkan balkir gultekin ozsoyoglu delivering presentations multimedia servers vldb journal international journal large data bases v7 n4 p294307 december 1998 rayi chang weikuan shih rueichuan chang realtime disk scheduling multimedia applications withdeadlinemodificationscan scheme realtime systems v19 n2 p149168 sept 2000 banu zden alexandros biliris rajeev rastogi abraham silberschatz lowcost storage server movie demand databases proceedings 20th international conference large data bases p594605 september 1215 1994 nabil j sarhan chita r das caching scheduling nadbased multimedia servers ieee transactions parallel distributed systems v15 n10 p921933 october 2004 david p anderson device reservation audiovideo editing systems acm transactions computer systems tocs v15 n2 p111133 may 1997 murthy devarakonda impact application scale diversity file systems proceedings 6th workshop acm sigops european workshop matching operating systems application needs september 1214 1994 wadern germany banu zden rajeev rastogi avi silberschatz storage retrieval continuous media data proceedings third international conference information knowledge management p322328 november 29december 02 1994 gaithersburg maryland united states xiaoye jiang prasant mohapatra efficient admission control algorithms multimedia servers multimedia systems v7 n4 p294304 july 1999 martha l escobarmolano shahram gandeharizadeh douglas ierardi optimal resource scheduler continuous display structured video objects ieee transactions knowledge data engineering v8 n3 p508511 june 1996 michael k bradshaw bing wang lixin gao jim kurose prashant shenoy towsley subhabrata sen periodic broadcast patching services implementation measurement analysis internet streaming video testbed proceedings ninth acm international conference multimedia september 30october 05 2001 ottawa canada ginkou chiungshien wu meichian liu baoshuh p lin efficient realtime data retrieval scalable multimedia storage proceedings fifth acm international conference multimedia p165172 november 0913 1997 seattle washington united states divyesh jadav alok choudhary designing implementing highperformance mediaondemand servers ieee parallel distributed technology systems technology v3 n2 p2939 june 1995 michael k bradshaw bing wang subhabrata sen lixin gao jim kurose prashant shenoy towsley periodic broadcast patching services implementation measurement analysis internet streaming video testbed multimedia systems v9 n1 p7893 july jason gait optimizing unix database file operations ieee software v11 n3 p4856 may 1994 richard staehli jonathan walpole constrainedlatency storage access computer v26 n3 p4453 march 1993 andreas vogel brigitte kerherv gregor v bochmann jan gecsei distributed multimedia applications quality service survey proceedings 1994 conference centre advanced studies collaborative research p71 october 31november 03 1994 toronto ontario canada
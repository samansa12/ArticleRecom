new tiling techniques improve cache temporal locality tiling wellknown loop transformation improve temporal locality nested loops current compiler algorithms tiling limited loops perfectly nested transformed trivial ways perfect nest paper presents number program transformations enable tiling class nontrivial imperfectlynested loops cache locality improved define program model loops develop compiler algorithms tiling propose adopt oddeven variable duplication break anti output dependences without unduly increasing workingset size adopt speculative execution enable tiling loops may terminate prematurely due eg convergence tests iterative algorithms implemented techniques research compiler panorama initial experiments several benchmark programs performed sgi workstations based mips r5k r10k processors overall transformed programs run faster 9 164 b introduction due widening gap processor memory speed importance efficient use caches widely recognized loop tiling combines stripmining loop interchange wellknown loop transformation used increase work sponsored part national science foundation grants ccr950254 mip9610379 purdue research foundation appear acm sigplan pldi99 copyright c fl1999 association computing machinery inc permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copies bear notice full citation first page intial screen document copyrights components work owned others acm must honored abstracting credit permitted copy otherwise republish post servers redistribute lists requires prior specific permission andor fee request permissions publications dept acm inc fax 1 212 8690481 permissionsacmorg reuse cached data 25 variety loop transformations reversal skewing also proposed enable loop tiling 23 current tiling techniques generally limited perfectlynested loops loop except innermost one perfect nest contains exactly one inner loop next level loop nest contains simple statements two loop headers shown figure 1 transformed perfect nest simply moving statements guarded appropriately inserted conditions inside inner loop 23 assuming inner loop iterates least unfortunately many imperfectlynested loops numerical programs trivial one figure 1 loop may contain several inner loops level example jacobi program kernel shown figure 2a two separate loop nests within outmost loop certain cases techniques peelandfusion 13 transform nontrivial imperfectlynested loops perfectly nested ones may become amenable tiling unfortunately techniques exploit temporal locality within iteration outer loop eg loop jacobi code paper tloop called timestep loop relatively little temporal reuse exploited cached data reused across different time steps current tiling techniques also difficulties premature loop exits caused convergence tests iterative numerical algorithms paper presents number program transformations overcome aforementioned difficulties tiling make two main contributions ffl define class nontrivial imperfectlynested loops present algorithms legally profitably tile separate loops perfectlynested timestep loop case jacobi temporal reuse thus exploited across different time steps ffl present scheme permit tiling loops premature exits speculatively executing iterations timestep loop exit condition tested iterations rollback statements inserted insure correct program results case exit condition turns true techniques introduced paper particularly suitable iterative stencil computations matrix element updated based values neighboring elements computations often performed solving partial differential equations geometric modeling image process ing data dependence information required automate proposed techniques gathered existing compiler analyses implemented proposed techniques within panorama compiler order evaluate effectiveness applied techniques one wellknown numerical computation kernel jacobi two application programs tomcatv swim industrial spec95 benchmarks 20 overall program transformation improves execution speed 9 164 sgi sequential workstations statement statement end statement 3 end statement end end transformation b transformation figure 1 trivial imperfect loop nest transformed perfect loop nest paper consider uniprocessor computer memory hierarchy includes cache memories one levels assume one caches large enough store small number columns considered arrays whole arrays secondary caches typical modern workstations satisfy assumption techniques introduced paper aim improve data reuse caches rest paper organized follows section 2 define class imperfectlynested loops present tiling scheme legally tile loops also present criteria determine whether tiling scheme profitable discuss techniques improve profitability tiling scheme loop preprocessing section 3 present scheme speculative execution allow tiling timestep loop contains premature exits section 4 present experimental results discuss related work section 5 conclude section 6 tiling imperfectlynested loops section first use jacobi example give basic idea tiling scheme imperfectly nested loops define class loops handled scheme present scheme legally tiles imperfectlynested loops criteria determine whether tiling end end end end end jocobi kernel code b stencil illustration jacobi code j2 j2 j2 j2 j2 j2 flow dependence backward direction along j1 j2 flow dependence straight forward direction along j1 j2 antidependence backward direction along j1 j2 antidependence straight forward direction along j1 j2 output dependence backward direction along j1 j2 output dependence straight forward direction along j1 j2 c iteration subspace dependences figure 2 code computation stencil dependences iteration subspace jacobi kernel profitable discuss techniques improve profitability tiling scheme additional loop transformations analyzing complexity compiler algorithms briefly discuss extensions 21 basic idea iterative numerical algorithms array elements usually accessed repeatedly different time steps number array elements large cache overflow requires array elements fetched repeatedly cache every time step using loop tiling work time step finishes execution moves next time step operate array elements recently refer enced avoids cache overflow unfinished time step continue later moment consider jacobi kernel shown figure 2a convergence test removed simplify illustration plot iteration subspace j1 j2 loops shown figure 2c within iteration complete execution j1 j2 loops requires accesses nearly 2 theta n gamma 1 2 distinct array elements sufficiently large n cache overflow resulting cache misses next itera tion avoid overflow partition iteration subspace tiles marked staircase lines figure 2c executed order topleft bottomright properly chosen tile size make number memory locations accessed tile fit cache reordered execution sequence legal satisfies original data dependences figure 2b shows jacobis computation stencil figure 2c shows subset data dependences edges iteration points indicate flow anti output dependences adopt valuebased definition flow dependences 25 flow dependence exists statement s1 statement s2 latter may use value written former adopt traditional definitions anti output dependences 11 antidependence exists s1 s2 former read memory location overwritten latter output dependence exists s1 s2 s2 may overwrite memory written s1 one similarly define dependences two variable references two loop iterations two program segments 25 key scheme tiling imperfectlynested loops find uniform tile slope flow dependences carried satisfied find offset tiled inner loop flow dependences within also satisfied tile shape result guarantees flow dependences exist laterexecuted tile earlierexecuted tile anti output dependences exist laterexecuted tiles earlierexecuted ones eliminated technique called oddeven duplication arrays unlike full array expan sion oddeven duplication unduly increase workingset size defeats locality figure 2c edge node n1 n2 drawn solid j loop index value n1 greater drawn dotted otherwise j stands either j1 j2 solid edges affect legal tile shape one see solid flow dependence edge within tile solid antidependence edge may cross two neighboring tiles however shown section 23 latter removed oddeven duplication exist solid output dependence edges jacobi 22 class imperfectlynested loops general program model presented figure 3a loop body contains jloops 1 j loop may contain arbitrary program constructs without loss generality loops assumed step 1 require loop j take form lower upper bounds respectively l u invariants b nonnegative known constant make presentation clean itmax assumed even number require read reference gets value either always iteration end end end modt 2eq1 end end end end end end program model b oddeven array duplication modt 2eq1 end end end end end end end c tiling figure 3 steps tiling imperfect loop nest always previous iteration hence flow dependence distance either 0 1 loop level commonly true applications focus use iterative algorithms existing compiler techniques array privatization determine whether condition flow dependences satisfied see 5 list references jacobi code figure 2 read references always get values previous iteration except gives distance 1 read references l always get values iteration making distance 0 figure 3a assume b always gets value previous iteration simplicity exposition paper consider tiling j loops 1 even though may contain inner loops techniques proposed however extended include loops within j loops briefly discussed section 26 tth iteration potential reuse slope t1th iteration loop ji loop ji figure 4 portion tile illustrate reuse 23 algorithm tiling imperfect loop nest given loop nest program model goal transform form shown figure 3c terms 23 jj called tile controlling loop j tiled loops conve nience call loop timestep loop j loops tiled size nstep terms figure 2c nstep number grid points tile j1j2 direction slope number grid points tile shifts left tindex increases 1 figure 4 illustrates two instances loop j shows shape portion tile potential temporal reuse across iterations proportional value nstep gamma slope figure 5 shows main steps tiling tech nique rest subsection present compiler algorithms implement steps 231 constructing subgraph minimum legal slope constrained data dependence distances exist extensive studies problem computing data dependence distance pair array references respect common enclosing loops 25 distance constant symbolic analysis performed derive bounds distance values 3 16 7 current literatures dependence distances usually defined respect loops contain dependent references program model would apply loop slightly extend definition also include j loops program model suppose exists dependence iteration 1 j 1 iteration k say dependence distance vector specifically say distance respect j loops j 2 negative say exists backward dependence wrt j existing works distancecomputing cited readily used compute lower bound upper bound distances defined references different j loops construct dependence subgraph 11 loop nest node represents statement within one j loops edge represents flow anti output dependence multiple edges may exist one node another edge marked ffl construct dependence subgraph ffl calculate minimum slope ffl select maximum legal tile size test profitability ffl perform array duplication ffl generate tiled code figure 5 main steps tile loop nest distance vector dt dj dt distance wrt dj lower bound estimated possible negative distances wrt j loops dt values grouped three classes 0 1 value greater 1 differentiate different dt values greater 1 denote g1 equally recall program model flow dependence distance respect loop 0 1 hence possible anti output dependences distance wrt j cannot negative let dj 0 jacobi example figure 2 dependence subgraph shown figure 6a s1 statement computes l s2 one computes easy illustration figure 6a draw one edge represent type data dependences flow anti output one vertex another marking possible dependence distance vectors since loop iterations must executed lexicographical order flow dependence edge dependence subgraph whose vertices must distance vector 0 0 1 dj anti output dependence edge must distance vector 0 0 1 dj g1 dj group anti output dependence edges source target dj value delete one edge minimum dt value tile shape determined remaining dependence edges also satisfy deleted ones furthermore condense nodes dependence subgraph belong j loop single node resulting new graph defined simplified graph filters dependence information unimportant tiling scheme thus improving efficiency graph traversal technique definition 2 jloop distance subgraph g l graph derived dependence subgraph gd given loop nest conforms program model 1 node j g l represents j loop given loop nest 2 flow dependence edge gd distance vector dt dj n1 loop j i1 n2 loop j i2 j i1 j i2 different nodes g l add edge g l j i1 j i2 distance vector dt dj otherwise j i1 j i2 dt j2 b antidependence flow dependence dependence figure dependence jloop distance subgraphs jacobi equal 1 add edge j i1 j i2 distance vector dt dj 3 every two nodes n1 gd exist anti dependences n1 n1 loop j i1 n2 loop j i2 consider antidependence edges n1 group antidependence edges edges belonging group dj value b group take minimum dt value denoted mindt add edge j i1 j i2 distance vector mindt 4 process output dependences gd way step 3note step 3b g l instead mindt dj although treatment potentially produce overconservative tile shape expect cases jacobis dependence distance subgraph figure 6a jloop distance subgraph derived shown figure 6b 232 calculating minimum slope following algorithms perform loop tiling based jloop distance subgraph first algorithm computes minimum legal tiling slope slope offsets j loop bounds within tile algorithm 1 compute minimum legal tiling slope offsets input loop nest conforms program model jloop distance subgraph g l output slope minimum legal slope tiling offset node g l procedure ffl step compute offset every node g l 1 temporarily remove anti output dependence edges edge 1 2 nodes g l without successors 3 nodes g l assigned offset values go 6 otherwise continue 4 4 find node u g l whose successors assigned offset values edge annotated 5 go back 3 6 put edges removed step a1 back g l offsetuju v nodes g l flow dependence edge 1 gfor jacobi code figure 2a step a1 exists one edge j1 j2 distance vector 0 0 initializing offsetj2 0 offsetj1 means need adjust loop bounds either j1 j2 within iteration step b since exist two flow dependence edges j2 j1 233 selecting tile size definition 3 define wsetx maximum working set size single iteration transformed code figure 3c single iteration transformed code loop bounds j depend combination jj wsetx takes maximum working set produced jjt combinations since code yet transformed compilation stage estimate wsetx memcount represents number different memory locations accessed x iterations loop j estimation gives upperbound wsetx memcount estimated array data flow analysis merging array regions accessed j loop body 5 next determine size tile objective maximize tile size order maximize data reuse within tile prevent anti output dependence crossing backward one tile boundary tile wide working set size exceeds effective cache size 22 algorithm 2 profitability test tile size deter mination input loop nest conforms program model jloop distance subgraph g l slope value computed algorithm 1 given cache size cs ff effectivecache factor 1 22 output tile size nstep tiling profitable logical value profitable procedure 1 holds 1 go step 2 otherwise return procedure 2 compute goto step 3 3 nstep slope return procedure otherwise goto step 4 4 let ju v nodes g l u v anti output dependence edge nodes g l u v anti output dependence edge 1g nstep otherwise guarantees overlap iteration points least one j loop adjacent iterations ie holds least one j loop step 2 guarantees working set fit effective cache according figure 4 makes nstep large enough allow potential temporal reuse across iterations step 4 prevents anti output dependence crossing backward one tile boundary jacobis jloop distance subgraph figure 6b exist two anti dependence edges respectively recall offsetj1 exist antidependence edge two output dependence edges 234 array duplication next algorithm determines whether particular anti output dependence needs removed duplication algorithm 3 oddeven duplication input loop nest conforms program model jloop distance subgraph g l data flow upwardexposure information output loop nest oddeven array duplication inserted shown figure 3b procedure theta cs called effective cache size determined various system factors recommended computer vendor based empirical locality measurement chose experiments ffl step every anti output dependence distance vector check see whether need oddeven array dupli cation procedure returns otherwise continue step b ffl step b duplicate loop body insert ifstatement one copy loop body becomes branch copy else branch branch executed odd iterations else branch even iterations respectively ffl step c anti output dependence distance vector condition b step hold identify array say contributes dependence declare copy ffl step assume original array c new copy write reference branch change referenced array name c read reference value odd iteration change c ffl step e insert proper initialization statements new copies arrays regions initialized newly declared array upwardlyexposed entry second iterationin worst case arrays could duplicated jacobis jloop distance subgraph figure 6b antidependence j1 j2 makes necessary duplicate array regions upwardly exposed entry second iteration initial values copied duplicates 235 tiled code generation based calculation slope nstep offsets loop transformation performed algorithm 3 following algorithm calculates loop bounds tiled j loops modified loop new jj loop figure 3c also forms loop body tiled j loop algorithm 4 tiled code generation input 1 jloop distance subgraph g l 2 slope calculated algorithm 1 nstep calculated algorithm 2 3 loop nest updated algorithm 3 form shown figure 3b output tiled loop nest procedure end end end end figure 7 tiled j loop ffl every j loop whose current loop bounds respectively replace whole loop body code segment shown figure 7b offsetj represents original j loop body except loop index variable j replaced k bodyk offsetj loop body replaced code segment shown figure 7a ffl lower bound jj loop tiled loop nest mg upper bound jj loop mg lower bound new loop maxmin fd upper bound new loop c itmaxthe proof correctness algorithm 4 sketched appendix figure 8 shows jacobi code transformed algorithm 4 note since offsetj1 loop body figure 7a applies loop im proved shown figure 9 loop fusion 14 25 forward substitution 2 assuming array l dead exit whole loop nest improvement known techniques discussed details paper 24 techniques improve profitability number compiler techniques applied given loop nest shorten backward dependence distances wrt j loops hence increase profitability present two algorithms paper first one deals problem incompatible j loops take example figure 10a exists flow dependence j2 j1 hence 1 say loops j1 j2 incompatible indices appear different dimensions array hand say loops j1 i2 compatible end end modt 2eq1 end end end end end end end end end end end figure 8 jacobi kernel transformed tiling oddeven duplication modt 2eq1 end end end end end end figure 9 tiled jacobi kernel improved simple loop fusion forward substitution indices appear array dimension loops j2 i2 permuted shown figure 10b flow dependence i2 j1 distance vector 1 0 making loop nest profitable tile similarly loop i1 said compatible loop j2 loop i1 loop j1 permuted shown figure 10c however cacheline spatial locality suffer due columnmajor memory allocation array needs transposed 1 8 order restore spatial locality formal definition compatibility given definition 4 program model figure 3a suppose j loop contains inner loops i1 i2 perfectly nested within j outmost one innermost one denote j i0 compatible set 1tuple 1 c nonnegative integer c appear dimension ardo end end end end end end end end end end end end end end end b c figure 10 example illustrate compatible set rays 3 type equals row column indices appear first second dimension call compatible set rowcompatible column compatible set respectively 2dimensional array rowassociated columnassociated row compatible columncompatible set least one loop index variable ic set appears first second dimension references 2 following algorithm checks see combination array transpose 1 8 loop permutation 25 produce loop nest profitably tiled although exists exponential number possible combinations permutations j loops array transpose small number need considered practice algorithm 5 loop permutation array transpose improve profitability input 1 loop nest lp conforms program model 2 comsets compatible sets lp 3 boolean array outmost allowed 1 array perm1 mg outmost allowed uv indicates whether loop iuv become outmost loop within loop legal permutation outmost allowed legal permutation vectors output transformed loop nest algorithm succeeds restored original loop nest algorithm aborts procedure profitable permutations unlikely exist element cs c1 array transpose arrays rowassociated cs outmost allowed ic perform permutation specified permic applying algorithm return transformed loop nest undo permutation array transpose performed end abort 2 jacobi code figure 2a two compatible sets 0 0 column 1 1 row figure 10a compatible set 01column calls permutation loop i2 loop j2 outmost allowed 21 true compatible set 10row calls transposing array permutation i1 j1 outmost allowed11 true next show known loop transformation called circular loop skewing 25 used enhance profitability tiling technique example suppose code skeleton figure 11a wrapped around computation stencil typical pdes circular boundary conditions iteration subspace shown figure 11b assume within time step 1 jth iteration loop j2 flowdependent j gamma 1th jth j iterations j1 first iteration loop j2 flowdependent first second last iterations j1 3 last iteration loop j2 flowdependent n gamma 1th nth first iterations j1 assume flow dependence j2 j1 distance vector j loops free loopcarried dependences reduce slope 1 follows change j2 iteration order 1 2 also change j1 iteration order 1 2 transformation eliminate backward dependences resulting following algorithm formalizes circular loop skewing cls technique profitability enhancement circularly skews bounds every j loop shorten backward distances calls procedure find cls parameter eliminate backward dependences whose distances less given loop nest lp find cls parameter returns ffi skewing amount every j loop adjacent iterations also marks fi 1 node j jloop distance subgraph g l fi initial skewing amount j algorithm 6 circular loop skewing shorten backward dependences input loop nest lp conforms program model except j loop index form l u invariant jloop distance subgraph g l real cache size cs effective cache size factor ff every loop assumed free loopcarried dependences output transformed loop nest successful procedure calculate csg end end end j2 j2 end end end j2 j2 b c figure 11 sample example transformed algorithm original loop nest skeleton b simplified iteration space graph transformation c transformed loop nest skeleton simplified iteration space graph transformation code procedure find cls parameter presented appendix b j loop assume lower upper loop bounds j l u respectively change loop bounds assignment j beginning j loop body end apply algorithm 2 transformed loop nest return transformed loop nest else abort figure 11c shows transformed code figure 11a applying algorithm 6 figure 11d shows corresponding iteration subspace suppose procedure find cls parameter performs following 1 initialize remove edges l 3 j1 since predecessors nothing 4 j2 increment fi 2 1 backward dependence distance restore edges back g l 6 processing edges 25 complexity analysis construction jloop distance subgraph requires information array dataflow dependence distances worst case requires exponential time compute however practice information obtained efficiently implemented schemes see 5 25 list references algorithm 2 dominated workingset computation requires array region union operations operations simpler constructing jloop distance subgraph given jloop distance subgraph g l v e algorithm 1 takes ojv algorithm 3 finding arrays duplicated needs ojv time renaming references takes time proportional loop body size algorithm 4 takes time multiplied loop body size algorithm 5 theoretically takes loop body size small practice algorithm 6 procedure find cls parameter worstcase time ojv jjej 2 26 discussion techniques extended tile inner loops within j loops take one loop level j example extension j loop perfectly nested inner loop lower bound upper bound u 0 invariant j invariant c known nonnegative constant following changes made previous definitions algorithms needs extended distance vector triple dt dj di instead pair dt dj definition 2 extended edge g l marked new distance vector algorithm 1 computes slopej slopei j loops loops respectively also needs annotate g l offset j offset j loops respectively algorithms 2 computes nstepj nstepi j loops respectively definition 3 extended define wsetxy x nstepj nstepi new algorithm 2 check see whether wsetnstepj fnstep g true increase nstepj max fx j wsetx nstepi ff csg ffl algorithm 3 duplicates condition b true either j algorithm 4 needs generate correct loop bounds ii addition jj j 3 tiling speculative execution numerical programs using iterative methods often exist convergence tests may cause maximum iteration count reached enable tiling algorithms presented present algorithm partition maximum iteration counts end end goto next end end next extended program model chunk plus exit condition iteration end end next b code iteration chunks initialize b execute tiled chunk econdeqtrue go rollback copy aor odd copy c backup copy b accumeqitmax goto next end end go next roolback restore backup copy b execute original loop nest figure 12a next c tiled speculated code figure 12 tiling speculative execution chunks exit condition tested execution chunk iterations instead one iteration tile individual chunks case overshooting iterations execution rolled back speculative code statements must inserted guard potential exceptions overflow dividedbyzero possibility exceptions detected execution rolls back latest checkpoint model defined section 22 hence extended include loop exit test shown figure 12a exit condition reference variables defined either within iteration outside loop source carried flow dependences following algorithm implements idea algorithm 7 tiling speculative execution input loop nest conforms program model shown figure 12a output tiled loop nest procedure ffl step estimate chunk size lmax ffl step b block loop figure 12a chunks size lmax shown figure 12b ffl step c tile chunk using algorithm 4 ffl step transform loop nest one shown figure 12c arrays referenced exit condition renamed similar renaming algorithm 3in transformed code every array source carried flow dependences create backup copy b identical copy initially variable accum accumulates total iterations executed far every iteration outmost loop executing tiled program lmax steps condition rollback checked execution must rollback values stored b restored computation resumes beginning accum1th iteration latest checkpoint otherwise odd copy c copied backup copy b execution reaches itmaxth iteration outmost loop terminates tradeoff overshooting cost checkpointing overhead performance gain tiling reasoned follows let original execution time per time step let flmax speedup per time step due tiling accounts checkpointing overhead amortized lmax time steps assume originally takes steps converge since incur penalty lmax iterations rollback occurs tiling speculation gain performance total currently use formula e equals estimated time steps per tile given tile size nstep future work one certainly experiment formulas instance lmax may vary distinct computation stages section 4 see gain cache temporal reuse outweighs loss due checkpointing overshooting 4 experimental evaluation implemented techniques panorama compiler 5 apply algorithms one wellknown numerical kernel jacobi convergence test two spec95 benchmarks tomcatv swim run two sgi uniprocessor workstations one based mips r5k processor based mips r10k r5k processor 32kb 2way data cache 512kb 2way unified l2 cache r10k processor also 32kb 2way l1 data cache 2mb 2way unified l2 cache moreover mips r10k performs outoforder instruction ex ecution provides data prefetching instructions permits multiple pending cache misses native compiler mipspro f77 compiler experiments original code peelandfused code turn o3 switch enables number loop transformations including interchange fusion fission tiling code generated techniques o2 o3 delivers nearly performance show o2 results original tomcatv swim programs fail profitability test apply algorithms 5 6 two programs taking general steps shown figure 5 algorithm 5 finds tomcatv made profitable tiling loop permutation array transpose algorithm 6 finds swim made profitable circular loop skewing algorithm 7 applies jacobi tomcatv swim program exit conditions timestep loop jacobi code also optimized forward substitution figure 9 jacobi program fixed itmax 100 vary input matrix size arbitrarily based algorithm 2 nstep derived 10 9 7 respectively 1279 r5kbased workstation matrix sizes r10kbased workstations nstep derived 44 37 30 respectively table 1 shows performance results original program peelandfusion program tiled algorithm 4 marked tiling w array dup although based tiling technique array dupli cated shown figure 8 array l eliminated forward substitution figure 9 giving increase memory usage peelandfusion scheme manually apply methods presented lrw 12 tss 6 choose tile size real cache size effective cache size 22 best four schemes gives shortest execution time chosen evaluate peelandfusion table 1 tiling oddeven duplication always performs better peel andfusion improves performance 70 84 r5k 159 164 r10k original code tomcatv program among 7 nbyn arrays tomcatv two arrays duplicated increasing memory usage 29 nstep equals 5 21 r5k r10kbased workstations respectively reference input data tomcatv always runs maximum time step ie 750 order measure potential overhead rollback alter convergence test trigger rollback comparison different convergence tests result different number iterations executed untransformed transformed programs execution time different versions tomcatv r5k shown table 2 iter orig means number table 2 execution time seconds tomcatv r5k various convergence tests iter orig itertrans exec time orig time speedup 43 199 204 175 207 118 731 736 593 717 128 table 3 execution timein seconds swim test exec time speedup exec time speedup orig prog 32685 100 625 100 trans prog 21501 152 573 109 iterations executed untransformed code iter trans means number iterations executed transformed code rolling back chunk size lmax 5 based heuristic rollback happens always incur penalty lmax iterations however except cases converge fast still get steady speedup 128 rollback loop bound 750 reached speedup 169 r10k original program executes 366 seconds transformed program takes 288 seconds speedup 127 convergence test altered performance comparison similar r5k also run tomcatv peelandfusion transformed code takes 649 306 seconds r5k r10k achieves speedup 113 119 respectively original program swim program duplicated swim nstep equals 5 22 r5k r10k respectively performance results shown table 3 orig prog stands original program trans prog represents transformed program r5k smaller l2 cache therefore smaller results less overlap iteration points adjacent iterations within tile thus yielding lower speedup peelandfusion apply directly swim due long backward dependence distances r10k addition execution time also measure secondary cache misses using perfex library based r10k performance counters table 4 shows result ls stands number dynamic loadstore instructions sm number misses secondary cache mr secondary cache miss ratio jacobi even checkpointing number dynamic loadstore instructions reduced due forward substitution table 1 execution time seconds different versions jacobi different scheme matrix size r5k matrix size r10k original time 46 68 102 2443 4465 5293 peelandfusion time 37 50 82 1708 2723 3576 tiling w array dup time 25 38 believe difference number loadstore instructions original code peelandfusion code due slightly memory optimization opportunities native compiler peelandfusion tomcatv number loadstore instructions increased technique due periodical checkpointing swim added number loadstore instructions expansion arrays make program conforming program model five cases secondary cache miss rate dramatically reduced gain temporal locality across iterations overcomes loss memory instructions thus improving overall performance experiments applied intervariable padding similar scheme 18 tiled swim padding reduces cache set conflicts hence improving speedup 108 152 also applied intervariable padding three original programs without noticeable performance gain cache overflow original program dominates performance 5 related work kodukula et al propose data shackling 9 blocks arrays based data flow analysis forms new loop nests compute block block although tackle certain imperfectlynested loops method apply stencil computations handled work updating one block destroy boundary data necessary adjacent blocks manjikian et al present peelandfusion 13 method partially fuse adjacent loops within loop tile fused loops exploits locality within loop iteration algorithm 1 bears similarity peelfactor computation consider dependences within iteration consider dependences across iterations kodukula pingali propose matrixbased framework represent transformations imperfectlynested loops 10 including permutation reversal skewing scaling alignment distribution jamming work apply tiling strout et al discusses minimum storage requirement allow flexible loop scheduling tiling 21 method deal imperfectly nested loops handled work collard proposes method speculatively execute whileloops parallel machines 4 objective increase parallel process utilization tile loops better memory performance uniprocessors use quite different algorithms pugh et al present method handle exit conditions iterative application parallel environment 17 works collard pugh et al present interesting ideas handle loop exit condi tions may incorporated future work mccalpin wonnacott develop scheme called time skewing adopts valuebased flow analysis optimize memory locality 15 method first performs full array expansion forward sub stitution recompresses expanded array preserving data dependences method handles subset imperfectlynested loops represented program model 6 conclusion future work paper presented new techniques tile nontrivial imperfectlynested loops handle class imperfectlynested loops seem quite general scientific computing develop two algorithms shorten backward dependence distances improve profitability also extend program model handle exit conditions common iterative algorithms implement techniques fortran sourcetosource compiler panorama 5 preliminary experimental results show transformed programs run faster 9 164 optimized native compiler work opened several interesting subjects future work important ones include application idea speculative execution localityenhancement techniques study effect aggressive localityenhancement algorithms effective cache size acknowledgement thank chauwen tseng careful review paper finalized r data computation transformations multiprocessors compiler transformations highperformance comput ing symbolic range propa gation experience efficient array data flow analysis array privatization tile size selection using cache organization data layout symbolic dependence analysis high performance parallelizing compilers matrixbased approach global locality optimization problem transformations imperfectly nested loops structure computers computations cache performance optimizations blocked algorithms fusion loops parallelism locality improving data locality loop transformations time skewing valuebased approach optimizing memory local ity practical algorithm exact array dependence analysis exploiting monotone convergence functions parallel programs eliminating conflict misses high performance architectures standard performance evaluation corporation combining loop transformations considering caches scheduling improving locality parallelism nested loops data locality optimizing algorithm high performance compilers parallel computing tr cache performance optimizations blocked algorithms data locality optimizing algorithm practical algorithm exact array dependence analysis improving locality parallelism nested loops instructionlevel parallel processing compiler transformations highperformance computing tile size selection using cache organization data layout improving data locality loop transformations exploiting monotone convergence functions parallel programs combining loop transformations considering caches scheduling fusion loops parallelism locality multilevel blocking experience efficient array data flow analysis array privatization eliminating conflict misses high performance architectures scheduleindependent storage mapping loops transformations imperfectly nested loops structure computers computations symbolic range propagation matrixbased approach global locality optimization problem ctr claudia leopold optimal temporal locality stencil codes proceedings 2002 acm symposium applied computing march 1114 2002 madrid spain nawaaz ahmed nikolay mateev keshav pingali synthesizing transformations locality enhancement imperfectlynested loop nests international journal parallel programming v29 n5 p493544 october 2001 shoaib kamil kaushik datta samuel williams leonid oliker john shalf katherine yelick implicit explicit optimizations stencil computations proceedings 2006 workshop memory system performance correctness october 2222 2006 san jose california david wonnacott achieving scalable locality time skewing international journal parallel programming v30 n3 p181221 june 2002 roger espasa federico ardanaz joel emer stephen felix julio gago roger gramunt isaac hernandez toni juan geoff lowney matthew mattina andr seznec tarantula vector extension alpha architecture acm sigarch computer architecture news v30 n2 may 2002 guohua jin john mellorcrummey experiences tuning smg98 semicoarsening multigrid benchmark based hypre library proceedings 16th international conference supercomputing june 2226 2002 new york new york usa jingling xue wentong cai timeminimal tiling rise larger zero parallel computing v28 n6 p915939 june 2002 j hu kandemir n vijaykrishnan j irwin analyzing data reuse cache reconfiguration acm transactions embedded computing systems tecs v4 n4 p851876 november 2005 guohua jin john mellorcrummey robert fowler increasing temporal locality skewing recursive blocking proceedings 2001 acmieee conference supercomputing cdrom p4343 november 1016 2001 denver colorado steve carr soner nder case workingsetbased memory hierarchy proceedings 2nd conference computing frontiers may 0406 2005 ischia italy nawaaz ahmed nikolay mateev keshav pingali synthesizing transformations locality enhancement imperfectlynested loop nests proceedings 14th international conference supercomputing p141152 may 0811 2000 santa fe new mexico united states induprakas kodukula keshav pingali datacentric transformations locality enhancement international journal parallel programming v29 n3 p319364 june 2001 nawaaz ahmed nikolay mateev keshav pingali tiling imperfectlynested loop nests proceedings 2000 acmieee conference supercomputing cdrom p31es november 0410 2000 dallas texas united states gabriel rivera chauwen tseng locality optimizations multilevel caches proceedings 1999 acmieee conference supercomputing cdrom p2es november 1419 1999 portland oregon united states qing yi vikram adve ken kennedy transforming loops recursion multilevel memory hierarchies acm sigplan notices v35 n5 p169181 may 2000 naraig manjikian tarek abdelrahman exploiting wavefront parallelism largescale sharedmemory multiprocessors ieee transactions parallel distributed systems v12 n3 p259271 march 2001 yonghong song rong xu cheng wang zhiyuan li data locality enhancement memory reduction proceedings 15th international conference supercomputing p5064 june 2001 sorrento italy kristof beyls erik h dhollander intermediately executed code key find refactorings improve temporal data locality proceedings 3rd conference computing frontiers may 0305 2006 ischia italy ya kalinov l lastovetsky n ledovskikh posypkin compilation vector statements c language architectures multilevel memory hierarchy programming computing software v27 n3 p111122 mayjune 2001 sriram krishnamoorthy muthu baskaran uday bondhugula j ramanujam atanas rountev p sadayappan effective automatic parallelization stencil computations acm sigplan notices v42 n6 june 2007 jonathan weinberg michael mccracken erich strohmaier allan snavely quantifying locality memory access patterns hpc applications proceedings 2005 acmieee conference supercomputing p50 november 1218 2005 gabriel rivera chauwen tseng tiling optimizations 3d scientific computations proceedings 2000 acmieee conference supercomputing cdrom p32es november 0410 2000 dallas texas united states charlie hu alan cox willy zwaenepoel improving finegrained irregular sharedmemory benchmarks data reordering proceedings 2000 acmieee conference supercomputing cdrom p33es november 0410 2000 dallas texas united states michelle mills strout larry carter jeanne ferrante barbara kreaseck sparse tiling stationary iterative methods international journal high performance computing applications v18 n1 p95113 february 2004 chunghsing hsu ulrich kremer quantitative analysis tile size selection algorithms journal supercomputing v27 n3 p279294 march 2004 martha mercaldi steven swanson andrew petersen andrew putnam andrew schwerin mark oskin susan j eggers instruction scheduling tiled dataflow architecture acm sigops operating systems review v40 n5 december 2006 karin hgstedt larry carter jeanne ferrante parallel execution time tiled loops ieee transactions parallel distributed systems v14 n3 p307321 march venkata k pingali sally mckee wilson c hseih john b carter computation regrouping restructuring programs temporal data cache locality proceedings 16th international conference supercomputing june 2226 2002 new york new york usa chen ding maksim orlovich potential computation regrouping improving locality proceedings 2004 acmieee conference supercomputing p13 november 0612 2004 swarup kumar sahoo sriram krishnamoorthy rajkiran panuganti p sadayappan integrated loop optimizations data locality enhancement tensor contraction expressions proceedings 2005 acmieee conference supercomputing p13 november 1218 2005 venkata k pingali sally mckee wilson c hsieh john b carter restructuring computations temporal data cache locality international journal parallel programming v31 n4 p305338 august abdelhameed badawy aneesh aggarwal donald yeung chauwen tseng evaluating impact memory system performance software prefetching locality optimizations proceedings 15th international conference supercomputing p486500 june 2001 sorrento italy cociorva j w wilkins c lam g baumgartner j ramanujam p sadayappan loop optimization class memoryconstrained computations proceedings 15th international conference supercomputing p103113 june 2001 sorrento italy jingling xue xavier vera efficient accurate analytical modeling wholeprogram data cache behavior ieee transactions computers v53 n5 p547566 may 2004 sandhya krishnan sriram krishnamoorthy gerald baumgartner chichung lam j ramanujam p sadayappan venkatesh choppella efficient synthesis outofcore algorithms using nonlinear optimization solver journal parallel distributed computing v66 n5 p659673 may 2006 zhiyuan li yonghong song automatic tiling iterative stencil loops acm transactions programming languages systems toplas v26 n6 p9751028 november 2004 chen ding ken kennedy improving effective bandwidth compiler enhancement global cache reuse journal parallel distributed computing v64 n1 p108134 january 2004
ray tracing programmable graphics hardware recently breakthrough occurred graphics hardware fixed function pipelines replaced programmable vertex fragment processors near future graphics pipeline likely evolve general programmable stream processor capable simply feedforward triangle renderingin paper evaluate trends programmability graphics pipeline explain ray tracing mapped graphics hardware using simulator analyze performance ray casting implementation next generation programmable graphics hardware addition compare performance difference nonbranching programmable hardware using multipass implementation architecture supports branching also show approach applicable ray tracing algorithms whitted ray tracing path tracing hybrid rendering algorithms finally demonstrate ray tracing graphics hardware could prove faster cpu based implementations well competitive traditional hardware accelerated feedforward triangle rendering b introduction realtime ray tracing goal computergraphics community many years recently vlsi technology reached point raw computational capability single chip sufficient realtime ray tracing realtime ray tracing demonstrated small scenes single generalpurpose cpu simd floating point extensions wald et al 2001b larger scenes shared memory multiprocessor parker et al 1998 parker et al 1999 cluster wald et al 2001b wald et al 2001a various efforts way develop chips specialized ray tracing ray tracing chips accelerate offline rendering commercially available hall 2001 given realtime ray tracing possible near future worthwhile study implementations different architectures goal providing maximum performance lowest cost currently nvidia corporation tpurcell ianbuck billmark hanrahangraphicsstanfordedu paper describe alternative approach realtime ray tracing potential perform cpubased algorithms without requiring fundamentally new hardware using commodity programmable graphics hardware implement ray tracing graphics hardware recently evolved fixedfunction graphics pipeline optimized rendering texturemapped triangles graphics pipeline programmable vertex fragment stages nearterm next year two graphics processor gpu fragment program stage likely generalized include floating point computation complete orthogonal instruction set capabilities demanded programmers using current hardware show capabilities also sufficient us write complete ray tracer hardware programmable stages become general hardware considered generalpurpose stream processor stream processing model supports variety highlyparallelizable algo rithms including ray tracing recent years performance graphics hardware increased rapidly cpus cpu designs optimized high performance sequential code becoming increasingly difficult use additional transistors improve performance code contrast programmable graphics hardware optimized highlyparallel vertex fragment shading code lindholm et al 2001 result gpus use additional transistors much effectively cpus thus sustain greater rate performance improvement semiconductor fabrication technology advances convergence three separate trends sufficient raw performance singlechip realtime ray tracing increasing gpu programmability faster performance improvements gpus cpus make gpus attractive platform realtime ray tracing gpubased ray tracing also allows hybrid rendering algorithms eg algorithm starts zbuffered rendering pass visibility uses ray tracing secondary shadow rays blurring line traditional triangle rendering ray tracing allows natural evolution toward increased realism paper show efficiently implement ray tracing gpus paper contains three main contributions show ray tracing mapped stream processing model parallel computation part map ping describe efficient algorithm mapping innermost raytriangle intersection loop multiple rendering passes show basic ray caster extended include shadows reflections path tracing analyze streaming gpubased ray casters performance show competitive current cpubased ray casting also show initial results system including secondary rays believe near future gpubased ray tracing much faster cpubased ray tracing guide future gpu implementations analyze compute memory bandwidth requirements ray casting gpus study two basic architectures one architecture without branching requires multiple passes another branching requires single pass show single pass version requires significantly less bandwidth computelimited also analyze performance texture cache used ray casting show effective reducing bandwidth programmable graphics hardware 21 current programmable graphics pipeline application vertex program rasterization fragment program display figure 1 programmable graphics pipeline diagram modern graphics pipeline shown figure 1 todays graphics chips nvidia geforce3 nvidia 2001 ati radeon 8500 ati 2001 replace fixedfunction vertex fragment including texture stages programmable stages programmable vertex fragment engines execute userdefined programs allow fine control shading texturing calculations nvidia vertex program consists 128 4way simd floating point instructions lind holm et al 2001 vertex program run incoming vertex computed results passed rasterization stage fragment stage also programmable either nvidia register combiners spitzer 2001 directx 8 pixel shaders mi crosoft 2001 pixel shaders like vertex programs provide 4way simd instruction set augmented instructions texturing unlike vertex programs operate fixedpoint values pa per primarily interested programmable fragment pipeline designed operate system fill rate approxi mately 1 billion fragments per second programmable shading recent innovation current hardware many limitations vertex fragment programs simple incomplete instruction sets fragment program instruction set much simpler vertex instruction set fragment program data types mostly fixedpoint input textures output framebuffer colors typically 8bits per color component intermediate values registers slightly precision many resource limitations programs limited number instructions small number registers stage limited number inputs outputs eg number outputs vertex stage constrained number vertex interpolants number active textures number dependent textures limited current hardware permits certain instructions computing texture addresses certain points within program example directx 8 ps 14 pixel shader two stages first texture addressing stage consisting four texture fetch instructions followed eight color blending instructions color computation stage consisting additional texture fetches followed color combining arithmetic programming model permits single level dependent texturing single color value may written framebuffer pass programs cannot loop conditional branching instructions 22 proposed nearterm programmable graphics pipeline limitations current hardware make difficult implement ray tracing fragment program fortunately due interest programmable shading mainstream game applications programmable pipelines rapidly evolving many hardware software vendors circulating proposals future hardware fact many current limitations merely result fact represent first generation programmable hardware paper show implement ray tracer extended hardware model think approximates hardware available next year two model based loosely proposals microsoft directx 90 marshall 2001 3dlabs opengl 20 3dlabs 2001 target baseline architecture following features programmable fragment stage floating point instructions registers also assume floating point texture framebuffer formats enhanced fragment program assembly instructions include instructions available vertex level furthermore allow longer programs long enough basic ray tracing components may downloaded single program longest program order 50 instructions texture lookups allowed anywhere within fragment pro gram limits number texture fetches levels texture dependencies within program multiple outputs allow 1 2 floating point rgba 4 vectors written framebuffer fragment pro gram also assume fragment program render directly texture stencil buffer consider enhancements natural evolution current graphics hardware already mentioned features actively consideration various vendors heart efficient ray tracing implementation ability traverse acceleration structure test intersection ray list triangles abilities require looping construct note architecture include datadependent conditional branching instruction set despite limitation programs loops conditionals mapped baseline architecture using multipass rendering technique presented peercy et al 2000 implement conditional using technique conditional predicate first evaluated using sequence rendering passes stencil bit set true false depending result body conditional evaluated using additional rendering passes values written framebuffer corresponding fragments stencil bit true although algorithm developed fixedfunction graphics pipeline extended used programmable pipeline assume addition two hardware features make peercy et al algorithm efficient direct setting stencil bits early fragment kill similar z occlusion culling kirk 2001 standard opengl pipeline stencil bits may set testing alpha value alpha value computed fragment program written framebuffer setting stencil bit computed alpha value requires additional pass since fragment programs baseline architecture modify stencil values directly eliminate extra pass another important rendering optimization early fragment kill fragment kill depth stencil test executed fragment program stage fragment program executed fragment passes stencil test stencil bit false instructions executed texture framebuffer bandwidth used except read 8bit stencil value using combination two techniques multipass rendering using large fragment programs control stencil buffer quite efficient see ray tracing involves significant looping although rendering pass efficient extra passes still cost pass consumes extra bandwidth reading writing intermediate values texture pass also requires bandwidth read stencil values thus fewer resources would used inner loops voxels triangles coalesced single pass obvious way would add branching fragment processing hardware however adding support branching increases complexity gpu hardware nonbranching gpus may use single instruction stream feed several fragment pipelines simultaneously simd computation gpus support branching require separate instruction stream processing unit mimd computation therefore graphics architects would like avoid branching possible concrete example trade evaluate efficiency ray casting two architec tures one one without branching multipass architecture supports arbitrary texture reads floatingpoint texture framebuffer formats general floating point instructions two floating point 4vector outputs branching implemented via multipass rendering branching architecture multipass architecture enhanced include support conditional branching instructions loops control flow 23 streaming graphics processor abstraction graphics processor evolves include complete instruction set larger data types appears like generalpurpose processor however challenge introduce programmability without compromising performance otherwise gpu would become like cpu lose costperformance advantages order guide mapping new applications graphics architectures propose view nextgeneration graphics hardware streaming processor stream processing new idea media processors transform streams digital information mpeg video decode imagine processor example generalpurpose streaming processor khailany et al 2000 streaming computing differs traditional computing system reads data required computation sequential stream elements element stream record data requiring similar computation system executes program kernel element input stream placing result output stream sense programmable graphics processor executes vertex program stream vertices fragment program stream fragments since part ignoring vertex programs rasterization treating graphics chip basically streaming fragment processor streaming model computation leads efficient implementations three reasons first since stream elements computation independent designers add additional pipelines process elements stream parallel second kernels achieve high arithmetic intensity perform lot computation per small fixedsize record result computation memory bandwidth ratio high third streaming hardware hide memory latency texture fetches using prefetching torborg kajiya 1996 anderson et al 1997 igehy et al 1998 hardware fetches texture frag ment fragment registers placed fifo fragment processor starts processing another fragment texture fetched processor return fragment method hiding latency similar multithreading alverson et al 1990 works abundant parallelism streams sum mary streaming model allows graphics hardware exploit par allelism utilize bandwidth efficiently hide memory la tency result graphics hardware makes efficient use vlsi resources challenge map ray tracing onto streaming model computation done breaking ray tracer kernels kernels chained together streams data originating data stored textures framebuffer 3 streaming ray tracing section show reformulate ray tracing streaming computation flow diagram streaming ray tracer found figure 2 generate eye rays traverse acceleration structure intersect triangles grid triangle list offsets camera triangles triangle list shade hit generate shading rays materials normals figure 2 streaming ray tracer paper assume scene geometry represented triangles stored acceleration data structure rendering begins typical scenario application would specify scene geometry using display list graphics library would place display list geometry acceleration data structure consider cost building data structure since may expensive operation assumption implies algorithm described paper may efficient dynamic scenes second design decision use uniform grid accelerate ray tracing many possible acceleration data structures choose bounding volume hierarchies bsp trees k trees octrees uniform grids adaptive grids hierarchical grids etc chose uniform grids two reasons first many experiments performed using different acceleration data structures different scenes excellent recent study see havran et al 2000 studies single acceleration data structure appears efficient appear within factor two second uniform grids particularly simple hardware implementations accesses grid data structures require constant time hierarchical data structures contrast require variable time per access involve pointer chasing code grid traversal also simple highly optimized hardware system grid represented 3d texture map memory organization currently supported graphics hardware discuss pros cons grid section 5 split streaming ray tracer four kernels eye ray generation grid traversal raytriangle intersection shad ing eye ray generator kernel produces stream viewing rays viewing ray single ray corresponding pixel image traversal kernel reads stream rays produced eye ray generator traversal kernel steps rays grid ray encounters voxel containing triangles ray voxel address output passed intersection kernel intersection kernel responsible testing ray intersections triangles contained voxel intersector two types output raytriangle intersection hit occurs voxel ray triangle hit output shading hit occurs ray passed back traversal kernel search voxels containing triangles continues shading kernel computes color ray terminates hit color written accumulated image additionally shading kernel may generate shadow secondary rays case new rays passed back traversal stage implement ray tracing kernels fragment programs execute programs rendering screensized rectangle constant inputs placed within kernel code stream inputs fetched screenaligned textures results kernel written back textures stencil buffer controls fragments screensized rectangle screenaligned textures active 8bit stencil value associated ray contains rays state rays state traversing intersecting shad ing done specifying correct stencil test rendering pass allow kernel run rays particular state following sections detail implementation ray tracing kernel memory layout scene describe several variations including ray casting whitted ray tracing whitted 1980 path tracing shadow casting 31 ray tracing kernels 311 eye ray generator eye ray generator simplest kernel ray tracer given camera parameters including viewpoint view direction computes eye ray screen pixel fragment program invoked pixel screen generating eye ray eye ray generator also tests ray scene bounding box rays intersect scene bounding box processed fur ther miss terminated 312 traverser traversal stage searches voxels containing triangles first part traversal stage sets traversal calculation second part steps along ray enumerating voxels pierced ray traversal equivalent 3d line drawing perray setup cost pervoxel rasterization cost use 3ddda algorithm fujimoto et al 1986 traversal step kernel queries grid data structure stored 3d texture grid contains null pointer voxel empty pointer null voxel contains triangles case rayvoxel pair output ray marked tested intersection triangles voxel implementing traverser loop multipass architecture requires multiple passes per ray setup done two passes step voxel requires additional pass end pass fragment program must store stepping parameters used within loop textures must read next pass discuss multipass implementation discuss intersection stage triangle textures vertex triangle list texture texture grid z x z x z x z x z x z x z x z x z x v2 z x z x z x z x z x z x figure 4 grid triangle data structures stored texture memory grid cell contains pointer list triangles pointer null triangles stored voxel grids stored 3d textures triangle lists stored another tex ture voxels containing triangles point beginning triangle list triangle list texture triangle list consists set pointers vertex data end triangle list indicated null pointer finally vertex positions stored textures 313 intersector triangle intersection stage takes stream rayvoxel pairs outputs raytriangle hits performing raytriangle intersection tests triangles within voxel hit occurs raytriangle pair passed shading stage code computing single raytriangle intersection shown figure 5 code similar used carr et al 2002 directx 8 ps 14 raytriangle intersector discuss system section 5 triangles overlap multiple grid cells possible intersection point lie outside current voxel intersection kernel checks case treats miss note rejecting intersections way may cause ray tested triangle multiple times different voxels possible use mailbox algorithm prevent extra intersection calculations amanatides woo 1987 mailboxing difficult implement multiple rays traced parallel layout grid triangles texture memory shown figure 4 mentioned voxel contains offset trianglelist texture trianglelist texture contains delimited list offsets trianglevertex textures note triangle list texture trianglevertex textures 1d textures fact textures used randomaccess readonly memory represent integer offsets 1component floating point textures vertex positions three floating point rgb textures thus theoretically four billion triangles could addressed texture memory 32bit integer addressing however much less texture memory actually available current graphics cards limitations size 1d textures overcome using 2d textures generate find intersection shade hit shadow rays generate shade hit find nearest intersection eye rays generate shade hit find nearest intersection eye rays generate shade hit find nearest intersection eye raysshadow caster ray caster whitted ray tracer path tracer b c figure 3 data flow diagrams ray tracing algorithms implement algorithms depicted shadow casting b ray casting c whitted ray tracing path tracing ray tracing raysurface intersection generates l 2 rays l number lights scene corresponding number shadow rays tested two reflection refraction rays path tracing randomly chooses one ray bounce follow feedback path one ray wide list pos float4 h float list pos trilist float float float return float4 u v id figure 5 code raytriangle intersection proper address translation well segmenting data across multiple textures traversal stage inner loop triangles voxel involves multiple passes ray requires single pass per raytriangle intersection 314 shader shading kernel evaluates color contribution given ray hit point shading calculations exactly like standard graphics pipeline shading data stored memory much like triangle data set three rgb textures 32bits per channel contains vertex normals vertex colors triangle hit information passed shader includes triangle number access shading information simple dependent texture lookup particular triangle specified choosing different shading rays implement several flavors ray tracing using streaming algorithm look ray casting whittedstyle ray tracing path tracing shadow casting figure 3 shows simplified flow diagram methods discussed along example image produced system shading kernel optionally generates shadow reflection fraction randomly generated rays secondary rays placed texture locations future rendering passes ray also assigned weight finally terminated contribution final image may simply added image kajiya 1986 technique assigning weight ray eliminates recursion simplifies control flow ray caster ray caster generates images identical generated standard graphics pipeline pixel screen eye ray generated ray fired scene returns color nearest triangle hits secondary rays generated including shadow rays previous efforts implement interactive ray tracing focused type computation serve basic implementation whitted ray tracer classic whittedstyle ray tracer whitted 1980 generates eye rays sends scene upon finding hit reflection model surface evaluated pair reflection refraction rays set shadow rays one per light source generated sent scene path tracer path tracing rays randomly scattered surfaces hit light source path tracer emulates arnold renderer fajardo 2001 one path generated per sample path contains 2 bounces shadow caster simulate hybrid system uses standard graphics pipeline perform hidden surface calculation first pass uses ray tracing algorithm evaluate shadows shadow casting useful replacement shadow maps shadow volumes shadow volumes extremely expensive compute shadow maps tends difficult set proper resolution shadow caster viewed deferred shading pass molnar et al 1992 shadow caster pass generates shadow rays light source adds lights contribution final image blockers found multipass branching kernel instr memory words stencil instr memory words count r w rs ws count r w generate eye ray 28 0 5 traverse intersect shade shadow reflected 26 11 9 9 path table 1 ray tracing kernel summary show number instructions required implement kernels along number 32bit words memory must read written rendering passes r w number memory words read randomaccess textures two sets statistics shown one multipass architecture another branching architecture multipass architecture also show number 8bit stencil reads rs writes ws kernel stencil read overhead charged rays whether kernel executed 32 implementation evaluate computation bandwidth requirements streaming ray tracer implemented kernel assembly language fragment program nvidia vertex program instruction set used fragment programs addition instructions described previously assembly language implementation provides estimates number instructions required kernel invocation also calculate bandwidth required kernel break bandwidth stream input bandwidth stream output bandwidth memory random access read bandwidth table 1 summarizes computation bandwidth required kernel ray tracer multipass branching architectures traversal intersection kernels involve looping counts setup loop body shown separately branching architecture allows us combine individual kernels together result branching kernels slightly smaller since initialization termination instructions removed branching architecture permits kernels run together within single rendering pass using table 1 compute total compute bandwidth costs scene r total number rays traced c r cost generate ray c v cost walk ray voxel c cost performing raytriangle intersection c cost shading p total number rendering passes c stencil cost reading stencil buffer total cost associated stage determined number times kernel invoked number depends scene statistics v average number voxels pierced ray average number triangles intersected ray average number shading calculations per ray branching architecture stencil buffer checks c stencil zero multipass architecture must pay stencil read cost rays rendering passes cost ray tracer various scenes presented results section finally present optimization minimize total number passes motivated part delanys implementation ray tracer connection machine delany 1988 traversal intersection kernels involve loops various strategies nesting loops simplest algorithm would step voxels ray encounters voxel containing triangles intersect ray triangles ever strategy would inefficient since intersection rays encountered voxels triangles simd machine like connection machine results low processor utilization graphics hardware yields excessive number passes resulting large number stencil read operations dominating performance following efficient algorithm generate eye ray anyactiveray oracleray traverseray else eye ray generation ray tracer enters loop tests whether rays active active rays require either traversals intersections inactive rays either hit triangles traversed entire grid pass oracle called oracle chooses whether run traverse intersect pass various oracles possible simple algorithm runs intersect pass rays require intersection tests better oracle first proposed delany choose pass perform work done calculating percentage rays requiring intersection vs traversal experiments found performing intersections 20 rays require intersection tests produced minimal number passes within factor two three optimal simd algorithm performing single computation per rendering pass implement oracle assume graphics hardware maintains small set counters stencil buffer contains state ray total eight counters one per stencil bit would sufficient needs since four states alternatively could use opengl histogram operation oracle operation implemented high performance stencil buffer 41 methodology implemented functional simulators streaming ray tracer multipass branching architectures simulators high level simulations architectures written c programming language simulators compute images gather scene statistics example statistics include average number traversal steps taken per ray average number hall outside soda hall inside forest top forest inside bunny ray cast figure fundamental scene statistics test scenes statistics shown match cost model formula presented section 32 recall v average number voxels pierced ray average number triangles intersected ray average number shading calculations per ray soda hall 15m triangles forest 10m triangles stanford bunny 70k triangles scenes rendered 1024x1024 pixels raytriangle intersection tests performed per ray multipass architecture simulator also tracks number type rendering passes performed well stencil buffer activity statistics allow us compute cost rendering scene using cost model described section 3 multipass branching architecture simulators generate trace file memory reference stream processing texture cache simulator cache simulations used 64kb directmapped texture cache 48byte line size line size holds four floating point rgb texels three floating point rgba texels wasted space execution order fragment programs effects caching behavior execute kernels though single pixel wide graphics pipeline likely gpu implementation include multiple parallel fragment pipelines executing concurrently thus accesses interleaved architectures specified level detail therefore able take effects account cache simulator analyze performance ray tracer five viewpoints three different scenes shown figure 6 soda hall relatively complex model used evaluate realtime ray tracing systems wald et al 2001b walls made large polygons furnishings made small polygons scene high depth complexity forest scene includes trees millions tiny triangles scene moderate depth complexity difficult perform occlusion culling analyze cache behavior shadow reflection rays using scene bunny chosen demonstrate extension ray tracer support shadows reflections path tracing figure 7 shows computation bandwidth requirements test scenes computation bandwidth utilized broken kernel graphs clearly show computation bandwidth architectures dominated grid traversal triangle intersection choosing optimal grid resolution scenes difficult finer grid yields fewer raytriangle intersection tests leads traversal steps coarser grid reduces number traversal steps increases number raytriangle intersection tests attempt keep voxels near cubical shape specify grid resolution minimal grid dimension acceptable along dimension scene bounding box bunny minimal grid dimension 64 yielding final resolution 98 64 163 larger soda hall forest models minimal dimension 128 yielding grid resolutions 250 198 128 581 128 581 respectively resolutions allow algorithms spend equal amounts time traversal intersection kernels outside inside hall top inside forest bunny ray cast26 ginstructions intersector traverser others515gbytes multipass outside inside hall top inside forest bunny ray cast2ginstructions intersector traverser others515 gbytes branching figure 7 compute bandwidth usage scenes column shows contribution kernel left bar plot compute right bandwidth horizontal line represents persecond bandwidth compute performance hypothetical architecture scenes rendered 1024 1024 pixels 42 architectural comparisons compare multipass branching architectures first investigate implementation ray caster multipass architecture table 2 shows total number rendering passes distribution passes amongst various kernels total number passes varies 10003000 although number passes seems high total number needed render scene conventional graphics pipeline many fewer per object used many objects drawn system pass draws single rectangle speed geometry processing part pipeline factor also evaluate efficiency multipass algorithm recall rays may traversing intersecting shading done efficiency pass depends percentage rays processed pass scenes efficiency 610 test scenes except outside view soda hall pass breakdown per ray maximum simd total traversal intersection traversals intersections efficiency hall outside 2443 692 1747 4 384 1123 0009 hall inside 1198 70 1124 4 forest top 1999 311 1684 4 137 1435 0062 forest inside 2835 1363 1468 4 898 990 0068 bunny ray cast 1085 610 471 4 221 328 0105 table 2 breakdown passes multipass system intersection traversal make bulk passes systems rest passes coming ray generation traversal setup shading also show maximum number traversal steps intersection tests per ray finally simd efficiency measures average fraction rays useful work given pass outside inside hall top inside forest bunny ray cast515gbytes stencil state variables data structures figure 8 bandwidth consumption data type left bars multipass right bars branching overhead reading 8bit stencil value shown top state variables data written read texture passes data structure bandwidth comes readonly data triangles triangle lists grid cells shading data scenes rendered 1024 1024 pixels viewpoint contains several rays miss scene bounding box entirely expected resulting efficiency much lower since rays never useful work rest compu tation although 10 efficiency may seem low fragment processor utilization much higher using early fragment kill avoid consuming compute resources nonstencil bandwidth fragment finally table 2 shows maximum number traversal steps intersection tests performed per ray since total number passes depends worst case ray numbers provide lower bounds number passes needed multipass algorithm interleaves traversal intersection passes comes within factor two three optimal number rendering passes naive algorithm performs intersection soon ray hits full voxel requires least factor five times passes optimal scenes ready compare computation bandwidth requirements test scenes two architectures figure 8 shows bandwidth measurements shown figure 7 broken data type instead kernel graph shows ex pected bandwidth required branching architecture reading voxel triangle data structures memory multipass architecture conversely uses bandwidth writing reading intermediate values texture memory passes similarly saving restoring intermediates requires extra instructions addition significant bandwidth devoted reading stencil buffer extra computation bandwidth consumption fundamental limitation multipass algorithm one way reduce number rendering passes bandwidth consumed intermediate values multipass architecture unroll inner loops presented data outside inside hall top inside forest bunny ray cast shadow reflect forest0515normalized bandwidth stencil state variables voxel data triangle data shading data figure 9 ratio bandwidth texture cache bandwidth without texture cache left bars multipass right bars branching within bar bandwidth consumed texture cache broken data type scenes rendered pixels single traversal step single intersection test performed per ray rendering pass instead unroll kernels perform four traversal steps two intersection tests test scenes reduce total bandwidth usage 50 assume suppress triangle voxel memory references ray finishes middle pass total bandwidth reduction reaches 60 time total instruction count required render scene increases less 10 aggressive loop unrolling bandwidth savings continue total instruction count increase varies factor two scenes results indicate loop unrolling make overhead inherent multipass architecture unrolling achieve compute bandwidth ratio obtained branching architecture finally compare caching behavior two implemen tations figure 9 shows bandwidth requirements texture cache used bandwidth consumption normalized dividing noncaching bandwidth reported earlier inspecting graph see multipass system benefit much texture caching bandwidth used streaming data particular either stencil buffer intermediate results since data unique kernel vocation reuse contrast branching architecture utilizes texture cache effectively since bandwidth devoted reading shared data structures reuse studying caching behavior triangle data see 9699 hit rate achieved multipass branching system high hit rate suggests triangle data caches well fairly small working set size summary implementation ray caster multipass architecture achieved good balance computation bandwidth ratio instruction count bandwidth matches capabilities modern gpu example relative extension instructions bandwidth shadow caster 085 115 whitted ray tracer 262 300 path tracer 324 406 table 3 number instructions amount bandwidth consumed extended algorithms render bunny scene using branching architecture normalized ray casting cost nvidia geforce3 able execute approximately 2g instruc tionss fragment processor roughly 8gbs memory bandwidth expanding traversal intersection kernels perform multiple traversal steps intersection tests per pass reduces bandwidth required scene cost increasing computational requirements amount loop unrolling changed match computation bandwidth capabilities underlying hardware comparison branching architecture consumes fewer instructions significantly less bandwidth result branching architecture severely computelimited based todays gpu bandwidth compute rates however branching architecture become attractive future compute bandwidth ratio graphics chips increases introduction parallel fragment pipelines 43 extended algorithms efficient ray caster place implementing extensions shadow casting full whitted ray tracing path tracing quite simple method utilizes raytriangle intersection loop analyzed ray caster implements different shading kernel generates new rays fed back system figure 3 shows images bunny produced system ray casting extensions simulate total cost rendering scene depends number rays traced cache performance table 3 shows number instructions bandwidth required produce image bunny relative ray casting cost using branching architecture path traced bunny rendered 256 256 pixels 64 samples 2 bounces per pixel others rendered 1024 1024 pixels ray cast bunny finds valid hit 82 pixels hence 82 primary rays generate secondary rays rays equal one would expect shadow caster consume 82 instructions bandwidth ray caster likewise path tracer would consume 32 times ray caster note instruction usage close expected value bandwidth consumed additionally secondary rays cache well eye rays due generally incoherent nature last two columns figure 9 illustrate cache effectiveness secondary rays measured separately primary rays tests render inside forest scene two different styles shadow rendered three light sources hit producing three shadow rays reflect applies two bounce reflection single light source shading model primitive scene multipass rendering system texture cache unable reduce total bandwidth consumed system streaming data destroys locality present triangle voxel data branching architecture results demonstrate scenes secondary rays benefit caching system achieves bandwidth reduction shadow computation however caching reflective forest reduce required band width currently investigating ways improve performance system secondary rays section discuss limitations current system future work 51 acceleration data structures major limitation system rely preprocessing step build grid many applications contain dynamic ge ometry support applications need fast incremental updates grid building acceleration data structures dynamic scenes active area research reinhard et al 2000 interesting possibility would use graphics hardware build acceleration data structure graphics hardware could scan convert geometry grid however architectures studied paper cannot efficiently operations like rasterization within fragment processor would need ability write arbitrary memory locations classic scatter operation would move hardware even closer general stream processor research assumed uniform grid uniform grids ever may fail scenes containing geometry empty space many levels detail since view texture memory randomaccess memory hierarchical grids could added system currently graphics boards contain relatively small amounts memory 2001 typical board contains 64mb scenes looked require 200mb 300mb texture memory store scene interesting direction future work would study hierarchical caching geometry commonly done textures trend towards unified system graphics memory may ultimately eliminate problem 52 cpu vs gpu wald et al developed optimized ray tracer pc simd floating point extensions wald et al 2001b 800 mhz pentium iii report raytriangle intersection rate 20m intersectionss carr et al 2002 achieve 114m raytriangle inter sectionss ati radeon 8500 using limited fixed point preci sion assuming proposed hardware ran speed geforce3 2g instructionss could compute 56m raytriangle intersectionss branching architecture compute limited increase instruction issue rate factor four 8g structionss would still use bandwidth available geforce3 8gbs would allow us compute 222m ray triangle intersections per second believe inherently parallel nature fragment programs number gpu instructions executed per second increase much faster number cpu simd instructions basic feasibility ray tracing gpu demonstrated interesting consider modifications gpu support ray tracing efficiently many possibilities immediately suggest since rays streamed system would efficient store stream buffer texture map would eliminate need stencil buffer control conditional execution stream buffers quite similar fbuffers uses multipass rendering mark proudfoot 2001 current implementation grid traversal code map well vertex program instruction set thus quite inefficient since grid traversal similar rasterization might possible modify rasterizer walk grid finally vertex program instruction set could optimized raytriangle intersection could performed fewer instructions carr et al 2002 independently developed method using gpu accelerate ray tracing system gpu used accelerate raytriangle intersection tests system gpu memory used hold state many active rays system triangle turn fed gpu tested intersection active rays system differs store scene triangles 3d grid gpu stores acceleration structure cpu also run entire ray tracer gpu system much efficient since eliminate gpucpu communication bottleneck 53 tiled rendering multipass architecture majority memory bandwidth consumed saving restoring temporary variables since streaming temporaries used bandwidth savings due cache unfortunately streaming variables accessed texture displace cacheable data structures size cache used large enough store working set includes temporary variables data structures best way deal problem separate streaming variables cacheable variables another solution problem break image small tiles tile rendered completion proceeding next tile tiling reduces working set size tile size chosen working set fits cache streaming variables displace cacheable data structures performed preliminary experiments along lines results encouraging 6 conclusions shown viewing programmable graphics processor general parallel computation device help us leverage graphics processor performance curve apply general parallel computations specifically ray tracing shown ray casting done efficiently graphics hardware hope encourage graphics hardware evolve toward general programmable stream architecture many believe fundamentally different architecture would required realtime ray tracing hardware work demonstrates gradual convergence ray tracing feedforward hardware pipeline possible acknowledgments would like thank everyone stanford graphics lab contributing ideas work thank matt papakipos nvidia thoughts next generation graphics hardware kurt akeley reviewers comments katie tillman stayed late helped editing would like thank hanspeter pfister merl additional support work sponsored darpa contracts dabt6395c0085 mda90498ca933 ati nvidia sony sun r tr artsccelerated raytracing system rendering equation ray tracing connection machine pixelflow highspeed rendering using image composition talisman tera computer system accommodating memory latency lowcost rasterizer prefetching texture cache architecture interactive ray tracing isosurface rendering interactive ray tracing interactive multipass programmable shading improved illumination model shaded display userprogrammable vertex engine fbuffer dynamic acceleration structures interactive ray tracing interactive distributed ray tracing highly complex models ctr edgar velzquezarmendriz eugene lee kavita bala bruce walter implementing render cache edgeandpoint image graphics hardware proceedings 2006 conference graphics interface june 0709 2006 quebec canada manfred weiler martin kraus markus merz thomas ertl hardwarebased ray casting tetrahedral meshes proceedings 14th ieee visualization 2003 vis03 p44 october 2224 h du sanchezelez n tabrizi n bagherzadeh l anido fernandez interactive ray tracing reconfigurable simd morphosys proceedings conference design automation test europe designers forum p20144 march 0307 h du sanchezelez n tabrizi n bagherzadeh l anido fernandez interactive ray tracing reconfigurable simd morphosys proceedings conference asia south pacific design automation january 2124 2003 kitakyushu japan anton l fuhrmann robert f tobler stefan maierhofer realtime glossy reflections planar surfaces proceedings 3rd international conference computer graphics virtual reality visualisation interaction africa november 0305 2004 stellenbosch south africa christian henning peter stephenson accelerating ray tracing height fields proceedings 2nd international conference computer graphics interactive techniques australasia south east asia june 1518 2004 singapore pradeep sen mike cammarano pat hanrahan shadow silhouette maps acm transactions graphics tog v22 n3 july chihchang chen damon shingmin liu use hardware zbuffered rasterization accelerate ray tracing proceedings 2007 acm symposium applied computing march 1115 2007 seoul korea nathan carr jared hoberock keenan crane john c hart fast gpu ray tracing dynamic meshes using geometry images proceedings 2006 conference graphics interface june 0709 2006 quebec canada daniel reiter horn jeremy sugerman mike houston pat hanrahan interactive kd tree gpu raytracing proceedings 2007 symposium interactive 3d graphics games april 30may 02 2007 seattle washington victor moya carlos gonzalez jordi roca agustin fernandez roger espasa shader performance analysis modern gpu architecture proceedings 38th annual ieeeacm international symposium microarchitecture p355364 november 1216 2005 barcelona spain j stewart e p bennett l mcmillan pixelview viewindependent graphics rendering architecture proceedings acm siggrapheurographics conference graphics hardware august 2930 2004 grenoble france jingyi yu jason yang leonard mcmillan realtime reflection mapping parallax proceedings 2005 symposium interactive 3d graphics games april 0306 2005 washington district columbia kaoru sugita takeshi naemura hiroshi harashima performance evaluation programmable graphics hardware image filtering stereo matching proceedings acm symposium virtual reality software technology october 0103 2003 osaka japan tim foley mike houston pat hanrahan efficient partitioning fragment shaders multipleoutput hardware proceedings acm siggrapheurographics conference graphics hardware august 2930 2004 grenoble france christophe cassagnabre franois rousselle christophe renaud path tracing using ar350 processor proceedings 2nd international conference computer graphics interactive techniques australasia south east asia june 1518 2004 singapore karl e hillesland sergey molinov radek grzeszczuk nonlinear optimization framework imagebased modeling programmable graphics hardware acm transactions graphics tog v22 n3 july karl e hillesland sergey molinov radek grzeszczuk nonlinear optimization framework imagebased modeling programmable graphics hardware acm siggraph 2005 courses july 31august f losasso h hoppe schaefer j warren smooth geometry images proceedings eurographicsacm siggraph symposium geometry processing june 2325 2003 aachen germany peijie huang wencheng wang gang yang enhua wu traversal fields ray tracing dynamic scenes proceedings acm symposium virtual reality software technology november 0103 2006 limassol cyprus xianfeng gu song zhang peisen huang liangjun zhang shingtung yau ralph martin holoimages proceedings 2006 acm symposium solid physical modeling june 0608 2006 cardiff wales united kingdom kolb l latta c rezksalama hardwarebased simulation collision detection large particle systems proceedings acm siggrapheurographics conference graphics hardware august 2930 2004 grenoble france acceleration structures gpu raytracer proceedings acm siggrapheurographics conference graphics hardware july 3031 2005 los angeles california chris wyman scott davis interactive imagespace techniques approximating caustics proceedings 2006 symposium interactive 3d graphics games march 1417 2006 redwood city california sudipto guha shankar krishnan kamesh munagala suresh venkatasubramanian application twosided depth test csg rendering proceedings symposium interactive 3d graphics april 2730 2003 monterey california nathan cournia chessboard domination programmable graphics hardware proceedings 44th annual southeast regional conference march 1012 2006 melbourne florida nathan carr jesse hall john c hart gpu algorithms radiosity subsurface scattering proceedings acm siggrapheurographics conference graphics hardware july 2627 2003 san diego california ingo wald carsten benthin philipp slusallek distributed interactive ray tracing dynamic scenes proceedings ieee symposium parallel largedata visualization graphics p11 october 2021 lionel baboud xavier dcoret rendering geometry relief textures proceedings 2006 conference graphics interface june 0709 2006 quebec canada nolan goodnight cliff woolley gregory lewin david luebke greg humphreys multigrid solver boundary value problems using programmable graphics hardware proceedings acm siggrapheurographics conference graphics hardware july 2627 2003 san diego california anthony sherbondy mike houston sandy napel fast volume segmentation simultaneous visualization using programmable graphics hardware proceedings 14th ieee visualization 2003 vis03 p23 october 2224 yuan zhou michael garland robert haber pixelexact rendering spacetime finite element solutions proceedings conference visualization 04 p425432 october 1015 2004 abhinav dayal cliff woolley benjamin watson david luebke adaptive frameless rendering acm siggraph 2005 courses july 31august nolan goodnight cliff woolley gregory lewin david luebke greg humphreys multigrid solver boundary value problems using programmable graphics hardware acm siggraph 2005 courses july 31august timothy j purcell craig donner mike cammarano henrik wann jensen pat hanrahan photon mapping programmable graphics hardware proceedings acm siggrapheurographics conference graphics hardware july 2627 2003 san diego california timothy j purcell craig donner mike cammarano henrik wann jensen pat hanrahan photon mapping programmable graphics hardware acm siggraph 2005 courses july 31august ingo wald openrtapi acm siggraph 2005 courses july 31august shihwei liao zhaohui du gansha wu gueiyuan lueh data computation transformations brook streaming applications multiprocessors proceedings international symposium code generation optimization p196207 march 2629 2006 nathan carr jesse hall john c hart ray engine proceedings acm siggrapheurographics conference graphics hardware september 0102 2002 saarbrucken germany solomon boulos dave edwards j dylan lacewell joe kniss jan kautz peter shirley ingo wald packetbased whitted distribution ray tracing proceedings graphics interface 2007 may 2830 2007 montreal canada v singh silver n cornea realtime volume manipulation proceedings 2003 eurographicsieee tvcg workshop volume graphics july 0708 2003 tokyo japan gregory johnson juhyun lee christopher burns william r mark irregular zbuffer hardware acceleration irregular data structures acm transactions graphics tog v24 n4 p14621482 october 2005 jrg schmittler ingo wald philipp slusallek saarcor hardware architecture ray tracing proceedings acm siggrapheurographics conference graphics hardware september 0102 2002 saarbrucken germany greg coombe mark j harris anselmo lastra radiosity graphics hardware proceedings 2004 conference graphics interface p161168 may 1719 2004 london ontario canada jrg schmittler sven woop daniel wagner wolfgang j paul philipp slusallek realtime ray tracing dynamic scenes fpga chip proceedings acm siggrapheurographics conference graphics hardware august 2930 2004 grenoble france nolan goodnight rui wang cliff woolley greg humphreys interactive timedependent tone mapping using programmable graphics hardware proceedings 14th eurographics workshop rendering june 2527 2003 leuven belgium ingo wald thiago ize andrew kensler aaron knoll steven g parker ray tracing animated scenes using coherent grid traversal acm transactions graphics tog v25 n3 july 2006 nolan goodnight rui wang cliff woolley greg humphreys interactive timedependent tone mapping using programmable graphics hardware acm siggraph 2005 courses july 31august feng liu scott owen ying zhu robert harrison irene weber web based molecular visualization using procedural shaders x3d acm siggraph 2005 web program july 31august naga k govindaraju brandon lloyd wei wang ming lin dinesh manocha fast computation database operations using graphics processors acm siggraph 2005 courses july 31august aaron e lefohn joe kniss charles hansen ross whitaker streaming narrowband algorithm interactive computation visualization level sets acm siggraph 2005 courses july 31august naga k govindaraju brandon lloyd wei wang ming lin dinesh manocha fast computation database operations using graphics processors proceedings 2004 acm sigmod international conference management data june 1318 2004 paris france jens krger rdiger westermann linear algebra operators gpu implementation numerical algorithms acm siggraph 2005 courses july 31august jens krger rdiger westermann linear algebra operators gpu implementation numerical algorithms acm transactions graphics tog v22 n3 july heiko friedrich johannes gnther andreas dietrich michael scherbaum hanspeter seidel philipp slusallek exploring use ray tracing future games proceedings 2006 acm siggraph symposium videogames p4150 july 3031 2006 boston massachusetts mark j harris greg coombe thorsten scheuermann anselmo lastra physicallybased visual simulation graphics hardware proceedings acm siggrapheurographics conference graphics hardware september 0102 2002 saarbrucken germany jeff bolz ian farmer eitan grinspun peter schrder sparse matrix solvers gpu conjugate gradients multigrid acm siggraph 2005 courses july 31august jeff bolz ian farmer eitan grinspun peter schroder sparse matrix solvers gpu conjugate gradients multigrid acm transactions graphics tog v22 n3 july vincent c h michael mccool low latency photon mapping using block hashing proceedings acm siggrapheurographics conference graphics hardware september 0102 2002 saarbrucken germany doug l james kayvon fatahalian precomputing interactive dynamic deformable scenes acm transactions graphics tog v22 n3 july r mark donald fussell realtime rendering systems 2010 acm siggraph 2005 courses july 31august ian buck tim foley daniel horn jeremy sugerman kayvon fatahalian mike houston pat hanrahan brook gpus stream computing graphics hardware acm transactions graphics tog v23 n3 august 2004 ingo wald solomon boulos peter shirley ray tracing deformable scenes using dynamic bounding volume hierarchies acm transactions graphics tog v26 n1 p6es january 2007 aaron e lefohn shubhabrata sengupta joe kniss robert strzodka john owens glift generic efficient randomaccess gpu data structures acm transactions graphics tog v25 n1 p6099 january 2006
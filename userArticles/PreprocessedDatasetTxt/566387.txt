polynomialtime computation via local inference relations consider concept local set inference rules local rule set automatically transformed rule set bottomup evaluation terminates polynomial time localruleset transformation gives polynomialtime evaluation strategies large variety rule sets cannot given terminating evaluation strategies known automatic technique article discusses three new results first shown every polynomialtime predicate defined unstratified local rule set second new machinerecognizable subclass local rule sets identified finally show locality property rule sets undecidable general b introduction conditions given set inference rules define computationally tractable inference relation syntactic question syntactic inference rules variety motivations identifying tractable inference relations first tractable inference relations sometimes provide decision procedures semantic theories example equational inference support national science foundation grants iis9977981 iis0093100 gratefully acknowl edged article revised expanded version paper appeared proceedings third international conference principles knowledge representation reasoning october 1992 pp 403 412 authors addresses r givan school electrical computer engineering purdue university 1285 ee build ing west lafayette 47907 email givanpurdueedu web httpwwwecepurdueedugivan mcallester att labs research p box 971 180 park avenue florham park nj 07932 email dmacresearchattcom web httpwwwresearchattcomdmac permission make digitalhard copy part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copyright notice title publication date appear notice given copying permission acm inc copy otherwise republish post servers redistribute lists requires prior specific permission andor fee r givan mcallester rules reflexivity symmetry transitivity substitutivity define tractable inference relation yields decision procedure entailment relation sets ground equations kozen 1977 shostak 1978 another example set equational horn clauses valid lattice theory special case results paper one show automatically validity latticetheoretic horn clause decidable cubic time deductive databases provide second motivation studying tractable inference relations deductive database designed answer queries using simple inference rules well set declared data base facts inference rules deductive database typically define tractable inference relationthese inference rules usually special form known datalog pro gram datalog program set firstorder horn clauses contain function symbols datalog program defines tractable inference relation ullman 1988 ullman 1989 interest generalizing inference rules used deductive databases beyond special case datalog programs general case function symbols allowed horn clause inference rules set inference rules viewed prolog program considerable work done bottomup evaluation strategies programs sourcetosource transformations make bottomup evaluation strategies efficient naughton ramakrishnan 1991 bry 1990 work presented local inference relations viewed extension optimization techniques example locality testing provides automatic sourcetosource transformation inference rules equality symmetry reflexiv ity transitive substitution allows completely evaluated bottomup fashion cubic time know automatic transformation inference rules provides terminating evaluation strategy rule set tractable rule sets also play important role typeinference systems computer programming languages talpin jouvelot 1992 jouvelot gifford 1991 although yet investigated connections notion locality used known results tractability type inference systems seems like fruitful area future research practical perspective seems possible generalpurpose bottomup evaluation strategies inference rules applied inference rules typeinference systems theoretical perspective show polynomialtime predicate defined local set inference rules many typeinference systems give polynomialtime decidable typability fourth motivation study tractable inference relations role relations play improving efficiency search many practical search algorithms use form incomplete inference prune nodes search tree knuth 1975 mackworth 1977 pearl korf 1987 incomplete inference also plays important role pruning search constraint logic programming jaffar lassez 1987 van hentenryck 1989 mcallester siskind 1991 tractable inference relations also used define notion obvious inference used socratic proof verification systems require proofs reduced obvious steps mcallester 1989 givan et al 1991 mentioned inference rules syntactically similar firstorder horn clauses fact inference rules naturally syntactically expressed 1 horn clause sorted firstorder logic r set horn clauses set ground atomic formulas f ground atomic formula write first order logic write rather r r r polynomialtime computation via local inference rules 3 think r set syntactic inference rules inference relation generated rules throughout paper use term rule set synonym finite set horn clauses give nontrivial conditions r ensure inference relation polynomialtime decidable noted rule set r contain function symbols called datalog pro gram wellknown inference relation defined datalog program polynomialtime decidable vardi immerman independently proved essence datalog programs provide characterization complexity class p polynomial time predicate finite databases written datalog program provided one given successor relation defines total order domain elements vardi 1982 immerman 1986 papadimitriou 1985 hella et al 1997 immerman 1999 although datalog programs provide interesting class polynomialtime inference relations class tractable rule sets much larger class datalog programs first one generalize concept datalog program concept superficial rule set call set horn clauses superficial term appears conclusion clause also appears premise clause superficial rule set property forwardchaining inference introduce new terms show paper superficial rule sets provide different characterization complexity class p datalog programs encode polynomialtime predicate ordered finite databases superficial rule sets encode polynomialtime predicate ground firstorder terms let predicate ground firstorder terms constructed finite signature define dag size firstorder term number distinct terms appear subexpressions 2 possible show computed polynomial time sum dag size arguments represented superficial rule set specifically prove predicate k ground firstorder terms exists superficial rule set r 1 k input predicate symbol accept distinguished proposition symbol characterization complexity class p terms superficial rule sets differs previous characterization p terms datalog programs two ways first result stated terms predicates ground terms rather predicates data bases second unlike datalog characterization separate total order domain elements required superficial rule sets special case general class local rule sets mcallester 1993 set r horn clauses local whenever exists proof f every term proof mentioned f r local polynomialtime decidable superficial rule sets local many local rule sets superficial set four inference rules equality local superficial local inference relations provide third characterization complexity class p let predicate ground firstorder terms constructed finite signature computed polynomial time sum 1 inference relation principle defined firstorder horn clauses expressing inference rules involving implicit substitution higher order matching somewhat awkward 2 dag size term size directed acyclic graph representation term r r r r 4 r givan mcallester dag size arguments exists local rule set r ground terms 1 qt 1 k q predicate symbol representing note superficial rule set property forwardchaining inference superficial rule set introduce new terms find characterization polynomialtime predicates terms local rule sets particularly pleasing described yields direct mapping semantic predicates predicates used inference rules unlike superficiality locality difficult recognize set four inference rules equality local proof fact nontrivial useful machinerecognizable subclasses local rule sets identified mcallester mcallester 1993 basin ganzinger basin ganzinger 1996 basin ganzinger 2000 former subclass semidecidable latter subclass decidable even semidecidable resulting procedures mechnically demonstrate tractability many natural rule sets interest inference rules equality introduce third semidecidable subclass contains variety natural rule sets contained either earlier classes briefly describe two earlier classes give examples rules sets included new class included earlier classes basin ganzinger identify class rule sets saturated respect orderings compatible subterm ordering notion saturation derived ordered resolution refer rule sets simply saturated saturation respect class sub termcompatible orders turns decidable property rule sets membership mcallester 1993 class new class identified semidecidable rule set classes exists proof locality certain restricted form different form two classes basin ganzinger identify subclass local rule sets saturated respect orderings compatible subterm ordering approach taken basin ganzinger different approach taken approach advantages primary advantage saturation approach relationship wellknown methods firstorder term rewriting theorem proving saturation viewed form ordered resolution second advantage saturation respect class orders compatible subterm ordering decidable subclass local rule sets given semidecidable third advantage saturation generalizes notion locality term orders subterm order approaches support completion process extending rule set adding derived rules resulting larger rule set desired subclass local rule sets procedures described mcallester93 one simply converts counterexample locality new derived inference rule primary advantage approach described paper saturation approach method described often yields smaller efficient rule sets example consider following rules 1 r x x polynomialtime computation via local inference rules 5 rules local rule set mcallesters class new class introduced saturated saturation adds least following rules 2 decision procedure based larger saturated set would still run time added rules significantly impact constant factors important issue practice semidecidable subclass local rule sets introduced mcallester 1993 called boundedlocal rule sets subclass defined carefully body paper comparison new subclass introduced set four basic rules equality boundedlocal another example boundedlocal rule set give following rules reasoning monotone operator sets sets let r f following set inference rules monotone operator simple sourcetosource transformation local rule set converts rule set superficial rule set without changing relation described example consider rules monotone operator transform rules derive information terms explicitly mentioned query introduce another predicate symbol intuitive meaning mentioned let r f following transformed version r f note r f superficial hence bottomup forwardchaining evaluation must terminate polynomial time 3 determine determine bottomup evaluation whether analogous transformation applies local rule set variety boundedlocal rule sets given mcallester 1993 example rule set local bounded local give following rules reasoning lattice 3 rule set bottomup evaluation run completion cubic time x z z x x x x x r f 6 r givan mcallester rules remain local monotonicity rule added without monotonicity rule rule set boundedlocal paper construct another useful semidecidable subclass local rule sets call inductivelylocal rule sets boundedlocal rule sets given mcallester 1993 also inductivelylocal procedure recognizing inductivelylocal rule sets implemented used determine rule set inductivelylocal hence inference relation defined rules 5 polynomialtime decidable since rules complete lattices result implies validity latticetheoretic horn clauses polynomialtime decidable believe boundedlocal rule sets inductivelylocal although present one found natural examples local rule sets fail inductivelylocal inductively local rule sets provide variety mechanically recognizable polynomialtime inference relations throughout paper claim ruleset either boundedlocal inductivelylocal fact demonstrated mechanically using techniques paper also settle open question previous analysis mcallester 1993 show locality general property rule sets undecidable hence optimization logic programs based recognition locality necessarily somewhat heuristic process 2 basic terminology section give precise definitions concepts discussed introduction definition 1 horn clause first order formula form atomic formulas set horn clauses r finite set ground atoms ground atomic formula f write whenever firstorder logic set universal closures horn clauses variety inference relations defined paper inference relation sets ground formulas g write g inference relation given direct syntactic characterization syntactic x x z x x z x z r u r polynomialtime computation via local inference rules 7 characterization useful determining locality following definitions lemma set ground atomic formulas f single ground atomic formula definition 2 derivation f using rule set r sequence ground atomic formulas n f exists horn clause r ground substitution sy formula form either member formula appearing earlier derivation lemma 1 exists derivation f using rule set r following restricted inference relation plays important role analysis locality definition 3 write exists derivation f every term appearing derivation appears subexpression f subexpression formula lemma 2 tractability lemma mcallester 1993 finite rule set r inference relation polynomialtime decidable proof let n number terms appear subexpressions f formula q predicatesymbol k arguments appears inference rules r n k formulas form qs 1 k since r finite maximum arity k predicate symbols appear r total number ground atomic formulas derived restrictions definition order n k given particular set derived ground atomic formulas one determine whether additional ground atomic formula derived checking whether rule r instance whose premises currently derived formulas rule k variables n k instances check instance checked polynomial time thus one extend set derived formulas checking polynomially many instances polynomial time set derived formulas extended polynomially many times lemma follows clearly converse hold general definition converse holds r local definition 4 mcallester 1993 rule set r local restricted inference relation unrestricted relation clearly r local polynomialtime decidable 3 characterizing p superficial rules section consider predicates firstorder terms computable polynomial time results stated require somewhat careful definition polynomialtime predicate firstorder terms r r r r r r f r 8 r givan mcallester definition 5 polynomialtime predicate terms predicate one firstorder terms computed polynomial time sum dag sizes arguments definition 6 rule set superficial term appears conclusion rule also appears premise rule theorem 1 superficial rule set representation theorem polynomialtime predicate k firstorder terms fixed finite signature exists superficial rule set r firstorder terms 1 n signature true arguments example consider acyclic predicate directed graphs predicate true directed graph graph cycles wellknown acyclicity polynomialtime property directed graphs property simple definition using superficial rules one level stratification graph cyclic acyclic theorem implies acyclicity predicate defined superficial rules without stratifica tion unstratified rule set acyclicity somewhat complex rather give give proof general theorem proof rather technical casual readers advised skip next section proof theorem 1 consider predicates one argument proof predicates higher arity similar let one argument polynomialtime computable predicate terms ie predicate terms one determine polynomial time dag size term whether holds general approach construct database property terms viewed polynomialtime computable property database since term extracted database computed get datalog program computing property database given total ordering database individuals using result immerman vardi immerman 1986 vardi 1982 proof finishes showing superficial rules given construct required database required ordering database individuals desired superficial rule set combination datalog program added rules constructing database ordering argue approach detail first describe database represent term subterm introduce database individual c ie new constant symbol unique term assumed predicate defined terms constructed fixed finite signature ie fixed finite set constant function symbols consider constants functions arguments function symbol f n arguments finite signature introduce database relation p f n1 arguments ie p f n1ary predicate symbol term define set ground formulas form subterm possibly equal set viewed database individuals c relations p f let g set formulas form sc c u u subterms represents successor relation individuals r c n polynomialtime computation via local inference rules 9 ie exists bijection r individuals consecutive integers ss u g 1 result immerman vardi immerman 1986 vardi 1982 implies polynomial time property p ordered databases exists datalog program r databases pd accept since term easily recovered set viewed polynomialtime property must exist datalog program r g accept assume without loss generality rule r derive new formulas involving database predicates p f r rules eliminated introducing duplicate predicates p f adding rules copy p f facts p f facts replacing p f p f rules add rule set r superficial rules construct formulas needed g rules use number auxiliary relation symbols computations assume names relation symbols chosen choice r occurrences relation symbols r first define mentioned predicate ms provable subterm second rule schema rules form f one finite number function symbols signature x one variables x 1 x n give rules via schema construct version formula set use subterms instead corresponding constants write collection rules construct formula set g use terms rather corresponding constants rules define successor relation subterms basic idea enumerate subterms depthfirst tree traversal starting root ignorning terms encountered earlier tree traversal done rule sets 11 12 rule sets rely various utility predicates must first define start defining simple subterm predicate su suu v provable u v subterms u subterm v second rule schema rules form within finite signature also need negation subterm predicate call ni define predicate first need define equal predicate ne neu v provable u v distinct subterms input r r r givan mcallester instances first rule schema must f g distinct function symbols second rule schema x occur argument position arguments f terms define predicate ni nis u subterm u give rules constants functions two arguments rules functions numbers arguments similar instances first rule schema must c constant symbol subterm input simultaneously define threeplace walk relation ws u w binary last relation ls u ws u w provable u subterms w u successor lefttoright preorder traversal subterms w elimination later duplicates ls u provable last term lefttoright preorder traversal subterms u elimination later duplicates definitions also use auxiliary threeplace relation ws u v ws u f w v means roughly u subterms v u comes preorder traversal v every term u traversal subterm w precisely ws u v inferred v form f xy occurrences u preorder traversal removing duplicates within occurrence u later occurrence terms occurrences traversal subterms x using w ni together see two different rules enables construction preorder traversal subterms x removed used construct preorder traversal f xy duplicates removed ylast ylast x l ylast f x xlast x l xlast f x ylast ylast x w flast ylast f x flast x l flast f x polynomialtime computation via local inference rules 11 finally define successor predicate terms w follows let r datalog program r plus superficial rules g accept inputt accept proof complete theorem 4 characterizing p local rules using theorem previous section one provide somewhat different characterization complexity class p terms local rule sets recall definition 4 rule set r local set ground atomic formulas single ground atomic formula f note tractability lemma lemma 2 implies immediately r local polynomialtime decidable theorem 2 local rule set representation theorem polynomialtime predicate firstorder terms exists local rule set r firstorder terms 1 k true arguments 1 k q predicate representing giving proof theorem give simple example local rule set polynomialtime problem contextfree language recognized cubic time fact easily proven giving translation grammars local rule sets represent string symbols using constant symbol symbol binary function cons construct terms represent lists symbols nonterminal symbol grammar introduce predicate two arguments p x indicate x strings symbols result removing prefix x parses category grammar production c c terminal symbol construct rule premises conclusion x grammar production b c following inference rule finally let p monadic predicate true strings generated distinguished start nonterminal grammar add following rule w w input z r f r r r 12 r givan mcallester 15 let r set inference rules r local rule set see first note rules maintain invariant p x derivable subterm x easy show use rule r derivable premises property every term appearing premise either top level subterm toplevel term also appears conclusion either top level subterm toplevel term implies proof p x mention terms x subterms includes rule set r also property x string language generated given grammar general methods analyzing order running time local rule sets used immediately give clauses run completion order n 3 time n length input string 4 implemented compiler converting local rule sets efficient inference procedures compiler used automatically generate polynomialtime parser inference rules proof theorem 2 prove theorem local inference relations preceding theorem superficial rule sets superficial ruleset representation theorem must exist superficial rule set r first order terms 1 k inputt 1 k accept input predicate symbol accept distinguished proposition symbol goal define local rule set r inputt 1 k accept qt 1 k predicate arguments appearing r let new predicate symbol km arguments define rule set r rule set containing following clauses given definition easily show qt 1 k remains show r local suppose must show let 1 k first k arguments f f qt 1 k either f case result trivial must also suffices prove result assuming f application primed version predicate appearing r every derivation based r involves formulas first k arguments particular given f must 4 analysis order running time decision procedures local inference relations given mcall ester 1993 r r x r r r f r r r polynomialtime computation via local inference rules 13 f set formulas 1 k first k argu ments let f result replacing formula f respectively since f must since r superficial every term derivation underlying inputt 1 either appears appears implies every term derivation appears either f thus theorem 2 5 another characterization locality section give alternate characterization locality characterization locality plays important role definition boundedlocal rule sets given mcallester 1993 notion inductivelylocal rule sets given next section definition 7 bounding set set ground terms every subterm member also member ie subtermclosed set terms definition 8 ground atomic formula called label formula bounding set every term member definition 9 bounding set define inference relation exists derivation f every formula derivation label formula term set set terms appearing subexpressions f formulas inference relation used give another characterization locality suppose r local case must exist f let set terms appear f must however since must finite superset consider growing bounding set one term time starting terms appear f definition 10 onestep extension bounding set ground term every proper subterm member definition 11 feedback event r consists finite set ground formulas ground formula f bounding set containing terms appear f onestep extension abuse notation feedback event written lemma 3 mcallester 1993 r local feedback events r proof first note r feedback event r local conversely suppose r local case r r ry ry r f ry ry r f r ry f r f ry ry f ry ry ry r f ry f 14 r givan mcallester f finite considering least one show feedback event exists r concepts bounded locality inductive locality involve concept feedback event define bounded locality first defining c r u set formulas r boundedlocal local exists natural number k whenever exists kstep shorter derivation c r u every term derivation member u mentioned set four basic inference rules equality boundedlocal moreover exists procedure determining given rule set kboundedlocal particular k hence exists semideci sion procedure verify locality boundedlocal rule set mcallester 1993 procedure sufficiently efficient practice verify locality large number bounded local rule sets local rule sets boundedlocal next section introduces intuctivelylocal rule sets new recursivelyenumerable subclass local rule sets 6 inductive locality define inductive locality first define notion feedback template feedback template represents set potential feedback events also define backward chaining process generates feedback templates rule set r show exists feedback event r event found backchaining process furthermore define induc tive termination condition backchaining process show backchaining process achieves inductive termination r local throughout section let r fixed arbitrary set horn clauses inference relation written understanding r implicit parameter relation define feedback templates ground objects contain ground firstorder terms formulas process generating feedback templates defined ground process deals ground instances clauses r ground process lifted using lifting transformation since lifting largely mechanical arbitrary ground procedures mcall ester siskind 1991 lifting operation discussed briefly definition 12 feedback template consists set ground atomic formulas multiset ground atomic formulas g ground atomic formula f bounding set u onestep extension f every formula label formula every formula g label formula u contains abuse notation feedback template written g f g multiset ground atomic formulas label formula u containing union g allow derivation f relative bounding set u feedback template potential feedback event sense extension allows derivation formulas g may result feedback event requirement g multiset needed templatebased induction lemma given feedback templates r constructed backward chaining r f ry ry ry ry polynomialtime computation via local inference rules 15 nondeterministic procedure generating template r 1 let 1 n f ground instance clause r 2 let term appears clause appear conclusion f appear proper subterm term clause 3 let bounding set contain contain every term clause 4 let set premises contain 5 let g set premises contain 6 return feedback template g f let 0 r set feedback templates derived r application procedure leave reader verify 0 r set feedback templates consider feedback template g f feedback template g f statement exists proof f local u multiset ulocal premises multiset g u alocal premises following procedure defines method constructing new template backchaining alocal premise given template nondeterministic procedure backchaining g f 1 let q member g 2 nondeterministically choose ground instance 1 n q clause r q conclusion label formula u 3 let plus premises contain 4 let g g minus q plus premises contain 5 return template g f note need clauses satisfying condition step 2 procedure case possible executions templates generated step 4 procedure g constructed using multiset operations example multiset g contains two occurrences q g minus q contains one occurrence q need g multiset order guarantee certain backchaining operations commute proof induction lemma particular use fact sequence backchaining operations remove element q g point exists permutation sequence backchaining operations producing resulting template removes q first set feedback templates define bt plus templates derived element application backchaining procedure important keep mind definition bt contains let b n bb bt n applications b definition 13 feedback template called critical g empty r givan mcallester f critical template f f f feedback event abuse notation critical template f f called feedback event following lemma provides motivation definition feedback template backchaining process lemma 4 exists feedback event r exists j b j 0 contains feedback event proof reverse direction trivial prove forward direction suppose exists feedback event r let f minimal feedback event r ie feedback event r minimizes length derivation f bounding set u fact feedback event minimal implies every formula derivation f contains see suppose q formula derivation f involve q q f one two must feedback event otherwise would f one feedback event involves smaller derivation f contradicts assumption f minimal since every formula f derivation underlying f contains template f derived backchaining steps mirroring derivation lemma implies rule set local backchaining uncover feedback event however primarily interested cases rule set local backchaining process establish locality must find termination condition guarantees locality let set feedback templates practice taken j define selfjustification property sets feedback templates prove selfjustifying n b n contain feedback event defining selfjustification property treat template independent induction hypothesis template justified using set templates induction hypotheses set selfjustifying definition 14 write g f contains templates subset g subset g 1 2 k f definition 15 set templates said justify template g f exists q g template g f generated one step backchaining g f selecting q step 1 backchaining procedure ty ty polynomialtime computation via local inference rules 17 definition 16 set called selfjustifying every member either critical justified contain feedback events theorem 3 templatebased induction theorem selfjustifying set contains feedback event proof consider selfjustifying set templates must show every critical template f proof induction n consider critical template f b n assume theorem critical templates b j j less n critical template f must derived backchaining template g f note must subset g empty equals f selfjustifying thus cannot contain feedback events g empty since selfjustifying choose q g template g f derived g f single step backchaining q g f noted backchaining operations commute ensure took g multiset rather set commutativity backchaining steps exists backchaining sequence g f f first step sequence backchaining step q let g f template results first backchaining step g f note subset must g f definition must contain templates subset g subset g 1 2 k f note subset since g subset g must sequence fewer n backchaining steps leads critical template subset critical template member b j less n induction hypothesis template cannot feedback event consequence thus templatebased induction theorem following corollary follows theorem 3 along lemmas 3 4 corollary 1 b n 0 r selfjustifying n r local come main definition theorem section definition 17 rule set r called inductivelylocal exists n b n 0 selfjustifying ty ty r givan mcallester theorem 4 exists procedure given finite set r horn clauses terminate feedback event whenever r local terminate success whenever r inductivelylocal fail terminate cases r local inductivelylocal proof procedure derived lifting ground procedure computing lifting formalized mechanical operation arbitrary nondeterministic ground procedures mcallester siskind 1991 lifted procedure maintains set possibly nonground templates g f template must satisfy conditions occurs toplevel argument every atom g occur f every term phi occurs u lifted template represents set ground templates derived applying subsitution lifted template specifically set ground terms u let cu denote u plus subterms f terms u lifted feedback template represents set wellformed feedback templates form ss sg sfnote expressions form need wellformed feedback templates eg might st equals sa occurs however ss sg sf wellformed feedback template say covered lifted template prove theorem 4 first show exists finite set lifted templates set ground templates covered lifted set exactly 0 r done lifting procedure generating 0 r ie step procedure made nondeterministically generate lifted object expression possibly containing variables way ground feedback event nondeterministically generated ground procedure covered lifted feedback event nondeterministically generated lifted procedure example first step procedure generating 0 r simply nondeterministically selects one lifted rules r step 2 selects unifiable subset toplevel subterms premise clause general unifier set applied clause taken result applying unifier one selected terms steps 3 4 5 6 computed deterministically specified given finite set lifted templates covering possibly infinite ground set procedure generating bt modified generate finite set lifted templates covers exactly bt lifted nondeterministic backchaining procedure starts lifted feedback template nondeterministically selects step 2 rule whose conclusion unifiable atom g unification violates part definition feedback event execution fails example unification might identify subterm term thus fail steps 3 4 preceeded step nondeterministically selects subset top level terms occuring 1 n identify general unifier terms applied expressions part definition feedback template violated execution fails steps 3 4 5 computed specified get b n 0 r represented finite set lifted tem plates finally definition 15 also lifted speak lifted template justified finite set lifted templates r inductively local exists n finite set lifted templates representing b n 0 r selfjus tifying given n decidable theorem 4 follows csy csy polynomialtime computation via local inference rules 19 implemented resulting lifted procedure used verify locality variety rule sets including instance rule set given equation 5 reasoning lat tices procedure also useful designing local rule sets applied nonlocal rule set procedure returns feedback event often used design additional rules added rule set give local rule set computing inference relation 7 locality undecidable prove locality undecidable reducing halting problem theorem 5 problem deciding locality rule set r undecidable let specification turing machine first show one mechanically construct local rule set r property machine halts exists term h monadic predicate symbol turing machine computations represented firstorder terms formula ht intuitively states term representing halting computation prove preliminary result first construct superficial rule set halts exists term inputt ht mechanical construction superficial rule set turing machine fairly straightforward given convert superficial rule set local rule set r follows predicate arguments appearing let new predicate symbol m1 arguments rule set r constructed 1 inputt qt define rule set r rule set containing following clauses clause form design r easily show qt 1 inputt qt 1 directly follows inputt ht turing machine halts term desired proof rule set r local closely follows proof r local local rule set representation theorem proven theorem 2 constructed local rule set r property halts exists term let r r plus single clause hx halts halts new proposition symbol claim local halt first note halts r local conversely suppose halt case must show r local suppose must show suppose f formula halts case equivalent since r local must thus r q r q x input x x r r r r r halts r r f r r f r f 20 r givan mcallester suppose f formula halts halts member result trivial assume halts since must term c implies thus show suffices show c mentioned preceding argument since rule set r generated construction given every inference based clause r every formula inference first argument implies set formulas c first argument assumed halt thus hence must empty since every formula mentions c contained conclude must mention c thus since 8 open problems closing note open problems many known examples rule sets local yet corresponding inference relation polynomialtime decidable cases studied exists conservative extension rule set local conjecture every rule set r polynomialtime decidable exists local conservative extension r problems less precise one find natural rule set local inductively local related question whether useful machine recognizable subclasses local rule sets classes boundedlocal inductivelylocal rule sets acknowledgements would like thank franz baader invaluable input discussions robert givan supported part national science foundation awards 9977981iis 0093100iis 9 r automated complexity analysis based ordered resolution automated complexity analysis based ordered resolution query evaluation recursive databases bottomup topdown rec onciled natural language based inference procedures applied schuberts steamroller define linear order finite models relational queries computable polynomial time descriptive complexity constraint logic programming algebraic reconstruction types effects estimating efficiency backtrack programs complexity finitely presented algebras consistency networks relations lifting trans formations knowledge representation system mathe matics automatic recognition tractability inference relations note expressive power prolog search techniques algorithm reasoning equality type effect systems principles database knowledgebase systems constraint satisfaction logic programming complexity relational query languages tr relational queries computable polynomial time constraint logic programming principles database knowledgebase systems vol constraint satisfaction logic programming bottomup beats topdown datalog ontic knowledge representation system mathematics query evaluation recursive databases bottomup topdown reconciled algebraic reconstruction types effects automatic recognition tractability inference relations algorithm reasoning equality automated complexity analysis based ordered resolution complexity analysis based ordered resolution complexity relational query languages extended abstract complexity finitely presented algebras lifting transformations
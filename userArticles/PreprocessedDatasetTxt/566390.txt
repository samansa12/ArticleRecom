boolean satisfiability transitivity constraints consider variant boolean satisfiability problem subset epsiv propositional variables appearing formula fsat encode symmetric transitive binary relation n elements relational variables eij 1 j n expresses whether relation holds elements j task either find satisfying assignment fsat also satisfies transitivity constraints relational variables eg e12 wedge e23 e13 prove assignment exists solving satisfiability problem final difficult step decision procedure logic equality uninterpreted functions procedure forms core tool verifying pipelined microprocessorsto use conventional boolean satisfiability checker augment set clauses expressing fsat clauses expressing transitivity constraints consider methods reduce number clauses based sparse structure relational variablesto use ordered binary decision diagrams obdds show sets epsiv obdd representation transitivity constraints exponential size possible variable orderings considering relational variables occur obdd representation fsat experiments show readily construct obdd representation relevant transitivity constraints thus solve constrained satisfiability problem b introduction consider following variant boolean satisfiability problem given boolean formula f sat set variables v subset symbolically encodes binary relation n elements reflexive symmetric transitive relational variables whether relation holds elements j typically e sparse containing much fewer nn gamma 12 possible variables note e ij 62 e value j imply relation hold elements j simply indicates f sat directly depend relation elements j transitivity constraint formula form denote set transitivity constraints formed relational variables task find assignment v f0 1g satisfies f sat well every constraint transe goel et al gszas98 shown problem nphard even f sat given ordered binary decision diagram obdd bry86 normally boolean satisfiability trivial given obdd representation formula motivated solve problem part tool verifying pipelined microprocessors vb99 tool abstracts operation datapath set uninterpreted functions uninterpreted predicates operating symbolic data prove pipelined processor behavior matching unpipelined reference model using symbolic flushing technique developed burch dill bd94 major computational task decide validity formula fver logic equality uninterpreted functions bgv99a bgv99b decision procedure transforms fver first replacing function application terms terms set domain variables fv j1 ng similarly predicate applications replaced formulas set newlygenerated propositional variables result formula f ver containing equations form v equations encoded introducing relational variable e ij similar method proposed goel et al gszas98 result translation propositional formula encf ver expressing verification condition relational variables propositional variables appearing f ver let f sat denote encf ver complement formula expressing translated verification condition capture transitivity equality eg v transitivity constraints form e ij e jk e ik finding satisfying assignment f sat also satisfies transitivity constraints give us counterexample original verification condition fver hand prove assignments proved fver universally valid consider three methods generate boolean formula f trans encodes transitivity constraints direct method enumerates set chordfree cycles undirected graph edge relational variable e method avoids introducing additional relational variables lead formula exponential size dense method uses relational variables e ij possible values j 1 axiomatize transitivity forming constraints form e ij e jk e ik distinct values j k yield formula cubic n sparse method augments e additional relational variables form set variables resulting graph chordal rose70 require transitivity constraints form e ij e jk e ik sparse method guaranteed generate smaller formula dense method use conventional boolean satisfiability sat procedure solve constrained satisfiability problem run checker set clauses encoding f sat f trans latest version fgrasp sat checker m99 able complete benchmarks although run times increase significantly transitivity constraints enforced using ordered binary decision diagrams evaluate satisfiability could generate obdd representations f sat f trans use apply algorithm compute obdd representation conjunction obdd finding satisfying solutions would trivial show approach feasible general obdd representation f trans intractable sets relational variables obdd representation transitivity constraint formula f trans exponential size regardless variable ordering npcompleteness result goel et al shows obdd representation f trans may exponential size using ordering previously selected representing f sat obdd leaves open possibility could variable ordering would yield efficient obdd representations f sat f trans result shows transitivity constraints intrinsically intractable represent obdds independent structure f sat present experimental results complexity constructing obdds transitivity constraints arise actual microprocessor verification results show obdds indeed quite large consider two techniques avoid constructing obdd representation transitivity constraints first proposed goel et al gszas98 generates implicants cubes f sat rejects violate transitivity constraints although method suffices small benchmarks find number implicants generated larger benchmarks grows unacceptably large second method determines relational variables actually occur obdd representation f sat apply one three techniques encoding transitivity constraints order generate boolean formula transitivity constraints reduced set relational variables obdd representation formula generally tractable even larger benchmarks benchmarks benchmarks vb99 based applying verifier set highlevel microprocessor designs based dlx risc processor described hennessy patterson hp96 1thetadlxc singleissue fivestage pipeline capable fetching one new instruction every clock cycle implements six instruction types registerregister registerimmediate circuit domain propositional equations variables variables buggy min 22 56 89 2thetadlxcc avg 25 69 124 max table 1 microprocessor verification benchmarks benchmarks suffix modified require enforcing transitivity load store branch jump pipeline stages fetch decode execute memory writeback interlock causes instruction following load stall one cycle requires loaded result branches jumps predicted nottaken 3 instructions squashed misprediction example comparable dlx example first verified burch dill bd94 2thetadlxca complete first pipeline capable executing six instruction types second pipeline capable executing arithmetic instructions 0 2 new instructions issued cycle depending types source registers well types destination registers preceding instructions example comparable one verified burch bur96 2thetadlxcc two complete pipelines ie execute six instruction types four load interlocksbetween load execute either pipeline instruction decode either pipeline cycle 0 2 instructions issued examples domain variables v 1 n f ver encode register identifiers described bgv99a bgv99b encode symbolic terms representing program data addresses distinct values avoiding need equations among variables equations arise modeling read write operations register file bypass logic implementing data forwarding load interlocks pipeline issue logic original processor benchmarks verified without enforcing transitivity con straints unconstrained formula f sat unsatisfiable every case nonetheless motivated study problem constrained satisfiability two reasons first processor designs might rely transitivity eg due sophisticated issue logic second aid designers debugging pipelines essential generate counterexamples satisfy transitivity constraints otherwise designer unable determine whether counterexample represents true bug weakness verifier create challenging benchmarks generated variants circuits require enforcing transitivity verification example normal forwarding logic execute stage 1thetadlxc must determine whether forward result memory stage instruction either one operands execute stage instruction comparing two source registers esrc1 esrc2 instruction execute stage destination register mdest instruction memory stage modified circuit changed bypass condition esrc1mdest esrc1mdest esrc1esrc2esrc2mdest given transitivity two expressions equivalent pipeline introduced four modifications forwarding logic different combinations source destination registers modified circuits named 1thetadlxct 2thetadlxcat 2thetadlxcct study problem counterexample generation buggy circuits generated 105 variants 2thetadlxcc containing small modification control logic 5 found functionally correct eg modification caused processor stall un necessarily yielding total 100 benchmark circuits counterexample generation table 1 gives statistics benchmarks number domain variables n ranges 13 25 number equations ranges 27 143 verification condition formulas f ver also contain 42 77 propositional variables expressing operation control logic variables plus relational variables comprise set variables v propositional formula f sat circuits modifications require enforcing transitivity yield formulas containing 19 additional equations final three lines summarize complexity 100 buggy variants 2thetadlxcc apply number simplifications generation formula f sat hence small changes circuit yield significant variations formula complexity 3 graph formulation definition transe equation 1 places restrictions length form transitivity constraints hence infinite number show construct graph representation relational variables identify reduced set transitivity constraints satisfied guarantees possible transitivity constraints satisfied introducing relational variables alter graph structure reducing number transitivity constraints must considered variable set e define undirected graph ge containing vertex edge variable e assignment boolean values relational variables define labeled graph ge graph ge edge labeled 1edge e ij 0edge e ij path sequence vertices edges successive elements element p sequence 1 p successive pair elements forms edge consider edge also part path cycle path form proposition 1 assignment variables e violates transitivity cycle ge contains exactly one 0edge proof suppose cycle letting 1 vertex one end 0edge trace around cycle giving sequence vertices vertex end 0edge assignment e j j1 hence violates equation 1 suppose assignment violates transitivity constraint given equation 1 construct cycle vertices edge path said acyclic said simple prefix proposition 2 assignment variables e violates transitivity simple cycle ge contains exactly one 0edge proof portion proof covered proposition 1 portion proved induction number variables antecedent transitivity constraint equation 1 assume transitivity constraint containing k variables antecedent violated violated constraints least k variables antecedents values p q 1 cycle values p q exist form transitivity constraint transitivity constraint contains fewer k variables antecedent also violated contradicts assumption violated transitivity constraint fewer k variables antecedent 2 define chord simple cycle edge connects two vertices adjacent cycle precisely simple cycle chord edge ge 1 cycle said chordfree simple chords proposition 3 assignment variables e violates transitivity chord contains exactly one 0edge proof portion proof covered proposition 1 portion proved induction number variables antecedent transitivity constraint equation 1 assume transitivity constraint k variables violated transitivity constraint fewer variables antecedent violated values p q variable e p q corresponding cycle chordfree values p q exist consider two cases illustrated figure 1 0edges shown dashed lines 1edges shown solid lines wavy lines 0edge 1edge figure 1 case analysis proposition 3 0edges shown dashed lines cycle representing transitivity violation contains chord find smaller cycle also represents transitivity violation represent sequences 1edges case 1 edge 0edge shown left transitivity constraint violated fewer k variables antecedent case 2 edge 1edge shown right transitivity constraint violated fewer k variables cases contradict assumption violated transitivity constraint fewer k variables antecedent 2 length k cycle given following clauses clause derived expressing equation 1 disjunction 2 set relational variables e define f trans e conjunction transitivity constraints chordfree cycles graph ge theorem 1 assignment relational variables e satisfy transitivity constraints given equation 1 satisfies f trans e theorem follows directly proposition 3 encoding given equation 2 31 enumerating chordfree cycles enumerate chordfree cycles graph exploit following properties acyclic path said chord edge classify chordfree path terminal ge extensible otherwise proposition 4 path chordfree terminal cycle chordfree follows noting conditions imposed chordfree path identical chordfree cycle except latter includes closing edge proper prefix path proposition 5 every proper prefix chordfree path chordfree extensible clearly prefix chordfree path also chordfree prefix terminal attempt add edge would yield either simple cycle path chord given properties enumerate set chordfree paths breadth first expan sion enumerate paths also generate c set chordfree cycles define p k set extensible chordfree paths k vertices 1 k n initially given set p k generate set p k1 add cycles length k 1 c path consider path edge classify path cyclic edge classify path chord edge add cycle c otherwise add path p k1 generating paths use set c generate set chordfree cycles terminal chordfree cycle k vertices 2k members c k edges cycle serve closing edge cycle traverse closing edge either direction generate set clauses given equation 2 simply need choose one element c closing edge eg considering cycles figure 2 indicates exponential number chordfree cycles graph particular figure illustrates family graphs 3n vertices consider cycles passing n diamondshaped faces well edge along bottom diamondshaped face f cycle pass either upper vertex lower vertex thus 2 n cycles addition edges forming perimeter face f create chordfree cycle giving total cycles columns labeled direct table 2 show results enumerating chordfree cycles benchmarks correct microprocessor two graphs one transitivity constraints played role verification one indicated end name modified require enforcing transitivity constraints summarize results transitivity oe ae figure 2 class graphs many chordfree cycles graph n diamondshaped faces cycles circuit direct dense sparse edges cycles clauses edges cycles clauses edges cycles clauses 1thetadlxct 37 95 348 78 286 858 42 68 204 2thetadlxcct 143 2136 8364 300 2300 6900 193 858 2574 full min 89 1446 6360 231 1540 4620 132 430 1290 buggy avg 124 2562 10270 300 2300 6900 182 750 2244 table 2 cycles original augmented benchmark graphs results given three different methods encoding transitivity constraints constraints 100 buggy variants 2thetadlxcc terms minimum average maximum measurement also show results five synthetic benchmarks consisting n theta n planar meshes n n ranging 4 8 mesh figure 3 circuit benchmarks number cycles although large appears manageable moreover cycles 4 edges synthetic benchmarks hand demonstrate exponential growth predicted worst case behavior number cycles grows quickly meshes grow larger furthermore cycles much longer causing number clauses grow even rapidly 32 adding relational variables enumerating transitivity constraints based variables e runs risk generating boolean formula exponential size guarantee polynomial growth considering larger set relational variables general let e 0 set relational variables let f trans transitivity constraint formula generated enumerating chordfree cycles graph ge 0 theorem 2 e set relational variables f sat f trans e satisfiable f sat f trans introduce series lemmas prove theorem propositional formula f set variables assignment f0 1g define valuation f denoted result evaluating formula f according assignment first prove extend assignment set relational variables one superset variables yielding identical valuations transistivity constraint formulas lemma 1 sets relational variables e 1 e 2 assignment 1g f trans assignment f trans proof consider case g general statement proposition holds induction je assignment 2 graph ge 1 path 1edges node node j consider two cases 1 2 e ij cycle ge must contain 0edge e ij hence adding edge introduce transitivity violations 2 2 e ij must path p 1 1edges nodes j order introduction 1edge e ij create transitivity violation must also path p 2 nodes j ge exactly one 0 edge could concatenate paths p 1 p 2 form cycle ge exactly one 0edge implying f trans conclude therefore adding 1edge e ij introduce transitivity violationslemma 2 assignment f trans also f trans proof note cycle ge must present ge edge labeling thus ge cycle single 0edge neither ge return proof theorem 2 proof suppose f sat f trans e satisfiable ie assignment f sat 1 lemma 1 find assignment 0 f trans furthermore since construction 0 lemma 1 preserves values assigned variables e relational variables occurring f sat conclude f sat suppose hand f sat f trans assignment 0 f sat hence f sat f trans e satisfiable 2 goal add relational variables possible order reduce size transitivity formula continue use path enumeration algorithm generate transitivity formula 33 dense enumeration dense enumeration method let en denote set variables e ij values j 1 graph gen complete undirected graph graph cycle length greater three must chord hence algorithm enumerate transitivity constraints form e ij e jk e ik distinct values j k graph yielding total columns labeled dense table 2 show complexity method benchmark circuits smaller graphs 1thetadlxc 1thetadlxct 4 5 method yields clauses direct enumeration cycles original graph larger graphs however yields fewer clauses advantage dense method evident mesh graphs cubic complexity far superior exponential 34 sparse enumeration improve methods exploiting sparse structure ge like dense method want introduce additional relational variables give set variables resulting graph graph property every cycle length greater three chord chordal graphs studied extensively context sparse gaussian elimination fact problem finding minimum set additional variables add set identical problem finding elimination ordering gaussian elimination minimizes amount fillin although problem npcomplete yan81 good heuristic solutions satisfiable secs satisfiable secs full min buggy avg 125 1517 23 table 3 performance fgrasp benchmark circuits results given without transitivity constraints particular implementation proceeds series elimination steps step remove vertex graph every pair distinct uneliminated vertices j k graph contains edges j k add edge j already exist original graph plus added edges forms chordal graph choose vertex eliminate given step implementation uses simple heuristic choosing vertex minimum degree one vertex minimum degree choose one minimizes number new edges added columns table 2 labeled sparse show effect making benchmark graphs chordal method observe method gives superior results either two methods implementation therefore used sparse method generate transitivity constraint formulas satbased decision procedures boolean satisfiability sat checkers take input formula expressed clausal form clause set literals literal either variable complement clause denotes disjunction literals task checker either find assignment variables satisfies clauses determine assignment exists solve constrained satisfiability problem using conventional sat checker generating set clauses c trans representing f trans set clauses c sat representing formula f sat run checker combined clause set c sat c trans find satisfying solutions experimenting number boolean satisfiability checkers found fgrasp ms99 best overall performance recent version directed periodically restart search using randomlygenerated variable assignment m99 first sat checker tested complete benchmarks experiments conducted 336 mhz sun ultrasparc ii 12gb primary memory indicated table 3 ran fgrasp clause sets c sat c trans c sat ie without transitivity constraints benchmarks 1thetadlxc 2thetadlxca 2thetadlxcc formula f sat unsatisfiable seen including transitivity constraints increases run time significantly benchmarks 1thetadlxct 2thetadlxcat 2thetadlxcct formula f sat satisfiable transitivity enforced add clauses f trans formula becomes unsatisfiable buggy circuits run times c sat range 1 second 36 minutes run times c trans c sat range less one second 12 hours cases adding transitivity constraints actually decreased time much factor 5 cases cpu time increased much factor 69 average using geometric mean adding transitivity constraints increased time factor 23 therefore conclude satisfiability checking transitivity constraints difficult conventional satisfiability checking added complexity overwhelming 5 obddbased decision procedures simpleminded approach solving satisfiability transitivity constraints using obdds would generate separate obdd representations f trans f sat could use apply operation generate obdd f trans f sat either find satisfying assignment determine function unsatisfiable show sets relational variables e obdd representation f trans e large represent manipulate experiments use cudd obdd package dynamic variable reordering sifting 51 lower bound obdd representation f trans e prove sets e obdd representation f trans e may exponential size possible variable orderings mentioned earlier npcompleteness result proved goel et al gszas98 implications complexity representing f trans e obdd showed given obdd g sat representing formula f sat task finding satisfying assignment f sat also satisfies transitivity constraints transe npcomplete size g sat assuming p 6 np infer obdd representation f trans e may exponential size using variable ordering used g sat result extends lower bound arbitrary variable orderings independent vs np problem let n denote planar mesh consisting square array n theta n vertices example figure 3 shows graph planar graph edges partition plane faces shown figure 3 label f ij 1 1 total n faces one see set edges forming border face forms chordfree cycle n shown table 2 many cycles also chordfree eg perimeter rectangular region height width greater 1 consider cycles f 11 f 12 f 13 f 14 f 15 f 31 f 32 f 33 f 34 f 35 f 41 f 42 f 43 f 44 f 45 f 51 f 52 f 53 f 54 f 55 figure 3 mesh graph 6 corresponding single faces nthetan set relational variables corresponding edges n f trans e nthetan encoding transitivity constraints variables theorem 3 obdd representation f trans e nthetan must vertices prove theorem consider ordering variables representing edges n let denote first half ordering b denote second half classify face according four edges forming border b b c others b called split faces observe cannot type face adjacent type b face since shared edge cannot b therefore must split faces separating region type faces region type b faces example figure 4 shows three possible partitionings edges 6 resulting classification faces let b c denote number faces respective type see always c particular minimum value c achieved partitioning edges corresponds partitioning graph region type faces region type b faces nearly equal size split faces forming boundary two regions c figure 4 partitioning edges sets solid b dashed face classified type solid b dashed c mixed lemma 3 partitioning edges mesh graph n equallysized sets b must least n gamma 32 split faces note lower bound somewhat weakit seems clear must c n gamma 1 however weaker bound suffice prove exponential lower bound obdd size proof proof adaptation proof leighton lei92 theorem 121 n bisection bandwidth least n one would remove least n edges split graph two parts equal size observe n n 2 vertices 2nn gamma 1 edges edges split nn gamma 1 nn gamma 1 b let n denote planar dual n contains vertex u ij face f ij n edges pairs vertices corresponding faces n common edge fact one readily see graph isomorphic ngamma1 partition vertices n sets u u b u c according types corresponding faces let b c denote number elements sets face n four bordering edges edge border two faces thus upper bound must 4a 2nn gamma 1 giving nn gamma 12 similarly b addition since face type cannot adjacent n one type b vertex u adjacent one u b consider complete directed bipartite graph edges set u theta u b u b theta u ie total 2ab edges given bounds 12 minimum value 2ab achieved either giving lower bound embed bipartite graph n forming path vertex u ij vertex either u ij 2 u u viceversa convention use path first follows vertical edges u 0 j follows horizontal edges u 0 j 0 must least one vertex u c along path therefore removing vertices u c would cut 2ab paths vertex u ij 2 u c bound total number paths passing separately considering paths enter bottom top left right entering bottom vertices gamma 1 destination vertices giving paths quantity maximized giving upper bound n gamma 1 3 4 similar argument shows n gamma 1 3 4 paths entering top vertex paths entering left j vertices n gamma destinations giving j gamma 1n paths quantity maximized giving upper bound n gamma 1 3 4 bound also holds paths entering right thus removing single vertex would cut n gamma 1 3 paths combining lower bound number paths 2ab upper bound number paths cut removing single vertex fact removing c vertices rewrite values n set faces said edge independent two members set share edge lemma 4 partitioning edges mesh graph n equallysized sets b must edgeindependent set split faces containing least n gamma 34 elements proof classify parity face f ij even even odd otherwise observe two faces parity common edge divide set split faces two subsets even parity odd subsets edge independent one must least 12 elements set split faces 2 complete proof theorem 3 proof suppose edgeindependent set k split faces split face choose one edge one edge b bordering face value 2 f0 1g k define assignment ff respectively fi variables representing edges resp b follows edge e part k split faces define ff 0 edge e part split face one ones chosen specially let ff 1 edge e chosen variable face let ff give us assignment ff delta fi variables evaluates 1 independent split face f two 1edges cycles graph least two 0edges hand z 2 f0 1g k 6 z assignment ff delta fi z cause evaluation 0 face 6 z one edge assigned value 1 thus set assignments fff jy 2 f0 1g k g forms obdd fooling set defined bry91 implying obdd must least 2 k 2 ngamma34 seen adding relational variables reduce number cycles therefore simplify transitivity constraint formula raises question adding relational variables affects bdd representation transitivity constraints unfortunately exponential lower bound still holds corollary 1 set relational variables e e nthetan e obdd representation f trans e must vertices extra edges e introduce complications create cycles containing edges different faces result lower bound weaker define set faces vertex independent two members share vertex lemma 5 partitioning edges mesh graph n equalsized sets b must vertexindependent set split faces containing least n gamma 38 elements proof partition set split faces four sets ee eo oe oo face f ij assigned set according values j ee j even eo even j odd oe odd j even oo j odd sets vertex independent least one sets must contain least 14 elements since least n gamma 32 split faces one sets must contain least vertexindependent split faces 2 prove corollary 1 proof ordering variables e partition two sets b come b number variables e nthetan equally split b suppose vertexindependent set k split faces value 2 f0 1g k define assignments ff variables fi variables b assignments defined proof theorem 3 addition variable e ij nthetan assigned value 0 consider set assignments ff delta fi z values z 2 f0 1g k cycles ge ff delta fi z less two 0edges corresponding perimeters split faces proof theorem 3 set fff jy 2 f0 1g k g forms obdd fooling set defined bry91 implying obdd must least 2 k 2 ngamma38 lower bounds fairly weak reflection difficulty proving lower bounds found practice obdd representations transitivity constraint functions arising benchmarks tend large relative encountered evaluation f sat example although obdd representation f trans 1thetadlxct 2692 nodes function 42 variables unable construct obdd representations function either 2thetadlxcat 178 variables 2thetadlxcct 193 variables despite running 24 hours 52 enumerating eliminating violations goel et al gszas98 proposed method generates implicants cubes function f sat obdd representation implicant examined discarded violates transitivity constraint experiments found approach works well normal correctly designed pipelines ie circuits 1thetadlxc 2thetadlxca 2thetadlxcc since formula f sat unsatisfiable hence implicants 100 buggy circuits first implicant generated contained transitivity violation hence valid counterexample circuits require enforcing transitivity constraints found approach im practical example verifying 1thetadlxct means generated 253216 implicants requiring total 35 seconds cpu time vs 02 seconds 1thetadlxc benchmarks 2thetadlxcat 2thetadlxcct program ran 24 hours without generated implicants contrast circuits 2thetadlxca 2thetadlxcc verified 11 29 seconds respectively implementation could improved making sure generate implicants irredundant prime general however believe verifier generates individual implicants robust complex control logic pipeline lead formulas f sat containing large numbers implicants even transitivity plays minor role correctness design 53 enforcing reduced set transitivity constraints one advantage obdds representations boolean functions readily determine true support function ie set variables function depends leads strategy computing obdd representation f sat intersecting support e give set relational variables could potentially lead transitivity violations augment variables make graph chordal yielding set variables circuit verts direct dense sparse edges cycles clauses edges cycles clauses edges cycles clauses 1thetadlxct 9 reduced min 3 buggy avg 12 17 19 75 73 303 910 21 14 42 2thetadlxcc max 19 52 378 1512 171 969 2907 68 140 420 table 4 graphs reduced transitivity constraints results given three different methods encoding transitivity constraints based variables true support f sat circuit obdd nodes cpu reduced min 20 1 20 7 buggy avg 3173 1483 25057 107 2thetadlxcc max 15784 93937 438870 2466 table 5 obddbased verification transitivity constraints generated reduced set variables generate obdd representation f trans satisfiable generate counterexample table 4 shows complexity graphs generated method benchmark cir cuits comparing full graphs shown table 2 see typically reduce number relational vertices ie edges factor 3 benchmarks modified require transitivity even greater factor buggy circuit benchmarks resulting graphs also sparse example see direct sparse methods encoding transitivity constraints greatly outperform dense method table 5 shows complexity applying obddbased method bench marks original circuits 1thetadlxc 2thetadlxca 2thetadlxcc yielded formulas f sat unsatisfiable hence transitivity constraints required 3 modified circuits 1thetadlxct 2thetadlxcat 2thetadlxcct interesting reduction number relational variables makes feasible generate obdd representation transitivity constraints compared benchmarks 1thetadlxc 2thetadlxca 2thetadlxcc see significant although tolerable increase computational requirement verify modified circuits attributed complex control logic need apply transitivity constraints 100 buggy variants 2thetadlxcc f sat depends 52 relational variables average 17 yielded obdds f trans ranging 93937 nodes average 1483 obdds f sat f trans ranged 438870 nodes average 25057 showing adding transitivity constraints significantly increase complexity obdd representation however one obdd end sequence obdd operations worst case imposing transitivity constraints increased total cpu time factor 2 average increased 2 memory required generate f sat ranged 98 509 mb average 155 even worst case total memory requirement increased 2 6 conclusion formulating graphical interpretation relational variables shown generate set clauses expressing transitivity constraints exploits sparse structure relation adding relational variables make graph chordal eliminates theoretical possibility exponential number clauses also works well practice conventional sat checker solve constrained satisfiability problems although run times increase significantly compared unconstrained satisfiability best results obtained using obdds considering relational variables true support f sat enforce transitivity constraints small increase cpu time r graphbased algorithms boolean function manipulation complexity vlsi implementations graph representations boolean functions application integer multiplication exploiting positive equality logic equality uninterpreted functions processor verification using efficient reductions logic uninterpreted functions propositional logic automated verification pipelined microprocessor control techniques verifying superscalar microprocessors bdd based procedures theory equality uninterpreted functions computer architecture quantitative ap proach introduction parallel algorithms architectures arrays grasp search algorithm propositional satisfiability impact branching heuristics propositional satisfiability algorithms triangulated graphs elimination process superscalar processor verification using efficient reductions logic equality uninterpreted functions computing minimum fillin npcomplete tr graphbased algorithms boolean function manipulation complexity vlsi implementations graph representations boolean functions application integer multiplication introduction parallel algorithms architectures techniques verifying superscalar microprocessors computer architecture 2nd ed grasp processor verification using efficient reductions logic uninterpreted functions propositional logic effective use boolean satisfiability procedures formal verification superscalar vliw chaff impact branching heuristics propositional satisfiability algorithms superscalar processor verification using efficient reductions logic equality uninterpreted functions propositional logic bdd based procedures theory equality uninterpreted functions automatic verification pipelined microprocessor control exploiting positive equality logic equality uninterpreted functions ctr miroslav n velev efficient formal verification pipelined processors instruction queues proceedings 14th acm great lakes symposium vlsi april 2628 2004 boston usa miroslav n velev using positive equality prove liveness pipelined microprocessors proceedings 2004 conference asia south pacific design automation electronic design solution fair p316321 january 2730 2004 yokohama japan miroslav n velev using abstraction efficient formal verification pipelined processors value prediction proceedings 7th international symposium quality electronic design p5156 march 2729 2006 miroslav n velev efficient translation boolean formulas cnf formal verification microprocessors proceedings 2004 conference asia south pacific design automation electronic design solution fair p310315 january 2730 2004 yokohama japan miroslav n velev randal e bryant effective use boolean satisfiability procedures formal verification superscalar vliw microprocessors journal symbolic computation v35 n2 p73106 february miroslav n velev exploiting signal unobservability efficient translation cnf formal verification microprocessors proceedings conference design automation test europe p10266 february 1620 2004 robert nieuwenhuis albert oliveras cesare tinelli solving sat sat modulo theories abstract davisputnamlogemannloveland procedure dpllt journal acm jacm v53 n6 p937977 november 2006
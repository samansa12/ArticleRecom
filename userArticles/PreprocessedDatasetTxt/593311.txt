localizer local search traditional technique solve combinatorial search problems raised much interest recent years design implementation local search algorithms easy task general may require considerable experimentation programming effort however contrary global search little support available assist design implementation local search algorithms paper describes design implementation localizer modeling language implementing local search algorithms localizer makes possible express local search algorithms notation close informal descriptions scientific papers experimental results boolean satisfiability graph coloring graph partitioning jobshop scheduling show feasibility approach b introduction combinatorial search problems solved global local search global search problem divided subproblems subproblems simple enough solved directly local search initial configuration generated algorithm moves current configuration neighborhood configuration solution deci sion problems good solution optimization problems found resources available exhausted two approaches complementary strengths weaknesses application areas design global search algorithms supported variety tools ranging modeling languages ampl 2 numerica 10 constraint programming languages chip ilog solver clp prologiv oz name contrast little attention devoted support local search despite increasing interest algorithms recent years note however various efforts integrate local search clp languages eg 9 design local search algorithms easy task however problem modeled many different ways see instance 4 making design process inherently experimental enterprise addition efficient implementations local search algorithms often require maintaining complex data structures incrementally tedious errorprone activity localizer 5 domainspecific language implementation local search al gorithms combining aspects declarative imperative programming since important local search algorithms localizer makes possible write local search algorithms notation close informal presentation found scientific publications inducing reasonable overhead specialpurpose implementations localizer offers support defining traditional concepts like neighborhoods acceptance criteria restarting states addition localizer also introduces declarative concept invariants order automate tedious errorprone aspect local search procedures incremental data structures invariants provide declarative way specify needs maintained define neighborhood objective function paper progress report describing status localizer february 1998 main focus language implementation 1 intended final word language since new higherlevel extensions currently evaluation paper however describes core localizer probably evolve significant ways paper organized four main parts section 2 gives readers quick tour localizer section 3 describes language detail section 4 describes implementation invariants cornerstone localizer section 5 summarizes experimental results several applications finally section 6 concludes paper tour localizer section gives overview main features localizer starts reviewing computational model localizer general form localizer statements considers two main contributions localizer invariants neighborhoods 21 computation model understand statements localizer best consider underlying computational model first figure 1 depicts computational model localizer decision problems model captures essence local search algorithms algorithm performs number local searches maxsearches global condition satisfied local search consists number iterations maxtrials local condition satisfied iteration algorithm first tests state satisfiable case solution found otherwise selects candidate move neighborhood moves new state acceptable solution found maxtrials local condition false algorithm restarts new local iteration state restartstates computation model optimization problems similar except line 5 needs update best solution far necessary eg case minimization 51 bestbound values 52 best companion paper operations research community oriented around applications modeling aspects optimization algorithm course initialize f properly return best solution found end computation procedure localizer begin 2 search 1 maxsearches global condition 3 trial 1 maxtrials local condition 5 return 6 select n neighborhoods 7 acceptablen 9 restartstates figure 1 computation model localizer 22 structure localizer statements purpose localizer statement specify problem hand instance data state generic parts computation model eg neighborhood acceptance criterion localizer statement consists number sections depicted figure 2 instance data defined type constant init sections using traditional data structures programming languages state defined values variables neighborhood defined neighborhood section using objects previous sections acceptance criterion part definition neighborhood initial state defined section start restarting states defined section restart parameters eg maxtrials given parameter section global local conditions given sections global condition local condition note identifiers boldface description computation model eg search trial fact keywords localizer mentioned previously original aspects localizer specifications neighborhood acceptance criterion course notations reminiscent languages ampl claire syntactical level underlying concepts fundamentally different rest section describe original aspects localizer without trying comprehensive 23 running example overview mostly uses boolean satisfiability illustrate concepts localizer boolean satisfiability problem amounts finding truth assignment firstorder boolean formula expressed disjunctive normal form input given set clauses model solve j optimize hobjective functioni figure 2 structure localizer statements clause consisting number positive negative literals traditional literal simply atom positive atom negation atom negative atom clause satisfied soon least one positive atoms true least one negative atoms false local search model considered boolean satisfiability based gsat algorithm selman et al 8 local search moves consist flipping truth value atom local improvement model boolean satisfiability described figure 3 model atoms represented integers 1 n clause represented two sets set positive atoms p set negative atoms n data representation specified type section problem instance specified array clauses n variables instance data declared constant section initialized init section shown state specified truth values atoms captured array variables variable section variable ai represents truth value atom invariant section key component localizer statements describes declarative way data structures must maintained incrementally invariants reviewed detail section 24 model depicted figure 3 maintain number true literals nbtlc clause c number satisfied clauses nbclausesat satisfiable section describes state solution clauses satisfied objective function section describes objective function maximize number satisfied clauses used drive search neighborhood section describes actual neighborhood acceptance criterion neighborhood consists states obtained flipping truth value atom move accepted improves value objective function neighborhood section another important part localizer reviewed solve type constant cl array1m clause variable array1n boolean invariant 1m int sumi clip aj sumj clin aj satisfiable objective function maximize nbclausesat neighborhood move ai ai f1ng accept improvement start foralli 1n ai randomftruefalseg restart foralli 1n ai randomftruefalseg figure 3 local improvement model boolean satisfiability detail section 25 start restart sections describe generate initial state new state restarting search use simple random generation model interesting point stress simplicity model since difficult imagine concise formal statement algorithm 24 invariants invariants probably important tool offered localizer support design local search algorithms make possible specify needs maintained incrementally without considering informally speaking invariant expression guarantees time computation value variable v type value expression exp also type course instance invariant 1m int sumi clip aj sumj clin aj boolean satisfiablity model specifies nbtlc equal sum true positive atoms false negative atoms clause c clauses 1n localizer uses efficient incremental algorithms maintain invariants computation automating one tedious timeconsuming tasks local search algorithms instance whenever value ak changed nbtlc updated constant time localizer allows wide variety invariants complex data structures invariant also boolean satisfiability model illustrates use relations inside invariant relation used inside expression considered 01 integer ie relation evaluated 1 true 0 otherwise excerpt c array1n int distributex1n1n select 1n select 1n sizeci 0g unused candidates b arrayk 1n select ck select j ck ai j taken graphcoloring model implementing algorithm 4 graphcoloring problem amounts finding smallest number colors label graph adjacent vertices different colors graph n vertices algorithm considers n colors integers 1 n color class c set vertices colored bad edges c denoted b edges whose vertices colored main idea algorithm minimize objective function whose local minima valid colorings minimize function algorithm chooses vertex chooses color whose color class nonempty one unused colors important consider one unused colors avoid bias towards unused colors invariant b arrayk 1n select ck select j ck adji j bk set edges obtained selecting two adjacent vertices color class k illustrates localizer maintain queries sets varying time since evolves local search invariant c array1n int distributex1n1n equivalent efficient c arrayi 1n int select 1n primitive function provided since useful large variety applications invariant select 1n sizeci 0g defines nonempty classes note set 1n vary condition important emphasize significant support provided localizer invariants invariants maintain complex data structures incrementally users specify declarative way 25 neighborhood many strategies local improvement simulated annealing tabu search proposed last decades local search algorithms section reviews modeled neighborhood section fundamental tool provided localizer 251 local improvement local nondegradation model depicted figure 3 uses stochastic local improvement approach neighborhood section neighborhood move ai ai f1ng accept improvement specifies following strategy select value 1n ie select atom flip ai resulting state improves value objective function take move state improve value objective function move taken localizer proceeds next iteration innermost loop computational model strategy illustrates structure neighborhood definition localizer move part specifies state transformation uses traditional imperative constructs show transform state another state part specifies set objects used specify state transformation accept part describes accept move local improvement strategy made greedy adding keyword best front move instruction neighborhood best move ai ai f1ng accept improvement solve type constant cl array1m clause variable array1n boolean invariant 1m int sumi clip aj sumj clin aj satisfiable objective function maximize nbclausesat neighborhood best move ai ai f1ng accept nodecrease start foralli 1n ai randomftruefalseg restart foralli 1n ai randomftruefalseg figure 4 gsatbased model boolean satisfiability excerpt specifies following strategy consider value 1n flipped produces improvement select one best improvement note strategy explores neighborhood systematic way previous strategy selecting random move testing improvement neighborhood section neighborhood first move ai ai f1ng accept improvement another approach explores neighborhood systematically move improving value objective function found contrasted random walk strategy presented previously sometimes important allow flexibility local search allow moves may improve objective function neighborhood neighborhood best move ai ai f1ng accept nodecrease accepts best move decrease value objective function resulting model depicted figure 4 captures essence gsat algorithm 252 simulated annealing simulated annealing wellknown stochastic strategy enhance local improvement search easily expressed localizer neighborhood neighborhood move ai ai f1ng accept improvement ch cor nodecrease key novelty accept statement may number acceptance conditions tried sequence one succeeds fail addition acceptance condition associated action simulated annealing neighborhood specifies move accepted improves objective function decrease objective function standard probability simulated annealing depends temperature parameter variation delta objective function note variable ch incremented improvement decrease objective function complete model given figure 5 model illustrates also several new features localizer operator section describes two procedures used subsequently start restart sections operators localizer uses traditional constructs imperative programming languages eg loops conditions well new primitives randomization features described detail section 3 note also variables temperature ch change counter used various places model 253 tabu search tabu search another strategy escape local optima contrast simulated annealing resort stochastic moves neighborhood neighborhood best move ai ai f1ng tabui accept always tv trial solve type constant cl array1m clause variable array1n boolean real invariant 1m int sumi clip aj sumj clin aj operator void foralli 1n xi randomftruefalseg ch 0 void lowtemp f ch 0 satisfiable objective function maximize nbclausesat neighborhood move ai ai f1ng accept improvement ch cor nodecrease start restart lowtemp figure 5 simulated annealing model sat indicates simple tabu search expressed localizer key idea select atom tabu clause generalized include condition moves sodefined accepted model also keeps track atom last flipped using keyword trial atom tabu flipped recently expressed f return tl parameter specifying time atom stays tabu list complete model described figure 6 course complicated tabu search algorithms eg using aspiration criteria overwrite tabu status tabu list whose size varies time implemented easily 254 composing neighborhoods localizer makes also possible compose neighborhoods instance following neighborhood try move occurinunsatclause accept default best move f1ng accept nodecrease implements random walknoise strategy gsat localizer flips arbitrary variable unsatisfied clause probability 01 applies standard strategy probability 09 note localizer simply goes next iteration selected neighborhood empty since neighborhoods may nonempty 255 incrementality issues models presented far localizer needs simulate move find objective function evolves simulation become expensive moves accepted practice local search implementations often try evaluate impact solve type constant cl array1m clause variable array1n boolean array1n int tl int invariant 1m int sumi clip aj sumj clin aj operator void tl 10 foralli 1n xi randomftruefalseg foralli 1n ti tl return satisfiable objective function maximize nbclausesat neighborhood best move ai ai f1ng tabui accept always tv trial start restart figure model boolean satisfiability move current state localizer supports practice allowing specify acceptance criteria evaluated current state instance neighborhood definition neighborhood first move ai ai f1ng accept current state evaluates condition gaini 0 current state determine whether take move course requires generalize invariants maintain gaini incrementally invariants become invariant nbtl array 1m int sumi clip aj sumj clin aj informal meaning new invariants following g01i represents change number satisfied clauses changing value atom false true assuming atom currently false obviously flip produces gain unsatisfied clauses atom appears positively also produces loss clauses appears negatively atom responsible satisfaction clause g10i represents change satisfied clauses changing value atom true false assuming atom currently true computed way similar g01 gaini represents change satisfied clauses changing value atom implemented using conditional expression terms g01i g10i current value atom simulation necessary resulting model gsat model made even incremental since gsat selects move best objective value possible maintain candidate moves incrementally change add two invariants candidates select 1n maxgain simply maximum gains candidates describes set candidates flipping set atoms whose gain positive maximal invariants described neighborhood defined flipping one candidates need use keyword best nodecrease acceptance criteria since already enforced invariants complete model depicted figure 7 course transformation performed tabu search model solve data type constant cl array1m clause po array 1n fintg select c 1m clcp array 1n fintg select c 1m clcn variable array1n boolean invariant nbtl array 1m int sumi clip aj sumj clin aj gain array 1n int ai g10i else g01i candidates select 1n satisfiable neighborhood move ai ai candidates start foralli 1n restart foralli 1n figure 7 incremental model gsat 3 language mentioned previously localizer hybrid language embedding aspects declarative programming within imperative language main declarative tool course concept invariants specify expressions whose values must maintained crementally imperative constructs mostly used specify state transformations starting restarting states section reviews localizer detail essentially organized along textual ordering localizer statements 31 type section type section localizer used define record types records within localizer identical records found conventional imperative languages like pascal c aggregate number named fields possibly different types instance excerpt declares record type edge consisting two integers origin destination nodes excerpt declares record type clause two fields pl nl type sets integers 32 constants constant section declares input data possibly derived data useful stating model constants typed read ie cannot modified assignments initialized shown later various ways initialize data localizer 321 data types basic data types basic data types supported localizer integers booleans floats excerpt declares integer n whose value 10 float whose value 314 boolean integers range gamma2 floats doubleprecision floatingpoint numbers arrays localizer supports multidimensional arrays arbitrary types declara tion defines onedimensional array integers initialized vector 61457 declaration declares matrix integers records mentioned previously records used localizer cluster together related data instance declaration edge defines p array 3 edges edge initialized tuple tuple compatible record type number fields type field compatible type corresponding field sets finally localizer supports sets arbitrary types instance declaration declares initializes set edges 322 inline offline initializations constants initialized inline previous examples also initialized offline init section separate model instance data usually good practice excerpt declares float f whose initialization given init section init section consists set pairs identifiervalue course type initializationmust match type declaration offline initializations used arbitrary types instance boolean satisfiability models may contain initialization section form init cl cl initialized vector 11 tuples tuple pair sets first set pair associated first field record type clause denotes set positive literals clause second set matched second field record denotes negative atoms clause 323 generic data localizer also supports concepts generic data introduced numerica 10 basic idea initialize data using expression may depend parameters declaration genericity especially attractive define derived data used simplify model case fully incremental version gsat see figure 7 important know clauses atom appears positively negatively information derived data cl using generic declarations constant po arrayi 1n fintg select c 1m clcpg arrayi 1n fintg select c 1m clcng couple important points stress first declarations use parameters range index sets array instance parameter ranges 1n set atoms second parameters used expression defined righthand side specify value array given position gsat example poi defined set clauses atom appears positively expressions allowed righthand side general syntax given figure 8 figure 9 describes signature primitive functions obvious meanings 33 variables variables course fundamental localizer since define state com putation variables declared ways constants except initialized generally given initial value start section modified neighborhood restart sections clear examples localizer assignment operator whose righthand side expression 34 invariants invariants key concept provided localizer support design local search algorithms syntactically invariants simply generic data however invariants static since may contain variables andor invariants consequence values invariants statedependent localizer responsible update state transition following excerpt illustrates invariants graphcoloring model ci refers another invariant whose type fintg set integers constant literal hexpri hidentifieri hset bodyi hexpri hexpri j hexpri hexpri hexpri select hidentifieri hrangei hexpri select hidentifieri hexpri hexpri hrangei hexpri hexpri figure 8 expression syntax arithmetic set related output min2intintint sizeftgint printvoid max2intintint randomftgt printlnvoid floorfloatint minofftgt ceilfloatint insertftgtvoid roundfloatint removeftgtvoid expfloatfloat timeint figure 9 primitive functions select 1n sizeci0g 1n fedgeg select ck select j ck addition standard expressions invariants also defined terms distribute dcount take input onedimensional array integers two sets must subset index set result type distribute expression onedimensional array set integers b whose index set fintg result type dcount expression onedimensional array integers whose index set meanings given following equivalences expressions introduced ubiquity practical applications important stress data declared invariants cannot appear lefthand sides assignment statements operators operator section contains function definitions functions localizer essentially similar functions c use traditional assignment conditional iterative statements well recursion addition localizer provides constructs useful local search algorithms syntax statements localizer sketched figure 10 forall instruction provides convenient way iterating elements set choose instruction used select element set dont care nondeterministic way possible filter elements given set select element optimizing function following examples illustrate various forms choose statements choose choose minimizing di choose gaini 0 choose gaini 0 maximizing di entire state including constants variables invariants accessible functions however variables locals modified assignments note functions imperative constructs used start restart sections specification state transformation neighborhood actions associated specific acceptance criteria instructions appear clause move instruction typical examples functions introduced models figures 5 6 hexpri hstatementi return hexpri choose hidentifieri hexpri hoptclausei hoptclausei minimizing hexpri maximizing hexpri hexpri minimizing hexpri hletblocki hexpri maximizing hexpri hletblocki figure 10 syntax statements 36 neighborhood neighborhood specified localizer move instruction form move xn sn instruction uses declarative procedural components first part statement specifies imperative code transformation current state one neighbors second part starting keyword specifies objects used imperative code modeling effort primarily devoted definition sets invariants based syntax move instructions depicted figure 11 element neighborhood selected localizer determines appropriate move acceptance criterion lists boolean conditions tried sequence soon state satisfies one conditions accepted state transformation performed criterion build according syntax hidentifieri f hexpr 1 hidentifieri f hidentifieri htypei j hselect 1 hidentifieri hlvaluei hoptclausei figure 11 syntax move instructions resulting state hacceptancestatementi current state hacceptancestatementi improvement nodecrease hacceptanceconditioni hacceptanceconditioni hacceptanceconditioni hacceptanceconditioni hacceptanceconditioni acceptance criteria default evaluated new state new state must constructed induces update invariants also possible specify acceptance criterion evaluated current state using keywords current state using current state evaluate moves may produce significant improvements efficiency 37 objective function objective function stated separate section used assess quality given state objective function fact viewed invariant maintained localizer used evaluate moves note objective function optional used acceptance criteria evaluated resulting state 38 termination criteria termination handled via several sections depends nature problem model starts keyword either solve optimize specify either decision optimization problem satisfiable section optional satisfiable section used specify whether state solution decision problems localizer terminates whenever case optimization problems localizer updates best solution whenever state solution improves best bound found far section omitted localizer assumes every state solution local global conditions sections optional specify boolean predicates used control innermost outermost loops computation model instance simulated annealing model use local condition implement cutoff strategy terminates innermost loop drops temperature whenever evaluation function updated sufficiently many times parameter section section also optional used override default values parameters system typical uses redefine maxsearches maxtrials parameters computation model implementation section reviews implementation invariants cornerstone local izer informally speaking invariants implemented using planningexecution model planning phase generates specific order propagating invariants execution phase actually performs propagation model makes possible propagate differences two states mimics certain extent way specific local search algorithms implemented planningexecution model imposes restrictions invariants restrictions intuitively makes sure order invariants propagated pair variableinvariant considered various restrictions imposed static invariants ordered compile time thus especially efficient however static invariants rule interesting models scheduling resource allocation problems dynamic invariants still make possible produce ordering pair variableinvariant considered however dynamic invariants require interleave planning execution phases dynamic invariants seem good compromise efficiency expressiveness rest section organized follows algorithms use normalized invariants section 41 reviews normalization process section 42 describes static invariants implementation give readers preliminary understanding implementation section 43 describes dynamic invariants implementation section considers arithmetic invariants difficult generalize results invariants sets 41 normalization invariants localizer rewritten primitive invariants flattening expressions arrays primitive invariants form x phi z c constant x variables phi arithmetic operator arithmetic relation q aggregate operator sum prod max min relations return 1 true 0 otherwise invariant assigns x element position e list x last invariant useful arrays indexed expressions containing variables given time localizer maintains set invariants variables v given invariant 2 form x e e expression defi denotes x expi denotes e given set invariants v x 2 v invariantsx returns subset invariants fi x occurs expi set variables v nfdefiji ig variables parameters system invariants variables modified neighborhood definitions note also variable x defined one invariant ie exist one 42 static invariants basic assumption behind localizer implementation invariants change marginally moving one state one neighbors consequently goal implementation run time proportional amount changes precisely implementation makes sure pair variable invariant considered ie variable updated invariant updated never reconsidered variable achieve goal implementation uses planningexecution model planning phase determines ordering updates execution phase actually performs existence suitable ordering guaranteed restrictions imposed invariants system note also planningexecution models often graphical constraint systems eg 1 section describes static invariants impose static restriction although restriction may seem strong accommodates many models applications satisfiability graph coloring name main practical limitation elements arrays cannot depend elements array restriction lifted dynamic invariants note however static invariants nice property planning phase entirely performed compile time 421 planning phase basic idea behind static invariants require existence topological ordering variables topological ordering obtained associating topological number tx variable x topological number invariant simply tdefi topological numbers obtained constraints derived invariants 1 topological constraints invariant defined follows definition 2 topological constraints set invariants denoted tci i2i tci definition 3 set invariants static exists assignment satisfies tci planning phase static invariants consists finding topological assignment planning phase performed compile time since topological constraints depend values variables given state 422 execution phase execution phase given set variables updated topological assignment propagates changes according topological ordering algorithm uses queue contains pairs form hx ii intuitively pair means invariant must reconsidered variable x updated main step algorithm consists popping pair hx ii smallest ti propagate change possibly adding new elements queue algorithm shown figure 12 procedure executeimt begin endwhile function popqt pre q empty post figure 12 execution phase static invariants 423 propagating invariants complete description implementation static invariants remains describe propagate invariants basic idea associate two values x variable x value x represents value variable x beginning execution phase value x c represents current value x beginning execution phase x course keeping two values possible compute much variable changed update invariants accordingly instance propagation invariant performed procedure procedure propagatex x sumx 1 begin procedure updates x c according change x note topological reached final value note also x c necessarily final update pairs hx may need propagated 43 dynamic invariants static invariants attractive since planning phase performed entirely compile time however interesting applications areas scheduling resource allocation sets invariants static section introduces dynamic invariants broaden class invariants accepted localizer dynamic invariants updated series planningexecution phases planning phase takes place execution time 431 motivation main restriction static invariants comes invariant static topological constraint invariant prevents localizer accepting expressions elements array may depend elements array constraint strong value e known compile time fact may even known start execution phase since invariants may update however many applications scheduling resource allocation invariants occur naturally instance scheduling application may modeled terms invariant start3 maxendprec3 enddisj3 starti represents starting date task preci predecessor task job disji predecessor task disjunction variable disji typically updated local search invariant normalized set form start 3 maxp course application also invariants form implying resulting set invariants static 432 overview approach basic idea behind dynamic invariants evaluate invariants levels invariant associated one level inside one level invariants static level completed planning next level take place using values previous levels since lower levels never reconsidered computation model mind topological constraint associated invariant reconsidered basic idea require e evaluated x ie level x level e e updated easy find weaker topological constraint since value e known invariant simplified planning phase thus divided two steps first step carried compile time partitions invariants levels second step executed runtime topologically sorts invariants within level whenever invariants lower level propagated 433 formalization basic intuition formalized terms two assignments l two sets constraints definition 4 level constraints associated invariant denoted lci defined follows g level constraints strong except invariant element level x strictly greater level e informally means e must evaluated earlier phase x definition 5 level constraints associated set invariants denoted li simply i2i definition 6 set invariants serializable exists assignment l satisfying lci serializable set invariants partitioned sequence invariants level serialization performed compiletime second step consists ordering invariants inside partition ordering take place runtime since necessary know values invariants simplify element invariants definition 7 let computation state let sx denote value x static constraints associated invariant wrt denoted sdi defined follows definition 8 static constraints associated set invariants wrt state denoted sdi simply i2i definition 9 set invariants static wrt state exists assignment main novelty course invariant element topological constraint ignore e since value known addition since final value e known topological constraints made precise since element e c x depends upon known computation state set invariants dynamic wrt 0 1 serializable partitioned sequence 2 static wrt 0 state obtained propagating invariants igamma1 igamma1 course dynamic invariants cannot recognized compiletime may produce execution error runtime localizer planning level 434 execution algorithm new execution algorithm simple generalization static algorithm shown figure 13 note planning step called level procedure executeim begin endfor figure 13 execution algorithm dynamic invariants 5 experimental results section summarizes preliminary results implementation localizer 35000 lines c goal report final word implementation rather suggest localizer implemented efficiency comparable specific local search algorithms demonstrate practicability experimented localizer several problems gsat graph coloring graph partitioning jobshop scheduling 51 gsat gsat generally recognized fast well implemented system experimental results carried specified 8 table 1 gives number variables v number clauses c maxtrials size benchmarks well cpu times seconds localizer l cpu times seconds gsat g reported 8 ratio lg times gsat given sgi challenge 70 mhz mips r4400 processor times localizer obtained sun sparc scaled factor 15 account speed difference two machines localizer times incremental model presented section 2 note comparison perfect eg randomization may different sufficient showing localizer implemented efficiently 52 graph coloring graph coloring object extensive experimental evaluation 4 section reports experimental results along lines experiments conducted graphs densities 10 50 90 sizes 125 250 500 also conducted socalled cooked graphs nature experimental results reported 4 easy compare efficiency localizer efficiency algorithm consequence efficient c implementation algorithm built scratch graduate student closely supervised obtain efficient incremental algorithm far judge timings quality algorithm seem 5 200 860 2000 87311 16800 520 av 338 table 1 gsat experimental results consistent 4 addition algorithm efficient implementation built graduate student combinatorial optimization class brown cs258 last three years given model course following discuss development time two implementations quality solutions obtained make sure algorithms comparable quality efficiency development time c implementation algorithm 1500 lines long required full week localizer model one page long quality solutions table 2 describes quality coloring found lo calizer results agree c implementation reported 4 set rows corresponds class graphs 100 executions localizer graphs class rows set report various values found localizer graphs frequencies columns report number vertices density graph size factor sf used experiments number colors found solution frequency colorings quality instance first set rows reports graphs 125 vertices density 50 92 executions led coloring 19 colors 8 executions led coloring colors results given random cooked graphs frequencies similar localizer c implementation efficiency table 3 compares efficiency localizer c implementation problems row reports average time two implementations 100 graphs class computes slowdown localizer experiments performed sun sparc ultra1 running solaris 551 standard c compiler average slowdown 482 minimum maximum slowdowns respectively 356 554 problems average slowdown slightly higher machine generation remains reasonable given preliminary nature implementation slowdown also contrasted substantial reduction development time vertices density size factor sf colors frequency random 125 50 3 19 92 random 250 50 4 43 34 44 random 500 50 4 random 125 90 1 44 7 random random 500 90 1 143 144 22 cooked 125 4 9 100 cooked cooked 500 2 25 71 table 2 graph coloring quality solutions vertices density size factor sf localizer l c implementation c lc random 125 50 3 783 189 450 random 250 50 4 828 184 450 random 500 50 4 6337 1234 510 random 125 90 1 1618 453 356 random random 500 90 1 1627 296 488 cooked 125 4 2209 418 528 cooked cooked 500 2 2403 499 480 average 482 table 3 graph coloring efficiency localizer 53 graph partitioning problem studied experimentally 3 experiments reported based similar setting table 4 depicts experimental results localizer first row gives setting parameters starting tempera ture tf percentage reduction temperature sf size factor remaining two described previously table 5 compares localizer results reported 3 54 jobshop scheduling conclude report preliminary results jobshop scheduling localizer evaluated set 28 classic benchmarks model used experiment implements neighborhood commonly referred n1 considers reversal exactly one edge critical path n1 number nice properties preserves satisfiability solution transition graph induced neighorhood optimal solution reachable nodes graph experiments conducted fashion similar reported 6 parameters defined ffl maximal number searches maxsearches 1 ffl maximal number iterations inner loop maxtrials 12000 ffl tabu list varying length constrained 5 30 moreover length varied according rule 6 ffl contrary 6 model use restarting strategy graph results class v ertices density sb f req localizer random 124 2 1113 1416 1719 33 38 29 222 random 4 5559 6065 6677 random 8 159174 175190 191 23 53 24 324 random random random 2 92106 107121 122131 12 42 36 510 random 4 324343 344363 364380 38 43 19 650 random 8 828877 878927 928 37 40 23 998 random 500 05 4854 5559 6066 15 43 42 1008 random 4 16611701 17021741 17421824 22 58 20 2067 random 1000 025 90103 104118 119126 41 52 7 1999 random 05 439455 456475 476503 36 43 21 2262 geom 500 5 413 1423 2437 7 58 geom 20 148246 247346 347450 41 44 15 1140 geom 1000 5 2443 4463 6478 37 57 6 1870 geom 20 196399 400599 600816 28 table 4 graph partitioning experimental results graph results class v ertices density lbest ltime jbest jt ime ratio random 124 2 11 222 13 854 385 random random 500 05 47 1008 52 3798 377 random 1000 025 90 1999 102 7299 365 table 5 graph partitioning comparison results table 6 reports preliminary results results cannot really compared results 6 since neighborhood used experiment rn1 rn2 model used relies n1 alone time reported correspond algorithm termination 12000 iterations spent time required produce best optimal solution first time note also value optimal solution used stopping criterion condition used running time would vary lot instance la01 usually produce optimum solution 05 seconds interestingly enough even simple neighborhood n1 quite well finds optimum solution benchmarks 28 benchmarks table also reports coarse histogram summarizes frequencies apparition solutions frequencies obtained based serie 100 experiment benchmark summary results seem indicate localizer also compare well scheduling application 6 conclusion main contribution paper show local search supported modeling languages shorten development time algorithms substantially preserving efficiency specialpurpose algorithms substantiate claim presented progress report domainspecific language localizer introduced 5 localizer statements organized around traditional concepts local search may exploit special structure problem hand main conceptual tool underly benchmark results md12000ms1neighborhoodn1 name job opt ranges f req loc avgsol table ing localizer concept invariants make possible specify complex data structures declaratively data structures maintained incrementally local izer automating one tedious errorprone parts local search algorithms experimental results indicate localizer implemented run efficiency comparable specific implementations current research focuses building higherlevel data structures simplify design invariants cornerstone language extending strategies accommodate dynamic kopt 7 genetic algorithms constraint techniques also contem plated longer term research explore localizer turned programming language library guarantee extensibility wide applicability expert users preserving right level abstraction acknowledgments paper dedicated memory paris c kanellakis kept gently pressuring us pursue topic thanks mcallester b selman many discussions research costas bush implementing graphcoloring algorithm c research supported part nsf nyi award r programming language aspects thinglab ampl modeling language mathematical programming optimization simulated annealing experimental evaluation optimization simulated annealing experimental evaluation modeling language local search marco trubian mauro dellamico combinatorial optimization algorithms complexity new method solving hard satisfiability problems models using stochastic constraint solvers constraint logic programming numerica modeling language global optimization tr ctr simon de givry laurent jeannin unified framework partial hybrid search methods constraint programming computers operations research v33 n10 p28052833 october 2006 pascal hentenryck laurent michel liyuan liu contraintbased combinators local search constraints v10 n4 p363384 october 2005 irit katriel laurent michel pascal hentenryck maintaining longest paths incrementally constraints v10 n2 p159183 april 2005 pascal hentenryck laurent michel control abstractions local search constraints v10 n2 p137157 april 2005 laurent michel pascal van hentenryck constraintbased architecture local search acm sigplan notices v37 n11 november 2002 marco cadoli toni mancini combining relational algebra sql constraint modelling local search theory practice logic programming v7 n12 p3765 january 2007 laurent michel pascal van hentenryck comet context proceedings paris c kanellakis memorial workshop principles computing knowledge paris c kanellakis memorial workshop occasion 50th birthday p95107 june 0808 2003 san diego california usa
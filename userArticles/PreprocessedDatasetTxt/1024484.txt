constraint programming viewed rulebased programming study natural situation constraint programming entirely reduced rulebased programming end explain first one compute constraint satisfaction problems using rules represented simple firstorder formulas consider constraint satisfaction problems based predefined explicitly given constraints solve first derive rules explicitly given constraints limit computation process repeated application rules combined labeling consider two types rule first type call equality rules leads new notion local consistency called rule consistency turns weaker arc consistency constraints arbitrary arity called hyperarc consistency marriott stuckey 1998 boolean constraints rule consistency coincides closure wellknown propagation rules boolean constraints second type rules call membership rules yields rulebased characterization arc consistency show feasibility rulebased approach constraint programming show types rules automatically generated chr rules frhwirth 1995 yields implementation approach programming means constraint logic programming illustrate usefulness approach constraint programming discussing various examples including boolean constraints two typical examples many valued logics constraints dealing waltzs language describing polyhedral scenes allens qualitative approach temporal logic b introduction 11 background paper concerned two styles programming constraint programming rulebased programming constraint programming programming process limited generation krzysztof r apt eric monfroy constraints solution obtained constraint satisfaction problems csps general domain dependent methods rulebased programming programming process consists repeated application rules theoretical basis programming paradigm consists socalled production rules introduced seventies see eg luger 1998pages 171186 though idea goes back works thue e post first half twentieth century production rules conditionaction pairs condition part used determine whether rule applicable action part defines action taken known programming language built around programming paradigm ops5 forgy 1981 recently revival interest rulebased programming context constraint programming earliest example chr language fruhwirth 1995 part ecl ps e system recent complete overview chr see fruhwirth 1998 chr rules extend syntax constraint logic programming allowing two atoms conclusion employing guards rules predominantly used write constraint solvers another example programming language rules play important role elan offers logical environment specifying prototyping deduction systems means conditional rewrite rules controlled strategies elan used support design various rulebased algorithms constraints solvers decision procedures theorem provers algorithms expressed logic programming languages provide modular framework studying combinations general overview elan found borovansky et al 1998 whereas kirchner ringeissen 1998 castro 1998 shall return section 8 describe applications elan constraint programming constraint solving also hybrid functional objectoriented language programming language claire caseau laburthe 1996 rules present claire designed apply constraint programming techniques operations research prob lems rulebased programming supported means production rules naturally used express constraint propagation 12 overview approach traditional way solving csps consists combining constraint propagation techniques search constraint propagation aims reducing csp equivalent one simpler case finite domains basic approach search consists labeling repeated enumeration domains successive variables aim paper show natural circumstances constraint programming entirely rendered means rulebased programming approach constraint propagation achieved repeated application rules search limited labeling end study csps built predefined explicitly given constraint programming viewed rulebased programming 3 finite constraints csps often arise practice examples include boolean constraints constraints dealing waltzs language describing polyhedral scenes allens temporal logic constraints multivalued logic solve csps explore structure explicitly given constraints first information expressed terms valid rules computation process csp built constraints entirely driven rules approach computation process consists two phases generation rules explicitly given constraints repeated application rules combined labeling approach rules simple firstorder formulas provide computational interpretation framework rulebased programming fact logicbased rules shall consider implications built simple atomic formulas precisely study two types rules generated given advance constraints first type rules call equality rules form variables elements respective mains computational interpretation rule 2 1n domain variable x equals singleton fs g remove element domain second type rules call membership rules form variables subsets respective mains computational interpretation rule 2 1n domain variable x included set remove element domain characterize effect rules use notions local consistency notions approximate loose sense notion global consistency see eg tsang 1993 show first type rules leads local consistency notion turns weaker arc consistency constraints arbitrary arity call rule consistency original domains unary binary rule consistency coincides arc consistency additionally predefined constraints truth tables boolean connectives rules essentially coincide wellknown boolean propagation rules see eg codognet diaz 1996 side effect shows boolean propagation rules characterize arc consistency rule consistency thus generalization boolean propagation nonbinary domains also show membership rules lead notion local consistency coincides arc consistency yields rulebased implementation arc consistency show feasability rulebased approach constraint programming 4 krzysztof r apt eric monfroy automatically generate types rules explicitly given finite constraint rules chr language combined labeling procedure chr programs constitute automatically derived decision procedures considered csps expressed constraint programming language level particular automatically generate algorithms enforce rule consistency arc consistency availability algorithms enforce rule consistency arc consistency constraint programming language level contributes automation programming process within constraint programming frame work fact case csps built predefined explicitly given finite constraints user need write ones chr rules considered constraints simply adopt rules automatically generated final example paper also show using equality rules membership rules implement powerful notions local consistency alternatively generated equality rules membership rules could fed generic chaotic iteration algorithms apt 1999 made available systems ilog solver would yield rule consistency alternative implementation arc consistency algorithms explicitly given finite constraint generate appropriate rules characterize rule consistency arc consistency unavoid ably running time exponential number constraint variables consequently general impractical test usefulness algorithms small finite domains implemented ecl ps e successfully used several examples including ones mentioned fact could handle examples shows approach practical value particular used automatically derive practical decision procedures constraint satisfaction problems defined small finite domains also shows usefulness chr language automatic generation constraint solvers decision procedures 13 organization paper rest paper organized follows next section clarify syntax rules explain one compute section 3 formalize concept csp built predefined constraints next section 4 introduce notion rule consistency discuss algorithm used generate minimal set rules characterize notion local consistency section 5 compare rule consistency arc consistency section 6 study membership rules discuss algorithm analogous one section 4 entails notion local consistency turns equivalent arc consistency section 7 discuss implementation algorithms generate explicit representation finite constraint set chr rules characterize respectively rule consistency arc consistency also illustrate constraint programming viewed rulebased programming 5 usefulness implementations means several examples finally section 8 discuss works link made constraint programming rulebased programming section 9 assess merits approach appendix summarize tests carried means implementation algorithms computing rules follows introduce specific type rules explain one compute constraint satisfaction problems first introduce constraints consider sequence variables x x respective domains associated variable x ranges domain constraint c x mean subset 1 given element dn subsequence x x denote dy sequence 1 particular variable x x next define rules interested definition 21 ffl let x variable element set atomic formula mean one following formulas ffl rule mean expression form b j atomic formula 2 follows rule always associated constraint every atomic belongs domain x respectively subset domain x subsequently explain compute using rules presence con straints first limit considerations rules form x 6 need explain turn disequality formula action done identifying disequality x 6 assignment x x gamma fag x current domain x words interpret x 6 action removing value current domain variable x leads us definition application rule need semantic notions first definition 22 consider constraint c sequence variables x variable x x tuple 2 c ffl given atomic formula involving x define relation ffl given sequence atomic formulas 6 krzysztof r apt eric monfroy definition 23 consider constraint c finite sequence variables x rule form involving variables x suppose 2 c let c 0 constraint obtained c removing element domain variable x removing c tuples dx call constraint c 0 result applying rule x 6 c 2 say relevant application rule x 6 c c 0 coincides c say application rule x 6 c maintains equivalence 2 application rule x 6 constraint c sequence variables respective domains results constraint c 0 variables x respective domains theta say constraint c restricted domains defined result single application rule proceed define computations end first introduce constraint satisfaction problems constraint satisfaction problem short csp mean finite sequence variables x respective domains together finite set c constraints subsequence x write hc solution mean element 2 constraint c 2 c sequence variables x dx call csp consistent solution two csps sequence variables called equivalent set solutions modify definition application rule constraint application rule csp end attach rule constraint supposed applied even though constraints change computations consider always clear context constraint given rule attached definition 24 consider csp p rule x 6 attached constraint c p suppose 2 c define csp p 0 variables p follows ffl domain x p 0 equals domain x p ffl domains variables p 0 p ffl constraints p 0 obtained restricting constraints p new domains constraint programming viewed rulebased programming 7 say csp p 0 result applying rule x 6 p 2 say relevant application rule x 6 finally introduce crucial notion computation definition 25 consider set rules r form x 6 initial csp p computation means r starting p mean maximal sequence csps p j1 result relevant application rule r p j 2 computations finite infinite domains p finite computations starting p insist application relevant computation finite application rule considered set rules r final csp relevant computations considered general insufficient solving csp case csps finite domains combined label ing labeling easily incorporated rulebased framework introducing rule splits given csp two union equivalent given csp addition rule considered framework leads conceptual difficulties omitted string definitions allowed us define computations actions limited applications rules form x 6 acting csps limiting attention type rules lose expressiveness indeed consider first rule form compute interpret equality x assignment x x fag x current domain x rule x equivalent conjunction rules form x 6 b b 2 gamma fag original domain x next consider rule form x 2 compute interpret atomic formula x 2 assignment x x x current domain x rule x 2 equivalent conjunction rules form x 6 b b 2 gamma original domain x finally rule form equivalent conjunction rules form ab note rules form x expressive socalled dependency rules database systems see eg ullman 1988 rules form x explained model means rules form x however modeling direction possible seen taking variables x domain f0 1 2g constraint c x represented following table 8 krzysztof r apt eric monfroy x rule equivalent conjunction dependency rules introduce number semantic notions concerning rules definition 26 consider constraint c ffl say rule ab valid c tuples 2 c implies ffl say constraint c closed rule ab j tuples 2 c implies j b tuples 2 c ffl say rule ab feasible c tuple 2 c ffl say rule ab constraint c extends rule 0 b contains variables 0 tuples 2 c implies ffl given set rules r call rule minimal r feasible properly extend valid rule r 2 note definition application rule designed link semantics kept following sense rule r valid constraint c c closed r rules feasible trivially valid note also rule extends valid rule valid well validity extends upwards follows confine attention computations involving two types rules ffl equality rules rules form x abbreviate ffl membership rules rules form x 1 abbreviate x specializing r set equality rules set membership rules obtain notions minimal equality rule minimal membership rule illustrate introduced notions consider following example confine attention equality rules constraint programming viewed rulebased programming 9 example 21 take constraint ternary relation represents conjunction andx viewed following table x z words assume variables x z domain f0 1g view andx constraint x z consists four triples easy see equality rule rule extends rule also valid andx however two equality rules minimal finally rules feasible rules feasible 2 note use condition contains variables 0 definition relation rule ab extends rule 0 b without would following paradoxical situation consider variables x z domains f0 1g constraint c x defined c f0 0 0 1 0 1g rules valid c without mentioned condition would rule extends rule would imply first rule minimal sequel following observation useful note 21 consider two finite nonempty constraints c e c e set rules r c closed valid rules r e iff closed minimal valid rules r e proof suppose c closed minimal valid rules r e take rule r r valid e case 1 r feasible e e finite r extends minimal valid rule r 0 r e c closed r 0 closed r well case 2 r feasible e r feasible c either since c e consequently since c non empty c closed r krzysztof r apt eric monfroy given csp finite domains would like solve considering computations starting get rules note given constraint c rule r valid c constraint c trivially closed r consequently application r c relevant ie affect c obtain change need use rules valid initial constraints brings us notion csp based another one 3 csps built predefined constraints introduction informally referred notion csp built predefined explicitly given constraints let us make concept formal need two auxiliary notions first preparation next definition already consider constraints together domains defined definition 31 ffl given constraint c 1 dn permutation 1n denote c relation defined call permutation c ffl given two constraints c 1 n say c based e notion based involves domains constraints c based e c restriction e domains c defined definition 32 assume predefined constraints presented given advance csp base suppose constraint c csp p based permutation constraint base say p based base 2 definition use permutations constraints allows us abstract variable ordering used base following example illustrates notion example 31 consider wellknown full adder circuit defined following formula xor defined expected way view original constraints following csp bool viewed inventory predefined constraints constraint programming viewed rulebased programming 11 csp solved query concerning full adder viewed csp based bool example section 7 shall consider query corresponds following csp based bool iin follows consider computations start csp based csp base computations wish maintain equivalence successive csps end following simple observation crucial note 31 consider two constraints c e c based e let x 6 rule valid e application x 6 c maintains equivalence proof assume rule x 6 applied c ie 2 c suppose rule x 6 c maintain equivalence 2 c c based e 2 e validity rule e get dx 6 yields contradiction observation provides us way maintaining equivalence computation suffices use step rule valid permutation c constraint base rule attached ie applied constraint based c shall sequel depending type rules used obtain way different notions local consistency 4 rule consistency section consider csp p based finite csp base study computations use exclusively equality rules rules obtained constraints base valid permutation c constraint c base applied constraint p based c note 31 successive csps equivalent initial csp p computation ends csp obtained closed rules used brings us natural notion local consistency expressed terms equality rules definition 41 consider csp p based csp base let c constraint p constraint fc base permutation c based fc ffl call constraint c rule consistent wrt base closed equality rules valid fc ffl call csp p rule consistent wrt base constraints rule consistent 2 follows drop reference base clear context 12 krzysztof r apt eric monfroy example 41 take base csp consider following four csps based 1 handx 2 handx 3 handx 4 handx subset f0 1g noted example 21 equality rule z first three csps constraint closed rule fourth one since 1 present domain z whereas domain x equals f0g fourth csp rule consistent one show first two csps rule consistent third one since closed valid equality rule trying generate valid equality rules note 21 allows us confine attention minimal valid equality rules introduce algorithm given finite constraint generates set minimal valid equality rules collect generated rules list denote empty list empty result insertion element r list l insertr l assignment sequence variables x mean element cartesian product domains variables x 2 c dx intuitively represent constraint c table rows corresponding elements tuples c columns corresponding variables c assignment x tuple elements appears row columns correspond variables x algorithm following form assume considered constraint c defined sequence variables var cardinality n equality rules generation algorithm subset x var cardinality assignment x varx element domain r valid c extend element l insertr l end end end end constraint programming viewed rulebased programming 13 end end following result establishes correctness algorithm theorem 41 given constraint c equality rules generation algorithm produces l set minimal valid equality rules c proof first note algorithm possible feasible equality rules considered list l valid equality rules retained additionally valid equality rule retained extend rule already present l equality rules considered order according use less variables considered first ensures precisely minimal valid equality rules retained l note minimality property rule l extends another easy see algorithm given constraint defined n variables o2 n n rules considered size largest variable domain shows practice algorithm impractical large domains constraints many variables shall return matter section 7 appendix relating rule consistency arc consistency clarify status rule consistency compare notion arc consistency notion introduced mackworth 1977 binary relations extended arbitrary relations mohr masini 1988 let us recall definition definition 51 ffl call constraint c sequence variables x arc consistent every variable x x element domain exists 2 c element domain participates solution c ffl call csp arc consistent constraints arc consistent 2 following result relates constraints arbitrary arity arc consistency rule consistency theorem 51 consider csp p based csp base p arc consistent rule consistent wrt base proof assume p arc consistent choose constraint c p consider equality rule valid fc f definition 41 suppose contradiction c closed rule x 14 krzysztof r apt eric monfroy domain variable x j p equals fs j g moreover 2 domain variable p arc consistency p exists 2 c form domains variables x also dx holds additionally p based base 2 fc assumption equality rule valid fc dy 6 contradiction converse implication hold general following example shows example 51 take base following csp constraint c x equals set f0 1 1 0 2 2g c viewed following table x next take 1 set f0 1g 2 set f0 1 2g csp hc 1 theta 2 based base arc consistent since value 2 domain participate solution yet easy show constraint csp closed equality rules valid c 2 show domain two elements notions arc consistency rule consistency coincide precisely following result holds theorem 52 let base csp domain unary binary consider csp p based base p arc consistent iff rule consistent wrt base proof implication contents theorem 51 prove reverse implication suppose constraint c p arc consistent prove c rule consistent constraint c variables x respective domains 2 1n 2 participate solution c sequence domains singletons suppose j consider equality rule take fc f constraint programming viewed rulebased programming 15 definition 41 appropriate domains 0 n base n next take 2 fc dx show 2 c since suffices prove 2 1 variable x j lying inside x dx turn variable lying outside x domain j two elements assumption base j corresponding domain 0 j fc consequently n indeed 2 c hence dx 6 choice proves validity equality rule c closed rule since 2 c rule consistent 6 membership rule consistency section consider computations use exclusively membership rules previous section saw notion rule consistency weaker arc consistency constraints arbitrary arity show using membership rules obtain notion local consistency coincides arc consistency first let us clarify notion membership rule considering following example example 61 consider constraint variables x z domain f gamma l rg defined following table x z constraint socalled fork junction language waltz 1975 describing polyhedral scenes note following three membership rules valid membership rules r 2 r 3 extend r 1 membership rule r 1 extends neither r 2 r 1 membership rules r 2 r 3 incomparable sense none extends 2 krzysztof r apt eric monfroy analogy definition 41 introduce following notion definition 61 consider csp p based csp base let c constraint p constraint fc base permutation c based fc ffl call constraint c membership rule consistent wrt base closed membership rules valid fc ffl call csp membership rule consistent wrt base constraints membership rule consistent 2 following result theorem 61 consider csp p based csp base p arc consistent iff membership rule consistent wrt base proof part proof simple modification proof theorem 51 assume p arc consistent choose constraint c p consider membership rule x valid fc f definition 32 suppose contradiction c closed rule x domain variable x j included j moreover 2 domain variable arc consistency p exists 2 c form domains variables x also dx holds additionally p based base 2 fc assumption rule x valid fc dy 6 contradiction part proof modification proof theorem 52 suppose constraint c p arc consistent prove c membership rule consistent constraint c variables x respective domains 2 1n 2 participate solution c take definition 61 appropriate domains n base fc 0 n sequence domains respectively different 0 consider membership rule x dx j show 2 c since suffices prove 2 1 variable x j lying inside x dx j turn variable x j lying outside x domain j corresponding domain 0 j fc base consequently n indeed 2 c hence dx 6 choice proves validity rule x c closed membership rule since 2 c membership rule consistent constraint programming viewed rulebased programming 17 example 51 shows notions rule consistency membership rule consistency coincide see difference better let us reconsider csp discussed example noted csp arc consistent rule consistent theorem know csp membership rule consistent fact consider following membership rule 2 membership rule valid base constraint c restricted constraint closed rule conclusion membership rules powerful equality rules section 4 provide algorithm given constraint generates set minimal valid membership rules assume considered constraint c defined sequence variables var cardinality n instead assignments used equality rules generation algorithm need slightly different notion define variable x var denote set fdx j 2 cg cx weak assignment sequence variables x x sequence subsets respectively cx 1 2 c exists dx 2 1k intuitively represent constraint c table rows corresponding elements c columns corresponding variables c view column set elements weak assignment x tuple subsets columns correspond variables x shares assignment algorithm weak assignments fixed sequence variables considered decreasing order sense weak assignments u 2 1k u first membership rules generation algorithm subset x var cardinality weak assignment x decreasing order varx element domain r valid c extend element l insertr l end end end end krzysztof r apt eric monfroy end end following result establishes correctness algorithm theorem 62 given constraint c membership rules generation algorithm produces l set minimal valid membership rules c proof proof analogous theorem 41 need check membership rules considered order rule r 2 extends rule follows following observation suppose rule r 2 z 2 subsequence z variable x x corresponding element u subset corresponding element applications section discuss implementation equality rules generation membership rules generation algorithms discuss use selected domains 71 constraint handling rules chr order validate approach realized prolog platform ecl ps e prototype implementation rules generation algorithm membership rules generation algorithm made compromise memory usage performance could tackle nontrivial problems terms size domains variables terms arity constraints spite exponential complexity algorithms implementations generate chr rules deal finite domain variables using ecl ps e library constraint handling rules chr fruhwirth 1995 declarative language allows one write guarded rules rewriting constraints rules repeatedly applied fixpoint reached rule applications precedence usual resolution step logic programming chr provides two types rules simplification rules replace constraint simpler one propagation rules add new constraints equality rules membership rules modelled means propagation rules illustrate point consider constraint cons three variables domain f0 1 2g rules generation algorithm generates rules 2 rule translated chr rule form cons0b1 b2 constraint program query unifies cons0b1 rule fired value 2 removed domain variable b constraint programming viewed rulebased programming 19 turn membership rules generation algorithm generates rules 2 rule translated chr rule predicate defined inxl domxd subsetdl holds current domain variable x yielded builtin dom ecl ps e included list l constraint unifies cons0bc current domain variable c included 12 value 2 removed domain b types rules achieve desired effect examples combine rules premise one rule obvious way present rules chr syntax 72 generating rules begin discussing generation equality rules membership rules selected domains times given refer implementation ran silicon graphics o2 64 mbytes memory 180 mhz processor boolean constraints first example consider boolean constraints example conjunction constraint andxyz example 21 equality rules generation algorithm generated 002 seconds following six equality rules domains binary replace conclusions form become wellknown rules found fruhwirth 1998page 113 case virtue theorem 52 notions rule arc consistency coincide six equality rules characterize arc consistency constraint implementations equality rules generation membership rules generation algorithms yield rules three valued logic next consider three valued logic kleene 1952page 334 consists three values true f false u unknown consider crucial equivalence relation j defined truth table 20 krzysztof r apt eric monfroy determines ternary constraint nine triples obtain 20 equality rules 26 membership rules typical examples equivtxy inyf u xt six valued logic van hentenryck et al 1992 constraint logic programming language chip used automatic testpattern generation atpg digital circuits end authors define specific six valued logic provide rules expressed form socalled demons carry constraint propagation and6 constraint question defined means following table gammagamma gammagamma gammagamma gammagamma dnot gammagamma dnot gammagamma gammagamma gammagamma dnot enot 0 enot gammagamma dnot 0 enot equality rules generation algorithm generated 41 equality rules seconds membership rules generation algorithm generated 155 membership rules 1435 seconds difficult compare outcome two algorithms rules given van hentenryck et al 1992page 133 latter ones allow equalities variables premise however clear approach systematic fully automatic propagating signs next example consider rules propagating signs arithmetic expressions see eg davis 1987page 303 limit case multiplication consider following table constraint programming viewed rulebased programming 21 theta neg zero pos unk neg pos zero neg unk zero zero zero zero zero pos neg zero pos unk unk unk zero unk unk table determines ternary constraint msign consists 16 triples instance neg neg pos denotes fact multiplication two negative numbers yields positive number value unk stands unknown equality rules generation algorithm generated 008 seconds 34 equality rules typical example msignxzeroy yposynegyunk turn membership rules generation algorithm generated 06 seconds 54 membership rules typical example corresponds following two membership rules constraint msignxzy waltz language describing polyhedral scenes waltz language consists four constraints one fork junction already mentioned example 61 equality rules generation algorithm generated 12 equality rules membership rules generation algorithm 24 membership rules another constraint socalled junction defined following table x z r l r r l l case equality rules generation algorithm membership rules generation algorithm generate output consists one rule rule characterizes rule consistency arc consistency csps based junction 22 krzysztof r apt eric monfroy two constraints l junction arrow junction generation equality rules membership rules equally straightforward 73 using rules next show means examples generated rules used reduce solve specific queries also show using compound constraints achieve local consistency notions stronger arc consistency constraints arbitrary arity waltz language describing polyhedral scenes following predicate describes impossible scene given figure 1 taken winston 1992page 262 f g j fig 1 impossible scene impafaiabijihjhghgcgeefedcdcb arrowafabai lbcba arrowcbcdcg ldedc arrowedegef lfafe forkghgcge arrowhghihj lineaffa lineabba lineaiia lineijji lineihhi linejhhj lineghhg linefeef linegeeg linegccg linedccd lineedde linebccb supplementary constraint line defined following table constraint programming viewed rulebased programming 23 x l r r l elsewhere use ecl ps e builtin declare variable domains using equality rules obtained equality rules generation algorithm associated fork arrow l line constraints query impafaiabijihjhghgcgeefedcdcb reduces 0009 seconds variable domains af 2 l ai 2 ab constraints remain unsolved need add labeling mechanism prove inconsistency problem hand using membership rules inconsistency detected without labeling 006 seconds wellknown example cube given figure 1215 winston 1992page 260 membership rules also powerful equality rules sets rules reduce problem cases labeling needed produce four solutions comparing constraint solver based membership rules constraint solver based equality rules easy although propagation efficient membership rules solver based equality rules sometimes faster depending structure problem whether labeling needed also compared solvers generated implementations equality rules generation membership rules generation algorithms approach described 1997 based metaprogramming prolog ran examples drew following conclusions small examples solvers less efficient ones factors varying 2 10 however complex examples solvers became significantly efficient factors varying 10 500 attributed increased role constraint propagation reduces backtracking absent bys approach temporal reasoning allen 1983 approach temporal reasoning entities intervals relations temporal binary relations allen 1983 found 13 possible temporal relations pair events krzysztof r apt eric monfroy namely overlaps meets starts finishes symmetric relations six relations equal denote 13 relations respectively bdomsfbdomsfe set temp consider three events b c suppose know temporal relations pairs b b c question temporal relation c answer allen 1983 provided 13 theta 13 table table determines ternary constraint triple events b c denote allen example overlaps 2 allen since overlaps b b c implies c using table equality rules generation algorithm produced constraint allen 498 equality rules 3116 seconds tried set rules solve following problem allen 1983 john room touched switch turn light three events time touching switch l time light j time john room two relations l r2 j problem translated csp allen constraint variables r1 r2 r3 infer relation r3 l j use following query r1om r2bmbm r3bdomsfbdomsfe allenr1r2r3 labelingr1r2r3 obtain following solutions 006 seconds mbb mme mms mms mmb obb obd obf obm obo obb omd omf omo ombg carry allen 1983 complete problem john room later light went translated l overlaps starts j ie r3 2 osd run following query r1om r2bmbm r3osd allenr1r2r3 labelingr1r2r3 variable instantiated need perform labeling effectively apply rules constraint programming viewed rulebased programming 25 obtain four solutions 004 seconds r1r2r3 2 fmbo mms obo omog full adder final example illustrates use equality rules membership rules implement powerful notions local consistency already discussed example 31 full adder circuit defined following constraint logic program see eg fruhwirth 1998 uses boolean constraints xor addi1i2i3o1o2 xori1i2x1 andi1i2a1 xorx1i3o2 andi3x1a2 ora1a2o1 query addi1i2i3o1o2 followed labeling mechanism generates explicit definition truth table full adder constraint eight entries fulladder10110 generate equality rules membership rules compound constraint full adder constraint defined means basic constraints xor constraints rules refer compound constraint allow us reason directly instead using rules deal basic constraints case full adder constraint equality rules generation algorithm generated 52 equality rules 027 seconds constraint propagation carried means equality rules powerful one carried means rules generated xor constraints exam ple query xyz01 fulladder1xyz0 reduces z 1 whereas query xyz01 add1xyz0 reduce z shows rule consistency compound constraint defined means basic constraints general stronger rule consistency basic constraints treated separately fact case equality rules full adder constraint yield relational 15consistency notion dechter van beek 1997 whereas virtue theorem 52 equality rules xor constraints yield weaker notion arc consistency 8 related work number papers link made constraint programming rulebased programming start montanari rossi 1991 general study constraint propagation undertaken defining notion relaxation rule proposing general relaxation algorithm implements constraint 26 krzysztof r apt eric monfroy propagation means repeated application relaxation rules however abstract view constraint programming cannot realized simple way since application relaxation rule complex process apt 1998 showed constraint programming couched proof theoretic terms viewing programming process task proving original csp proposed framework two types rules proposed deterministic ones splitting ones deterministic rules either concerned domain reduction constraint reduction former case rules called domain reduction rules latter case constraint reduction rules rules highlevel abstractions implementation level involve complex computations useful see rulebased approach constraint programming proposed paper instance proof theoretic view constraint pro gramming namely equality rules membership rules examples domain reduction rules labeling formal treatment omitted example splitting rule important gain implementation considered equality rules membership rules boils straightforward translation chr syntax leads implementation approach constraint programming means constraint logic programming important limitation approach applies csps built predefined explicitly given finite constraints similar approach constraint programming apt 1998 proposed castro 1998 approach proof rules represented rewrite rules already mentioned introduction programming language elan work emphasis showing general techniques constraint programming particular various search strategies expressed form rules preparing revised version paper noted similar notion rule consistency notion introduced context theory fuzzy sets see pedrycz gomide 1998pages 252261 notion considered deals rules form x b b fuzzy sets spite name used namely rule consistency uses notions different case employ reduce specific csps smaller ones case fuzzy set theory corresponding notion used detect conditions potential inconsistency 9 conclusions aim paper provide framework constraint programming entirely reduced rulebased programming involved constraint satisfaction problems built explicitly given constraints case latter constraints defined small finite domains csps often solved means automatically generated constraint propagation algorithms argued csps often arise practice consequently methods constraint programming viewed rulebased programming 27 developed practical use believe approach paper could applied study various decision problems concerning specific multivalued logics turn could used analysis digital circuits see eg muth 1976 nine valued logic used applications could involve nonlinear constraints small finite domains analysis polyhedral scenes presence shadows see waltz 1975 introduced notion rule consistency weaker arc consistency circumstances appropriate one use example case temporal reasoning considered last section easily generated equality rules enforce rule consistency whereas 24 hours turned enough generate membership rules enforce arc consistency precise summary tests carried see appendix finally notions rule consistency membership rule consistency could parametrized desired maximal number variables used rule premises parametrized versions notions could useful dealing constraints involving large number variables equality rules generation algorithm membership rules generation algorithm implementations trivially adapted parametrized notions approach proposed paper could easily integrated constraint logic programming systems ecl ps e could done providing automatic constraint propagation means equality rules membership rules flagged predicates defined list ground facts much way constraint propagation linear constraints finite systems automatically provided acknowledgements would like thank thom fruhwirth andrea schaerf anonymous referees useful suggestions concerning preliminary version paper r maintaining knowledge temporal intervals proof theoretic view constraint programming essence constraint propagation automatic generation constraint propagation algorithms small finite domains introduction claire programming language departement mathematiques et informatique building constraint satisfaction problem solvers using rewrite rules strategies simple efficient boolean constraint solver constraint logic programming constraint propagation interval labels local global relational consistency ops5 users manual theory practice constraint handling rules constraint handling rules introduction metamathematics artificial intelligence consistency networks relations programming constraints good old discrete relaxation constraint relaxation may perfect introduction fuzzy sets foundations constraint satisfaction principles database knowledgebase systems constraint satisfaction using constraint logic programming generating semantic descriptions drawings scenes shadows artificial intelligence tr ctr krzysztof r apt sebastian brand schedulers rulebased constraint programming proceedings acm symposium applied computing march 0912 2003 melbourne florida sebastian brand krzysztof r apt schedulers redundancy class constraint propagation rules theory practice logic programming v5 n45 p441465 july 2005 abdennadher christophe rigotti automatic generation rulebased constraint solvers finite domains acm transactions computational logic tocl v5 n2 p177205 april 2004
transforming net intermediate language using path logic programming path logic programming modest extension prolog specification program transformations give informal introduction extension show used coding standard compiler optimisations also number obfuscating transformations object language microsoft net intermediate language il b introduction optimisers obfuscators refactoring tools need apply program transformations automatically furthermore applications desirable one easily experiment transformations varying applicability conditions also strategy transformations applied paper introduces variation logic programming called path logic programming specifying program transformations declarative yet executable manner separate language strategies used controlling application order permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copies bear notice full citation first page copy otherwise republish post servers redistribute lists requires prior specific permission andor fee ppdp02 october 68 2002 pittsburgh pennsylvania usa illustrate ideas considering net intermediate language il typed representation used backends compilers many dierent programming languages 15 22 il quite close highlevel lan guages particular c 2 17 ease one convert il c obfuscation il important 8 main examples therefore drawn literature obfuscation also consider standard compiler optimisations structure paper follows first provide brief introduction il variant il useful applying program transformations indeed writing decompiler next introduce main ideas path logic programming extensions standard prolog explain use ideas transform il pro grams preliminaries present concrete examples first simple optimisations complex obfuscating transformations 2net core microsofts net platform intermediate language variety dierent source languages compiled similar java bytecode although rather complex specifically designed convenient compilation target multiple source lan guages programs distributed intermediate language justintime compiled native code target platform paper shall concerned relatively small subset language ongoing work expand scope transformation system il stackbased language fragment shall considering instructions load literal values onto stack ldc create new arrays allocated heap newarr load store values local variables method arguments stack ldloc ldarg stloc starg standard arithmetic boolean comparison operations intuitive names operate solely stack values finally instructions nothing branch conditionally unconditionally return method nop brfalse brtrue br ret programs must verifiable purposes means possible establish statically type item stack position instruction sequence also means particular position stack must height time flow control reaches position stackbased nature il makes dicult formulate even quite simple conditions il code example assignment might represented il sequence add sub stloc result condition recognised assignment would need quite long problem becomes much worse complicated expressions especially branches controlflow occur values stack therefore first step take convert il expression il eil language abstracts il stack replacing stackbased computations expres sions introducing new local variables hold values would previously stored stack fact deal verifiable il makes translation possible first stage simply introduces one extra local variable stack location replaces il instruction appropriate assignment thus would become something like left transformations described later merge assignments together give original assignment 1 eil analogous jimple grimp languages soot framework 29 30 initial translation produces code similar threeaddress code jimple assignment merging leaves us proper expressions like grimp concrete syntax omits many significant details eil example expressions typed arithmetic operators multiple versions dierent overflow han dling shall return structure eil section 4 fragment eil consider enables us make many simplifying assumptions would invalid whole language particular ignore aliasing problems paper 3 path logic programming simple optimisation performed atomic propagation case atomic value taken constant local variable parameter passed value method intention local variable assigned atomic value neither variable value redefined use variable replaced atomic value essence atomic propagation rewrite rule sx stands statement contains variable x v statement x replaced naturally validity rule requires x variable holds value v whenever statement x reached formulation x v metavariables instantiated appropriate fragments program wish transform wish apply propagation v atomic value introduce repeated computations easy implement rewriting logic programming language makes particularly easy keep track bindings metavariables see eg 16 28 deed observation prompted de volder propose use prolog appropriate framework programming transformations 13 go one step extend prolog new primitives help us express side conditions found transformations atomic propagation prolog program interpreted relative flow graph object program transformed new primitive predicate holds true n nodes flow graph paths n form specified pattern q furthermore least one path satisfies pattern q shall justify slightly nonintuitive condition later pattern regular expression whose alphabet consists logic programming goals illustrate let us return atomic propagation predicate propagaten x v holds true transformation applicable node n flow graph appropriate bindings x v example predicate evaluated relative flow graph figure 1 possible bindings definition propagate terms new primitive setx v localx usex entry n definition says paths program entry node n satisfy particular pattern path figure 1 example flow graph sequence edges flow graph path pattern regular expression example consists four components path first starts zero edges particularly care indicated shall see shortly interpretation predicate holds true always next encounter edge whose target node assignment form x v x local variable v atomic worth attempting propagation next zero edges nodes redefine x value v finally reach edge pointing use variable x pattern satisfied one particular binding paths entry n fragments curly brackets ordinary logic programming goals except use tick mark front predi cates predicates properties edges example predicate takes two arguments variable x edge e holds true edge points node x assigned similarly usex e true target e node labelled statement makes use x place tick mark front predicate inside path pattern current edge added final parameter predicate called return requirement least one path nodes n predicate q n hold suppose insist restriction node n exist path entry node propagaten succeed value x v would lead nonsensical situation tried apply trans formation could course specifically add check definition propagate avoid would required many predicates found requirement hindrance also pragmatic reasons requirement implementation primitives demands 12 may seem rather unnatural represent paths sequences edges rather sequences nodes given patterns usually examine target node edge rather edge however using edges rather nodes give us slightly power particular allows us specify path goes else branches statement although thus far made use extra power wish rule possibility future 31 syntax semantics figure 2 summarises syntax extended version prolog two new forms predicate namely exists takes path pattern two terms terms meant designate nodes say predicate p b holds true paths b form indicated p exists least one path form predicate exists p b simply requires exists one path form pattern regular expression whose alphabet given temporal goals operator represents sequential com position represents choice zero occurrences empty path temporal goal list temporal predicates enclosed curly brackets temporal predicate either ordinary predicate like atomic example examined ticked predicate like use think patterns usual way au tomata edges labelled temporal goals turn temporal goal interpreted property edge flow graph pattern holds edge e constituents holds edge e check whether ticked predicate holds e simply add e parameter given predicate nonticked predicates ignore e shall write g e interpretation temporal goal g edge e precise meaning exists exists means words exists path flow graph sequence goals pattern leads initial state final state automaton q goal holds corresponding edge universal path patterns similarly defined except require least one path satisfies given pattern wit means exists words exists path desired form additionally paths form predicate pattern term term exists pattern term term predsymterm term notpredicate predicate pattern tpred tpred pattern pattern pattern tpred predicate predsymterm term figure 2 syntax path logic programming point worth mentioning proposal add temporal features prolog means new idea 25 application features specification program transformations however appear novel 4 transforming eil graphs 41 logic terms eil remarked earlier abstract syntax eil carries quite lot detailed information expressions reflected representation expressions logic terms thus integer literal 5 becomes logic term expr type constructor reflects fact expressions typed first parameter expression second type type inttrue b32 32bit signed integer true would become false wanted unsigned one construct constant literal constructor ldc used takes type parameter redundant simplifies processing eil parts transformation system literal value slightly complicated example expression x local variable represented inttrue b32 inttrue b32 inttrue term localvarsnamex refers local variable x seemingly redundant constructor sname reflects fact also possible use dierent constructor refer local variables position methods declaration list although facility currently used constructor applyatom exists simplify relationship il eil term addfalse true directly corresponds il instruction add adds top two items stack signed values without overflow thus meaning applyatom summarised ap ply il instruction first parameter rest parameters stack finally remains explain eil instructions defined shall used label edges nodes flow graphs instruction either expres sion branch return statement combined list labels statement using constructor instr label example following defines conditional branch label target branchcond note borrow notation lists functional programming writing lieu x xs current instruction expression exp enclosing expression would used place branch similarly return used case return statement eil constructors shall introduced encounter 42 defining conditions eil terms nodes graph labelled logic term corresponding eil instruction node ad dition described earlier edge labelled term eil instruction node edge points labels used solve existential universal queries anticipate future versions system complex analysis information stored nodes edges information dier nodes edges logic language provides primitives access relevant label given node edge elabele holds instruction edge e vlabelv holds instruction node v use convention giving primitives names beginning thus define set predicate used section 3 follows e expexpr elsewhere adopt prolog convention singleton variables named identifier starts underscore straightforward define def terms set e setx also need define use based predicate occursr x checks whether x occurs r obvious recursive traversal defining usex e want distinguish uses x definitions x whilst still finding uses variable x expressions ax usex e elabele occurss x usex e set l r e occursr x 43 modifying graph although logic language described makes convenient define side conditions program transfor mations would rather dicult use language actually apply transformations since would require program flow graph represented logic term approach take successful logic query also bind parameter list symbolic actions define correct transformation flow graph highlevel strategy language responsible directing order logic queries tried applying resulting transformations strategy language similar found literature rewriting 5 31 shall discuss action term either form replace vertexv w new localt n former replaces vertex v vertex w latter introduces new local variable named n type thus overall propagation rewrite defined follows propagate rewritereplace vertex n predicate buildn v creates new vertex copying old vertex n replacing uses x vlabeln old listof new vertex new es already discussed primitive vlabel predicate constructs term new old replacing uses x v use defined apply definitions x replacing x 0 x x 1 want end x 01 new vertices constructed using new vertex primitive takes vertex label list outgoing edges binds new vertex final parameter case use list edges old vertex since wish replace label predicate sourcen e true vertex n source edge e whilst listof predicate standard prolog predicate takes three parameters term predicate involving free variables third parameter bound list instantiations solve predicate thus overall eect listof e sourcen e es bind es outgoing edges node n required 5 optimisations remainder paper consists examples intended evaluate design sketched shall first examine number typical compiler optimi sations present context transformations used clean code results either translation il eil obfuscations partic ular examine dead assignment elimination form constant folding dead branch elimination chosen representative list however exhaustive essential applied conjunction transformations embark detailed coding therefore summarise one transformations particularly important discussed section 2 transformation il eil creates many extra local variables example il instructions stloc x translated something form easily seen assignments combined give newly created local variables generally used exception original il code control flow split program point values stack local variable used assignment propagated regardless whether value assigned atomic long value changed meantime transformation carry propagation follows similar pattern atomic propagation defined section 3 shall spell details 51 dead assignment elimination propagation atomic values removal unique variable uses described places code variables assigned value used afterwards assignments replaced nop subsequent transformation remove nops completely convenient two phases many transformations remove code would otherwise careful preserve labels removed instructions case jumps labels existed let us look conditions needed transformation pure exists setx v localx entry n noted although used exists query really need case looking single node satisfies certain conditions entire path however turns convenient express query way predicates use already defined respect edges first part condition states need expression form x v node n also require x local method v pure ie side eects conditions defined standard prolog predicates second part condition require node n x longer used except node n another definition x exit method body reached first define predicate unused capture first half requirement note permissible use negation since x already bound ground term unused atn x e isnoden e unused atn x e notusex e define path condition unused unused atn x words paths node n exit use node n unless first redefine x transformation appropriate use build produce new vertex since entire assignment needs replaced nop instead vertex created manually dead codereplace vertex n pure assignmentx v n unused listof vlabeln instr labell new vertex instr label l expexpr typeapplyatomnop void es nopvert 52 evaluation elimination unique uses variable atomic value propagation performed often left expressions involving constants could evaluated example z would transformed z would like right hand side assignment replaced 52 need predicate tries evaluate arithmetic operations constant expressions try evaluate bind resulting integer j base case states value constant constant evalapplyatomldcinttrue b32 n n another clause eval evaluating addition evall v1 evalr v2 v v1 v2 noted inspecting overflow sign bits ov semantics dictate future versions implementation employ reflection ensure semantics compiletime evaluation exactly runtime evaluation using eval eil expression leaves us integer succeeds convert back eil inttrue b32 apply evaluation node look nonatomic expression node allowed atomic expressions evaluated constant values would repeatedly transformed replace expression value eval succeeds evaluatereplace vertexn exists usef entry n buildn ce f use build replace original expression f ce 53 dead branch elimination one obfuscations see section 622 adds conditional branches program evaluation conditions branches elsewhere may find constant condition therefore redundant keeping specification il assume true defined nonzero integer first need find suitable conditional branch specify predicate test whether vertex conditional branch instruction cond branchcond labels e labellabels branchcondcond use find true branch look constant conditions whose value nonzero replace branch vertex nop pointing true branch dead assignment elimination simpler overall replacing branch statement true vertex dead branchreplace vertex branchvert exists cond branch applyatomldcinttrue b32 n inttrue b32 labels entry branchvert listof edge sourcebranchvert edge trueedge new vertex instr label labels expexpr typeapplyatomnop void nopvert use listof discussed earlier obtain list outgoing edges branchvert graph representation guarantees edges ordered true branch first false branch repeat definition require n equals 0 condition replace trueedge falseedge construction nopvert 6 obfuscations relatively easily decompile il code back highlevel language c therefore software distributors wish avoid source code revealed example prevent tampering protect secret algorithm need take steps make harder one possibility obfuscate il code distribute although preventing decompilation completely likely impossible especially case verifiable il code applying transformations make source code results decompilation dicult understand might acceptable alternative section show path logic programming used give formal executable specifications two representative examples collbergs taxonomy obfuscating transformations 8 variable transformation array splitting 61 variable transformations idea variable transformation pick variable local method replace occurrences method new variable j related need function f bijective domain z subset z potential values known range z could subset also need f inverse f exists f bijective transform need perform two types replacements expressions form e definition transformed j f uses ie definition replaced f 1 j 611 example let us take f program brif 15 loop transformed brif j 2 15 loop could also define transformations conduct algebraic simplification would turn brif j 30 loop 612 implementing transformation initial phase transformation find suitable variable require variable assigned somewhere local choose variable oldvar generate fresh variable name using fresh name takes type parameter name generated reflect type well producing action adds new local variable method following introduce local predicate returns old new local variables needed next phase actually transform uses definitions old variable introduce localoldvar newvar new localinttrue b32 exists setoldvar v inttrue entry oldvarvert fresh nameinttrue b32 newvarname snamenewvarname inttrue b32 new local introduced carry obfuscation exhaustively replacing uses definitions old variable appropriate first specify predicates build representations functions f outlined section 611 predicate use fna b binds b representation f 1 use fn applyatomcdivtrue ldcinttrue b32 2 inttrue b32 inttrue similarly define assign fnc binds representation f c simple replace uses oldvar replace useoldvar newvar replace vertex oldvert newvert exists useoldvar entry oldvert use fnnewvar newuse buildoldvert newuse oldvar newvert similarly replace assignments oldvar 62 array transformations method uses one arrays rearrange arrays example permuting elements one merging two arrays one splitting one two separate arrays essence array transformations type variable transformation key point access use definition element one original arrays translated access element one transformed arrays one original arrays used entirety example assigned another array would need replaced code dynamically apply transformation entire array could major impact runtime performance program therefore avoid applying array transformations situations would necessary consider arraytyped local variable array transformation applied every path method reaches particular initialisation variable newly created array using il instruction newarr occurrences array variable reached initialisation accesses element array rather use definition array variable 621 array splitting obfuscation going specify array split idea array splitting take array place elements two new arrays necessary define functions determine elements original array mapped ie array position array let us look simple example suppose array size n want split two new arrays b1 b2 want b1 b2 size possibly diering one ele let b1 size n 1 div 2 b2 size n div 2 relationship b1 b2 given following rule b1 div 2 even program int new int20 int brif 20 loop transformed int b1 new int10 int b2 new int10 int i2 else b2i 12 brif 20 loop else strictly part eil implementation terms branches obvious 622 specifying transformation general suppose array size n define array split two arrays need three functions c f 1 f 2 two new arrays b1 b2 sizes m1 m2 respectively m1 m2 n types functions follows relationship b1 b2 given following rule ensure index clashes new ar rays require f 1 f 2 injective also make sure elements fairly distributed b1 b2 means c partition 0n approximately equal pieces 623 finding suitable array show implement array split using transformation outlined example section 621 let us look conditions necessary transformation first need find place array initialised array initialiseinitvert oldarray type exists setoldarray applyatom newarrt inttrue b32 arraytype arraytype ctype type spectype entry initvert condition states initvert instruction form oldarray newarrtypesize oldarray local variable array type standard representation types il using far known ctype however type parameter newarr takes slightly dierent form known type spec use predicate ctype type spec compare two thus make sure dealing welltyped array initialisation next step check every path method reaches initialisation point array variable used except access array element predicate unindexedoldarray e holds oldarray used without index node pointed edge e gives us following condition ok transforminitvert oldarray isnodeinitvert unindexedoldarray entry exit 624 initialising new arrays next need create two new arrays correct sizes size old array n sizes new arrays n 12 n2 define predicates div two plus one div two construct appropriate expressions given original array size since expression computes original array size might side eects quite complicated first introduce new local variable hold value expression repeat computation thus need construct three new vertices replace initvert one initialise local variable two initialise new ar rays omit details minor diculty new vertex requires list outgoing edges constructing new edges requires target vertex must construct vertices reverse order appear graph 625 replacing old array next step exhaustively replace occurrences old array occurrence follows newly inserted initialisations need insert dynamic test index old array accessed access one two new arrays depending result dynamic test finding occurrences straightforward define predicate array occursa e looks occurrence form ai e search nodes occurring initialisation second new array whose vertex bound secondinitvert find old arrayoldarray exists array occursoldarray index secondinitvert occursvert using newly bound value index construct necessary nodes replace occursvert omit details 7 related work paper contribution extensive literature specifying program analyses transformations declarative style section shall survey closely related work directly prompted results presented apts system paige 26 major source inspiration work presented apts program transformations expressed rewrite rules side conditions expressed boolean functions abstract syntax tree data obtained program analyses functions ways similar presented gone little embedding variant prolog contrast apts analyses coded hand norm similar systems constructed highperformance computing community mt1 4 tool restructuring fortran programs another dierence systems transform tree structure rather flow graph learnt idea taking graph rewriting basis transformation toolkit work assmann 3 whitfield soa 32 assmanns work based general notion graph rewriting highly declarative nature little dicult ever express properties program paths whitfield soas system allow expression properties number primitives specialisations predicate p main contribution relative work generalisation embedding prolog use path patterns examining graph struc ture contain logical variables borrowed literature querying semistructured data 6 existential path patterns considered relative work contribution explore utility universal path patterns well liu yu 20 derived algorithms solving regular path queries using predicate logic language inclusion although patterns yet support free variables purposes essential applying transformations case using prolog vehicle expressing program analyses forcefully made 11 research team went embed model checkers prolog 10 indeed inspiration implementing exists primitives tabling kris de volders work taught us use prolog applying program transformations 13 8 discussion presented modest extension prolog namely path logic programming extension modest syntactic semantic terms introduced two new forms predicate easy compile standard prolog primitives resulting program uses tabling conduct depthfirst search product automaton determinised pattern flow graph 12 could chosen give specifications terms modal logic instead regular expressions indeed modal logic specifications starting point line research 19 believe regular expressions little convenient may due familiarity formal comparison expressivity alternate styles would valuable 81 shortcomings number problems need overcome ideas presented applied practice transformations need take account aliasing recently updated implementation add prolog primitives conduct alias analysis demand alternative approach would annotate graph alias information eciency would desirable prolog interpreter proceeds incrementally work done transformation reused afterwards current implementation oblivious previous work therefore inecient currently developing algorithm address concern hope able report results soon deal mutually recursive procedures would accurate describe paths program contextfree grammar instead traditional flow graph 23 engaged implementation system three problems main idea compile logical goals form q standard analysis 1 allows smooth integration standard data flow analyses also reuse previous work incremental computation analyses however require us make step standard logic programming prolog inequality constraints programming languages path logic programming would greatly benefit static typing discipline experience programming errors come building syntactically wrong eil terms could easily caught type system mercury 27 fact mercury already net implementation 14 argument integrating new features language rather standard prolog current implementation language standard ml transformations involve scope information tricky keep track exact binding information possibility variable capture framework provide support handling diculties automatically diculty solved higherorder logic programming 24 hope integrate ideas work later stage transformation sideconditions quickly become quite complex readability resulting description prolog something concern hope judicious modularisation prolog programs appropriate use strategy language separate dierent transformations addresses issue experience required determine whether actually works practice large sets complex transformations 82 applications path logic programming might applications beyond presented example aspectoriented programming one needs specify sets points dynamic call graph 18 current language proposals specification pointcuts somewhat ad hoc path logic programming could provide principled alterna tive furthermore could use transformation technology presented achieve compiletime improvement aspectoriented programs 21 another possible application path logic programming static detection bugs path queries could used look suspect patterns code indeed nature patterns dawson englers work bug detection 7 similar presented first note variant logic programming would wellsuited application area roger crew designed language astlog inspection annotated abstract syntax trees 9 suggestion work extended inspection program paths thus making connection extensive literature software model checking 83 acknowledgements would like thank colleagues programming tools research group oxford many enjoyable discussions topic paper would also like thank david lacey krzysztof apt hidehiko masuahara paul kwiatkowski three anonymous ppdp reviewers many helpful comments stephen drape ganesh sittampalam supported research grant microsoft research 9 r inside c specify program analysis transformation graph rewrite systems transformation mechanisms mt1 query language algebra semistructured data based structural recursion checking system rules using systemspecific taxonomy obfuscating transformations astlog language examining abstract syntax trees logic programming model checking practical program analysis using general purpose logic programming systems case study universal regular path queries compiling mercury logic programming approach implementing higherorder term rewriting programmers introduction c imperative program transformation rewriting solving regular path queries compilation semantics aspectoriented programs technical overview commmon language infrastructure interconvertibility class set constraints contextfree language reachability overview temporal modal logic programming viewing program transformation system work logic programming programmers optimizing java bytecode using soot framework feasible language program transformation based rewriting strategies approach exploring code improving transformations tr compilers principles techniques tools logic programming approach implementing higherorder term rewriting practical program analysis using general purpose logic programming systemsmyampersandmdasha case study approach exploring code improving transformations interconvertibility class set constraints contextfreelanguage reachability programmers introduction c 2nd ed inside c universal regular path queries overview temporal modal logic programming logic programming model checking uniformly specify program analysis transformation graph rewrite systems optimizing java bytecode using soot framework imperative program transformation rewriting solving regular path queries viewing program transformation system work unql query language algebra semistructured data based structural recursion soot java bytecode optimization framework ctr mathieu verbaere ran ettinger oege de moor jungl scripting language refactoring proceeding 28th international conference software engineering may 2028 2006 shanghai china yanhong liu tom rothamel fuxiang yu scott stoller nanjun hu parametric regular path queries acm sigplan notices v39 n6 may 2004 ganesh sittampalam oege de moor ken friis larsen incremental execution transformation specifications acm sigplan notices v39 n1 p2638 january 2004
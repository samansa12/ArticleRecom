optimal deterministic protocols mobile robots grid paper studies system robots operating set n work locations connected aisles nxn grid mnform time robots need move along aisles order visit disjoint sets locations movement robots must comply following constraints 1 two robots collide grid node traverse grid edge time 2 robots sensory capability limited detecting presence another robot neighboring node present deterministic protocol small constant e 0 allows m1en targets target visited one robot also prove lower bound showing protocols known n general n suboptimal randomized protocols known b introduction multi robot grid system shortly mrg consists robots operate set locations connected aisles n theta grid st95 time robots located distinct grid nodes time time robot given set work locations targets visited target sets disjoint particular order prescribed visiting targets set moreover robots may end arbitrary locations visits completed may regard system representing warehouse tertiary storage eg tape system robots employed gather redistribute items simplicity assume system synchronous robots provided identical clocks control distributed sense robots moves scheduled locally processor embedded robot goal design efficient distributed online protocol every robot must follow order visit assigned targets avoiding deadlocks conflicts robots specifically protocol must comply following rules ffl time robots reside grid ie robot leave grid enter outside ffl two robots occupy grid node traverse grid edge time ffl robot cannot exchange information robots directly however robot equipped shortrange sensor able detect presence robots occupying nodes manhattan distance one current location ffl one time unit robot perform constant amount internal computation read output shortrange sensor decide whether remain current grid node move neighboring node mrgn problem n robots mrg system required visit n targets grid node target one robot sake simplicity assume n power 4 grid recursively decomposed subgrids whose size still power 4 general case n even power handled minor modifications 11 related work mrgn problem originally introduced st95 practical case study within general quest social laws coordinate agents sharing common environment distributed rather centralized fashion central control relies single arbiter regulates possible interactions among agents distributed control based set local rules must complied order avoid conflicts need distributed control stems number shortcomings may limit applicability central protocol need reprogramming system set agents changes time overhead computation communication introduced arbiter fact distributed protocol may exploit better intrinsic parallelism problem since agent programmed independently others follow common set rules order efficient distributed protocol must require minimal amount communication regulate interaction agents hence protocol must based simple rules applied locally quickly although mrgn problem entails routing robots twodimensional grid exhibits however fundamental differences classical message routing problems nodes network used exchange messages typically processing units able compute maintain local status many cases temporarily buffer messages transit contrast mrg system grid nodes passive entities status computing power robots active agents system must orchestrate movements solely based processing sensory capabilities moreover message routing packets travelling network destroyed replicated long message eventually delivered destinations clearly admissible dealing robots reasons also observed pu96 none many message routing protocols known literature appears directly applicable mrgn problem see lei92 sib95 comprehensive surveys grid protocols even hotpotato protocols require simple operations nodes employ internal buffers directly applicable since work assumption one time unit node may receive packet neighbor manipulate information carried packet headers redistribute packets suitably permuted neighbors eg see ns95 nevertheless show paper techniques employed message routing suitably yet trivially adapted devise efficient solutions mrgn problem instance mrgn problem trivially completed letting robots circulate along directed hamiltonian cycle traversing grid nodes fact preminger upfal pu96 proved deterministic protocol robots completely blind ie robot cannot detect presence robots distance requiresomega n time thus implying optimality trivial strategy case robots n time necessary worst case due grid diameter clearly single robot single destination mrgn 1 1 problem achieve bound simply traversing shortest path source target larger number robots single destination per robot mrgn 1 problem two optimal theta ntime protocols presented st92 st95 two special cases first protocol designed n 14 robots second one works robots long initially reside distinct columns known protocol deals arbitrary number n robots single destination given pu96 algorithm randomized solves problem suboptimal log n time high probability however algorithm works relaxed set rules specifically assumes robots shortrange sensor able detect presence robots distance two robot may initially stay outside grid arbitrary amount time robots disappear grid soon visited target deterministic protocol takes time works stricter rules described paper known mrgn 1 problem case 1 targets one could repeat singletarget protocol times however show paper strategy achieve optimal performance best knowledge specific algorithm case 1 targets developed far 12 results devise simple general protocol mrgn 1 problem n4 attains optimal theta n time algorithm implements routing strategy way fully complies constraints imposed mrg system protocol improves upon work pu96 several directions first protocol deterministic hence provides worstcase guarantee performance second achieves optimality general case thus reducing running time pu96 log n factor third works weaker model robots reside grid time sensors detect robots distance one next consider case 1 targets put constraint order visits fixes priori sequence targets reach robot simple argument based diameter considerations suffices prove protocol problem quiresomega n time worst case consequently applying optimal mrgn 1 protocol times yields optimal theta p ntime general solution case however robots arbitrarily rearrange order targets latter approach becomes suboptimal indeed prove anomega ip lower bound mrgn problem provide optimal theta ip time protocol matches lower bound n arbitrarily fixed constant first nontrivial solution general case mrg problem must remarked protocols require common clock governing robots movements results pu96 st95 adapted hold slightly weaker notion synchronicity paper organized follows section 2 describes optimal deterministic protocol mrgn 1 problem assumption n4 section 3 protocol extended handle general mrgn problem n section also proves lower bound showing optimality extended protocol final conclusions open problems drawn section 4 2 case single targets consider arbitrary instance mrgn 1 problem n4 basic idea behind protocol perform routing sorting typical strategy employed context packet routing however need develop specific primitives order implement strategy restrictive rules mrg system following assume time robot knows coordinates current location let us consider grid partitioned n4 2 theta 2 subgrids call tiles protocol simple highlevel structure consisting four phases outlined ffl phase balancing robots relocate grid robot ends topleft node distinct tile ffl phase ii sortingbyrow robots sort target row sorted sequence robots arranged grid one robot per tile according peano indexing mor66 shown pictorially figure 1 described mathematically later words end sorting ith robot sorted order occupies topleft corner tile peano index ffl phase iii permuting sorted sequence robots permutes peano indexing rowmajor indexing ffl phase iv routing robots first circulate within columns tiles reach rows containing targets circulate around rows visit targets describing four phases detail show perform basic primitives mrg system needed implement phases pack given q robots tnode linear array pack q consecutive nodes one end array solution robot repeatedly crosses edge towards designated end whenever shortrange sensor detects node across edge empty collisions arise way moreover simple argument shows time steps robots completed packing 2 count given q robots tnode linear array make q known robot solution robots first pack one end array robot ends ith location one end jth location sets primitive requires 2t steps 2 compareswap given tile two robots sort two robots one associated smaller target row goes top left corner goes bottom left corner solution suppose two robots start top bottom left corners tile robots execute number rounds learn relative order sorted sequence specifically ith round robots implicitly compare ith significant bit binary representation respective target row follows robot positions left corner row tile bit 0 positions right corner bit 1 robot infer robots bit simply checking presence column first time robots find different bits robot whose bit 0 moves top left corner moves bottom left corner algorithm ends robots target row ie bits equal stay starting positions overall computation takes log n steps 2 following subsections describe four phases protocol detail 21 phase balancing phase n4 robots start arbitrary positions grid must distribute among n4 tiles tile contains one robot topleft node accomplished log steps numbered 0 log according following inductive scheme beginning step even robots already distributed evenly among square subgrids size induction clearly holds step robots work independently within square subgrid partition evenly among rectangular subgrids size n2 i2 analogously step odd robots work independently within rectangular subgrid size partition evenly among square subgrids size clearly end step log robots evenly partitioned among subgrids size 2 theta 2 tiles one robot per tile point robot moves topleft corner tile describe implementation step odd implementation balancing step even index requires minor modifications consider arbitrary theta t2 rectangular subgrid suppose p robots subgrid let rows resp columns subgrid numbered 1 resp t2 end step want bp2c robots upper half top t2 rows remaining dp2e lower half bottom t2 rows subgrid done following substeps 1 robots row pack towards left 2 robots column pack towards bottom comment step robots form staircase descending northwest southeast subgrid 3 column k t2 robot determines number robots column number odd topmost robot referred leftover moves top column leftovers pack towards right topmost row move along column t2 towards bottom column t2 robot determines number robots column comment p 2 4 always case enough room column t2 hold leftovers 5 every column k let x number robots column step 4 note x may odd t2 robots pack around column center ie rows t2 robots pack bx2c end upper half remaining dx2e end lower half lemma 1 phase takes n time proof correctness strategy immediate resulting time bound geometrically decreasing sum whose ith term cost balancing step implemented terms pack count primitives presented 2 22 phase ii sortingbyrow end balancing phase robots spread among grid nodes way one robot tile parked tiles topleft corner robots sort according target row ties broken ar bitrarily sorting algorithm relies upon grid implementation batchers bitonic sorting algorithm bat68 sequences size n4 smaller recall batchers algorithm structured cascade log merging stages beginning ith merging stage 1 log robots partitioned n42 subsequences size 2 igamma1 pairs subsequences merged independently end stage n42 sorted subsequences size 2 turn ith merging stage made sequence steps called jcompareswap specifically jcompareswap step compares swaps pairs elements distance 2 j subsequence direction compareswap operator fixed priori depends values j order efficiently implement batchers algorithm grid number n4 tiles according peano indexing defined follows see figure 1 split set indices four equally sized subsets consecutive indices 1g similarly split grid four quadrants n16 tiles assign four subsets indices four quadrants namely h h br stands top b bottom left r right assign set indices 0 h 1 h b 2 h tr 3 h br proceed recursively within quadrants quadrants one tile reached easy argument shows two tiles indices h h phi 2 j peano indexing phi denotes bitwise exclusiveor lie row column tiles depending parity j distance ip jcompareswap step performed follows let k denote integer binary representation 0 position j following substeps figure 1 64 tiles 16 theta 16 grid ordered according peano indexing square represents tile 2 theta 2 grid nodes contains one robot balancing phase executed parallel values k 1 robot residing tile k peano indexing moves tile k 2 robots tile k execute compareswap primitive according target row ties broken arbitrarily one robot tile moves directly tiles top left corner 3 robot larger smaller target moves tile k depending direction jcompareswap operator routing implied step 1 easily performed robots without collisions particular j odd robot tile k first moves bottomleft corner tile moves left reaches bottomleft corner tile k row tile k numbering j even robot tile first moves topright corner tile moves upwards along column reaches bottomright corner tile k positions bottomleft tile step 3 accomplished analogously thus steps 1 3 require ip time overall using compareswap primitive discussed step 2 requires log n time phase ii takes n time proof ith merging stage sorting algorithm 1 log consists sequence jcompareswap steps jcompareswap step takes ip time total running time algorithm log ngamma2 ip 23 phase iii permuting sorting phase robots reside distinct tiles sorted target row according peano indexing phase iii robots permute way sorted sequence rearranged according rowmajor indexing let us call tcolumn resp row column resp row tiles permutation executed according following recursive protocol permutation trivial consider 1 robot h tr swaps positions one occupying corresponding position h b 2 within quadrant sorted subsequence robots recursively permutes peano rowmajor indexing 3 within quadrant robots permute odd trows pack top even trows pack bottom quadrant robot lower half h positions one occupying corresponding position top half h tr resp h br correctness permutation protocol easily established induction give pictorial illustration steps robots initial configuration 43 26 28 50 52 58 22 step 1 28 43 34 36 42 44 50 52 58 step 2 28 step 3 28 step 4 26 lemma 3 phase iii takes n time proof movements robots implied step 1 step 3 step 4 executed conflictfree fashion n time one robot tile since recursive step 2 executed parallel independently within subgrids geometrically decreasing side conclude overall permutation time also n 2 24 phase iv routing routing phase starts robots sorted target row occupying first tiles rowmajor indexing one robot per tile tiles topleft corner number tcolumns resp trows 1 n2 note due sorting tcolumn holds two robots targets row routing performed first moving robots target row final target accomplished parallel follows 1 1 n2 robot residing tcolumn 2i trow j moves topright corner tile tcolumn 2i gamma 1 trow j comment step oddnumbered tcolumn four robots destined row evennumbered tcolumns empty 2 robots oddnumbered tcolumn circulate along directed hamiltonian cycle traversing nodes tcolumn robot traveling right side tcolumn reaches target row attempts shift right adjacent tile moves rightmost unoccupied node tile comment within oddnumbered tcolumn two robots target row able move adjacent tcolumn 3 robots trow circulate along directed hamiltonian cycle traversing nodes trow therefore visiting target locations 4 robots go back tcolumns occupied end step 1 steps 23 repeated deliver robots visited targets yet end robots already completed task attempt shift right step 2 comment robots visited targets beginning step 5 able lemma 4 phase iv takes p n time proof steps 13 require n time altogether executed twice due step 5 step 4 executed follows oddnumbered tcolumn robots row pack left robots evennumbered tcolumn circulate along directed hamiltonian cycle traversing nodes tcolumn robot sees empty spot adjacent tcolumn left moves spot packing left thus step 4 requires n time implies whole routing phase also takes p n time 2 following theorem immediate consequence lemmas 1 2 3 4 theorem 1 instance mrgm n 1 problem n4 solved time n worst case simple diameterbased argument shows running time stated theorem optimal moreover result easily extended case 0 robots one target reach remaining ones visit perform sufficient associate latter robots fictitious destination whose row n1 let participate various phases protocol clearly increase running time 3 case multiple targets section devise protocol general mrgn problem robots needs visit grid nodes grid node visited one robot protocol first presented case n4 extended handle n1 gamma ffl robots constant 0 arbitrarily fixed describing protocols prove lower bound running time protocol mrgn problem lower bound employed later show optimality proposed protocols lemma 5 every choice integers n 1 n exists instance mrgn problem whose solution time proof n 4 4 bound follows diameter argument therefore let us examine case n 4 let n 0 0 largest powers 4 n 0 n note n 0 n4 0 d4 0 n 0 consider square subgrid n 0 nodes partitioned 0 square tiles size suppose one robots 0 centers tiles among targets center tile node row 2th column tile order visit targets robot must traverse least nodes overall time requirement omega ip 31 optimal protocol n4 consider instance mrgn problem n n4 let dc protocol structured sequence k stages geometrically increasing running time 0 k stage robots visit least 4 less 4 i1 destinations accomplish task call robots active stage whereas remaining robots called inert stage note since robots reside grid times protocol must orchestrate movement active inert robots every stage stage 0 stage 1 executed simply running singletarget protocol fifteen times one every possible target robot active stages clearly inert robots participate protocol associating fake destinations described end section 2 stage 2 k n4 robots active let ffi regard grid conceptually partitioned 4 square subgrids ffi nodes refer ffi tiles observe robots active stage fit one quadrant tile stage executed two rounds first round inert robots pack lower half grid active robots tour tiles upper half grid stopping ffi tile time sufficient visit destinations tile progressively accumulating first tile lower half complete tour clearly different robots may stop ffi tile different amounts time depending number targets tile similarly second round inert robots pack upper half grid active robots visit destinations lower half describe detail operations performed robots first round stage omitting description second round virtually identical denote jth tile based snakelike ordering tiles proceeds alternatively lefttoright righttoleft note ffi tiles upper half grid indices j 4 1 robots relocate grid active robots end 1 inert robots pack tiles j 4 2 following sequence substeps repeated 17 delta 4 igamma1 times parallel 2a active robot unvisited targets j visits one arbitrary target 2b robots visited targets j move topleft quadrant robot still unvisited targets j moves bottomright quadrant j 2c robots visited targets j move topleft quadrant j1 2d robots newly arrived j1 pack tiles bottomright quadrant lemma 6 2 k stage correct completed ip time proof fix 2 k consider first round stage argument second round identical note since 2 comprise n4 nodes altogether hence inert robots fit tiles step 1 easily accomplished n time balancing sorting techniques described section 2 substep 2a executed independently within entails one execution singletarget protocol section 2 takes time substeps 2b 2c 2d executed balancing sorting within tiles simple relocations adjacent tiles time correctness substeps follows observing time cannot robots tile j 1 j 4 beginning substep 2d robots 4 igamma1 21 packed tiles bottomright quadrant remains show 17 delta 4 igamma1 iterations step 2 sufficient active robot visit targets upper half grid consider active robot let j number targets j 1 j 4 2 robot stay tile iterations hence total number iterations needed visit targets thus step 2 takes ip time overall since complexity step 2 dominates step 1 ip also running time entire round 2 theorem 2 instance mrgn problem n4 n solved optimal theta ip time worst case proof stage 0 stage 1 correctly performed theta n time theorem 1 correctness complexity stage 1 k established lemma 6 total cost therefore ip optimality follows lemma 5 2 32 extension let ffl fixed constant consider instance mrgn problem robots let c smallest power 2 larger equal 3ffl regard grid conceptually partitioned c 2 ffitiles size ffi ffitile turn divided four ffi4tiles size ffi4 let ffi4tiles numbered 1 4c 2 order visit targets robots employ following protocol 1 robots pack first towards left row towards bottom column thus ending staircase configuration descending northwest southeast grid let b denote two ffitiles northeast corner grid see figure 2 comment shown end step 1 b empty 2 following sequence substeps repeated index 1 2a let r denote set robots occupying ith ffi4tile robots move within grid robots r end ffitile robots return positions beginning step figure 2 configuration robots step 1 2b c 2 times 2b1 robots r visit targets within ffitile currently reside using protocol previous subsection 2b2 robots ffitile move corresponding positions next ffitile according predetermined hamiltonian circuit ffitiles 2c robots r move back grid nodes occupied beginning substep 2a running time protocol analyzed following theorem theorem 3 instance mrgn problem n1 gamma ffl n solved optimal theta ip time worst case proof row column packings step 1 easily accomplished n time end step 1 ffitiles b must empty otherwise would c c robots grid impossible since ffl consider arbitrary iteration step 2 exploiting empty ffitile b repeatedly moving robots adjacent ffitiles robot maintaining relative positions within tile difficult orchestrate relocation grid ffitile always kept empty fixed ffitile robots initially end tile adjacent n time based observation easily seen substep 2a executed time p n theorem 2 substep 2b1 takes ip time since empty ffitile always present grid step 2 easy robots execute substep 2b2 time n since c ip time overall finally substep 2c mirrors substep 2a hence takes time n well thus one iteration step 2 completed time ip theorem follows substeps 2a xi 2c iterated 4c times 2 conclusions studied complexity moving set robots limited sensory capabilities multi robot grid system size p n theta n provided ip deterministic protocol governs movement n1 gamma ffl robots robot may visit distinct locations two robots visit location also proved lower bound showing protocol optimal would interesting extend protocol handle number robots protocol could employed end rules governing system relaxed allow robot stay initially outside grid arbitrary amount time disappear grid soon visits targets finally another interesting open problem concerns extension protocol allow distinct robots visit location best knowledge result known setting except trivial ntime protocol based hamiltonian tour grid nodes acknowledgments authors would like thank elena lodi fabrizio luccio linda pagli ugo vaccaro many interesting discussions comments early stages work referees provided number useful suggestions r proceedings afips spring joint computer conference introduction parallel algorithms architectures arrays ffl trees ffl hypercubes computer oriented geodetic data base new technique file sequencing proceedings 5th scandinavian workshop algorithm theory overview mesh results artificial intelligence planning systems proceedings first international conference social laws artificial agent societies offline design tr introduction parallel algorithms architectures traffic laws mobile robots social laws artificial agent societies hotpotato algorithms permutation routing safe efficient traffic laws mobile robots ctr kieran herley andrea pietracaprina geppino pucci onetomany routing mesh proceedings thirteenth annual acm symposium parallel algorithms architectures p3137 july 2001 crete island greece
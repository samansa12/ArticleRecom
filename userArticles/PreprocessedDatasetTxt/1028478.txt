short signatures weil pairing introduce short signature scheme based computational diffiehellman assumption certain elliptic hyperelliptic curves standard security parameters signature length half dsa signature similar level security short signature scheme designed systems signatures typed human sent lowbandwidth channel survey number properties signature scheme signature aggregation batch verification b introduction short digital signatures needed environments strong bandwidth constraints ex ample product registration systems often ask users key signature provided cd label human asked type digital signature shortest possible signature needed similarly due space constraints short signatures needed one prints barcoded digital signature postage stamp 41 37 third example consider legacy protocols allocate xed short eld nonrepudiation 1 25 one would like use secure signature ts alloted eld length two frequently used signatures schemes rsa dsa produce relatively long signatures compared security provide example one uses 1024bit modulus rsa signatures 1024 bits long similarly one uses 1024bit modulus standard dsa signatures 320 bits long elliptic curve variants dsa ecdsa also 320 bits long 2 320bit signature long keyed human propose signature scheme whose length approximately 170 bits provides level security similar 320bit dsa signatures signature scheme secure existential forgery chosenmessage attack random oracle model assuming computational diehellman problem cdh hard certain elliptic curves nite eld generating signature simple multiplication curve verifying signature done using bilinear pairing curve signature scheme inherently uses properties curves consequently equivalent scheme f constructing short signatures old problem several proposals show shorten dsa preserving level security naccache stern 37 propose variant dsa signature length approximately 240 bits mironov 35 suggests dsa variant similar length gives concrete security analysis construction random oracle model another technique proposed reducing dsa signature length signatures message recovery 38 41 systems one encodes part message signature thus full version paper appeared asiacrypt 01 12 supported nsf packard foundation shortening total length messagesignature pair long messages one achieve dsa signature overhead 160 bits however short messages eg 64 bits total length remains 320 bits using signature scheme signature length always order 160 bits however short message message transmitted along signature dsa signatures message recovery long standard dsa signatures also note patarin et al 40 construct short signatures whose security depends hidden field equation hfe problem signature scheme uses groups cdh problem hard decision die hellman problem ddh easy rst example groups given 27 previously used 26 10 call groups gap diehellman groups gdh groups short show construct signature scheme gdh groups prove security scheme show build gdh groups lead short signatures signature scheme resembles undeniable signature scheme chaum pederson 13 signature scheme several useful properties described section 5 example signatures generated dierent people dierent messages aggregated single signature 11 signature also supports standard extensions threshold signatures blind signatures 9 notation use ef q denote elliptic curve r 1 use ef q r denote group points e f q r use jef q r j denote number points ef q r diehellman groups bilinear maps presenting signature scheme rst review concepts related bilinear maps gap diehellman groups use following notation 1 g 1 g 2 two multiplicative cyclic groups prime order p 2 g 1 generator g 1 g 2 generator g 3 isomorphism g 2 g 1 g 2 4 e bilinear map e one set g allow general case g 1 6 g 2 take advantage certain families nonsupersingular elliptic curves described section 43 proofs security require eciently computable isomorphism one could take identity map g 1 6 g 2 need describe explicitly eciently computable isomorphism map essential security illustrate give next section example bilinear map engenders insecure signature scheme precisely exist setup obtain natural generalizations cdh ddh problems computational codiehellman cocdh compute h 2 g 1 decision codiehellman coddh yes b otherwise answer yes say codiehellman tuple problems reduce standard cdh ddh next dene cogdh gap group pair pair groups coddh easy cocdh hard dene advantage algorithm solving computational codiehellman problem adv cocdha words probability uniform random choice z p h g 1 coin tosses say algorithm breaks computational codiehellman runs time adv cocdha least denition 21 two groups gap codiehellman pair cogdh pair satisfy following properties 1 group action g 1 g 2 map g 2 g 1 computed one time unit 2 decision codiehellman problem solved one time unit 3 algorithm breaks computational codiehellman say g 1 gapdiehellman group gdh group note denition normalizing time algorithms take one time unit normalization algorithm breaks cdh 21 bilinear maps currently examples gap diehellman groups arise bilinear maps 27 brie dene bilinear groups show give gdh groups possible constructions gap diehellman groups exist two groups additional group g jg 1 jg j bilinear map following properties 1 bilinear u ab 2 nondegenerate eg denition 22 two orderp groups bilinear group pair satisfy following properties 1 group action g 1 g 2 map g 2 g 1 computed one time unit 2 group g order p bilinear map e exist e computable one time unit 3 algorithm breaks computational codiehellman joux nguyen 26 showed ecientlycomputable bilinear map e provides algorithm solving decision codiehellman problem follows tuple g consequently two groups bilinear group pair also t2 cogdh group pair converse probably true 3 signature schemes based gap diehellman groups present signature scheme works gap codiehellman group pair prove security scheme next section show leads short signatures scheme resembles undeniable signature scheme proposed chaum pederson 13 okamoto pointcheval 39 brie note gap problems give rise signature schemes however gap problems lead short signatures signature element g 1 signature scheme comprises three algorithms keygen sign verify makes use fulldomain hash function security analysis views h random oracle 7 section 32 weaken requirement hash function h key generation pick random x r public key v 2 g 2 secret key x signing given secret key x 2 z p message 2 f0 1g compute h x signature 2 g 1 verication given public key v 2 g 2 message 2 f0 1g signature 2 g 1 compute verify g 2 v h valid codiehellman tuple output valid output invalid signature single element g 1 construct short signatures therefore need cogdh pairs elements g 1 short representation construct groups section 4 31 prove security signature scheme existential forgery chosenmessage attacks random oracle model existential unforgeability chosen message attack 24 signature scheme keygen sign verify dened using following game challenger adversary setup challenger runs algorithm keygen obtain public key pk private key sk adversary given pk queries proceeding adaptively requests signatures pk q messages choice challenger responds query signature output eventually outputs pair wins game 1 dene adv sig probability wins game taken coin tosses keygen denition 31 forger q q h breaks signature scheme runs time makes q signature queries q h queries hash function adv sig least signature scheme existentially unforgeable adaptive chosen message attack forger q q h breaks following theorem shows signature scheme secure theorem 32 let order p signature scheme existential forgery adaptive chosenmessage attack random oracle model satisfying c g 1 constant depends g 1 e base natural logarithm hence security signature scheme follows hardness cocdh based standard computational diehellman assumption g 1 proof theorem 32 suppose forger algorithm q breaks signature scheme show construct 0 time algorithm b solves cocdh probability least 0 contradict fact let g 2 generator g 2 algorithm b given 2 goal output h 2 g 1 algorithm b simulates challenger interacts forger follows starts giving generator g 2 public key u g r random z p hqueries time algorithm query random oracle h respond queries algorithm b maintains list tuples hm explained refer list hlist list initially empty queries oracle h point 2 f0 1g algorithm b responds follows 1 query already appears hlist tuple hm responds 2 otherwise b generates random coin c 2 f0 1g prc 3 algorithm b picks random b 2 z p 4 algorithm b adds tuple hm hlist responds setting note either way w uniform g 1 independent current view required signature queries let signature query issued algorithm b responds query follows 1 algorithm b runs algorithm responding hqueries obtain w hm corresponding tuple hlist reports failure terminates 2 know c observe therefore valid signature public key 2 algorithm b gives algorithm output eventually algorithm produces messagesignature pair f f signature query issued f tuple hlist containing f b issues query hm f ensure tuple exists assume f valid signature f given public b reports failure terminates next algorithm b nds tuple hm f w b ci hlist reports failure terminates otherwise outputs required h h h r u b g 2 rb completes description algorithm b remains show b solves given instance cocdh problem probability least 0 analyze three events needed b succeed abort result signature queries generates valid messagesignature forgery f f tuple containing f hlist succeeds events happen probability following claims give lower bound terms 1 probability algorithm b abort result signature queries least 1e hence proof without loss generality assume ask signature message twice prove induction makes signature queries probability b abort least 1 1q claim trivially true ith signature query let hm corresponding tuple hlist prior issuing query bit c independent view value could given depends c hm distribution hm whether c therefore probability query causes b abort 1q 1 using inductive hypothesis independence c probability b abort query least 1 1q proves inductive claim since makes signature queries probability b abort result signature queries least 1 1q 2 algorithm b abort result signature queries algorithm view identical view real attack hence pre proof public key given distribution public key produced algorithm keygen responses hqueries real attack since response uniformly independently distributed g 1 responses signature queries valid therefore produce valid messagesignature pair probability least hence pre 3 probability algorithm b abort outputs valid forgery least proof given events e 1 e 2 happened algorithm b abort generates forgery tuple hm f w b ci hlist c 1 time generates output knows value c issued signature query remaining independent view indeed issue signature query value given depends c hm distribution hm whether c could issued signature query f know c independent current view therefore using bounds claims equation 1 shows b produces correct answer probability least eq algorithm bs running time running time plus time takes respond q h q hash queries q signature queries query requires exponentiation g 1 assume takes time c g 1 hence total running time completes proof theorem 32 analysis used proof theorem 32 resembles corons analysis full domain hash note probabilisitc full domain hash pfdh signatures 16 tighter security reduction fdh signatures improvement security reduction applied signature scheme however randomizing signature scheme pfdh would increase length signature defeating main goal constructing short signatures necessity recall proof security relied existence eciently computable isomorphism show necessity give example bilinear map e cocdh problem believed hard g 1 yet resulting signature scheme insecure let q prime let g 2 subgroup z q prime order p generator g let g 1 group g addition modulo p dene map clearly bilinear since eax b ab cocdh problem given problem believed hard since algorithm computing cocdh gives algorithm computing discrete log g 2 hence conditions theorem 32 except known computable isomorphism easy see resulting signature scheme bilinear map insecure given one messagesignature pair easy recover secret key comment one avoid using cost making stronger complexity assumption without necessary assumption proving security polynomial time algorithm compute h 2 g 1 given naturally exists group considering reason rely stronger complexity assumption 32 hashing onto elliptic curves signature scheme needs hash function next section use elliptic curves construct cogdh groups therefore need g 1 subgroup elliptic curve since dicult build hash functions hash directly onto subgroup elliptic curve slightly relax hashing requirement let ef q elliptic curve dened point prime order p wish hash onto subgroup g suppose given hash function 1g hash functions h 0 built standard cryptographic hash functions security analysis view h 0 random oracle use following deterministic algorithm called maptogroup hash messages f0 1g onto g 1 fix small parameter dlog 2 log 2 1e desired bound failure probability algorithm denes h f0 1g g 1 follows 1 given 2 f0 1g set 0 2 represented ibit string 3 fx quadratic residue f q 3a let q two square roots fx use b 2 f0 1g choose roots choose full ordering f q ensure 1 greater 0 according ordering swapping 0 1 necessary set point 3b compute pm pm g 1 output maptogroup h 0 stop 4 otherwise increment go step 2 reaches 2 report failure failure probability made arbitrarily small picking appropriately large probability h 0 k leads point g approximately 12 probability choice random oracle h 0 hence expected number calls h 0 approximately 2 probability given message found unhashable lemma 33 let ef q elliptic curve let ef q order let g 1 subgroup ef q order p assume p 2 divide suppose cogdh signature scheme secure groups used 2 c g 1 secure hash function h computed maptogroup h 0 h 0 random hash function 1g proof sketch suppose forger algorithm f 0 breaks signature scheme hash function h computed using maptogroup h 0 build algorithm f breaks signature scheme h random oracle new forger f run f 0 black box algorithm f passes signatures queries made f 0 signature oracle f uses hash oracle simulate f 0 behavior maptogroup h 0 uses array ij whose entries elements f q f0 1g array q h rows 2 columns initialization f lls ij uniformlyselected elements f q f0 1g f runs f 0 keeps track indexes unique messages f 0 requests h 0 hash f 0 asks h 0 hash message w k whose forger f previously seen whose w arbitrary ibit string f scans row ij 0 j 2 seeking points g smallest j ij maps g 1 f replaces ij dierent point dened follows let constructs random point follows 1 let p note mp integer since p divides furthermore mp inverse modulo p since p 2 divide hence mp relatively prime p 2 pick random point 3 set random point ef q mp set maps step 3a maptogroup maptogroup h 0 required preliminary patching completed f able answer h 0 hash queries f 0 strings w k simply returning iw simulated h 0 f 0 sees statistically indistinguishable real attack thus f 0 succeeds breaking signature scheme using maptogroup h 0 f running f 0 consulting h succeeds likelihood suers runningtime penalty maintaining additional information running exponentiation step 3 maptogroup algorithm assume exponentiation g 1 takes time c g 1 building cogdh groups small representations using weil 29 pp 243245 tate 18 pairings obtain cogdh groups certain elliptic curves recall necessary facts elliptic curves see eg 29 44 show use certain curves short signatures 41 elliptic curves weil pairing goal construct bilinear groups lead cogdh groups discussed section 21 let ef q elliptic curve rst dene useful constant called security multiplier subgroup hp ef q denition 41 let q prime power ef q elliptic curve points ef q let p ef q point prime order p say subgroup hp security multiplier integer 0 order q f p words security multiplier ef q security multiplier largest prime order subgroup ef q describe two families curves provide 6 standard security parameters sucient obtaining short signatures open problem build useful elliptic curves slightly higher say rst step dene g 1 g 2 describe bilinear map e describe isomorphism discuss intractability cocdh balasubramaniankoblitz let ef q elliptic curve let p 2 ef q point prime order p p 6 q suppose subgroup hp security multiplier 1 ie p q 1 useful result balasubramanian koblitz 3 shows ef q contains point q order p linearly independent p set g note g 1 ef q g 2 ef q weil tate pairings let ep group points order dividing p ef q group ep isomorphic z p z p 44 also g 1 g 2 ep weil pairing q following properties 1 2 bilinear r 1 3 nondegenerate r 2 ep er r 0 4 computable r 1 pairing er 1 computable polynomial time 34 note er 1 r 1 r 2 linearly dependent see 31 10 denition weil pairing description algorithm computing tate pairing 18 another useful bilinear map ep properties similar weil pairing necessarily satisfy property 1 identity weil pairing curve e gives computable nondegenerate bilinear f q enables us solve decision codiehellman problem groups tate pairing nondegenerate g 1 g 2 also used solve decision codiehellman trace map present computable isomorphism using trace map tr sends points ef q ef q let galois maps f q f q also trace map tr ef q dened fact 42 let p 2 ef q point prime order p 6 q let hp security multiplier 1 let q 2 ef q point order p linearly independent p trq 6 tr isomorphism hqi hp proof suppose r 2 ef q point order p r hp p r generate ep therefore ep ef q follows ep r 2 f q order p since otherwise e would degenerate ep since 1 know p divide q 1 consequently elements order p f q hence must r 2 hp follows points ef q order p contained hp since trq 6 know trq 2 ef q order p therefore trq 2 hp hence tr isomorphism hqi hp hence trq 6 trace map isomorphism g 2 g 1 computable polynomial time log q required intractability cocdh remaining question diculty cocdh problem necessary conditions cdh intractability best known algorithm solving cocdh compute discretelog g 1 fact discretelog cdh problems g 1 known computationally equivalent given extra information group g 1 30 therefore suces consider necessary conditions making discretelog problem ef q intractable let hp subgroup ef q order p security multiplier brie discuss two standard ways computing discretelog hp 1 mov use eciently computable homomorphism mov reduction 32 map discrete log problem hp discrete log problem extension f q say f q solve discrete log problem f using number field sieve algorithm 43 image hp homomorphism must subgroup f q order p thus denition implies hence mov method best reduce discrete log problem hp discrete log problem subgroup f q therefore ensure discrete log hard hp want curves suciently large make discrete log f q intractable 2 generic generic discrete log algorithms babystepgiantstep pollards rho method 33 running time proportional p p therefore must ensure p suciently large summary want curves ef q generic discrete log algorithm ef q number field sieve f q intractable 42 cogdh signatures elliptic curves summarize construction cogdh groups adapt signature scheme use group points elliptic curve cogdh groups use dened follows 1 let ef q elliptic curve let p 2 ef q point prime order p 1 p 6 q divide jef q j 2 let 1 security multiplier hp balasubramanian koblitz 3 exists point q 2 ef q linearly independent p easy construct q expected polynomial time number points ef q known since 1 know q 62 ef q ensure trq 6 replace q q p q p order p linearly independent p trq 3 4 since p q linearly independent weil pairing gives nondegenerate bilinear map q computed polynomial time log q tate pairing nondegenerate g 1 g 2 also used bilinear map 5 since trq 6 trace map ef q isomorphism g 2 g 1 computable polynomial time log q subgroups g 1 g 2 elliptic curve ef q signature scheme works follows recall maptogroup h 0 hash function maptogroup built hash function q f0 1g described section 32 key generation pick random x r xq public key v 2 ef q secret key x signing given secret key x 2 z p message 2 f0 1g 1 compute 2 xr 2 ef q 3 output xcoordinate signature 2 f q verication given public key v 2 g 2 message 2 f0 1g signature 2 f q 1 find 2 f q point order p ef q exists output invalid stop 2 compute 3 test either e output valid otherwise output invalid signature length dlog 2 qe note verication accept signature account fact signature 2 f q could come either point ef q security theorem 32 suces study diculty cocdh best known algorithm solving cocdh problem requires computation discrete log g 1 computation discrete log f q 43 using nonsupersingular curves elds high characteristic remains build elliptic curves desired security multiplier next two sections show curves security multiplier describing family nonsupersingular elliptic curves family outlined miyaji et al 36 call mnt curves idea follows suppose veried p divides q 6 1 divide q 1 0 6 p prime curve ef q p points likely security multiplier discriminant signature size dlog security mov security 28894627 177 177 1062 9877443 206 206 1236 table 1 nonsupersingular elliptic curves cogdh signatures e curve prime eld f q p largest prime dividing order mov reduction maps curve onto eld discriminant complex multiplication eld ef q build ef q p points use complex multiplication 8 chapter viii brie explain suppose integers another positive integer integer prime complex multiplication method produce elliptic curve ef q points time od 2 log q 3 value called trace curve want curve f q p points plugging values 2 get leads xed 4 need integers satisfying equation prime prime small multiple prime solution verify get curve ef q security multiplier finding integer solutions equation type 3 done reducing pells equation whose solution well known 45 table values lead suitable curves signature scheme example get curve ef q q 168bit prime signatures using curve 168bits best algorithm cocdh ef q requires either 1 generic discrete log algorithm taking time approximately 2 83 2 discrete log 1008bit nite eld large characteristic 44 special supersingular curve another method building curves security multiplier 6 use special supersingular curve ef 3 specically use curve mov reduction maps discrete log problem ef 3 f use two simple lemmas describe behavior curves see also 47 28 lemma 43 curve dened curve e dened proof see 28 section 2 lemma 44 let e elliptic curve dened 1 5 jef 3 j divides 3 6 1 proof see 47 together lemmas 43 44 show relevant values groups curves multiplier 6 specically j 6 whether security parameter actually 6 particular prime subgroup curve must determined computation automorphism useful automorphism make primeorder subgroups opposed cogdh groups fact used shrink size public key since makes possible public key live ef 3 opposed ef 3 6 automorphism dened follows mod 12 1 5 compute three elements f 3 6 u r r satisfying consider following maps f 3 6 lemma 45 let mod 12 equal 1 5 automorphism automorphism e f 3 6 moreover p point order p point order p linearly independent p proof see silverman 44 p 326 let ef 3 one e point prime order p set g group generated p let ef 3 automorphism curve dene modied weil pairing standard weil pairing ep lemma 45 know p linearly independent e nondegenerate follows g 1 gdh group two implications signature scheme security signature scheme based diculty standard computational diehellman problem g 1 opposed cocdh problem public keys elements g 1 hence shorter public keys automorphism exist curve l sig size dlog security mov security table 2 supersingular elliptic curves gdh signatures p largest prime divisor j mov reduction maps curve onto eld characteristic 3 size 3 6 useful curves useful instantiations curves presented table 2 note restrict instantiations prime avoid weildescent attacks 21 22 except 121 recently shown certain weildescent attacks eective case 17 suggesting may safe use performance galbraith et al 20 baretto et al 4 show frobenius map used speed computation weil tate pairings curves results signicant speedup signatureverication algorithm consequently signature scheme using curves much faster scheme using curves previous section bad news mov reduces discrete log problem discrete log problem f discretelog algorithm due coppersmith 14 43 specically designed compute discrete log small characteristic elds consequently discretelog problem f much easier discretelog problem f p prime approximately size 3 n get security equivalent dsa using 1024bit prime would use curve much larger 1024 bits leads much longer signatures defeating point using curves words xed signature length supsersingular curves lead signature reduced security compared curves previous section 45 open problem higher security multipliers curves section 43 security multiplier sucient constructing short signatures security comparable dsa using 1024bit prime however obtain security comparable dsa using 2048bit prime signatures length bits elliptic curves higher say would result short signatures higher security needed 2048bit discretelog security let q large prime power say q 2 160 currently open problem construct elliptic curve ef q ef q prime order baretto et al 5 show build elliptic curves e ef q given security multipliers however largest prime order subgroup ef q much smaller q consequently curves cannot used secure short signatures generic discretelog algorithm ef q break scheme time proportional p p p largest prime factor jef q j one could also build gdh groups higher genus galbraith 19 constructs supersingular curves higher genus large security multiplier example jacobian supersingular curve point jacobian curve genus two characterized two values f 2 two xcoordinates reduced divisor length signature 2 bits hence might obtain signature length 2 security computing cdh nite eld f 2 12 factor 6 length signature degree nite eld elliptic curve case hence genus 2 curve improve security signature give variety curves used short signatures discrete log jacobian curves reducible discretelog eld characteristic 2 consequently one must take coppersmiths discrete log algorithm 14 account discussed end section 44 obtain larger security multipliers rubin silverberg 42 propose certain abelian varieties supercially show signatures produced using curve section 44 shortened 20 result nbit signature pairing reduces discrete log problem nite eld size approximately 2 75n useful example currently know multiplier greater 6 extensions signatures support threshold signatures batch verication surprisingly signatures distinct people distinct messages aggregated single convincing signature brie survey extensions refer boldyreva 9 verheul 46 boneh et al 11 full description proofs security 51 aggregate signatures common environments require managing many signatures dierent parties distinct messages example certicate chains contain signatures distinct certicates issued various certi cate authorities signature scheme enables us aggregate multiple signatures distinct entities distinct messages single short signature party signatures aggregate signatures aggregation done incrementally two signatures aggre gated third added aggregate see 11 applications bilinear group pair prime order p suppose n users publicprivate suppose user signs message 2 f0 1g obtain signature aggregate signatures computed simply 1 2 n 2 g 1 aggregate verication given public f0 1g aggregate signature 2 g 1 verify signed message test 1 messages distinct 2 e conditions hold accept aggregate signature otherwise reject refer 11 exact security model proof security attacker existentially forge aggregate signature subverted solve cocdh aggregate signature verication requires bilinear map generic gap diehellman group apparently insucient generic gap diehellman groups sucient verifying aggregate signatures message dierent people verifying aggregate signatures distinct messages person 52 batch verication suppose n users sign message 2 f0 1g obtain n signatures show n signatures veried batch much faster verifying one one similar property holds signature schemes 6 cogdh group pair prime order p suppose user private key x public key v verify n signatures batch use technique due bellare et al 6 1 pick random integers c n range 0 b value b b controls error probability discussed 2 compute 3 test g 2 v hmu coddh tuple accept n signatures reject otherwise theorem 33 6 shows incorrectly accept n signatures probability 1b hence verifying n signatures batch faster verifying one one note signers required prove knowledge private keys taking c sucient yielding even faster batch verication 9 similar batch verication procedure used verify quickly n signatures distinct messages issued public key 53 threshold signatures using standard secret sharing techniques 33 signature scheme gives immediate robust toutofn threshold signature 9 threshold signature scheme n parties possesses share private key party use share private key produce share signature message complete signature constructed least shares signature available robust toutofn threshold signature scheme derives signature scheme follows central authority generates publicprivate key pair let x 2 z p private key public key central authority picks random degree 1 polynomial user value x share private key authority publishes public key v n values signature message 2 f0 1g needed party wishes participate signature generation publishes share signature loss generality assume users participate generate shares anyone verify share valid checking g 2 codiehellman tuple shares valid complete signature recovered mod fewer users able generate signature message users used solve cocdh threshold scheme robust participant contributes bad partial signature detected immediately since g codiehellman tuple note need trusted third party generate shares private key n users generate shares private key without help trusted third party using protocol due gennaro et al 23 6 conclusions presented short signature based bilinear maps elliptic curves signature one element nite eld standard signatures based discrete log dsa require two elements signatures much shorter current variants dsa security showed scheme existentially unforgeable chosen message attack random oracle model assuming computational diehellman problem hard certain ellipticcurve groups generally signature scheme instantiated gap diehellman group co gdh group pair presented two families elliptic curves suitable obtaining short signatures rst based 36 family nonsupersingular curves prime nite eld second uses supersingular curves f 3 families curves produce nbit signatures discrete log problem curves reducible discrete log problem nite eld size approximately 2 6n hence 1024bit security get signatures size expect rst family curves nonsupersingular curves one used short signatures 171bit signatures 1024bit security discussed end section 44 second family curves supersingular curve f 3 used short signa tures problem discrete log curves reduces discrete log nite eld characteristic 3 coppersmiths algorithm used implementation results 20 4 indicate signature scheme performs well signature generation simple multiplication elliptic curve faster rsa signature generation verication requires two computations bilinear map slower rsa signature verication section 45 outlined open problem would enable us get even better security maintaining length signatures hope future work constructing elliptic curves higher genus curves help solving problem acknowledgments authors thank steven galbraith alice silverberg moni naor victor shoup scott renfro paulo barreto doug kuhlman helpful discussions work r dstu x9 62 fips 1862 improbability elliptic curve subexponential discrete log problem menezesokamotovanstone algorithm constructing elliptic curves prescribed embedding degrees fast batch veri exact security digital signatures sign rsa rabin elliptic curves cryptography aggregate veri short signatures weil pairing wallet databases observers fast evaluation logarithms fields charateristic two exact security full domain hash optimal security proofs pss signature schemes ghsattack odd characteristic tate pairing discrete logarithm applied elliptic curve cryptosystems supersingular curves cryptography implementing tate pairing cryptographic application weil descent constructive destructive facets weil descent elliptic curves secure distributed key generation discretelog based cryptosystems digital signature scheme secure adaptive chosenmessage attacks iso 8583 financial transaction card originated messages one round protocol tripartite diehellman separating decision diehellman diehellman cryptographic groups elliptic curve implementation finite field digital signature algorithm elliptic functions towards equivalence breaking diehellman protocol computing discrete logarithms elliptic curve public key cryptosystems reducing elliptic curve logarithms logarithms finite field handbook applied cryptography short programs functions curves short signature secure dsa new explicit conditions elliptic curve traces frreduction signing postcard message recovery signature schemes based discrete logarithm problem gap problems new class problems security cryptographic primitives postal revenue collection digital age supersingular abelian varieties cryptology discrete logarithms e arithmetic elliptic curves algorithmic resolution diophantine equations abelian varieties finite fields tr ctr meiyuan zhao sean w smith david nicol aggregated path authentication efficient bgp security proceedings 12th acm conference computer communications security november 0711 2005 alexandria va usa gyeong kang je hong park relationship squared pairings plain pairings information processing letters v97 n6 p219224 31 march 2006 giuseppe ateniese alfredo de santis anna lisa ferrara barbara masucci provablysecure timebound hierarchical key assignment schemes proceedings 13th acm conference computer communications security october 30november 03 2006 alexandria virginia usa giuseppe ateniese susan hohenberger proxy resignatures new definitions algorithms applications proceedings 12th acm conference computer communications security november 0711 2005 alexandria va usa giuseppe ateniese jan camenisch breno de medeiros untraceable rfid tags via insubvertible encryption proceedings 12th acm conference computer communications security november 0711 2005 alexandria va usa
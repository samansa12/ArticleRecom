lambda calculus type theory formalized survey substantial body knowledge lambda calculus pure type systems formally developed constructive type theory using lego proof system lambda calculus work abstract simplified proof standardization beta reduction mention redex positions residuals outline meta theory pure type systems leading strengthening lemma one novelty use named variables formalization along way point feel learned general issues formalizing mathematics emphasizing search formal definitions convenient formal proof convincingly represent intended informal concepts b introduction paper hobby first sentence mp93 first report formal development lambda calculus type theory written autumn 1992 continued pursue hobby ever since developed substantial body formal knowledge including churchrosser standardization theorems beta reduction basic theory pure type systems pts leading strengthening theorem type checking algorithms pts work reported mp93 vbjmp94 pol94b pol95 present paper survey work including new proofs point feel learned general issues formalizing mathematics technical side describe abstract simplified proof standardization beta reduction previously published mention redex positions residuals general issues emphasize search formal definitions convenient formal proof convincingly represent intended informal concepts lego proof development system lp92 used check work implementation extended calculus constructions inductive types luo94 lego refinement style proof checker publicly available ftp www users manual lp92 large collection examples section 13 contains submitted journal automated reasoning version paper appears technical report ecslfcs97359 university edinburgh z laboratory foundations computer science university edinburgh x basic research computer science university aarhus centre danish national research foundation information accessing formal development described pa per interesting examples formalized lego include program specification data refinement luo91 strong normalization system f alt93 synthetic domain theory reu95 reu96 operational semantics imperative programs sch97 11 pts beautiful metatheory developed informally bar92 ber90 gn91 vbj93 geu93 papers unusually clear mathematical little doubt correctness sults write machinechecked development informal presentations leave many decisions unspecified many facts unproved far detail representation needed write computer program typechecking pts lemmas needed prove correctness program start longterm goal fill gaps order increase confidence proofchecking programs lego based type theory goal largely met pol95 also basic informal theory pts well stood difficulties formalization suggested reformulations clarify presentation another goal project develop realistic example formal mathematics mathematics computer science prove one big theorem throw away work leading theorem want build body formal knowledge continually extended suggests design criteria formalization representations definitions must suitable whole development specialized single theorem theory structured like computer programs abstraction providing isolation components several parts theory worked simultaneously perhaps several workers inevitable wrong decisions underlying representations later fixed without affecting seriously large theory depends body knowledge want formalize still grow ing eg vbjmp94 reports advances typechecking pts done later original formalization became part formal development work typechecking benefited basic formalization pts since proofs several related systems could easily adapted proofs already done pts new subjects included eg standardization theorem used type theory formalized first author hand claim type theory realistic example formal math ematics especially suitable formalization objects inductively constructed properties proved induction structure little equality reasoning perhaps compelling reason continuing fascination work lure completely concrete yet simple proofs results whose conventional presentation seems require notions messy formalize eg standardization theorem discussed section 34 see proofs beautiful simplicity concreteness tendency formalization throw simplicity winds frustration get proof work checked beautified relatively easily improved definitions arguments mechanically checked easily pointing new glitches suggesting fix also formal development easy come back year later details would otherwise written explicit dont rediscovered 12 related work many formalizations churchrosser theorem sha85 hue94 nip96 pfe92 formalization standardization theorem know coq96a lazy combinator expressions formalizations type theory include db93 bar96 address limited aspects special type theories essentially calculus constructions although bar96 interesting work program extraction mechanism coq used extract executable typechecker proof decidability typechecking contrast cited work except bar96 development hasnt terminated reaching one specified theorem continues grow various directions guided interests work come across feel needs checking example authors checked parts type theory papers asked referee novelty presentation use named variables formalizations type theory lambda calculus know use de bruijn indices nameless variables sha85 alt93 hue94 nip96 bar96 higher order abstract syntax pfe92 avoid formalizing renaming variables prevent unintended capture substitution de bruijn notation concrete suitable formalization reasons formalize theory named variables one thing implementations must use names level whether internally parsing printing either case use names must formally explained interesting insight gained meaning binding many researchers agree de bruijn representation really informally mean lambda terms sense need quotient terms alphaconversion ie intensional equality de bruijn terms corresponds informally meant identity terms nonetheless de bruijn representation coding informal notion binding doesnt address relationship free bound variables namely free variables become bound formalization syntactic terms using named variables concrete names bound variables actually occur parametrically metaformulas containing names free variables done using formulation suggested coquand coq91 based syntactically distinguishing free bound variables 1 work formalization binding substitution using names includes coq96b gm96 owe95 sat83 sto88 work large examples using binding notions would interesting compare development similar example using terms upto alpha conversion gm96 presentation type theory based treating terms named variables concretely martinlofs calculus explicit substitutions tas93 presentation closed alphaconversion presentation section 553 view failure concreteness martinlofs system 13 paper formal development source files development described paper along readme file explaining check available lego www homepage httpwwwdcsedacukhomelego lego uses module system described jp93 based cardellis mock modules car91 source file module module header saying modules depends thus directory modules associated paper contains parallel even incompatible developments type load strengthening file strengtheningl contains proof strengthening pts loaded preceeded every module depends 2 distinction already present gentzen gen69 pages 712 1167 141 2167 prawitz pra65 2 dependencies determined module headers examining 70 proof source files extension l containing 1500 definitions lemmas large amount formal knowledge survey paper uses informal mathematical notation almost every definition lemma mention given formal name typewriter font often parentheses use grep find file defined files used particularly elegant keeping track large amount formal knowledge serious problem addressed well 131 notation mentioned paper uses informal notation arrived manually translating formal lego notation l e x translation purely syntactical chose surpress technical details readable presentation errors quite likely arising translation interpretation paper may informative outline formal work want believe one results must read formal statement formal definitions used statement see pol97 discussion believing large formal development mp93 used formal notation verbatim text manually extracted lego source files translation errors occur reason believe verbatim text paper actually appears files indeed document files drifted apart time pol94b used formal notation mechanically extracting marked sections source files following idea knuths web could rerun extraction update document formal source many readers complained document unreadable formal source presenting formal development serious problem perhaps mechanical extraction mechanical translation informal notation right direction pursue better worse sanitised presentation little purely formal detail shows example mostly sur press distinction boolean values propositional values however dont want hide fact formalization requires many details dont appear informal presentations actual dependencies files 3 l files ones wrote lego generates compiled files extension fully annotated terms generated lego tactics called l file basic notations development uses legos builtin library impredicative definitions usual logical connectives properties use standard notation connectives quantifiers typed ecc reserve symbols range certain types drop type labels almost everywhere eg p reserved range parameters pp well known computer science notations used eg ifthenelse list type lists sometimes concatenation list append funtions ecc total opposed functions object theory lambda terms pts operations take extra arguments failure value eg assoc b l returns b first element pair occurring l pure languages section discuss formalization language pts including terms occurrences substitution derive strong induction principle wellformed terms pure language pl triple pp vv ss ffl pp infinite set parameters ranged p q r global free variables ffl vv infinite set variables ranged v x local bound variables ffl ss set sorts ranged u constants pp vv ss decidable equality pp vv infinite captured assumption every list parameters variables exists parameter variable occurring list eg assuming mathematical principles working parametrically types pp vv ss stated properties instantiated particular types provably properties eg natural numbers lists finite enumeration type working parametrically preserving abstractness stated properties used proofs 4 formula memberp l decidable pp decidable equality 21 terms terms pl trm ranged n e b given grammar atoms variable parameter sort binders lambda pi application precise trm inductively generated six constructors every term thought wellfounded tree whose leaves variables parameters sorts whose interior nodes lambda pi three branches application two branches often define functions trm structural primitive recursion inductive definition usual intend vab fvagb bind v b however intended binding structure determined definition trm made explicit definitions substitution occurrence equality terms defined recursion trm inherits decidability pp vv ss remark 21 notation often case analysis term structure want say binders lambda pi behave way introduce notation hvaia allow combining cases actual formalization notation would saved much cutting pasting developing proofs length term used measure wellfounded induction two properties measure used applications proper subterm b used induction length terms every term positive length used reasoning pts induction sum lengths terms context 22 occurrences parameters sorts list parameters occurring term computed primitive recursion term structure boolean judgement whether given parameter occurs given term decided member function list parameters paramsp p paramshvaia paramsa paramsa similarly defined 23 substitution machinery terms need two kinds substitution parameters variables defined primitive recursion term structure write apm formally psub substitution parameter p entirely textual preventing capture since parameters binding instances terms hiding parameter name binder apq ifpq q apff ff ff 2 vv ss aphvbib hvapbiapb substitution variable v written avm formally vsub respect hiding bound instances substitution prevent capture avx ifvx x avff ff ff 2 pp ss avhxbib hxavbiifvx b avb used safe ways type theory theory reduction conversion prevent unintended capture variables note operations total functions rename variables also occurrences shared regardless whether occur within different binding scopes contrast situation de bruijn indices important lemmas proved vclatom vclosedff ff 2 pp ss vclbind table 1 inductive definition relation vclosed ready supply terms shape pvm many properties operations proved formal development 24 free occurrences variables intuitively parameters free names terms variables intended bound names consider terms free variables well formed define inductively predicate vclosed variableclosed terms table 1 analagous way typing relation specifies another kind wellformedness turn every pts typable term vclosed thus vclosed used induction principle well formed terms relation simple case ideas recur many times follows discuss length course terms form p vclosed rule vclatom terms shape v vclosed rule introduce vclosedv define vclosed binders approach going binders central idea formal handling names hvaia vclosed require vcloseda vclosed pva parameter p go binder first fill hole parameter p p doesnt appear conclusion rule vclbind parameter use definition vclosed say parameter another possible choice vclosed pvb derivable p formal question one tasks reader formal mathematics decide formalisation correctly captures informal understanding formaliser help readers pointing alternatives formally proving relationship especially interesting alternative definitions lead easier proofs cases see vclosed remark 22 vclosed equivalent free variables vclosed vclosed vclosed vclosed observation may informal interest definition vclosed reasonable use formally vclosed allows us avoid talk vclosed generation lemmas suppose proof examining know must constructed vclbind proofs vcloseda rule vclosed conclusion shape vclosed hvaib fact relation inductively defined means judgements derived using rules often called case analysis generally lemmas express properties called generation lemmas bar92 inversion principles dfh 93 note inversion principles determined shape definition extension lego new useful tactics automate use inversion mcb96 describe paper done tactics available frequently use inversion inductive definitions rest paper without comment generation lemmas definition vclosed notice existential quantifier case binders expresses failure subformula property vclosed 241 better induction principle vclosed three obvious facts vclosed alpha vclosed lem vclosed alpha directly provable appear need length induction appeals wellfounded induction subsidiary case analysis eg proof claim avclosed alpha usual reason statements change names proved length induction rather structural induction eg qvm generally subterm n shorter n derive new induction principle packages arguments consider alternative definition called avclosed differing rule binders right premise requires avclbind show vclosed avclosed derive judgements induction avclosed principle melham gordon rediscovered gm96 section 32 worth saying vclosed type finitely branching wellfounded trees ie vclatom leaves vclbind vclapp binary branching nodes hand avclosed contains infinitely branching wellfounded trees avclbind creates branch parameter p notice also term one derivation avcloseda may many derivations vcloseda differing parameters used left premises instances avclbind equivalence vclosed avclosed avclosed vclosed vclosed avclosed directions follow easily structural inductions following claim avclosed alpha proof claim proved induction lngthb works every term appearing premise rule avclosed shorter term appearing conclusion typing relations considered later property subtle proofs required section 521 wellfounded induction lngthb goal using term structural induction cases sort vari able parameter binder application case analysis necessary dont use structural induction hypotheses consider case binder must show avclosed qv hnaib ie assumptions ie avclosedhnpvaiifvn b pvb avclosed inversion applied assumption vclp also know avclbind suffices show noticing pv doesnt change lngth first holds ih h1 second let r arbitrary parameter consider cases done h2 ie qvb doesnt actually appear goal pvb doesnt actually appear h2 finally interesting case v 6 n use straightfoward lemma alpha commutes alpha rewrite goal avclosed qv rnb ih suffices show avclosed pv rnb follows h2 rewriting order substituting p r gained defining avclosed showing extensionally equivalent vclosed view induction principle avclosed induction principle extension vclosed clearly stronger induction principle vclosed insist extension point avclosedinduction may used prove statements judgement vclosed derivations judgement notice could directly prove analogue claim avclosed alpha vclosed proof outlined works stronger premises avclosed ie generation lemmas stronger induction hypotheses 25 technical digression renamings sequential operations used notion simultaneous substitution except following special case renaming finite function parameters parameters renamings represented formally graphs lists ordered pairs rp pp theta pp renaming pair renaming listrp ae oe range renamings action renaming rentrm parameters lookup representing list extended compositionally terms aep assoc p p ae aeff ff ff 2 vv ss aehvaia hvaeaiaea aem n aem aen tricky representation first pair p q ae returns p action renaming always total finite support also assumption renamings graphs functional relations action renaming func tional assoc finds first matching pair conversely consing new pair front renaming shadow old pair first component formalize observations renamings commute substitution natural way renaming iterated substitution analyse action renaming terms substitution rentrm conjugated psub lemma easy show renaming respects relation substitution parameters respects psub resp rentrm resp similar results hold n ary relations r injective surjective renamings useful bijective renamings eg section 521 definitions standard surprisingly difficult construct bijective renamings general trickiness representation mentioned however clear renaming swaps parameters bijective swap sur swap inj enough purposes 3 reduction conversion section outline theory reduction conversion pure languages main results churchrosser standardization theorems definition vclosed section 24 interesting point defining reduction relation goes binders understand reduction works consider informally onestep betareduction untyped lambda calculus style fi rules substitution nxm rhs fi prevent capture restriction required obvious capture occur n closed usual informal sense distinguish parameters variables enough n vclosed actual restriction want reason vclosed terms anyway wellformed terms use fi binder allowed must preserve invariant fi applied vclosed terms fill holes left stripping binder fresh parameter instance incorrect capture might occur contracting underlined redex removing outer binder x replacing bound instances fresh parameter q contracting vclosed redex thus obtained must rebind hole occupied q since q fresh instances q mark holes rebound according require variable term n qyn contractum vclosed redex xq example pair xy one used z xz z 6 x however derive incorrect judgement thus incorrect capture avoided 31 parallel reduction rather use ordinary fi reduction take parallel reduction la taitmartinlof basic reduction relation parallel reduction convenient churchrosser standardization theorems emphasised takahashi beautiful account tak95 development follows tak95 refinements 311 onestep parallel reduction relation par red1 defined table 2 vclosed dependence congruence rule binders choice parameter p apparent however something new arises namely side conditions p 62 eigenvariable pr1atom ff pr1beta vclosedu pr1bind pr1app table 2 1step parallel reduction conditions 5 ensure parameter p correctly indicates position bound variables compound terms vclosed terms participate par red1 vclosed reflexive vclosed terms par red1 refl stronger induction principle rules pr1atom pr1 bind pr1app congruence rules language vclosed section 241 introduce strong congruence rule binders pr1 bind prove extensionally equivalent giveing us stronger induction inversion principles eigenvariable conditions pr1bind technique using renamings required 5 kleene kle52 x78 notion pure variable proof explains treat conditions however must explicitly consider operations derivations hence dependent elimination whereas methods require rule induction ie nondependent elimination second author grateful n shankar reference show equivalence omit details similar argument used section 521 strong induction principle used show closed substitution par red1 psub manystep parallel reduction par redn transitive closure inherits properties par redn vclosed par redn refl corresponding properties mentioned 312 alphaconversion define ff conversion ff least congruence ie ff exactly without rule pr1beta ff definition symmetric inspection show transitive requires stronger induction principle ff prove way hence ff equivalence relation 6 decidable vclosed terms decide alpha conv ff straightfoward messy proof double induction avclosedb informally alphaconversion used changing names vari ables hxaib ff prevent capture however true alpha conv pi closure ff conversion one coquands original motivations distinguishing variables parameters avoid need reason ff conversion many arguments churchrosser standardisation subject reduction achieve goal namecarrying syntax regarded abbreviation quotient modulo ff conversion formalise relation r parallel reduction really intend r modulo quotient structure ie ff say relation r 6 contrasted galliers meticulous longwinded treatment gal90 closed ff ffffir rffiff strongly closed ffffir r full wrt ff rffiff ffffir strongly full rffiff r remark 31 strongly closed ff conversion proof transitivity ff additional case redex handled observing ff variant redex redex however full wrt ff classes example ff variant lhs reduces 1 qy 1 although ff variant rhs 313 churchrosser theorem using argument tait martinlof modernized tak95 prove first cr theorem par redn dp usual strip lemma argument diamond property comp dev par red1 dp introduce inductive characterisation complete development gamma comp dev 7 given rules except application rule cdapp gamma ab gamma lambda side condition cdapp forces contraction redexes deterministic subrelation theorem finiteness developments becomes combination ffl induction definition gamma may think partial correctness assertion ffl existence vclosed terms complete developments comp dev exists may think termination argument 7 cf definition gamma function structural recursion terms tak95 separation concerns gives us advantage takahashis informal proofs consider proof gamma subsidiary induction caseanalysis resolve redexnon redex distinction case application handled existence proof induction definition gamma already delineates redexnonredex distinction price pay longer work objectlevel function rather functional relation course simplified matters considering developments entire set redexes term sufficient purposes refined analysis eg hue94 would take us beyond simple datastructure terms diamond property comp dev par red1 dp follows easily following takahashi lemma comp dev precr whose proof induction gamma 0 inversion n usual interesting case redexredex appeals par red1 psub remark 32 proofs make appeal ff conversion gamma relations strongly closed ff conversion indeed may show following two properties strengthen comp dev exists namely comp dev unique comp dev exists unique 32 conversion define conversion conv symmetric transitive closure inherits properties conv vclosed conv refl mentioned second churchrosser theorem straightfoward prove conversion convcr 33 normal forms term beta normal beta norm beta redexes may defined rules avclosed except rule application bnapp beta norm beta norm b beta norm ab lambda beta norm terms vclosed beta norm vclosed relation reduction normal form defined n beta norm n normal reflexive reduction normal form every reduct normal form normal form parrednbnormisbnorm reduct normal form alphaconverts normal form parrednbnormisalphaconv hence churchrosser normal forms term unique alphaconversion nfunique since ff converse also holds nfalphaclass thus class normal forms vclosed term either empty exactly alphaconversion equivalence class deciding conversion conversion decidable normalizing terms proof depends churchrosser since normal forms unique alphaconversion also depends decidability alphaconversion section 312 34 standardization theorem work typechecking requires us go beyond theorems churchrosser analysis reduction particular talk syntaxdirected systems must consider deterministic reduction relations weakhead reduction simplest typical wh 0 table 3 one step weakhead reduction property required relation following counterpart quasinormalisation theorem wh standardisation lemma takahashi showed approach theorems analysis parallel reduction head reduction followed internal reduction socalled semistandardization lemma mit79 adapted methods case weakhead reduction corresponding modified notion internal reduction simplify somewhat particular removing need complex invariant n moreover arguments employed replicated context head reduction internal reduction classical senses recently rounded line development proving standardization theorem pure languages main novelty removal mention residuals reader may unconvinced formalised standardization theorem thing observe desirable consequences standardization required analyse typechecking lemma already corollaries semistandardization lemma three main ingredients theorem weakhead reduc tion internal parallel reduction standard reduction 341 weakhead reduction one step weakhead reduction wh red1 shown table 3 inversion see weakhead reducts lambda may assume without loss generality lambda rule wh1app built vclosed assumptions definition always used context terms vclosed reader may validate definition considering weak head normal forms table 4 various lemmas relating wh whatom whnfff ff 2 pp ss whbind lambda table 4 weakhead normal forms ip1atom ff ip1bind table 5 one step internal parallel reduction whnf wh red1 determin wh nf nf1 alpha conv resp wh nf manystep weakhead reduction iwh wh redn defined reflexive transitive closure wh closed renam ings substitution psub resp wh redn application right 342 internal parallel reduction classical notion head reduction leads notion internal redex nonhead redex adapt notion weakhead duction gives us definition internal parallel reduction ipar red1 shown table 5 allow arbitrary parallel reduction compound term except rator position applications restrict internal reduction immediate structural induction internal parallel reductions parallel reductions also important abstract property ipar red1 refl wh nf preserves reflects weak head normal forms fortiori shape outermost constructor term reflection weakhead normal forms together lemma key proof quasinormalisation result opened discussion semistandardization par red1 wh redn ipar red1 proof proof proceeds induction tricky case parallel fi step inductive hypothesis obtain introducing skolem constants aw bw required show exists mw since psub resp wh redn psub vsub alpha may conclude result stitching weakhead reduction sequences together provided establish following claim easy base case lemma 24 tak95 wh ipar red1 psub proved way showed closure parallel reduction substitution induction detail observe must explicitly assume reduction n n 0 parallel takahashi builds invariant whereas use wh ipar red1 psub obtain assumption free premise associated reduction show case application b induction hypothesis exists pa npa iwh pa proof claim hence whole lemma completed taking p def pa npb appealing psub resp wh redn ipar red1 app par red1 psub establish full semistandardization result must also show commutation result ipar wh redn commutes corollary induction mw iwh 0 following lemma ipar wh red1 commutes proof induction ancillary hypothesis cases trivial except application show case whredex use fact ipar red1 reflects weakhead normal form infer uu 000 moreover since inversion u v 8p pua 000 pva 00 choosing p 62 00 p 62 000 applying pr1sub obtain bua 000 appeal lemma 342 finally conclude p required throughout used induction definitions various reduction relations establish lemmas contrast takahashis treatment induction term structure inversion relational hypotheses leads slightly weaker arguments consequently need stronger inductive variants refinements arguments would inconceivable without machine support 343 standard reduction property standard reduction gamma usually stated eg mitschke mit79 terms highly intensional geometric definition terms formalise definition directly would enrich datatype terms order able speak stdatom ffgamma ff ff 2 pp ss stdbind stdapp stdwh table standard reduction standard adapted plotkin redex positions term approach taken hue94 chosen instead presentation table 6 adapted plotkins notion standard sequence plo75 essence presentation define standard reduction least congruence closed prefixing weakhead reductions leave implicit sequence redexes contracted may computed recursion lefttoright character thus avoid mention residuals redex positions remark 33 defined standard reductions arbitrary length without considerations reduction normal note furthermore however may easily achieve end adding side condition 0 6 stdapp rule whnfb stdwh rule also definition strongly closed ff conversion strongly full final aim following standardization theorem standardisation lemma induction suffices show notion standard reduction absorbs single steps parallel reduction lemma 342 stdwh suffices prove following lemma standard reduction absorbs single steps internal parallel reduction standard absorbs ipar red1 proof proof induction b gamma c avoids reconsidering tricky application case commutation lemma may exploit fact preserves reflects shape terms price pay need strong induction b gamma c ancillary hypothesis expansion step nonatomic case make subsidiary appeal semistandardization order able exploit induction hypotheses gives rather mechanical abstract nonsense flavour argument emphasising real complexity lies proof lemma 342 focus case binder hypotheses inversion h conclude 8p pwb c pub semistandardization c iwh aw induction hypothesis iha aw gamma 0 using stdwh fold back reductions c iwh aw finally obtain c gamma 0 exactly way modulo choice parameter obtain pwb c gamma pvb 0 c gamma hva 0 ib 0 construction concludes proof standard reduction absorbs internal reduction hence parallel reduction finally may conclude every parallel fi reduction sequence may standardized 4 pure type systems pts class type theories given set derivation rules table 7 parameterized pl pp vv ss two relations informally axs 1 2 start weak lda app table 7 typing rules pts formal name gts ffl rules rl ss theta ss theta ss written informally rls usually intend ax rl decidable assumption used basic theory pts interested algorithms typechecking pol94b pol95 even stronger assumptions decidability needed typing judgement shape meaning type formal name relation gts old name generalized type systems call gamma subject predicate judgement contexts ranged gamma delta bind parameters types contexts formalized lists pp theta trm gamma participates derivable judgement 41 generalization abstract conversion generalized pts parameterizing rules table 7 another relation called abstract conversion occurring side condition rule tconv conventional presentations pts bar92 actual relation betaconversion used several reasons interested parameterizing pts conversion relation one thing type theory ecc implemented lego actually pts uses generalized notion conversion called cumulativity ecc special interest us formalize extension pts includes ecc formal development includes typechecking algorithm ecc pol94b even pts notorious open problem expansion postponement problem vbjmp94 pol94b asks conversion relation table 7 replaced betareduction without changing typability terms know one work pts using abstract conversion relation bm properties necessary prove substitution lemma section 54 reflexivity transitivity invariance substitution cnv trans 8a prove subject reduction theorem section 55 finally need conversion related contraction redexes inter nal churchrosser property notice contravariance last property easy prove properties formally instantiate cumulativity ecc discharge assumptions working abstractly making assumptions equivalence relation partial order use asymmetric symbol significant properties generally hold include differences abstractconversion pts fi conversion detailed pol94b kind analysis properties actually used body work greatly aided formalization 42 rules formalization pts leaving aside abstract conversion rules table 7 differ standard informal presentation bar92 several ways first handling parameters variables pi lda rules similar rules table 2 differences restriction weakening atomic subjects lda rule binding substitution treatment operating binders table 7 analogous reduction relations considered see discussion rule lda substitution used rule app may cause capture variables must show n vclosed fact gts vclosed lem structural induction also follows easily valid context vclosed obvious sense atomic weakening standard presentation weakening pts allows term subject weakening restrict atomic terms ff see rule weak rules derive judgements weakening seen admissible section 53 allow fewer derivations derivations weakening pushed leaves gives cleaner meta theory induction derivations treats fewer cases example given application subject confusion whether derived app weak thus atomic weakening judgement may derived tconv exactly one remaining rules lambda rule rule typing lambda informal presentations bar92 geu93 conventional understanding bound variable x doesnt really occur conclusion rule notations refer alphaequivalence classes 8 thus concrete notation subject predicate lambda rule may bind different variables formalize rule lda one might instead rule first attempt surprisingly system derives judgements system table 7 lemmas rlts gts gts rlts however using lda subject reduction theorem difficult prove derivations distorted need use conversion rule alphaconversion see pol94b details 5 pts abstract conversion survey development leading subject reduction theo rem main difference section presentation bar92 use atomic weakening rules section 42 simpler proof subject reduction section 55 51 basic facts sample many small facts established usually simple structural induction parameter lemmas parameter occurrences judgement bound context binding instances valid context distinct parameters free params lem1 8 however left premise rule free instances actual symbol intended refer context entry xa thus conventional reading rule doesnt make sense concrete notation start lemmas every axiom derivable every valid context global bindings valid context derivable 52 better induction principle pts previous relations define alternative typing relation apts identifies derivations judgement inessentially different parameters occurring derivation conclusion differs right premise pi rule left premise lda rule alda premises avoid choosing particular parameter requiring premise hold parameters reason hold sufficiently fresh parameters show derive judgements interesting compare side conditions pi api pi need side condition p 62 b unintended occurrences p ie arising occurrences variable x bound right premise need p validity gammapa obvious right premise api cannot require right premise p gammapa remains valid ie p occurring gamma however condition required genericity right premise api must hold infinitely many parameters occurring finitely many instances occur b 521 equivalent previous relations equivalence give us stronger induction principle stronger generation inversion lemmas apts gts gts apts proof direction straightfoward structural induction prove direction first prove lemma bijective renamings respect bij ren resp apts structural induction 9 proceed prove structural induction derivation cases trivial except rules pi lda consider case pi must prove assumptions l prem prem rule api using l ih suffices show gammara arbitrary parameter r 62 gamma thus using free parameter lemmas section 51 know l prem noccg prem prem taking derivable using bijrenrespapts rename r ih recall section 25 swapp q always bijective thus finished show clear first equation holds nopg noccg nora nopa second equation notice done trivially assume r 6 p hence r 62 pnb r prem noccg using vsub rentrm commutes section 25 9 actually injectivity renaming enough preserve cannot prove know required 53 thinning lemma weakening thinning lemma important formulation shows full weakening weakening admissible system justifying use atomic weakening definition section 42 subcontext relation defined also say delta extends gamma definition used informally bar92 gn91 vbj93 much complicated definition required express property representation using de bruijn indices global variables state thinning lemma naive attempt prove thinning lemma structural induction encounters serious difficulties parameter side conditions see mp93 pol94b discussion proof straightfoward using induction justified previous section full weakening rule corollary thinning lemma 54 cut type correctness substitution lemma substitution lemma proved induction derivation gammap get commonly used case cut rule instantiating delta empty context among correctness criteria type systems every type well formed pts theorem type correctness proof structural induction nontrivial case rule app uses substitution lemma vsubispsubalpha section 23 subject reduction theorem closure reductio important property type systems term lose types reduction thus types classification terms preserved computation fact show entire judgements closed reduction need five properties abstract conversion section 41 551 nonoverlapping reduction goal prove usually called subject reduction theorem naive strategy show one step reduction preserves typing induction critical case rule app application actually redex contracted order simplify case want avoid overlapping redexes allowed fi rule want reduction relation overlapping whose transitive closure equal another difficulty rules pi lda subterm subject conclusion typelabel appears context part premise thus cases induction argument reduction subject conclusion may result reduction context premise suggests induction hypothesis strengthened simultaneously treat reduction context subject leading goal ordinary onestep fi reduction approach used gn91 bar92 produces large number case distinctions based subterm subject contains one redex contracted subcases inessential except isolate one nontrivial case redex contracted application constructed rule app simultaneous treatment one reduction either context subject suggested us proof would smoother using reduction relation congruent simultaneously branches forbidding overlapping redexes one step nonoverlapping reduction red1 defined rules table 2 except fi rule modified prevent overlapping redexes nor1beta uu b assumed property cnv conv section 41 extend compositionally contexts red1cxt pairs context term red1subj writing gamma hgamma mi also define redn transitive closure show par redn par redn 552 main lemma subject reduction lem proof structural induction show interesting case rule app given l prem prem red must show induction hypotheses type correctness gtsdm pigeneration lemma 2 p 62 b cut rule gtsdl gtsdb also use vsubispsubalpha section 23 several times case two subcases 0 l goal rule app induction hypotheses easily use rule tcnv gts dbsub expand l 0 predicate back l required uses cnvconv goal lambdageneration lemma w b 0 0 cnvcrpi c time used proof generation lemma gtsdpi tcnv cnva gtsdl gtsda tcnv cnvb gtsdbsub suffices show follows cut gtsdl gtsdb 553 closure reduction easy show subject reduction theorem gtssr useful corollary predicate reduction finally extending compositionally contexts 10 closed betareduction gtsallred relation equivalent transitively closing compositional extension contexts trivial useful lemma predicate conv unlike rule tcnv dont ask evidence type side condition uses prove lemma requires technical restrictions eg ecc type hierarchy chopped finite level fails property sort top hierarchy closure alphaconversion gtsallred fact ff follows judgements preserved ff gts alpha closed hence implementation may typecheck judgement stated user rather searching alpha equivalent judgement derivable see pol94b pol94a 56 another presentations pts several rules context gamma occurs list premises order build complete derivation gamma must constructed start weak branch appears much efficient assume start valid context check rules extend context ie right premise pi left premise lda maintain validity keeping implementations actually used work current context mathematical assumptions present system table 8 show equivalent idea originally due martinlof mar71 used hue89 system two judgements type judgment shape lvtyp validity judgement shape gamma lv lvcxt note mutually inductive validity depends typing conversely proved lv characterizes iff gts lvcxt lvtyp direction proof subtle formally uses auxiliary mutual inductive definition wellfounded induction requiring dependent elimination place entire development either mutual induction dependent elimination used abstractly direction claims termination function replaces proof annotations omitted lv fastgrowing function termination strong result proof described pol94b lvlda lvcons table 8 system locally valid contexts lvtyp lvcxt 6 pts fi conversion remarkable little needed theory described far section 41 pol94b pursue theory pts abstract conversion correct typechecking algorithm cumulative pts including luos system ecc point standard theory pts fi conversion ie instantiate preceeding actual relation lego command cut executes admissible rule substitution lemma section 54 theory leading strengthening theorem typechecking algorithms classes pts detailed vbjmp94 61 strengthening strengthening tricky result pts first proved jut ting vbj93 gammaqc gts strengthening development formalize strengthening corollary work typechecking described detail vbjmp94 particularly interested prove strengthening lego uses discharge command 62 functional pts functional pts well behaved perhaps ones interesting practice functional ae functional pts ax rl graphs partial functions necessarily procedures compute functions uniqueness types definition functional pts makes sense abstractconversion pts useful setting gives kind uniqueness building derivation typing judgement guided syntax subject deterministic axiom use instance ax rule use instance pi pol94b idea behind definition functional uniqueness mentioned propagates whole derivations give property types unique conversion conv unique types fi conversion pts prove functional conv unique types types unicity structural induction however proof uses properties cannot modified prove similar property abstractconversion pts types unicity linear partial order correct generalization principal types lemma saying type principal type cannot hope every two types comparable pol94b subject expansion fi pts uniqueness types also subject expansion property subject expansion conv unique types subject reduction says terms dont lose types reduc tion lemma says terms dont gain types reduction principal premise wellformedness premise examples two different ways subject expansion fail nonfunctional pts vbjmp94 r formalization strong normalization proof system f lego lambda calculi types coq en coq type dependence constructive mathemat ics subject reduction property algebraic type systems fsub system algorithm testing conversion type theory combinator shared reduction infinite objects type theory algorithm typechecking dependent types towards checking proof checkers girards collected papers gerhard gentzen logics type systems five axioms alpha con version modular proof strong normalization calculus constructions constructive engine residual theory incremental changes lego introduction metamathematics lego proof development sys tem users manual technical report ecslfcs92211 lfcs computer science dept university edinburgh kings buildings program specification data refinement type theory computation reasoning type theory computer science per martinlof inverting inductively defined predicates lego standardisation theorem pure type systems malized churchrosser proofs isabellehol coding binding substitution explicitly abelle proof churchrosser theorem representation logical framework closure alphaconversion theory lego proof checker extended calculus constructions verified typechecker believe machinechecked proof natural deduction program verification synthetic domain ory synthetic domain theory type theory another logic computable functions theory symbolic expressions auxiliary variables recursive procedures mechanical proof churchrosser theorem substitution revisited parallel reductions formulation martinlofs theory types explicit substitutions masters thesis tr ctr michael norrish mechanising hankin barendregt using gordonmelham axioms proceedings acm sigplan workshop mechanized reasoning languages variable binding p17 august 26 2003 uppsala sweden christian urban michael norrish formal treatment barendregt variable convention rule inductions proceedings 3rd acm sigplan workshop mechanized reasoning languages variable binding p2532 september 3030 2005 tallinn estonia yasuhiko minamide koji okuma verifying cps transformations isabellehol proceedings acm sigplan workshop mechanized reasoning languages variable binding p18 august 26 2003 uppsala sweden michael norrish mechanising calculus using classical first order theory terms permutations higherorder symbolic computation v19 n23 p169195 september 2006 j ambler r l crole alberto momigliano definitional approach primitivexs recursion higher order abstract syntax proceedings acm sigplan workshop mechanized reasoning languages variable binding p111 august 26 2003 uppsala sweden dimitri hendriks proof reflection coq journal automated reasoning v29 n34 p277307 2002 jonathan ford ian mason formal foundations operational semantics higherorder symbolic computation v16 n3 p161202 september conor mcbride james mckinna functional pearl numberi free variable proceedings 2004 acm sigplan workshop haskell september 2222 2004 snowbird utah usa james cheney scrap nameplate functional pearl acm sigplan notices v40 n9 september 2005 thierry coquand randy pollack makoto takeyama logical framework dependently typed records fundamenta informaticae v65 n12 p113134 january 2005 ren vestergaard james brotherston formalised firstorder confluence proof calculus using onesorted variable names information computation v183 n2 p212244 15 june andrew pitts nominal logic first order theory names binding information computation v186 n2 p165193 01 november conor mcbride james mckinna view left journal functional programming v14 n1 p69111 january 2004 riccardo pucella sigact news logic column 14 acm sigact news v36 n4 december 2005
dynamic memory management programmable devices paper presents design implementation novel dynamic memorymanagement scheme espa language programmable devices firmware programmable devices fast reliable support high performance esp provides explicit memorymanagement interface implemented efficiently ensure reliability esp uses model checker verify memory safetythe vmmc firmware used case study evaluate effectiveness memorymanagement scheme find spin model checker able exhaustively verify memory safety firmware largest process took 676 seconds used 3445 mbytes memory verify also find runtime overhead maintain reference counts small additional overhead accounts 735 total message processing cost worst case mallocfree interface b introduction traditionally devices implement simple functionality usually implemented hardware complex functionality implemented device drivers running main processor however devices get faster increasingly harder software running main cpu keep devices main cpu permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copies bear notice full citation first page copy otherwise republish post servers redistribute lists requires prior specific permission andor fee ismm02 june 2021 2002 berlin germany go across memory io buses reach device incurs several hundreds cycles access situations better performance achieved implementing functionality device instead main cpu 2 22 9 21 18 20 25 1 24 programmable devices used implement increasingly sophisticated functionality supported devices devices equipped programmable processor memory figure 1 since processor resides card incurs much smaller overhead access control registers device writing firmware devices dicult two rea sons first code running device fast processing power memory device tends least order magnitude less main cpu main memory migrating code main cpu device involves tradeo running code faster processor incurs higher overhead access device running slower processor faster access device slower code runs device smaller benefit migrating code devices second device firmware reliable trusted operating system ability write location physical memory stray memory write resulting bug corrupt critical data structures operating system crash entire machine firmware programmable devices usually written using eventdriven state machines c concurrency eective way structuring firmware programmable devices multiple threads control provide convenient way keeping track progress several events time eventdriven state machines support lowoverhead concurrency however programming eventdriven state machines c suers number problems 17 consequently device firmware deliver good performance often dicult write debug esp 17 16 language writing firmware programmable devices using eventdriven state machines designed meet three goals ease programming ease debugging high performance paper focuses novel memorymanagement scheme supported esp earlier paper 17 included brief description scheme paper presents detailed description design implementation esps dynamic memory management scheme paper also provides detailed measurements vmmc firmware evaluate effectiveness approach challenging firmware fast well reliable problem compounded fact firmware implemented using concurrency traditional memory management schemes fall two categories automatic explicit memory management one hand automatic memory management using garbage collection techniques 26 provides safety usually involves high overhead terms amount memory processing time hand explicit memory management involves lower overhead hard program correctly section 6 discusses related work detail keep dynamic memory management overhead low esp provides explicit memory management interface uses model checker spin 15 ensure memory safety key observation allocation bugs dicult find memory allocation correctness global property programthe property cannot inferred looking single module program rectify esp designed make memory allocation correctness local property process promotes modular programming also allows model checkers verify safety model checking involves exponential search making memory safety local property results smaller models amenable model checking esp runtime maintains reference counts objects manage dynamic allocation eciently make memory allocation correctness local property process objects sent channels passed value esp se mantically means copy object sent channel delivered receiving process ensures two processes share object however copying objects sent channels runtime expensive esp runtime avoids copying objects maintaining reference counts objects objects actually shared multiple processes covers demonstrate eectiveness approach use vmmc firmware case study vmmc firmware runs myrinet 4 network interface cards programmed using esp found spin model checker able exhaustively verify memory safety esp processes vmmc firmware implementation largest process took 676 seconds 3445 mbytes memory verify also found reference counting used esp runtime incurs fairly small overhead measurements indicate additional bookkeeping necessary maintain reference count results 735 increase worst case message processing cost mallocfree interface supported c rest paper organized follows section 2 presents brief introduction model checking section 3 presents overview esp section 4 describes design implementation esps dynamic memory management scheme section 5 uses vmmc firmware evaluate eectiveness scheme section 6 discusses related work finally section 7 presents conclusions 2 background esp uses model checkers debug extensively test device firmware model checking technique verifying system composed concurrent finitestate machines given concurrent finitestate system model checker ex cpucpu bus main memory main cpu network dma dma cpu mem card network dma cpu figure 1 machine programmable devices plores possible interleaved executions state machines checks property verified holds global state system snapshot entire system particular point execution state space system set global states reachable initial global state since state space systems finite model checkers principle exhaustively explore entire state space model checking verifiers check variety prop erties properties traditionally divided safety liveness properties safety properties properties satisfied specific global states system assertion checking deadlock safety properties assertions predicates hold specified point one state machines corresponds set global states state machine specified point predicate holds deadlock situation corresponds set global states valid next state liveness properties ones refer sequence states absence livelocks liveness property corresponds sequence global states useful work gets done liveness properties usually specified using temporal logics advantage using model checking auto matic given specification system property verified model checkers automatically explore state space violation property discovered produce execution sequence causes violation thereby helps finding bug disadvantage using model checking computationally expensive state space explored exponential number processes amount memory used program result resources required cpu well memory resources model checker explore entire state space quickly grow beyond capacity modern machines 3 esp eventdriven statemachines programming esp 17 16 language programmable devices designed three goals ease programming ease debugging high performance section begin description approach esp takes meet goals present overview esp language 31 approach esp meets three goals follows figure 2 ease programming support ease programming esp allows programs expressed concise modular fashion using processes channels addition provides number features including pattern matching support dispatch channels flexible external interface c novel memory management scheme e cient safe ease debugging support ease debugging esp allows use model checker like spin 15 extensively test program esp compiler figure 2 generates executable also extracts spin models esp programs 16 minimizes eort required using model checker debug program often esp program debugged entirely using model checker ported run device avoids slow painstaking process involved debugging programs device high performance support high performance esp language designed fairly static compiler aggressively optimize programs languages like c eventdriven state machines specified using function pointers makes dicult c compiler optimize programs forces programmers hand optimize program get good performance contrast esp designed support eventdriven state machines allows esp compiler generate ecient code 32 language overview esp language adopts several structures csp 14 cstyle syntax esp supports eventdriven statemachines programming concurrency esp expressed using processes chan nels esp program consists set processes communicating channels process represents sequential flow control concurrent program implicitly encodes state machines processes communicate channels messages sent channel using operation received using operation communication channels synchronous 1 unbuereda process attempting perform operation channel concurrently another process attempting perform operation channel message successfully transferred channel consequently blocking operations alt statement allows process wait operations several dierent channels till one becomes ready complete addition basic types like int bool esp supports mutable immutable versions complex data types like record union array however esp support recursive data types two reasons first specification languages model checkers support recursive data types sending recursive data types byvalue channels involves additional runtime overhead esp processes channels static firstclass objectsthey neither created dynamically also known rendezvous channels stored variables sent channels design allows compiler perform optimizations effectively esp supports pure message passing communication channels allowing processes communicate shared memory using shared mutable data structures would require esp provide additional mechanism like locks avoid race conditions avoid esp allow processes share data structures two aspects esp prevent sharing data structures first esp disallows global variables variable local single process second objects sent channels passed value support eciently esp allows immutable objects sent channels applies object specified operation also objects recursively pointed object 4 dynamicmemorymanagementin 41 design design memory management scheme esp driven two goals first programs safe bugs stemming lack safety dicult find problem compounded fact programs concurrent run devices minimal debugging support second memory management overhead small esp provides novel memory management scheme provides safety well low overheads manage dynamically allocated memory provides explicit mallocfree style interface incurs low overheads ensures safety using model checker unsafe aspect esp explicit memory management scheme memory allocation bugs eliminated using model checker results safe esp program incur low memorymanagement overhead runtime key observation allocation bugs dicult find memory allocation correctness global property programthe property cannot inferred looking single module program programmer examine entire program make sure allocated objects eventually freed accessed freed rectify esp makes memory allocation correctness local property process section 32 describes design choices ensure two processes share data structure noted support pure message passingstyle communication would sucient ensure two processes share mutable data structures however make memory allocation correctness local property esp disallows sharing even immutable data structures making memory allocation correctness local property allows model checker verify memory safety process separately ability check process separately ensures size model checked remains small largest model checked depends size largest process size entire program number processes con sequently able exhaustively check memory safety esp processes vmmc firmware sec pgmesp esp compiler pgmc helpc generate firmware using c compiler pgmnspin verify property 1 verify property n using spin using spin figure 2 esp approach esp compiler generates models pgm1nspin used spin model checker debug esp program pgmesp compiler generates three types models detailed retains details program memorysafety check memory safety abstract generate compact model dropping irrelevant details compiler also generates c file pgmc compiled executable shaded regions represent code provided programmer test code test1nspin used check dierent properties esp program includes code generate external events network message arrival well specify property verified programmersupplied c code helpc implements simple lowlevel functionality like accessing special device registers dealing volatile memory marshalling packets sent network tion 52 addition making memory allocation correctness local property promotes modular programming objects sent channels passed value means deep copy object delivered receiving process 2 objects received channel treated like newly allocated objects later freed process one possible complication occurs object contains multiple links another object pointer sharing preserved receiving process would need know sharing check data structure correctly freed however cannot determine sharing pointer comparisons allowed esp example figure 3 illustrates problem copying semantics preserves pointer sharing avoid deep copy performed data structure sent channel preserve pointer sharing allows receiving process simply perform recursive arriving channels esp provides mallocfreestyle interface manage dynamically allocated memory since objects shared processes process responsible freeing objects two primitives free rfree 3 allow processes free allocated objects addition esp provides two primitivespfree prfree free object evaluation current expression allows compiler perform optimization section 43 following code fragment chan1 prfreev equivalent chan1 v esp supports immutable well mutable data struc tures immutable object arriving channel 2 true semantically esp runtime never actually copy objects sent channels section 43 3 performs free recursively mutated first applying cast operation obtain mutable version object semantically cast operation causes new object allocated corresponding values copied new object however compiler avoid creating new object number cases instance compiler determine object cast freed immediately cast reuse object avoid allocation esp allows dangling pointers pointers objects already freed program execution dangling pointers allowed program would delete pointers given object object could freed would require additional bookkeeping would place unnecessary burden programmer although esp allows dangling pointers disallows use pointers access memory ensures memory safety contrast usual approach ensure memory safety reclaim object pointers point avoids dangling pointers approach aware provides safety allowing dangling pointers regionbased memory management 19 uses type system guarantee dangling pointers used run time memory allocation esp nonblocking operation concurrent program making memory allocation blocking advantages allows memory allocation request one process find memory available block till another process frees memory although would lead better memory utilization introduces additional synchronization processes forces programmer treat allocation potentially blocking make sure cause program deadlock 42 extracting memorysafety models currently esp used spin model checker 15 spin flexible powerful model checker designed software systems spin supports highlevel features like processes rendezvous channels arrays records ver record v int channel sharec array entryt process process1 sharec assert lengtha 2 process process2 11 sharec p1 p2 process process3 5 sharec p p figure 3 example illustrate problems copying semantics preserves pointer sharing process process1 expects array two elements channel sharec receives process frees one entries proceeds use entry process process2 sends array channel process1 would execute correctly two entries point dierent objects however process process3 sends array channel process1 try access record freed resulting error ifiers target hardware systems provide fairly dier ent specification language although esp translated languages additional state would introduced implement features like rendezvous channels using primitives provided specification language would make state explosion problem worse addition semantic information lost translation would make harder verifiers optimize statespace search allows verification safety well liveness prop erties liveness properties spin specified using linear temporal logic ltl esp compiler generates three types models de tailed memorysafety abstract 16 detailed models contain details original esp program models useful development debugging firmware using simulation mode spin memorysafety models used check memory allocation bugs program models essentially detailed models additional spin code inserted check validity memory accesses abstract models omit details irrelevant particular property verified models significantly smaller state detailed models useful checking larger systems paper discuss detail memorysafety models memorysafety models generated esp compiler used check memory allocation bugs program models essentially detailed models additional spin code inserted check validity memory accesses therefore contain even state detailed models spite models usually used exhaustively explore state space allocation bugs memory safety individual process checked separately using verifier section 41 variables esp store pointers data objects stance following code variables b1 b2 point array therefore update b11 visible variable b2 b1 array int 5 11 allocate since spin support pointers object generated model assigned objectid allocation time objectid stored additional field object object gets copied due assignment operation objectid field also gets copied ensures objects translated spin code share objectid represent single object original esp code mutable object gets updated esp code translated spin code includes code check update objects objectid memorysafety model includes additional code asser tions checks validity object accessed new object allocated unused objectid assigned object every object access code inserted model check object live array accesses include additional code check array index within bounds union references include code check field accessed valid object objects model objectid marked invalid changing objectid field 1 memorysafety model checks bugs like accessing object freed double freeing object using invalid array index addition also find memory leaks process generated model bounded number objects compiler determine bound arrays source unbounded allocation esp process since esp support recursive data types however esp compiler imposes bound maximum lengths arrays model extraction 17 thereby bounding number objects model constraining model pick objectids within bound steady memory leak detected steady leak cause model run objectids model checking currently objectids source unnecessary increase state space explored models generated esp compiler problem stems fact given object program get assigned dierent objectids depending scheduling decisions made prior allocation result single state manifests several dierent states state space problem alleviated using separate objectid table distinct type process two pointers point object type belong process reduce number dierent objectids given object get assigned 43 code generation programmers perspective process set objects managed separately process section 41 process allocates objects explicitly frees using free objects sent channels deep copied handed receiving processes therefore objects arriving channel treated like newly allocated objects later freed process implementation uses referencecounting scheme manage objects although semantically processes share objects implementation shares objects processes eciencycopying objects computationally expensive runtime system maintains reference counts keep track number processes sharing object recursive increment decrement operations cyclic data structures require additional bookkeeping avoid infinite loops however esp support recursive data types consequently operations implemented eciently normal allocation causes objects allocated reference count initialized one object sent channel reference count object recursively incremented thereby avoiding expensive deep copy giving receiving process process frees object reference count decremented one object actually deallocated processes freed reference count zero following simple optimization fairly eective reducing number reference count increments decre ments following code fragment chan1 prfreev reference count recursively incremented sending object v channel sending object reference count recursively decremented prfree case reference count increments decrements optimized away compiler deep copy performed data structure sent channel preserve pointer sharing section 41 two benefits first allows copying semantics implemented eciently simple recursive increment reference count suces object pointed multiple times within data structure reference count incremented multiple times second allows correctness memory allocation local property process section 41 receiving process worry pointer sharing objects arriving channels cast immutable object mutable object require copying object program detect object sharing mutating one location observing change another location however cast operation fairly uncommon esp programs addition copying always necessary copy often avoided cast necessary program written carefully allow compiler optimize instance reference count immutable object one process holding object object freed immediately cast compiler avoid copy use object record v int channel countc array entryt process processa 3 p1 p2 countc process processb figure 4 example shows traditional reference counting scheme sucient esp several design choices esp language allow implementation share objects providing illusion disjoint set objects first immutable objects sent channels therefore program cannot detect object shared mutating one process observing change another process sec ond objects cannot compared pointer equality prevents program comparing pointer two dierent objects detecting implementation using object represent finally esp support recursive data types therefore program cannot cyclic data structures means recursive reference count increments deal infinite loops due cyclic data structures therefore implemented eciently traditional reference counting schemes maintain counts objects dierently way done esp traditional scheme reference counts incremented root decremented recursively reference count object becomes zero earlier paper 17 suggested would sucient esp turns sucient consider example figure 4 point objects sent channel countc schemes would kept reference counts objects three objects pointed variables p1 p2 would reference count one however performing send operation channel countc traditional scheme increment reference count array object esp scheme increment reference count three objects scheduler chooses schedule process processb first free statement executed traditional scheme cause reference count object pointed p1 go zero thereby freeing object generate error process processa scheduled run tries access variable p1 esp scheme reference count object pointed p1 decremented two one object freed allows process processa later access 44 limitations one main limitations approach problems dealing recursive data types problem recursive data types introduce cyclic data structures presence cyclic data structures deep copy semantics esp make sense one possible approach allow noncyclic data structures channels might require additional checks run time however checks would necessary channels allow recursive data types 5 experimental results section presents measurements demonstrate eectiveness esps memory management scheme measurements performed vmmc firmware runs myrinet 4 network interface cards measurements designed investigate following issues programmer eort required verify memory safety eectiveness using model checker verify memory safety extra performance overhead incurred runtime maintain reference counts allocation pattern exhibited firmware particular measure object lifetimes answering questions section presents brief overview vmmc firmware 51 vmmc firmware virtual memorymapped communication vmmc architecture 9 delivers high performance gigabit networks using sophisticated network cards allows data directly sent application memory thereby avoiding memory copies without involving operating system thereby avoiding system call overhead operating system usually involved connection setup disconnect vmmc implementation 9 uses myrinet 4 network interface cards myrinet packetswitched gigabit network myrinet network card connected network two unidirectional links 160 mbytess peak bandwidth actual nodetonetwork bandwidth usually constrained pci bus 133 mbytess network card sits network card programmable memory three dma engines transfer data one transfer data host memory one send data onto network one receive data network card number control registers including status register checks data arrival watchdog timers dma status vmmc software figure 5 three components library links application device driver used mainly connection setup disconnect firmware runs network card software complexity concentrated firmware code implemented using eventdriven statemachines c significant eort 10 9 3 6 spent imple menting performance tuning debugging vmmc card interface processor main network application network firmware device driver library figure 5 vmmc software architecture shaded regions vmmc components process esp generated test program model code reliablesend reliablerecv 152 664 41 localreq 172 742 67 remotereq 167 882 85 remotereply 177 715 104 table 1 sizes lines various files used check memory safety various processes vmmc firmware three remaining processes listed table involve allocation second column shows size portion program relevant particular model third column shows size model generated esp compiler last column shows number lines spin test code required firmware spite continue encounter bugs firmware vmmc firmware reimplemented using esp esp version vmmc firmware required significantly fewer lines code c version esp version 500 lines esp code together around 3000 lines c code complex state machine interactions restricted esp code uses 8 processes 19 channels c code performs simple operations like packet marshalling handling device registers significant improvement c version complex interactions scattered throughout 15600 lines code 52 verifying memory safety vmmcfirmware esp compiler extracts memorysafety models used verify safety processes separately section 42 use models verify safety involves two steps first programmer provide test code test1nspin figure 2 check processes model checker used perform statespace exploration verify safety former involves programmer eort latter performed automatically constrained available computational resource programmer eort required test code checking memory safety provided programmer simulates external events network message arrival unlike models test include additional code check safetythe code check memory safety included generated model form assertions table 1 presents sizes test code written verify memory safety firmware 4 case size test code fairly small table also shows size relevant portion esp code size models generated esp compiler test code written used repeatedly recheck system software evolves since models extracted automatically rechecking software requires little programmer eort eectiveness model checking every process vmmc firmware entire state space could explored exhaustively using spin table 2 presents amount state explored verify memory safety processes biggest process reliablesend required 676 seconds processor time 3445 mbytes memory shows eectiveness model checker verify safety contrast experience checking vmmc firmware global properties like deadlocks 16 esp compiler used abstraction techniques generate smaller models would require less resource explore state space approach allowed model checker identify several hardtofind bugs firmware cause firmware deadlock however state space still big result spin could perform partial search due resource constraints illustrates importance making memory safety local property process memorysafety model generated esp compiler catches bugs due invalid memory accesses also memory leaks section 42 memory safety bugs vmmc firmware already eliminated time esp compiler modified support memorysafety models spin used check earlier version firmware allocation bug verifier easily identified bug check eectiveness using memorysafety models variety memory allocation bugs inserted manually program bugs either access objects freed use invalid array index introduce memory leaks spin able quickly find bug every case esp model checker used throughout program development process traditionally model checking used find hardtofind bugs working systems since developing firmware network interface card involves slow painstaking process used spin simulator implement debug debugged firmware ported network interface card little eort 53 performance reference counting overhead measure performance overhead incurred esp runtime manage dynamic memory vmmc firmware put 4 processes listed table involve dynamic allocation head perspective estimates additional overhead esps scheme would incur mallocfree interface supported c vmmc provides two types operations transfer data two machines remotewrite operation transfers data local machine remote machine remoteread operation fetches data remote machine local machine remoteread operation behaves like two remotewrite operations requires two messages sent networka request message sent local machine reply message requested data sent remote machine therefore section report measurements remotewrite operations measuring memory management overhead firmware poses problem granularity clock available myrinet network card fairly large 05 fore cannot simply instrument firmware measure fraction time spent memory management rou tines consequently estimate memory management overhead three steps first measure overhead memory management operations second column table 3 reference count decrement operation performed object freed depending whether reference count zero therefore overhead cases mea sured overhead memory management operations little variance esp uses simple scheme manage free memory keeps set list free blocksall blocks particular list size consequently allocating freeing object involves removing adding head list second measure number times operations executed remotewrite operation table 3 using numbers two steps estimate memory management overhead involved remotewrite operation finally instrument vmmc firmware measure total time spent process remotewrite request third column table 4 compute fraction total processing time spent managing dynamic memory table 4 esp performs common optimization performed referencecounting systems reference counts newly allocated objects set zero instead one free objects identified presence free list avoids need incrementing counter allocation decrementing freeing consequently actual cost maintaining reference counts table 4 obtained adding execution times rows two three table 3 table 4 shows overhead maintaining reference fairly small fraction total memorymanagement cost 277 worst case reference count increments decrements necessary firmware one reference count increment necessary sending side three receiving side table 3 remaining memory management overhead cost allocating freeing memory cost would incurred even simple mallocfree interface provided c one advantage explicit memory management scheme programmer control object freed allows programmer get better performance process name states time seconds memory used mbytes stored matched stack hash table states store total reliablesend 11118 316725 676 240 10 945 3445 localreq remotereq 2315 3510 09 240 10 187 2687 remotereply 8565 7312 23 240 10 555 3055 table 2 checking memory safety vmmc firmware using spin case entire state space explored exhaustive mode spin stored column shows number unique states encountered matched column shows number states encountered already visited memory usage broken space used stack hash table visited states space used stack hash table statically allocated spin operation operation sender receiver execution time operation count execution time operation count execution time allocation 059 3 177 3 177 increment ref count 015 1 015 3 045 decrement object freed 026 1 026 3 078 count object freed 048 3 144 3 144 total 362 444 table 3 estimate memory management overhead vmmc firmware table computes amount time spent memory management primitives firmware machine sends message another machine shows time spent sending well receiving machines values computed using measurements columns machine total memory management overhead reference counting overhead execution time execution time total execution time total sender small 1950 362 1856 041 210 rest 2847 362 1272 041 150 receiver 1674 444 2652 123 735 table 4 comparison memory management overhead total time spent vmmc firmware process message sent network sender receiver machines since messages 32 bytes treated dierently larger messages sender overheads shown separately two categories small bytes messages rest total execution time measured instrumenting firmware memory management overheads obtained table 3 reference counting overhead overhead maintaining reference counts object obtained adding execution times rows two three table 3 application problem size lucontiguous 2048 x 2048 matrix waterspatial 15625 molecules barnesspatial 8192 particles waternsquared 1000 molecules volrend head table 5 splash2 applications moving allocation overhead critical path object lifetimes measure lifetime allocated objects vmmc firmware using splash2 applications table 5 applications run top shared virtual memory svm 3 library turn runs top vmmc library applications measurements made using cluster four smp pc pc four 200 mhz pentium processors 1 gb memory myrinet network interface card lanai 4x 33 mhz processor 1 mb onboard sram memory nodes connected myrinet crossbar switch pcs run table 6 shows lifetimes objects allocated firmware lifetime measured number allocations execution time allocation counter incremented seen table objects freed quicklyover 99 objects freed within 128 allocations small number tables allocated firmware started objects never freed 6 related work explicit memory management traditionally dynamic memory programmable devices managed using interface allows program allocate free memory maintained buer pools required programmer explicitly maintains reference counts objects interfaces provide memory safety often result memory allocation bugs notoriously dicult find lead memory corruption manifests faulty behavior location program dierent site bug number tools 5 use static runtime techniques find memory allocation bugs unsafe languages like c instance purify 13 tool inserts code executable check number bugs like invalid indices array accesses memory leaks allows detect error happens run time however programmers responsibility run executable different inputs exercise every possible program path lclint 11 combines static analysis program annotations identify broad class allocation bugs different approach 23 find limited class bugs buer overruns formulate buer overrun problem integer constraints problem statically check constraint satisfaction limitation static approaches flag falsepositive well falsenegative bugs automatic memory management automatic memory management safe programming languages implemented using garbage collector responsible reclaiming unused memory 26 garbage collection often involves runtime overhead terms processor overheads well additional memory requirement make dicult use programmable devices copying garbage collectors usually use half available memory problem programmable devices relatively small amounts memory markandsweep collectors waste memory incur overhead proportional size heap although techniques 7 used reduce cost sweep phase even cost mark phase significant firmware maintains large tables scanned mark phase problem programmable devices collector would triggered frequently limited memory available memory management using regions vault 8 cyclone 12 use regions 19 provide safe memory man agement regionbased memory management techniques exiting dynamic contexts like procedures makes unsuitable language like esp dynamic context 7 conclusions paper presented design implementation novel memorymanagement scheme esp esp provides explicit interface manage dynamic memory interface implemented eciently using referencecounting technique esps design makes memoryallocation correctness local property process allows model checker used ensure safety pro gram approach results safe programs incur low runtime overheads manage memory eectiveness esps scheme evaluated using vmmc firmware case study found spin model checker able exhaustively verify memory safety esp processes firmware verifying memory safety took 01 676 seconds required less 35 mbytes memory also found runtime overhead maintain reference counts small additional overhead maintain reference counts compared simple mallocfree interface varied 15 735 total message processing cost acknowledgments work supported part national science foundation cda9624099eia9975011ani9906704eia 9975011 department energy defc0299er25387 california institute technology pc159775 pc228905 sandia national lab ao5098a06 lawrence livermore laboratory b347877 intel research council intel technology 2000 equipment grant 8 r using network interface support avoid asynchronous protocol processing shared virtual memory systems gigabitpersecond local area network porting userlevel communication architecture nt experiences performance reducing sweep time nearly empty heap enforcing highlevel protocols lowlevel software design implementation virtual memorymapped communication myrinet static detection dynamic memory errors fast detection memory leaks access errors communicating sequential processes spin model checker esp language programmable devices esp language programmable devices high performance messaging workstations illinois fast messages fm myrinet implementation typed callbyvalue lambdacalculus using stack regions active messages mechanism integrated communication computation evolution virtual interface architecture first step towards automated detection bu virtual log based file systems programmable disk uniprocessor garbage collection techniques splash2 programs characterization methodological considerations tr active messages implementation typed callbyvalue myampersand955calculus using stack regions splash2 programs unet high performance messaging workstations static detection dynamic memory errors model checker spin active disks virtual log based file systems programmable disk using network interface support avoid asynchronous protocol processing shared virtual memory systems reducing sweep time nearly empty heap communicating sequential processes enforcing highlevel protocols lowlevel software regionbased memory management cyclone highspeed data paths hostbased routers userlevel network interface protocols evolution virtual interface architecture myrinet design implementation virtual memorymapped communication myrinet uniprocessor garbage collection techniques ctr sanjeev kumar kai li using model checking debug device firmware proceedings 5th symposium operating systems design implementation due copyright restrictions able make pdfs conference available downloading december 0911 2002 boston massachusetts sanjeev kumar kai li using model checking debug device firmware acm sigops operating systems review v36 nsi winter 2002
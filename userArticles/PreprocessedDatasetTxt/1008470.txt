distributed council election paper studies problem electing small number representatives council possible large group anonymous candidates problem arises scenarios multicast avoid feedback implosion small subset receivers chosen provide feedback network conditionswe present several algorithms problem analyze expected number messages rounds required convergence particular present algorithm almost always converges one round using small number messages typical council size number hosts known case number hosts unknown large polled algorithms converge small number rounds improves previous results bolot et al 1994 b introduction many distributed applications need distributively elect small group hosts potentially large population elected group needs maintained dynamic network conditions include new members joining leaving network temporary partition typical application problem appears multicast protocols due feedback implosion problem need elect small group representatives possibly large set receivers multicast group members election mechanism proposed bolot et al btw94 elect small number receivers collect feedback regarding loss rate congestion multicast group applications require distributed groupelection electing hot backup servers distributed databases distributed network management particular example algorithms implemented idmaps project jjj part project measurement stations tracers installed various locations internet tracers measure distance among areas inter net measurement results sent potentially many distance information servers multicast reduce measurement overhead distance information servers provide feedback usefulness measurement tracer avoid feedback implosion problem tracers need select one representatives server population multicast congestion control idmaps example communication data transmitting entity group hosts done using multicast reverse direction done using unicast transmissions examples population size may vary several orders magnitude population may change time transmitting entity initial knowledge population size examples choosing single representative usually undesirable redundancy better statistical representation multicast exam ple thus algorithms capable electing group size predefined range note transmitting entity knows ids receivers deterministically choose representatives cannot assume due feedback implosion problem model environment using synchronous distributed election process hosts communicate among central entity sends global feedback message entire population two measures interest environment expected number rounds election expected number unicast messages needed n present work several distributed randomized algorithms analyze performance algorithms explore tradeoff two measures state maintained hosts first present basic algorithm requires host maintain single bit state algorithm converges small constant number rounds regardless n initial population size sublinear n number messages typical rs hosts maintain state previous round present improved algorithm reduces 1015 typical rs dramatically reduces n constant factor thus omitting n dependency n present algorithm reduces expected number rounds close 1 eg regardless n ever last algorithm requires almost double number messages previous algorithm still n 8 regardless n algorithms assume n either known alternatively polled single round n mes sages show robustness suggested algorithms inaccurate estimation n leads efficient algorithm case n unknown maybe big polled algorithm searches n way similar one suggested bolot et al btw94 achieves superior performance ii related work problem similar collision resolution problem multiple access networks type network hosts try transmit packets via shared medium multiple transmissions overlap usually packet collides targeted receiver cannot decode signal problem collision resolution networks extensively studied 1970s 1980s several submodels differ feedback hosts receive channel analyzed emphasize relevant ones refer interested reader book rom sidi rs90 work networks concentrated two feedback models binary model assumes hosts knows whether collision occurred ternary feedback model assumes hosts aware three channel con ditions silence packets transmission success one packet successfully transmitted collision one packet transmitted none successfully received receiver host receives feedback number packets collided works dealt model richer feedback channel tsybakov tsy80 examined model number colliding hosts known georgiadis papantonikazakos gpk82 studied channel number colliding hosts known bound pippenger pip81 proved capacity collision channel full multiplicity feedback 1 ruszinko vanroose rv97 gave algorithm achieves bound works examined model channel multiple reception capability k 1 simultaneous transmissions may decoded tsybakov et al tml83 assumed channel ternary feedback hosts know previous slot idle successful transmissions k 1 collision k packets occurred likhanov et al lps examined similar model assumed case successful transmissions hosts aware exact number successful transmissions important note even case model literature one used objective different thus optimization problem different makes solution works well one problems perform badly example model full multiplicity feedback given matches model host feedback thus results pip81 rv97 might seem suggest n grows exists algorithm elects group least case r 11 expected number rounds approaches one however examination algorithm structure pip81 rv97 reveals initialization phase takes n log n rounds whose cost amortized transmission n packets solution fit goal since interested first successful transmission jargon somewhat less related line work distributed leader election many variants problem studied lyn97 closest model problem case anonymous cliques ie network full connectivity unique identifiers processors montecarlo solution given afek matias am94 aware lasvegas solution better fits model note model central entity exist distributed leader election literature feedback suppression multicast studied extensively recent years main two solution approaches suggested timer based structural based cf nb98 one exception work bolot et al btw94 suggested mechanism feedback control multicast video distribution solution host assigned random 16 bit vector sender polls receivers sending bit mask receivers matching vector reply polling masks decreasing size sender ensure small number feedback messages high probability polling may take 15 rounds number receivers small solution unknown n case similar nature demonstrated section via tuned achieve faster convergence specific target range feedback messages iii model n hosts wish elect subgroup size range r l u election hosts communicate central trusted entity c direct communication among hosts allowed communication done synchronous rounds round c broadcasts feedback message hosts host may send reply message distinguish solutions based amount information feedback message f following parameters interest first would like minimize expected number rounds needed election process another important parameter would like minimize election overhead number messages sent hosts en 3basic algorithm 1 init 2 n c received feedback 3 n c l 4 send reply 5 1 6 else 7 n c u 8 send reply 9 else 10 rnd cn c 11 send reply 12 else 13 0 fig 1 basic algorithm host basic algorithm 1 n c 0 2 n 3 send feedbackn c 4 n c number replies fig 2 basic algorithm c tire election process excluding first n messages iv algorithms history first study simple algorithm requires host maintain one bit state see figure 1 indicates host participates current election process round see figure 2 c sends number reply messages received previous round n c ie f size log n bits host decides reply suggest representative probability p defined cn c n c u 1 c preconfigured constant state bit set feedback c less l reset host drops candidacy probability 1 cn c election process starts c sends value 0 feedback ends number active hosts desired range figures 1 2 give pseudocode algorithm host c rnd returns random number uniformly distributed 01 value constant c predetermined next evaluate algorithm performance particular show calculate optimal value c end let us first define p rfijmg probability hosts active current round exactly hosts decide remain active reset c basic algorithm simulation analysis fig 3 comparison simulation results analytical results 500 next round 2 expected number messages nn given following relation formulation omit cost first initialization round reasons become clear section via first line sum possibilities hosts stayed active round pay messages round n n rest election relation reflects fact election ends active host number reaches target range last relation due fact undershoot restart algorithm equation 3 defines linear system n n equation solved c free parameter minimize message overhead note calculation certain n obtain rest values n n n cannot used obtain n values similar system defined one wishes minimize number rounds takes system elect number representatives desired target range case pay unit price per round although analysis easily used produce numerical results found running high confidence simulations much faster large n values thus graphs presented paper driven high 23number users n expected number rounds lu1 c13 l4 u8 c66 l1 u8 c43 number users n expected number messages l4 u8 c85 l1 u8 c56 fig 4 basic algorithm n nn function n confidence simulations point average 10000 runs cases 1 confidence interval less 1 figure 3 compares results achieved simulations analysis 500 3 c 8 simulation point derived 10000 different runs simulation points fall close analysis results simulation used predict high accuracy value function used selection optimal c figure 4 depicts values n nn several target ranges graph picked c value closer optimum obvious fact graphs fast converges algorithm little dependency n n astonishingly even large values n expected number rounds initialization round less 2 number messages needed algorithm also well n10 large enough n grows sublinear rate figures show n dependency c dependency fairly stable wide range n val ues functions fairly flat around optimum become quite steep farther away next present simple observation help l4 u8 n500 l1 u8 n500 fig 5 basic algorithm n nn function c selecting c close optimal shape p rfijmg mode rapidly drops sides thus selecting l c u one expect likely undershoot range overshoot 1 penalty undershoot two rounds penalty overshoot one round 2 suggests cases one additional round needed thus selecting c 23 point l u ie 2u l3 likely lay flat region around optimum similarly n penalty overshoot thus optimal c approximated u u lu improved algorithm skipreset although basic algorithm performs well still room improvement use observation feedback less l wasted round hosts suggest candi dates purpose round hosts learn value n value advertised c saves round significantly n messages algorithm skipreset 1 init 2 n c r received feedback 3 4 1 5 n c l 6 send reply 7 1 8 else 9 n c u 10 send reply 11 else 12 rnd cn c 13 send reply 14 else 15 0 fig 6 algorithm skipreset host algorithm skipreset 1 n c 0 2 n 0 3 n 4 n c l 5 send feedbackn 1 6 else 7 send feedbackn c 8 n c number replies 9 n maxfnn c g fig 7 algorithm skipreset c transmitted round 1 pseudocode improved algorithm called skip reset given figures 6 7 seen addition host algorithm ability receive reset bit feedback message algorithm c needs store memory population size variable n use reset required change formulation enhancement simple l avoid payment skipped round n 1 thus equation 3 equation 4 written observation similar spirit one made massey binary tree collision resolution protocols rs90 section 521 number users n expected number rounds basic improved number users n expected number messages improved fig 8 improved algorithm vs basic algorithm n nn figure 8 shows improvement algorithm performance 8 improvement n modest fifth round 13 improvement nn dramatic almost linear dependency n n eliminated get nn 92 n 100 parameter selection similar improvement achieved b power choice weve seen cases election done one round increase chances succeeding first round one use following technique round host draws two coins probability p sends election message containing drawings least one draws remains active requires two bits sent election message c receives election messages hosts choose use either two rounds drawing whichever optimizes operation 2 particular al technique similar spirit one used azar et al balanced allocation balls bins abku99 1214 number users n expected number rounds skipreset choice number users n expected number messages skipreset choice fig 9 algorithm skipreset vs choice algorithm n nn gorithm take one round either two drawings within target range example probability success one round 13 using free choice two rounds probability succeed one round increases 1 1 feedback c sends must include bit indicating two election rounds used requires hosts maintain additional two bits part state figure 9 shows gain algorithm combined previous improvement skip reset one see number rounds appropriate choice c almost always 1 however penalty increase number messages almost factor two note however use improvement basic algorithm improve n v algorithms history section present algorithm requires hosts remember state previous round motivation type algorithm less algorithm skipreset history 1 init 2 n c r received feedback 3 4 1 5 n c l 6 send reply 7 1 8 else 9 n c u 10 send reply 11 else 12 rnd cn c 13 send reply 14 else 15 0 16 else 17 h 0 fig 10 algorithm skipreset history host algorithm skipreset history 1 n c 0 2 n 0 3 n 4 n c l 5 send feedbackn 1 6 else 7 send feedbackn c 8 n n c 9 n c number replies fig 11 algorithm skipreset history c l hosts left active better return pervious round may less active participants initial number active hosts potentially reduce number messages algorithm skipreset without adding number rounds figures show pseudocode algorithm skipreset one round history host maintains previous state variable h returns active mode receives reset notification active previous round c maintains smallest number still larger l active hosts learned sends reset upon receiving less l replies equations 3 4 seem change slightly however change substantial introducing history last state algorithm never rolls back equation becomes oblivious initial host popu lation main advantage ability solve equations iteratively obtain 2 ni values l n holds iterative form equations 7 8 u note every round election expected number messages c receives c regardless number active hosts means functions defined l course mean election number messages sent c times number election rounds fact easily proved induction u assuming hypothesis holds 1 proves hypothesis clear holds also algorithm skipreset since also every round number messages expected c however finding algebraic proof algorithm skipreset still open though logical proof suffice basic algorithm constant factor relation hold reason rounds namely feedback message shows less l active hosts number active hosts n probability 1 expected c figure 12 depicts improvement algorithm skip reset history used gain n 56 gain nn around quarter percent reference also plot algorithm choice improves roughly 40 increases n 5 vi robustness previous sections assumed either n known c poll nodes number applications like multicast feedback polling number users n expected number rounds skipreset choice history 411114number users n expected number messages skipreset choice history fig 12 performance comparison algorithm skipreset choice algorithm algorithm skipreset history leader election scenario values may cause feedback implosion applications number hosts may dynamically change result hosts joiningleaving network partitioning cases important check robustness algorithms presented previous section inaccurate estimation n figure 13 presents performance algorithm skipreset used estimation total number hosts n instead real value one see factor 10 mistakes value n increase n one round may generate times messages estimation un dershot another fact clear figure 13 always pays overestimate due fact underestimation may cause generate many messages since nodes using much big overestimation cause additional rounds message transmitted since estimating n robustness algorithms respect n indicates small degradation per 5log2initial guess true n twith tn n5000 nwith nn n5000 fig 13 relative performance algorithm skipreset different estimations n formance scenario small number nodes either joining leaving system however applications like multicast number hosts may vary sig nificantly important keep estimation always bigger actual n value avoid feedback implosion suggest family algorithms starts high estimation say 100000 compare 2 16 used btw94 reduces every time number responses smaller l rate estimation reduced given function work used family functions defined following way second condition ensures estimation range 1u estimated value n decreases constant factor 1 however 1 estimated value n decreases much faster latter shorter convergence time may result messages algorithm skipreset estimating n 1 n c 0 2 n maxguess 3 send feedbackmaxguess 1 4 n 5 n c number replies 6 n c l 7 n fn 8 send feedbackn 1 9 else 11 n maxfnn c g fig 14 algorithm skipreset estimating n c let fn function used decrease estimate feedback l denote n fijng probability exactly n hosts elected round given estimate hosts analyze performance estimation algorithm assuming algorithm skipreset used write expressions expected number messages rounds elect council given initial estimation hosts note unlike previous analysis count rounds including initialization round following previous formulation let expected number messages sent round correspondingly given n hosts thus write recursive relations n n ones calculated linear system 5 n defined since fn return values range see equation 11 since host suggest candidate next round way write equations u number users n l1 u8 c56 conservative aggressive number users n l1 u8 c56 conservative aggressive fig 15 performance algorithm skipreset n unknown figure 15 shows performance algorithm typical scenario target range willing elect 8 members compare responders bound btw94 selected two sets parameters conservative set aggressive set compare two algorithm btw94 3 even actual population small 10 conservative search takes 10 rounds elect represen 3 bolot et al calculate expected number messages instead showed probability number greater small calculated expected number messages algorithm algorithm section host c feedback name number memory memory size bits skipreset iva 1 bit log n bits 1 choice ivb 3 bits log n bits algorithms presented tatives compare 13 rounds required btw94 algorithm algorithms reduce approximation factor 2 performs better since probability host become candidate estimate reaches 60 get p 110 thus high probability one representative elected much faster convergence achieved using aggressive parameter set every time response estimation reduced n 07 therefor four rounds sufficient n reduction number rounds comes penalty increase expected number messages however maximum 15 messages aggressive algorithm achieves well within tolerable number local maxima aggressive algorithm graphs corresponds maximal number steps vii concluding remarks table summarizes algorithms presented pa per note algorithms work continuously change condition cs algorithm true way representative group size decreases time l new election process automatically restarts context interesting research direction design efficient election algorithm increases group size close still l thus avoiding reactivation election r balanced allocation elections anonymous networks scalable feedback control multicast video distribution inter net collision resolution protocol random access channels energy detectors lixia zhang distributed algorithms optimal multicast feedback bounds performance protocols multiple access broadcast channel multiple access protocols performance analysis erdos renyitype search approach gives explicit code construction rate 1 random access multiplicity feedback bounds packet transmission rate randommultipleaccess system resolution conflict known multi plicity tr multiple access protocols performance analysis elections anonymous networks scalable feedback control multicast video distribution internet reliable multicast framework lightweight sessions application level framing balanced allocations idmaps distributed algorithms control message aggregation group communication protocols
symbolic cache analysis realtime systems caches impose major problem predicting execution times realtime systems since cache behavior depends history previous memory references pessimistic assumptions cache hits obtain worstcase execution time estimates prohibitive realtime systems paper presents novel approach deriving highly accurate analytical cache hit function cprograms compiletime based assumption external cache interference eg process dispatching dma activity occurs first symbolic tracefile instrumented cprogram generated based symbolic evaluation static technique determine dynamic behavior programs memory references program described symbolic expressions recurrences stored chronological order symbolic tracefile second cache hit function several cache architectures computed based cache evaluation technique approach goes beyond previous work precisely modelling program control flow program unknowns modelling large classes cache architectures providing accurate cache hit predictions examples sparc architecture used illustrate accuracy effectiveness symbolic cache prediction b introduction due highlevel integration superscalar architectural designs computational capability microprocessors increased significantly last years unfortunately gap processor cycle time memory latency increases order fully exploit potential processors memory hierarchy must efficiently utilized guide scheduling realtime systems information execution times required compiletime modelling caches presents major obstacle towards predicting execution times modern computer architectures worstcase assumptions eg every memory access results cache miss 1 cause poor execution time estimates c publishers printed netherlands j blieberger fahringer b scholz focus paper accurate cache behavior analysis note modelling caches one performance aspect must considered order determine execution times many performance characteristics blieberger 1994 blieberger lieger 1996 blieberger 1997 fahringer 1996 park 1993 healy et al 1995 analyzed however beyond scope paper paper introduce novel approach deriving highly accurate analytical function precise number cache hits 2 implied program approach based symbolic evaluation cf eg fahringer scholz 1997 compiletime collects runtime properties control data flow information given pro gram number cache hits described symbolic expressions recurrences defined programs input data maintain relationship cache cost function input data figure 1 depicts overview framework described paper cprogram compiled results instrumented c program sourcecode level instrumentation inserts code points main memory data referenced read written instrumented sourcecode symbolically evaluated symbolic tracefile created memory references program described symbolic expressions recurrences stored symbolic tracefile based cache parameters describe cache architecture analytical cache hit function computed symbolically evaluating symbolic tracefile note model strictly separates machine specific cache parameters program model substantially alleviates portability approach cache architectures programming languages performing worstcase cache analysis according approach divided following steps 1 build symbolic tracefile based instrumented program sources using symbolic evaluation 2 compute analytical cache hit function symbolically evaluating symbolic tracefile 3 find closed form expression cache hit function 4 determine lower bound cache hit function order derive worstcase caching behavior program steps 1 2 treated paper steps guarantee precise description cache hits misses step 3 requires solve recurrence relations implemented recurrence solver described fahringer scholz 1997 symbolic cache analysis realtime systems 3 ccompiler instrumentation executable cfiles instrumented cfile symbolic evaluation symbolic tracefile parameters cache cachehit function symbolic cache evaluation figure 1 overview predicting cache performance fahringer scholz 1999 current implementation recurrence solver handles recurrences following kind linear recurrence variables incremented inside loop symbolic expression defined constants invariants polynomial recurrence variables incremented linear symbolic expression defined constants invariants recurrence variables geometric recurrence variables incremented term contains recurrence variable multiplied invariant algorithm fahringer 1998b computing lower upper bounds symbolic expressions based set constraints used detect whether recurrence variable monotonically increases decreases even closed form found recurrence variable monotonicity information may useful instance determine whether pair references ever touch address 4 j blieberger fahringer b scholz current implementation symbolic evaluation framework models assignments goto simple io array statements loops procedures result step 3 conservative approximation number exact cache hits misses ie computed upper lower bounds used find lower bound cache hit function output form step 3 suitably normalized casestructure possibly comprises several cache hit functions conditions attached different cases correspond original program structure affected cache architecture step 4 determine minimum cache hit functions casestructure mentioned note necessary determine worstcase input data program structure implies worstcase cache behavior steps 3 4 described detail fahringer scholz 1997 fahringer scholz 1999 fahringer 1998b rest paper organized follows section 2 discuss architecture model caches section 3 describe symbolic evaluation outline new model analyzing arrays section 4 contains theoretical foundations symbolic tracefiles illustrates practical example section 5 symbolic cache evaluation techniques presented direct mapped set associative caches section 6 provide experimental results although approach explained experimentally examined based cprogramming language similarly applied procedural languages including ada fortran section 7 compare approach existing work finally conclude paper section 8 2 caches rate processor execute instructions limited memory cycle time limitation fact significant problem persistent mismatch processor main memory speeds caches relatively small highspeed memories introduced order hold contents recently used data main memory exploit phenomenon locality reference see hennessy patterson 1990 advantage cache improve average access time data located main memory concept illustrated figure 2 cache contains small portion main memory cache hit occurs cpu requests memory reference found cache case reference memory word transmitted symbolic cache analysis realtime systems 5 cpu cache memory transfer block transfer word figure 2 cpu cache main memory cpu otherwise cache miss occurs causes block memory fixed number words transferred main memory cache consequently reference transmitted cache cpu commonly cpu stalled cache miss clearly memory references cause cache miss significantly costly reference already cache past various cache organizations hennessy patterson introduced figure 3a depicts general cache organization cache consists ns slots slot hold n cache lines one cache line contains block memory consisting cls contiguous bytes tag holds first address bits memory block figure 3b shows address divided three fields find data cache block offset field used select desired data block index field select slot tag field used comparison note bits index used n 1 cache characterized three major parameters first capacity cache determines number bytes main memory may contain second line size cls gives number contiguous bytes transferred memory cache miss third associativity determines number cache lines slot block memory reside exactly one location cache called direct mapped cache set contain one cache line block reside cache location cache called fully associative one slot block reside exactly n locations n size cache set cache called nway set associative case fully associative set associative caches memory block selected replacement cache set memory block full processor requests data done according replacement strategy smith 1982 common strategies lru least recently used lfu least frequently used random furthermore two common cache policies respect write accesses cpu first write caches write data memory cache therefore memory cache line second write back caches update cache line data 6 j blieberger fahringer b scholz block offset tag block cache organization figure 3 cache organization item stored write back caches cache line marked dirty bit different memory block replaces modified cache line cache updates memory write access cpu address reside cache called write miss two common cache organizations respect write misses first writeallocate policy loads referenced memory block cache policy generally used write back caches second nowriteallocate policy updates cache line address cache policy often used write cache advantages memory always contains uptodate information elapsed time needed write access constant symbolic cache analysis realtime systems 7 caches classified cache holds instructions called instruction cache cache holds data called data cache cache hold instructions data called mixed unified cache cache design extensively studied good surveys found alt et al 1996 mueller 1997 ottosson sjoedin 1997 li et al 1996 li et al 1995 healy et al 1995 arnold et al 1994 nilsen rygg 1995 liu lee 1994 hennessy patterson 1990 3 symbolic evaluation symbolic evaluation 3 cheatham et al 1979 ploedereder 1980 fah ringer scholz 1997 fahringer scholz 1999 z constructive description semantics program moreover symbolic evaluation merely arbitrary alternative semantic description program relationship arithmetic algebra specific arithmetic computations dictated program operators generalized delayed using appropriate formulas dynamic behavior precisely represented symbolic evaluation satisfies commutativity property symbolic evaluation gammagammagammagammagammagammagammagammagammagammagammagammagammagammagammagamma zp parameters result conventional execution gammagammagammagammagammagammagammagammagammagammagammagammagammagammagammagamma zpi program p conventionally executed standard semantics given input result symbolically evaluated program instantiated clearly symbolic evaluation seen compiler translates program different language use target language symbolic expressions recurrences model semantics program semantic domain symbolic evaluation novel representation called program context fahringer scholz 1997 fahringer scholz 1999 every statement associated program context c describes variable values assumptions regarding constraints variable values path condition path condition holds given input statement executed formally context c defined triple p state state condition p path condition gamma state described set variablevalue pairs fv program variable e symbolic 8 j blieberger fahringer b scholz expression describing value v 1 n program variables v exists exactly one pair gamma state condition contains constraints variable values implied loops variable declarations user assertions path condition predicate true program statement reached note components context including state information described symbolic expressions recurrences unconditional sequence statements j 1 j r symbolically evaluated initial context represents context holds 1 r context holds r sequence contain side effects implying change variable furthermore context c p logical assertion c predicate set program variables program input free variables input values c igamma1 holds executing statement c strongest post condition dijkstra 1976 program variables state satisfying c executing technical details refer reader fahringer scholz 1997 fahringer scholz 1999 blieberger burgstal ler 1998 blieberger et al 1999 following discuss novel approach evaluate arrays 31 arrays let onedimensional array n n 1 array elements consider simple array assignment aiv element index substituted value v intuitively may think array assignment array operation defined array operation applied array changes internal state arguments array operation value index new assigned array element sequence array assignments implies chain operations formally array represented element array algebra array algebra inductively defined follows 1 n symbolic expression n 2 2 2 ff fi symbolic expressions phi ff fi 2 3 nothing else symbolic cache analysis realtime systems 9 int a100x figure 4 cprogram fragment state context array variable associated element array algebra undefined array states denoted size array determines number array elements array assignment modelled phifunction semantics phifunction given phi ff represents elements array fi denotes index element new value ff following general array assignment context context statement symbolic value variable evaluating statement denoted furthermore element least one phifunction phichain every phichain written length chain jaj number phifunctions chain cprogram fragment figure 4 illustrates evaluation several array assignments context statement j represented c beginning program fragment value variable x symbolic expression denoted x array undefined j blieberger fahringer b scholz 100 array assignment statements state path conditions set true code fragment implies branches program statements imply change single variables value order avoid large lists variable values state descriptions variables whose value changes evaluation associated statement explicitly specified reason introduce function ffi specifies state whose variable binding equal state j except variable v assigned new value e therefore previous example state 1 state 0 except symbolic value array last statement array symbolically described 1 leftmost phifunction relates first assignment example program rightmost one last statement note last two statements overwrite values first two statements therefore simplified representation given although equivalence two symbolic expressions undecidable haghighat polychronopoulos 1996 wide class equivalence relations solved practice set conditions among used variables context significantly improves evaluation equivalence relation partial simplification operator introduced simplify phichains operator defined follows partial simplification operator seeks two equal expressions phichain pair exists result initial phi chain without phifunction refers fi expression smaller index pair exists operator returns initial phichain chain could simplified semantically rightmost expression relates latest assignment overwrites value previous assignment symbolic index partial simplification operator reduces one redundant phifunction previous example must applied twice order symbolic cache analysis realtime systems 11 simplify phichain moreover phifunction chain potentially redundant one therefore chain potentially simplified less jaj applications partially complete simplification iterative application partial simplification operator written applied applying simplify anymore order access elements array need model symbolic access function operator ae symbolic expressions e described phichain reads element index array index found phichain ae yields corresponding symbolic expression otherwise ae undefined value latter case possible determine whether array element index written let element l1 ff l fi l operator ae defined ae symbolic index array element found general determining whether symbolic index matches phi function undecidable practice wide class symbolic relations solved techniques comparing symbolic expressions 1998a symbolic evaluation framework cannot prove result ae fi l ae resolvable remains unchanged symbolic expression e present four examples figure 5 based value end program fragment figure 4 every example insert one following statements end code fragment shown figure 4 1 xax 2 xax1 3 xax1 4 xay new variable symbolic value figure shows symbolic value x inserted statement note first equation element index x uniquely determined second equation resolved well third example index x gamma 1 exist phichain therefore access returns undefined symbol last equation enough information determine unique value array element index distinguish several cases cover possibilities j blieberger fahringer b scholz 1 2 3 4 figure 5 examples ae 32 array operations inside loops modelling loops implies problem recurrence variables 4 use functions model recurrences follows ik value scalar variable end iteration k 1 symbolic evaluation framework detects recurrence variables determines recurrence system finally tries find closed forms recurrence variables loop exit solving recurrence sys tem recurrence system given boundary conditions initial values recurrence variables loop preheader recurrence relations implied assignments recurrence variables loop body recurrence condition loop exit condition implemented recurrence solver scheibl et al 1996 written top mathematica recurrence solver tries determine closed forms recurrence variables based recurrence system directly obtained program context implementation recurrence solver largely based methods described gerlek et al 1995 lueker 1980 improved techniques fahringer scholz 1997 fahringer scholz 1999 similar scalar variables array manipulation inside loops described recurrences recurrence system consists boundary condition recurrence relation ff l k fi l k ff l k fi l k symbolic expressions k recurrence index k 0 clearly every instance recurrence element without changing semantics array recurrence applied simplify recurrence relation symbolic cache analysis realtime systems 13 operator ae needs extended array recurrences arrays written inside loops accessed eg aeaz symbolic expression z number loop iterations determined loop exit condition index accessed element furthermore recurrence index k bounded 0 k z determine possible phifunction accessed element written potential index set l lth phifunction computed l contains possible fi l k z equal index index set one element array element written different loop iterations lth phifunction last iteration writes array element interest consequently choose element greatest index supremum x l index set l greatest index finally define operator ae follows ae az ae maximum supremum indices x l determines symbolic value ff l x l supremum index exists ae returns access value loop example code program figure 6 shows symbolically evaluate array access recurrence ik resolved state 3 3 due missing information recurrence array resolvable symbolic evaluation still models dynamic behavior example code 4 symbolic tracefile tracing method generating sequence instruction data references encountered program execution trace data commonly stored tracefile analyzed later point time tracing instrumentation needed insert code points program memory addresses referenced tracefile created sideeffect execution tracing requires careful analysis program ensure instrumentation correctly reflects data code references program moreover instrumentation 14 j blieberger fahringer b scholz int char a100s0 figure 6 cprogram fragment done sourcecode level machine code level framework need sourcecode level instrumentation past variety different cache profilers introduced e g mtool gold berg hennessy 1991 pfcsim callahan et al 1990 cprof lebeck wood 1994 novelty approach compute trace data symbolically compiletime without executing program symbolic tracefile constructive description possible memory references chronological order represented symbolic expressions recurrences following discuss instrumentation program figure 6 sparc assembler code listed figure 7 first part code loop preparation phase portion code contents variable n loaded work register additionally address built register g2 inside loop storage location n referenced anymore four read accesses ai ai ai1 two write accesses ai furthermore variable held register based information instrument example program figure 8 instrumented program shown function r refrnb denotes read reference address r length nb bytes write reference function w ref used symbolic cache analysis realtime systems 15 ld o3long5 read n mov 0o1 add g51g5 cmp o1g5 bge ll3 g2loag2 add g21o4 ldub o2losg2 read ldub o0g3 read ai add g2g3g2 stb g2o2los write ldub o0g2 read ai ldub o1o4g3 read ai1 add g2g3g2 stb g2o0 write cmp o1g5 bl ll5 add o01o0 retl figure 7 sparc code example figure 6 symbolic tracefile created using chain algebra references stored chain symbolic trace file 2 inductively defined follows 1 2 2 r nb symbolic expressions phi oer nb 2 3 2 r nb symbolic expressions phi r nb 2 4 nothing else semantically function oe write reference memory symbolic address r whereby number referenced bytes denoted nb similar semantics read references r address nb number referenced bytes instance 32bit bus cache cpu transfer word references 4 bytes therefore double data item j blieberger fahringer b scholz comprises 8 bytes r 8 must loaded two consecutive steps 4 word reference need number referenced bytes anymore constant example legal rewrite r 8 rphir4 notation extensively used examples section 5 loops need recurrences l k read write reference r l k nb r l k nb symbolic evaluation used automatically generate symbolic tracefile cprogram instead symbolically evaluating instrumentation calls associate w ref r ref specific semantics pseudo variable 2 added program read reference r refrnb translated phi r nb state pseudo variable evaluating instrumentation done write references except replaced oe let us consider example figure 8 entering loop needs log reference r refn4 therefore equal phin n denotes address variable n inside loop recurrence used describe symbolically boundary condition t0 equal phi n 4 reflects state loop recurrence relation given note alternative notation ak start address array finally last value k recurrence tk determined loop condition symbolic tracefile small portions final program context needed therefore extract necessary parts final context describe symbolic tracefile state condition symbolic value relevance example figure 8 symbolic tracefile given symbolic cache analysis realtime systems 17 int char a100s0 figure 8 cprogram fragment symbolic tracefile length symbolic tracefile corresponds number readwrite references either number reads number writes interest selectively count elements oe instance number read references jtj number write references jtj 1 overall number memory references given 5 symbolic evaluation caches symbolic tracefile program describes memory references sued cpu chronological order based symbolic trace j blieberger fahringer b scholz file derive analytical function input computes number hits symbolic tracefile contains information obtain hit function moreover symbolic cache analysis decoupled original program thus approach used tailor cache organization due needs given application following introduce two formalisms compute hit function direct mapped set associative data caches symbolically simulate cache hardware hit sets introduced hit sets symbolically describe addresses held cache keep track number hits 51 direct mapped caches direct mapped caches easiest cache organization analyze item data exactly one location direct mapped cache placed 5 cache contains ns cache lines size cache line cls determines amount data moved main memory cache following introduce cache evaluation direct mapped caches write nowriteallocate policy compare section 2 new cache evaluation operator fi defined derive hit set given tracefile hit set h first component h symbolic cache element second component represents number cache hits symbolic cache c hit set h ns elements element corresponds cache line cache formally algebraic operation c phir fi loads memory block start address r cache whereby fi index cache line note cpu issues address r start address r corresponding memory block must selected describe reference moreover cache placement function maps reference index cache c load operation reference r written c phi r r following assume function modulo operation ns cls 511 definition cache evaluation operator ns 0 denotes initial hit set final hit set tracefile final hit set h f analytical description number cache hits final state cache following describe operator fi inductively first empty tracefile hit set symbolic cache analysis realtime systems 19 second write reference first reference tracefile change hit set removed 2 l either read reference r l write reference oer l third read references new hit set must computed c otherwise increment 1 reference r cache otherwise zero reference r must loaded loading data item address r cache c assigned new symbolic value c phi r r order symbolically describe conditional behavior caches data item cache introduce flfunction see fahringer scholz 1997 semantically equivalent cx c conditional expression c negation c moreover x symbolic expressions based definition fl 6 aggregate formulas given 34 5 depending condition aec either number cache hits h 0 incremented one symbolic cache assigned new symbolic value c j blieberger fahringer b scholz similar tracefiles hit sets written pair first component pair symbolically describes hit set second component contains constraints variable values conditionals recurrences stemming loops furthermore recursivelydefined tracefiles need generalize hit sets hit set recurrences let tk l k tracefile recurrence relation h initial hit set hit set recurrence expressed 512 example sake demonstration study example figure 6 cache size 4 cache lines cache line comprises one byte cache placement function r r mod 4 maps memory addresses slots cache moreover references already transformed word references references n a0 aligned first cache line note example word reference transfer one byte cpu cache vice versa initial hit set h 0 based symbolic tracefile given 1 hit set recurrence derived first apply operator fi hit set recurrence according 8 final hit set given h highest index k recurrence determined loop condition following evaluate boundary condition hit set recurrence successively apply evaluation rule 7 operator fi initial hit set 4 0 symbolic cache analysis realtime systems 21 note condition aec rule 7 false read references boundary condition evaluating boundary condition still cache hit cache fully loaded contents variable n next step analyze loop iteration continue apply operator fi recurrence relation c k h k denote symbolic cache number hits kth iteration hit set recurrence global variable mapped first cache line first slot cache contains address cache hit occurs number hits incremented otherwise new element loaded number hits remains apply operator fi obtain next step eliminate write reference oes according rule 2 apply operator fi ak 22 j blieberger fahringer b scholz simplify flfunction contents symbolic cache k k mod 4 k reference ak loaded step previous one note write reference oes destroy reference ak last step references ak oeak evaluated continue third flfunction reduced since element k1 never written condition aec 00 hit set recurrence still conditional investigations necessary derive closed form number hits know number cache lines four consider four modulo classes index k given example results unconditional recurrence 0 condition aec k first flfunction false since aec k 0 rewritten k k 1 otherwise condition second flfunction aec 0 false well cache line loaded reference case k mod hit set recurrence reduced unconditional recurrence first flfunction condition aec k never true previous step recurrence symbolic cache analysis realtime systems 23 cache line 1 loaded contents ak gamma 1 fur thermore element ak fetched previous step therefore condition second flfunction evaluates true hit set recurrence written 3 cases conditions flfunctions true load reference interfere ak ak 1 recurrence given extract number hits hit sets 9 10 11 modulo classes rewritten k replaced 4i modulo class boundary conditions stem number hits h0 recurrence linear resolving obtain index z final hit set h determined z 1 analytical cache hit function h z given 12 approximated 9 example conditional recurrence collapsed unconditional one general obtain closed forms specific although important classes conditional recurrences recurrences cannot resolved employ approximation techniques described fahringer 1998a j blieberger fahringer b scholz1n1 figure 9 nway set associative cache 52 set associative fully associative caches section investigate nway set associative write data caches writeallocate policy least recently used replacement lru strategy organization setassociative complex direct mapped data caches due placing memory block n possible locations slot compare section 2 similar direct mapped caches define cache evaluation operator fi derive hit set given tracefile set associative caches hit set tuple cache h number hits max symbolic counter incremented every read write reference note symbolic counter needed keep track least recently used reference slot figure 9 illustrates symbolic representation c set associative caches c array ns slots slot denoted ns gamma 1 hold n cache lines array c slots elements array algebra formally algebraic operation phi r fi loads memory block start address r set whereby fi index 0 fi n current symbolic value max reading value r denoted ae r fi reading time stamp written ae fi whole set loaded cache c via c phi note cpu issues address r start address r corresponding memory block must selected describe reference similar direct mapped caches cache placement function maps memory reference slot load operation reference r written c phi aec r phi r r r function determining symbolic cache analysis realtime systems 25 index slot according lru strategy defined exists aes note first case determines spare location slot first spare location determined second case computes least recently used cache line slot 521 definition cache evaluation operator ns 0 0 denotes initial hit set final hit set tracefile final hit set h f analytical description number cache hits final state cache following describe operator fi inductively first empty tracefile hit set second read write operation r first memory reference tracefile new hit set deduced follows symbolic counter max incremented one furthermore slot reference r determined increment given 0 otherwise exists element slot equal r cache hit occurs increment reference r must updated new time stamp function r looks index reference r stored slot r described recurrence 0 cache miss occurs reference loaded cache 26 j blieberger fahringer b scholz aggregate formulas 13 18 flfunctions depending condition new element updated new time stamp loaded cache note fl functions nested formula 19 nested fl recursively expanded compare 6 expanded boolean expression added corresponding true false term higherlevel flfunction furthermore recursivelydescribed tracefiles need generalize hit sets hit set recurrences compare 8 522 example symbolically evaluate example figure 6 2way set associative cache two slots cache line size one byte cache organization word reference transfer one byte cpu cache vice versa thus cache size section 51 cache organization changed cache placement function r r mod 2 assume references symbolic tracefile already transformed word references references n a0 aligned first slot initial hit set h 0 based tracefile given 1 hit set recurrence derived similar example section 51 apply operator fi hit set recurrence according 8 read references boundary cache hit occurred cache loaded contents variable n number cache symbolic cache analysis realtime systems 27 hits zero next step evaluate recurrence relation continue apply operator fi according rule 19 c k h k k denote symbolic cache number hits time stamp counter kth iteration hit set recurrence order keep description hit set recurrences small possible rewrite outer flfunction 20 p apply operator fi obtain next step evaluate write reference oes get 28 j blieberger fahringer b scholz simplify flfunction variable read within current iteration loop without overwritten cache condition outer flfunction evaluates true hence obtain similar previous step reduce flfunctions read reference ak produces cache miss thus next step simplified symbolic cache analysis realtime systems 29 last step fi operator applied write reference cache hit eliminate fl functions arguments similar section 51 show conditions outer flfunction p 0 p 00 true k 1 false therefore derive unconditional recurrence relation number cache hits k 1 3 closed form solution given 2 index z final hit set h determined z 1 thus analytical cache hit function shows example set associative cache performs better direct mapped cache size 6 experimental results order assess effectiveness cache hit prediction chosen set cprograms benchmark adopted evaluation framework introduced fahringer scholz 1997 fahringer scholz 1999 programming language c cache evaluation instrumentation done hand although existing tool cprof lebeck wood 1994 could instrumented benchmark suite symbolic evaluation framework computed symbolic tracefiles symbolically evaluated data caches order compare predictions real values j blieberger fahringer b scholz int n char a100 void sum int figure 10 benchmark program measured cache hits given cache problem size measuring empirical data used acs cache simulatorhunt 1997 programs benchmark suite amended instrumentation routines provided library bin2pdt generated tracefiles stored pdats johnson ha 1994 files later read acs cache simulator first program benchmark suite example program figure 10 contrast section 5 analyzed direct mapped data cache cache line size greater one byte furthermore first byte array aligned first byte arbitrary cache line cache one cache line framework computes cache hit function number cache hits determined cls upsilon cls cache line size 4 8 bytes intuitively get 2n gamma 1 potential cache hits every new cache line miss implied therefore subtract number touched cache lines cls upsilon number read references table ia describes problem sizes n n first column number read rref second column write wref third column ref erences sum read write references tref fourth column tables measured predicted cache hits various data cache configurations capacitycache line size instance dcache 2564 corresponds cache 256 bytes cache line size 4 bytes every table comprises four columns mmiss tabulates measured cache misses mhits measured cache hits phits predicted cache hits accordance accurate symbolic cache analysis observe predicted hits identical associated measurements cache configurations considered benchmark program taken derive analytical cache hit function set associative data caches note result direct mapped caches even empirical study two way data caches capacity delivered measurements given tables ib id symbolic cache analysis realtime systems 31 table problemsize rref wref tref 28 1000 1999 999 2998 10000 19999 9999 29998 table ib dcache2564 mmiss mhit phit 100 26 173 173 1000 251 1748 1748 10000 2501 17498 17498 table ic dcache16k8 mmiss mhit phit 1000 126 1873 1873 10000 1251 18748 18748 table mmiss mhit phit j blieberger fahringer b scholz table iia experiment mcnt problem size nthetam rref wref tref table iib dcache 64k16 nthetam mmiss mhit phit 100theta100 5000 5000 5000 100theta200 100000 100000 100000 second program mcnt benchmark suite counts number negative elements n theta mmatrix counter held register interfere memory references matrix analyzed program three different direct mapped cache configurations 2564 16k8 64k16 data cache sizes 2564 16k8 cache hit function zero due float fnn unn newnn void jacobirelaxation int ij figure 11 jacobi relaxation symbolic cache analysis realtime systems 33 table iiia experiment jacobi relaxation problem size nthetan rref wref tref 90theta90 48020 9604 288120 table iiib dcache 2564 nthetan mmiss mhit phit table iiic dcache 5124 nthetan mmiss mhit phit 50theta50 7102 4418 4418 90theta90 47672 348 348 table iiid dcache 1k4 nthetan mmiss mhit phit 50theta50 7102 4418 4418 90theta90 34 j blieberger fahringer b scholz usage double elements matrix 64k16 configuration program benefit data cache cache hits given sigma ndeltamupsilon tables iia iib analytical function compared measured results similar first benchmark cache hit function remains set associative data caches capacity measurements identical table iib third program jacobi relaxation figure 11 calculates jacobi relaxation n theta n float matrix doubly nested loop value resulting matrix new computed loop variables held registers therefore direct mapped data caches interference occur read references arrays f u investigated jacobi relaxation code cache configuration 2564 5124 1k4 number cache hits given ns ns ns ns ns n ns according section 4 ns number cache lines compared measured cache hits values cache hit function results experiments shown tables iiia iiid fourth program gauss jordan figure 12 linear equation solver note program contains ifstatement inside loop variables ip j k held registers direct mapped data caches interference occur read references array analyzed gauss jordan algorithm cache configuration 2564 could classify three different ranges n behavior hit function varies cn must described n range furthermore p n function containing 64 cases note number 64 stems number cache lines sake demonstration enlist symbolic cache analysis realtime systems 35 float ann void gaussjordanvoid int iipjk j aji aik aii figure 12 gauss jordan cases tables iva ivb compare measured results function values hit function ability determine accurate number cache hits depends complexity input programs quality techniques resolve recurrences analyse complex array subscript expressions loop bounds branching conditions interprocedural effects pointer operations impacts accuracy cache hit function instance closed forms cannot computed recurrences introduce approximations symbolic upper lower bounds fahringer 1998a provided detailed analysis codes handled symbolic evaluation fahringer scholz 1999 36 j blieberger fahringer b scholz table iva experiment gauss jordan problem size nthetan rref wref tref 200theta200 15999600 3999900 19999500 2000theta2000 15999996000 3999999000 19999995000 table ivb dcache 2564 dcache 2564 nthetan mhit phit 200theta200 7060901 7060901 2000theta2000 5825464317 5825464317 7 related work traditionally analysis cache behavior worstcase execution time estimates realtime systems park 1993 puschner koza 1989 chapman et al 1996 far complex recent research ar nold et al 1994 proposed methods estimate tighter bounds wcet systems caches work successfully applied instruction caches liu lee 1994 pipelined architectures healy et al 1995 lim et al 1994 extend original timing schemas introduced puschner koza 1989 handle pipelined architectures cached architectures nearly methods rely frequency annotations statements programmer provides wrong annotations quality prediction doubtful approach need user programmer interaction since derives necessary information programs code 6 restrict program structure ghosh et al 1997 major component framework described arnold et al 1994 static cache simulator mueller 1997 realized data flow analysis framework alt et al 1996 alternate formalization relies technique abstract interpretation presented approaches based dataflow analysis symbolic cache analysis realtime systems 37 properly model control flow among others cannot deal dead paths zerotrip loops carefully considered evaluation framework fahringer scholz 1997 blieberger 1997 implicit path enumeration ipet li et al 1995 li et al 1996 allows express semantic dependencies constraints control flow graph using integer linear programming models frequency annotations still required additionally problem ipet counts number hits misses cannot keep track history cache behavior little work done introduce history variables ottosson sjoedin 1997 ipet model ifstatements correctly provided programmer supplies correct frequency annotations lacks adequate handling loops tracefiles exactly describe data control flow behavior programs among others enables precise modeling loops theiling ferdinand 1998 ipet enriched information abstract interpretation described alt et al 1996 graph coloring approach used rawat 1993 estimate number cache misses realtime programs approach supports data caches random replacement strategy 7 employs standard dataflow analysis requires compiler support placing variables memory according results presented algorithm alleviating assumptions loops cache performance improving transformations loop unrolling make analysis less precise approach assumed every memory reference accessed inside loop specific loop iteration causes cache miss analysis consider reference might transmitted cache due cache miss previous loop iteration much research done predict cache behavior order support performance oriented program development approaches based estimating cache misses loop nests ferrante et al 1991 compute upper bound number cache lines accessed sequential program allows guide various code optimizations determine upper bounds cache misses array references innermost loops inner two loops number cache misses innermost loop causes cache overflow multiplied product number iterations overflow loop containing loops approximation technique may entail polynomial evaluations suffers limited control flow modeling unknown loop bounds branches etc lam et al 1991 developed another cache cost function based number loops carrying cache reuse either temporal 38 j blieberger fahringer b scholz relating data element spatial relating data elements cache line employ reuse vector space combination localized iteration space cross interference elements different arrays displace cache self interferences interference elements array modeled loop bounds considered even known constants temam et al 1994 examine source code numerical codes cache misses induced loop nests fahringer 1996 1997 implemented analytical model estimates cache behavior sequential data parallel fortran programs based classification array references control flow modeling loop bounds branches etc modeled profiling analytical cache cost function approach goes beyond existing work correctly modeling control flow program even presence program unknowns branches ifstatements inside loops cover larger classes programming languages cache architectures particular data caches instruction caches unified caches including direct mapped caches set associative fully associative caches handle important cache replacement write policies approach accurately computes cache hits whereas methods restricted approximations closed form expressions conservative approximations found according steps described section 1 symbolic evaluation also used wcet analysis without caching blieberger 1997 thereby solving dead paths problem program path analysis park 1993 altenbernd 1996 addi tion used performing standard compiler optimizations thus optimal framework integrating optimizing compilers wcet analysis compare engblom et al 1998 different approach 8 conclusion future work paper described novel approach estimating cache hits implied programs written procedural languages cluding c ada fortran generate symbolic tracefile input program based symbolic evaluation static technique determine dynamic behavior programs symbolic expressions recurrences used describe memory references program stored chronologically symbolic tracefile cache symbolic cache analysis realtime systems 39 hit function several cache architectures computed based cache evaluation technique following describe contributions research targets upper bounds cache misses focus deriving accurate number cache hits automatically determine analytical cache hit function compiletime without user interaction symbolic evaluation enables us represent cache hits function program unknowns eg input data approach allows comparison various cache organizations given program respect cache performance easily port techniques across different architectures strictly separating machine specific parameters eg cache line sizes replacement strategies etc machineindependent parameters eg loop bounds array index expressions etc novel approach introduced model arrays part symbolic evaluation maintains history previous array references shown experiments demonstrate effectiveness approach predicted cache behavior example codes perfectly match measured data although applied techniques direct mapped data caches write writeallocate policy set associative data caches write writeallocate policy possible generalize approach cache organizations well moreover approach also applicable instruction unified caches addition work extended analyze virtual memory architectures combined analysis caching pipelining via symbolic evaluation conducted near future compare healy et al 1999 different approach quality cache hit function depends complexity eg recurrences interprocedural effects pointers etc input programs instance cannot find closed forms recurrences employ approximations upper bounds currently extending symbolic evaluation techniques handle larger classes input programs additionally building sourcecode level instrumentation system sparc processor architecture investigate applicability techniques multilevel data instruction caches finally process conduct experiments larger codes j blieberger fahringer b scholz notes 1 cache miss occurs referenced data cache needs loaded main memory 2 cache hit occurs referenced data cache 3 symbolic evaluation confused symbolic execution see eg king 1976 4 variables written inside loop including loop variable called recurrence variables 5 slot consists one cache line see section 2 6 clearly approach cannot bypass undecidability 7 random replacement seems questionable realtime applications indeterministic behavior r analyzing visualizing performance memory hierachies discipline programming kluwer academic publishers computer architecture quantitative approach research interests include areas analysis algorithms data structures studied computer science tu vienna received doctoral degree readers may contact johann blieberger department computeraided automation thomas fahringer thomas fahringer received masters degree readers may contact fahringer institute software technology parallel systems bernhard scholz bernhard scholz going enrol position assistant professor computer science dept readers may contact scholz dept figure 13 technical university vienna tr ctr berhard scholz johann blieberger thomas fahringer symbolic pointer analysis detecting memory leaks acm sigplan notices v34 n11 p104113 nov 1999 thomas fahringer bernhard scholz unified symbolic evaluation framework parallelizing compilers ieee transactions parallel distributed systems v11 n11 p11051125 november 2000 johann blieberger dataflow frameworks worstcase execution time analysis realtime systems v22 n3 p183227 may 2002 b b fraguela r doallo j tourio e l zapata compiler tool predict memory hierarchy performance scientific codes parallel computing v30 n2 p225248 february 2004
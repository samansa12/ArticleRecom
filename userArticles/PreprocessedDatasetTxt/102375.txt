debugging larch shared language specifications checkability designed lsl larch shared language described two tools help perform checking discussed lp larch power principal debugging tool design development motivated primarily work lsl also uses eg reasoning circuits concurrent algorithms uses also tend use lp analyze larch interface specifications authors tried make lp lslspecific instead chosen build second tool lslc lsl checker serve frontend lp lslc checks syntax static semantics lsl specifications generates lp proof obligations claims proof obligations fall three categories consistency specification contradict theory containment specification intended consequences relative completeness set operators adequately defined extended example illustrating lp used debug lsl specifications presented b introduction proponents formal specifications argue susceptibility formal specifications machine analysis manipulation increases value reduces cost larch project 9 10 11 12 seeks support position building using tools facilitate construction formal specifications program modules sufficient specifications precise also accurately reflect specifiers intentions without accuracy precision useless misleading mistakes many sources crop specifications practical methodology relies specifications must provide means detecting correcting flaws short debugging parsing typechecking useful easy dont go far enough hand cannot prove correctness specification absolute standard judge correctness seek tools helpful detecting localizing kinds errors commonly observe larch style specification emphasizes brevity clarity rather executability usually impossible validate larch specifications testing instead larch allows specifiers make precise claims specificationsclaims true verified specification time verification cannot guarantee specification meets specifiers intent powerful debugging technique removed flaws reveals confidence accuracy specification claims allowed larch specifications undecidable general case impossible build tool automatically certify arbitrary specification however feasible build tools assist specifiers checking claims debug specifications paper describes two tools fit work lsl larch shared language lp larch prover principal debugging tool design development motivated primarily work lsl also uses example reasoning circuits concurrent algorithms 6 19 uses also intend use lp analyze larch interface specifications tried make lp lslspecific instead chosen build second tool lslc lsl checker serve frontend lp lslc checks syntax static semantics lsl specifications generates lp proof obligations claims proof obligations fall three categories consistency specification contradict theory containment specification intended consequences relative completeness set operators adequately defined section 2 provides brief introduction larch sections 3 4 describe checkable claims made lsl specifications sections 5 8 describe lp used check claims section 9 contains extended example illustrating lp used debug lsl specifications concluding section summarizes current state research plans addw indow proc v modifies v ensures v 0 addwv w c except w figure 1 sample larchclu interface specification 2 larch family specification languages larch family specification languages supports twotiered definitional approach specification 12 specification components written two languages one designed specific programming language another independent programming language former called larch interface languages latter larch shared language lsl larch interface languages used specify interfaces program components specification provides information needed use interface write programs implement critical part interface component communicates environment communication mechanisms differ programming language programming language sometimes subtle ways found easier precise communication interface specification language reflects programming language specifications written interface languages generally shorter written universal interface language also clearer programmers implement components programmers use larch interface language deals observed behavior components written particular programming language incorporates programming languagespecific notations features side effects exception handling iterators concurrency simplicity complexity depends largely upon simplicity complexity observable state state transformations programming language figure 1 contains sample interface specification clu procedure window system larch shared language specifications used provide semantics primitive terms used interface specifications specifiers limited fixed set primitive terms use lsl define specialized vocabularies suitable particular interface specifications example lsl specification would used define meaning symbols 2 addw figure 1 thereby precisely answering questions means window view visible possibly obscured means add window view may contain windows location larch approach encourages specifiers keep complexity specifications lsl tier several reasons z lsl abstractions likely reusable interface specifications linearcontainer e c trait introduces next rest asserts c generated new insert c partitioned next rest isempty nextinsert new e dd e restinsert new e dd new emptynew implies emptyc converts 2 empty figure 2 sample lsl specification z lsl simpler underlying semantics programming languages hence interface languages specifiers less likely make mistakes z easier make check claims semantic properties lsl specifications semantic properties interface specifications paper concentrates problem debugging lsl specifications 3 semantic checks larch shared language precise definition larch shared language including associated semantic checks contained 9 11 section informally describes lsl checks considering claims specifiers make sample traitslsls basic units specification trait specifies properties collection operators trait linearcontainer figure 2 example specifies properties common number abstract data types objects sort c contain elements sort e definite order types exhibiting properties include stacks queues priority queues sequences vectors trait used specifying additional generic operators data types specialized specify particular data types asserts clause associates multisorted firstorder theory trait axioms theory consist equations following quantifier forall asserts clause equations form dd true abbreviated induction scheme associated generated axiom associated partitioned example theory linearcontainer axiomatized six equations axiom schema obtained generated instantiated firstorder formula axiom obtained partitioned theories lsl traits closed logical consequence semantics lsl based firstorder logic rather initial final algebras two reasons first important able construct reason specifications incrementally treating assertions trait axioms firstorder theory ensure adding assertions even new operators trait remove facts associated theory initial final algebra interpretations sets equations monotonic sense provide less suitable semantics firstorder logic second generated partitioned constructs lsl natural interpretations firstorder logic provide greater flexibility axiomatizing traits initial final algebra interpretations semantic claims lsl claims lsl traits fall three categories consistency theory containment relative completeness consistency always required say lsl theory contain inconsistent equation true dd f alse claims two categories made specific lsl constructs implies clause adds nothing theory trait instead makes claim theory containment enables specifiers include information believe redundant either check understanding call attention something reader might otherwise miss redundant information two kinds statements like asserts clauses converts clauses describe extent specification claimed complete initial design lsl incorporated builtin notion completeness quickly concluded however requirements completeness better left specifiers discretion useful check certain aspects completeness long priority queuee q trait assumes otalorder e includes linearcontainer e q asserts forall q q e e nextinsert q e dd emptyq e else nextq e nextq else e restinsert q e dd emptyq new else nextq e insert restq e else q implies converts next rest empty 2 exempting next new restnew figure 3 lsl specification priority queue specification finished finished specifications left intentionally incomplete places lsl allows specifiers make checkable claims complete intend specifications claims usually valuable specification revised first written specifiers dont usually make erroneous claims completeness first writing specification hand editing specification frequently delete change something without realizing impact completeness converts clause linearcontainer claims trait contains enough axioms define 2 isempty exactly means define operator one delicate design issues lsl changed recent version language converts clause claims given fixed interpretations operators interpretations 2 isempty satisfy traits axioms converts clause priorityqueue figure involves subtle checking exempting clause indicates lack equations nextnew restnew intentional operators next rest claimed defined uniquely relative interpretations terms nextnew restnew section 7 describes checking entailed converts clause detail checking composed lsl specifications two mechanisms combining lsl specifications defined operations texts specifications rather theories models 3 17 mechanisms theory combined specification axiomatized union axiomatizations individual specifications operator constrained axioms traits appears trait inclusion trait assumption differ checking entail introduces asserts forall x x x x dd x implies otalorder e f f figure 4 lsl specification total orders trait priorityqueue includes linearcontainer constrains interpretations next rest insert assumes clause indicates theory also contains trait totalorder shown figure 4 use assumes rather includes entails additional checking namely assumption must discharged whenever priorityqueue incorporated another trait example checking trait natpriorityqueue trait includes priorityqueuenat natq naturalnumber involves checking assertions traits priorityqueue linearcontainer naturalnumber together imply totalordernat figure 5 summarizes checking beyond consistency lsl requires sample traits introduced section 4 proof obligations lsl specifications anlsl specification generally consists hierarchy traits include assume imply others use lsl checker lslc check syntax static semantics traits formulate proof obligations required check semantic claims traits discharge proof obligations section describes lslc extracts proof obligations next several sections describe use lp discharge proof obligations lslc cannot discharge inspection lslc extracts proof obligations specification checks cycles trait hierarchy let c transitive closure relation defined setting includes assumes let c transitive closure relation defined setting implies lslc checks following two conditions natpriorityqueue check assumption otalorder nat priorityqueue use assertions traits except totalorder priorityqueue naturalnumber check implications check use assertions priorityqueue use theories linearcontainer totalorder linearcontainer totalorder check implications check implications use local assertions use local assertions figure 5 summary required checking condition 1 c strict partial order condition 2 traits c c conditions ensure traits checked separately soundness separate checks shown induction trait hierarchy defined condition 1 must satisfied condition 2 also satisfied implications traits trait hierarchy safely used checking note c need strict partial order specifications may want assert two traits equivalent say implies implies may even case trait totalorder see figure 4 wish assert like total ordering relation extracts six sets propositions equations generated clauses partitioned clauses trait trait hierarchy follows z assertions consist propositions asserts clauses traits transitively included z assumptions consist assertions traits transitively assumed z axioms consist assertions assumptions z immediate consequences consist propositions implies clause axioms traits explicitly implies z explicit theory consists axioms propositions implies clause explicit theories traits c c explicit theory unlike theory defined section 3 finite set closed logical consequence lsl traits lslc lsl checker diagnostics obligations user lp larch prover success diagnostics figure using lslc lp check lsl traits z lemmas available checking condition 2 satisfied consist explicit theories traits c check hierarchy traits must prove axioms trait consistent must discharge following proof obligations z immediate consequences must follow axioms condition 2 satisfied sound use lemmas available performing check z converts clauses must follow explicit theory preceding proof obligation ensures explicit theory follows axioms z assumptions trait explicitly included must follow axioms lslc discharge proof obligations inspection example proposition proved occurs textually among facts available use proof times lslc must formulate commands lp initiate proof proposition sometimes lp able carry required proof automatically sometimes require user assistance figure 6 shows lslc lp used together check lsl traits consider example traits priorityqueue assumes totalorder natpri orityqueue includes priorityqueue naturalnumber naturalnumber explicitly includes implies totalorder assertions totalorder among axioms naturalnumber lslc discharge assumption required including priorityqueue natpriorityqueue hand naturalnumber simply asserts properties binary relations lslc formulate lp commands initiate proof conjecture properties imply assertions totalorder providing small set axioms trait specifier make easier check traits imply include trait assumes providing large set implications specifier make easier reason particular check traits include assume without time making harder check traits imply include trait assumes translating lsl traits lp basis proofs lp logical system section contains overview components logical system lp discusses relation components lsl trait following sections discuss components used lp discharge proof obligations associated lsl traits logical system lp consists signature given declarations equations rewrite rules operator theories induction rules deduction rules expressed multisorted fragment firstorder logic systems closely related lsl theories handled somewhat different ways axioms lp operational content well semantic content presented lp incrementally rather declarations sorts operators variables play roles lp lsl lsl operators variables must declared operators overloaded minor differences sorts must declared lp lp doesnt provide scoping variables lps syntax terms yet rich lsls plan rectify paper uses lsls term syntax throughout lslc produces lp declarations shown figure 7 introduces forall clauses trait linearcontainer equations rewrite rules like lsl lp based fragment firstorder logic equations play prominent role lps inference mechanisms work directly equations however require equations oriented rewrite rules lp uses reduce terms normal forms usually essential rewriting relation terminating term rewritten infinitely many times lp provides several mechanisms automatically orient many sets equations terminating rewriting systems example response commands declare declare sorts e c declare variables c c declare operators next rest figure 7 lp declarations produced lslc linearcontainer declare variables x declare operators e g g g assert e dd x l ix e l x dd x enter usual firstorder axioms groups lp produces rewrite rules automatically reverses second equation prevent nonterminating rewriting sequences discussion operator theories treats issue termination systems rewriting theory say propositions proved reduction normal form always subset equational theory say propositions follow logically equations rewrite rules considered equations proof mechanisms discussed section 6 compensate incompleteness results usually case systems rewriting theory include equational theory case group theory example equation e dd ie follows logically second third axioms rewriting theory three rewrite rules irreducible yet identity lp provides builtin rewrite rules simplify terms involving boolean operators j equality operator conditional operator rewrite rules sufficient prove many identities involving operators unfortunately sets rewrite rules known complete propositional calculus require exponential time space furthermore expand rather simplify propositions reduce identities serious drawbacks debugging specifications often attempt prove conjectures true none complete sets rewrite rules built lp instead lp provides proof mechanisms used overcome incompleteness rewriting system allows users add complete sets choose use lp treats equations true dd f alse x dd term containing variable x inconsistent inconsistencies used establish subgoals proofs cases contradiction arise situations indicate axioms logical system inconsistent operator theories lp provides special mechanisms handling equations x c dd c x cannot oriented terminating rewrite rules lp command assert ac c says c associative commutative logically assertion merely abbreviation two equations operationally lp uses match unify terms modulo associativity commutativity increases number theories lp reason also reduces number axioms required describe various theories number reductions necessary derive identities need certain kinds user interaction example case analysis main drawback term rewriting modulo operator theories much slower conventional term rewriting lp recognizes two nonempty operator theories associativecommutative theory commutative theory contains mechanism based usersupplied polynomial interpretations operators ordering equations contain commutative associative commutative operators terminating systems rewrite rules mechanism difficult use users rely simpler ordering methods based lpsuggested partial orderings operators simpler ordering methods guarantee termination equations contain commutative associativecommutative operators work well practice like manual ordering methods give users complete control whether equations ordered left right right left easy use striking contrast manual ordering methods yet caused difficulties producing nonterminating set rewrite rules induction rules lp uses induction rules generate subgoals proved basis induction steps proofs induction syntax induction rules lp lsl 1 users specify multiple induction rules single sort example lp commands 1 semantics induction stronger lsl lp arbitrary firstorder formulas cannot written declare sorts e declare operators set name setinduction1 assert generated fg insert set name setinduction2 assert generated fg f g use appropriate rule attempting prove equation induction example prove x x induction x using setinduction2 lsl axioms trait typically one generated sort often useful however put others traits implications deduction rules lp subsumes logical power partitioned construct lsl deduction rules lp uses deduce equations equations rewrite rules like formulas lp deduction rules may asserted axioms proved theorems partitioned trait linearcontainer expressed equation general partitioned equivalent universalexistential axiom expressed deduction rule lp example lp commands declare sorts e declare operator 2 declare variables e e x assert f orall e e 2 x dd e 2 yield x dd define deduction rule equivalent axiom set extensionality also expressed assert partitioned 2 lp lsl deduction rule enables lp deduce equations x dd x x automatically equations e 2 x dd e 2 x x deduction rules also serve improve performance lp reduce need user interaction examples deduction rules builtin splitting law declare variables p q bool cancellation law addition declare variables x x c dd x c z yield dd z lp automatically applies deduction rules equations rewrite rules whenever normalized sample proof section 7 illustrates logical power deduction rules well benefits applying automatically case induction hypotheses proof 6 proof mechanisms lp section provides brief overview proof mechanisms lp next two sections discuss used check semantic claims lsl specifications lp provides mechanisms proving theorems using forward backward inference forward inferences produce consequences logical system backward inferences produce lemmas whose proof suffice establish conjecture four methods forward inference lp z automatic normalization produces new consequences rewrite rule added system lp keeps rewrite rules equations deduction rules normal form equation rewrite rule normalizes identity discarded hypothesis deduction rule normalizes identity deduction rule replaced equations conclusions users immunize equations rewrite rules deduction rules protect automatic normalization enhance performance lp preserve particular form use proof users also deactivate rewrite rules deduction rules prevent automatically applied z automatic application deduction rules produces new consequences equations rewrite rules system normalized deduction rules also applied explicitly example immune equations z computation critical pairs knuthbendix completion procedure 13 16 produce consequences ie dd e incomplete rewriting systems three rewrite rules groups rarely complete rewriting systems reasons discussed 5 however often make selective use critical pairs discussed section 9 also use completion procedure look inconsistencies z explicit instantiation variables equations rewrite rules deduction rules also produces consequences example system contains rewrite rules b c c true b c c true instantiating deduction rule x dd true z dd true yield x z dd true x b c c z produces deduction rule whose hypotheses normalize identities thereby yielding conclusion true also six methods backward inference proving equations lp methods invoked prove command method lp generates set subgoals proved lemmas together sufficient imply conjecture methods also generates additional axioms may used prove particular subgoals z normalization rewrites conjectures conjecture normalizes identity theorem otherwise normalized conjecture becomes subgoal proved z proofs cases rewrite conjecture command prove e cases directs lp prove equation e division cases two cases 1 one subgoal prove addition 1 n lp substitutes new constants variables e form 0 creates subgoal e 0 additional hypothesis 0 true inconsistency results adding case hypothesis 0 case impossible e 0 vacuously true case analysis two primary uses conjecture theorem proof cases may circumvent lack completeness rewrite rules conjecture theorem attempted proof cases may simplify conjecture make easier understand proof succeeding z proofs induction based induction rules described section 5 z proofs contradiction provide indirect method proof inconsistency follows adding negation conjecture lps logical system conjecture theorem z proofs implications carried using simplified proof cases command prove directs lp prove subgoal 0 2 using hypothesis 0 obtained proof cases suffices implication vacuously true 0 1 false z proofs conjunctions provide way reduce expense equational term rewriting command prove directs lp prove subgoals lp allows users determine methods backward inference applied automatically order lp command set proofmethod normalization directs lp use first three named methods applies given conjecture set name totalorder declare declare variables x declare operators assert x x x dd x figure 8 file totalorder assertionslp proofs interesting conjectures hardly ever succeed first try sometimes conjecture wrong sometimes formalization incorrect incomplete sometimes proof strategy flawed detailed enough attempted proof fails use variety lp facilities example case analysis try understand problem many proof attempts fail lp designed fail relatively quickly provide useful information designed find difficult proofs automatically unlike boyermoore prover 1 perform heuristic searches proof unlike lcf 15 allow users define complicated search tactics strategic decisions try induction must supplied explicit lp commands either user frontend lslc hand lp proof checker since require proofs described minute detail many respects lp best described proof debugger 7 checking theory containment proof obligations triggered implies assumes clauses lsl trait require us check theory containment check claims follow axioms section discusses lslc formulates proof obligations theory containment lp well use lp discharge obligations next section discusses checking consistency proving equation proof obligation equation easy formulate consider example proof obligations must discharged check trait totalorder shown figure 4 figure 8 displays lp commands lslc extracts trait order axiomatize theory figure 9 displays lp commands lslc extracts order discharge execute totalorder assertions set name totalorder consequences prove implication totalorder prove x x qed prove x z qed prove x j x j x qed prove x dd x qed prove implied equation prove x x qed figure 9 file totalorder obligationslp proof obligations execute command obtains axioms totalorder file totalorder assertionslp prove commands initiate proofs five immediate consequences totalorder lp discharge proof obligations except last without user assistance user alerted need supply assistance last proof diagnostic incomplete proof printed response last qed command point user complete proof entering commands criticalpairs totalorder totalorder qed proofs equations require varying amounts assistance example checking linearcontainer implies emptyc e 2 c single lp command resume induction c suffices finish proof checking priorityqueue implies guidance required proof also proceeds induction lp proves basis subgoal without assistance induction subgoal lp introduces new constant q 0 take place universallyquantified variable q adds induction hypothesis attempts prove prove e 2 q e next q induction q resume case emptyq 0 handle case emptyq 0 criticalpairs casehyp linearcontainer handle case isemptyq 0 resume case v 0 nextc 0 handle case v 0 nextc 0 resume case e 0 v 0 handle case e 0 6d v 0 complete handle case v 0 next c 0 resume case e 0 v 0 handle case e 0 6d v 0 criticalpairs implieshyp inducthyp figure 10 guidance proof priorityqueue implication reduces lp assumes hypothesis implication introducing new constants e 0 v 0 take place variables e v attempts prove conclusion implication hypothesis point guidance required command resume case emptyq 0 directs lp divide proof two cases based boolean expression first first case emptyq 0 conclusion reduces e 0 v 0 command criticalpairs caseh yp linearcontainer leads lp deduce e 2 q 0 first implication linearcontainer available use proof linearcontainer priorityqueue trait hierarchy fact lp able finish proof first case automatically applies builtin deduction rule conclude e 2 alse uses rewrite rule another builtin deduction rule derive e hypothesis implication uses rewrite rule help simplify conclusion implication identity second case user assistance figure 10 shows entire proof script proving partitioned proving partitioned clause amounts proving validity associated deduction rule lp example lslc formulates lp proof obligations associated partitioned implies clause figure 11 execute set assertions prove partitioned lp translates partitioned deduction rule f orall z x z dd z z x dd z yield x dd deduction rule contains two hypotheses binary operator either hypothesis sufficient present way indicate lsl lp lp generates subgoal proving deduction rule introducing two new constants x 0 0 sort assuming x 0 z dd 0 z z x 0 dd z 0 additional hypotheses attempting prove subgoal x 0 dd 0 lp cannot prove x 0 dd 0 directly equation irreducible user guide proof typing command instantiate z feg whenhyp yields lemma e 2 x 0 dd e 2 0 lp automatically completes proof applying deduction rule associated assertion partitioned 2 proving generated proving generated clause involves proving set elements generated given operators contains elements sort example lslc formulates lp proof obligation associated generated implies clause figure 11 execute set assertions prove generated fg f g lp introduces new operator isgenerated adds hypotheses isgenerated fg isgenerated feg isgenerated x isgenerated isgenerated x attempts prove subgoal isgenerated x user guidance required complete proof example entering commands resume induction x complete introduces asserts generated fg insert partitioned 2 insert implies generated fg f partitioned insert e dd feg insert insert e e 0 dd insert insert e 0 e insert e fg converts f g 2 converts insert 2 figure 11 lsl trait finite sets directing lp use induction scheme obtained assertion generated fg insert run completion procedure draw necessary inferences additional hypotheses proving converts proving trait converts set operators involves showing axioms trait define operators set relative operators trait example show linearcontainer converts isempty 2 must show given interpretations fg insert unique interpretations isempty 2 satisfy assertions linearcontainer equivalently must show theory linearcontainer together theory linearcontaineris empty 0 empty 2 0 2 imply equations empty 0 c dd emptyc e 2 0 c dd e 2 c lslc formulates proof obligation lp making two copies file lin contains explicit theory linearcontainer second copy linearcontainer convertslp occurrences isempty 2 replaced empty 0 producing two files lslc formulate proof obligation following lp commands execute linearcontainer execute linearcontainer converts prove empty 0 c dd emptyc qed prove qed user guidance required prove converts clause command proceed induction c proof obligation converts clause priorityqueue similar must show given interpretations fg insert well exempted terms next new restnew unique interpretations next rest isempty 2 satisfy assertions priorityqueue lslc formulates proof obligation lp making required copy priorityqueuelp generating following lp commands execute priorityqueue execute priorityqueue converts assert next 0 new dd next new assert rest 0 new dd restnew prove next 0 q dd next 0 q qed prove rest 0 q dd restq qed prove empty 0 q dd emptyq qed prove qed user guidance required complete proofs commands proceed induction q checking consistency checks theory containment fall typical pattern use theorem prover check consistency harder formulate involves nonconsequence rather consequence still evaluating several approaches check seems probable techniques detecting check fails useful techniques certifying succeeds standard approach logic proving consistency involves interpreting theory checked another theory whose consistency assumed example peano arithmetic established previously 18 approach user assistance required define interpretation proof interpretation satisfies axioms trait checked becomes problem showing theory containment lp well suited approach cumbersome unattractive practice promising approaches based metatheorems firstorder logic used restricted classes specifications example extension definitions see 18 consistent theory consistent equational traits say traits purely equational axiomatizations relatively questions consistency translated questions critical pairs cases use lp answer questions running completion procedure computing critical pairs actions generate inconsistency axioms inconsistent complete axioms without generating equation true dd f alse trait consistent proof strategy usually succeed proving consistency many equational theories cannot completed cannot completed acceptable amount time space however proved useful debugging specifications equational nonequational traits general use lps forward inference mechanisms search presence inconsistencies specification completion procedure search inconsistencies automatically instantiate axioms focus objects sense mcallester 14 provide completion procedure basis search even though unsuccessful searches certify specification consistent increase confidence specification testing increases confidence program recently lsl allowed another kind claim also involved check nonconsequence namely claim one trait incorporated another without constraining meanings operators however none approaches certifying falsifying claims conservative extension proved practical without promising means checking inclined consider claims module independence comments rather checkable claims therefore removed lsl imports construct made claims 9 extended example illustrate approach checking specifications slightly realistic setting show one might construct check traits used specification simple windowing system 8 preliminary versions traits would likely expanded specifications including interface parts developed first three traits declare signatures basic operators coordinate trait introduces asserts forall cd coord cd cd origin assumes coordinate introduces r true point cd region r nothing assumed shape contiguity regions assumes coordinate includes regiont introduces represents appearance object point cd proof obligations associated traits easily discharged lps completion procedure run coordinate terminates without generating critical pairs since coordinate generated partitioned clauses sufficient guarantee consistent checking inclusion region displayable regions assumption coordinate discharged syntactically using displayables assumption trait next trait defines window object composed content clipping regions foreground background colors window identifier 2 qualified signature last line trait overloaded necessary say 2 converted assumes coordinate includes region displayablew asserts w tuple cont clip r fore back color id wid forall w w cd coord implies converts 2 coord three proof obligations associated trait assumptions coordinate region displayable syntactically discharged using windows assumption converts clause discharged lp without user assistance proof obligation consistency discussed previous section use completion procedure search inconsistencies running short time neither uncovers inconsistency proves consistency view trait figure 12 defines view object composed windows locations several proof obligations associated trait assumptions window displayable discharged syntactically assumption view using completion procedure search inconsistencies uncovers problems however checking converts clause turns problem conversion inw 2s easily proved induction objects sort v however inductive base case reduce emptyv cd defined problem solved either defining emptyv cd adding exempting forall cd coord emptyv cd converts clause choose latter obvious definition emptyv cd added exemption inductive proof conversion without interaction attempt prove first explicit equations implies clause view run difficulty automatically applying proof method implications lp reduces conjecture cd 0 cd 0 else view trait assumes coordinate includes introduces inw v w coord bool asserts generated emptyv addw view window offset origin implies adding new window affect appearance parts view lying outside window appearance within newly added window independent view added converts inw 2 coord figure 12 sample view specification reduces assumed hypothesis implication point ask hypothesis sufficient reduce conjecture identity problem seems order operands leads us look carefully second equation inw trait view discover written cd cd 0 written cd 0 cd consistent form equations reversed role cd cd 0 left hand side equation changing axiom proof first implication goes without interaction second conjecture lp applies proof method implications reduces cd 0 cd 0 else cd 0 cd 0 else resume proof dividing two cases based boolean expression outermost ifs expression true conjecture reduces true false conjecture reduces since v 0 variable v 0 fresh constant know going able reduce true necessarily mean proof fail since could impossible case say current hypotheses could lead contradiction however examining current hypotheses implication hypothesis gives us obvious reason believe contradiction exists leads us wonder validity conjecture trying prove ask thought true added trait informal reasoning 1 hypothesis conjecture inw addwv cd 0 w wid cd guarantees coordinate cd window w view addwv cd 2 w added place v 0 v cd must also addwv 3 furthermore cd cd 0 relative coordinate w addwv cd addwv 4 therefore equation trait view guarantee conclusion first step formalizing informal argument attempt prove lemma lp reduces conclusion implication using normalized implication hypothesis casing first disjunct hypothesis reduces conjecture false implication case hypotheses thus stuck place attempted proof original conjecture leads us question validity first step informal proof discover flaw v contains window id w implication sound problem implicitly assumed invariant view would contain two windows id specification guarantee correct problem try adding additional operator three additional axioms trait view unfortunately run lps completion procedure revised specification view quickly get inconsistency several ways around problem among 1 trait view could changed addw chooses unique id whenever window added 2 trait view could changed addw identity function id window added already associated window view 3 preservation invariant could left interface level cartesianview trait includes view naturalnumber asserts coord tuple x nat nat origin dd 0 0 implies converts origin figure 13 sample cartesian view specification third alternative consistent interface specification given section 2 one chosen causes us weaken second implication trait v iew appearance within newly added window independent view added provided window already present view proved small amount user interaction finally figure 13 introduce coordinate system lp uses facts trait naturalnumber shown automatically discharge assumption coordinate carried level level lp requires assistance complete proof coordinate operators indeed converted course expository purposes used artificially simplified example also deliberately seeded errors lp find however errors discussed occurred unintentionally wrote example notice actually attempted mechanical proofs larger specifications expect bugs frequent harder find conclusions larch shared language includes several facilities introducing checkable redundancy specifications facilities chosen expose common classes errors give specifiers better chance receiving diagnostics specifications unintended meanings much way type systems give programmers better chance receiving diagnostics erroneous programs primary goal larch provide useful feedback specifiers something wrong specification hence designed lp primarily debugging tool overly troubled detecting inconsistencies generally quicker easier certifying consistency expect discover flaws specifications attempted proofs fail lp automatically apply backwards inference techniques requires user guidance provers much guidance highly predictable eg proving hypotheses deduction rules lemmas although tempting supply lp heuristics would generate lemmas automatically feel better leave choice user many points proof many heuristics apply experience choosing next step proof example case split proof induction deciding proof attempt abandoned often depends upon knowledge application lp cannot reasonably expected possess knowledge especially searching counterexample conjecture rather attempting prove cases lslc may able use knowledge structure specifications generate guidance example using induction prove converts clause users must currently provide lp checkable redundancy lsl encourages specifications also supports regression testing specifications evolve change part specification example strengthen assertions one trait important ensure change unintended sideeffects lps facilities detecting inconsistencies help us discover totally erroneous changes claims traits specification imply assume changed trait help us discover subtle problems claims already checked lps facilities replaying proof scripts make easy recheck proofs changean important activity one likely neglected without mechanical assistance encouraged early experience using lp check lsl specifications clear work must done lslc lp nonexperts use costeffectively plan investigate lslc discharge proof obligations textually provide guidance lp discharging others plan enhance lp include many syntactic amenities present lsl provide facilities proof management fundamentally plan enhance logic lp enabling reason formulas embedded quantifiers finally plan continue improving performance lp reducing amount guidance requires particularly use reason theories include standard subtheories booleans natural numbers acknowledgments wish thank andres modet martn abadi help understanding semantics larch designing several semantic checks andres modet responsible first implementation lslc james rauen alexander esterkin second james saxe jrgen staunstrup provided helpful comments suggestions based use lp r putting theories together make specifications inductive methods reasoning abstract data types overview lp larch prover verification vlsi circuits using lp using lp debug specifications formal specification design tool report larch shared language larch shared language handbook revised report larch shared language overview larch family specification languages simple word problems universal algebras ontic knowledge representation system mathematics logic computation interactive proof cambridge lcf complete sets reductions equational theories observational equivalence algebraic specifica tion mathematical logic compositional verification vlsi circuits tr report larch shared language larch shared language handbook observational equivalence algebraic specification logic computation interactive proof cambridge lcf computational logic handbook inductive methods reasoning abstract data types ontic knowledge representation system mathematics complete sets reductions equational theories formal specification design tool localized verification circuit descriptions overview lp larch power ctr geoffrey r hird towards reuse verified ada software proceedings conference triada 90 p1421 december 0306 1990 baltimore maryland united states huiming yu albert esterline joseph monroe objectoriented formal specifications support ada 95 reuse proceedings conference triada 96 disciplined software development ada p125131 december 0307 1996 philadelphia pennsylvania united states daniel jackson aspect economical bugdetector proceedings 13th international conference software engineering p1322 may 1317 1991 austin texas united states daniel jackson craig damon elements style analyzing software design feature counterexample detector acm sigsoft software engineering notes v21 n3 p239249 may 1996 j wing using larch specify avalonc objects ieee transactions software engineering v16 n9 p10761088 september 1990 daniel jackson somesh jha craig damon faster checking software specifications eliminating isomorphs proceedings 23rd acm sigplansigact symposium principles programming languages p7990 january 2124 1996 st petersburg beach florida united states antoy j gannon using term rewriting verify software ieee transactions software engineering v20 n4 p259274 april 1994 daniel jackson craig damon elements style analyzing software design feature counterexample detector ieee transactions software engineering v22 n7 p484495 july 1996 barbara liskov history clu history programming languagesii acm press new york ny 1996 barbara liskov history clu acm sigplan notices v28 n3 p133147 march 1993
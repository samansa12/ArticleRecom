dependent types program termination verification program termination verification challenging research subject significant practical importance already rich body literature subject still undeniably difficult task design termination checker realistic programming language supports general recursion paper present approach program termination verification makes use form dependent types developed dependent ml dml demonstrating novel application dependent types establishing liveness property design type system enables programmer supply metrics verifying program termination prove every welltyped program type system terminating also provide realistic examples verified prototype implementation support effectiveness approach program termination verification well unobtrusiveness programming main contribution paper lies design approach program termination verification smoothly combines types metrics yielding type system capable guaranteeing program termination supports general form recursion including mutual recursion higherorder functions algebraic datatypes polymorphism b introduction programming notoriously errorprone conse quence great number approaches developed facilitate program error detection practice programmer often knows certain program properties must hold correct implementation therefore indication program errors actual implementation violates properties instance various type systems designed detect program errors cause violations supported type disciplines common practice programmer often knows reasons particular program terminate implemented correctly immediately implies termination checker great value detecting program errors cause nonterminating program ex partially supported nsf grant ccr0092703 ecution however termination checking realistic programming language supports general recursion often prohibitively expensive given program termination language general undecidable b termination checking often requires interactive theorem proving involved programmer c minor change program readily demand renewed effort termination checking large number changes likely made program development cycle order design termination checker practical use issues must properly addressed already rich literature termination verifica tion approaches automated termination proofs either programs term rewriting systems trss use various heuristics highly involved synthesize wellfounded orderings eg various path orderings 3 polynomial interpretation 1 etc approaches mainly developed firstorder languages work higherorder settings also found eg 7 program terminating implemented correctly cannot proven terminating often difficult programmer determine whether caused program error limitation heuristics involved therefore automated approaches likely offer little help detecting program errors cause nonterminating program execution addition automated approaches often difficulty handling realistic necessarily large programs programmer also prove program termination various interactive theorem proving systems nuprl 2 coq 4 isabelle 8 pvs 9 viable practice various successes reported however main problem practice programmer may often need spend much time proving termination program compared time spent simply implementing program addition renewed effort may required time changes likely program development cycle made program therefore programmer often feel hesitant adopt interactive theorem proving detecting program errors general programming primarily interested finding middle ground particular interested forming mechanism programming language allows programmer provide information needed establishing program termination else withtype inatjnat ij inti intj knat intk figure 1 implementation ackerman function automatically verifies provided information indeed suffices analogy would like allowing user provide induction hypotheses inductive theorem proving proving theorems provided induction hypotheses clearly challenging question information establishing program termination formalized expressed main contribution paper lies attempt address question presenting design allows programmer provide dependent types key information relatively simple clean way common practice prove termination recursive functions metrics roughly speaking attach metric wellfounded ordering recursive function verify metric always decreasing recursive function call made paper present approach uses dependent types developed dml 18 14 carry metrics proving program termination form type system metrics encoded types prove every welltyped program terminating emphasized advocating design programming language terminating programs written instead interested designing mechanism programming language programmer chooses use facilitate program termination verification manifested type system form smoothly embedded type system dml illustrate basic idea concrete example going details figure 1 implementation ackerman function given withtype clause type annotation states natural numbers j function takes argument type inti another argument type returns natural number result note refined usual integer type int infinitely many singleton types inta inta precisely type integer expressions value equal write finatjnatg universally quantifying index variables j nat sort index expressions values natural numbers also write knat intk represents sum types novelty pair hi ji type annotation indicates metric used termination checking informally explain termination checking performed case assume j two natural numbers n types inti intj respectively attach metric hi ji ack n note three recursive function calls ack body ack attach metric hi 1 1i first ack since 1 1 types inti 1 int1 respectively similarly attach metric hi 1 ki second ack k assumed natural number metric hi j 1i third ack obvious hi hi j 1i hi ji hold usual lexicographic ordering pairs natural numbers thus claim function ack terminating theorem proven paper note although simple example termination cannot proven lexicographical structural ordering semantic meaning addition subtraction needed 1 realistic examples presented section 5 involving dependent datatypes 15 mutual recursion higherorder functions polymorphism reader may read examples studying sections technical development get feel actually handled approach combining metrics dependent types dml poses number theoretical pragmatic questions briefly outline results design choices first question arises decide metrics support clearly variety metrics establishing program termination endless practice pa per consider metrics tuples index expressions sort nat use usual lexicographic ordering compare metrics main reasons decision metrics commonly used practice establish termination proofs large variety programs b constraints generated comparing metrics readily handled constraint solver already built typechecking dml programs note usual structural ordering firstorder terms obtained attaching term number constructors term readily accomplished using dependent datatype mechanism dml however currently unable capture structural ordering higherorder terms second question establishing soundness approach proving every welltyped program type system design terminating though idea mentioned example ackerman function seems intu itive task far trivial presence higherorder functions reader may take look higherorder example section 5 understand seek method readily adapted handle various common programming features added 1 implementation ackerman function involves primitive recursion thus easily proven terminating point drive particular implementation proven terminating approach including mutual recursion datatypes polymorphism etc naturally leads us reducibility method 12 form notion reducibility dependent types extended metrics novelty lies treatment general recursion formation novel knowledge constitutes main technical contribution paper third question integrating termination checking mechanism dml practice common encounter case termination function f depends termination another function g unfor tunately proven various reasons eg beyond reach adopted mechanism termination checking programmer simply unwilling spend effort proving approach designed way allows programmer provide metric case verifying termination f conditional termination g still useful detecting program errors presented work builds upon previous work use dependent types practical programming 18 14 work roots dml largely unclear priori dependent types dml used establishing program termination thus believe significant effort actually design type system combines types metrics prove type system guarantees program termination effort strengthened prototype implementation variety verified examples rest paper organized follows form language ml 0 section 2 essentially extends simply typed callbyvalue calculus form dependent types developed dml recursion extend ml ml section 3 combining metrics types prove every program ml 0 termi nating section 4 enrich ml significant programming features datatypes mutual recursion polymorphism present examples section 5 illustrating approach program termination verification applied practice mention related work conclude full paper available online 16 reader find details omitted start language ml 0 essentially extends simply typed callbyvalue calculus form dependent types general recursion syntax ml given figure 2 21 syntax fix integer domain restrict type index expres sions namely expressions used index type domain sorted domain subset sorts formed instance use nat subset sort 0g use base type indexed sequence index expressions may empty instance bool0 bool1 types boolean values false true respectively integer inti singleton type integer expressions value equal use satisfaction relation means p holds formula p defined satisfied domain integers instance satisfaction relation holds since following formula true integer domain note decidability satisfaction relation depends constraint domain integer constraint domain use satisfaction relation decidable accept nonlinear integer constraints use usual dependent function sum types respectively type form essentially equivalent use n 2 also introduce variables variables ml use x f respectively lambdaabstraction formed variable recursion via fixed point op erator must formed variable variable value variable use abstracting index variables lam abstracting variables fun forming recursive func tions note body either fun must value use hi j ei packing index expression e form expression dependent sum type open unpacking expression dependent sum type 22 static semantics write mean legally formed type omit standard rules judgments index substitutions j 7 substitutions j x 7 e j f 7 e substitution finite mapping represents empty mapping use substitution mapping index variables index expressions dom domain similar notations used substitutions variables write result applying type expression etc standard practice also types form omit simplifying presentation index constants c index expressions j c j index propositions p index sorts index variable contexts index constraints types contexts constants c true expressions e c j x values figure 2 syntax ml figure 3 typing rules ml definition omitted following rules judgments form 0 roughly means type write dom domain set variables declared given substitutions say write congruent extension index expressions types determined following rules application rules generates constraints typechecking present typing rules ml figure 3 rules obvious side conditions omit ted instance rule typeilam cannot free occurrences following lemma plays pivotal role proving subject reduction theorem ml whose standard proof available 14 lemma 21 assume derivable holds derive 23 dynamic semantics present dynamic semantics ml use evaluation contexts defined certainly possibilities purpose explore 3 evaluation contexts e write ee expression resulting replacing hole e e note replacement never result capturing free variables definition 22 redex defined redexes false reduce e 1 e 2 respectively lam x ev redex reduces ex 7 v let e fun f e redex reduces vf 7 e v redex reduces va 7 open hi j vi ha j xi e redex reduces ea 7 ix 7 v use r redex write r e r reduces e e write e 1 e 2 say reduces e 2 one step let reflexive transitive closure say reduces e 2 many steps e 1 e 2 omit standard proof following subject reduction theorem uses lemma 21 theorem 23 subject reduction assume derivable ml derivable ml 24 erasure simply transform ml language ml 0 erasing syntax related type index expressions ml 0 basically extends simply typed calculus recursion let jej erasure expression e e 1 reducing e 2 ml reducing je 2 j ml 0 therefore e terminating ml jej terminating ml 0 crucial point since evaluation program ml 0 likely done evaluation erasure ml 0 please find details issue 18 14 3 instance suggested one present dynamic semantics style natural semantics later form notion reducibility evaluation rules combine metrics dependent types ml forming language ml prove every welltyped program ml terminating main technical contribution paper 31 use usual lexicographic ordering tuples natural numbers strict part given two tuples natural numbers hi holds evi dently wellfounded stress theory difficulty supporting various wellfounded orderings natural numbers usual multiset ordering fix ordering solely easing presentation definition 31 metric let tuple index expressions index variable context say metric derivable mean metric decorated type ml 0 form following rule forming types syntax ml ml except context ml maps every variable f domain decorated type recursive function ml form fun f v process translating source program expression ml call elaboration thoroughly explained 18 14 approach program termination verification applied elaborated programs 32 dynamic static semantics dynamic semantics ml formed precisely manner ml 0 thus omit details difference ml ml lies static semantics two kinds typing judgments ml forms 0 call latter metric typing judgment give explanation suppose roughly speaking free occurrence f e f followed sequence index expressions 7 call label occurrence f less 0 suppose welltyped closed recursive function 0 sorts f f 7 holds rule typefun know labels f v less 7 label f f since labels cannot decrease forever yields basic intuition recursive functions ml terminating however intuitive argument difficult formalized directly presence highorder functions typing rules ml judgment form essentially ml except following ones present rules deriving metric typing judgments figure 4 given means 1 k satisfied 1 j k also satisfied lemma 32 following 1 assume holds derive 2 assume derivable dom derive proof 1 2 proven simultaneously structural induction derivations theorem 33 subject reduction assume derivable ml 0 e e 0 e derivable ml obviously following proposition 34 assume derivation f 0 derivation height 4 33 reducibility define notion reducibility welltyped closed expressions definition 35 reducibility suppose e closed expression type e v holds value v reducibility e defined induction complexity 4 minor technicality reason count neither rules typevar var calculating height derivation 1 base type e reducible 2 reducible reducible values v 1 type 3 reducible e reducible 4 v 1 v 1 reducible value type note reducibility defined closed expressions reduce values proposition 36 assume e closed expression type e e 0 holds e reducible e 0 reducible proof induction complexity following key notion handling recursion though natural requires technical insights definition 37 reducibility let e welltyped closed recursive function fun f closed metric e 0 reducible e reducible satisfying 7 0 definition 38 let substitution maps variables expressions every x 2 dom xreducible x reducible every f 2 dom f f reducible f f reducible sense following lemma verifies whether notion reducibility formed correctly difficulty probably lies formulation rather proof lemma 39 main lemma assume e derivable also assume xreducible every x 2 dom every f 2 derivable f f reducible e reducible proof let derivation e proceed induction height present interesting case cases found 16 assume following rule typefun last applied suppose e reducible definition exist 1 e 0 reducible e reducible satisfying words e f1 reducible derive figure 4 metric typing rules ml proposition 34 derivation 1 height 1 less induction hypothesis v note e 0 v thus e 0 reducible contradicting definition 0 therefore e reducible following main result paper corollary 310 e derivable ml ml reducible thus reduces value proof corollary follows lemma 39 extensions extend ml significant programming features mutual recursion datatypes poly morphism defining notion reducibility extension thus making clear lemma 39 still holds extension present section treatment mutual recursion currying leaving details 16 41 mutual recursion treatment mutual recursion slightly different standard one syntax typing rules handling mutual recursion given figure 5 use type expression representing n mutually recursive functions types respectively confused product types also n en must positive constant integer let v following expression funs every 1 k n vk redex reduces form metric typing judgment e f 0 verifying labels f e less 0 rules deriving judgment essentially figure 4 except lab given f f rule funs handling mutual recursion straightforward thus omitted definition 41 reducibility let e closed expression reduces v e reducible ek reducible 42 currying decorated type must far form restriction rather unpleasant consequence types j expressions e j en j funs f 1 values v j funs f 1 f f typefuns figure 5 syntax typing rules mutual recursion instance may want assign following type implementation ackerman function figure 1 finatg inti fjnatg intj int formally written decorate metric involve index variable 1 making impossible verify implementation terminating generalize form decorated types following address problem also introduce following form expression e representing recursive function require e 0 value following deal case 1 n 1 treatment similar e e 0 following typing rule following metric typing rule definition 42 reducibility let e closed recursive function closed metric e 0 reducible e 1 v reducible reducible values 1 5 practice implemented typechecker ml prototype implementation dml experimented various examples presented also address practicality issue end section 51 examples demonstrate various programming features handled practice approach program termination verification primitive recursion following implementation primitive recursion operator r godels clearly typable ml note z assigned types nat0 respectively datatype nat z0 nnat sn1 natn u r n u r n u v withtype nnat nat nnat natn type corollary 310 clear every term terminating weakly normalizing example paper proven terminating structural ordering point make though seems evident use r cannot cause nontermination trivial prove every term terminating notice proof cannot obtained peano arithmetic notion reducibility precisely invented overcoming difficulty 12 actually every term strongly normalizing obviously untrue 0 nested recursive function call program figure 6 involving nested recursive function call implements mc carthys 91 function withtype clause indicates every integer x f91x returns integer 91 x 100 informally explain metric type annotation suffices establish termination f91 inner call f91 need prove obvious outer call f91 need verify 1 max0 101 assumed clearly example handled structural ordering mutual recursion program figure 7 implements quicksort list functions qs par defined mutually recursively informally explain program typable ml 0 thus qs terminating function corollary 310 call par body qs label 0 1 length xs 0 need verify satisfied obvious two calls qs body par need verify hold since also indicates need r r metric par two calls par body par need verify hold since example handled structural ordering higherorder function program figure 8 implements function accept takes pattern p string checks whether matches p meaning pattern given comments auxiliary function acc implemented continuation passing style takes pattern p list characters cs continuation k matches prefix cs p call k rest characters note k given type allows k applied character list longer cs metric used proving termination acc hn ii n size p number constructors p excluding empty length cs notice call acc p cs 0 k last pattern matching clause label attached call length cs 0 0 since continuation type must false call hap pens therefore straightforward see labels attached calls acc less hn ii corollary 310 acc termi nating implies accept terminating assuming explode terminating every aspect nontrivial example even interactive theorem proving systems notice test lengthcs 0 body acc timeconsuming resolved using continuation accepts arguments character list length 5 elegant implementation accept processing pattern matched eliminates test runtime check also realistic cases termination depends program invariant cannot difficult captured type system dml instance following example adopted implementation bit reversing part implementation fast fourier transform fft fun loop j kj loop jk k2 else jk withtype anatbnat inta intb int obviously loop1 0 terminating however may know reason second argument loop never 0 execution leads following im plementation need check k 1 holds calling loopj k k2 guarantee k2 positive integer fun loop j else raise impossible withtype anatbpos max0 ab inta intb int readily verified loop terminating func tion example indicates insert runtime checks verify program termination sometimes approximating liveness property safety property 52 practicality two separate issues concerning practicality approach program termination verification practicality termination verification process b applicability approach realistic programs 5 note lengthcs 0 lengthcs types inti 0 inti respectively thus lengthcs type depending whether 0 equals thus inferred type system withtype figure 6 implementation mccarthys 91 function case xs x xs par cmp x xs withtype bool nnat n0 listn listn anda par cmp x l r case xs x xs cmpx x par cmp x x l r xs else par cmp x l x r xs withtype bool pnatqnatrnat pqrr1 listp listq listr listpqr1 figure 7 implementation quicksort list easy observe complexity typechecking ml basically ml since added work verify metrics provided pro decreasing requires solving extra constraints number extra constraints generated typechecking function proportional number recursive calls body function therefore likely small based experience dml thus feel typechecking ml suitable practical use applicability approach realistic pro grams use type system programming language c example illustrate design decision obviously type system c unsound unsafe type casts often needed c typing programs would otherwise possible spite practice type system c still great help capturing program errors clearly similar design allow programmer assert termination function dml cannot verified may call termination cast combining termination verification runtime checks termination cast feel approach promising put practice 6 related work amount research work related program termination simply vast section mainly mention related work work shares similarity either design technique approaches automated termination proofs either programs term rewriting systems trss use various heuristics synthesize wellfounded orderings ap proaches however often difficulty reporting comprehensible information program cannot proven ter minating following 13 also large amount work proving termination logic programs 11 reported mercury compiler perform automated termination checking realistic logic programs however address different question interested checking whether given metric suffices establish termination program synthesizing metric design essentially one adopted 10 checks whether given structural ordering possibly highorder terms decreasing inductive proof logic program clearly approaches based checking complements based synthesis approach also relates semantic labelling approach 19 designed prove termination term rewriting systems trss essential idea differentiate function calls labels show labels always decreasing function call unfolds semantic labelling approach requires constructing model trs verify whether labelling done correctly approach typechecking notion sized types introduced 6 proving correctness reactive systems type system capable guaranteeing termination welltyped programs language presented 6 designed embedded functional programming contains significant restriction supports minor variant primitive recursion cause inconvenience programming instance seems difficult implement quicksort using primitive recursion experience general recursion really major programming feature greatly complicates program termination verification also notion existential dependent types deem indispensable practical programming exist 6 compared various interactive theorem proving datatype pattern string matches empty char1 char c matches char c inatjnat plusij1 patterni patternj cs matches plusp1 p2 cs matches either p1 p2 inatjnat timesij1 patterni patternj cs matches timesp1 p2 prefix cs matches p1 rest matches p2 inat stari1 patterni cs matches starp cs matches possibly 0 copies p length computes length list length len withtype len xs withtype inat listi inti empty tuple used since length recursive case p empty k cs charc case cs c cs plusp1 p2 case k used backtracking acc p1 cs k true else acc p2 cs k timesp1 p2 acc p1 cs fn cs acc p2 cs k cs true else acc p0 cs fn cs else acc p cs withtype nnat patternn inat n char listi inat char listi bool bool explode turns string list characters withtype pattern string bool figure 8 implementation pattern matching strings systems nuprl 2 coq 4 isabelle 8 pvs 9 approach program termination weaker sense many fewer programs verified terminating automatic less obtrusive programming essentially designed mechanism program termination verification language interface used program development cycle consider main contribution paper applied designed mechanism intends facilitate program error detection leading construction robust programs 7 conclusion future work presented approach based dependent types dml allows programmer supply metrics verifying program termination proven correctness also applied approach various examples involve significant programming features general form recursion including mutual recursion higherorder functions algebraic datatypes polymorphism supporting usefulness practice program property often classified either safety property liveness property program never performs outofbounds array subscripting runtime safety property demonstrated 17 dependent types dml guarantee every welltyped program dml possesses safety property effectively facilitating runtime array bound check elimination however unclear priori whether dependent types dml also used establishing liveness properties paper formally addressed question demonstrating dependent types dml combined metrics establish program termination one significant liveness properties termination checking also useful compiler opti mization instance one decides change execution order two programs may required prove first program always terminates also seems feasible use metrics estimating time complexity programs lazy function programming information may allow compiler decide whether thunk formed future expect explore along lines research although presented many interesting examples cannot proven terminating structural orderings emphasize structural orderings often effective practice establishing program termination therefore seems fruitful study combination approach structural orderings handles simple cases either automatically synthesized manually provided structural orderings verifies difficult cases metrics supplied programmer r termination rewriting systems polynomial interpretations implementation implementing mathematics nuprl proof development system orderings term rewriting systems proving correctness reactive systems using sized types higherorder recursive path ordering generic theorem prover pvs combining specification termination reduction checking logical framework termination analysis mercury intensional interpretations functionals finite type efficient tests topdown termination logic rules dependent types practical programming dependently typed data structures dependent types program termination verifica tion eliminating array bound checking dependent types dependent types practical program ming termination term rewriting semantic la belling tr ctr kevin donnelly hongwei xi formalization strong normalization simplytyped lambdacalculus system f electronic notes theoretical computer science entcs v174 n5 p109125 june 2007 chiyan chen hongwei xi combining programming theorem proving acm sigplan notices v40 n9 september 2005 kevin donnelly hongwei xi combining higherorder abstract syntax firstorder abstract syntax ats proceedings 3rd acm sigplan workshop mechanized reasoning languages variable binding p5863 september 3030 2005 tallinn estonia amir benamram chin soon lee program termination analysis polynomial time acm transactions programming languages systems toplas v29 n1 p5es january 2007 arne john glenstrup neil jones termination analysis specializationpoint insertion offline partial evaluation acm transactions programming languages systems toplas v27 n6 p11471215 november 2005
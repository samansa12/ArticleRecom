refreshment policies web content caches web content caches often placed end users origin servers mean reduce server load network usage ultimately userperceived latency cached objects typically associated expiration times considered stale must validated remote server origin another cache sent client considerable fraction cache hits involve stale copies turned current validations current objects small message size nonetheless often induce latency comparable fullfledged cache misses thus functionality caches latencyreducing mechanism highly depends content availability also freshness propose policies caches proactively validate selected objects become stale thus allow client requests processed locally policies operate within existing protocols exploit natural properties request patterns frequency recency evaluated compared different policies using tracebased simulations b introduction caches often placed endusers origin servers mean reduce userperceived latency server load network usage see figure 1 among dierent performance objectives caches improving enduser web experience gradually becoming pronounced many organizations deploying caching servers front lans mainly way speed users web access gen erally available bandwidth endusers internet service providers isps increasing complemented short round trip times thus latency bottleneck shifting endusers cache cache origin servers viewpoint web sites content distribution networks like decreasing costs servermachines back earlier version paper appeared proceedings infocom 01 1 bone connectivity bandwidth along increasing use web commercial purposes imply server network load gradually becoming lesser issue relative enduser quality service limit trends indicate communication time local caches remote servers increasingly dominates cache servicetimes userperceived latency technologies provide tradeos tracincrease latencydecrease would become increasingly worthwhile web sites isps servicing request cache involves remote communication requested object cached case request constitutes content miss remote communication also required cache contains copy object copy stale freshness lifetime expired must validated origin server cache fresh copy prior served cached copy turns modied request constitutes content miss otherwise cached copy valid refer request freshness miss validation requests turn freshness misses typically smallsize responses due communication overhead remote servers often contribution userperceived latency comparable fulledged content misses thus cache service times improved reducing content freshness misses content hit rate measured per object per byte sometimes weighted estimated object fetching cost dictated available cache storage replacement policy used replacement policies web caches extensively studied eg 3 4 5 6 7 8 9 10 policies seem perform well least recently used lru evicts least recently requested object cache full least frequently used lfu evicts leastfrequently requested object greedydualsize accounts varying object sizes fetching costs squid 11 popular caching server software implements lru policy replacement policies however due decreasing storage cost cache hit rate already level would signicantly improve even unbounded storage made available content availability improved prefetching 12 13 prefetching content involves involved predictions induces signicant bandwidth overhead freshness hit rate cache directly addressed replacement policies captured content hit rate metric clients origin servers cache figure 1 schematic conguration cache clients origin servers expiration time object determined brought cache according attached http response headers provided origin server expired content must validated served current caching platforms validate content passively ie client request arrives cached copy object stale perform validation via conditional get request typically ifmodifiedsince ims get request means validation requests always performed online enduser waiting promote proactive refreshment cache initiates unsolicited validation requests selected content ine validations extend freshness time cached objects client requests served directly cache motivation signicant cost issue associated freshness misses direct eect userperceived latency rather eect server network load thus worth performing one oine validation order avoid one performed line formalize cost model proactive refreshment overhead cost additional validation requests origin servers balanced increase freshness hits propose evaluate refreshment policies extend freshness periods selected cached objects decision objects renew upon expiration varies policies guided natural properties request history object timetolive ttl values popularity recency previous requests refreshment policies also viewed prefetching fresh ness methodology implementation however closer replacement policies object prefetching al gorithms refreshment policies resemble common replacement policies lru lfu way objects prioritized first policies prefer renewing recently frequentlyrequested objects second implementation similar since object value determined request history object rather considering request history related objects another dierence refreshment document prefetching validations typically considerably smaller responsesizes complete doc uments due communication overhead latency gap nearly pronounced hence refreshment potentially provides considerably better tradeos bandwidth vs reduced latency compared object prefetching experimental study indicates best among refreshment policies studied eliminate half freshness misses cost 2 additional validation requests per eliminated freshness miss freshness constitute large fraction 3050 cache hits typical cache today therefore conclude one considerably improve cache performance incorporating refreshment policy overview paper proceeds follows discuss related work section 2 provide brief overview http freshness control section 3 section 4 discuss analyze log data section 5 present dierent refreshment policies section 6 describe methodology tracebased simulations simulation results performance dierent policies conclude section 7 summary future research directions 2 related work recent work addressed validation latency incurred freshness misses including transferring stale cached data cache clients browser data validity veried 14 modied portion delta computed 15 schemes however may require browser support eective limited bandwidth enduser cache modem users freshness misses eliminated via stronger cache consistency cache consistency architectures include serverdriven mechanisms clients notied server objects modied eg 16 17 clientdriven mechanisms cache validates server objects stale cached copy hybrid approaches validations initiated either server client hybrid approaches include server piggybacking validations responses requests related objects 18 19 20 used cache update freshness status content another hybrid approach leases server commits notify cache modication limited preagreed period 21 22 23 24 serverdriven mechanisms provide strong consistency eliminate freshness misses hybrid approaches provide good balance validation overhead reduced validation traf c none mechanisms however deployed even standardized implementation requires protocol enhancements software changes cache participating web servers may also require web servers maintain perclient state hence unlikely become widely deployed near future mean except proprietary coherence mechanisms deployed hosted mirrored content 2 25 require control endpoints coherence mechanism currently widely deployed supported http11 clientdriven based ttl timetolive refreshment approach utilizes mechanism considered refreshment policies similar ones proposed 26 caches domain name system dns servers resource record rr domain name system ttl value initially set authoritative server cached rr becomes stale ttl expires client queries answered much faster information available cache hence refreshment policies renew cached rrs oine increase cache hit rate decrease userperceived latency although yet supported widely deployed web caching platforms eg squid 11 proactive refreshment oered cache vendors 27 28 products allow refreshment selections congured manually administrator integrate policies based object popularity work formalizes issues policies systematically evaluates 3 freshness control provide simplied overview freshness control mechanism specied http supported compliant caches details see 29 30 11 31 32 caches compute object timetolive ttl value considered fresh beyond becomes stale request arrives stale object cache must validate serving communication either entity fresh copy another cache origin server cachability ttl computation performed using directives values found objects http response headers cache receives client request object acts follows object cached fresh request constitutes content freshness hit chit fhit respec tively cached copy immediately returned client object cached stale cache issues conditional http get request origin server another appropriatelyselected cache conditional get uses entity tag cached copy http11 etag value provided response issues ifmodifiedsince request lastmodified response header value indicating last modication time object source response notmodified request constitutes content hit chit freshness miss fmiss object modied request content miss cmissr item found cache fetched origin another cache request constitutes content miss cmissd request arrives client nocache header cache forwards origin server cache must forward request even fresh copy cache uses response replace refresh older copy object refer requests nocache requests ttl calculation cachable object specied http11 compares age object freshness lifetime age smaller freshness lifetime object considered fresh otherwise considered stale ttl freshness lifetime minus age zero negative age object dierence current time according caches clock timestamp specied objects date response header supposed indicate response generated origin age header present age taken maximum implied age header freshness lifetime calculation proceeds follows first maxage directive present value taken freshness lifetime otherwise expires header indicating absolute expiration time present freshness lifetime dierence time specied expires header time specied date header zero dierence negative thus ttl dierence value expires header current time specied caches clock otherwise explicit freshness lifetime provided origin server heuristic used freshness lifetime assigned fraction http11 mentions 10 example time dierence timestamp date header time specied lastmodified header subject maximum allowed value usually 24 hours since http11 requires cache must attach warning heuristic expiration used objects age exceeds 24 hours concluding overview point two qualitative issues actual use freshness control relation refreshment approach 33 analyze distribution dierent freshness control mechanisms objects traces used shows large majority cachable objects explicit directives objects heuristic calculation used determine freshness lifetime thus tradeos freshness coherence controlled tuning parameter values url lters 31 refreshment policies applied top heuristic take given attempt reduce freshness misses without compromising coherence another important issue suggested recent studies cache control directives response header timestamp values often set carefully ac curately practices may skew freshness calculations away original intent 32 34 33 issue also orthogonal approach since policies like caches take settings face value 4 used two 6 days nlanr cache traces 35 collected uc sd caches january 20th till january 25th 2000 nlanr caches run squid 11 logs labels request several attributes request time service time cache action taken response code returned client response size data analysis considered http get requests 200 304 response codes ok notmodified returned client classied requests fhit fmiss cmissr cmissd nocache using squid logging labels follows content hits fhit freshness hit cache fresh cached copy squid labels tcp hit tcp mem hit fmiss freshness miss cache stale cached copy validated squid label tcp refresh hit content misses cmissr cache stale cached copy issued ims request got new copy modied response squid label tcp refresh miss cmissd cached copy object squid label tcp miss nocache request arrived nocache request header squid label tcp client refresh miss table figure 2 shows fraction requests type requests classied fmisses cmisses nocache involve communication origin server another cache freshness misses targeted refreshment policies constitute 13 uc 19 sd requests moreover evident freshness misses constitute 31 uc 43 sd content hits requests classied fmisses fhits nlanr caches directed validation requests fmisses cmissesr origin server 100 uc cache 993 sd cache also apparent vast majority 90 uc 95 sd validation requests return notmodified classied fmisses nlanr traces also recorded service time request time http request received last byte response written clients socket note usually one round trip time rtt less clients viewpoint figure 3 plots cumulative distribution function cdf service time requests broken cache ac tion gap freshness misses freshness hits indicates potential benet terms latency eliminating fmisses gap freshness misses content misses part due additional time required transfer largersize response another explaining factor content misses exhibit less locality reference sense elapsed time since preceding request server likely longer decreased locality implies longer dns resolutions servers hostname since required dns records less likely cached longer response time http request since origin server likely cold respect cache 1 similar service time distribution nocache freshness misses suggests nocache requests made popular cached content figure 4 plots cdf service times freshness misses freshness hits broken response code cache returned client http response code 200 indicates content returned whereas response code 304 notmodified indicates client issued ims get request copy validated cache responses code 304 typically smallersize responses code 200 see freshness hits 304 response client minimal service time whereas freshness hits 200 responses ect rtts study 36 indicates rst http request server time period likely take longer subsequent ones cache clients additional processing gap freshness misses 200 304 responses also similar ects additional communication cache clients due larger transmitted response size 5 refreshment policies refreshment policies associate every cached object renewal credit nonnegative integer cached copy expire according respective ttl interval nonzero renewal credit renewal request sent respective authoritative server renewal credit decremented association renewal credits objects governed particular policy policies consider may increment renewal credit upon client request renewal scheduling implemented via priority queue grouping together objects closetogether expiration possibly eventtriggered process discuss two types renewal requests 1 conditional fetch cache noties server last modication times entity tags cached ver sions object requests either validation current version new valid version supported http10 ifmodifiedsince get request 2 pure validation request test whether cached version object valid without requesting valid copy longer valid http10 performed issuing ifmodifiedsince head request http11 provides additional mechanisms eg range requests policies use pure validation requests stop renewing copy invalidated even renewal credit positive pure validation renewals generally use less bandwidth conditional fetches since object modied object header transmitted hand conditional fetches result fresh cached copy even object modied thus policies perform pure validation renewals target freshness misses whereas policies allow conditional fetches also address content misses cmissesr smallsize objects single packet however overhead pure validations similar conditional fetches conditional fetches would eective ultimately type renewal request determined policy perrequest perobject basis according previous content length modication patterns data analysis section 4 shows small fraction 510 ims requests result invalidations content transmission suggests additional overhead performing conditional fetches pure validations typically amortized 10 renewals therefore moderate size objects total bandwidth usage similar choices renewal actions sake simplicity evaluated policies pure validation renewals since likelihood modication low pure validation renewals capture trace total req 200304 req fhits fmisses cmissesd cmissesr nocache uc 75m 63m 23 10 56 1 10 sd 56m 44m 19 15 56 3 7 figure 2 classication requests uc sd traces01030507090 500 1000 1500 2000 2500 3000 3500 4000 fraction x milliseconds uc cdf request service times fhits nocache cmissesr cmissesd01030507090 500 1000 1500 2000 2500 3000 3500 4000 fraction x milliseconds sd cdf request service times fhits nocache cmissesr cmissesd figure 3 cdf service times broken cache action potential refreshments provide good indication full potential believe however incorporation conditional fetches policies deserves study another design issue may require explaining chose consider predictive policies renew prefetch longexpired objects predictive renewals document prefetching typically eective activity traced peruser basis future requests predicted according current requests made user related objects refreshment approach diers predictiverenewal consider aggregate behavior across users object policies use minimal bookkeeping simple implementation require web server support ultimately may eective refreshment policies coexist predictive renewals content prefetching believe basic dierences techniques call separate initial evaluations one last important point would like make explicit policies designed evaluated caches forward requests origin servers exam ple toplevel caches hierarchy caches attached hierarchy directing renewal requests authoritative source assures maximum freshness time response caches congured forward requests parent cache may also benet deploying refreshment policy potential gain however limited since renewals would often obtain aged responses ie objects already cached time period higher level cache studied age eects performance cascaded caches 37 38 proceed describing dierent policies illustrated example provided figure 5 next section evaluate compare performance using tracebased simulations policies passive passive validation objects validated result freshness miss ie request arrives stale cached copy way caches work today opti approximation optimal omniscient oine policy 2 policy assumes knowledge time subsequent request object whether object copy would still valid subsequent request current copy remains valid issued within c freshnesslifetime durations expiration current copy renewal credit set c otherwise renewals performed recencyk renewal credit reset k following request object including nocache requests recencyk similarly cache replacement policy lru exploits recency property request se quences states future requests likely issued recentlyrequested objects recency k variant recencyk resets renewal credit k following request object except nocache requests increment renewal credit j request would freshness miss passive words add j renewal credit specify optimal oine algorithm 26 fraction x milliseconds uc cdf request service times 304 fhits 200 fhits 200 fmisses01030507090 500 1000 1500 2000 2500 3000 3500 4000 fraction x milliseconds sd cdf request service times 304 fhits 200 fhits 200 fmisses figure 4 cdf service times contenthits broken response code client recency2 time request nocache request refresh miss hit m250167180overhead passive figure 5 behavior dierent refreshment policies example sequence 9 requests time line units freshnesslifetime durations policies incur least two misses rst request coldstart miss 8th request nocache request header always miss gure also summarizes number misses renewals performed policy passive example incurs 7 misses performs renewals thfreq05 incurs 2 misses performs 13 renewals policy opt1 ecient following sense performs least renewals among policies incur 4 misses eg recency1 freq1 0 example illustrates coverage fraction misses eliminated policies recencyi freqi increases overhead number extra requests per eliminated miss however typically always increases well example recency1 eliminates 3 misses respect passive performs 8 renewals thus issues 84 renewals misses passive overhead 53 167 similarly recency2 eliminates 4 misses issuing 3 passive thus overhead upon request issued freshness lifetimeduration units time previous request caused passive policy contact origin server addition upon request except nocache requests renewal credit set less policy freqj purely exploits frequency property states objects frequently requested past likely requested soon replacement policy exploits frequency property lfu policy freqj hybrid freqj recencym thfreqth keep renewing objects ratio wouldhave passive freshness misses number freshnesslifetimedurations since beginning log drops threshold words upon request would freshness miss passive increment renewal credit would keep renewing ratio drops threshold addition upon request except nocache requests renewal credit increased less policy exploits frequency property normalizes freshness lifetimeduration also naturally provides continuous range tradeos since th necessarily integer policy purely frequencybased whereas higher values correspond hybrids recencym policy 6 experimental evaluation conducted tracebased simulations order evaluate cache performance dierent refreshment policies outline methodology proceed present discuss simulation results 61 methodology traces included cache action taken request currentlyimplemented passive refreshment order simulate policies however obtain response header values ttl values requested objects unfortunately data available recorded trace therefore separately issued get requests urls trace shortly downloading processed response headers extracted cache directives values relevant header elds cachable objects objects without nocache directive response header applied squid object freshness model 11 http11 compliant described section 3 calculate ttls using values extracted explicit freshness lifetime duration provided expires maxage header applied squids heuristic used 10 time dierence time specied date header time specied lastmodified header subject maximum value one day issued single get sample objects repeated ttl calculation found cache control directives freshnesslifetime values change frequently indicated estimates ected reasonably well values would obtained origin server time requests logged ran simulations using original sequence requests extracted ttl values put policies equal ground eliminate eect boundary conditions also simulated passive performance gures provided later correspond simulated passive rather one ected original labels given section 4 rst discarded requests labeled http get simulation applied requests urls obtained 200 ok response separatelyissued requests note 302 responses http redirect cachable hence requests urls obtained response discarded simulation utilized logged information following way logged requests considered url used along request time determine status object simulated cache resulting cache actions ii original cacheaction label used identify requests arrived nocache header simulation accounted requests resetting ttl freshnesslifetime duration even fresh copy present simulated cache iii original labels also used heuristic estimated points objects modied modication heuristic considered various recorded labels requests clearly successful request classied labels trace cmissr ie labeled tcp refresh miss trace see section contents changed requests labeled cmissesd explicit indication whether content changed used heuristic based logged size response client order simulate performance refreshment policies also estimate point interval requests modication actually occurred since refreshment policies stop refreshing server invalidates object simulation assumed modication occurred two consecutive requests therefore incur content miss later happened midpoint time interval two requests modications happened likely rst one occurred earlier interval hence assumption means unproductive renewals occur simulation reality thus simulated policies would exhibit somewhat worse tradeos since majority validations return notmodied however assumption could signicant eect results since could issue get requests urls present trace reasonable time without adversely aect ing environment selected subset scaled results factor sampling applied nonuniform sampling denser samples frequently requested urls particular included urls requested 12 times total fetched 224k distinct urls reason nonuniform sampling zipflow relation requests urls many requests issued small set popular urls original logs 5 million dierent urls requested thus samesize sample obtained uniform sampling urls would yielded lowercondence estimates nonuniform sample used sampling bias factored scaling frequency group individually simulations assumed innite cache storage capacity consistent current industry trends actual traces used since objects requested twice 6 day period likely discarded replacement policy used squid performance metric used simulations counted requests constituted content hits content hits occurred freshnesslifetime duration past previous simulated server contact counted freshness misses requests occurring within duration counted freshness hits content hits exclude requests explicit noncachable objects requests nocache request headers requests content changed since information requests classify rst request object appropriate requests objects freshnesslifetimeduration 0 counted content hits considered freshness misses note renewals performed objects hence number freshness misses incurred objects reduced refreshment policies 62 simulation results simulated baseline policy passive objects refreshed result client requests 48 content hits constituted freshness misses uc trace 53 freshness misses sd trace recall respective numbers according labels recorded trace provided section 4 31 43 gap mainly due simulating shorter trace dierent boundary conditions conservative heuristic used identify content hits factors aect policies similar manner order put passive equal grounds policies chose simulate rather using labels trace evaluated performance dierent refreshment policies tradeo overhead vs coverage coverage reduction freshnessmisses calculated fraction number freshness misses according passive eliminated respective policy precisely x denotes number freshness misses passive number freshness misses policy p coverage p fraction x yx calculated overhead policy p dierence number validation requests issued p number validation requests issued passive recall cache issues validation request freshness miss hence request overhead total number renewals performed minus number freshness misses eliminated converted freshness hits normalize overhead dividing total number freshness misses converted freshness hits obtain coverageoverhead tradeo type policy swept value respective parameter example points curve recency correspond runs recency1 recency2 points freq obtained runs freq1 note opt0 recency0 recency 0 fact passive 3 tradeos shown figure 6 performance recency recency policies almost identical hence omitted recency curve similarity shows requests without nocache header likely follow request nocache header one without nocache header types policies coverage peaks 63 67 remaining 3337 freshness misses mostly occur objects freshnesslifetimeduration 0 refreshment eective opt policies eliminates addressable freshness misses overhead 13 requests per miss eliminates bulk misses overhead 05 numbers bound potential refreshment policies also indicate performance loss restriction refreshment frame work 4 simulation results opt recency show locality eect freshness misses eliminated occur within small number freshnesslifetime durations previous request leftmost point curves recency opt correspond recency1 opt1 show 30 freshness misses occur within one freshnesslifetimeduration expiration cached copy second points left correspond recency2 opt2 indicate additional 15 freshness misses occur one two freshnesslifetime durations passed expiration note observed fact small number freshness occur 10 freshnesslifetimedurations passed expiration due locality also ects interaction log duration 6 days common freshnesslifetimeduration 24 hours 33 fact coverage recency frequencybased policies peaks place indicates small fraction freshness misses incurred infrequently requested objects since frequencybased policies perform renewals rst request thus eliminate misses incurred second quest correspondence peak coverage opt policytypes due threshold phenomenon freshness misses occur objects freshness lifetimeduration 0 occur within small number freshnesslifetimedurations following previous request frequencybased policies freqj 0 thfreqth signicantly outperformed recencyk ects fact vast majority freshness misses eliminated occur popular urls gap caused large number cachable urls 3 remark policies able achieve contin uous tradeos mixing two consecutive integral values respective parameter example applying recency1 urls recency2 others 4 recall refreshment framework objects must kept fresh continuously till following hit optimal unrestricted policy validates objects requested incurs overhead requestoverhead per eliminated fmiss fraction fmisses eliminated uc trace performance refreshment policies opt recency requestoverhead per eliminated fmiss fraction fmisses eliminated sd trace performance refreshment policies opt recency figure performance dierent refreshment policies simulated uc sd traces requested recencyk policy performed k unproductive renewals 5 request hybrid policies freq thfreq 0 performed considerably worse pure frequencybased policies correspond hence results shown behavior surprising given recency yielded much worse tradeos overall results indicate frequencybased object prioritization eective recencybased prioritization domination frequencybased policies also consistent studies cache replacement policies web contents 8 7 since dierent urls tend wide range characteristic popularities property captured better frequencybased policies interesting contrast results related study refreshment policies performed dns records contrast nd ings dns caches recency frequencybased policies exhibited similar performance 26 explanation hostname level signicantly smaller fraction objects resolved performance freq thfreq similar although thfreq normalizes frequency freshnesslifetime duration performed somewhat better similarity mostly explained fact large majority freshness lifetimedurations length one day also shorter durations frequency requests correlated duration policy thfreq provides spectrum tradeos better performance particularly lowoverhead range thfreq however may require bookkeeping freq particular tradeos obtained frequencybased policies shows signi cant improvements obtained fairly low overhead 10 freshness misses eliminated overhead half validation request per eliminated freshness miss 25 freshness misses eliminated overhead single request per eliminated miss 50 eliminated overhead two 65 freshness misses eliminated overhead three 5 could less k since perform renewals passed termination time log 7 conclusion large fraction 3050 cache hits constitute freshness misses cached copy fresh turned valid communication origin server validations performed prior sending responses users signicantly extend cache service time fore freshness misses impede cache ability speedup web access emerging challenge web content caches reduce number freshness misses proactively maintaining fresher content seems cache vendors already implemented adhoc refreshment mechanisms proposed refreshment policies relatively lowoverhead systematic solution refreshment policies extend freshness lifetime selectively validating cached objects upon expiration since cache freshness increased requested objects likely fresh thereby serviced faster demonstrated good refreshment policy eliminate 25 freshness misses overhead single validation requests per eliminated miss two oine validation requests replace one online request future work propose ways reduce renewal overhead rst propose renewals objects located host batched together thus decrease overhead sharing persistent connection batching natural colocated objects often share cachecontrol mechanism subsets objects embedded page related pages often requested together second proposal perform renewals opeak hours common freshness lifetime duration 24 hours provides sucient scheduling exibility eg performing renewals due 10am est signicantly lessbusy time 7am est next step evaluation eectiveness refreshment policy hope incorporate one policy popular caching server software squid results indicate integration refreshment would impose signicant computational overhead would boost performance terms userperceived latency acknowledgment experiments would possible without collection timely availability nlanr cache traces thank duane wessels answering questions regard squid logging bug 8 r tr scale performance distributed file system leases efficient faulttolerant mechanism distributed file cache consistency web cache coherence removal policies network caches worldwide web documents improving endtoend performance web using server volumes proxy filters exploiting regularities web traffic patterns cache replacement online file caching aging cascaded caches volume leases consistency largescale systems imagebased rendering controllable illumination evaluating serverassisted cache replacement web proactive caching dns records applicationlevel document caching internet maintaining strong cache consistency worldwide web ctr edith cohen haim kaplan proactive caching dns records addressing performance bottleneck computer networks international journal computer telecommunications networking v41 n6 p707726 22 april timo koskela jukka heikkonen kimmo kaski web cache optimization nonlinear model using object features computer networks international journal computer telecommunications networking v43 n6 p805817 20 december
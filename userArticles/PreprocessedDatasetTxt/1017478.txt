plugging haskell extension languages enable users expand functionality application without touching source code commonly languages dynamically typed languages lisp python domainspecific languages support runtime plugins via dynamic loading components show haskell comfortably used statically typed extension language haskell foreignlanguage applications supported haskell ffi perform typesafe dynamic loading plugins using dynamic types moreover discuss plugin support especially useful applications haskell used embedded domainspecific language edsl explain realise typesafe plugins using dynamic types runtime compilation dynamic linking exploiting infrastructure provided glasgow haskell compiler demonstrate practicability approach several applications serve running examples b introduction success applications emacs command shells web browsers microsoft word excel gimp significant degree due providing users extension language extension languagewhether general purpose eg emacss lisp permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit commercial advantage copies bear notice full citation first page copy otherwise republish post servers redistribute lists requires prior specific permission andor fee september 22 2004 snowbird utah usa application specific eg word macrosenables users add new functionality application without understanding recompiling source code indeed extension languages advocated alternative writing application single language 25 convenient applications notably emacs 32 consist small core almost higherlevel functionality implemented extension lan guage code components written extension language usually loaded runtime application extended dynamically components often called plugins paper discuss use haskell typed extension language outline approach dynamic loading haskell plugins based dynamic types 1 2 4 22 37 illustrate broad scope applications haskell plugins argue plugins viewed step development embedded domainspecific languages edslsthat domainspecific languages dsls embedded host language haskell instead implemented scratch particular dsl used extension language implementation dsl edsl gets plugin support free using framework discussed paper implemented library called hsplugins capable dynamically compiling loading haskell code running ap plications address space utilising object loading capabilities glasgow haskell compilers runtime system 30 33 functions provided plugin transparently available application appearing standard haskell values addition plugin library tracks module dependencies enables manipulation plugin source abstract syntax supports different levels trust application plugin authors respect type safety plugins applications written foreign languages may use plugin librarys c language bindings enables application interface c easily support haskell extension language summary main contributions following describe architecture typesafe plugins haskell using dynamic typing integrate extensions languages edsls introduce haskell plugins foreign languages lightweight parsers userfriendly edsls paper consists two main parts first sections 2 3 4 illustrate usefulness haskell plugins increasingly challenging application scenarios second sections 5 6 7 discuss principles behind implementation plugins haskell plugins haskell convenient way extending application dynamically way plugins ie software components application loads links already running plugins present two distinct chal lenges 1 interface communication protocol host application plugins must defined 2 plug ins object code needs integrated running application dynamic link loader remainder section outline architecture addresses challenges case haskell program extended plugins also written haskell running simple example 21 defining interface many extension languages eg lisp python lack strong static typing plugin interface characterised two sets symbol names plugin access host application host application expects defined plugin moreover informal agreement data structures passed host application plugin haskell need ensure host application plugin agree types data structures functions share moreover want application ensure violation types either side detected reported system defer details guarantee type safety section 5 closer look specification interfaces avoid arbitrary dependencies plugin code application inter nals application programmer defines plugin interfaces extra modules collect interface functions data structure called interface example merely contains single string processing function named stringprocessor complex plugin might module stringprocapi interface plugin data interface interface stringprocessor string string plugin interface addition defining interface signature api module provides default implementation named plugin default implementations provide sensible values absence dynamically loaded plugins useful many contexts providing default runtime behaviours user may optionally override via plugins 22 implementing interface compile application stringprocapi plugin must also import implement interface type declared module additionally application expects plugin bind implementation interface specific identifier named resource example following plugin implementation define stringprocessor function reverse input string wrap plugins resource interface module stringprocplugin resource import stringprocapi plugin src api make load object value passed haskell value application figure 1 compiling loading plugins 23 using plugin discuss plugin used application generally three steps involved 1 compilation plugins source code 2 loading plugins resolving symbols 3 calling plugins functions plugins may compiled plugin author host ap plication choice influences amount trust application put type safety plugin see section 5 simple application using stringprocplugin might read strings user line line output result applying stringprocessor strings example let us assume plugin source compiled function named make resulting plugin object code loaded function named load application could use plugin follows obj make stringprocpluginhs mod rsrc load obj resource code fragment first compiles plugin source using make yielding location object file obj loads object obtains handle plugin symbol named resource precisely obtains handle mod haskell module contained obj well value bound resource module call rsrc note functions take extra parameters use details concerning signatures functions plugin library appendix process object code generation loading illustrated figure 1 two functions make load invoke two different subsystems plugin infrastructure called compilation manager dynamic loader respectively compilation manager checks whether plugin source needs recompiling calls haskell compiler appropriate flags dynamic loader brings plugins object code applications address space loads necessary dependencies resolves symbols returns value exported plugin normal haskell value use host application discuss subsystems detail sections 6 7 stringprocessor rsrc simply applied string eg stringprocessor rsrc hello world rsrc type stringprocapiinterface application free load plugins time startup may even reload plugins change program execution exam ple might allow string processor change one line user input next following function applies plugins stringprocessor function user input reloading plugin thus giving different behaviour source code changed loop mod rsrc str getline reload mod resource else return rsrc putstrln stringprocessor rsrc str loop mod rsrc session application change plugin source execution may look like following verbose messages included clarity compiling stringprocplugin done loading package base linking done loading object stringprocapi stringprocplugin done 4321hgfedcba change reverse chartoupper plugin source compiling stringprocplugin done reloading object stringprocplugin done first string reversed whereas second converted upper case 3 beyond plugins ability load reload plugins execution program enables applications go beyond standard idea programs extended plugins example programs loading plugins generated runtime program illustrate idea example interactive haskell shell 31 haskell evaluator using dynamically reloadable plugins present application named plugs plugin users ghci system interactive haskell shell reminiscent hi hmake interactive 35 ghci user enters strings haskell expressions prompt plugs immediately evaluates prints screen achieves dumping expression together wrapper plugin module compiled loaded executed un loaded process closer hmake interactive ghci code compiled interpreted example session displayed listing 1 system works follows together import declarations corresponding inscope modules dumps user input haskell source file constituting plugin example user types sort 738642019 plugin essentially contains module usercodeplugin resource import usercodeapi plugin import datalist show sort 738642019 type help loading package base linking done case 7 8 x x listing 1 haskell interpreter plugs example session actually generated plugin slightly complex contains line number hints source code enable compilation manager produce informative error messages case malformed user input system proceeds compile load execute plugin using make load functions plugin library entire system 70 lines haskell core plugs lines long source writeout userstring objerr make source null err mapm putstrln err else mv load obj symbol v exceptionevaluate code v putstrln v writeout function generates plugin user input exceptionevaluate part ghcs exception library handles runtime exceptions benefit using dynamically loaded plugins implement plugs clear reuse existing haskell compiler runtime system add interactive haskell environment application requiring lines code compared hmake inter active plugs omits linking phase leads significantly faster turnaround times factor two moreover small step plugs embeddable haskell engine provides application haskell scripting capabilities plugs simple haskell environment doesnt provide full feature set example ghci however reason features cannot added plugs desired simplicity also virtue plugs easy modify extend example recently embedded modified version plugs irc bot providing haskell interpreter irc userswhich would far difficult task ghci 32 plugging haskell c objectivec since haskell standardised foreign function interface 3 use plugin infrastructure language supported ffi includes directly supported languages c also languages interoperate c c objectivec use plugin functions make load c function parameters results must marshaled languages anything convenient haskell extension languages python tcl lua haskell ffi emphasises data marshalling haskell side results less marshalling code written c host application marshalling common data types c char haskell even performed automatically plugin infras tructure described section 63 addition complemented basic make load api foreign functions enable host application c communicate haskell plugins symbolic level example plugin library implements hs eval function resembling scripting languages eval operator evaluates haskell expression stored c string io monad similar code generation strategy used plugs previous subsection c string used dynamically generate plugin loaded back application resulting haskell value returned caller variants hs eval provided basic haskell types allowing plugin result type checked us age present c program loads haskell plugin evaluate fold include stdioh include runhaskellh int mainint argc char argv int p printfdn p executed c program calls haskell runtime system arranges haskell plugin library compile load execute c string passed hs eval returning pointer integer result caller dynamic typing haskell side checks compiled haskell value matches type expected c program yielding error indicated null pointer c program expects wrong type haskell string language haskell binding possibly going via common interface c take advantage plugins dynamically load haskell code runtime example consider objectivec program evaluates expressions entered user gui implemented objectivec expression evaluator haskell source plugin user choose alter running application figure 2 shows screenshot application running arithmetic expression evaluator plugin left side keyvalue parser plugin right side entire application plugin code combined 100 lines 4 extension languages edsls plugins extend host application predefined points extension frameworks call hooks case symbols base application loads plugin hooks redefined extension code written haskell independent whether base application written haskell another language using haskell plugins via ffi extension languages generally simplify application extension virtue two properties 1 extensions well defined places based well defined api conceptually simpler arbitrary additions ap figure 2 using haskell plugins parse expressions application plication source also robust respect changes application base 2 extension languages often higherlevel language application base implemented eg lisp emacs whose core written c variant second property extension language general purpose language domain specific one tailored application domain simplify complexity extensions level implemented nonprogrammers recent work demonstrated haskell excellent host language embedding domain specific languages dsls implementing domain specific languages library generalpurpose host language saves overhead implementing new language ground 6 10 16 17 24 29 36 domain specific languages implemented fashion called embedded domain specific languages edsls context haskell used extension language seems particularly desirable provide plugin authors domainspecific notation words haskell plugins make edsls applicable turn makes haskell especially attractive extension language 41 typed application configuration files first simple example applicationspecific edsl consider textual application configuration files commonly called resource rc files unixlike systems egbashrc vimrc muttrc application becomes complex language features added configuration files usually adhoc manner result application configurable dsl typically lacks type safety expressiveness coherent syntax haskell plugins allow much principled approach demonstrate example simple typed edsl configuring mail user agent first application describes parameters available user configuration along interface instance default values module mailconfigapi data interface interface editor io string attribution string string headercolor color colorize string includesource bool data black cyan yellow magenta mail interface attribution structure clearly follows plugin api modules considered since configuration api written application programmer usual complexity however configuration files implemented normal users may programming background hence imperative avoid clutter possible help goal plugin framework offers merge facility combines two haskell source files plugins partitioned configuration information provided application user applicationsupplied stub file extra syntax containing module name export list import declarations users configuration file stub merged together compilation manager create actual plugin source mail configuration example stub may module mailconfig resource import mailconfigapi resource interface users configuration file might import systemdirectory attribution doesfileexist usrbinemacs return b emacs else vi compilation manager merges configuration file stub declarations configuration file replace name stub example two useful effects 1 configuration file empty default configuration 2 type signature stub file used ensure resource right type context userfriendly edsls problem achieve clear error messages arises standard problem edsls claim found new solution however application inspect modify error messages due make invocation forwarding user exact merging process type checking make described detail section 7 overall configuration file compiled loaded application startup enabling userdefined behaviour based values plugins resource data structure example shows application author reuse language infrastructure ap plications configuration system without resort adhoc language implementation gains additional features type checking often omitted dsls 42 pantheon pantheon 29 implementation elliotts language pan continuous imageanimation synthesis 10 11 consists library implementing edsl pan client capable displaying images animations inbetween library client effect plugins using edsl describe images animations client displays pan edsl models images functions continuous cartesian coordinates colours animations modelled functions continuous time images interactive effects defined using user interface monad ui enables user attach gui widgets radio boxes sliders variables affect appearance effect eg circles radius amount stretch image horizontally simple example consider following plugin whose effect declaration implements blue circle white background whose radius adjusted slider widget circle frac imagec circle circlereg frac image bool circlereg r effect ui animc liftm circleanim v getting details pan circlereg creates black white image region covered circle radius r function circle turns blue white image circleanim makes radius variable timeresulting animation animation hooked slider effect pantheon client expects type ui animc pantheon configuration example previous sub section error messages plugin compilation provided user remaining challenge making clear edsl user pantheon benefits enormously plugins library beginning one design goals effects described interactive although goal satisfied part ui monad ability users interactively view effects make minor alterations load new versions within single runtime session much convenient forcing recompile pantheon client every time effect changed addition multiple effects open displaying simultane ously implemented multiple plugins 43 lightweight parsers primary attractiveness edsls lies reuse host languages featureshowever one pays price inheritance haskell facilities syntactic control precedence fixity controlled degree perfect mix fix syntax cannot defined example could one define notation without form preprocessing specified extensions haskells syntax despite fact merely syntactic sugar additionally possible redefine syntax even though may desirable dsl context one attractive features dsls easier nonprogrammers use target audience already familiarity notation domain ensuring syntax matches domain merely convenient crucial success language providing dsl semantically embedded haskell plugin architecture runtime compilation provides solution lightweight parser written perform dsltohaskell syntax transformation parser called host application transform dsl code suitable compilation make resulting haskell plugin compiled dynamically loaded application words lightweight parser essentially preprocessor edsl code vanilla haskell also produce syntax errors form easy understand end user opposed haskell centric error messages make produces situation errors relating static semantics comprehensive error checking lightweight parser make parser significantly less lightweight although beneficial usability defining syntax dsl purely frontend existing compiler infrastructure away compiler modules normally needed writing dsl abstract syntax definitions name supplies symbol table utilities compiler infrastructure cheaply available using plugins one could also plug dsl parsers different syntax could provided different parser plugins users could choose whichever syntax prefer write clearly context extension languages pluginbased architecture affords extra flexibility edsls makes even attractive implementation technique 5 type safety operating systems dynamic loader eg dlopen unix loadlibrary windows inherently unsafe find value function loaded object dynamic loader searches symbol name returns reference value associated symbol unsafe user may generate plugin correct symbol name wrong type likelihood lead crash lack safety operating system loaders implies safety guarantees provided higherlevel software unfortunately ghcs dynamic loader although performs extra checks also unsafe moreover typesafe alternatives dlopen library based typed assembly language 15 feasible use ghc ghc loads objects compiled via standard c compiler dont want simply trust authors plugin code provide value correct type consider two techniques ensuring type safety framework ultimately employs unsafe dynamic loader gory lowlevel work first discuss use dynamic typing check plugin values loaded second discuss use full type checker runtime providing form staged type inference overcome limitations first technique 51 dynamically checked plugins plugins compiled separately host application must import implement applications plugin api see section 22 ever due separate compilation plugin cannot guarantee plugin imports correct api provides symbol correct type hence need able annotate compiled object code type information plugin infrastructure perform type checks loading plugin haskell provides suitable dynamic type 1 4 22 37 standard libraries dynamic encapsulates value representation type checked usage runtime dynamic type thus enables type checking delayed runtime plugin infrastructure requires plugin wraps interface dynamic value host application uses fromdynamic function coerce cast dynamic type interfaces expected type returning error value cast fails thus complement dynamic linkers load function dynload function dynload performs conventional load also unwraps dynamically typed value performs type check following example application expects plugin export value type apiinterface wrapped dynamic type ever plugin author instead provides something dynamic type int dynload function catches type error loads object file displaying appropriate error message loading package base linking done loading object api plugin done fail type doesnt match apiinterface approach gives us much type safety underlying dynamics implementation permits however dynamically typed object code defence malicious code check whether types correct way check whether value associated type valid rea son however dynamic type check cannot replaced alternative implements rigorous object code check ing dynload effectively provides hooks adding verification underlying unsafe dynamic loader application may even able choose number trusted verification hooks depending needs 52 dynamic types dynamic loading dynamics haskell standard libraries provide runtime type checking way following function typeable dynamic maybe words fromdynamic expects applied value type dynamic unfortunately leads weakness dynload neither operating systems ghcs dynamic loader guarantee symbol obtained separately compiled loaded plugin type dynamic plugin provides correct symbol name bound nondynamic value fromdynamic simply crash form dynamic type checking safe presence separate compilation need able differentiate dynamic values others plugins object code designing check ongoing work standard dynamics library also fails deduce type equalities correctly presence dynamic loading uses integer keys represent types fast comparison however separate com pilation key created plugins type generated applications version type due implementation hashing standard library luckily readily remedied provide alternative dynamics implementation plugin infrastructure library uses string comparison canonical name type rather hash keys type representation another problem standard dynamics library requires values instances typeable restricts dynamic type monomorphic value mechanism cannot deal type quantification consequently cannot deal form polymorphism fortunately work around extent using ghcs rankn polymorphism eg data type declaration data interface interface rsrc forall eq bool enables us wrap polymorphic values data type namely interface remains typeable means use dynamic type technique works well plugin interfaces since advocate use single type representing plugin api storing polymorphic values wrapped inside api type additional restriction however need wrap unwrap polymorphic value another type tedious contexts eg haskell interpreter plugs generated plugins expressions entered plugs promptmay polymorphic 53 dynamically checked plugins improved number researchers proposed forms dynamics support polymorphic values form runtime type unification 2 22 26 27 present alternative approach lower implementation costs stays within limits haskell type system nevertheless dynamically check plugin values without placing artificial limits plugins interface type remaining safe statically linked code loading plugin need check value retrieve object compatible type api ie need type pluginresource compatible apiinterface case following module type checks module apitypeconstraint import qualified api import qualified plugin apiinterface instead using form dynamic types check types run time simply invoke standard type checker module unlike idea staged type inference 31 approach advantage entirely independent extensions type system supported underlying im plementation require extension also inhibit use features type system plugin apis particular types involving type variables pose additional difficultiesmuch contrast dynamic types however invoking full type inference machinery runtime may sound expensive quantify costs plugin library generate temporary module corresponding apitypeconstraint check conformance plugin code plugin apis function pdynload p polymorphic used load plugin ghcs type checker accepts apitypeconstraint module safe load plu gin precisely pdynload implemented follows pdynload obj incs pkgs ty tmp newtyconstraint ty symbol err typecheck tmp null err v load obj incs pkgs symbol return v else mapm putstrln err return nothing function pdynload closely related fromdynamic arm typecase expression predicated type equal ity checks value exported plugin referred symbol type determined ty two steps first newtyconstraint generates temporary module similar apitypeconstraint second typecheck invokes ghcs type checker temporary module test suc cessful safely load plugin otherwise return error leads question type information propagated api plugin source apitypeconstraint module implementing type constraint luckily mechanism needed ghcs standard support separate compilation sufficient particular ghc generates interface hi file type information compiled modules exported values type information sufficient purposes checking plu gins values interested must already export list hence staged type inference restricted case plugins easily implemented generally case example consider following plugin source module plugin resource num module well typed however leads type error compiling apitypeconstraint module resource clearly type apiinterface since resource exported type plugins interface file whichin case ghchas following form interface plugin resource forall ghcnumnum contrast interface file generated applications api module might following interface api data interface interface ghcbasestring ghcbasestring plugin interface given two interface files type checker reject expression pluginresource apiinterface checking apitypeconstraint module following error message indicating num class restriction plugin value compatible api type load dynload load table 1 cost checked runtime loading relative unchecked load checking types done 14 instance num apiinterface arising use pluginresource 1418 expression pluginresource apiinterface note none requires access plugin source required plugin object files accompanied interface files compiler generates automatically creates object files 531 type checking performance question remains whether invoking full haskell type checkerin case actually invoking ghcis sufficiently fast fact overhead less might imagined code generation required table 1 shows comparative performance various load strategies use runtime loading plugin without type checking reference value named load table runtime type checking using dynamic types standard library 7 slower dynload table con trast invoking ghc adds 22 base load time another 24 use type check apitypeconstraint module pdynload table overall staged type inference plugins using pdynload provides maximum flexibility 46 expensive unchecked load ratios averaged several different architectures running different version com piler different operating systems believe additional overhead pdynload versus unchecked load significant issue two reasons first plugins typically loaded cost amortised running time application second plenty room optimisation performance problem example shields sheard peyton jones 31 discuss several mechanisms limiting amount type inference needs performed run time might adapted framework addition ally speculate linking type checker statically applicationrather invoking ghc external process greatly reduce type checking times could based ghcs recent support linking compiler components library 54 type safety source code plugins despite pdynload overcoming limitations runtime type checking dynamic types remains vulnerable attack since type checker trusts type information contained interface file user provide malicious interface file nothing short proofcarrying code 5 give full type safety dynamically loadable objects however need trust interface files access source code plugins case generate object code matching interface file using plugin librarys compilation manager make combination dynamic loader pdynload process successful application sure plugin internally load dynload pdynload safe object code source code full type full available internal variable free safety interface table 2 type safety plugins using different approaches welltyped also matching interface still needs trust full compiler different plugin statically linked application 55 type safety summary considered two fundamentally different mechanisms typesafe plugins 1 limited runtime type checking using dynamic types 2 full runtime type checking via compiler overcome limitations first approach demonstrated added flexibility latter implies roughly 50 penalty respect time needed load plugin independent mechanism used check plugin interface may compile plugin source load time ensure internally typesafe table 2 summarises different levels type safety achieved either object code available source code compiled load time 6 dynamic loader dynamic loaders purpose load object code applica tions address space arrange code available application achieve needs interact haskell runtime system typically uses operating systems dynamic loader dynamic loader also requires highlevel mechanism resolving dependencies plugins libraries dependent libraries modules must loaded prior loading plugin runtime system cannot chasing dependencies finding libraries makes significant proportion dynamic loaders code 61 runtime loading object loading facilities ghc runtime system implemented c provide single module loading searching appropriate symbol relocation resolution without dependency chasing object loading comprises part linker created haskell execution platform 30 used ghci load haskell libraries interpreter session following ghcis approach plugin library implements foreign function interface object loader linker runtime system making available haskell extend lowlevel functionality providing full library module dependency searching loading much required ghci problem dependency chasing object files contain information necessary determine object files given plugin depends upon ghc problem solves storing module library dependency information object corresponding interface hi file plugins compiled ghc hi file always created object able use purposes interface files stored compressed binary format makes quite difficult parse extracted ghcs binary hi file parser library module application makes call load object file first parse interface file associated object extracting module library dependencies load dependencies dependency order finally loading plugin resolving symbols returning requested value application unfortunately exists another problem dependencies haskell library dependencies noted interface file canonical name library example library usrlocallibghc621hsunixo stored interface file simple string unix complicating libraries depend libraries including c libraries additional dependencies appear interface file fortunately necessary information required find full path dependency information library stored ghcs library configuration file packageconf access parse information implemented packageconf package file parser enabling us reconstruct information required find load library interface file read package information resolved finally able find load plugins dependent libraries modules maintain mutable state dynamic loader keep track libraries modules loaded skip loading components needed peatedly also use state store map libraries canonical names full paths internally state locked using mvars concurrent access synchronised safe 62 standalone typechecker dynamic type checking mechanisms provided pdynload requires call compiler runtime type check code fragment currently achieved writing code fragment temporary file invoking compiler appropriate flags stop compilation type checking hence preventing code gen eration treat compiler simply type checking function errors produced returned caller without code generation type checking relatively fast could improved linking compiler directly application library facilities already exist ghc 63 proxy objects one usually thinks dynamic loader tool inject new code programs address space runtime however dynamic loader also thought intermediary plugin instead directly exposing plugins functions host applica tion dynamic loader mediate communication host application plugin enables complete separation plugins implementation location host applica tion example dynamic loader search userextensible plugin repository matching plugin satisfies interface needed application transparently marshal data provided haskell esdl host application written c gives dynamic loader powers features surrogate objects corbas interceptors fulfil proxy mediator adapter design patterns 12 feature particularly useful haskell since dynamic loader maintains local state separate application contains information loaded plugins depen dencies plugin requires local state dynamic loader supply state instead host application saves host application carrying around plugins state data structures requiring additional code simply support extraneous state plugins may make use 7 compilation manager next dynamic loader compilation manager second major component plugin library infrastructure arranges source code conditionally compiled determining whether changed since previous compile also implements merging extra code plugins abstract syntax compile time allowing compulsory definitions included automatically 71 invoking compiler plugin librarys make function accepts path haskell source file argument invokes ghc compile source object file whose output path controlled host application dynamically loaded important performance plugin reloading call make unnecessarily recompile source code invoking ghc external process adds significant overhead even ghc detects source changed detect modification times source calling ghc makes reload cheap opera tion invokes ghc recompile plugin compilation actually required 72 merging syntax one feature governed compilation manager addition syntax plugins source code facilitate simplified edsl plugins achieved application author write stub haskell source file contains declarations application requires plugin application example specify module name export list stub used preference plugins ensuring compiled plugin correct module name plugin library uses haskell parser construct abstract syntax trees two sources type information plugin tree erased type information module importex port declarations stub tree merged ast plugin resulting ast contains union type information provided application author declarations plugin author ast written haskell source file compiled via make compilation errors occur returned host application display user existing haskell parser library languagehaskell limited parsing haskell 98 extensions edsl file syntax merged turn limited haskell 98 future intend remove restriction linking ghc parser library full haskell parser 8 related work dynamic loader described paper strongly related glasgow haskell compilers dynamic loader used extensively ghcithe compilers interactive environmentto enable mixing compiled interpreted code reuse ghcs dynamic loader extensible fashion enabling used haskell code binding haskell via ffi 3 also implemented dependency resolution similarly ghci using interface files generated ghc compilation reuse interface package parser ghci however use techniques propose ensuring type safety objects loaded ghci emerged hep 30 project whose full goals yet realised sense adding missing elements hep many functional programming languages less support dynamic typing dynamic loading particular clean 28 good support polymorphic dynamic types used variety scenarios including typesafe distributed communication 14 interactive clean interpreter 34 similar spirit plugs ghci particular describes safe file io system storing arbitrary objects including functions disk system requires form dynamic linking combined polymorphic dynamic typing 26 27 use dynamics similar concentrate topics extension languages plugin infrastructure rather use dynamics however would wise research cleans dynamic types dynamic loading work lowerlevel overcome dynamics implementation problems discussed section 52 adding dynamic typing dynamic loading ml family languages also received significant amount attention 9 13 18 22 particular leroy mauny describe eval syntax function abstract syntax dynamically typed values briefly discuss function may used embed caml within program objective caml provides dynlink library 21 supports dynamic loading linking bytecode objects type safety ensured checking object compiled interface application java virtual machine jvm supports dynamic loading via class loaders 23 since jvm bytecode typed language class loaders able perform typesafe dynamic loading jvm contains verifier ensures type safety dynamically loaded code due popularity java jvm likely widely used implementation typesafe dynamic loader 9 future work work highlighted need safer form dynamic typing haskell particular need able generate exception value retrieved loaded object dynamic type currently value unsafely coerced dynamic resulting crash unless handle situation gracefully using dynamic types objectcode plugins remains unsafe using envisage least two approaches solving problem 1 introduce simple type system object file understood runtime system 2 provide checksum type representation stored dynamic value simple type system alternative 1 would distinguish two types namely whether value type dynamic type information sufficient prevent unsafe coercion values type dynamic checksum alternative 2 used similar way recomputing checksum inspecting value approach would make use dynamic types safe checksum used acceptable amount safety many applications use existential types 20 supported many existing haskell implementations including ghc hugs nhc98 existential types commonly associated dynamic types 7 8 previously used provide dynamic dispatch haskell 19 indeed since plugins often used dynamically dispatch functions research needed possible interactions existential types plugins currently use plugin infrastructure library produces rather large binary sizes due statically linking large parts ghc many haskell libraries resulting application modifying plugin infrastructureand thus ghc runtime system linkerto use operating systems native shared library mechanism ieso dll dylib files would produce much smaller application binary sizes especially important embedding haskell support applications written languages larger binary size may barrier using haskell extension language eventually hope produce executable sizes comparable application embedding support languages perl python whose supporting libraries runtime systems usually stored shared libraries one caveat using pdynload type check objectcode plugins discussed section 53 plugins interface hi file must accompany object files directory hence plugin consists two files rather one makes bit unwieldy future hope add support ghc store interface information compiled object file shared library alleviates need extra file moreover plan link parts ghc type checker host application save overhead forking external process end plan exploit ghcs recent support making components compiler library paper introduced general framework plugins haskell discussed framework enables haskell used strongly statically typed extension language used modify add applications functionality runtime without modify applications source code discussed relationship edsls extension languages advocate use haskell edsls dynamic scripting languages possible due plugin frastructure languages ffi bindings haskell immediately inherit benefits enabling use haskell extension language rather designing adhoc language plugin infrastructure library currently used extend pan theon image manipulation framework uses pan edsl extension language described interactive haskell environment evaluates haskell code strings compiling loading strings plugins showed runtime compilation used via ffi enable use dynamically generated haskell plugins within c objectivec programs source code examples paper well plugin library hsplugins available view download httpwwwcseunsweduaudonshspluginspaper acknowledgments grateful kai engelhardt mark wotton simon winwood rest irc channel slashnetorgmaya feedback drafts moreover thank anonymous reviewers constructive criticism r dynamic typing statically typed language dynamic typing polymorphic languages primitive foreign function interface lightweight implementation generics dynamics automated techniques provably safe mobile code yampa ar cade dynamic types existential type dynamic typing distributed programming polymorphic languages functional image synthesis compiling embedded languages design patterns elements reusable objectoriented software dynamic ml without dynamic types distributed computing based clean dynamics safe flexible dynamic linking native code building domainspecific embedded languages haskore music notation algebra music alice land oz interoperability based implementation functional language top relational language combining type classes existential types type classes existential types objective caml system 308 dynamics ml dynamic class loading java virtual machine functional automatic differentiation dirac impulses higher level programming 21st century first class file io dynamic types type dependent functions concurrent clean language report version 21 optimising embedded dsls using template haskell architecture haskell execution platform hep dynamic typing staged type inference emacs extensible ghc team type safe interactive interpreter functional language using compiled code draft haskell xml generic combinators typebased translation proceedingsin proceedings fourth acm sigplan international conference functional programming icfp99proceedings tr dynamic typing statically typed language dynamics ml design patterns building domainspecific embedded languages dynamic typing staged type inference dynamic class loading java virtual machine dynamic typing distributed programming polymorphic languages haskell xml typesafe cast lightweight implementation generics dynamics typesafe linking recursive dlls shared libraries scripting automated techniques provably safe mobile code safe flexible dynamic linking native code first class file io dynamic types type dependent functions emacs extensible customizable selfdocumenting display editor yampa arcade functional automatic differentiation dirac impulses compiling embedded languages ctr bjrn bringert anders hckersten conny andersson martin andersson mary bergman victor blomqvist torbjrn martin student paper haskelldb improved proceedings 2004 acm sigplan workshop haskell p108115 september 2222 2004 snowbird utah usa niklas broberg haskell server pages dynamic loading proceedings 2005 acm sigplan workshop haskell p3948 september 3030 2005 tallinn estonia stewart manuel chakravarty dynamic applications ground proceedings 2005 acm sigplan workshop haskell p2738 september 3030 2005 tallinn estonia
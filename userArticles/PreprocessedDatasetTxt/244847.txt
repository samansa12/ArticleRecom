latch optimization circuits generated highlevel descriptions gatelevel description finite state machine fsm tradeoff number latches size logic implementing nextstate output functions typically initial implementation generated via explicit state assignment translation highlevel language tradeoff subsequently lightly explored efficiently explore good latchlogic tradeoffs large designs generated highlevel specifications reduce number latches controlling logic size demonstrate efficacy techniques large industrial examples b introduction gatelevel description nite state machine fsm tradeooe number latches size logic implementing nextstate logic tradeooe exploited two levels generation initial implementation subsequent logic optimization steps 11 background state assignment generation state encoding initial latchlogic implementation higher level design process date primarily two approaches used explicit state assignment begins explicit state transition graph chooses minimum latch encoding minimizing size combinational logic dbsv85 vsv90 har61 state assignment highlevel languages chooses encoding according delay statements specication relying logic synthesis later optimize gatelevel implementation bt93 explicit state assignment impractical large designs despite sophisticated techniques determining optimal assignment produce results far worse handcoded implementations furthermore explicit state assignment programs targeted greaterthanminimumlatch imple mentations current technology eg fpgas longer necessary minimize number latches often produces prohibitively large combinational logic onehot encoding also applied explicit state graph one latch used state resulting logic small fast since states need encoded decoded however number latches huge onehot implementation dioecult starting place logic synthesis automatic techniques reducing number latches onehot implementation produce good tradeooe resoundingly successful state assignment highlevel languages typically done statementbystatement transla tion results natural insertion registers delay statements description good starting point logic synthesis results far latches required implement design bt93 even number latches important nal implementation many drastically reduce eoeciency many synthesis optimization algorithms eg symbolic state traversal state assignment latchlogic tradeooe explored via logic optimization standard techniques eg extracting common factors function simplication retiming may result latchlogic rearrangement largely state assignment xed optimization improves implementation given assignment goal retiming resynthesis msbsv91 jointly optimize latch positions combinational logic optimization potential limited initial state assignment rr nsigma2943 4 ellen sentovich horia toma grard berry removal redundant latches done ubiquitously term iredundant latchesj used ubiquitously variety meanings latches fanout primary output latches constant entire state space latches constant reachable state space latches equivalent latches sophisticated denitions consider simple redundant latch removal latches fanout latches constant results straightforward equivalent state variable identication removal done part several works eg ssm current bdd symbolic traversal techniques also simple operation robust algorithm single latch removal published ln91 directly relevant single latch removal algorithm described section 31 treated thoroughly section exact precisely replacing single latch logic far expensive number latches exceeds minimum log 2 reachable gamma states even small circuits qcc 95 general technique reencoding nite state machines given work relevant eg controlling size encodingdecoding logic target quite dioeerent goal reencoding try match encodings two dioeerent similar machines order speed symbolic traversal 12 approach complete exploration latchlogic tradeooe certainly feasible necessary nonetheless suoeciently rich choice solutions available especially variety implementations found todays technology example ffl one may target implementation hardware software ffl hardware implementation may targeted nal custom design fpga board emulation ffl current specication may preliminary one intended implementation used verication functional properties three cases optimization criteria quite dioeerent focus eoecient exploration latchlogic tradeooe design generated highlevel specication particular begin designs generated esterel descriptions initial encoding generated esterel compiler natural one respect behavior design contains many redundant registers develop algorithms removing redundant registers target algorithms work well large designs remove registers cheaply possible ie easily discover redundant registers able easily replace minimum amount additional logic generate optimal solutions considering nal implementation cost andor eoecacy intermediate representations key results include following ffl algorithms eoecient enough provide signicant choice implementations regarding latchlogic tradeooe large circuits results direction published thus far aware ffl applying simple easy compute heuristics latch reduction get close minimum number latches possible given reachable state set almost examples obtained nal number latches less equal log 2 jrj set reachable states ffl work incrementally initial implementation taken highlevel language strive preserve given structure size resulting logic remains tractable even approach minimum number latches inria latch optimization circuits generated highlevel descriptions 5 ffl results maximum latch removal terms area resulting logic compare favorably obtained traditional irobustj technique extracting state transition graph running explicit state encoding program performing logic optimization result usually obtain smaller implementation much less time furthermore observed blowup area initial implementation state assignment resulting long logic optimization runtimes experience incremental techniques could make comparison relatively small examples explicit state transition graph expensive compute ffl runtimes latch removal algorithms insignicant reachable state set computed initially subsequent latch redundancies determined comparatively trivial amount time set 2 overview technique apply heuristic techniques successively remove redundant latches controlling size combinational logic complete latch removal technique could implemented extracting explicit state transition graph performing exact state minimization running state assignment program generate minimumlatch encoding far expensive yields insight latchlogic tradeooe instead successively remove latches using subset information used aforementioned complete scheme example consider reachable states equivalent states realm general heuristic procedure might 1 compute bdds latches outputs auxiliary functions eg equivalent states reachable states controllabilityobservability information environment 2 apply algorithms removing latches sequential behavior unchanged respect environment described auxiliary functions 3 iterate removing many latches possible many latches desired given constraints size combinational logic 21 general algorithm nd scheme still expensive industrial applications robust necessary demonstrate experimentally choose simpler scheme 1 compute reachable states machine 2 determine set latches may easily removed preserving reachable state set 3 among choose set latches remove based cost estimate remove latches add logic optimize 4 iterate removing many latches possible many latches desired given constraints size combinational logic important note onelatchremoval step proposed algorithms reencode states considering state pairs easily merged general reencoding pair reachable state unreachable state give pair single new encoding pairmerge operation done way ffl computationally easy determine pairings rr nsigma2943 6 ellen sentovich horia toma grard berry figure 1 general circuit transformation ffl inexpensive bdd size logic size perform mergings update reachable states ffl existing logic preserved much possible contains valuable information structure circuit way computations required remain tractable large circuits resulting additional combinational logic usually limiting factor incremental reencoding algorithms controllable important note transformation proven preserve behavior reachable state set remains correct every overapproximation reachable state set therefore could used conjunction eoecient techniques approximate reachability analysis chm 22 circuit transformation transformation illustrated figure 1 original fsm transformed one 0 call ng set latches transformation remove latches indices set convenience keep indices remaining latches ig assume l 0 latches next state vector l generated c called 0 encoding function e type given vector functions decoding function type given vector set reachable states resp 0 denote characteristic function r resp r 0 thus r 2 r implies let r 0 r 0 0 denote initial states 0 context say equivalent 0 r property transformations satisfy functions represented polynomials bdds input variables consistently called k l k r l 0 k r 0 f denotes polynomial bdd set variables x another set variables denote f yx result substitution x k k f x result substitution x k complements k respectively denote f x f x positive negative cofactor f respect x algorithms section several algorithms latch removal described summary 1 singlelatch removal determine latches removed individually replaced combinational function latches inria latch optimization circuits generated highlevel descriptions 7 2 determine pairs latches removed replaced single latch whose input combinational function latches 3 onehot3by2 search onehot encoding replace every three latches two latches combinational function 4 replacement n latches latches new combinational function latch following sections specied precisely according ffl condition latches removed ffl logical transformation required circuit ie specication e figure 1 note many choices functions implement chosen described one algorithm reasons choice subsequent eoeects optimization described section 4 ffl proof transformation valid note new initial state trivially computed encoding function e hence discussed ffl brief description algorithm note every case r incrementally eoeciently updated computations iterations 31 transformation singlelatch single latch removal nd replaces latches substituted combinational function latches condition single latch l replaced combinational function others r l condition originally given bcm90 satisfaction implies l distinguish reachable states reencoding couple reachable state form l 1 l unreachable state l 1 l produce state l 0 n similarly 10 general subset latches satisfy condition single latch removed remaining subset removable latches may change apply heuristic techniques described algorithms determine latches remove ln91 exact branchandbound algorithm used determine maximum number single latches removed paper indicates bounding heuristics powerful exact result obtained reasonable amount time experiments performed small examples largest reduction number latches 5 largest total number latches 21 designs 10s 100s latches many redundant latches exact algorithm far expensive empirically observed results nearly match singlelatch algorithms furthermore reduce number latches even algorithms described sequel transformation latch l removed logic functions e added e dened e k set k l 0 rr nsigma2943 8 ellen sentovich horia toma grard berry singlelatch1m r removedlist find remove latches 1 bestlatchcost foreach latch l c l bestlatchcost bestlatchcost j 1 break removedlist removedlist removedlist j oe return compute modify foreach l 2 removedlist foreach l removelatchm l rnew 9 l r rnew figure 2 transformation let l implies r l two algorithms implemented single latch removal pseudocode given figures 2 3 inria latch optimization circuits generated highlevel descriptions 9 singlelatch2m r bound 1 removablelist removedlist foreach latch l transformation 2 removablelist removablelist l removablelist j oe return foreach latch l 2 removablelist stillcanberemovedremovedlist l removelatchm l removedlist removedlist figure 3 transformation algorithm 1 greedily selects removes one latch time based cost function related potential removing latches use branching heuristic ln91 computecost sets c l j jrj onset size bdd r absolute value term highest latches potential distinguishing states selecting latch lowest c l leave latches highest potential thus heuristically maximize chances removing latches furthermore heuristic implies minimum number minterms changed encoding space observe help control size overall logic selecting latch r updated though latch already removed process iterated set latches removed simultaneously computed removed replaced combinational logic depends remaining latches algorithm computes maximal removable set hence iteration necessary note upon removing latch output variable implementing input latch set 0 results simplication combinational logic c addition computed directly initial r smoothing variables removed l 1 simultaneously removable thermore operations performed order since 9 commutative 9 cofactor commute alternately r could updated variable removed next computed updated r latter technique requires less computation removal creates functions depend upon variables eventually removed hence increases levels logic strive control size depth logic computation time signicant prefer former method algorithm 2 selects set latches according cost bound based bdd size computecost returns number support variables bdd estimate bdd size manipulation nal implementation size resulting logic course number bdd support variables tight measure implementation size nonetheless rr nsigma2943 ellen sentovich horia toma grard berry foreach latch l foreach latch l j j isremovabler l l j transformations 4 5 removelatchm l r l figure 4 transformation 2by1 algorithm correlation level dioecult estimate implementation size without synthesizing design since set latches selected according individual removable condition r guarantee removed simultaneously condition checked latch removal second part algorithm must recomputed well ensure depends remaining latches entire process iterated increasing cost bound 32 transformation 2by1 condition two latches l l j replaced single latch l 0 satisfaction condition implies valid pairing reachable states unreachable states reencoding couple reachable state l 1 l unreachable state l 1 l produce l 0 n l l 11 replaced l replaced l transformation l l j satisfy condition one remove l set ae 4 proof let l 2 r k 6 k 6 j k let l l since 1 rst term condition 3 implies r l l j l j similarly l l j 2 f01 10 11g thus l reachable state l 2 inria latch optimization circuits generated highlevel descriptions 11 algorithm pseudocode algorithm shown figure 4 latch pair examined replaced single latch possible note case input removed latch l cannot set 0 e j depends therefore subsequent logic reduction c 33 transformation onehot3by2 transformation specic onehot encoded designs note single latch removal algorithm applied onehotencoded design one latch removed even exact algorithm applied even though design jlj latches minimum log 2 jlj algorithm rst searches part encoding space onehot encoded replaces every three latches two part encoding condition condition latch onehotencoded given r l transformation group three latches l l i1 l i2 replaced deltal 0 l proof algorithm omit proof brevity describe algorithm detail specialized heuristic straightforward implement 34 transformation nbyn1 nbyn1 algorithm considers entire encoding space searching statepair merging rather restricting merging across plane small cube case single 2by1 algorithm two parts first encoding modied without removing latches clustering existing encodings toward all0 encoding called migratestates next resulting encoding checked see reachable state paired mirror state variables complemented 341 transformation migratestates condition condition encodings shifted toward origin given registers removed step reachable states l deltar l reencoded l deltar l 6 r transformation safely maps state reachable set unused encoding unreachable set transformation given l satises 6 machine reencoded follows r l rr nsigma2943 12 ellen sentovich horia toma grard berry let l 1 shannon cofactor l finally l r l algorithm greedily moves encodings towards origin boolean space algorithm implemented simply iterating latches checking condition performing transformations possible motivation subsequent foldstates operation performed reachable states hamming distance ne gamma 1 origin 1 could choose point boolean space around cluster encodings all0 encoding good choice esterel circuits believe others generated highlevel descriptions reason initial encodings onehot close onehot igrouphotj contain many 0s migratestates add exorbitant amount logic rather iterating completion check foldstates condition iteration stop satised reachable states updated latch visited follows 342 transformation foldstates reencoding done choosing latch l state encoding l l l encoding unchanged l state variables inverted latch l removed example condition satised choosing rst bit removed latch l new encoding r condition condition states merged given transformation transformation removes register l sets ae proof let l 2 r let l l shannon expansion rl fact since condition r l finally l j 6 similarly l algorithm implemented directly 10 11 reachable states updated follows 1 suoecient necessary condition inria latch optimization circuits generated highlevel descriptions 13 35 comments algorithms must emphasized selecting algorithms heuristics focus primarily traditional logic optimization metrics goals exploring latchlogic tradeooe instead ffl maintain initial existing logic structure extent possible reaeects structure given highlevel description ffl use metrics relate perform algorithms size e logic control try overly pessimize logic synthesis ffl leave logic optimization existing tools specialized purpose heuristics important heuristic described related dont care conditions selecting e case actually set combinational functions used single one set arises use unreachable states dont care conditions indicated choice description e functions example singlelatch algorithm function satises r l would correct experimented dioeerent choices found functions small enough degree aeexibility useful level furthermore since arises solely reachable state set information used instead subsequent logic optimization many heuristics employed selecting latch minimizing bdds minimizing implementation optimizing algorithm performance etc focus nding good implementations exploring reasonable subset latchlogic tradeooe given available tools stateoftheart bdd technology logic optimization etc designs domain rather attempting implement exact algorithms thoroughly test large set heuristics whose nal value dioecult measure tested number heuristics especially selecting e choices function implementation reaeect results experiments similar algorithms note 2by1 generalization single latch removal algorithm generalized replace 3 registers 2 etc found successive generalization improve results suoeciently justify rapidly increasing cost note nbyn1 algorithm described generalization 2by1 completeness singlelatch algorithms complete nished single latches removed maintaining reachable state set l claims made removing several latches criteria transformation 2by1 complete may possible two latches replaced one latch additional combinational logic replaced algorithm similarly nbyn1 algorithm complete 4 implementation results experiments shown nding good latch encoding performing optimization dioecult problem yet important one encoding strongly eoeects subsequent optimization know log 2 jrj encoding usually implies exorbitant combinational logic given particular encoding cannot predict size combinational logic intuition applies tradeooe number latches performance verication algorithms rr nsigma2943 14 ellen sentovich horia toma grard berry aim implementation develop tool allows us make estimates starting points combinational optimization hardware software designs verication two dioeerent metrics imply need dioeerent strategies combining latch removal logic optimization 41 implementation implemented program remlatch using tiger library cmt93 contains bdd package reachable states computation implement latch removal algorithms berkeley sis environment ssl 92 perform combinational logic optimization used mainly two scripts logic optimization sis fast less robust one combopt expensive one includes eg fullsimplify blifopt actual logic cost estimated literal count sis computed cost register terms literals varies depending target implementation found reasonable measure hardware software produce implementation optimization rst strategy oriented hardware software implementations basis latch removal case singlelatch2 cost function bounds size support bdds logic replacing latches transition bdds logic costly found bdd support size best measure controlling blowup opposed guess based literal count recall singlelatch algorithms actually reduce size c overall logic cost using postsynthesis measure literal count varies little see section 42 experiments observed attractive congurations discovered even circuits large intermediate bdds generated cases subsequent logic optimization successfully reduced implementation sizes reason iterate singlelatch2 relaxing cost conditions continue 2by1 foldstates algorithm expensive terms additional logic 2by1 necessity performing migrateto0 add signicant logic prohibits use nbyn1 hardware software implementations 412 strategy 2 verication optimization second strategy oriented improving time taken vericationbased algorithms experiments demonstrate reducing number latches positive eoeect performance verication techniques bdds reachable states decrease size size combinational logic grows slowly reason primarily number latches strong eoeect bdd sizes two bdd variables per latch fsm verication thus strategy uses singlelatch1 heuristics maximizing number removed latches followed iteration 2by1 completion latter applied alternatively logic optimization ensure successive nite state machines reasonable sizes results phase encouraging mainly suoeciently control additional logic using blifopt script largest circuits course possible use combopt script logic grew quickly consequently restricted number latches removed nonetheless able reduce latches improve verication times able perform optimization previously explore topic handling large circuits section 5 413 strategy 3 exploration goal third strategy minimize number latches study behavior algorithms properties nal circuits interestingly able almost cases reduce inria latch optimization circuits generated highlevel descriptions 15 circuit states reg exact single1 minimum s400 8865 21 s526 8868 21 19 19 14 table 1 singlelatch1 vs exact single removal number latches log 2 jrj 1 gives indication power algorithms addition found large examples remain reasonablysized even number latches decreases dramatically report extensively maximum latch removal compared strategies section 42 414 controlling logic size already tailor algorithms nd state pairs easy merge reencode thereby minimally modify reached state set functions determined necessary compute implementing logic start bdd new logic must transform logicgate representation two places control size introduced logic rst keeping bdd sizes small goal used algorithms tiger bdd package creates logic bdds linear number bdd nodes second use formulas e logic directly implement functions logic gates computing functions bdds substituting bdd results created logic gates technique increase number levels circuit must used caution 42 results rst set test iscas89 sequential test benchmarks used comparison exact single latch algorithm ln91 results shown table 1 s444 results exact algorithm better runtime comparison would fair implementation exact algorithm author algorithm ran seconds iscas benchmarks compares favorably results ln91 implementation exact algorithm ran hour smallest esterel examples benchmarks used synthesized esterel v5 compiler simply test programs others large industrial designs tcint renault snecma sequenceur trappes particularly large interesting examples two possible starting points designs generated directly esterel compiler manageable initial implementation terms encoding logic far many redundant registers case arises examples initially combinational cycles design causal causality analysis program sbt96 generates initial acyclic implementation directly bdds thus huge terms logic eg trappes table 2 initial circuit compared minimumlatch remlatch result optimized combopt obtained close minimum number latches examples logic increases remains reasonable many cases decreases due removal many simply redundant latches gates fact sequenceur tcintnocount trappes reported minimum number latches logic increase exorbitant eg tcintnocount obtained 9latch version 11826 literals sequenceur 59latch version 600000 literals cpu times reported table 3 experiments run dec alpha 200233 station rr nsigma2943 ellen sentovich horia toma grard berry initial remlatch circuit states min reg lit reg lit abc 4 12 renault runner 6 5 5182 13 sequenceur tcintnocount 19 20 310 9 90 1036 26 328 trappes 53 154 135718 table 2 initial version vs minimumlatch version circuit reachablestates single 2by1 merge fold abc 03 07 09 11 13 abcdef 12 33 35 37 39 controle 09 14 16 18 20 controlecount 45 58 64 68 71 renault 65 122 146 156 169 runner 546 620 683 755 761 sequenceur 12706 26789 34027 36307 snecma 453 672 697 705 712 tcint 1336 2381 2500 2505 2528 tcintnocount 196 761 819 829 841 trappes 2459 4064 5711 7335 8961 table 3 cpu seconds dec alpha remlatch novasis circuit reg literals reg literals states abc 4 111 4 197 controle 5 626 5 172 23 controlecount tcintnocount 26 313 8 7692 231 traoec 5 table 4 remlatch minimumlatch vs novasis times cpu seconds table show series cumulatives times running algorithms succession begin reachable states computation progressively add times algorithm runtimes remain order magnitude initial reachable states computation note tcint mergestates condition satised immediately runs quickly table 4 report minimumlatchblifopt results versus obtained combination stategraph extraction exact state minimization state assignment nova logic optimization sis sis rugged script blifopt tcint example actually run latch removal optimization obtain implementation could extract state transition graph still exception controle circuits novasis combination performed much worse case abcdef initial nova circuit large run optimization even though circuits generated esterel one case equivalent states found aoeect minimum number latches gives indication losing much explicitly considering equivalent states strategy inria latch optimization circuits generated highlevel descriptions 17 blifopt bestremlatch circuit reg lit reg lit renault 23 166 37 507 28 497 runner 6 5 29 198 15 198 tcint 19 20 50 241 38 237 tcintnocount 19 20 47 197 38 194 sequenceur trappes 53 154 20 1193 table 5 blifopt vs bestremlatch2503504508 singledat sissingledat figure 5 graph 1 latches vs literals table 5 compare best logic optimization results obtained applying blifopt initial circuit best remlatch results obtained combination latch removal optimization small examples able reduce number latches minimum thorough exploration possible tried many combinations latch removal optimization algorithms strategies discussed sections 3 41 reaeect experience larger les couldnt obtain minimum due size encoding logic theoretical limits algorithms instead used strategies similar successful small examples number literals comparable despite fact remlatch must add encoding decoding logic furthermore number latches much lower sequenceur trappes signicant logic optimization done without rst removing latches present novel results examples graph figure 5 shows evolution latchliteral tradeooe one example application standard strategies examples behaved similarly observe rst number literals remains almost constant single latch removal recall c actually rr nsigma2943 ellen sentovich horia toma grard berry579111315 figure graph 2 verication times vs number latches reduced case 2by1 algorithm logic tends increase quickly still successful reducing logic continuing 2by1 except sequenceur logic size must always carefully monitored similar phenomenon observed application migrate fold graph figure 6 shows evolution cpu time selfverication one examples number latches decreases best point 15 latches obtained single 2by1 without iterating 2by1 completion examples behaved similarly 5 future work rst goal use results work preprocessor improve logic optimization critical point since circuits produced causal analysis large dioecult cope experimental work indicates partitioning beyond e improve results stage next step exploit particular properties esterel programs including esterel relations form dont care conditions circuit structures particular esterelgenerated implementations cost functions based structural analysis could improve verication times also allow good tradeooes logic optimization important large designs exploit given natural circuit structure hardware implementations using fpgas explore increasing number latches via retiming improve critical path fact retimingbased techniques could used directions stage ie reduce number latches reduce critical path increasing new latches acknowledgements work supported part national science foundation grant int9505943 french genie mesr inria project inria latch optimization circuits generated highlevel descriptions 19 r new ideas symbolic manipulations finite state machines optimized controller synthesis using esterel structural approach state space decomposition approximate reachability analysis optimal state assignment finite state machines state assignment problem sequential machines exact redundant state registers removal based binary decision diagrams retiming resyn thesis optimizing sequential networks combinational techniques incremental fsm reencoding simplifying verication symbolic traversal constructive analysis cyclic circuits sis system sequential circuit synthesis sequential circuit design using synthesis optimization detection equivalent state variables finite state machine verication nova state assignment finite state machines optimal twolevel logic implementations tr sequential circuit design using synthesis optimization structural approach state space decomposition approximate reachability analysis constructive analysis cyclic circuits ctr ellen sentovich horia toma gard berry efficient latch optimization using exclusive sets proceedings 34th annual conference design automation p811 june 0913 1997 anaheim california united states andrew seawright wolfgang meyer partitioning optimizing controllers synthesized hierarchical highlevel descriptions proceedings 35th annual conference design automation p770775 june 1519 1998 san francisco california united states yunjian jiang robert k brayton software synthesis synchronous specifications using logic simulation techniques proceedings 39th conference design automation june 1014 2002 new orleans louisiana usa priyank kalla maciej j ciesielski performance driven resynthesis exploiting retiminginduced state register equivalence proceedings conference design automation test europe p125es january 1999 munich germany hahnsang kim thierry turletti amar bouali epspectra formal toolkit developing dsp software applications theory practice logic programming v6 n4 p451481 july 2006 stefano quer gianpiero cabodi paolo camurati luciano lavagno ellen sentovich robert k brayton verification similar fsms mixing incremental reencoding reachability analysis combinational checks formal methods system design v17 n2 p107134 oct 2000 klaus winkelmann formal methods designing embedded systemsthe sacres experience formal methods system design v19 n1 p81110 july 2001
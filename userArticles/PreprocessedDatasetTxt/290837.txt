code generation fixedpoint dsps paper examines problem codegeneration digital signal processors dsps make two major contributions first important class dsp architectures propose optimal algorithm tasks register allocation instruction scheduling expression trees optimality guaranteed sufficient conditions derived structural representation processor instruction set architecture isa second develop heuristics case basic blocks directed acyclic graphs dags b introduction digital signal processors dsps receiving increased attention recently due role design modern embedded systems like video cards cellular telephones multimedia communication devices dsps largely used systems generalpurpose architectures capable meeting domain specific constraints case portable devices example power consumption cost may make usage generalpurpose processors prohibitive true highperformance arithmetic processing required implement dedicated functionality low cost case specific communications preliminary version parts paper presented araujo malik 1995 1995 acmieee international symposiumon system synthesis france september 1315 1995 araujo et al 1996 1996 acmieee design automation conference june 37 authors address g araujo institute computing university campinas unicamp cxpostal 6176 campinas sp 13081970 brazil malik department electrical engineering princeton university olden st princeton nj 08544 usa permission make digital hard copies part work personal classroom use granted without fee provided copies made distributed profit direct commercial advantage copies show notice first page initial screen display along full citation copyrights components work owned others acm must honored abstracting credit permitted copy otherwise republish post servers redistribute lists use component work works requires prior specific permission andor fee permissions may requested publications dept acm inc 1515 broadway new york ny 10036 usa fax 1 212 8690481 permissionsacmorg computer graphics applications increasing usage processors revealed new set code generation problems efficiently handled traditional compiling techniques techniques make implicit assumptions regular nature target architecture microarchitecture rarely case dsps irregularities microarchitecture basis efficient computation specialized functions due hard onchip memory constraints hard realtime performance requirements code generated processors meet high quality standards since existing compilation techniques task vast majority code written directly assembly language research part project directed towards developing compilation techniques capable generating quality code processors httpeeprincetoneduspam implementation techniques forms compiling infrastructure used work called spam compiler large body work done code generation general purpose pro cessors code generation general hard problem instruction selection expressions subsumes directed acyclic graph dag covering npcomplete problem garey johnson 1979 bruno sethi 1976 sethi 1975 showed problem optimal code generation dags npcomplete even single register machine remains npcomplete expressions shared term subexpression shared term aho et al 1977a efficient solution restricted class dags proposed prabhala 1980 code generation expression trees number solutions n number nodes tree algorithms offer solutions case stack machines bruno sethi 1975 register machines sethi ullman 1970 aho johnson 1976 appel supowit 1987 machines specialized instructions aho et al 1977b form basis code generation single issue order execution generalpurpose architectures problem generating code dsps embedded processors received much attention though probably due small size programs running architectures enabled assembly programming increasing complexity embedded systems programming systems without support highlevel languages become impractical many problems associated code generation dsp processors first brought light lee lee 1988 lee 1989 comprehensive analysis architecture features processors code generation dsp processors studied past recently number interesting work tackled important problems marwedel 1993 proposed treebased mapping technique compiling algorithms microcode architectures liem et al 1994 uses treebased approach algorithm matching instruction selection registers organized classes register allocation based leftfirst algo rithm datapath routing techniques also proposed lanner et al 1994 perform efficient register allocation wess 1990 proposed usage normal form schedule dsp architectures offered combined approach register allocation instruction selection using concept trellis diagrams wess 1992 kolson et al 1996 recently proposed interesting exact approach register allocation loops embedded processors overview current code generation fixedpoint dsps delta 3 research work code generation dsp processors embedded processors general found marwedel goosens 1995 paper propose optimal two phase algorithm performs instruction selection register allocation instruction scheduling expression tree polynomial time class dsps architecture model described section 2 programmable highlyencoded instruction set architecture isa fixedpoint dsp processor formally speaking class extension machine models discussed coffman sethi 1983 first pass section 3 perform instruction selection register allocation simultaneously using ahojohnson algorithm aho johnson 1976 second pass described section 4 algorithm takes optimally covered expression tree n nodes schedules instructions memory spills required memory spill operation contents particular register saved memory due lack available registers operation reloaded memory operation finished observe memory store operation required architecture topology considered memory spill proposed algorithm uses concept register transfer graph rtg structural representation datapath annotated isa information show rtg machine acyclic optimal code guaranteed program expression tree written machine case dsp said acyclic datapath since dag code generation npcomplete develop heuristics case acyclic datapaths section 5 uses rtg concept section 6 show results applying ideas benchmark programs section 7 summarizes major contributions suggests open problems 2 architectural model dsp processors irregular architectures compared general purpose counterparts section analyzes main architecture features distinguish dsps general purpose processors respect basic block code generation purpose section give detailed extensive analysis features comprehensive analysis dsp architectures found lee 1988lee 1989 lapsley et al 1996 dsps classified according type data use fixedpoint dsps floatingpoint dsps applications running fixedpoint dsp users responsible scaling result integer operations automatically done floatingpoint dsps floating point units extremely costly terms silicon area clock cycles reason large number systems based dsps uses fixedpoint dsps case acronym dsp assumed mean fixedpoint dsp dsps onchip data memory based fast static rams onchip nonvolatile program rom unlike general purpose architectures dsps designed cache virtual memory systems since data program streams usually fit available onchip memories onchip memories fast cache misses issue dsps designed memoryregister architectures texas instruments 1990 order achieve bandwidth required appli cations dsps architectures provide multiple memory banks motorola 1990 since performance important factor dsp applications dsp instructions usually designed fetched single machine cycle order achieve instructions encoded minimize number bits require architectures texas instruments 1990 done means data memory pages instructions need carry offset data within current page order access goal design dsp datapath implement functional units speed costly operations frequently occur processor application domain common example units multiply accumulate mac due design requirements dsp designers frequently constrain interconnectivity registers functional units two main reasons first desired functionality usually requires particular datapath topol ogy second broad interconnectivity translates datapath buses andor muxes results increased cost instruction performance degradation large number dsps heterogeneous register architectures architectures contain multiple register files instructions require operands store resulting computation different register files hence name het erogeneous generalpurpose architectures instructions usually restrict registers use provided come register file hence operand registers homogeneous considerably simplifies code generation prob lem since decouples tasks instruction selection register allocation due property say generalpurpose architectures homogeneous register architectures example 1 example dsp architecture ti tms320c25 digital signal processor dsp texas instruments 1990 considered target architecture rest paper processor part ti tms320 family processors makes large number commercial dsp processors use today tms320 family composed fixedpoint processors tms320c1xc2xc5xc54x heterogeneous architectures also number floatingpoint homogeneous architecture dsps tms320c3xc4x tms320c25 processor contains isa specialized memoryregister registerregister instructions three separate registerfiles p containing single register 3 optimal instruction selection register allocation homogeneous register architectures selection instruction connection whatsoever types registers instruction uses selecting instructions heterogeneous register architectures usually requires allocating register specific registerfiles operands particular instructions strong binding instruction selection register allocation indicates tasks must performed together araujo malik 1995 consider example intermediate representation ir patterns figure 1 corresponding subset instructions tms320c25 isa figure 1 instruction associated treepattern whose node composed operations plusminusmul registers apt constants const memory references code generation fixedpoint dsps delta 5 add apac mpy mpyk p pac sacl const spac lac lack const fig 1 ir patterns tms320c25 processor instruction operands destination cost three address form add 1 apac ap 1 spac ap 1 gamma p lack k k 1 k pac p 1 p table 1 partial isa tms320c25 processor treepatterns represented using threeaddress form table 1 threeaddress standard compiler representation instructions destination instruction two operands hence name three address operation performs present reference square brackets associated memory position table 1 also lists cost associated instruction notice instructions implicitly define registers use example instruction apac take operands registers p always computes result back observe also operations transfer data datapath like lac load register memory position pac move register p register represented single node corresponding source register transfer operation associated cost case cost moving data source register destination register since registers dsp architectures scarce resource final code quality sensitive cost routing data datapath 31 problem definition optimal instruction selection combined register allocation problem determining best cover expression tree cost pattern match depends number cycles associated instruction also number cycles required move operands location 6 delta guido araujo sharad malik currently location instruction requires 32 problem solution solution problem use variation ahojohnson algorithm aho johnson 1976 node keep possible costs matches node also possible costs resulting matching node moving result originally computed reachable location datapath treegrammar parsers used way implement codegenerators aho et al 1989 fraser et al 1993 tjiang 1993 combine dynamic programming efficient treepattern matching algorithms hoffman odonnell 1992 optimal instruction selection implemented combined instruction selection register allocation using olive tjiang 1993 codegenerator generator olive based techniques proposed iburg fraser et al 1993 takes input set grammar rules treepatterns described prefixed linearized format ir patterns table 1 converted olive description figure 2 rewriting instruction threeaddress representation format notice instruction destination registers associated grammar nonterminals represented lower case letters figure 2 fig 2 partial olive specification tms320c25 processor instruction numbers names right part specification rules 1 3 4 5 correspond instructions take two operands store final result particular register p respectively rule 6 describes immediate load register rules 7 10 associated data transference instructions bring cost moving data datapath total cost match point sake simplicity represent figure 2 patterns corresponding commutative operations example instruction add specified two different ways plusam plusma nevertheless consider remainder paper commutative forms operation pattern available whenever required consider instruction scheduling associated spills point algorithm proposed optimal follows fact algorithm variation provably optimal ahojohnson dynamic programming algorithm aho johnson 1976 code generation fixedpoint dsps delta 7 4 scheduling optimal instruction selection register allocation expression tree enough produce optimal code optimal code instructions must scheduled way memory spills introduced notice memory positions allocated previous phase considered spills result optimal selection memoryregister instructions isa presence resource conflicts aho johnson 1976 showed using dynamic programming optimal code generated linear time wide class architectures schedule propose based strong normal form theorem theorem guarantees optimal code schedule expression tree homogeneous register architectural model always transformed strong normal form snf code sequence snf formed set code subsequences separated memory storages code subsequence determined strongly contiguous sc schedule code sequence sc schedule formed follows every selected match child subtrees 1 2 continuously schedule instructions corresponding subtree 1 followed instructions corresponding 2 finally instruction corresponding pattern wess 1990 used snf heuristic schedule instructions tms320c25 dsp 41 problem definition sc schedules efficient way schedule instructions heterogeneous register set architectures produce code sequences whose quality extremely dependent order subtrees evaluated consider example ir tree figure 3a expression tree optimally matched using approach proposed section 3 target isa takes variables memory positions 0 4 stores resulting computation one variable memory position using 5 temporary storage code sequences generated three different schedules corresponding threeaddress representation showed figure 3bd memory position 7 used whenever spill location required scheduler code figure 3b left subtree node scheduled first followed right subtree instruction corresponding node operation opposite approach used obtain code figure 3c neither sc schedules figure 3b c sc schedule ever produce optimal code obtained using nonsc schedule first schedules addition rest tree figure 3d notice schedule indeed snf schedule since first subtree corresponding 2 contiguously scheduled followed storage operation memory position 5 another code sequence resulting sc schedule rest tree figure 3 verify appropriate snf schedule minimizes spilling example tree figure 3a scheduled using leftfirst result operation theta 1 first stored p moved register used route result position 5 still contains live result result 0 case codegenerator emit code spill value memory recover mpy m0 p m0 lac m3 m3 add m2 pac p add m2 sacl m7 m7 sacl m5 m5 lt m1 m1 lac m3 m3 mpy m5 p m5 mpy m0 p m0 add m2 sacl m5 m5 pac p lt m4 m4 mpy m5 p m5 mpy m0 p m0 spac p lac m7 m7 pac p sacl m6 m6 spac p lt m7 m7 spac p sacl m6 m6 b c fig 3 matched ir tree tms320c25 b snf leftfirst schedule c snf rightfirst schedule optimal schedule later would required scheduler first stored 2 loading result 0 problems like one illustrated common dsp architectures obvious question raises exist guaranteed snf schedule spilling required prove schedule exist certain conditions depend exclusively isa target processor let us define problem formally given optimally covered expression tree heterogeneous register architecture determine instruction schedule introduce spill code 42 problem solution section divided follows section 421 state prove sufficient condition heterogeneous register architecture satisfy order enable spill free schedules section 422 introduce concept register transfer graph rtg show impacts code generation task finally code generation fixedpoint dsps delta 9 prove existence optimal linear time scheduling algorithm class dsp architectures acyclic rtgs let expression tree unary binary operations let function maps nodes set rm set n registers set memory locations let u root expression tree v 1 children u consider allocation performed registers lv 1 assigned v 1 respectively 2 subtrees rooted v 1 figure 4 terms expression tree allocated expression tree used interchangeably context distinguishing tree allocated 421 allocation deadlock definition 1 expression tree contains allocation deadlock iff following conditions true lv 1 c exist nodes w 1 w 2 w 2 lw 1 definition visualized figure 4 situation two sibling subtrees 1 2 contain least one node allocated register register assigned root sibling tree using definition possible propose following result fig 4 allocation deadlock expression tree theorem 1 let expression tree spill free schedule contains least one subtree allocation deadlock proof assume nodes u u free allocation deadlocks valid schedule exist according definition 1 u allocation deadlock case snf schedule exists subtree 1 scheduled first followed subtree case cannot happen since nonunary operator expression tree takes two operands simultaneously location b c fig 5 trees without allocation deadlock c exist lw 2 case possible schedule 1 first followed 2 instruction corresponding node u valid schedule schedule 1 finished register r 1 live therefore since register r 1 exists resource conflict occur subtree scheduled figure 5a exist lw 1 symmetric previous case schedule 2 first followed 1 instruction corresponding u figure 5b exist case trivial sc schedule results spill free schedule figure 5c since conditions applied node u valid schedule free memory spilling code contradicts initial assumption corollary 1 let expression tree subtree containing allocation deadlock must spill free schedule moreover schedule computed using proof theorem 1 proof directly theorem 422 rtg model theorem definition 2 rtg directed labeled graph node represents location datapath architecture data stored edge rtg node r node r j labeled instructions isa take operands location r store result location r j nodes rtg represent two types storage register files single registers register file nodes represent set locations type store multiple operands datapath single register simply single register register file unitary capacity register file nodes distinguished single register nodes means double circle uniqueness memory described rtg arrows used instead represent memory operations incoming outgoing arrow pointing rtg node r associated code generation fixedpoint dsps delta 11 load store operation memory notice rtg labeled graph edge labels corresponding instructions require operation words instructions p q take one operand r store result r j edge r r j least two labels p q say architecture rtg acyclic contains cycles consequence register transfer cycle acyclic rtg go memory 1 example 2 consider example partial olive description figure 2 rtg figure 6 formed description numbers parenthesis right side figure 2 used label edge graph isa instructions target processor represented description figure 2 therefore edges rtg figure 6 labeled notice rtg tms320c25 architecture acyclic dsp processors also acyclic rtgs like processors tms320c1xc2xc5x fujitsu fdsp4 paper proposes solution code generation acyclic rtg architectures unfortunately known dsps like adsp2100 motorola 56000 cyclic rtgs nevertheless shown later code generation processors also benefit results work p123 fig 6 tms320c25 architecture acyclic rtg theorem 2 architecture rtg acyclic expression tree exists schedule free memory spills proof let expression tree rooted u v 1 children lv 2 let 1 2 subtrees rooted nodes let p k subtrees root p k result operation p k stored memory ie lp k dark areas figure 7 subtrees formed removing nodes subtrees p k show rtg acyclic optimal schedule always determined properly ordering schedules p k eg p 1 address two cases assume allocation deadlock therefore corollary 1 optimal schedule b consider allocation deadlock present caused registers r 1 r 2 shown figure 7 assume also exist paths r 2 r 1 processor rtg observe node 2 figure 7 allocated r 1 eg w 2 path goes w 2 ancestor v 2 allocated 1 observe selfloop considered rtg cycle wp fig 7 rtg theorem necessarily pass node allocated memory eg p 2 comes fact path r 1 r 2 traverse memory given rtg acyclic contains paths r 2 r 1 notice one recursively schedule subtrees p 2 p 4 2 root allocated memory corresponds emitting advance instructions store results done memory locations live remaining subtree q 2 contains instruction uses r 1 nodes remain scheduled subtrees 1 therefore tree 1 fug scheduled using corollary 1 spill required notice result obtained one first recursively schedules subtrees p 1 white areas figure followed applying corollary 1 schedule subtree q 1 fug based proof theorem 2 algorithm designed computes best schedule expression tree acyclic rtg architecture designed algorithm named optschedule theorem 3 algorithm optschedule optimal running time n number nodes subject tree proof first part trivial since optschedule implements proof theorem 2 also theorem 2 algorithm divides set disjoint subtrees recursively schedules therefore every node visited hence algorithm running time remark 1 rtg acyclic particular architecture optimal sequential code guaranteed expression tree compiled programs running architecture unfortunately true architectures code generation fixedpoint dsps delta 13 acyclic rtgs nevertheless expression trees architectures also benefit work observe corollary 1 expression tree free allocation deadlocks optimally scheduled valid expression tree generated architecture matter architecture acyclic rtg consider example path added p rtg figure 6 creates cycle architecture rtg go memory hand expression tree use new path free allocation deadlocks therefore still optimally scheduled expression trees could identified simple modification instruction selection algorithm question many trees exist typical program still open though 5 heuristic dags instruction selection expression dag requires dag covering known npcomplete garey johnson 1979 practical solutions problem heuristics proposed divide dag component trees selecting appropriate set trees however dismanteling dag component trees unique several ways done traditionally heuristic employed case homogeneous register architectures disconnect multiple fanout nodes dag aho et al 1988 dividing dag component trees requires disconnecting breaking edges dag code generation task breaking dag edge nodes u v implies allocation temporary storage save result operation u consumed operation v storage location traditionally memory general location datapath key idea proposed heuristic uses architectural information rtg selection component trees dag resulting code minimal spills consider example dag figure 8 notice two different approaches used decompose dag component trees depending edge e 1 e 2 selected break represent broken edge line segment traversal subject edge one see figure 8b one extra instruction generated dismanteling heuristic based breaking edge e 2 instead e 1 incidentally code figure 8a also best sequential code one generate subject dag observe architectural description table 1 multiplication operation requests operands memory result addition operation always produce result accumulator notice also figure 6 bring data register one go figure 8 one see result addition operation stored must moved order used operand multiplication operation move data one go memory suppose memory position selected store temporary result 5 hence breaking dag edge e 1 one assigning advance memory operation appear edge instruction selection phase code generation notice existence registertransfer path always goes memory whenever data moved property target datapath similarly registertransfer 14 delta guido araujo sharad malik lac m2 m2 lac m2 m2 add m3 sacl m5 m5 sacl m5 m5 mpy m5 p m5 add m4 add m4 mpy m5 p m5 b fig 8 breaking edge e 1 breaking edge e 2 path p must also pass memory notice also edge e 2 broken pattern plusam instruction add 4 cannot used match addition 4 result 2 accumulator case instruction lac 5 figure 8b issued order bring data 5 back accumulator adding new instruction final code 1 1 1 2 fig 9 expression dag partial register allocation performed natural pseudonatural edges identified corresponding lemma code generation fixedpoint dsps delta 15 51 problem solution heuristic propose address problem described divided four phases first phase section 511 partial register allocation done datapath operations clearly allocated code generation task performed dag second phase section 512 architectural information employed identify special edges dag broken without introducing loss optimality subsequent tree mapping stages third phase section 52 edges marked disconnected dag finally component trees scheduled optimal code generated component tree section 52 511 partial register allocation general property heterogeneous register architectures results specific operations always stored well defined datapath locations imply total register allocation data routed datapath locations required instructions take example operations add mul target processor notice implicitly define primary storage resources used operation result case observe table 1 register allocation task required determine registers p respectively used store immediate result operations add mul thus partial allocation performed well advance even task breaking edges expression dag takes place observe possible operation always uses register file store immediate result consider example expression dag figure 9 notice partial register allocation immediately performed registers p 512 natural edges saw figure 8 edges specific properties originating target architecture allow us disconnect dag without compromising optimality edges termed natural edges defined follows definition 3 instruction selection matching edge u v always produces sequence data transfer operations datapath pass memory edge u v referred natural edge b r fig 10 natural edges identified single line segment u v natural b u v natural r selfloop rtg given expression dag target architecture acyclic rtg shown number edges natural edges order let us state set lemmas let r 1 r 2 pair registers datapath acyclic rtg architecture also let function maps nodes set datapath locations r r set registers datapath set memory positions lemma 1 let r 1 r 2 registers architecture rtg exist path r 1 r 2 therefore edge u v natural edge proof given path registers r 1 r 2 traversed whenever instruction selection performed edge u v memory operation always selected instruction selection u v therefore u v natural edge figure 10a lemma 2 edges u v natural edges selfloop exists register node r rtg representation target architecture figure 10b proof architecture acyclic rtg loop rtg selfloop traverse memory thus register r selfloop rtg loop starting r go memory therefore memory operation selected whenever instruction selection performed edge u v hence u v natural edge notice task breaking natural edges introduce new operations dag name implies instruction selection phase memory operation naturally selected due constraints architecture datapath topology result potential optimality lost breaking natural edges example 3 consider one lemmas rtg figure 6 observe expression dag figure 9 natural edges identified 1 lemma 1 see r 1 r 2 every edge u v natural edge 2 consider lemma 2 first take situation r rtg figure 6 observe register p selfloop since rtg acyclic dag edge u v natural edge consider case r register figure 6 contains selfloop thus nothing said regarding edges 513 pseudonatural edges following two lemmas show dag edges sometimes interact one edge set two edges must result storage memory edges set called pseudonatural edges lemma 3 consider operation v operand nodes u w figure 11a partial register allocation operations w v pseudonatural edges proof notice binary operation v take operands simultaneously register consider two situations code generation fixedpoint dsps delta 17 w b r r fig 11 selected pseudonatural edges identified double line segment one edges uses loop rtg b one edges goes memory node r selfloop architecture rtg one edges eg could matched instruction takes one operand r hand instruction matches edge ie w v make use register contained rtg loop selfloop goes r back r similarly lemma 2 matching w v introduce sequence transfer operations necessarily goes memory making w v u v pseudonatural edges b selfloop node r exists architecture rtg edges natural edges according lemma 2 lemma 4 consider operation v operand nodes u w figure 11b let partial register allocation nodes rtg paths pair nodes one path go memory u v w v pseudonatural edges proof proof trivial follows fact since operation v cannot take operands register r j time use two paths rtg bring data register r j since one path r j r go memory path pass memory based lemmas need decide edge u v w v disconnected dag loss optimality might occur depending edge selected selected pseudonatural edge identified using double line segment distinguish natural edges unlike natural edges breaking pseudonatural edges might result compromising optimality code generation component trees however good chance might happen actual practice example 4 consider lemmas 3 4 rtg figure 6 observe expression dag figure 9 pseudonatural edges identified lemma 3 satisfied case r 4 case r one path exists rtg p go memory rules 14 examples 3 4 applied expression dag figure 9 results marked edge figure 9 side number corresponding rule used examples 3 4 52 dismanteling algorithm task dismanteling expression dag may potentially introduce cyclic read write raw dependencies resulting tree components leading impossible schedule similar problem also encountered aho et al 1977a liao et al 1995 authors studied problem scheduling worm graphs derived dags singleregister architectures consider example b fig 12 cyclic raw dependency b constraining tree scheduler reconvergent paths nodes u v component trees 1 2 figure 12a dismanteling dag figure 12a requires least one edges multiple fanout nodes u 2 disconnected assume edges selected edges break case nodes u v tree 1 collapsed single component tree 3 dismanteling dag trees 3 4 edge two nodes broken raw edge introduced dashed lines figure 12 order guarantee original datadependencies preserved scheduler case resulting raw edges form cycle component trees 3 4 results infeasible schedule component trees notice dismanteling also possible edge 2 w broken instead figure 12b occurs raw edge u 2 brought resulting component tree 3 consequence potential optimality tree scheduler algorithm optschedule guaranteed anymore since satisfy constraint imposed new raw edge inside 3 possible solution problem modify tree scheduler algorithm satisfy raw constraint inserted tree unfortunately difficult task efficient solution seems exist hence dismantle dag avoid inserting raw edges component trees two situations analyzed conclude edges reconvergent paths disconnected order guarantee proper scheduling code generation fixedpoint dsps delta 19 operations inside component trees component trees algorithm dismantles dag disconnect edges using many natural pseudonatural edges possible designed algorithm call dismantle dismantle algorithm starts first breaking natural edges since breaking edges adds cost total cost final code dismantle proceeds identifying reconvergent paths traverses paths dag looking edges marked pseudonatural edges pseudonatural edge used break existing reconvergent path edge broken otherwise outgoing edge starts reconvergent path corresponding multiple fanout node broken edges marked black dot figure 13 point reconvergent paths expression dag disconnected additional edges broken node ends one outgoing edge edges also marked black dots resulting dag applying algorithm dismantle shown figure 13 decomposes original dag five expression trees finally expression trees scheduled code generated expression tree fig 13 resulting component trees dismanteling 6 experimental results dspstone zivojnovic et al 1994 benchmark designed evaluate code quality generated compilers different dsp processors dspstone divided three benchmark suites application dspkernel ckernel application benchmark consists program adpcm wellknown speech encoding algorithm dspkernel benchmark consists number code fragments cover often used dsp algorithms ckernel suite aims test typical c program statements dspstone project supported number major dsp manufacturers analog devices att motorola nec texas instruments used benchmark experimental evaluations scheduling algorithms tree origin leftfirst rightfirst optschedule real update 5 5 5 3 dot product 8 8 8 6 iir one biquad table 2 number cycles compute expression trees using rightleft leftright optschedule 61 expression trees applied algorithm optschedule expression trees extracted programs dspkernel benchmark metric used compare code number cycles takes compute expression tree observe table 2 algorithm optschedule produces best code compared two sc schedules expected since proved opti mality notice although sc schedules sometimes produce optimal code also generate bad quality code case expression tree 6 also verify expression tree generates different code quality different sc schedules used structure expression tree dictates best sc schedule structure function way programmer writes code 62 dag types distribution expression dags classified trees leaf dags full dags leaf dags dags leaf nodes outdegree greater one classify dag full dag neither tree leaf dag one see table 3 classification revealed basic blocks analyzed 56 trees dsp kernel basic blocks trees leaf dags dags real update dot product iir one biquad 1 convolution lms table 3 types dags found typical digital signal processing algorithms code generation fixedpoint dsps delta 21 dag dag handwritten standard dismantle origin type code heuristic heuristic complex update f matrix 1x3 l 5 5 0 5 0 iir one biquad f 15 17 13 convolution lms f 7 9 28 8 14 table 4 experiments dags leaf dag l full dag 38 leaf dags 6 full dags set benchmarks table 3 noticed majority basic blocks found programs trees leaf dags another experiment performed time using dspstone application benchmark adpcm basic blocks analyzed determine frequency trees leaf dags dags case 94 basic blocks program found trees 3 leaf dags 3 full dags although dynamic counting basic blocks required order provide information impact execution time one reasonably argue large portion program execution time spent processing expression trees thus treebased code generation suitable application domain 63 expression dags table 4 list series expression dags extracted programs dspkernel benchmark selected largest dag found kernel purpose comparison handwritten code handwritten assembly code assembly reference code dspkernel program available dspstone benchmark suite zivojnovic et al 1994 compiled code generated dag resulting number cycles single loop execution reported table 4 compiled code also generated using standard heuristic dismantles dag breaking edges multiple fanout nodes column standard heuristic table 4 shows number processor cycles overhead respect handwritten code notice overhead due dag dismanteling technique average overhead comparing compiled dismantle heuristic assembly reference code 7 leaf nodes treated way heuristics simply duplicated different nodes one outgoing edge consequence heuristics performance case leaf dags average overhead dismantle heuristic case full dags higher 11 case leaf dags 4 discrepancy due existence memoryregister immediate instructions processor isa zero cost multiple fanout operands memory references constant values although heuristic gains may seem small every byte matters since dsps restricted onchip memory size makes generation high 22 delta guido araujo sharad malik quality code important goal compiler 7 conclusion increasing demand wireless multimedia systems expected usage dsps continue grow inspite research compiling techniques dsps received adequate attention devices continue offer new research challenges originate need high quality code low cost power consumption proposed optimal instruction selection register allocation instruction scheduling algorithm expression trees class heterogeneous register dsp architectures acyclic rtgs extend proposing heuristics case basic blocks dags approach based concept natural pseudonatural edges seeks use architectural information help task dismanteling expression dag forest trees question generate good code architectures cyclic rtgs remains open though mentioned expression trees generated architectures also benefit optimality provided free allocation deadlock interesting question follows many expression trees property generated programs running architectures work way order answer questions acknowledgments research supported part brazilian council research development cnpq contract 204033870 institute computing unicamp brazil r code generation using tree matching dynamic programming optimal code generation expression trees code generation expressions common subexpressions code generation machineswith multireg ister operations generalizations sethiullman algorithm register allocation optimal code generation embedded memory nonhomogeneous register architectures using registertransfer paths code generation heterogeneous memoryregister architectures code generation oneregister machine instructions sets evaluating arithmetic expressions journal acm engineering simple computers intractability pattern matching trees data routing paradigm efficient datapath synthesis code generation dsp processor fundamentals architectures features programmable dsp architectures part programmable dsp architectures part ii instruction selection using binate covering marwedel goosens efficient computation expressions common subexpressions complete register allocation problems generation optimal code arithmetic expressions journal acm 17 digital signal processing applications tms320 family olive twig optimal code generation signal flow computation automatic instruction code generation based trellis diagrams circuits systems tr compilers principles techniques tools generalization sethiullman algorithm register allocation code generation using tree matching dynamic programming digital signal processing applications tms320 family vol 2 optimal code generation embedded memory nonhomogeneous register architectures instruction selection using binate covering code size optimization optimal register assignment loops embedded code generation using registertransfer paths code generation heterogeneous memoryregister architectures data routing treebased mapping algorithms predefined structures generation optimal code arithmetic expressions generation optimal code stack machines optimal code generation expression trees code generation oneregister machine code generation expressions common subexpressions efficient computation expressions common subexpressions pattern matching trees instruction sets evaluating arithmetic expressions codegeneration machines multiregister operations code generation embedded processors computers intractability ctr jeonghun cho yunheung paek david whalley fast memory bank assignment fixedpoint digital signal processors acm transactions design automation electronic systems todaes v9 n1 p5274 january 2004 jeonghun cho yunheung paek david whalley efficient register memory assignment nonorthogonal architectures via graph coloring mst algorithms acm sigplan notices v37 n7 july 2002 alain pegatoquet emmanuel gresset michel auguin luc bianco rapid development optimized dsp code high level description software estimations proceedings 36th acmieee conference design automation p823826 june 2125 1999 new orleans louisiana united states shuvra bhattacharyya praveen k murthy cbp parameter module characterization approach dsp software optimization journal vlsi signal processing systems v38 n2 p131146 september 2004 minwook ahn jooyeon lee yunheung paek optimistic coalescing heterogeneous register architectures acm sigplan notices v42 n7 july 2007
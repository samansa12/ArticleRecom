probabilistic symbolic model checking prism hybrid approach paper present efficient symbolic techniques probabilistic model checking implemented prism tool analysis probabilistic models discretetime markov chains continuoustime markov chains markov decision processes using specifications probabilistic temporal logics pctl csl motivated success model checkers smv use bdds binary decision diagrams developed implementation pctl csl model checking based mtbdds multiterminal bdds bdds existing work direction hindered generally poor performance mtbddbased numerical computation often substantially slower explicit methods using sparse matrices focus paper novel hybrid technique combines aspects symbolic explicit approaches overcome performance problems typical examples achieve dramatic improvement purely symbolic approach addition thanks compact model representation using mtbdds verify systems order magnitude larger sparse matrices almost matching even beating speed b introduction design analysis software hardware systems often desirable even necessary include probabilistic aspects systems behaviour examples include representing unreliable unpredictable behaviour faulttolerant systems deriving ecient algorithms using electronic coin ipping decision making modelling arrivals departures calls wireless cell probabilistic model checking refers range techniques calculating likelihood occurrence certain events execution systems exhibit behaviour one rst constructs probabilistic model system properties shutdown occurs probability 001 less video frame delivered within 5ms probability 097 greater expressed probabilistic temporal logics model checking algorithms supported part epsrc grant grm04617 mathfit studentship david parker jp katoen p stevens eds 8th international conference tools algorithms construction analysis systems tacas02 volume 2280 lncs pages 5266 2002 c springerverlag berlin heidelberg 2002 marta kwiatkowska gethin norman david parker developed automatically verify whether model satises properties motivated success symbolic model checkers smv 28 use bdds binary decision diagrams 11 developed symbolic probabilistic model checker nonprobabilistic setting model checking involves analysing properties state transition systems manipulation sets states entities represented naturally bdds often compactly 13 probabilistic case since probability transition matrices probability vectors required bdds alone sucient hence also use mtbdds multiterminal binary decision diagrams 17 3 natural extension bdds representing realvalued functions symbolic probabilistic model checking considered number people 5 21 4 26 19 23 7 25 27 shown feasible use mtbdds construct compute reachable state space extremely large structured probabilistic models cases often also possible verify qualitative properties model checking reduces reachabilitybased analysis example 19 systems 10 states veried model checking quantitative properties hand involves numerical computation cases 27 mtbdds successful applied systems states often however turns computation slow infeasible way comparison also implemented equivalent numerical computation routines explicitly using sparse matrices cases nd sparse matrices orders magnitude faster present novel hybrid approach uses extensions mtbdd data structure borrows ideas sparse matrix techniques overcome performance problems include experimental data demonstrates using hybrid approach achieve speeds orders magnitude faster mtbdds fact almost match speed sparse matrices whilst maintaining considerable space savings outline paper follows section 2 gives overview probabilistic model checking introducing probabilistic models temporal logics consider section 3 describe tool prism implements model checking move discuss implementation section 4 introduces mtbdd data structure explains used represent analyse probabilistic models identify number performance problems implementation section 5 describe overcome limitations section 6 present experimental results analyse success technique section 7 concludes paper model checking section brie summarise three probabilistic models two temporal logics prism supports simplest probabilistic model discretetime markov chain dtmc species probability ps 0 making transition state target state 0 proba probabilistic symbolic model checking prism hybrid approach 3 bilities reaching target states given state must sum 1 ie decision processes mdps extend dtmcs allowing probabilistic nondeterministic behaviour formally state nondeterministic choice number discrete probability distributions states nondeterminism enables modelling asynchronous parallel composition probabilistic systems permits underspecication certain aspects system continuoustime markov chain ctmc hand species rates rs 0 making transition state 0 interpretation probability moving 0 within time units positive real valued 1 e rss 0 probabilistic specication formalisms include pctl 20 10 8 probabilistic extension temporal logic ctl applicable context mdps dtmcs logic csl 7 specication language ctmcs based ctl pctl allows us express properties form scheduling processes probability event occurs least p p way illustration consider asynchronous randomized leader election protocol itai rodeh 24 gives rise mdp algorithm processors asynchronous ring make random choices based coin tosses attempt elect leader use atomic proposition leader label states leader elected examples properties would wish verify expressed pctl follows p1 leader fair scheduling leader eventually elected probability 1 fair scheduling probability electing leader within k discrete time steps 05 specication language csl includes means express transient steadystate performance measures ctmcs transient properties describe system xed realvalued time instant whereas steadystate properties refer behaviour system long run example consider queueing system atomic proposition full labels states queue full csl allows us express properties probability queue becomes full within time units 001 long run chance queue full least 098 model checking algorithms pctl introduced 20 10 extended 8 4 include fairness algorithm csl rst proposed 7 since improved 6 25 model checking algorithms logics reduce combination reachabilitybased computation manip ulation sets states numerical computation former corresponds nding states satisfy formula study probability exactly 0 1 latter corresponds calculating probabilities remaining states dtmcs entails solution linear equation system 4 marta kwiatkowska gethin norman david parker modules parser parser hybrid engine sparse engine engine results statesprobabilities cudd mtbdd properties system description prism kernel fig 1 prism system architecture mdps solving linear optimisation problem ctmcs either solution linear equation system standard technique known uniformisation numerical problems typically large application direct methods instead iterative techniques approximate solution specied accuracy used 3 tool prism tool developed university birmingham supports model checking described previous section tool takes input description system written prisms system description language probabilistic variant reactive modules 1 rst constructs model description computes set reachable states prism accepts specications either logic pctl csl depending model type performs model checking determine states system satisfy specication reachabilitybased computation performed using bdds numerical analysis however choice three engines one using pure mtbdds one based conventional sparse matrices third using hybrid approach present paper figure 1 shows structure tool figure 2 shows screenshot graphical user interface prism written combination java c uses cudd 32 publicly available bddmtbdd library developed university colorado boulder highlevel parts tool user interface parsers written java engines libraries written c tool source code along information system description language case studies available prism web page 31 4 mtbdd implementation describe implementation tool fundamental data structures prism mtbdds bdds mtbdds used represent three supported models dtmcs mdps ctmcs furthermore algorithms construction analysis models implemented probabilistic symbolic model checking prism hybrid approach 5 fig 2 prism graphical user interface using data structures section summarise done discuss performance introduction mtbdds xn set distinct totally ordered boolean variables mtbdd directed acyclic graph vertex set vn partitioned nonterminal terminal vertices nonterminal vertex vn labelled variable var v 2 fx two children labelled real number val v impose boolean variable ordering onto graph requiring child w nonterminal vertex v either terminal nonterminal satises var v varw mtbdd represents function fm ir value fm determined traversing root vertex following edge vertex v thenv elsev varv 1 0 respectively note bdd merely mtbdd restriction labels terminal vertices 1 0 mtbdds ecient stored reduced form vertices v w identical ie elsew one stored furthermore vertex v satisifes elsev removed incoming edges redirected unique child one important factors mtbdds practical point view size number vertices heavily dependent ordering boolean variables although worst case size mtbdd representation exponential problem deriving optimal ordering given mtbdd npcomplete problem applying heuristics minimise 6 marta kwiatkowska gethin norman david parker graph size mtbdds provide extremely compact storage realvalued functions mtbdd represention probabilistic models inception 17 3 mtbdds used encode realvalued vectors matrices mtbdd variables real vector v length 2 n simply mapping reals ir hence decide upon encoding terms fx example standard binary encoding mtbdd represent v similar fashion consider square matrix size 2 n 2 n mapping ir taking boolean variables range row indices fy range column dices represent mtbdd fx g dtmcs ctmcs described matrices hence also straightforward represent mtbdds case mdps complex since need encode nondeterministic choices maximum number nondeterministic choices state bounded 2 k integer k view mdp function ir adding k extra boolean variables encode third index represent mdp mtbdd figure 3 shows example ctmc rate matrix ctmc includes one state unreachable explained section 5 figure 4 gives mtbdd represents ctmc table explaining con struction clarity notation mtbdds omit edges lead directly zero terminal vertex fig 3 ctmc rate matrix transition x1 x2 y1 y2 x1 y1 x2 y2 r fig 4 mtbdd representing ctmc figure 3 probabilistic symbolic model checking prism hybrid approach 7 observe figure 4 row column variables ordered alternately one common variable ordering heuristics minimise mtbdd size achieve compact mtbdd representations probabilistic systems ever must also consider actual encoding row column indices boolean variables well known rule thumb try preserve structure entity represented 23 practice accomplished performing direct translation highlevel description model case prism system description language mtbdds presented scheme 19 fast lead compact encoding probabilistic systems resulting variable ordering encodes unreachable states well reachable states hence reachability analysis via simple bdd xpoint calculation must performed identify experimental data presented section 6 reasons space include statistics two typical examples rstly mdp model coin protocol aspnes herlihys randomized consensus algorithm 2 parameterised n number processes additional parameter k xed 4 secondly ctmc model kanban manufacturing system 16 parameterised n number pallets system figure 8 gives memory requirements storing models compare mtbdd sparse columns signicant savings memory achieved using symbolic scheme described explicit storage method examples demonstrate result see prism web page 31 probabilistic model checking mtbdds implemented entire model checking procedure pctl csl mtbdds bdds saw section 2 essentially reduces combination reachabilitybased computation numerical calculation former performed bdds forms basis nonprobabilistic symbolic model checking proven successful 13 28 latter involves iterative numerical methods based matrixvector multiplication operation ecient mtbdd algorithms introduced 3 17 fact alternative direct methods gaussian elimination simplex could applied problems shown unsuitable mtbdd implementation 3 26 rely modifying model representation operations individual rows columns elements slow leads loss regularity subsequent explosion mtbdd size results implementation mtbdds summarised fol lows clear distinction two dierent aspects model checking reachabilitybased computation sucient model checking qualitative properties implemented eciently bdds shown 19 27 numerical computation required checking quantitative properties unpredictable problem focus found number case studies mtbbds outperform explicit techniques numerical computation one example coin 8 marta kwiatkowska gethin norman david parker protocol introduced previously include results model top half figure 9 compare columns mtbdd sparse would impossible even store sparse matrix larger examples assuming reasonable amount memory found pattern hold several mdp case studies considered examples illustrate found prism web site 31 include byzantine agreement protocol ieee 1394 firewire root contention protocol second class models namely ctmcs nd symbolic implementation numerical iterative methods far ecient despite compact mtbdd representation model process generally slow infeasible ineciency caused mtbdd representation iteration vectors becoming large vectors represented compactly mtbdds main requirement limited number distinct elements however general performing numerical analysis iteration vector quickly acquires almost many distinct values states system study figure 9 shows contrast performance mtbdds kanban ctmc coin protocol mdp sparse matrix based implementation much faster 5 hybrid approach present method overcome ineciencies mtbdds outlined previous section recall sparse matrix techniques yield extremely fast numerical computation since iteration vector stored full array remains constant size single matrixvector multiplication carried traversing sparse matrix extracting nonzero entries needed exactly compute new iteration vector unfortunately since probabilistic model also stored explicitly application large examples often limited memory constraints approach taken use hybrid two techniques mtbdds sparse matrices store transition matrix mtbddlike data structure use full array iteration vector perform matrixvector multiplication hence iterative methods using two data structures key dierence hybrid approach need extract nonzero matrix entries mtbdd rather sparse matrix clarity presentation focuses case ctmcs solve linear equation system iterative methods compute steadystate probabilities also applied techniques dtmc mdp models restrict certain iterative methods namely power jacobi jor matrix entries extracted order perform iteration means proceed via recursive traversal mtbdd matter enumerate entries essentially random order rather rowbyrow columnbycolumn sparse matrix probabilistic symbolic model checking prism hybrid approach 9 since matrix indices encoded standard binary representation integers trivial keep track row column index traversal noting whether else edge taken point summing appropriate powers 2 unfortunately number problems naive approach resolve make number modications mtbdd data structure modifying mtbdd data structure first recall section 4 get ecient mtbdd representation transition matrix must contain unreachable states performing matrixvector multiplication described mtbdd would require vector array store entries states including unreachable number unreachable states potentially large cases orders magnitude larger reachable portion puts unacceptable limits size problem handle solution adopt augment mtbdd vertex labels integer osets used compute actual indices matrix elements terms reachable states recursive traversal figure 5 illustrates idea example section 4 included unreachable state left modied mtbdd representing transition matrix r ctmc table right explains traversal process works row corresponds single matrix entry transition rst columns describe path taken mtbdd next four columns give vertex osets along path last column gives resulting matrix entry figure 6 give actual traversal algorithm would called follows traverserecroot 0 0 root toplevel vertex mtbdd path osets transition fig 5 modied mtbdd representing ctmc figure 5 key idea indices computed summing osets vertexs oset added leaving edge vertex note row column indices computed independently rows osets x vertices columns osets vertices example consider last line table take path mtbdd leads 7 terminal vertex use osets levels x 1 x 2 2 exited via edges row index 2 column index 1 obtain marta kwiatkowska gethin norman david parker traverserecv row col v nonzero terminal vertex found matrix element row elseif v row vertex traverserecelsev row col elseif v row vertex traverserecelsev row col traverserecthenv row col endif fig 6 hybrid traversal algorithm matrix entry 2 7 note references state 3 figure 4 changed state 2 figure 5 since three reachable states two points consider conversion mtbdd figure new form figure 5 first note vertices mtbdd reached along several dierent paths shared vertices correspond repeated submatrices overall matrix consider matrix figure 3 mtbdd representation figure 4 bottomleft topright quadrants matrix identical since rows columns unreachable states lled zeros ected fact x 2 vertex mtbdd two incoming edges two identical submatrices however share pattern reachable states means potential clash oset label vertex resolve adding extra copies vertex necessary labelled dierent osets note additional two vertices right hand side figure 5 eectively modied condition two mtbdd vertices merged requiring level identical children also oset label noted transform mtbbd use many iterations required discard hence need able traverse data structure manipulate way second point make conversion involves skipped levels mtbdd vertex identical children omitted save space causes potential problems must careful detect traversal fact solution adopt perform check initial conversion replace skips extra vertices allows us ignore issue entirely traversal makes process faster example figure 5 note extra x 2 vertex left hand side exception rule allow edges skip vertex directly zero terminal vertex since interested nonzero entries probabilistic symbolic model checking prism hybrid approach 11 optimising approach optimise method considerably via form caching mtbdds exploit structure model analysed giving signicant space saving achieved identical vertices representing identical submatrices merged stored traversal however shared vertices visited several times many times submatrix occurs overall matrix entries submatrix computed every time storing reusing results computation achieve signicant speedup traversal time rather store results cache would need searched frequently simply attach information directly mtbdd ver tices select subset vertices build explicit sparse matrix representations associated submatrices attach mtbdd obvious tradeo additional space required store data resulting improvement speed space required time improvement depend many vertices ones attach matrices experiences good policy replace vertices one fairly low level mtbdd figure 7 demonstrate technique running example replacing vertices x 2 level matrices represent practice nd caching improve traversal speed order magnitude next section give experimental results implementation includes techniques described 0 2fig 7 modied mtbdd labelled explicit submatrices 6 results section present experimental results obtained prism tool compare performance three implementations discussed paper pure mtbdds sparse matrices hybrid approach focusing problem iterative numerical computation figure 8 give storage requirements coin protocol kanban models introduced earlier compare size mtbdd sparse matrix modied mtbdd used hybrid approach without optimisation section 4 observed signicant advantage mtbdds sparse matrices note even storing oset information extra vertices explicit submatrices hybrid approach remains memory ecient 12 marta kwiatkowska gethin norman david parker model n states memory kb mtbdd sparse hybrid hybrid opt coin 4 43136 285 2265 567 698 protocol 6 2376448 612 173424 933 314 kanban 4 454475 957 48414 171 231 system 5 2546432 123 296588 219 337 6 11261376 154 1399955 272 486 fig 8 storage requirements coin protocol kanban examples model n states iters time per iteration sec mtbdd sparse hybrid hybrid opt coin 4 43136 6133 0173 0034 007 0039 protocol 6 2376448 12679 101 1741 558 302 kanban 4 454475 466 0436 609 0502 system 5 2546432 663 276 334 3150 fig 9 model checking times coin protocol kanban examples furthermore time adding information mtbdd cases negligle compared model checking figure 9 present model checking times two case studies coin protocol verify quantitative pctl property requires solution linear optimisation problem kanban system model check quantitative csl property requires computation steadystate probabilities via solution linear equation system use jor iterative method experiments run 440 mhz sun ultra 10 workstation 1 gb memory iterative methods terminated relative error subsequent iteration vectors less 10 6 remarked section 4 coin protocol model many mdp models ecient mtbdds problem try address hybrid approach typied kanban example mtbdds alone inecient using techniques presented paper able consider larger models sparse matrices furthermore using optimised version almost match speed sparse matrices ctmc case studies considered queueing networks workstation clusters conrm results details found prism web page 31 probabilistic symbolic model checking prism hybrid approach 13 related work aware three probabilistic model checking tools probverus 21 mtbddbased model checker supports dtmcs subset pctl tool emc 2 22 supports model checking ctmcs csl specications using sparse matrices tool described 18 uses abstraction renement perform model checking subset pctl mdps number sparsematrix based dtmc ctmc tools marca 33 allow logic specications support steadystate transient analysis area research close links work kronecker approach 30 technique analysis large structured ctmcs dtmcs basic idea matrix full system dened kronecker algebraic expression smaller matrices correspond subcomponents overall system necessary store small matrices structure kronecker expression iterative solution methods applied matrix form approach storage requirements matrix relatively small ingenious techniques must developed minimise time overhead required numerical solution tools support kronecker based methods include apnn 9 smart 14 particular smart incorporates matrix diagrams 15 data structure developed ecient implementation kronecker techniques matrix diagram approach much common hybrid method present paper particular methods use decisiondiagram like data structure storing matrices full array store vectors key dierence matrix diagrams tied kronecker representation require work extract transition matrix entries addition traversing data structure computation matrix elements requires multiplication entries smaller matrices another important dierence kronecker matrix diagram approaches permit use ecient iterative methods gaussseidel approach presently support hence although less work per iteration may require iterations using methods addition gaussseidel implemented single iteration vector whereas methods jacobi jor require two one issue unites kronecker approach matrix diagrams method limiting factor space required store iteration vector however compact matrix representation memory proportional number states required numerical solution buchholz kemper consider interesting technique 12 using pdgs probabilistic decision graphs attempts store iteration vector structured way done matrix investigation required discover potential approach 14 marta kwiatkowska gethin norman david parker 7 conclusion introduced prism tool build analyse probabilistic systems supports three types models dtmcs mdps ctmcs two probabilistic logics pctl csl well mtbdd sparse matrix based model checking engines prism includes novel hybrid engine combines symbolic explicit approaches shown large probabilistic systems constructed analysed using mtbdds often numerical computation inecient hybrid approach addresses performance problems allowing verication acceptable speed much larger systems would feasible using sparse matrices details available 29 one problem current techniques presently support power jacobi jor iterative methods plan extend work allow rapidly converging alternatives gaussseidel krylov methods used development prism ongoing activity near future intend consider extensions pctl expressing expected time long run average properties csl include rewards expand prism input language allow process algebra terms develop model checking engines prism work parallel distributed setting r reactive modules fast randomized consensus using shared memory algebraic decision diagrams applications algorithmic veri symbolic model checking probabilistic processes model checking continuoustime markov chains transient analysis approximative symbolic model checking continuoustime markov chains model checking probabilistic branching time logic fairness toolbox functional quantitative analysis deds model checking probabilistic nondeterministic systems compact representations probability distributions analysis superposed gspns symbolic model checking 10 20 states beyond smart simulation markovian analyser reliability timing data structure ecient kronecker solution gspns use kronecker operators solution generalized stocastic petri nets reachability analysis probabilistic systems successive symbolic model checking concurrent probabilistic processes using mtbdds kronecker representation logic reasoning time probability probverus probabilistic symbolic model checking markov chain model checker multi terminal binary decision diagrams represent analyse continuous time markov chains symmetry breaking distributed networks faster symbolic ctmc model checking symbolic model checking concurrent probabilistic systems using mtbdds simplex automated veri symbolic model checking implementation symbolic model checking probabilistic systems stochastic structure parallelism synchronisation models distributed algorithms prism web page cudd colorado university decision diagram package marca markov chain analyser tr ctr g ciardo r l jones iii miner r siminiceanu logic stochastic modeling smart performance evaluation v63 n6 p578608 june 2006 annabelle mciver carroll morgan abstraction refinement probabilistic systems acm sigmetrics performance evaluation review v32 n4 p4147 march 2005 christel baier frank ciesinski marcus grer probmela verification markov decision processes acm sigmetrics performance evaluation review v32 n4 p2227 march 2005 christel baier frank ciesinski marcus groesser quantitative analysis distributed randomized protocols proceedings 10th international workshop formal methods industrial critical systems p27 september 0506 2005 lisbon portugal christel baier boudewijn r haverkort holger hermanns joostpieter katoen model checking meets performance evaluation acm sigmetrics performance evaluation review v32 n4 p1015 march 2005 gianfranco ciardo andrew miner implicit data structures logic stochastic systems analysis acm sigmetrics performance evaluation review v32 n4 p49 march 2005 marta kwiatkowska gethin norman david parker jeremy sproston performance analysis probabilistic timed automata using digital clocks formal methods system design v29 n1 p3378 july 2006 hkan l younes reid g simmons statistical probabilistic model checking focus timebounded properties information computation v204 n9 p13681409 september 2006
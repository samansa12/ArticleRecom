compacting discriminator information spatial trees cacheconscious behaviour data structures becomes important memory sizes increase whole databases fit main memory spatial data rtrees originally designed diskbased data adopted inmemory applications paper investigate small amount space inmemory rtree node used better make rtrees cacheconscious observe many entries share sides parents introduce partial rtree stores information given parent node experiments showed partial rtree shows per cent better performance traditional rtree also investigated could improve search performance storing descriptive information instead standard minimum bounding box without decreasing fanout rtree partial static otree based otree stores important part information otree box experiments showed approach reduces search time line data 60 per cent b introduction latest surveys shown availability cheap memory lead computer systems main memory sizes order terrabytes next 10 years bernstein et al 1998 many databases entirely main memory database technology means traditional bottleneck memorydisk latency replaced cpumemory latency crucial factor database performance therefore increasingly important database index structures algorithms become sensitive cache behaviour recent research index structures includes several papers addressing cachesensitive index struc tures rao ross 2000 authors propose pointer elimination technique btrees nodes csbtree stored contiguously therefore pointer rst child node needs stored parent pointer elimination technique extended spatial data structures paper ross et al 2001 introduced costbased unbalanced rtrees curtrees cost factors cache behaviour given architecture modeled cost function curtree built optimized respect cost function given query model prefetch instructions combination multiple size nodes assist achieve better cache behaviour chen et al 2001 methods improve space utilization compressing entries rtree nodes get wider trees kim et al 2001 values describing discriminator minimum bounding box mbb rtrees represented relatively parent number bits per value reduced mapping values coarser repre sentation problem cachesensitivity data structures complex keys addressed paper bohannon et al 2001 uses partial keys xed size paper investigate make better use inmemory spatial tree nodes eliminating unnecessary information discriminator storing descriptive information minimum bounding boxes traditionally used approximate spatial objects inmemory rtrees typically small node sizes 3 7 entries natural node size determined size cacheline observed rtrees substantial part information stored multiple times dierent levels tree often entries nodes share least one sides enclosing parent bounding box propose use partial information rtree nodes show improve space utilization performance rtrees introduce concept partial rtrees information handed parent children eliminate multiple storing values values add information entry already given parent stored node also investigate descriptive information standard minimum bounding box stored using additional space compared standard rtree partial static otree based otree sitzmann stuckey 2000 stores four values thus increasing fanout tree providing better discriminator information thus improving search structure paper follows section 2 brie describes rtrees talks inmemory use present partial rtrees section 3 describe redundant information eliminated aects insertion search section 4 describes store descriptive information entries partial otrees present experimental results section 5 concluding paper section 6 summary outlook future work section 7 using rtrees main memory 21 rtree structure rtree variants guttman 1984 beckmann et al 1990 data structure ndimensional data originally designed index diskbased data rtree node number subtrees tn 1 tn discriminator minimum bounding box tid array four side values pointer tit pointer points object identier node leaf node otherwise points another rtree node rtrees built maximum number entries per node minimum number entries per node m2 rules determine shape rtree 1 leaf nodes appear level 2 every node root node contains entries 3 root node least two entries unless leaf node insertion entry node results overfull node node split splitting algorithms linear quadratic complexity presented literature guttman 1984 beckmann et al 1990 22 dierences disk inmemory rtrees concept rtree organize spatial objects balanced search tree using minimum bounding boxes mbbs discriminators works well diskbased context io cost rtrees directly dependent number block accesses systems small mainmemory competitive compared spatial access methods approach also transfered inmemory use rtrees works similarly well respect cachebehaviour rtrees whose performance depends number cache misses occurring thus strength rtree concept diskbased inmemory use looking size rtree nodes observe expected number entries per node inmemory case signicantly smaller diskbased case page size 4 kbytes 170 entries one node regular rtree 255 use csbtechnique eliminate pointers assuming 4 byte long numbers inmemory rtrees using cacheline 64 bytes normal rtree node using 4 bytes per number store 3 en tries csbpointer elimination technique en figure 1 memory layout csbrtree node increase fanout tree case assuming bytes per number 5 entries csbtechnique 7 entries per node figure 1 shows memory layout csbr tree node node consists pointer p contiguous array child nodes counter n number entries entries e 1 e n entry e consists four sides 1 4 child nodes csbrtree node stored contiguously refer th child node tp using base pointer tp adding oset conventional rtree notation corresponds tti th child node conventional rtree node analyzing characteristics small rtree nodes make observations quite dierent large rtree nodes used diskbased data discriminator mbbs usually small entries share sides enclosing mbb increasing fanout small nodes immediate eect height tree investigate whether improve performance inmemory rtrees making use two properties stated eliminating multiply stored information 31 analyzing rtrees small nodes idea partial rtrees motivated small experiment using simple datasets lines polygons see section 5 counted many discriminators rtree share one sides parents using nodes small sizes results table 1 rtree 3 entries per node file sides shared parent avg l100000 3093 4835 1455 001 603 228 p10000 2735 2967 1872 740 1679 227 p50000 2774 2880 1009 773 1661 226 p100000 2779 2004 1912 775 1627 225 table 1 mbb sides shared parent mbb average 225 23 sides discriminator stored per entry shown last column les least 83 per cent discriminators share least one side parent propose method information parent discriminator used construct complete box show increases fanout rtree nodes resulting better search performance 32 compact rtree representation propose storing sides discriminator entry common parent consider objects depicted figure 2 o2 o3 figure 2 objects rtree node dashed line represents minimum bounding box node contains three objects o1 o2 o3 o1 shares left upper side parent need store right bottom side o2 left side needs stored three sides given parent discriminator four sides o3 must stored node entry shares side parent structure rtree node partial information therefore dynamic traditional rtree node structure instead storing four sides every discriminator store 0 4 sides per entry structure shown figure 3 bn e1 valuesbits figure 3 node structure partial rtree partial rtree node contains pointer p counter n number entries node rst part node contains sequence 4bit elds bitelds correspond entries ascending order biteld indicates sides stored node sides inherited parent actual sides stored reverse order starting end node allows us make full use space rtree node minimize copy comparison operations insertion search table 1 shows store 225 sides per discriminator assuming side 4 bytes large save corresponds bits using 4 bits per entry extra information still save 52 bits per entry partial rtree node base pointer sp number subtrees sn 1 sn 4bit array sib indicating sides dier parent discriminator remainder node array side values ss ssj j th side value node corresponding side j th true bit occurring bit elds ignore fact array stored reverse order assume sl gives number sides stored partial rtree node note actually stored node since calculated number true bits 4bit elds 33 creating partial representation given rtree node parent discriminator pd create corresponding partial rtree node mapping entry partial information using algorithm topartial ignore pointer information eectively unchanged topartialt pd sn tn else sl return discriminator tid occuring rtree node check side j versus parent discrim inator dierent corresponding side parent set corresponding bit sibj store side next available space partial rtree node sl keeps track many sides stored total 34 extracting information partial r tree read discriminator partial rtree node need combine information parent discriminator information stored node algorithm tocomplete converts partial rtree node together parent discriminator pd total rtree node ignore pointer information tocompletes pd tn sn l 0 tid pd sibj l return setting number subtrees appropriately count sides initialized bit eld examined turn discriminator initialized parent discriminator dier ent side makred true bit next side value copied rtree node returned tocomplete partial rtree node identical rtree node given topartial construct information lost important note search operations need restore entries completely rather use partial information perform search describe building partial rtrees insertion procedure object partial rtree requires extra steps compared standard rtree insertion algorithm insert describes insertion object discriminator e partial rtree discriminator pd algorithm eectively rst converts partial rtree node visited corresponding total rtree node performs insertion converts back partial rtree node nodes inserts pd e case external else return sl sr dl dr replace ti tl tr sr 6 null else return sl sr dl dr inserting object external node convert node complete node simply add entry naively new parent discriminator pd e minimal bounding box includes pd e representation node depends parent discriminator representation entries new entry may changed might need recalculated example entry previously sharing 2 sides parent might share 1 side new larger parent discriminator convert expanded total rtree node back partial rtree node full tests whether new representation large node partial rtree node full sidebits great node together bits sn pointer new representation node large node either space new entry addition caused entries longer node split use linear quadratic splitting algorithms proposed literature guttman 1984 beckmann et al 1990 algorithm split node two nodes con tainint entries available space changes passed back parent node internal nodes rst select best subtree insertion choose subtree whose discriminator shows smallest increase area insertion new entry insertion continued selected subtree results insertion lower level used recalculate new representation node note need recalculate representation node node lower split also parent discriminator changed new representation might larger parent discriminator enlarged means might split node internal level even new entry added insertion lower tree check split necessary new representation determined propagate changes parent level algorithms shown convert partial rtree nodes rtree nodes back processing ease explanation implementation conversion discriminators avoided 36 searching partial rtrees searching partial rtree need reconstruct complete entry determine whether search continue child tree instead need compare stored sides entry query know inherited sides match query claried figure 4 imagine determined query box q intersects parent discriminator pd entry discriminator e order determine checked box q lie completely pd left pd etc comparisons represented four dashed arrows order determine q intersects e need consider whether lies completely e right since comparisons already made parent box pd hence two comparisons required respect sides e shared parent e pd figure 4 reducing comparisons partial rtrees search rtree node simultaneously scanning biteld start node entries stored back node store query sides way detect mismatch entry query four comparisons l 0 match true sibj ssl qdi match false break match case entry internal node check whether stored sides clash query use bit elds determine sides stored ss refer discriminator sides know sides stored node parent discriminator therefore match query entry matches query continue search level otherwise consider next entry entry external node compare stored sides query output entry matches query search algorithm shows redundancy normal rtree occurs storing sides also comparisons partial rtrees reduce number comparisons search time reduce number sides stored entry storing better information partial rtree try improve performance rtrees eliminating redundant informa tion thus creating room entries x figure 5 approximation polygons rtree otree results increased fanout node alter natively try improve search behaviour tree using gained space store descriptive information standard minimum bounding box help lter unsuccessful search paths higher level tree paper sitzmann stuckey 2000 introduced otree constraintbased data structure stores orthogonal box addition standard bounding box give better description objects tree 41 otree approach structure otree similar rtree dierence store two minimum bounding boxes per entry conventional mbb additional mbb along axes v w leave origin angle 4 x axes values v w obtained pand 2 thus object otree described eight values representing lower upper bounds four axes x store otree discriminator array eight side values lower upper bound x axis stored sides 0 1 sides 2 3 refer axis sides 4 5 v axis sides 6 7 w axis shown figure 5 standard mbb depicted solid lines poor representation kinds data although two shaded polygons far intersecting intersection test based mbbs indicates overlap information object given describe object additional orthogonal box dashed lines using intersection boxes lack overlap two polygons clear otree representation particularly useful line data figure 6 compares area discriminator rtree otree line data sin cos figure size otree bounding box rtree bounding box line data storing 2d unit length line angle 0 8 horizontal area bounding box cos sin otree hand area intersection bounding boxes cos sin sin 2 means otree region bounding line average 2 times area rtree minimum bounding box experiments found otrees indeed improve accuracy search signicantly disadvantage otrees became also apparent store eight numbers per entry instead four fanout tree signicantly reduced therefore overall search performance could slightly improved line data intersection queries otree rst presented impractical inmemory use typical 64 bytes cacheline 2 entries node paper transfer otree approach inmemory data structures try overcome weakness otree storing four descriptive sides otree combine information information obtained parent discriminator 42 compact otree representation although eliminating shared sides also reduces number sides per discriminator otree av erage still need store four sides per discriminator fanout otree therefore still smaller standard rtree therefore apply another technique eliminate side otree discriminators add little information objects describe partial otree based complete otree representation discriminator four descriptive sides selected storage entry less four sides selected discriminator shares four sides parent node structure similar partial rtree representation e4bits 4 numbers less values figure 7 node structure partial otree node contains pointer p rst child nodes counter n bitelds form rst part remaining node partial otree case contain 8 bits indicating sides entry stored node sides stored descending order back node cases store 4 sides per entry nodes information shared parent number sides reduced compared rtree slightly space overhead one additional byte per entry used bit vector almost halved space requirements complete otree 43 selecting descriptive data partial otree node created starting complete otree node enrty repeatedly discarding least useful information representation contains 4 sides algorithm otopartial equivalent otrees topartial otopartialt pd sn tn jsibj sibj sl return otree discriminator rst eliminate sides shared parent setting bits sib false long bit eld considered set contains 4 sides repeatedly call eliminateside delete side least importance ie information set sides reduced set four sides store sides node set biteld eliminateside chooses side eliminate causes least increase area discriminator area discriminator intersection mbb orthogonal mbb discard side discriminator shows least increase area side eliminated figure shows example elimination sides depicted minimum bounding box orthogonal minimum bounding box describe object group objects part gure sides boxes stored information describes area shaded grey stored sides shown solid lines see lower upper bounds x add extra information bounds given mobb already eliminate shown part b still describe shaded area furthermore observe lower upper bounds add little information object eliminating discriminator results area slightly larger still tight approximation object 44 reconstructing otree representation search dynamic insertion might want reconstruct complete otree representation opposed partial rtree conversion complete otree representation partial otree representation information get lost b c figure 8 eliminating sides otree discriminator store approximation original otree discriminator therefore partial otree representation less accurate complete otree representation still descriptive rtree information algorithm otocomplete converts partial otree node back complete otree node ie entry eight sides although entry complete approximation original complete otree representation partial rtree start copying parent discriminator replace values sides stored actual values function tighten propagates tightens otree discriminator resulting discriminator approximation original otree entry otocompletes pd tn sn l 0 pd sibj l tid tightend return although store information otree discriminator may able reconstruct information sides stored mbb axes x also gives bounds axes v w vice versa thus tighten bounds figure 9 illustrates tightening mbb x mbb v w mobb mbb x determines tighter lower bound v mbb v w determines tighter upper bound tighter bounds illustrated dashed lines function tighten takes discriminator sides read node parent mobb xl xu mbb yl vl wl wl figure 9 tightening representation otree discriminator tightend return boundaries x based values v w orthogonal box computed original values replaced computed bounds tighter process performed orthogonal mbb 45 insertion dynamic partial otrees insertion entries partial otree identical insertion partial rtrees except function getrepresentation trees new representation node based previous representation stored tree partial rtree representation complete accurate representation entry partial tree representation already approximation entry creating new partial otree representation therefore produce another approximation already approximated entry quality representation entry therefore deteriorates every time representation changed recalculated dynamic insertion happens frequently accuracy object description partial dynamic otree therefore poor leads inaccurate search involving high cost partial dynamic otrees therefore seem useful practice although rst approximation accurate description entries provides information rtree bounding box therefore suggest use partial otree approach static environment partial static otree generated existing otree every discriminator tree converted partial otree representation result partial otree takes half space original otree represents entries descriptive way rtree 46 building static partial otree static partial otree created complete tree determine fanout partial otree given node size complete otree fanout created nodes complete otrees twice large ones partial tree read complete otree convert every discriminator partial representation applying storesides algorithm result partial otree nodes given node size fanout complete larger tree apply approximation step discriminators tree accurate 47 searching partial otrees search partial otrees two dierent ways dierent cost accuracy accu ratesearch shown reads every entry tree tries reconstruct complete otree representation using readentry intersecttid q case search algorithms traverses tree reconstructs complete representation entries outputs leafs whose approximations intersect approximation query object alternative faster less accurate search algorithm similar partial rtree search entries completely reconstructed sides stored compared query reduces search time copying parent node copying entry sides tightening performed fastsearch exactly analogous search l 0 match true sibj ssl qdi match false break match case search algorithms implement lter step creates set candidate objects might actually intersect query renement step takes candidate object subsequent step checks intersection query object 5 experiments 51 description experiments experiments conducted sun ultra5 270 mhz 256 mbyte ram solaris 26 level2 cache line architecture 64 bytes implemented partial rtree partial otree using csbtechnique described sections 3 4 compared partial rtrees normal rtree also uses pointer elimination technique 64 byte cacheline traditional otrees cannot used node contain entries therefore include results normal otree graphs discussion trees used quadratic splitting algorithm trees test data consists set randomly constructed line polygon data relations line data set contains number lines approximate length 20 square area 5000 polygon data sets contain convex polygons 10 nodes edges length approximately 40 square area 10000 polygons constructed randomly creating 10 points using graham scan algorithm calculate convex hull experiments measure performance partial rtrees partial static otrees compare search performance rtree test case queried tree 10000 random queries measured number node ac cesses search time number results search times including renement step 52 experimental results figures show average number node per query line data polygon data spectively node accesses used rough measure cache misses ie worst case number cache misses line data partial rtrees show reduction per cent number node accesses compared rtree accurate partial otree reduces number node accesses 60 per rtree partial partial otree lines rtree accurate fast 100 26 21 25 26 1000 221 159 139 152 5000 1010 724 474 513 10000 1954 1403 869 933 50000 9194 6444 4010 4295 100000 18193 12701 7613 8105 figure 10 average node accesses line data query rtree partial partial otree polys rtree accurate fast 500 279 209 264 266 1000 559 407 549 554 5000 2711 1982 2708 2732 10000 5305 3923 5303 5354 100000 51492 38728 51021 51516 figure 11 average node accesses polygon data query cent fast search partial otree still per cent less node accesses rtree polygon data partial rtree shows similar improvement 25 per cent partial otrees hand reduce number node accesses marginal 1 per cent measuring search time per query line polygon data obtained results shown figures 12 13 line data partial rtree improves normal rtree 25 per cent partial otree accurate search shows expensive accurate search although could decrease number node accesses signicantly gained time used perform expensive opera tions search time partial accurate otree cent higher rtree less accurate fast otree search algorithm hand reduces search time 35 per cent shows clearly although fast search slightly less accurate search subtrees faster execution time results best perfor mance polygon data partial rtree reduces search time 25 per cent compared rtree partial partial otree lines rtree accurate fast 1000 033 029 112 042 5000 192 151 384 149 10000 411 320 703 279 50000 1974 1448 3258 1306 100000 3872 2837 6164 2459 figure 12 average search time line data rtree partial partial otree polys rtree accurate fast 500 031 037 209 068 1000 072 075 422 144 5000 521 407 2136 751 10000 1089 850 4237 1519 50000 5410 4030 20394 7429 100000 11058 8410 40551 14784 figure 13 average search time polygon data partial partial otree otree lines rtree accurate fast 500 1175 418 516 416 1000 2283 805 953 805 5000 11751 4155 4498 4155 10000 23417 8286 8809 8282 50000 116440 41177 43223 41131 100000 233360 82657 85969 82581 figure 14 total number results line data normal rtree partial otrees improve rtree accurate otree search suffers high computation cost shows increase 250 per cent even fast otree search shows slight increase search time showing great improvement line data additional orthogonal bounding box otrees seem help make search polygon data ecient nevertheless shown figures 14 15 still reduces number hits lter step sig nicantly included number results complete otree fanout measure best possible reduction results compared rtree partial rtree number hits complete otree reduces number results per cent line data 25 per cent polygon data accurate search partial otree still achieves 64 per cent reduction line data 23 per cent polygon data fast otree search slightly less accurate still show reduction 64 per cent line data 20 per cent polygon data partial partial otree otree polys rtree accurate fast 100 595 467 486 456 500 2833 2192 2287 2155 1000 5745 4422 4583 4371 5000 28474 22057 22875 21725 10000 56938 44033 45608 43419 100000 567204 436057 449977 430840 figure 15 total number results polygon data thousands compare search time search trees take renement step account renement step takes set results obtained searching tree lter step tests actual intersection query object object candidate result set search times experiment shown figures 16 17 rtree partial partial otree lines rtree accurate fast 500 031 031 079 042 1000 066 066 136 072 5000 422 347 485 263 10000 867 706 911 510 50000 4317 3446 4330 2402 100000 8713 6872 8169 4580 figure average search time line data including renement time rtree partial partial otree polys rtree accurate fast 500 112 117 286 153 1000 248 240 586 320 5000 1491 1315 3008 1685 10000 3038 2678 5947 3350 50000 15334 13238 29043 16311 100000 figure 17 average search time polygon data including renement time number results change improvement partial rtree compared normal rtree similar search including rene ment step otrees hand relative performance rtree changed accurate search otree shows slight improvement rtree large line data le similar performance line data sets fast search otree shows reduction search time 60 per cent larger les polygon data even reduced number candidates renement step make partial otree competitive accurate search search time 60 higher rtree still improvement shown fast otree search polygon data 6 summary investigated make better use space small rtree node inmemory applications many entries share sides parents introduced partial rtree stores information given parent node experiments showed partial rtree shows better performance rtree random line queries line polygon data improvements range 10 per cent due higher fanout node showed 4 compared 3 normal rtree also investigated could make better use space storing dierent information promises yield better approximation entry partial otree based otree stores important part information otree box implemented static version partial otree investigated two search algorithms fast search algorithm still shows enough accuracy showed improvements per cent line data without renement step per cent improvement line data rene ment step polygon data search could improved static partial otree still showed stable performance similar rtree 7 future work investigate improve fanout tree storing bitelds encoded using humanencoding furthermore also experiment static partial otrees diskbased database environment r asilomar report database research improving index performance prefetching optimizing multidimensional index trees main memory access making b tr rtree efficient robust access method points rectangles asilomar report database research making b trees cache conscious main memory optimizing multidimensional index trees main memory access mainmemory index structures fixedsize partial keys improving index performance prefetching rtrees costbased unbalanced rtrees otrees ctr jeong min shim seok il song jae soo yoo young soo min efficient cache conscious multidimensional index structure information processing letters v92 n3 p133142 15 november 2004
language specifying recursive traversals object structures present domainspecific language specifying recursive traversals object structures use visitor pattern traversals traditionally specified iterations forcing programmer adopt imperative style hardcoded program visitor proposal allows number problems best approached recursive means tackled visitor pattern retaining benefits separate traversal specification b introduction visitor pattern ghjv95 allows programmer write behavior traverses object structure without embedding assumptions structure computational code result separating navigational code code performs computation versions visitor pattern exact sequence parts object visited hardcoded either object visitor refer sequence object visits navigational code produces traversal visitor ideal object structure class graph application object structure contains concrete objects class graph may contain contain abstract classes interfaces since code implementing traversal necessarily detailed encoding class graph binding visitor navigational code together harms maintainability reuse alternative hardcoding separate navigation visitors behavior visitor work partially supported defense advanced projects agency darpa rome laboratory agreement number f306029620239 views conclusions herein authors interpreted necessarily representing official policies endorsements either expressed implied defense advanced research project agency rome laboratory us government research also supported part national science foundation grants ccr9629801 ccr9804115 appear proceedings oopsla 99 whole iterators ghjv95 strategies lie96 suggested purpose present object structure sequence visit events thereby linearizing traversal enforcing imperative style program visitor propose domain specific language express recursive traversals object structures linearizing object structure traversed language allows recursive computations expressed using visitor pattern range problems succinctly solved synthesizing result subresults making valuepassing explicit specification language able naturally express recursive algorithms design allows object used many different traversals traversal used many different visitors factoring behavior class graph traversal visitor makes program robust evolution class graph change class graph likely require local maintenance traversal definitions often visitors need changed features approach 1 allowing programmer specify order parts object traversed 2 allowing current node visited several times course traversal 3 allowing traversal control behavior dynamically 4 providing convenient mechanism values returned visits 5 providing convenient mechanism iterating traversal collections objects 6 allowing traversals named reuse traversal specifications translated java classes thus first class values stored variables passed arguments related work gamma et al ghjv95 present visitor pattern proposes separate behavior navigation former put separately compiled class latter put class diagram intended use visitor pattern create software robust addition new behavior changes class structure many cases navigational aspect trivial always covering entire object graph lieberherr lie92 lie96 argues complete traversal object graph often needed suggests visitor pattern modified navigational aspect packaged concise specification gathering information one place behavior traversal visitor may conveniently analyzed without hunting program lieberherr proposes specifying navigational aspects using navigation language leaves unimportant details unspecified details inferred system compile time information class diagram benefit lieberherrs underspecified navigation language many changes class diagram meaning inferred system unchanged goal none program require modification lieberherr calls system adaptive programming pitfall approach surprise paths surprise path occurs change class diagram leads system infer path intended surprise paths alter intended semantics program virtue surprising difficult locate importantly leaving unimportant details unspecified navigational aspect language poor match recursive programming recursive programming seems require explicit stages result propagated computed obviously conflict desire leave details unspecified proposal maintains separation navigation behavior sacrifices degree compactness locality robustness meaning changes program induced changes class definitions localized easily implemented aim least surprise whereas adaptive programming aims least modification current implementations adaptive programming require class diagram recompiled modification navigational aspect lo97 organization also allows navigational aspects added without recompiling class diagram 3 traversal specification 31 example motivate discussion start simple program written java example choose sum nodes tree class diagram example shown fig 31 java program visitor style looks like abstract class tree abstract void visitallleavestreevisitor tv class node extends tree tree leftright void visitallleavestreevisitor tv rightvisitallleavestv class leaf extends tree int val void visitallleavestreevisitor tv top int tree right left tree val figure 1 class diagram simple tree traversal traversal traversalname traversalentry traversalentry traversalentry action traverse partname figure 2 skeleton traversal specification gramma interface treevisitor void visitleafleaf l class sumvisitor implements treevisitor int void visitleafleaf l acc lval class top tree tree void visitallleavestreevisitor tv int sum return vacc coming sections show different versions program 32 syntax wish succinctly describe traversals object graph specifying list actions taken entering object specified class first ap proximation traversal specification 1 grammar shown figure 2 explaining semantics grammar transcribe summing example style traversal uses term traversal specification refers slightly different concept top traverse tree node traverse left traverse right leaf visit visitleaf abstract class tree class node extends tree tree left right class leaf extends tree int val class sumvisitor implements visitallleavesvisitor int void visitleafleaf l acc lval class top tree tree int sum return vacc code reorganized navigation specified traversal visitallleaves organization immediately improvement plain java code code part behavior grouped together traversal started invoking static method traverse class visitallleaves generated system traversal specification pass object traversed visitor v traverse traverse method visitor passed first argument traversal traversal invoked implicit traversal proceeds inspecting current object determine class list traversalentries scanned find specific entry object entry found corresponding list actions executed order occurrence action traverse p invokes traversal recursively object op action visit v invokes method v visitor current object argument general may several applicable entries object superclasses may entries call next specific entry super directive provided thus overriding extending behavior supported object traversed entry found action performed void result returned discrimination precise entry object could done using javas introspection facilities stated generating java code traversal specification instead use inheritance information class graph generate efficient java code later sections using information class graph provide types variables traversal 33 changing class diagram motivation behind suggestion make recursive programming less painful automatically generating lots code minimal functional description tree tree leaf top int val onenode twonode twonode oneor left right figure 3 class diagram complicated set trees also make code robust changes class diagram illustrate changes needed let us modify class diagram running example slightly nodes one child well two weve already seen see figure 3 keep names meaningful node become two node new traversal specification becomes traversal top traverse tree twonode traverse left traverse right onenode traverse leaf visit visitleaf apart global renaming node twonode changes necessary obviously modifications class diagram simple modifications required often similar make claim looking back program see traversal specification makes local assumptions class diagram specifically traversal assumes given class able access parts traver salentry class wishes traverse argued corresponding modifications needed plain java code almost painless changes traversal specification java code ever require changes separated parts program traversal specification organizes code changes localized traversal specification 34 passing parameters return values important able pass arguments return results traversals visitors extend traversal specification grammar figure 4 grammar visitors traversals take arguments return results result either bound traversal variable opposed instance variables current object subsequent use returned caller also special variable host bound host object traversed grammar also allows types optionally spec ified perform type inference mainly convenience avoid repeat type declarations traversal traversal traversalname traversalentry classname returning type action actionrhs traverse partname arguments parameters parameter parameter parameter arguments argument argument argument variablename figure 4 complete grammar dealing collections instance require programmer specify type collections elements section 36 covers collections greater detail let us rework example using new fea tures accumulator kept traversal rather visitor traversal visitallleavesint top traverse treeacc traverse rightlacc onenode traverse onlyacc leaf visit visitleafacc abstract class tree class node extends tree tree left right class leaf extends tree int val class sumvisitor implements visitallleavesvisitor void visitleafleaf l int sumsofar return class top tree tree int sum return visitallleavestraversethisnew visitor example internal state accumulator passed return valueparameter 2 notice also pass one argument traverse method traversal takes argument threading accumulator mimics original example doesnt illustrate recursive style prefer would elegant computation proceed natural recursive fashion although general visitors still state traversal top traverse tree node int lacc traverse left int traverse right visit combinelaccracc leaf visit visitleaf abstract class tree class node extends tree tree left right class leaf extends tree int val class sumvisitor implements visitallleavesvisitor void visitleafleaf l return lval int combinenode nint left int right return leftright class top tree tree int sum return visitallleavestraversethisnew sumvisitor program looks much like functional programmer would expect result inductively computed results subtrees traversal responsible passing data visitor responsible computing data two subresults combined calling method visitor traversing nonparts sometime desirable traverse objects connected object structure traversed example would traverse object result previous computation one way achieve make visitor method invokes traversal object ar gument approach drawback hardcoding name traversal visitor instead extend traverse directive traverse traversal variables addition instance variables host object traversal variables shadow instance variables host reflect added capability nonterminal partname grammar changed part orvarname language parsed unchanged give example facility may used next section 36 special case collections collections generally useful makes sense deal specially propose adding operator called foreach traversal specification language grammar shown figure 5 goal foreach emulate fold reduction fh88 collection since target language java use iteration construct offered class library enumerations require collection class method called returns enumeration strategy use methods provided enumeration access element collection perform traversal element thus accessed combine results using method name passed foreach actionrhs traverse partorvarname arguments method methodname arguments foreach partorvarname methodname argument arguments figure 5 reducing collections vector top complex nums figure vector complex numbers collection traversed partorvarname current host indirection necessary might several collections vectors class graph need generate different traversal code depending types elements contains foreach calls methodname method visitor result element collection passing two arguments result traversing element accumulated result first argument ac cumulators initial value remaining arguments parentheses passed traversal element result traversing collection accumulated result illustrate let us analyze use foreach find maximum magnitude list complex numbers let class diagram look like figure 6 top part called nums leads collection complex traverse collection might write traversal top double foreach nums calcmax maxinit complex returning double visit magnitude class maxvisitor implements foldcomplexvisitor double getinitvector v return 00 double calcmaxdouble magn double maxsofar return mathmaxmagnmaxsofar double magnitudecomplex comp return class top vector nums double findmax return foldcomplextraversethisnew maxvisitor foreach nums calcmax maxinit invoked traversal current object instance top collection traversed nums instance vari able enumeration created invoking method elements collection traversal iterates elements enumeration using code functionally equivalent following snippet double foreach maxvisitor v enumeration enum double initacc double complex double return acc three issues worth noting 1 mentioned use type information class diagram determine traversing collection complex allows us perform proper cast result nextelement 2 however class diagram contain enough information us determine types need know order produce snippet code one type type traversal result assert double must type inference determine types discussed section 52 particular case fact maxinit double enough also need know result traversing complex double code explicitly annotate entry complex cases might inferable system 3 retrieving object collection cast type know proceed traverse cases dont want traverse entire collec tions instead subset thereof section 35 introduced concept traversing variables traversal use facility create suitable collection traversing example wished find maximum magnitude every complex value might written traversal like traversal top double foreach mynums calcmax maxinit complex returning double visit magnitude added following method visitor vector makemynumstop vector new vector enumeration resaddelementenextelement ehasmoreelements nextelement return res makemynums method makes collection containing every element original traversed using foreach 37 controlling traversal would like traversal able make decisions runtime proceed example might searching item binary tree depending value stored node need search left subtree right found value traversal done end introduce thunk directive produces thunk list actions grammar figure 8 thunk reference variables visible declared cannot change values thunks java objects one method invoke typically passed methods also invoked traversal invoke directive return type determined body thunk since thunks return types basis class name thunk int thunk returns int invoked illustrate figure 7 shows thunks might used binary search tree element tree either node containing two subtrees leaf containing item node create two thunks one search either subtree pass visitor visitor determines subtree search invokes proper thunk using thunks wide variety quite complex behaviors programmed addition searching binary trees provide convenient way traverse cyclic objects situations desirable repeatedly perform traversal example iterating stateful operation fixpoint thunks may invoked several times row allowing computations expressed without creating separate traversal iterative computation instead invoking thunks immediately visitor decide store table invoke turns results needed later time small extension implemented would introduce memoizing thunks cache results subsequent invocations would return cached result instead reperforming traversal 38 calling traversals able call traversals useful enables us split common abstractions units reused several traversals translation extended straightforward way traversal generates interface visitors used traversal must implement visitor used several traversals visitor need implement interfaces another use multiple traversals encode state traversals depending traversal active computation certain state traversals mutually recursive must specified block must type checked group figure 8 shows final version grammar one traversal may call another traversal specified part using othertrav directive recursive call called traversal terminates calling traversal resumes traversals traversal traversal traversal traversal traversalname traversalentry classname returning type action actionrhs traverse partorvarname arguments partorvarname arguments foreach partorvarname methodname argument arguments parameters parameter parameter parameter arguments argument argument argument variablename figure 8 complete grammar person married vector lings married sibs siblings element spouse figure 9 inlaws example inlaws problem wer96 illustrates weakness visitor pattern object plays different roles depending context appears giving rolespecific behavior becomes tedious one workaround keep state variable visitor updated traversal reflect behavior visitor approach forces behavior visitor aware navigational details contrary philosophy visitor pattern figure 9 shows class diagram inlaws problem person married notmarrried zero siblings inlaw spouse sibling sibling spouse start person wish apply operation inlaw visit example inlaws person visitor pattern difficulty expressing problem class person plays role self sibling spouse inlaw behavior visitor depends role class int tree right left tree top item else return leftinvoke top traverse treegoal traverse rightgoal visit choosegoal gol gor traverse itemgoal traversal binsearchint traverse leftgoal visit atleafgoal getitem class searchvisitor implements binsearchvisitor goal nkey return rightinvoke item atleafleaf l int goal thunkitem get goal nkey return getinvoke else return null figure 7 code search binary tree borrowing solutions similar problems functional programming solve problem encoding state visitor traversal name instead one traversal four first traversal starts person whose inlaws seek traversal person othertrav mysibling siblings married visit combinespouse sibs notmarried super anybodys siblings may lead inlaws married notmarried delegate traversal entry superclass person married person also inlaws via spouse traverse using myspouse traver sal finally results married persons spouse siblings combined using combine visit visitor traversal siblings foreach sibs reduce val married othertrav myinlaw spouse notmarried visit initval list siblings dealt using foreach visitor assumed visit initval returns suitable initial value reduction reduction performed using method reduce visitor sibling married found inlaw spouse sibling notmarried initval used return suitable result traversal person othertrav myinlaw siblings similar vein siblings spouse also inlaws traversal siblings foreach sibs reduce val person returning int visit inlaw found inlaw invoke inlaw visit visitor specify return type inlaw visit give type checker type propagate type checker determine entries traversals mysibling myspouse myinlaw return type java doesnt allow polymorphic method signatures specify least one chose annotate person entry returning int like sibling list inlaws reduced one value using foreach initval inlaw visited results reduced use traversals count number inlaws person class inlawscounter implements myselfvisitor mysiblingvisitor myspousevisitor myinlawvisitor int initval return 0 int combinemarried h int int b return reduceab int reduceint int b return ab int inlawperson host return class person int countinlaws return myselftraversethisnew inlawscounter 5 translating java following section describe details translation traversals java translation fairly straight forward largest task translation performing type inference traversal specification process type checking incidentally also verifies traversal consistent class diagram code generation strategy assumes classes traversing written beforehand cannot recompiled allows us traverse object structures third party classes long able construct class diagram subset object structure wish traverse however developing traversal classes traversed parallel equally well supported since traversal specifications translated java classes compiled separately together users classes 51 class diagram order infer types traversal must know structure program used class structure needed typechecking insert proper casts elements extracted collections class diagram describes type structure program used several graphical representations class diagrams already example figure 9 class diagram encodes three different types edges classes ffl part edges relationships described parts variables class edges traversed explicitly traverse directive part edges named ffl inheritance edges object traversed precise traversalentry class executed entry choose extend rather override behavior superclass invoking super directive ffl collection edges implicit edges inside collection classes point element edges traversed foreach directive collection edges named would nice inheritance edge c c 0 classes c c 0 allowed return type traversal c 0 subtype c unfortunately java forbids overriding inherited methods methods different return types constraint strengthened equality 52 type checking consistency input grammar types optional must know type variables return types traversals order generate code result type checking determine types additionally need generate interface visitors used traversal must implement also requires detailed information types system class diagram traversal specification specify many types involved specify typically many classes traversal return type specified foreach needs infer type returned traversing object collection since function types polymorphism infer types simple constraintsolving wan87 since constraints equivalence relations possible sort type variables equivalence classes onffn time ff inverse ackerman function realistically never returns value greater 4 clr90 rules generating constraints given figure 10 take opportunity check traversal consistent class diagram generate interface visitors used traversal traversal considered consistent class diagram verify parts traversal mentions exist traversal expects find also part used foreach must collection class conditions verified side effect generating constraints constraints form t1 t2 type variables types generated constraints solve sorting type variables equivalence classes find possible typing error find type variables equivalent java type traversal polymorphic type variables since java yet parametric polymorphism currently regard type error inlaws example previous section specify return type inlaws visit avoid traversal becoming polymorphic determined values type vari ables ready generate java code 53 generated java figures 11 12 show details java code generated strategy generate class traversal class application method name entry classname generated class traversal entry used generate body method otherwise default entry delegates entry superclass used method javalangob ject empty default additionally methods find precise traversal entry object effectively simulating dynamic dispatch generated dispatch methods name traverse overloaded type first argument type inference know unambiguously signature visitor method order satisfy type safety requirements java output signatures java interface traversalname visitor require visitors used traversal implement interface interface allows visitor traversal used compiled separately generating traversal code separate class able traverse class long able produce class diagram allows us traverse classes able recompile need simulate dynamic dispatch traversal entries searching invoking specific traversal entry object furthermore putting traversal code one class becomes possible use traditional techniques subclassing extend evolve existing traversals discussed section 6 6 future work conclusion one uses visitor pattern extend functionality existing classes ffk98 typical visitor pattern takes traversal class graph given visitor always traverses entire object graph traversal name classname returning type return type traversal classname vn thetatheta ar thetatheta ar thetatheta ar ar thetatheta traverse part args type traverse part type travparam ar thetatheta othertrav trav part args traversing part type travparam ar thetatheta visit meth args return type meth type host type methparam ar thetatheta method meth args return type meth type methparam ar thetatheta varname ar thetatheta foreach part meth initvarargs abcd fresh type variables type collection return type meth first argument meth second argument meth return type traversal type travparam returning vn ar thetatheta invoke thunk returning v figure 10 type constraint generation rules type classgraph returned thunk abstract class thunk typef abstract type invoke traversal nameparams class name traversal f name visitor thevisitor namename visitor visitor f class classgraph subclassn immediate subclasses class type traverseclass host paramlist f class instanceof subclass1 return thistraversesubclass1 hostparamlist else class instanceof subclassn return thistraversesubclassn hostparamlist else return thisentry classhostparamlist classname returning type 735 nameparams classname host name visitor visitor params return new name traversalvisitor type entry classnameclassname host params f aan name true figure 11 java translation traversals part 1 thetatheta ar else ararname ret type varname thetatheta ar else ararname ret ar thetatheta traverse part args name binder part traversal variable hostpart else part host variable binder thistraversegetstrargs ar thetatheta othertrav travname part args namebinder part traversal variable hostpart else part host variable binder travnametraverse getstr travname visitor thevisitor args ar thetatheta visit meth args name binder ar thetatheta super args superclass closest superclass class binder entry superclasshostargs ar thetatheta varname ar thetatheta foreach part meth initvarargs name binder travresulttype inferred types part traversal variable hostpart else part host variable javautilenumeration inittype travresulttype binder acc 1 g735 aan name true ar thetatheta invoke thunkname figure 12 java translation traversals part 2 system able extend behavior simply via inheritance visitor system since separate traversal specifica tions would make sense able extend traversals addition visitors traversal entry class would override traversal entry super class overridden entry still invoked via javas super mechanism ever already used keyword invoke entry current objects superclass allowing traversal specifications subclass introduce second dimension overriding thus raising question overridden behavior wish invoke super call combination two dimensions behavioral specialization issue study prototype system implemented sketched detail combine traversal specifications demjava programming environment demjava visitorpatternbased programming environment extensively used number medium scale programming projects incorporates succinct traversal strategies make expressing recursive algorithms difficult two systems complement demjava simplifies traversals large class graphs traversal strategies allow elegant specification recursive computations smaller subgraphs however due time constraints combination reached preliminary stage many features missing r introduction algorithms functional programming design patterns elements reusable objectoriented software component enhancement adaptive reusability mechanism groups collaborating classes adaptive objectoriented soft ware preventative program maintainance deme terjava research demonstration simple algorithm proof type inference personal communication demeter seminar tr introduction algorithms design patterns preventive program maintenance demeterjava adaptive objectoriented software component enhancement synthesizing objectoriented functional design promote reuse ctr jeff gray using software component generators construct metaweaver framework proceedings 23rd international conference software engineering p789790 may 1219 2001 toronto ontario canada jeff gray ted bapty sandeep neema james tuck handling crosscutting constraints domainspecific modeling communications acm v44 n10 p8793 oct 2001 ralf lmmel eelco visser joost visser strategic programming meets adaptive programming proceedings 2nd international conference aspectoriented software development p168177 march 1721 2003 boston massachusetts joost visser visitor combination traversal control acm sigplan notices v36 n11 p270282 11012001 arie van deursen joost visser source model analysis using jjtraveler visitor combinator framework softwarepractice experience v34 n14 p13451379 november 2004
complexity data disjunctions study complexity data disjunctions disjunctive deductive databases dddbs data disjunction disjunctive ground clause rc1pt1rckk 2 derived database atoms clause involve predicate r consider complexity deciding existence uniqueness minimal data disjunction well actually computing one propositional data nonground program complexity database results extend complement previous results complexity disjunctive databases provide newly developed tools analysis complexity function computation b introduction past decades lot research spent overcome limitations conventional relational database systems field deductive databases emerged logic programming 29 uses logic tool representing querying information databases numerous logical query languages extend horn clause programming dealing various aspects incomplete indefinite information proposed date cf 1 33 particular use disjunction rule heads expressing indefinite information proposed minkers seminal paper 32 started interest disjunctive logic programming 30 10 example rule lives inx us lives inx canada lives inx mexico lives inx n america 1 informally states person living north america lives one three countries semantical computational aspects disjunctive logic programming particular disjunctive deductive databases investigated many papers see 33 overview results paper presented international workshop colloquium logicum complexity vienna october 910 1998 work partially supported austrian science fund project n z29inf british councilaustria arc programme collaborative research oracle computations within descriptive complexity theory paper interested restricted type disjunction previously considered eg 6 5 12 19 15 data disjunction 19 ground clause rc 1 atoms different involve predicate r example head rule 1 joe data disjunction well disjunctive fact lovesbill monica lovesbill hillary data disjunction expresses indefinite information truth predicate set arguments database terminology expresses null value predicate whose range given arguments atoms context deductive databases null values form extensional database complexity considered eg 20 many papers example fact lives injoe n america known data disjunction lives injoe us lives injoe canada lives injoe mexico derived rule 1 clause c entailed database also clause c 0 subsumed c entailed example clause c lives injoe usbekistan entailed virtue c well thus adopt natural condition data disjunction c must minimal ie proper subclause c entailed question address complexity data disjunctions disjunctive deductive database dddb table 1 summarizes problems studied paper see section 3 precise definitions main complexity results obtained complement previous results reasoning dddbs deciding whether arbitrary disjunction rather data disjunction follows dddb pi pdata propositional complexity exponentially higher expression combined complexity 14 various syntactic restrictions lower complexity conp even polynomial time 9 hand evaluating conjunctive query disjunctive extensional database conpcomplete 20 hence deciding entailment single ground atom conp data propositional complexity thus data disjunctions intermediate complexity arbitrary clauses single atoms observe table 1 contains also results actually computing data disjunction assuming one exists results table could derived standard way ie proving membership class c reducing chosen chard problem problem question pursue engineering perspective complexity analysis databases proposed eg 18 utilizes tools descriptive succinct complexity theory exploits properties deductive database semantics means tools hardness results derived abstracted level consideration without need choosing fixed chard problem tools particular complexity upgrading developed decision problems available function problems overcome generalizing tools propositional problems suitable way thus main contributions paper summarized follows firstly determine complexity data disjunctions obtain natural simple logical inference problems complete class theta p 2 refined polynomial hierarchy 45 computational variants complete problems function classes fp np k fl np log log exponential analogs secondly provide upgrading techniques determining complexity function computations generalize available tools decisional problems may fruitfully applied contexts well rest paper organized follows section 2 states preliminaries section 3 formalizes problems section 4 decision problems considered section 5 devoted computing data disjunction input disjunctive deductive database collection possibly disjunctive ground facts inference rules plus distinguished relation symbol r propositional complexity data complexity expression complexity combined complexity 9dd db data disjunction r theta p pspace np pspace np 9dd db unique data disjunction r theta p pspace np pspace np dd computation unique data disjunction r fpspace np fpspace np k dd computation unique data disjunction r k disjuncts k constant log log fl np log log fpspace np pol fpspace np pol table 1 complexity data disjunctions data disjunctions logical characterizations function computations given generalization stewart normal form snf 38 39 17 first used characterize class theta p deriving expression combined complexity function computations upgrading results developed section 6 final section 7 applies results area closedworld reasoning gives conclusions preliminaries 21 deductive databases background disjunctive deductive databases refer 30 syntax finite relational language tuple r relation symbols also called predicate symbols associated arities c constant sym bols atom formula form r v v tuple first order variables constant symbols disjunctive datalog rule clause form finite relational language atoms forming head clause b j atoms inequalities form u u v variables constants forming body clause disjunctive deductive program short program finite collection disjunctive datalog rules ground variables occur rules predicate symbol occurs rule bodies called input predicate otherwise called derived predicate disjunctive deductive program input negation program input predicates allowed appear negated ground fact clause form 1 1 variablefree atom disjunctive ground fact clause form 1 n variablefree atoms disjunctive deductive database dddb tuple e program e finite set disjunctive ground facts e represents input database also called extensional part inference rules called intensional part database db remark note e e disjunctive deductive programs ie ground facts included programs fact shall defining semantics however methodological complexity issues important distinguish input data inference rules example complexity evaluating db exponentially lower fixed section 3 shall define data query complexity give formal meaning intuition semantics semantics dddbs defined terms minimal models 32 30 e denote hu db herbrand universe ie set constants occurring db herbrand base hb db resp disjunctive herbrand base dhb db set ground atoms disjunctive ground facts predicates db hu db ground instantiation program set constants c denoted ground c ground instance db denoted grounddb ground hb db herbrand interpretation db subset h hb db interpretation h db model db satisfies rule grounddb standard sense model h db minimal contain model db properly mmdb denote set minimal models db write db true every 2 mmdb say entailed db example 21 let rule qx px e contains single disjunctive fact among models db minimal models db fqbgg remark easy see 32 positive clause c db iff db satisfaction models db repeatedly use fact set minimal models db characterized terms unique least modelstate ms see 30 ie subset dhb db computed least fixpoint iteration operator generalizing standard p operator logic programming 29 general computation ms takes exponential space time even program db fixed 211 negation introducing negation disjunctive deductive databases straightforward gave rise different semantics cf 33 restrict input negation ie use negated atoms r rule bodies r extensional predicate adopt closedworld assumption cwa models imposing following condition accepted model e restricted extensional part must minimal model e unless stated otherwise model dddb must satisfy kind closedworld assumption observe condition satisfied 2 mmdb negationfree furthermore e contains disjunctive facts rc true every 2 mmdb iff complexity easy see checking whether restriction extensional part minimal model e possible polynomial time hence complexity model checking deciding db increase cwa models furthermore e restricted disjunctionfree ground facts input negation eliminated computation follows definition 21 let finite relational language let class finite 0 structures relations r r 0 complement r proposition 21 extending given structure corresponding neg 0 structure replacing literals program r 0 possible logspace derivation hardness results shall consider dddbs e using input negation e disjunctionfree hence hardness results paper hold dddbs without negation nondisjunctive ie relational facts well 22 complexity section introduce specific complexity classes notions employed paper assume however familiarity basic notions complexity theory oracle computations np pspace l etc class theta p 2 contains languages polynomialtime truthtable reducible sets np wide range different characterizations 45 21 particular following classes coincide theta p polynomial time computation k rounds parallel queries np oracle 27 log polynomial time computation number queries np oracle logarithmic input size 25 log logarithmic space computation number queries np oracle logarithmic input size 26 1 1 observe space oracle tape bounded unbounded oracle space also assumed classes using oracle paper iii fl np log log iv ii log log log log query figure 1 function classes corresponding theta p overview different characterizations history consult 45 21 shown 21 4 37 40 picture changes turn function computation mentioned list gives rise three presumably different complexity classes fp np log fl np log shown figure 1 function class fc denote fclog restriction fc functions logarithmic output size moreover kk denotes k rounds parallel queries k constant relationships complexity classes figure 1 attracting quite research efforts led number interesting results ffl iiiii equivalent ffl iii equivalent property sat olog n approximable shown 2 iii proved 8 f approximability set means function g x holds gx ffl furthermore iii 1satsat ie promise sat p 4 40 fewpp npr 37 n np dtime2 n o1 log log n compare complexity functions obtain notion completeness function classes use krentels notion metric reducibility 25 definition 22 function f metric reducible mr reducible function g symbols f mr g pair polynomialtime computable functions h 1 h 2 every x proviso 1 let c complexity class unless stated otherwise use following convention ccompleteness defined respect logspace reductions c class decision problems respect metric reductions c class function problems complete problems function classes shown figure 1 canonical fp np complete problem query ie computing string 1 supremum computing given boolean formula f string satisfying assignment variables f x size computing size maximum clique given graph note problem also complete fp np log problems turned proper decision problems theta p 2 complete particular deciding whether maximum clique size graph even deciding whether answer string query contains even number 1s theta p complete cf 45 23 queries descriptive complexity definition 23 let finite relational language let frg language containing single relational symbol r query q function maps structures ffistructures domain st qa qb isomorphic b isomorphic r nullary q boolean query boolean query q regarded mapping structures f0 1g st isomorphic b remarks 1 disregard nonelementary queries identify queries higher order definable relations 2 note query also used oracle calls 3 since queries functions shall also write sets pairs qa definition 24 let finite relational language distinguished binary relation succ two constant symbols min max succ set finite structures least two distinct elements succ successor relation jaj min max first last element wrt successor relation respectively note queries defined succ arbitrary structures called order independence queries many query languages however seem require builtin order capturing complexity classes ie capturing requires structures extended contingent ordering structures succ thus write ordered structuresdatabases succ mean queries computed structures extended succ structures following theorems provide examples phenomenon definition 25 snf formula stewart normal form secondorder formula form ff fi pi 1 1 second order formulas equality free variables snf sentence snf formula without free variables skolem functions variables x called snf witnesses lemma 22 38 39 17 every theta p 2 computable property succ expressible oe snf sentence result equivalent terms firstorder logic npcomputable generalized quantifiers contained particular cases generalized quantifiers 38 39 given broad classes generalized quantifiers 17 structure formula x free variables x defines relation given fc j cg program defines relation r particular r nullary resp defines property lemma 23 immediate 13 14 every pi 1 1 definable property succ expressible disjunctive datalog program using input negation remark note lemma 23 require inequalities rule bodies since inequality definable presence order cf 14 3 data disjunctions definition 31 given dddb db disjunctive ground fact rc 1 rc n n 2 called data disjunction 1 db 2 ae case say db data disjunction r data disjunction seen kind null value data base example 31 dddb e data disjunction pa p b p c definition 32 given dddb db maximal disjunction r symbols mddbr disjunctive ground fact rc lemma 31 db data disjunction r db proof db data disjunction ffi r atom rc ffi implied db therefore ffi subclause mddbr thus db mddbr hand db clearly mddbr empty either mddbr data disjunction atoms mddbr removed minimal disjunction ffi reached db definition atomic subformula mddbr implied db ffi must contain least two different atoms j measuring complexity data disjunctions distinguish several cases following vardis 41 distinction data complexity expression complexity alias program complexity combined complexity definition 33 problems 9dd 9dd dd k dd defined follows instance dddb e relation symbol r query 9dd db data disjunction r 9dd db unique data disjunction r dd compute unique data disjunction r exists otherwise k dd compute unique data disjunction r exists k disjuncts otherwise observe 9dd called ignorance test 5 used 5 6 discriminate expressive power different query languages based nonmonotonic logics sets disjunctive ground facts problem 9dd corresponds unique satisfiability problem uniqueness variant problem often different complexity definition 34 let pi one 9dd 9dd dd k dd ffl data complexity pi complexity pi parameter fixed ffl expression complexity pi complexity pi parameter e fixed ffl propositional complexity pi complexity pi ground ffl unconstrained complexity pi also called combined complexity pi problem pi combined propositional complexity c pi ccomplete respect combined complexity pi data expression complexity c pi c respect data resp expression complexity choices parameter pi ccomplete respect data resp expression complexity particular choice parameter 4 existence data disjunctions theorem 41 let q fixed boolean query ordered databases following equivalent 1 q theta p computable 2 q definable snf sentence 3 exist program relation symbol r st data disjunction r iff 4 q equivalent snf sentence whose snf witnesses uniquely defined 5 exist program relation symbol r st unique data disjunction r iff proof equivalence 1 2 stated 17 close inspection proof 17 shows fact 1 also equivalent 4 3 1 lemma 31 following algorithm determines db data disjunction r algorithm ddexistencedb r 1 2 rc 2 hbdb 3 db 4 5 db return true else return false note line 4 equals mddbr algorithm ddexistence works polynomial time makes two rounds parallel queries np oracle thus problem p np 5 1 following algorithm dduniqueness extension ddexistence algorithm dduniquenessdb r 02 rc 2 hbdb 03 db 05 db 07 rc 2 08 db 10 db note lines 1 4 coincide ddexistence line 5 algorithm terminates data disjunction exists otherwise possible data disjunctions subclauses 9 construct subclause contains literals rc mddbr n cannot removed mddbr without destroying data disjunction ie contains literals necessarily appear every data disjunction thus data disjunction unique one hand unique data disjunction exists construction equal like algorithm ddexistence algorithm also works polynomial time making constant number rounds parallel queries np oracle hence problem theta p 2 3 let formula form lemma 23 exist programs b containing predicate symbols b let program b additional rules observe p occur b thus wellknown modularity properties 14 section 5 minimal models obtained extending minimal models b easy see data disjunction p exists tuple c indeed computes property succ equivalence 2 4 follows data disjunction program proof 2 3 unique j corollary 42 propositional data complexity 9dd 9dd theta p expression combined complexity 9dd 9dd pspace np proof remains consider expression combined complexity program fixed size hb db single exponential input thus algorithm ddexistence takes exponentially steps thus problem exptime np k coincides pspace np 18 j since theta p 2 complete problems obtain theorem 41 following corollary 43 program 9dd 9dd theta p hence obtain announced result theorem 44 data complexity propositional complexity 9dd 9dd theta p note propositional complexity 9dd stated 12 hardness proof given standard reduction far involved indicates elegance using descriptional complexity approach since data complexity query language uniquely determined expressive power two languages expressive power always data complexity hence data complexity property semantics expression combined complexity however depend syntax language therefore general possible determine expression complexity query language l expressive power indeed syntax semantics l impact expression complexity spite principal obstacles typical behavior expression complexity often found respect following pattern l captures c expression complexity l hard complexity class exponentially harder c main result 18 shows query languages satisfying simple closure properties indeed match observation suppose database domain elements replaced tuples domain elements operation natural database redesigned instance entries like john smith database replaced tuples johnsmith database b natural expect query qa easily rewritten equivalent query q b b call q b vectorized variant qa essence first closure property vector closure query language uniformly vector closed vectorized variants query expressions computed logspace second closure property similar suppose database replaced database b way relations defined views use unions intersections relations b natural expect query qa translated equivalent query q b b case call q b interpretational variant qa interpretation closure query language uniformly interpretation closed interpretational variants queries computed database schemata logspace conclusion following closure condition see 18 formal definition definition 41 query language uniformly closed uniformly vector closed uniformly interpretation closed lemma 45 18 language dddbs uniformly closed combining corollary 42 following proposition 46 obtain expression combined complexity 9dd 9dd proposition 46 18 language uniformly closed expresses theta p 2 properties succ expression complexity combined complexity least pspace np theorem 47 expression complexity combined complexity 9dd 9dd pspace np 5 computation data disjunctions 51 data complexity propositional complexity theorem 51 let q fixed query ordered databases following equivalent 1 q fp np computable 2 q definable snf formula 3 exist program relation symbol r st qa polynomial time computable unique data disjunction r proof 1 2 problem deciding whether given tuple c fulfills easily seen theta p 2 thus lemma 22 implies snf sentence oe c provide c designated singleton relation r c use 9yr c access c hence 2 3 similarly proof theorem 41 let snf formula free variables lemma 23 exist programs b containing predicate symbols b ac 2 hb bc 2 hb b iff b iff construct program whose unique data disjunction input relation r contains information tuples end consider program figure 2 let arity b new relation symbols also arity r arity a2 program figure 2 dddb program fp np queries requires successor relation tuples available lexicographical successor relation easily defined using datalog rules lines 1 3 enforce sc holds least one c consequently unique data disjunction c positive clause containing possible sc consider lines 1 4 program contained rules line 4 would enforce unique data disjunction r would clause max max lines 5 6 however remove certain literals clause particular holds iff c iff c unique data disjunction r contains clause rc min minrc min max rc max max therefore polynomial time computable unique data disjunction r 3 1 algorithm dduniqueness proof theorem 41 computes unique data disjunction variable provided exists easily modified output case j data propositional complexity dd easy corollary result corollary 52 problem dd data complexity propositional complexity fp np definition 51 domain element query deq query whose answer relation singleton ie query q st holds theorem 53 let q fixed deq ordered databases following equivalent 1 q fp np 2 qa tuple snf witnesses snf sentence 3 exist program relation symbol r st qa definable projection unique data disjunction r data disjunction contains two atoms 4 exist program relation symbol r st qa polynomial time computable unique data disjunction r data disjunction contains two atoms proof 1 2 constant c problem deciding whether c 2 easily seen theta p thus snf formula x free variables x constants st c theorem 41 may wlog suppose snf witnesses unique 2 3 let snf sentence unique snf witnesses program part 2 3 proof theorem 41 unique data disjunction form p c max data disjunction projection tuple yields desired result 3 polynomial time turing machine computes answer unique data disjunction use algorithm dduniqueness proof theorem 41 computes unique data disjunction variable remains check data disjunction small simulate assumption result logarithmic size data propositional complexity k dd immediate corollary result corollary 54 data complexity propositional complexity k dd fl np log log point question arises whether could surpassed reduction proof 2 3 theorem 51 exploiting completeness result k dd next result tells us presumably possible disjunctions bounded constant needed general hardness fp np proposition 55 problem dd metric reducible k dd respect data complexity fp np log proof suppose dd metric reducible k dd corollary 52 implies k dd metric complete fp np k since fl np log log fp np log implies fp np log denotes closure c metric reductions clearly mr log log thus log holds combined fp np log fp np cf figure 1 follows fp np log suppose fp np let f function complete fp np log f exists hypothesis use following fact every function f fp np log mr reducible function g fl np log log indeed krentel showed class optpolog n satisfies fp np log mr optpolog n clique size cf section 2 optpolog ncomplete 25 since clique size clearly fp np log log claimed fact follows transitivity mr fact corollary 52 together hypothesis fp np k imply dd mr f mr g mr dd transitivity mr obtain dd mr k dd j 52 expression combined complexity finally determine expression complexity computing unique data disjunction theorem 56 expression combined complexity dd fpspace np expression combined complexity k dd fpspace np pol proof theorem uses succinct upgrade techniques function problems whose inputs given succinct circuit description techniques described detail following section 6 problems succinct inputs 61 previous work methodology problem succinct input given string usual boolean circuit computes bits string example graph represented circuit 2n input gates input two binary numbers v w length n circuit outputs edge vertex v vertex w way circuit size represent graph 2 n vertices suppose graph algorithm runs time polynomial number vertices natural algorithm succinctly represented graph runs exponential time similarly upper bounds time space measures obtained question lower bounds succinct problems studied series papers circuits 35 22 31 24 3 7 44 also forms succinctness representation boolean formulas obdds 42 43 first crucial step results socalled conversion lemma states reductions ordinary problems lifted reductions succinct problems sa denotes succinct version x denote suitable notions reducibility transitive second step operator long introduced antagonistic sense reduces complexity arguments binary language longa taken set strings w whose size jwj written binary string contrary long contains instances exponentially larger input complexity class c longc set languages longa 2 c remains show second lemma compensation lemma slonga following theorem derived theorem let c complexity classes longc 1 let c 2 hard reductions suppose conversion lemma compensation lemma holds sa reductions proof show c 1 hardness let b arbitrary problem c 1 assumption longb 2 c 2 therefore longb x compensation lemma b slongb conversion lemma obtain slongb sa since transitive sa c 1 hard j 62 queries succinct inputs structure let enca denote encoding binary string standard way encode fix order domain elements concatenate characteristic sequences relations 2 turing machine based algorithms particular reductions fact work therefore shall usually identify enca without notice use notation ffl enc denotes binary language encodings finite structures ffl chara value binary number obtained concatenating leading 1 enca given binary circuit c k input gates genc denotes binary string size 2 k obtained evaluating circuit possible assignments lexicographical order idea succinct representation represent enca form genc overcome mismatch fact size enca almost arbitrary size genc always form 2 k use selfdelimiting encodings definition 61 let selfdelimiting encoding w defined 1 number n denotes binary representation number n thus string sdwv string w easily retrieved looking first 1 even position string definition 62 42 binary language l let sdl denote language 2 characteristic sequence relation binary string tuples lexicographical enumeration describes membership relation 1 nonmembership 0 graphs means writing adjacency matrix line line thus sdl language obtained l adding length descriptor dummy string pads size power 2 definition 63 fplt function f computed two polylogarithmic time bounded deterministic turing machines n input x n computes size output jfxj input x computes ith bit fx plt reduction reduction computed fplt function modulo plt reductions selfdelimiting encoding equivalent standard encoding lemma 61 42 nonempty binary language l l j plt sdl particular means exists fplt function extract extracts word selfdelimiting encoding definition 64 let f query structures succinct version sf f given denote corresponding structure otherwise gen c denotes default structure using gen rephrase definition sf follows weak reducibility needed antecedent conversion lemma given socalled forgetful metric reductions differ metric reductions complexity inner function restricted fplt outer forgetful function may access original input definition 65 function f forgetfully metric reducible function g symbols f mr f g fplt function h 1 polynomial time computable function h 2 every x hard see mr f transitive crucial observation needed generalize results succinct decision problems succinct function problems succinct representation affects inner computation metric reduction ie h 1 result succinct function sf succinct thus able lift inner reductions ordinary instances succinct instances leave outer computation ie h 2 unchanged lifting achieved following lemma lemma 62 immediate 44 let f fplt function maps structures oestructures exists fplt function f st circuits c background conversion lemma easy show lemma 63 conversion lemma let f query structures g query oestructures f sg proof assumption f show exist fplt function h 1 polynomial time function h 2 lemma 62 h 1 st h 1 gen set h lemma proven j remains define suitable long operator recall simplify complexity argu ment following 42 obtain following definition long queries definition 66 let r 1 signature single unary relation symbol let q convex query signature query longq defined follows chara value binary number obtained concatenating leading 1 characteristic sequence tuples lexicographical order lemma 64 compensation lemma let f query f mr proof lemma 63 sufficient show every input f translated shown using somewhat different terminology 42 lemma 6 j theorem 65 let f 1 two classes functions longf 1 query f hard f reductions sf hard f 1 mr f reductions 63 succinctness expression complexity succinct problems expression complexity related following methods used 23 14 generalized 18 suppose language l express c 2 complete property data complexity trivially language rich enough simulate boolean circuit program roughly size possible combine program program circuit simulation thus obtaining program sa consequently reduction sa expression complexity l 14 shown negationfree dddb simulate boolean circuit let boolean circuit decides kary predicate r f0 1g ie tuple supplied c input designated output gate c assume g value 1 iff describe program c simulates c using universe f0 1g gate g c uses kary predicate g g x informally states input tuple x c circuit computation sets output g 1 moreover uses propositional letter false true models g intended interpretation none models minimal clauses c following ones gate c contains clause depending type c contains additional clauses clauses 00 ensure model groundc f0 1g contains false maximal interpretation trivially model c fact model c contains false let mc denote interpretation given takes value 1 input c g lemma 66 14 boolean circuit c mc unique minimal model c theorem 67 problem dd complete fpspace np proof define usual problem whose input contains uniform circuit constant input gates generates instance solved easy see fp np k contains query q complete mr f reductions example query problem function h 1 metric reduction g mr query shifted inside oracle queries polylogtime bits input string x provided dummy oracle queries h 2 hard see longflinspace np therefore theorem 65 sq complete flinspace np standard padding arguments completeness flinspace np implies completeness fpspace np thus remains reduce sq dd lemma 66 circuit c k input gates converted disjunctive program c whose kary output relation r describes string genc consider query qextracta ordered input structure describes string unary relation since qextracta easily seen fp np k theorem 51 implies program whose data disjunction describes result qextracta since dddbs uniformly closed rewritten program 0 whose input relation r arity k proof theorem 51 assume lexicographical successor relation ktuples wellknown modularity properties 14 section 5 program 0 c indeed computes q succinctly specified input j hard show also fl np log mr f complete queries eg variant clique size circuits computing functions h metric reduction clique size part problem instance following theorem shown analogously theorem 68 problem k dd complete fpspace np pol 7 results conclusion 71 closed world reasoning results data disjunctions derived immediate application related problems area closedworld reasoning reiter 36 introduced closedworld assumption cwa principle inferring negative information logical database formally example cwafp ag follows results 11 computing cwadb propositional complexity fp np observe cwadb may classically consistent herbrand interpretations exam ple cwafp model shown 11 deciding whether cwadb consistent theta p 2 conphard propositional case precise complexity problem open refined notion partial cwa cf 16 spirit protected circumscription 34 atoms involving particular predicate p general predicate p list predicates p may negatively concluded db bg definition 71 pminimal model let p list predicates preorder p models dddb db defined follows p 0 every p c 2 hb db p 2 p holds model pminimal db exists model 0 remark pminimal model special case notion model 28 given empty list fixed predicates circumscription proposition 71 let db dddb p predicate following statements equivalent 1 db data disjunction p 2 pcwadbp consistent respect classical herbrand models 3 db global p minimal model ie p 0 models 0 db proof 1 2 suppose 2 data disjunction db implies means pcwadbp consistent suppose db global p minimal model atom p c 2 hb db holds db 6j p c iff 6j p c since unique smallest p part models db hence model pcwadbp thus pcwadbp consistent 3 1 suppose db global p minimal model let collection p minimal models db wlog 1 6 p 2 2 6 p 1 let x set atoms arbitrary atoms holds every means db contains data disjunction predicate p contains p pminimality list p predicates simple coding replaced single predicate first argument p codes predicate coding compatible pminimality ie pminimal p minimal models correspond obvious proposition 71 results previous sections thus obtain following result theorem 72 deciding consistency pcwadbp existence global pminimal model db theta p propositional data complexity pspace np program expression complexity coding technique result theorem 72 holds even language two predicates p contains single predicate hand language one predicate existence data disjunction p equivalent consistency cwadb whose precise complexity open 72 restricted data disjunctions 15 stronger notion data disjunction rc considered requests addition disjuncts rc identical one argument list constants c call data disjunctions restricted note data disjunction considered section 1 restricted problems reformulated restricted data disjunctions table 1 section 1 except expression combined complexity dd fpspace np pol indeed restricted data disjunction c disjuncts number constants thus dd log n many output bits combined complexity case n size db number maximal disjunctions mddbr adapted restricted data disjunctions polynomial data size thus upper bounds easily derived unrestricted data disjunctions hardness results immediate proofs except propositional data complexity dd mapping elements newly introduced polynomially many domain elements suitable technique adapting construction figure 2 proof theorem 51 finally remark lemma 23 remains true even disjunctions program describe restricted data disjunctions thus slight adaptation programs proofs exploiting fact disjunctionfree datalog input negation sufficient upgrading purposes 14 complexity results restricted data disjunction remain true even disjunctions db must restricted data disjunctions 73 conclusion paper considered complexity problems concerning data disjunctions deductive databases aim taken engineering perspective deriving complexity results using tools domain descriptive complexity theory combined results upgrading complexity results normal succinct representations problem input particular also investigated complexity actually computing data disjunctions function rather associated decision problem led us generalize upgrading techniques developed decision problems computations functions upgrading results particular theorem 65 may conveniently used contexts tools used provided paper allow highlevel analysis complexity prob lems sense establishing certain properties schematic reductions sufficient order derive intricate complexity results eg case data disjunctions clean transparent way without need deal particular problems reductions relieves us spelling detailed technical constructions understanding makes problem computationally hard may blurred particular syntactical restrictions complexity remains lowered immediately inferred leave considerations work another interesting issue future work consideration computing data disjunctions viewed multivalued function done acknowledgment grateful iain stewart georg gottlob discussions remarks r foundations databases sparse sets complexity algorithmic problems succinct instances autoepistemic logics unifying framework semantics logic programs querying disjunctive databases nonmonotonic logics succinct circuit representations leaf languages basically concept six hypotheses search theorem complexity propositional closed world reasoning circumscription semantics logic programs intuitions formal properties propositional circumscription extended closed world reasoning complexity class normal forms secondorder logic finite structures disjunctive datalog tractable class disjunctive deductive databases logical foundations artificial intelligence relativized logspace generalized quantifiers ordered finite structures succinctness source complexity logical formalisms complexity query processing databases orobjects computing functions parallel queries np computational complexity graph problems succinct multigraph representation negation fixpoint vector language simple descriptions hard instances complexity optimization problems relativization questions logspace computability comparison polynomialtime reducibilities computing circumscription foundations logic programming foundations disjunctive logic programming complexity graph problems succinctly represented graphs indefinite data bases closed world assumption logic databases 20 year retrospective computing protected circumscription note succinct representations graphs closedworld databases taxonomy complexity classes functions logical characterizations bounded query classes logspace oracle machines logical characterizations bounded query classes ii polynomialtime oracle machines polynomialtime truthreducibilities intractable sets pselective sets complexity relational query languages languages represented boolean formulas encode logical structure obdd succinct representation bounded query classes tr note succinct representations graphs logical foundations artificial intelligence foundations logic programming 2nd extended ed complexity optimization problems complexity query processing databases orobjects complexity graph problems succinctly represented graphs vector language simple description hard instances truthtable reducibility sat bounded query classes negation fixpoint foundations disjunctive logic programming propositional circumscription extended closedworld reasoning myampersandpgrsupscrptpsupscrptsubscrpt2subscrptcomplete complexity algorithmic problems succinct instances taxonomy complexity classes functions computing functions parallel queries np querying disjunctive databases nonmonotonic logics succinct circuit representations leaf language classes basically concept disjunctive datalog languages represented boolean formulas succinct representation leaf languages projection reductions foundations databases complexity class theta2p logic databases indefinite databases closed world assumption six hypotheses search theorem encode logical structure obdd complexity relational query languages extended abstract
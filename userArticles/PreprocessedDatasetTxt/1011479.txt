semantics logic object calculi main contribution paper formal characterization recursive object specifications existence based denotational untyped semantics object calculus existence guaranteed shown employing pitts results relational properties domains semantics used analyse verify abadi leinos object logic also suggests extensions example specifications methods may refer fields also methods objects store achieved without compromising existence theorem informal logic predomains use intentionally order avoid commitment particular syntax specification logic b described introduction rule wrt object formation therefore existence specification equivalent validity introduction rule resulting implicit definition specification neither guarantees existence uniqueness unless phi certain form 1 domain theory provides sufficient machinery guarantee existence uniqueness therefore working denotational domain theoretic semantics puts us position precisely account problem far authors aware systematic denotational analysis object logics carried first author partially supported epsrc grant grr6519001 nuffield foundation grant nal00244a usually phi monotonic recursively defined monotonicity strong condition object specifications yet although successful role model lcf logic computable functions logic functional paradigm outline paper follows firstly denotational semantics functional imperative untyped object calculus 1 given top notion specification inspired abadi leino logic 2 defined resulting object domains prove existence specifications mild assumptions employing andy pitts machinery relational properties domains 10 existence theorem interesting right also applied ffl prove soundness object formation rule 2 untyped way types encoded specifications ffl exemplify via counterexamples certain specification exist suggest extensions existing programming logic 2 8 introducing method invariants logic higher order store moreover proposed technique expected applicable various objectoriented languages programming logics basic ideas date back draft 13 abstract published 14 denotational model object calculus section describe simple denotational semantics functional imperative object calculi within category predom predomains partial continuous functions let denote partial continuous function space predomains fa denote function f applied undefined whereas fa denotes definedness 21 preliminaries specifying recursive types needed interpretation object calculi often employ record type formation following sense let l count able set labels predomain type records entries labels l defined follows l set total functions l easily seen recl locally continuous functor predom record labels l corresponding entries jg notice recl always nonempty contains element h definition 21 update extension operation records defined table 1 page 3 selection label 2 l record r 2 recl short ra defined yielding fa 2 22 functional object calculus let us first recall syntax functional object calculus 1 sake simplicity functional case distinguish field method update f sets method names field names respectively object creation method call method update simplicity methods additional argu ments real restriction arguments encoded fields let bval denote flat predomain basic values like numbers booleans functional object calculus naturally finds interpretation within recursively specified predomain nonempty record types always nonempty choose bval empty get recursive type 2 consider variant object calculus without fields get simple recursive type strongly reminds one callbyvalue lambda calculus given type equation difference essentially object partial continuous function objects objects whole record object o2o message result sending message object given omo understood divergent occur label record makes sense conceive methods partial continuous functions ie strict functions om defined argument defined well sake simplicity paper use last domain equation interpret functional object calculus fits convention calculus distinguish method field update 2 write aae interpretation object expression environment ae 2 var interpretation defined structural recursion object expressions via following clauses 23 imperative object calculus recall syntax imperative untyped object calculus 1 follows distinguish fields methods object creation field selection field update method call method update clonea shallow copy j letxa b local def imperative calculus finds interpretation within following slightly complicated system recursive types loc countable set locations considered predomain notation come handy later sections write st val rec loc rec f val obvious projection val ststval val oe projects first component 2 note distinguish however object logic different table 1 definition record update extension notice definition st rec loc ob faithfully reflects idea state assignment objects finite set locations think modelling states records also employed modelling eg simple imperative languages basic values stored locations besides conceptual adequacy technical advantage modelling rec loc n countable flat predomain whereas traditional choice locn uncountable highly nonflat definition 22 given environment ae 2 object expression interpretation stlocthetast defined table 22 page 4 note write om instead 1 resp reduce syntactic clutter one distinguish methods fields ignores basic values abadi cardelli 1 system mutual recursive type definitions simplifies follows fact fields methods distinguished implies method overriding allowed notice equivalently ob defined single recursive equation obviously obtained recm oo simply replacing locthetarec loc ob right hand side 231 variation la abadi cardelli notice denotational semantics presented quite accordance operational semantics imperative object calculus given book 1 abadi cardelli pp 136137 implies following domain equations method closures saved store meanings object expressions environment ae 2 val var functions type stvalthetast type stlocthetast leave exercise inclined reader give semantic equations object calculus according domain equations interpretation adequate wrt operational semantics 1 3 object specifications identified meaning functional imperative resp object calculus within recursively defined predomain loc theta st position use logic predomains reasoning objects end one might find useful identify special purpose calculus reasoning objects finds meaning translation logic predomains 3 however embarking project rather discuss shape predicates expressing interesting properties objects 31 first notion specification consider functional case first order understand specification object possible definition could following definition 31 let 2 popo monotonic othetao m2m data induce monotonic operator defined po bm stand result specifications tm represent transition specifications method finally specifies remaining properties ob ject ie fields write inva greatest fixpoint phi 3 eg hoare logic provides sort useful macrolanguage reasoning partial functions states fresh location domain oe 0 fresh location domain oe 0 let xa bae table 2 denotational semantics imperative object calculus postfixpoint phi every o2i satisfies predicate whenever omo defined satisfies bm related via tm particular holds greatest fixpoint inva phi given union post fixpoints phi thus order prove one simply exhibit predicate p notion invariant specification seems quite accordance coalgebraic view objectoriented world therefore probably quite use ful however seems limitations exemplified following example example 31 consider object expression j mxxm operational intuition tells us diverges therefore would desirable prove employing appropriate notion invariant comes ones mind immediately invariant false coinduction help proving object since one find predicate p canonical choice p nothing achieved 2 abadi leino introduced sort hoare logic variant imperative object calculus allows one prove divergence quite easily sake simplicity first discuss following adaption account purely functional case 32 functional object specifications notion specification functional objects sug gested existence specifications discussed section 4 definition 32 every 2 po po pom2m every predicate provided unique property call specification induced b different inva since one requires methods m2m condition 8o 0 2s omo 0 hold implicitly recursively specified even b depend example 32 illustrate power new notion employ specification satisfying ie 8o 0 2s omo 0 showing course o2s follows omo thus remains show however easily seen case diverges previous consideration 33 imperative object specifications imperative setting corresponding notion specification obtained analogously functional case yet accounting underlying store different im plementation existence specifications discussed section 4 definition 33 predicates families predicates resp pval theta st m2m st theta val theta st m2m let predicate loc theta st provided unique property predicate loc theta st provided unique property section 4 become clear useful restrict attention transition specifications refer flat part store higherorder part store ie method closures example 33 assume object specification supposed express following invariant field f always positive natural number define accordingly however despite indisputable usefulness problem specifications obvious reason exist right hand side equivalence characterising contains positive negative occurrences speca though 2 specifications used intrinsically existence verified instead validity assertions programs defined wrt derivability correctness assertions renders value soundness theorem 2 somewhat mysterious dubious 4 existence object specifications section identify mild assumptions guarantee existence uniqueness specifications introduced previous section 41 functional object specifications contrast functional 4 imperative kernel languages object calculus implicitly presupposes recursive types like thus appears necessary employ induction principles recursive type involved order verify pro grams recalling fairly concrete terms induction principle use establishing existence specifications fairly mild conditions wellknown work freyd pitts early nineties know bifree solutions domain equation characterised requirement id least fixpoint case f x defined explicitly endofunction oo given equivalently readable form e oo a2o m2m f immediately p id holds admissible predicate poo 8evid p ep ffie fixpoint induction principle used directly verifying properties objects example 41 let mxxm using fixpoint induction one prove consider admissible predicate oo obviously equivalent p id thus fixpoint induction suffices show suppose evid p e ie eomeo p ffie last equality induction hypothesis p e fixpoint induction principle employed proving unique existence specifications rather mild assumptions 4 example pcf based finite type hierarchy base type n simple imperative languages hoare calculus first introduced based rec loc valrec loc val definition 41 flat predomain let l complete lattice scottclosed ie admissible downwardclosed subsets thetaa ordered let flat predomain xy 2 l 10 set obviously nonempty scottclosed subset domain aa following theorem uses line arguments loccit theorem 42 given locally continuous bifunctor pre domains f predomain f predomain monotonic phi l op theta al xy unique 2 l proof let al monotonic satisfy condition mapping al op theta l monotonic endomap complete lattice l op theta thus knastertarski b phi fixpoint establishing show fixpoint induction admissible predicate p ef e e therefore p id id ef e e follows viously p induction step assume p e f f gously follows e f thus thus conclude exists least one 2 showing uniqueness suppose admissible predicate follows p ef e e fixpoint induction obvi ously p assume p e f induction hypothesis p id follows immediately id theorem 43 existence theorem let l denote l 1 f moreover let 2 om2m families id xy 2 l xy 2 l scottclosed exists unique 2 l satisfying proof consider predicate scottclosed due fact bm tm scottclosed see also condition 3 fact precondition implication scottopen clearly theta monotonic obviously requirement equivalent thus show exists unique 2 l guaranteed theorem 42 provided show phi satisfies condition theorem 42 verify next suppose e v id showing f show f e eo 2 phiy first show f e eo2ax 0 f e eo v therefore also f e eo2ax 0 due assumption 1 next let m2m therefore induction hypothesis 2 assumption moreover obtain assumption 3 eomeo 0 v omeo 0 since 3 implies x 0 v x v 0 implies f e eomo 0 42 imperative object specifications recall section 2 imperative object calculus 2 finds denotational interpretation within recursively defined predomain st f st st st latter defined rec loc rec f valthetarec locthetastvalthetast next prove variant theorem 43 imperative object calculus theorem 44 predicates families predi cates resp st theta val theta st m2m ii 2 iii predicate tm scottclosed last argument monotonic second argument exists unique 2 l loc st proof instantiating theorem 42 f st f loc st guarantees existence unique fixpoint phi provided verify phi satisfies condition theorem 42 note phiy x scottclosed due condition iii fact precondition implication scottopen also subsequent use helpful recall f st e eoe oe 2 st f st e b f st e show phi satisfies condition suppose e v id st xx show f st purpose suppose show h f st e eoei 2 phiy 3 get ax oe thus get ie first part conjunction second part suppose b f st e eoem 0 oe 0 know value v2val store oe 00 2st show f st e eom 6 follows eoe 0 thus 4 get 2 thus 3 follows bm xoem ie bm xhv oe 00 6 ii follows therefore 5 follows second part conjunction h oei 2 phiy x ensured 3 7 oem 0 eoe 0 6 5 follows eoe 00 6 eoe 0 fore assumption iii follows ie proves certain conditions specification really exist condition iii theorem 44 awkward prove simplified method specifications refer flat part store corollary 45 given predicates families predi cates resp ii 2 exists unique 2 l loc st proof applying corollary 44 remains show condition iii loccit holds follows simply fact st val flat predomain 5 soundness abadi leino logic de notationally theorem 51 object creation rule abadi leino logic correct wrt semantics proof object specification 2 reads follows field specifications b j result specifications method j j transitions specification j interpret predicates denotationally follows theorem 44 give rise unique predicate definition 33 serves denotational interpretation important abadi leino logic transition specifications j refer flat part store otherwise existence could guaranteed object formation rule loccit says newly created object specifies actual memory allocation absence side effects ignoring side effect issue creation correctness rule semantics follows simply definition 33 specification spec relatively straightforward devise denotational semantics whole logic abadi leino prove correctness calculus wrt denotational semantics proof easier one presented 2 6 possible extensions abadi leino logic dealing object specifications denotationally yield concise explanation abadi leino logic also suggests extensions 61 invariants contrast abadi leino predicates bm may contain recursive occurrences specification self field required fulfill specification ambient object one needs recursion result method required contain object fulfilling specification ambient ob ject one needs recursion bm 8 leino gives variant logic 2 allows recursive object descriptions requires methods declared advance presented approach even allows definition specification may allow bm refer self reference express whole specification invariant setting required method invocation preserve specification self object means specifications spec describe denotationally properties objects certain point program like abadi leino kind invariant seen definition class specification object calculus 62 method update generality presented approach allows one deal method update limited way consider following example example 61 sensible requirement presence method update method altered another method ie method n become less equally defined execution less since dealing partial correctness formally translates following transition predicate definition satisfies condition iii theorem 44 since e v id eoen w oe 0 n transitivity oen w eoen w oe 0 n w eoe 0 n follows forms transition specifications existence theorem applies remains clarified specifications general form need exist demonstrated counterexample next section 7 non existing specifications showing particular object specifications exist prove following auxiliary lemma deals transition specifications may also refer non flat part store ie method closures lemma 71 let locthetastthetalocthetastvalthetast location oe state satisfying proof 0 follows therefore 1 ie oe 2 thus oe oem give example nonexisting object specifica tion exhibit transition specification tm location store oe exist locthetast satisfying specification restrictive assumption theorem 45 tm must refer flat part store ie specifications past future behaviour methods made must necessarily violated also condition iii theorem 44 cannot hold example 72 consider following object specification note admissible let oe h denote property specification reformulated ie condition 0 lemma 71 holds oe one easily verifies 1 holds 2 false contradicting lemma 712 natural counterexamples expected semantic modelling logics object calculi using hoare triples like tentative one suggested 4 conclusions shown denotational approach programming logics object calculi leads better understanding implicit recursion object specifications reasoning principles since notion specification encodes object introduction rule logic soundness rule equivalent existence speci fication guarantee existence one careful reasoning nonflat method part store possible deal similar object calculi logics denotational way analysis languages fruitful quest natural counterexamples comparison classbased languages attempted 15 recursive methods programmed object calculus without explicit recursion due recursive higherorder definition underlying store particular instance recursion store general variant allows unrestricted execution code stored memory rather liberal usage higherorder store needs modelled different domain equations thus needs different treatment altogether results analogous paper expected hard establish paper used classical logic meta logic commit particular object logic spatial separation logic 9 5 prospective candidate object logic simplifies handling aliases remains seen whether predicates logic pose problems presented approach issues tackled include soundness proof abadi leino logic possibly extended invariants reasoning principles higherorder store development logic typed semantics object calculus subtyping including method parameters acknowledgment thanks cristiano calcagno peter ohearn discussions recursion store related matters r theory objects logic objectoriented pro grams proof theory sequential version pool logic objects garbage program logic modular specification verification objectoriented programs recursive object types logic objectoriented programs local reasoning programs alter data structures relational properties domains logical foundations typed objectoriented languages objects classes algollike lan guages logic recursive objects logic recursive objects abstract class based vs object based denotational com parison hoarecalculus verifying java realizations oclconstrained design models tr inheritance smalltalk80 denotational definition two semantic models objectoriented languages reasoning java classes objects classes algollike languages component software theory objects modular specification verification objectoriented programs recursive object types logic objectoriented programs hoare calculus verifying java realizations oclconstrained design models semantics logic object calculi classbased versus objectbased logic objectoriented programs wpcalculus oo garbage program logic logic recursive objects logical foundations typed objectoriented languages local reasoning programs alter data structures introduction specification logic denotational semantics inheritance ctr bernhard reus jan schwinghammer denotational semantics program logic objects mathematical structures computer science v16 n2 p313358 april 2006
spaceefficient planar convex hull algorithms spaceefficient algorithm one output given location input small amount additional memory used algorithm describe four spaceefficient algorithms computing convex hull planar point set b introduction set n distinct points euclidean plane convex hull minimal convex region contains every point denition follows convex hull convex polygon whose vertices points convenience say point p convex hull p vertex convex hull early 1972 graham 13 gave convex hull algorithm log n worstcase running time branching done based results comparisons quadratic polynomials shamos 33 later showed model computation sorting n log n lower bound every convex hull algorithm must require n log n time inputs despite matching upper lower bounds probably many applications convex hulls number planar convex hull algorithms published since grahams algorithm 1 2 4 6 11 17 21 28 particular note ultimate algorithm kirkpatrick seidel 21 computes convex hull set n points plane log h time h number vertices convex hull later result obtained chan using much simpler algorithm 3 authors show algebraic decision trees xed order n log h lower bound computing convex hulls sets n points convex hulls h vertices importance planar convex hulls natural try improve running time storage requirements planar convex hull algorithms paper focus reducing intermediate storage used computation planar convex hulls particular describe inplace situ algorithms computing convex hulls algorithms take input points array research partly funded national science foundation natural sciences engineering research council canada danish natural science research council contract 9801749 project performance engi neering cis polytechnic university six metrotech brooklyn new york 11201 fhbrjiaconogpolyedu z department computing university copenhagen jyrkidikudk x school computer science carleton university 1125 colonel dr ottawa ontario canada k1s 5b6 fmorinmorrisongcscarletonca school computer science mcgill university godfriedcgmcsmcgillca output vertices convex hull clockwise order array execution algorithm additional working storage kept minimum case inplace algorithms extra storage kept o1 situ algorithms allow extra memory size olog n execution algorithm array contains exactly points dierent order convenience refer inplace situ algorithms spaceecient spaceecient algorithms several practical advantages traditional algorithms pri marily spaceecient algorithms allow processing larger data sets algorithm uses separate input output arrays necessity require enough memory store 2n points contrast spaceecient algorithm needs enough memory store n points plus olog n o1 working space related fact spaceecient algorithms usually exhibit greater locality reference makes practical implementation modern computer architectures memory hierarchies nal advantage spaceecient algorithms especially mission critical applications less prone failure since require allocation large amounts memory may available run time describe four spaceecient planar convex hull algorithms rst inplace uses gra hams scan combination inplace sorting algorithm runs log n time second third algorithms run log h time situ based algorithms chan et al 4 kirkpatrick seidel 21 respectively fourth ultimate algorithm based algorithm chan 3 runs log h time inplace rst two algorithms simple implementable ecient practice justify claim implemented algorithms made source code freely available 25 best knowledge paper rst study problem computing convex hulls using spaceecient algorithms seems surprising given close relation planar convex hulls sorting large body literature spaceecient sorting merging algorithms 37 main reason probably scan portion grahams original algorithm 13 inherently inplace inplace sorting algorithms already provide log n time inplace convex hull algorithm remainder paper organized follows sections 2 3 4 four algorithms described section 5 results summarized open problems presented log n time algorithm section present simple inplace implementation grahams convex hull algorithm 13 precisely andrews modication grahams algorithm 1 algorithm requires use inplace sorting algorithm ecient inplace sorting algorithm see eg 19 37 refer algorithm simply inplacesort probably practically relevant algorithm given paper begin describing conceptually simple version algorithm describe slightly involved version improves constants running time 21 basic algorithm let set n 1 points let l line bottommostleftmost point topmostrightmost point upper convex hull convex hull points l lower convex hull convex hull points l wellknown convex hull point set union upper lower convex hulls cf 30 grahams scan computes upper lower hull xmonotone chain incrementally storing partially computed hull stack addition new point involves removing zero points top stack pushing new point onto top stack following pseudocode uses inplacesort algorithm grahams scan compute upper lower hull point set parameter used determine whether upper lower hull computed sorts points increasing order lexicographic x yvalues upper hull computed 1 inplacesort sorts points decreasing order lower hull computed value h corresponds number elements stack following remaining pseudocode array containing input points 1 inplacesorts n 2 h 1 3 4 h 2 right turnsh 2 sh 1 si 5 h h 1 f pop top element stack g 7 8 return h hard verify algorithm returns line 8 elements appear upper lower convex hull stored case upper hull computation 1 hull vertices sorted lefttoright clockwise case lower hull computation 1 hull vertices sorted righttoleft also clockwise compute convex hull point set proceed follows refer fig 1 first make call grahaminplacescan compute vertices upper hull store clockwise order positions follows s0 bottommostleftmost point sh 1 topmostrightmost point use h 1 swaps bring s0 position sh 1 keeping relative ordering finally make call grahaminplacescan compute lower convex hull also lower convex hull stores vertices lower convex hull clockwise order end result convex hull stored clockwise order following pseudocode gives precise description algorithm use c compute upper hull z move b z compute lower hull z output hull figure 1 execution grahaminplacehull algorithm pointer denote starting position array 1 h grahaminplacescans n 1 2 3 swap si 5 return h call grahaminplacescan executes log n time loop lines 23 takes oh time therefore total running time algorithm log n amount extra storage used inplacesort o1 storage used procedures theorem 1 algorithm grahaminplacehull computes convex hull set n points log n time using o1 additional memory algorithm section 4 makes use grahaminplacescan however algorithm requires resulting convex hull stored clockwise order beginning leftmost vertex note output format easily achieved time postprocessing step 22 optimized algorithm constants running time grahaminplacehull improved rst nding extreme points b using points partition array two parts one contains vertices appear upper hull one contains vertices appear lower hull fig 2 gives graphical description way point except b takes part one call grahaminplacescan partition upper hull candidates z lower hull candidates compute upper hull upper hull b z lower hull candidates z move shift upper hull b lower hull candidates z compute lower hull convex hull z output hull figure 2 faster implementation grahaminplacehull reduce constants algorithm one implement inplacesort inplace mergesort algorithm katajainen et al 19 algorithm requires n log comparisons 3n log swaps sort n elements since grahams scan performs 2n rightturn tests computing upper hull n points h points upper hull resulting algorithm performs 3n h rightturn tests extra n comes initial partitioning step call algorithm optgrahaminplacehull theorem 2 optgrahaminplacehull computes convex hull n points log n time using 3n h right turn tests 3n log comparisons o1 additional memory h number vertices convex hull finally note array already sorted lexicographic order lexicographic comparisons necessary one use inplace stable partitioning algorithm partition set upper hull candidates set lower hull candidates preserving sorted order within set exists stable partitioning algorithm runs time performs comparisons 18 context comparison actually right turn test since algorithm stable original sorted order input preserved additional sorting step necessary call resulting algorithm sortedgrahaminplacehull theorem 3 sortedgrahaminplacehull computes convex hull n points given lexicographic order time using right turn tests swaps lexicographic comparisons o1 additional memory nal option inplace implementation grahams sort points radially point p interior convex hull done one call grahaminplace scan compute entire convex hull unfortunately method requires log n right turn tests likely slower methods use right turn tests 3 two log h time insitu algorithms section show compute upper symmetrically lower hull log h time situ h number points upper respectively lower hull discuss two algorithms due kirkpatrick seidel 21 chan snoeyink yap 4 algorithms recursive partition problem two roughly equalsized subproblems use dierent strategies purpose however 31 chan snoeyink yaps algorithm rst show transform log h time algorithm chan et al situ algorithm algorithm begins arbitrarily grouping elements bn2c pairs pairs pair median slope found using linear time mediannding algorithm 1 nd point line p slope points naturally p vertex convex hull let qx denote x coordinate point q let denote index element paired si use p grouping partition elements three groups 0 fig 3 p si p si denotes line segment endpoints b algorithm recursively computes upper hull 0 fpg 1 fpg outputs concatenation two discussion correctness proof algorithm runs log h time see original paper 4 turn problem making situ algorithm choice median slope ensures 0 3n4 1 3n4 algorithm uses olog n levels recursion strategy implement level using o1 local variables one call mediannding routine uses olog n additional memory simplicity assume n odd case n even easily handled processing extra unpaired element paired elements processed pair consecutive elements even linear time mediannding algorithms exist see eg horowitz et al 14 section 36 lai wood 22 used nd pair si si 1 median slope tricky part implementation partitioning sets 0 1 2 diculty lies fact elements grouped pairs two elements pair 1 bhattacharya sen 2 wenger 36 noted mediannding replaced choosing random pair elements expected running time resulting algorithm log h figure 3 partitioning 0 1 2 unprocessed pairs figure 4 paritioning sets 0 1 2 may belong dierent sets j partitioning process pairs lefttoright maintain sets 0 1 2 leftmost part array see fig 4 precisely maintain three indices index last element j way index rst element next unprocessed pair step examine next unprocessed pair classify two points belonging 0 1 2 add appropriate sets adding points sets may shift two locations however required preserve order within set shifting easily done o1 time moving two leftmost elements set fig 5 recaps algorithm computing upper hull first algorithm partitions sets 0 1 2 recurses set 0 recursive call convex hull 0 stored beginning array last element hull point p used partitioning algorithm shifts 1 leftward adjacent p recurses 1 fpg end result upper hull stored consecutively clockwise order beginning array using technique section 2 figures 1 2 upper hull algorithm made convex hull algorithm running time memory requirements theorem 4 algorithm csyinsituhull computes convex hull n points log using olog n additional storage h number vertices convex hull z partition z recurse z compact z recurse z output hull figure 5 overview csyinsituhull algorithm 32 kirkpatrick seidels algorithm previous algorithm solves partitioning problem nding point p convex hull leaves roughly number vertices side kirkpatrick seidels original solution partitioning problem rst nd edge upper hull upper bridge leaves approximately number points side suppose nd edge pq px qx 0 consists points left points right q 2 points pq furthermore js 3n4 algorithm recursively computes upper hulls 0 fpg 1 fqg outputs concatenation two log h total time clearly pq edge convex hull result upper hull proof running time see original paper 21 unlike previous algorithm partitioning inplace 0 1 2 p q known trivial since necessary maintain pairing edges since js olog n levels recursion therefore nd upper bridge linear time inplace algorithm thus performed situ upper bridge problem asks given two sets 0 1 points separated vertical line two endpoints p 2 0 q 2 1 edge pq upper hull problem dual separated 2d linear programming problem phrased given two sets l 0 l 1 lines positive negative slopes respectively compute point smallest ycoordinate lines linear program always feasible solution always intersection pair lines opposite slopes denoting point coordinates x x line equation axby b c duality given x property p l l p moreover p left resp right p positive resp negative slope turn implies solution separated 2d linear programming problem given dual solution upper bridge problem intuition behind original algorithm 21 note duality really computed 2d linear programming problem solved directly points geometric predicates involving points transformed predicates lines via transformation thus answer 2d linear programming inplace also answer upper bridge problem inplace original algorithm rst compute median abscissa x 0 situ partition two roughly equalsized subsets around x 0 enforces jsj 3n4 jsj 3n4 algorithm due seidel 32 solves 2d linear programming problem expected linear time simple assumes order lines random could always enforce shuing set randomly linear time prior linear programming query upon close examination algorithm need reorder input fact works inplace maintaining two indices scan sets lines two indices remember two lines making current optimal solution megiddo 24 gave worstcase lineartime algorithm adapt algorithm run inplace explain lines dual setting megiddos algorithm assumes least 8 lines otherwise brute force method used lines l paired ordered slope within pair inplace implementation li paired li using situ mediannding pair whose point intersection median abscissa x 0 found linear time pairs intersecting left x 0 placed rst half pairs intersecting right x 0 second half take care exchanging two pairs line rst pair exchanged corresponding line second pair next line l 2 l intersects vertical line highest ordinate found recall solution linear programming problem lowest point lines therefore slope l negative solution linear programming problem right x 0 otherwise solution left rst case scan pairs rst half line smallest slope pair rst half discarded since right x 0 always paired line hence cannot dene solution second case line largest slope pair second half discarded discarded lines put end array swapping last yet undiscarded line works second case well pairs second half examined reverse order beginning end moving towards middle array since discarded zone grows twice slowly lines examined pairs choice medians ensure n4 lines discarded case end process left set l 0 d3n4e lines solution original problem dened two lines care must taken include last line 3n4 original number lines odd hence solution linear programming problem l 0 l algorithm run l 0 instead l size l 0 falls 8 point bruteforce method used practice seidels algorithm used certain xed size determined netuning z partition z recurse z compact z recurse z output hull figure overview ksinsituhull algorithm theorem 5 algorithm megiddoinplacelp2d solves separated 2d linear programming problem inplace linear time figure 6 recaps algorithm computing upper hull first algorithm computes median abscissa x 0 upper bridge pq using dual algorithm megiddo inplacelp2d bridge used partition sets 0 1 2 algorithm recurses set 0 recursive call convex hull 0 stored beginning array last element hull rst endpoint p upper bridge algorithm shifts 1 leftward adjacent pq recurses 1 fqg end result upper hull stored consecutively clockwise order beginning array theorem 6 algorithm ksinsituhull computes convex hull log h time using olog n additional storage h number vertices convex hull 4 log h time inplace algorithm next give log h time inplace planar convex hull algorithm algorithm modication chans log time algorithm essentially speedup jarvis march 17 begin review chans algorithm thereafter describe modications needed making inplace chans algorithm runs rounds th round algorithm nds rst points convex hull g h rounds end algorithm detects found points convex hull round algorithm partitions input points ng groups size computes convex hull group vertices convex hull output clockwise order beginning leftmost vertex successive vertex obtained nding tangents previous vertex ng convex hulls next vertex determined jarvis march choosing vertex largest polar angle respect previously found vertex origin case largest polar angle unique ties broken taking farthest vertex previously found vertex finding tangent individual convex hull done olog vertices convex hull stored array clockwise order 5 27 30 ng tangent nding operations per iteration g iterations round therefore round takes log dlog log rounds total cost chans algorithm next show implement round using o1 additional storage assume sake simplicity n multiple g grouping step build ng groups size g taking groups consecutive elements computing convex hulls using grahaminplacehull two questions arise 1 start tangentnding steps put convex hull vertices nd 2 order nd tangent point group olog need know size convex hull group keep track sizes using o1 extra memory answer rst question store convex hull vertices beginning array order nd nd k th vertex convex hull swap sk 1 point convex hull rst group group containing newly found convex hull vertex changed therefore recompute convex hulls cost keep track size convex hull group without storing size explicity use reordering trick let denote elements group g let denote lexicographic comparison x values say sign gj convex hull g contains h vertices follows rst elements signs form sequence 1 followed 0 furthermore elements reordered remainder signs form alternating sequence test point gi convex hull g simply observe three vertices must convex hull g unless collinear case g0 g1 convex hull g test point gi 3 convex hull g examine sequence signs formed gi gi 1 gi 2 gi 3 sequence contain two consecutive two consecutive simple case analysis convince reader gi convex hull g otherwise least one gi gi 1 gi 2 gi 3 convex hull g determine vertices last vertex perform tests form right turngj gj1 g0 fig 7 rst value test returns false index j nal element convex hull g test returns false convex hull g provided tools inplace implementation chans algorithm except cost recomputing convex hulls groups modifying running time implementation asymptotically original algorithm therefore need figure 7 rst vertex fail right turn test last vertex convex hull g bound extra cost one step round nd one convex hull vertex recompute convex hull two groups cost recomputing convex hulls og log g steps round therefore total cost recomputing convex hull vertices round og log log n 12 hence total cost round log log n 12 since abort algorithm log n 12 use grahaminplacehull overall running time algorithm log h theorem 7 algorithm chaninplacehull computes convex hull n points log using o1 additional storage h number vertices convex hull constants chaninplacehull improved using following trick mentioned chan 3 round terminates without nding entire convex hull g convex hull points computed discarded instead grouping round done remaining n g points thus eliminating need recompute rst vertices optimization works perfectly applied chaninplacehull since rst points already stored locations conclusions given four spaceecient algorithms computing convex hull planar point set rst algorithm inplace runs log n time second third algorithms situ run log h time fourth algorithm inplace runs log h time rst two algorithms reasonably simple implementable running times compare favourably convex hull algorithms use additional storage order facilitate comparisons convex hull implementations source code available download 25 although assumed throughout paper input points distinct algorithms paper modied handle case input multiset modications technical relatively straightforward particular care must taken respect side line tests size encoding scheme used section 4 needs make use third symbol 0 used consecutive identical elements ideas presented paper also apply problems maximal elements problem determining elements si sjx six sjy siy 0 j n algorithm almost identical grahams scan used solve maximal elements problems log n time easily implemented inplace furthermore inplace algorithm almost identical section 4 used solve maximal elements problem log h time h number maximal elements question situ inplace algorithms maximal elements convex hulls dimensions 3 still open order question make sense ask algorithm identify input points maximal convex hull testing whether given point maximal done odn time using denition maximality testing whether single point convex hull 1 dimensional linear programming problem solved inplace odn expected time using seidels algorithm 32 thus maximal elements problem solved time convex hull problem solved odn 2 using inplace algorithms algorithms reduced dependence n generally one might ask computational geometry problems admit space ecient algorithms problems immediately come mind computing kpiercings sets nding maximum cliques intersection graphs computing largest empty disks nding hamsandwich cuts acknowledgements authors grateful anonymous referee making observation algorithm section 31 allowed us greatly simplify partitioning step algorithmxs r another ecient algorithm convex hulls two dimensions simple optimal outputsensitive convex hull algorithms two three dimensions primal dividing dual pruning outputsensitive construction fourdimensional polytopes threedimensional voronoi diagrams intersection convex objects 2 3 dimensions applications random sampling computational geometry smoothsort alternative sorting situ introduction three algorithms sorting situ new convex hull algorithm planar sets algorithm 245 computer algorithms practical inplace merging fast stable merging sorting constant extra space identi stable minimum space partitioning linear time practical inplace mergesort ultimate planar convex hull algorithm implicit selection simple lineartime algorithm situ merging linear programming linear time dimension available online httpwww stable situ sorting minimum data movement maintenance con optimal real time algorithm planar convex hulls convex hulls computational geometry computational geometry sorting random access optimal stable merging randomized quick hull algorithm 232 tr simple lineartime algorithm situ merging sorting random access file situ computational geometry introduction ultimate planar convex hull algorithm intersection convex objects two three dimensions stable linear time sublinear space merging simplified stable merging tasks practical inplace merging unstable linear time 1 space merging implicit selection applications random sampling computational geometry ii stable italicin situ sorting minimum data movement smalldimensional linear programming convex hulls made easy stable minimum space partitioning linear time simple practical optimal outputsensitive randomized planar convex hull algorithm linear programming linear time dimension fixed inplace sorting fewer moves new convex hull algorithm planar sets optimal realtime algorithm planar convex hulls convex hulls finite sets points two three dimensions algorithm 245 treesort computer algorithms discipline programming practical inplace mergesort computational geometry ctr herv brnnimann timothy chan spaceefficient algorithms computing convex hull simple polygonal line linear time computational geometry theory applications v34 n2 p7582 may 2006 jan vahrenhold inplace algorithm klees measure problem two dimensions information processing letters v102 n4 p169174 may 2007 nikolay sirakov new active convex hull model image regions journal mathematical imaging vision v26 n3 p309325 december 2006
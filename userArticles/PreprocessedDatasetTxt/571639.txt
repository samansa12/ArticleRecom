neural methods dynamic branch prediction article presents new highly accurate method branch prediction key idea use one simplest possible neural methods perceptron alternative commonly used twobit counters source predictors accuracy ability use long history lengths hardware resources method scale linearly rather exponentially history length describe two versions perceptron predictors evaluate predictors respect five wellknown predictors show 4 kb hardware budget simple version method uses global history achieves misprediction rate 46percnt spec 2000 integer benchmarks improvement 26percnt gshare also introduce globallocal version predictor 14percnt accurate mcfarlingstyle hybrid predictor alpha 21264 show hardware budgets 256 kb globallocal perceptron predictor accurate evers multicomponent predictor conclude accurate dynamic predictor currently available explore feasibility ideas provide circuitlevel design perceptron predictor describe techniques allow complex predictor operate quickly finally show relatively complex perceptron predictor used modern cpus override simpler quicker smith predictor providing ipc improvements 158percnt gshare 57percnt mcfarling hybrid predictor b figure 1 perceptron model input values propagated weighted connections taking respective products weights products summed along bias weight produce output value 41 perceptrons work perceptron introduced 1962 24 way study brain function consider simplest many types perceptrons 2 singlelayer perceptron consisting one articial neuron connecting several input units weighted edges one output unit perceptron learns target boolean function inputs case bits global branch history shift register target function predicts whether particular branch taken intuitively perceptron keeps track positive negative correlations branch outcomes global history branch predicted figure 1 shows graphical model perceptron perceptron represented vector whose elements weights purposes weights signed integers output dot product weights vector input vector always set 1 providing bias input output perceptron computed inputs perceptrons bipolar ie either 1 meaning taken 1 meaning taken negative output interpreted predict taken nonnegative output interpreted predict taken 42 training perceptrons perceptron output computed following algorithm used train perceptron let 1 branch taken 1 taken let threshold parameter training algorithm used decide enough training done sign 0 end since always either 1 1 algorithm increments th weight branch outcome agrees decrements weight disagrees intuitively mostly agreement ie positive correlation weight becomes large mostly disagreement ie negative correlation weight becomes negative large magnitude cases weight large inuence prediction weak correlation weight remains close 0 contributes little output perceptron 43 linear separability limitation perceptrons capable learning linearly separable functions 11 imagine set possible inputs perceptron dimensional space solution equation hyperplane eg line dividing space set inputs perceptron respond false set perceptron respond true 11 boolean function variables linearly separable exist values true instances separated false instances hyperplane since output perceptron decided equation linearly separable functions learned perfectly perceptrons instance perceptron learn logical two inputs exclusiveor since line separating true instances exclusiveor function false ones boolean plane show later many functions describing behavior branches programs linearly separable also since allow perceptron learn time adapt nonlinearity introduced phase transitions program behavior perceptron still give good predictions learning linearly inseparable function achieve 100 accuracy contrast twolevel pht schemes like gshare learn boolean function given enough training time 44 branch prediction perceptrons use perceptron learn correlations particular branch outcomes global history behavior current branch correlations represented weights larger weight stronger correlation particular branch global history contributes prediction current branch input bias weight always 1 instead learning correlation previous branch outcome bias weight learns bias branch independent history processor keeps table perceptrons fast sram similar table twobit counters branch prediction schemes number perceptrons dictated hardware budget number weights determined amount branch history keep special circuitry computes value performs training discuss circuitry section 5 processor encounters branch fetch stage following steps conceptually taken 1 branch address hashed produce index table perceptrons 2 th perceptron fetched table vector register weights 3 value computed dot product global history register 4 branch predicted taken negative taken otherwise 5 actual outcome branch becomes known training algorithm uses outcome value update weights 6 written back th entry table may appear prediction slow many computations sram transactions take place steps 1 5 however section 5 shows number arithmetic microarchitectural tricks enable prediction single cycle even long history lengths 5 implementation section explores design space perceptron predictors discusses details circuitlevel implementation 51 design space given xed hardware budget three parameters need tuned achieve best performance history length number bits used represent weights threshold history length long history lengths yield accurate predictions 9 also reduce number table entries thereby increasing aliasing experiments best history lengths ranged 4 66 depending hardware budget perceptron predictor use one kind history used purely global history well combination global perbranch history representation weights weights perceptron predictor signed integers although many neural networks oatingpoint weights found integers sufcient percep trons simplify design nd using 8 bit weights provides best tradeoff accuracy hardware budget threshold threshold parameter perceptron training algorithm used decide whether predictor needs training 52 circuitlevel implementation discuss general techniques allow us implement quick perceptron predictor give detailed results transistorlevel simulation computing perceptron output critical path making branch prediction includes computation perceptron output thus circuit evaluates perceptron fast possible several properties problem allow us make fast prediction since 1 1 possible input values perceptron multiplication needed compute dot product instead simply add input bit 1 subtract add twoscomplement input bit 1 practice found adding onescomplement good estimate twoscomplement works well lets us avoid delay small carrypropagate adder computation similar performed multiplication circuits must nd sum partial products function integer single bit furthermore sign bit result needed make prediction bits output computed slowly without wait prediction paper report results simulate complementation idea training training algorithm section 42 implemented efciently hardware since dependences loop iterations iterations execute parallel since case 1 1 loop body restated increment 1 decrement otherwise quick arithmetic operation since 8bit numbers bit parallel else circuitlevel simulation using custom logic design program hspice cacti 20 simulators designed simulated hardware implementation elements critical path perceptron predictor several table sizes history lengths used cacti cache modeling tool estimate amount time taken read table perceptrons used hspice measure latency perceptron output circuit perceptron output circuit accepts input signals weights array history register weights read bitwise exclusiveored corresponding bits history register th history bit set operation effect taking onescomplement th weight otherwise weight passed unchanged weights processed sum found using wallacetree 3to2 carrysave adders 5 reduces problem nding sum numbers problem nding sum numbers nal two numbers summed carrylookahead adder wallacetree depth carrylookahead adder depth computation relatively quick sign sum inverted taken prediction table 1 shows delay perceptron predictor several hardware budgets history lengths simulated hspice cacti 180nm process technology obtain delay estimates selecting inputs designed elicit worstcase gate delay measure time takes one input signals cross half time perceptron predictor yields steady usable signal 4kb hardware budget history length 24 total time taken perceptron prediction 24 nanoseconds works slightly less 2 clock cycles cpu clock rate 833 mhz clock rate fastest 180 nm alpha 21264 processor writing alpha 21264 branch predictor takes 2 clock cycles deliver prediction predictor within bounds existing technology note perceptron predictor history 23 instead 24 takes 22 nanoseconds 10 faster predictor 24 weights 23 history plus 1 bias organized efciently predictor 25 weights reasons specic wallacetree design history table size perceptron table total clock cycles length bytes delay ps delay ps delay ps 833 mhz 176 ghz 9 512 725 432 1157 10 20 43 table 1 perceptron predictor delay table shows simulated delay perceptron predictor several table sizes history length congurations delay computing output fetching perceptron table shown separately well total compensating delay ideally branch predictor operates single processor clock cycle jimenez et al study number techniques reducing impact delay branch predictors 16 example cascading perceptron predictor would use simple predictor anticipate address next branch fetched would use perceptron begin predicting anticipated address branch arrive perceptron predictor nished anticipated branch address found incorrect small gshare table would consulted quick prediction study shows similar predictor using two gshare tables able use larger table 47 time overriding perceptron predictor would use quick gshare predictor get immediate prediction starting perceptron prediction time gshare prediction acted upon fetch engine perceptron prediction completes predictions compared differ actions taken fetch engine rolled back restarted new prediction incurring small penalty alpha 21264 uses kind branch predictor slower hybrid branch predictor overriding less accurate faster line predictor 18 line prediction overridden alpha predictor incurs singlecycle penalty small compared 7cycle penalty branch misprediction pipelining perceptron predictor using hierarchical techniques mentioned perceptron predictor used successfully future microprocessors overriding strategy seems particularly appropriate since pipelines continue become deeper cost overriding less accurate predictor decreases percentage cost full misprediction present detailed analysis overriding scheme section 64 6 results analysis evaluate perceptron predictor use simulation compare wellknown techniques literature rst compare accuracy two versions perceptron predictor 5 predictors evaluate performance using ipc metric comparing overriding perceptron predictor overriding mcfarlingstyle predictor two different clock rates finally present analysis explain perceptron predictor performs well 61 methodology describe experimental methodology discuss predictors simulated benchmarks used tuning predictors issues predictors simulated compare new predictor gshare 22 bimode 20 combination gshare pag mcfarlingstyle hybrid predictor 22 similar alpha 21264 tables scaled exponentially increasing hardware budgets perceptron predictor simulate purely global predictor well predictor uses global local history globallocal predictor takes input perceptron global history register input set perbranch histories globallocal perceptron predictor extra state used table local histories constrained within 35 hardware budget rest predictor reecting design alpha 21264 hybrid predictor gshare perceptron predictors also simulate agree mechanism 28 predicts whether branch outcome agree bias bit set branch instruction agree mechanism turns destructive aliasing constructive aliasing increasing accuracy small hardware budgets methodology differs previous work perceptron predictor 17 used traces x86 executables spec2000 explored global versions perceptron predictor nd perceptron predictor achieves larger improvement predictors alpha instruction set x86 instruction set believe difference stems alphas risc instruction set requires dynamic branches accomplish work thus requires longer histories accurate prediction perceptron predictor make use longer histories predictors performs better risc instruction sets gathering traces use simplescalaralpha 3 gather traces time simulator executes conditional branch records branch address outcome trace le branches libraries proled traces fed program simulates different branch prediction techniques benchmarks simulated use 12 spec 2000 integer benchmarks allow benchmark execute 300 million branches causes benchmark execute least one billion instructions skip past rst 50 million branches trace measure steady state prediction accuracy without effects benchmarks initializations tuning predictors use spec train inputs reporting misprediction rates test predictors ref inputs tuning predictors tune predictor history length using traces gathered 12 benchmarks train inputs exhaustively test every possible history length hardware budget predictor keeping history length yielding lowest harmonic mean misprediction rate globallocal perceptron predictor exhaustively test pair history lengths sum global local history length 50 agree mechanism set bias bits branch instructions using branch biases learned train inputs global perceptron predictor nd history length best value threshold using intelligent search space values pruning areas space give poor performance reuse thresholds globallocal agree perceptron predictors table 2 shows results history length tuning nd interesting relationship history length threshold best threshold given history length always exactly adding another weight perceptron increases average output constant threshold must increased constant yielding linear relationship history length threshold experimentation determine using 8 bits perceptron weights yields best results 62 impact history length accuracy one strengths perceptron predictor ability consider much longer history lengths traditional twolevel schemes helps highly correlated branches occur large distance 9 global branch prediction technique uses xed amount history information optimal history length given set benchmarks see table 2 perceptron predictor works best much longer histories two predictors example 4k byte hardware budget gshare works best history length 14 maximum possible length gshare hardware budget global perceptron predictor works best history length 24 hardware gshare global perceptron globallocal perceptron budget history number history number globallocal number bytes length entries length entries history entries table 2 best history lengths table shows best amount global history keep gshare two versions perceptron predictor well number table entries predictorpercent mispredicted gshare gshare agree bimode globallocal hybrid global perceptron globallocal perceptron globallocal perceptron agree0 hardware budget bytes figure 2 hardware budget vs prediction rate spec 2000 graph shows mispredictionrates various predictors function hardware budget 63 misprediction rates figure 2 shows harmonic mean misprediction rates achieved increasing hardware budgets spec 2000 benchmarks 4k byte hardware budget global perceptron predictor misprediction rate 194 improvement 53 gshare 413 31 6k byte bimode 282 global local history information used perceptron predictor still superior accuracy globallocal hybrid predictor conguration alpha 21264 predictor using 3712 bytes misprediction rate 267 globallocal perceptron predictor 3315 bytes state misprediction rate 171 representing 36 decrease misprediction rate alpha hybrid agree mechanism improves accuracy especially small hardware budgets small budget 750 bytes globallocal perceptron predictor achieves misprediction rate 289 less misprediction rate gshare predictor 11 times hardware budget less misprediction rate gshareagree predictor 2k byte budget figure 3 show misprediction rates two phtbased methods two perceptron predictors spec 2000 benchmarks hardware budgets 4k 16k bytesgshare 4kb bimode 3kb global perceptron 4kb globallocal perceptron 33kb percent mispredicted514 z r7g c c r c f sr e e r la pr er z pxi0o e r l f c benchmarkgshare 16kb bimode 12kb global perceptron 16kb globallocal perceptron 13kb percent mispredicted514 z r7g c c r c f sr e r l r oer xb z e r l f c benchmark figure 3 misprediction rates individual benchmarks charts show misprediction rates global perceptron gshare bimode predictors hardware budgets 4 kb 16 kb 631 large hardware budgets moores law continues provide transistors area makes sense explore much larger hardware budgets branch predictors evers thesis 10 explores design space multicomponent hybrid predictors using large hardware budgets kb 368 kb knowledge multicomponent predictors presented evers thesis accurate fully dynamic branch predictors known previous work predictor uses mcfarlingstyle chooser choose two mcfarlingstyle hybrid predictors rst hybrid component joins gshare short history gshare long history hybrid component consists pas hybridized loop predictor capable recognizing regular looping behavior even loops long trip counts simulate evers multicomponent predictors using conguration parameters given thesis set hardware budgets simulate globallocal version perceptron predictor tuning large perceptron predictor exhaustive smaller hardware budgets due huge design space tune best global history length spec train inputs best fraction global versus local history single hardware budget extrapolating fraction entire set hardware budgets previous globallocal perceptron experiments allocate 35 hardware budgets storing table local histories conguration perceptron predictor given table 3 size global local number number history history perceptrons local histories 53 50 table 3 congurations large budget perceptron predictors figure 4 shows harmonic mean misprediction rates evers multicomponent predictor globallocal perceptron predictor spec 2000 integer benchmarks perceptron predictor outperforms multicomponent predictor every hardware budget misprediction rates getting closer one another hardware budget increased predictors capable reaching amazingly low misprediction rates 368 kb hardware budget perceptron 085 multicomponent predictor 093 claim results evidence perceptron predictor accurate fully dynamic branch predictor known must point exhaustively tuned either multicomponent perceptron predictors huge computational challenge nevertheless clear separation misprediction rates multicomponent perceptron predictors perceptron predictors examined lower hardware budgets thus condent claim veried independent researchers 64 ipc seen perceptron predictor highly accurate multicycle delay associated delay large overall performance may suffer processor stalls waiting predictions percent mispredicted multicomponent hybrid globallocal perceptron0 hardware budget bytes figure 4 hardware budget vs misprediction rate large predictors evaluate perceptron predictor terms overall processor performance measured ipc taking account predictor access delay particular compare overriding perceptron predictor overriding hybrid predictor alpha 21264 consider two processor congurations one conguration uses moderate clock rate matches latest alpha processor approximates aggressive clock rate deeper pipeline intel pentium 4 remainder section describes congurations overriding perceptron predictor two clock rates reports simulated ipc spec 2000 benchmark 641 moderate clock rate simulations currently fastest alpha processor 180 nm technology clocked rate 833 mhz clock rate perceptron predictor alpha hybrid predictor deliver prediction two clock cycles using simplescalaralpha simulate twolevel overriding predictors 833 mhz rst level 256entry smith predictor 27 ie simple onelevel table twobit saturating counters indexed branch address predictor roughly simulates line predictor overriding alpha predictor smith predictor achieves harmonic mean accuracy 852 accuracy quoted alpha line predictor 18 second level predictor simulate perceptron predictor alpha hybrid predictor perceptron predictor consists 133 perceptrons 24 weights although 25 weight perceptron predictor best choice hardware budget simulations 24 weight version much accuracy 10 faster observed ideal ratio perbranch history bits total history bits roughly 20 use 19 bits global history 4 bits perbranch history table 1024 histories total state required predictor 3704 bytes approximately alpha hybrid predictor uses 3712 bytes alpha hybrid predictor perceptron predictor incur singlecycle penalty override smith predictor also simulate 2048entry nonoverriding gshare predictor reference gshare uses less state since operates single cycle note amount state allocated branch predictor hpparisc 8500 21 uses clock rate similar alpha simulate 12 spec int 2000 benchmarks time allowing benchmark execute 2 billion instructions simulate 7cycle misprediction penalty alpha 21264 branch encountered four possibilities overriding predictor rst second level predictions agree correct case penalty rst second level predictions disagree second one correct case second predictor overrides rst small penalty rst second level predictions disagree second one incorrect case penalty equal overriding penalty previous case well penalty full misprediction fortunately second predictor accurate rst case unlikely occur rst second level predictor agree incorrect case overriding prediction wrong full misprediction penalty incurred figure 5 shows instructions per cycle ipc predictors even though penalty overriding alpha perceptron predictors override smith predictor increased accuracies compensate effect achieving higher ipcs singlecycle gshare perceptron predictor yields harmonic mean ipc 165 higher overriding predictor 159 higher gshare 153 642 aggressive clock rate simulations current trend microarchitecture deeply pipeline microprocessors sacricing ipc ability use much higher clock rates instance intel pentium 4 uses 20stage integer pipeline clock rate 176 ghz situation one might expect perceptron predictor yield poor performance since requires much time make prediction relative short clock period nevertheless show perceptron predictor improve performance even previous case benets low misprediction rates greater 176 ghz clock rate perceptron predictor described would take four clock cycles one read table perceptrons three propagate signals compute perceptron output pipelining perceptron predictor allow us get one prediction cycle branches come close together dont wait predictor nished predicting previous branch wallacetree perceptron 7 levels small cost latch delay pipeline wallacetree four stages one read perceptron table another rst three levels tree another second three levels fourth nal level carrylookahead adder root tree new perceptron predictor operates follows 1 branch encountered immediately predicted small smith predictor execution continues along predicted path 2 simultaneously local history table perceptron tables accessed using branch address index 3 circuit computes perceptron output takes input global local history registers perceptron weights 4 four cycles initial prediction perceptron prediction available differs initial prediction instructions executed since prediction squashed execution continues along path 5 branch executes corresponding perceptron quickly trained stored back table perceptrons figure 6 shows result simulating predictors microarchitecture characteristics pentium 4 misprediction penalty 20 simulates long pipeline pentium 4 alpha overriding hybrid predictor conservatively scaled take 3 clock cycles overriding perceptron predictor takes 4 clock cycles 2048entry gshare predictor unmodied even though perceptron predictor takes longer make prediction still yields highest ipc benchmarks superior accuracy perceptron predictor yields ipc 148 57 higher hybrid predictor 1401cycle gshare alphalike 2cycle overriding predictor perceptron 2cycle overriding predictor instructions per cycle06g z r7g c c r c f sr e e r la pr er z pxi0o e r l f c benchmark figure 5 ipc overriding perceptron hybrid predictors chart shows ipcs yielded gshare alphalike hybrid globallocal perceptron predictor given 7cycle misprediction penalty hybrid perceptron predictors 2cycle latency used overriding predictors small smith predictor 65 training times compare training speeds perceptron predictor pht methods examine rst 100 times branch spec 2000 benchmarks executed branches executing least 100 times figure 7 shows average accuracy 100 predictions static branches 4kb hardware budget average weighted relative frequencies branch perceptron method learns quickly gshare bimode perceptron predictor training time independent history length techniques gshare index table counters training time depends amount history considered longer history may lead larger working set twobit counters must initialized predictor rst learning branch effect negative impact prediction rates certain point longer histories begin hurt performance schemes 23 see next section perceptron prediction weakness always better longer history length 1cycle gshare alphalike 3cycle overriding predictor perceptron 4cycle overriding predictor instructions per cycle06g z r7g c c r c f sr e e r la pr er z pxi0o e r l f c benchmark figure ipc overridingperceptron hybridpredictors long pipelines chart shows ipcs yields gshare hybrid predictor globallocal perceptron predictor large misprediction penalty high clock rate 66 advantages perceptron predictor hypothesize main advantage perceptron predictor ability make use longer history lengths schemes like gshare use history register index table require space exponential history length perceptron predictor requires space linear history length provide experimental support hypothesis simulate gshare perceptron predictor 64k hardware budget perceptron predictor normally outperforms gshare however allowing perceptron predictor use many history bits gshare 18 bits nd gshare performs better misprediction rate 186 compared 196 perceptron predictor inferior performance crippled predictor two likely causes destructive aliasing perceptrons larger thus fewer gshares twobit counters perceptrons capable learning linearly separable functions input gshare potentially learn boolean function figure 8 shows result simulating gshare perceptron predictor varying history lengths spec 2000 benchmarks use 4m byte hardware budget used allow gshare consider longer history lengths usual allow predictor consider longer histories becomes accurate gshare becomes worse runs bits since gshare requires resources exponential number history bits perceptron predictor continues improve unrealistically huge hardware budget gshare performs best history length 23 achieves misprediction rate 155 perceptron predictor best history length 66 achieves misprediction rate 109 67 impact linearly inseparable branches section 43 pointed fundamental limitation perceptrons perform ofine training cannot learn linearly inseparable functions explore impact limitation branch prediction relate linear separability branch prediction dene notion linearly separable branches percent mispredictedgshare bimode number times branch executed figure 7 average training times spec 2000 benchmarks axis number times branch executed axis average branches program 1 branch mispredicted otherwise time statistic tracks quickly predictor learns perceptron predictor achieves greater accuracy earlier two methods let recent bits global branch history static branch exists boolean function best predicts behavior function branch predictors strive learn linearly separable say branch linearly separable branch otherwise linearly inseparable branch theoretically ofine perceptrons cannot predict linearly inseparable branches complete accuracy phtbased predictors limitation given enough training time gshare predict linearly inseparable functions better perceptron predictor answer question compute static branch benchmark suite test whether functions linearly separable figure 9 shows misprediction rates benchmark 4k budget well percentage dynamically executed branches linearly inseparable benchmark bar left shows misprediction rate gshare bar right shows misprediction rate global perceptron predictor bar also shows using shading portion mispredictions due linearly inseparable branches linearly separable branches observe two interesting features chart first mispredicted branches linearly inseparable linear inseparability correlates highly unpredictability general second difcult determine whether perceptron predictor performs worse gshare linearly inseparable branches see perceptron predictor outperforms gshare cases except 186crafty benchmark highest fraction linearly inseparable branches branches require longer histories others accurate prediction perceptron predictor often advantage branches figure 10 shows relationship advantage required history length one curve linearly separable branches one inseparable branches axis represents advantage predictor computed subtracting misprediction rate perceptron predictor gshare sorted static branches according best history global perceptron gshare percent mispredicted0 history length figure 8 history length vs performance graph shows accuracy gshare perceptronpredictor improves history length increased perceptron predictor able consider much longer histories hardware budget length represented axis data point represents average misprediction rate static branches without regard execution frequency given best history length use perceptron predictor methodology nding best lengths using perceptron trained branch nd distant three weights greatest magnitude methodology motivated work evers et al show branches predicted looking three previous branches 9 best history length increases advantage perceptron predictor generally increases well also see predictor accurate linearly separable branches linearly inseparable branches predictor performs generally better branches require long histories gshare sometimes performs better branches require short histories linearly inseparable branches requiring longer histories well linearly separable branches always predicted better perceptron predictor linearly inseparable branches requiring fewer bits history predicted better gshare thus longer history required better performance perceptron predictor even linearly inseparable branches found history length nding distant three weights greatest magnitude perceptron trained branch application perceptron predictor analyzing branch behavior 68 additional advantages perceptron predictor assigning condence decisions predictor provide condencelevel predictions useful guiding hardware speculation output perceptron predictor boolean value number interpret taken value provides important information branch since distance 0 proportional certainty branch taken 15 condence used example allow microarchitecture speculatively execute branch paths condence low execute predicted path condence high branch prediction schemes explicitly compute condence predictions 14 predictor information comes free observed experimentally probability mispredictions mispredictions percent2016 c r sr r6g z p7g c c0t r e r lo e c z r e x benchmark figure 9 linear separability vs accuracy 4kb budget benchmark leftmost bar shows number linearly separable dynamic branches benchmark middle bar shows misprediction rate gshare 4kb hardware budget right bar shows misprediction rate perceptron predictor hardware budget branch taken accurately estimated linear function output perceptron predictor analyzing branch behavior perceptrons perceptrons used analyze correlations among branches perceptron predictor assigns bit branch history weight particular bit strongly correlated particular branch outcome magnitude weight higher less correlation thus perceptron predictor learns recognize bits history particular branch important prediction learns ignore unimportant bits property perceptron predictor used proling provide feedback branch prediction schemes example methodology use section 67 could used proler provide path length information variable length path predictor 29 conclusions paper introduced new branch predictor uses neural learning techniquesthe perceptron particularas basic prediction mechanism perceptrons attractive use long history lengths without requiring exponential resources potential weakness perceptrons increased computational complexity compared twobit counters shown perceptron predictor implemented efciently respect area delay particular believe feasible implementation overriding perceptron predictor uses simpler smith predictor provide quick prediction may later overridden spec 2000 integer benchmarks overriding predictor results 36 fewer mispredictions mcfarlingstyle hybrid predictor another weakness perceptrons inability learn linearly inseparable functions shown limitation existing branch predictors well gshare mispredicted perceptron mispredicted linearly inseparable branches linearly separable branches0 best history length figure 10 classifying advantage perceptron predictor data point average difference misprediction rates perceptron predictor gshare axis length branches axis axis perceptron predictor better average axis gshare better average linearly separable branches predictor average accurate gshare inseparable branches predictor sometimes less accurate branches require short histories accurate average branches require long histories shown benet considering history lengths longer previously consid ered variable length path branch prediction considers history lengths 23 29 study effects long branch histories branch prediction considers lengths 32 9 found additional performance gains found branch history lengths 66 also shown perceptron predictor accurate pht techniques provide general mechanism scale well history length predictor instead performs particularly well two classes branchesthose linearly separable require long history lengths represent large number dynamic branches perceptrons interesting characteristics open new avenues future work noted section 68 perceptrons also used guide speculation based branch prediction condence levels perceptron predictors used recognizing important bits history particular branch acknowledgments thank steve keckler kathryn mckinley many stimulating discussions topic thank steve kathryn ibrahim hur comments earlier versions paper research supported part darpa contract f306029710150 us air force research laboratory nsf careers grant aci9984660 onr grant n000149910402 r improving branch prediction understanding branch behavior fundamentals neural networks architectures neuroevolution method dynamic resource allocation chip multiprocessor computerarchitecture aquantitativeapproach assigning condence conditional branch predictions dynamically weighted ensemble neural networks classication impact delay design branch predic tors dynamic branch prediction perceptrons alpha 21264 microprocessor articial neural networks image understanding combining branch predictors trading conict capacity aliasing conditional branch predictors principles neurodynamics perceptrons theory brain mechanisms correlationandaliasing dynamicbranchpredictors understanding neural networks via rule extraction study branch prediction strategies agree predictor mechanismforreducingnegative branch history interference variable length path branch prediction highly accurate data value prediction using hybrid predictors tr introduction algorithms twolevel adaptive training branch prediction branch prediction free fundamentals neural networks correlation aliasing dynamic branch predictors evidencebased static branch prediction using machine learning assigning confidence conditional branch predictions agree predictor trading conflict capacity aliasing conditional branch predictors language describing predictors application automatic synthesis bimode branch predictor highly accurate data value prediction using hybrid predictors analysis correlation predictability computer architecture 2nd ed yags branch prediction scheme variable length path branch prediction impact delay design branch predictors artificial neural networks image understanding alpha 21264 microprocessor study branch prediction strategies dynamic branch prediction perceptrons improving branch prediction understanding branch behavior ctr veerle desmet hans vandierendonck koen de bosschere clustered indexing branch predictors microprocessors microsystems v31 n3 p168177 may 2007 kaveh aasaraai amirali baniasadi ehsan atoofian computational storage power optimizations ogehl branch predictor proceedings 4th international conference computing frontiers may 0709 2007 ischia italy andre seznec analysis ogeometric history length branch predictor acm sigarch computer architecture news v33 n2 p394405 may 2005 kreahling stephen hines david whalley gary tyson reducing cost conditional transfers control using comparison specifications acm sigplan notices v41 n7 july 2006 abhas kumar nisheet jain mainak chaudhuri longlatency branches much matter acm sigarch computer architecture news v34 n3 p915 june 2006 david tarjan kevin skadron merging path gshare indexing perceptron branch prediction acm transactions architecture code optimization taco v2 n3 p280300 september 2005 daniel jimnez fast pathbased neural branch prediction proceedings 36th annual ieeeacm international symposium microarchitecture p243 december 0305 daniel jimenez piecewise linear branch prediction acm sigarch computer architecture news v33 n2 p382393 may 2005 daniel jimnez improved latency accuracy neural branch prediction acm transactions computer systems tocs v23 n2 p197218 may 2005 ayose falcon jared stark alex ramirez konrad lai mateo valero better branch prediction prophetcritic hybrids ieee micro v25 n1 p8089 january 2005 ayose falcon jared stark alex ramirez konrad lai mateo valero prophetcritic hybrid branch prediction acm sigarch computer architecture news v32 n2 p250 march 2004 veerle desmet lieven eeckhout koen de bosschere improved composite confidence mechanisms perceptron branch predictor journal systems architecture euromicro journal v52 n3 p143151 march 2006 alan fern robert givan babak falsafi n vijaykumar dynamic feature selection hardware prediction journal systems architecture euromicro journal v52 n4 p213234 april 2006 javier verd jorge garc mario nemirovsky mateo valero architectural impact stateful networking applications proceedings 2005 symposium architecture networking communications systems october 2628 2005 princeton nj usa